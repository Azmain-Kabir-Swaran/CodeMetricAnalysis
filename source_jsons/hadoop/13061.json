{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockPlacementPolicyWithNodeGroup.java",
  "functionName": "pickupReplicaSet",
  "functionId": "pickupReplicaSet___first-Collection__DatanodeStorageInfo____second-Collection__DatanodeStorageInfo____rackMap-Map__String,List__DatanodeStorageInfo____",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyWithNodeGroup.java",
  "functionStartLine": 338,
  "functionEndLine": 376,
  "numCommitsSeen": 54,
  "timeTaken": 2983,
  "changeHistory": [
    "0e54b164a8d8acf09aca8712116bf7a554cb4846",
    "ec414600ede8e305c584818565b50e055ea5d2b5",
    "08466eaa0045658fa7919a634e48f2d0669f8414",
    "d01caeee77f4ea00173db7f20a945f6cbfd0c9f7",
    "4d0cab2729e2bdb1742b62dba69bd30ab69c868e"
  ],
  "changeHistoryShort": {
    "0e54b164a8d8acf09aca8712116bf7a554cb4846": "Yparameterchange",
    "ec414600ede8e305c584818565b50e055ea5d2b5": "Ybodychange",
    "08466eaa0045658fa7919a634e48f2d0669f8414": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "d01caeee77f4ea00173db7f20a945f6cbfd0c9f7": "Ymultichange(Yreturntypechange,Ybodychange)",
    "4d0cab2729e2bdb1742b62dba69bd30ab69c868e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0e54b164a8d8acf09aca8712116bf7a554cb4846": {
      "type": "Yparameterchange",
      "commitMessage": "HDFS-9314. Improve BlockPlacementPolicyDefault\u0027s picking of excess replicas. (Xiao Chen via mingma)\n",
      "commitDate": "24/11/15 10:30 AM",
      "commitName": "0e54b164a8d8acf09aca8712116bf7a554cb4846",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "04/11/15 10:22 AM",
      "commitNameOld": "ec414600ede8e305c584818565b50e055ea5d2b5",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 20.01,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,39 @@\n   public Collection\u003cDatanodeStorageInfo\u003e pickupReplicaSet(\n       Collection\u003cDatanodeStorageInfo\u003e first,\n-      Collection\u003cDatanodeStorageInfo\u003e second) {\n+      Collection\u003cDatanodeStorageInfo\u003e second,\n+      Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap) {\n     // If no replica within same rack, return directly.\n     if (first.isEmpty()) {\n       return second;\n     }\n     // Split data nodes in the first set into two sets, \n     // moreThanOne contains nodes on nodegroup with more than one replica\n     // exactlyOne contains the remaining nodes\n     Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e nodeGroupMap \u003d new HashMap\u003c\u003e();\n     \n     for(DatanodeStorageInfo storage : first) {\n       final String nodeGroupName \u003d NetworkTopology.getLastHalf(\n           storage.getDatanodeDescriptor().getNetworkLocation());\n       List\u003cDatanodeStorageInfo\u003e storageList \u003d nodeGroupMap.get(nodeGroupName);\n       if (storageList \u003d\u003d null) {\n         storageList \u003d new ArrayList\u003c\u003e();\n         nodeGroupMap.put(nodeGroupName, storageList);\n       }\n       storageList.add(storage);\n     }\n     \n     final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n     final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n     // split nodes into two sets\n     for(List\u003cDatanodeStorageInfo\u003e datanodeList : nodeGroupMap.values()) {\n       if (datanodeList.size() \u003d\u003d 1 ) {\n         // exactlyOne contains nodes on nodegroup with exactly one replica\n         exactlyOne.add(datanodeList.get(0));\n       } else {\n         // moreThanOne contains nodes on nodegroup with more than one replica\n         moreThanOne.addAll(datanodeList);\n       }\n     }\n     \n     return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Collection\u003cDatanodeStorageInfo\u003e pickupReplicaSet(\n      Collection\u003cDatanodeStorageInfo\u003e first,\n      Collection\u003cDatanodeStorageInfo\u003e second,\n      Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap) {\n    // If no replica within same rack, return directly.\n    if (first.isEmpty()) {\n      return second;\n    }\n    // Split data nodes in the first set into two sets, \n    // moreThanOne contains nodes on nodegroup with more than one replica\n    // exactlyOne contains the remaining nodes\n    Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e nodeGroupMap \u003d new HashMap\u003c\u003e();\n    \n    for(DatanodeStorageInfo storage : first) {\n      final String nodeGroupName \u003d NetworkTopology.getLastHalf(\n          storage.getDatanodeDescriptor().getNetworkLocation());\n      List\u003cDatanodeStorageInfo\u003e storageList \u003d nodeGroupMap.get(nodeGroupName);\n      if (storageList \u003d\u003d null) {\n        storageList \u003d new ArrayList\u003c\u003e();\n        nodeGroupMap.put(nodeGroupName, storageList);\n      }\n      storageList.add(storage);\n    }\n    \n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n    // split nodes into two sets\n    for(List\u003cDatanodeStorageInfo\u003e datanodeList : nodeGroupMap.values()) {\n      if (datanodeList.size() \u003d\u003d 1 ) {\n        // exactlyOne contains nodes on nodegroup with exactly one replica\n        exactlyOne.add(datanodeList.get(0));\n      } else {\n        // moreThanOne contains nodes on nodegroup with more than one replica\n        moreThanOne.addAll(datanodeList);\n      }\n    }\n    \n    return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyWithNodeGroup.java",
      "extendedDetails": {
        "oldValue": "[first-Collection\u003cDatanodeStorageInfo\u003e, second-Collection\u003cDatanodeStorageInfo\u003e]",
        "newValue": "[first-Collection\u003cDatanodeStorageInfo\u003e, second-Collection\u003cDatanodeStorageInfo\u003e, rackMap-Map\u003cString,List\u003cDatanodeStorageInfo\u003e\u003e]"
      }
    },
    "ec414600ede8e305c584818565b50e055ea5d2b5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9007. Fix HDFS Balancer to honor upgrade domain policy. (Ming Ma via lei)\n",
      "commitDate": "04/11/15 10:22 AM",
      "commitName": "ec414600ede8e305c584818565b50e055ea5d2b5",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "28/10/15 11:14 PM",
      "commitNameOld": "588baab160e7c328dca1c45cf3541e79218406e8",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 6.51,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,38 @@\n   public Collection\u003cDatanodeStorageInfo\u003e pickupReplicaSet(\n       Collection\u003cDatanodeStorageInfo\u003e first,\n       Collection\u003cDatanodeStorageInfo\u003e second) {\n     // If no replica within same rack, return directly.\n     if (first.isEmpty()) {\n       return second;\n     }\n     // Split data nodes in the first set into two sets, \n     // moreThanOne contains nodes on nodegroup with more than one replica\n     // exactlyOne contains the remaining nodes\n-    Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e nodeGroupMap \u003d \n-        new HashMap\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e();\n+    Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e nodeGroupMap \u003d new HashMap\u003c\u003e();\n     \n     for(DatanodeStorageInfo storage : first) {\n       final String nodeGroupName \u003d NetworkTopology.getLastHalf(\n           storage.getDatanodeDescriptor().getNetworkLocation());\n       List\u003cDatanodeStorageInfo\u003e storageList \u003d nodeGroupMap.get(nodeGroupName);\n       if (storageList \u003d\u003d null) {\n-        storageList \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n+        storageList \u003d new ArrayList\u003c\u003e();\n         nodeGroupMap.put(nodeGroupName, storageList);\n       }\n       storageList.add(storage);\n     }\n     \n-    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n-    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n     // split nodes into two sets\n     for(List\u003cDatanodeStorageInfo\u003e datanodeList : nodeGroupMap.values()) {\n       if (datanodeList.size() \u003d\u003d 1 ) {\n         // exactlyOne contains nodes on nodegroup with exactly one replica\n         exactlyOne.add(datanodeList.get(0));\n       } else {\n         // moreThanOne contains nodes on nodegroup with more than one replica\n         moreThanOne.addAll(datanodeList);\n       }\n     }\n     \n     return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Collection\u003cDatanodeStorageInfo\u003e pickupReplicaSet(\n      Collection\u003cDatanodeStorageInfo\u003e first,\n      Collection\u003cDatanodeStorageInfo\u003e second) {\n    // If no replica within same rack, return directly.\n    if (first.isEmpty()) {\n      return second;\n    }\n    // Split data nodes in the first set into two sets, \n    // moreThanOne contains nodes on nodegroup with more than one replica\n    // exactlyOne contains the remaining nodes\n    Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e nodeGroupMap \u003d new HashMap\u003c\u003e();\n    \n    for(DatanodeStorageInfo storage : first) {\n      final String nodeGroupName \u003d NetworkTopology.getLastHalf(\n          storage.getDatanodeDescriptor().getNetworkLocation());\n      List\u003cDatanodeStorageInfo\u003e storageList \u003d nodeGroupMap.get(nodeGroupName);\n      if (storageList \u003d\u003d null) {\n        storageList \u003d new ArrayList\u003c\u003e();\n        nodeGroupMap.put(nodeGroupName, storageList);\n      }\n      storageList.add(storage);\n    }\n    \n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n    // split nodes into two sets\n    for(List\u003cDatanodeStorageInfo\u003e datanodeList : nodeGroupMap.values()) {\n      if (datanodeList.size() \u003d\u003d 1 ) {\n        // exactlyOne contains nodes on nodegroup with exactly one replica\n        exactlyOne.add(datanodeList.get(0));\n      } else {\n        // moreThanOne contains nodes on nodegroup with more than one replica\n        moreThanOne.addAll(datanodeList);\n      }\n    }\n    \n    return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyWithNodeGroup.java",
      "extendedDetails": {}
    },
    "08466eaa0045658fa7919a634e48f2d0669f8414": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-6700. BlockPlacementPolicy shoud choose storage but not datanode for deletion.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611731 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/14 10:40 AM",
      "commitName": "08466eaa0045658fa7919a634e48f2d0669f8414",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6700. BlockPlacementPolicy shoud choose storage but not datanode for deletion.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611731 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/07/14 10:40 AM",
          "commitName": "08466eaa0045658fa7919a634e48f2d0669f8414",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "03/05/14 4:02 AM",
          "commitNameOld": "b2f65c276da2c4420a0974a7e2d75e081abf5d63",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 76.28,
          "commitsBetweenForRepo": 475,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,39 @@\n-  public Collection\u003cDatanodeDescriptor\u003e pickupReplicaSet(\n-      Collection\u003cDatanodeDescriptor\u003e first,\n-      Collection\u003cDatanodeDescriptor\u003e second) {\n+  public Collection\u003cDatanodeStorageInfo\u003e pickupReplicaSet(\n+      Collection\u003cDatanodeStorageInfo\u003e first,\n+      Collection\u003cDatanodeStorageInfo\u003e second) {\n     // If no replica within same rack, return directly.\n     if (first.isEmpty()) {\n       return second;\n     }\n     // Split data nodes in the first set into two sets, \n     // moreThanOne contains nodes on nodegroup with more than one replica\n     // exactlyOne contains the remaining nodes\n-    Map\u003cString, List\u003cDatanodeDescriptor\u003e\u003e nodeGroupMap \u003d \n-        new HashMap\u003cString, List\u003cDatanodeDescriptor\u003e\u003e();\n+    Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e nodeGroupMap \u003d \n+        new HashMap\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e();\n     \n-    for(DatanodeDescriptor node : first) {\n-      final String nodeGroupName \u003d \n-          NetworkTopology.getLastHalf(node.getNetworkLocation());\n-      List\u003cDatanodeDescriptor\u003e datanodeList \u003d \n-          nodeGroupMap.get(nodeGroupName);\n-      if (datanodeList \u003d\u003d null) {\n-        datanodeList \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n-        nodeGroupMap.put(nodeGroupName, datanodeList);\n+    for(DatanodeStorageInfo storage : first) {\n+      final String nodeGroupName \u003d NetworkTopology.getLastHalf(\n+          storage.getDatanodeDescriptor().getNetworkLocation());\n+      List\u003cDatanodeStorageInfo\u003e storageList \u003d nodeGroupMap.get(nodeGroupName);\n+      if (storageList \u003d\u003d null) {\n+        storageList \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n+        nodeGroupMap.put(nodeGroupName, storageList);\n       }\n-      datanodeList.add(node);\n+      storageList.add(storage);\n     }\n     \n-    final List\u003cDatanodeDescriptor\u003e moreThanOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n-    final List\u003cDatanodeDescriptor\u003e exactlyOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n     // split nodes into two sets\n-    for(List\u003cDatanodeDescriptor\u003e datanodeList : nodeGroupMap.values()) {\n+    for(List\u003cDatanodeStorageInfo\u003e datanodeList : nodeGroupMap.values()) {\n       if (datanodeList.size() \u003d\u003d 1 ) {\n         // exactlyOne contains nodes on nodegroup with exactly one replica\n         exactlyOne.add(datanodeList.get(0));\n       } else {\n         // moreThanOne contains nodes on nodegroup with more than one replica\n         moreThanOne.addAll(datanodeList);\n       }\n     }\n     \n     return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Collection\u003cDatanodeStorageInfo\u003e pickupReplicaSet(\n      Collection\u003cDatanodeStorageInfo\u003e first,\n      Collection\u003cDatanodeStorageInfo\u003e second) {\n    // If no replica within same rack, return directly.\n    if (first.isEmpty()) {\n      return second;\n    }\n    // Split data nodes in the first set into two sets, \n    // moreThanOne contains nodes on nodegroup with more than one replica\n    // exactlyOne contains the remaining nodes\n    Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e nodeGroupMap \u003d \n        new HashMap\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e();\n    \n    for(DatanodeStorageInfo storage : first) {\n      final String nodeGroupName \u003d NetworkTopology.getLastHalf(\n          storage.getDatanodeDescriptor().getNetworkLocation());\n      List\u003cDatanodeStorageInfo\u003e storageList \u003d nodeGroupMap.get(nodeGroupName);\n      if (storageList \u003d\u003d null) {\n        storageList \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n        nodeGroupMap.put(nodeGroupName, storageList);\n      }\n      storageList.add(storage);\n    }\n    \n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n    // split nodes into two sets\n    for(List\u003cDatanodeStorageInfo\u003e datanodeList : nodeGroupMap.values()) {\n      if (datanodeList.size() \u003d\u003d 1 ) {\n        // exactlyOne contains nodes on nodegroup with exactly one replica\n        exactlyOne.add(datanodeList.get(0));\n      } else {\n        // moreThanOne contains nodes on nodegroup with more than one replica\n        moreThanOne.addAll(datanodeList);\n      }\n    }\n    \n    return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyWithNodeGroup.java",
          "extendedDetails": {
            "oldValue": "[first-Collection\u003cDatanodeDescriptor\u003e, second-Collection\u003cDatanodeDescriptor\u003e]",
            "newValue": "[first-Collection\u003cDatanodeStorageInfo\u003e, second-Collection\u003cDatanodeStorageInfo\u003e]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-6700. BlockPlacementPolicy shoud choose storage but not datanode for deletion.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611731 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/07/14 10:40 AM",
          "commitName": "08466eaa0045658fa7919a634e48f2d0669f8414",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "03/05/14 4:02 AM",
          "commitNameOld": "b2f65c276da2c4420a0974a7e2d75e081abf5d63",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 76.28,
          "commitsBetweenForRepo": 475,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,39 @@\n-  public Collection\u003cDatanodeDescriptor\u003e pickupReplicaSet(\n-      Collection\u003cDatanodeDescriptor\u003e first,\n-      Collection\u003cDatanodeDescriptor\u003e second) {\n+  public Collection\u003cDatanodeStorageInfo\u003e pickupReplicaSet(\n+      Collection\u003cDatanodeStorageInfo\u003e first,\n+      Collection\u003cDatanodeStorageInfo\u003e second) {\n     // If no replica within same rack, return directly.\n     if (first.isEmpty()) {\n       return second;\n     }\n     // Split data nodes in the first set into two sets, \n     // moreThanOne contains nodes on nodegroup with more than one replica\n     // exactlyOne contains the remaining nodes\n-    Map\u003cString, List\u003cDatanodeDescriptor\u003e\u003e nodeGroupMap \u003d \n-        new HashMap\u003cString, List\u003cDatanodeDescriptor\u003e\u003e();\n+    Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e nodeGroupMap \u003d \n+        new HashMap\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e();\n     \n-    for(DatanodeDescriptor node : first) {\n-      final String nodeGroupName \u003d \n-          NetworkTopology.getLastHalf(node.getNetworkLocation());\n-      List\u003cDatanodeDescriptor\u003e datanodeList \u003d \n-          nodeGroupMap.get(nodeGroupName);\n-      if (datanodeList \u003d\u003d null) {\n-        datanodeList \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n-        nodeGroupMap.put(nodeGroupName, datanodeList);\n+    for(DatanodeStorageInfo storage : first) {\n+      final String nodeGroupName \u003d NetworkTopology.getLastHalf(\n+          storage.getDatanodeDescriptor().getNetworkLocation());\n+      List\u003cDatanodeStorageInfo\u003e storageList \u003d nodeGroupMap.get(nodeGroupName);\n+      if (storageList \u003d\u003d null) {\n+        storageList \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n+        nodeGroupMap.put(nodeGroupName, storageList);\n       }\n-      datanodeList.add(node);\n+      storageList.add(storage);\n     }\n     \n-    final List\u003cDatanodeDescriptor\u003e moreThanOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n-    final List\u003cDatanodeDescriptor\u003e exactlyOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n     // split nodes into two sets\n-    for(List\u003cDatanodeDescriptor\u003e datanodeList : nodeGroupMap.values()) {\n+    for(List\u003cDatanodeStorageInfo\u003e datanodeList : nodeGroupMap.values()) {\n       if (datanodeList.size() \u003d\u003d 1 ) {\n         // exactlyOne contains nodes on nodegroup with exactly one replica\n         exactlyOne.add(datanodeList.get(0));\n       } else {\n         // moreThanOne contains nodes on nodegroup with more than one replica\n         moreThanOne.addAll(datanodeList);\n       }\n     }\n     \n     return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Collection\u003cDatanodeStorageInfo\u003e pickupReplicaSet(\n      Collection\u003cDatanodeStorageInfo\u003e first,\n      Collection\u003cDatanodeStorageInfo\u003e second) {\n    // If no replica within same rack, return directly.\n    if (first.isEmpty()) {\n      return second;\n    }\n    // Split data nodes in the first set into two sets, \n    // moreThanOne contains nodes on nodegroup with more than one replica\n    // exactlyOne contains the remaining nodes\n    Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e nodeGroupMap \u003d \n        new HashMap\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e();\n    \n    for(DatanodeStorageInfo storage : first) {\n      final String nodeGroupName \u003d NetworkTopology.getLastHalf(\n          storage.getDatanodeDescriptor().getNetworkLocation());\n      List\u003cDatanodeStorageInfo\u003e storageList \u003d nodeGroupMap.get(nodeGroupName);\n      if (storageList \u003d\u003d null) {\n        storageList \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n        nodeGroupMap.put(nodeGroupName, storageList);\n      }\n      storageList.add(storage);\n    }\n    \n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n    // split nodes into two sets\n    for(List\u003cDatanodeStorageInfo\u003e datanodeList : nodeGroupMap.values()) {\n      if (datanodeList.size() \u003d\u003d 1 ) {\n        // exactlyOne contains nodes on nodegroup with exactly one replica\n        exactlyOne.add(datanodeList.get(0));\n      } else {\n        // moreThanOne contains nodes on nodegroup with more than one replica\n        moreThanOne.addAll(datanodeList);\n      }\n    }\n    \n    return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyWithNodeGroup.java",
          "extendedDetails": {
            "oldValue": "Collection\u003cDatanodeDescriptor\u003e",
            "newValue": "Collection\u003cDatanodeStorageInfo\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6700. BlockPlacementPolicy shoud choose storage but not datanode for deletion.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1611731 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/07/14 10:40 AM",
          "commitName": "08466eaa0045658fa7919a634e48f2d0669f8414",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "03/05/14 4:02 AM",
          "commitNameOld": "b2f65c276da2c4420a0974a7e2d75e081abf5d63",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 76.28,
          "commitsBetweenForRepo": 475,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,39 @@\n-  public Collection\u003cDatanodeDescriptor\u003e pickupReplicaSet(\n-      Collection\u003cDatanodeDescriptor\u003e first,\n-      Collection\u003cDatanodeDescriptor\u003e second) {\n+  public Collection\u003cDatanodeStorageInfo\u003e pickupReplicaSet(\n+      Collection\u003cDatanodeStorageInfo\u003e first,\n+      Collection\u003cDatanodeStorageInfo\u003e second) {\n     // If no replica within same rack, return directly.\n     if (first.isEmpty()) {\n       return second;\n     }\n     // Split data nodes in the first set into two sets, \n     // moreThanOne contains nodes on nodegroup with more than one replica\n     // exactlyOne contains the remaining nodes\n-    Map\u003cString, List\u003cDatanodeDescriptor\u003e\u003e nodeGroupMap \u003d \n-        new HashMap\u003cString, List\u003cDatanodeDescriptor\u003e\u003e();\n+    Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e nodeGroupMap \u003d \n+        new HashMap\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e();\n     \n-    for(DatanodeDescriptor node : first) {\n-      final String nodeGroupName \u003d \n-          NetworkTopology.getLastHalf(node.getNetworkLocation());\n-      List\u003cDatanodeDescriptor\u003e datanodeList \u003d \n-          nodeGroupMap.get(nodeGroupName);\n-      if (datanodeList \u003d\u003d null) {\n-        datanodeList \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n-        nodeGroupMap.put(nodeGroupName, datanodeList);\n+    for(DatanodeStorageInfo storage : first) {\n+      final String nodeGroupName \u003d NetworkTopology.getLastHalf(\n+          storage.getDatanodeDescriptor().getNetworkLocation());\n+      List\u003cDatanodeStorageInfo\u003e storageList \u003d nodeGroupMap.get(nodeGroupName);\n+      if (storageList \u003d\u003d null) {\n+        storageList \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n+        nodeGroupMap.put(nodeGroupName, storageList);\n       }\n-      datanodeList.add(node);\n+      storageList.add(storage);\n     }\n     \n-    final List\u003cDatanodeDescriptor\u003e moreThanOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n-    final List\u003cDatanodeDescriptor\u003e exactlyOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n     // split nodes into two sets\n-    for(List\u003cDatanodeDescriptor\u003e datanodeList : nodeGroupMap.values()) {\n+    for(List\u003cDatanodeStorageInfo\u003e datanodeList : nodeGroupMap.values()) {\n       if (datanodeList.size() \u003d\u003d 1 ) {\n         // exactlyOne contains nodes on nodegroup with exactly one replica\n         exactlyOne.add(datanodeList.get(0));\n       } else {\n         // moreThanOne contains nodes on nodegroup with more than one replica\n         moreThanOne.addAll(datanodeList);\n       }\n     }\n     \n     return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Collection\u003cDatanodeStorageInfo\u003e pickupReplicaSet(\n      Collection\u003cDatanodeStorageInfo\u003e first,\n      Collection\u003cDatanodeStorageInfo\u003e second) {\n    // If no replica within same rack, return directly.\n    if (first.isEmpty()) {\n      return second;\n    }\n    // Split data nodes in the first set into two sets, \n    // moreThanOne contains nodes on nodegroup with more than one replica\n    // exactlyOne contains the remaining nodes\n    Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e nodeGroupMap \u003d \n        new HashMap\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e();\n    \n    for(DatanodeStorageInfo storage : first) {\n      final String nodeGroupName \u003d NetworkTopology.getLastHalf(\n          storage.getDatanodeDescriptor().getNetworkLocation());\n      List\u003cDatanodeStorageInfo\u003e storageList \u003d nodeGroupMap.get(nodeGroupName);\n      if (storageList \u003d\u003d null) {\n        storageList \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n        nodeGroupMap.put(nodeGroupName, storageList);\n      }\n      storageList.add(storage);\n    }\n    \n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003cDatanodeStorageInfo\u003e();\n    // split nodes into two sets\n    for(List\u003cDatanodeStorageInfo\u003e datanodeList : nodeGroupMap.values()) {\n      if (datanodeList.size() \u003d\u003d 1 ) {\n        // exactlyOne contains nodes on nodegroup with exactly one replica\n        exactlyOne.add(datanodeList.get(0));\n      } else {\n        // moreThanOne contains nodes on nodegroup with more than one replica\n        moreThanOne.addAll(datanodeList);\n      }\n    }\n    \n    return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyWithNodeGroup.java",
          "extendedDetails": {}
        }
      ]
    },
    "d01caeee77f4ea00173db7f20a945f6cbfd0c9f7": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-5188. In BlockPlacementPolicy, reduce the number of chooseTarget(..) methods; replace HashMap with Map in parameter declarations and cleanup some related code.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1523400 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/09/13 9:15 PM",
      "commitName": "d01caeee77f4ea00173db7f20a945f6cbfd0c9f7",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5188. In BlockPlacementPolicy, reduce the number of chooseTarget(..) methods; replace HashMap with Map in parameter declarations and cleanup some related code.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1523400 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "14/09/13 9:15 PM",
          "commitName": "d01caeee77f4ea00173db7f20a945f6cbfd0c9f7",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "14/08/13 9:52 PM",
          "commitNameOld": "0182ea16d359b41c065bf9cbf740f8b23f6381e3",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 30.97,
          "commitsBetweenForRepo": 162,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,40 @@\n-  public Iterator\u003cDatanodeDescriptor\u003e pickupReplicaSet(\n+  public Collection\u003cDatanodeDescriptor\u003e pickupReplicaSet(\n       Collection\u003cDatanodeDescriptor\u003e first,\n       Collection\u003cDatanodeDescriptor\u003e second) {\n     // If no replica within same rack, return directly.\n     if (first.isEmpty()) {\n-      return second.iterator();\n+      return second;\n     }\n     // Split data nodes in the first set into two sets, \n     // moreThanOne contains nodes on nodegroup with more than one replica\n     // exactlyOne contains the remaining nodes\n     Map\u003cString, List\u003cDatanodeDescriptor\u003e\u003e nodeGroupMap \u003d \n         new HashMap\u003cString, List\u003cDatanodeDescriptor\u003e\u003e();\n     \n     for(DatanodeDescriptor node : first) {\n       final String nodeGroupName \u003d \n           NetworkTopology.getLastHalf(node.getNetworkLocation());\n       List\u003cDatanodeDescriptor\u003e datanodeList \u003d \n           nodeGroupMap.get(nodeGroupName);\n       if (datanodeList \u003d\u003d null) {\n         datanodeList \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n         nodeGroupMap.put(nodeGroupName, datanodeList);\n       }\n       datanodeList.add(node);\n     }\n     \n     final List\u003cDatanodeDescriptor\u003e moreThanOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n     final List\u003cDatanodeDescriptor\u003e exactlyOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n     // split nodes into two sets\n     for(List\u003cDatanodeDescriptor\u003e datanodeList : nodeGroupMap.values()) {\n       if (datanodeList.size() \u003d\u003d 1 ) {\n         // exactlyOne contains nodes on nodegroup with exactly one replica\n         exactlyOne.add(datanodeList.get(0));\n       } else {\n         // moreThanOne contains nodes on nodegroup with more than one replica\n         moreThanOne.addAll(datanodeList);\n       }\n     }\n     \n-    Iterator\u003cDatanodeDescriptor\u003e iter \u003d\n-        moreThanOne.isEmpty() ? exactlyOne.iterator() : moreThanOne.iterator();\n-    return iter;\n+    return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Collection\u003cDatanodeDescriptor\u003e pickupReplicaSet(\n      Collection\u003cDatanodeDescriptor\u003e first,\n      Collection\u003cDatanodeDescriptor\u003e second) {\n    // If no replica within same rack, return directly.\n    if (first.isEmpty()) {\n      return second;\n    }\n    // Split data nodes in the first set into two sets, \n    // moreThanOne contains nodes on nodegroup with more than one replica\n    // exactlyOne contains the remaining nodes\n    Map\u003cString, List\u003cDatanodeDescriptor\u003e\u003e nodeGroupMap \u003d \n        new HashMap\u003cString, List\u003cDatanodeDescriptor\u003e\u003e();\n    \n    for(DatanodeDescriptor node : first) {\n      final String nodeGroupName \u003d \n          NetworkTopology.getLastHalf(node.getNetworkLocation());\n      List\u003cDatanodeDescriptor\u003e datanodeList \u003d \n          nodeGroupMap.get(nodeGroupName);\n      if (datanodeList \u003d\u003d null) {\n        datanodeList \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n        nodeGroupMap.put(nodeGroupName, datanodeList);\n      }\n      datanodeList.add(node);\n    }\n    \n    final List\u003cDatanodeDescriptor\u003e moreThanOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n    final List\u003cDatanodeDescriptor\u003e exactlyOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n    // split nodes into two sets\n    for(List\u003cDatanodeDescriptor\u003e datanodeList : nodeGroupMap.values()) {\n      if (datanodeList.size() \u003d\u003d 1 ) {\n        // exactlyOne contains nodes on nodegroup with exactly one replica\n        exactlyOne.add(datanodeList.get(0));\n      } else {\n        // moreThanOne contains nodes on nodegroup with more than one replica\n        moreThanOne.addAll(datanodeList);\n      }\n    }\n    \n    return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyWithNodeGroup.java",
          "extendedDetails": {
            "oldValue": "Iterator\u003cDatanodeDescriptor\u003e",
            "newValue": "Collection\u003cDatanodeDescriptor\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5188. In BlockPlacementPolicy, reduce the number of chooseTarget(..) methods; replace HashMap with Map in parameter declarations and cleanup some related code.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1523400 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "14/09/13 9:15 PM",
          "commitName": "d01caeee77f4ea00173db7f20a945f6cbfd0c9f7",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "14/08/13 9:52 PM",
          "commitNameOld": "0182ea16d359b41c065bf9cbf740f8b23f6381e3",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 30.97,
          "commitsBetweenForRepo": 162,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,40 @@\n-  public Iterator\u003cDatanodeDescriptor\u003e pickupReplicaSet(\n+  public Collection\u003cDatanodeDescriptor\u003e pickupReplicaSet(\n       Collection\u003cDatanodeDescriptor\u003e first,\n       Collection\u003cDatanodeDescriptor\u003e second) {\n     // If no replica within same rack, return directly.\n     if (first.isEmpty()) {\n-      return second.iterator();\n+      return second;\n     }\n     // Split data nodes in the first set into two sets, \n     // moreThanOne contains nodes on nodegroup with more than one replica\n     // exactlyOne contains the remaining nodes\n     Map\u003cString, List\u003cDatanodeDescriptor\u003e\u003e nodeGroupMap \u003d \n         new HashMap\u003cString, List\u003cDatanodeDescriptor\u003e\u003e();\n     \n     for(DatanodeDescriptor node : first) {\n       final String nodeGroupName \u003d \n           NetworkTopology.getLastHalf(node.getNetworkLocation());\n       List\u003cDatanodeDescriptor\u003e datanodeList \u003d \n           nodeGroupMap.get(nodeGroupName);\n       if (datanodeList \u003d\u003d null) {\n         datanodeList \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n         nodeGroupMap.put(nodeGroupName, datanodeList);\n       }\n       datanodeList.add(node);\n     }\n     \n     final List\u003cDatanodeDescriptor\u003e moreThanOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n     final List\u003cDatanodeDescriptor\u003e exactlyOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n     // split nodes into two sets\n     for(List\u003cDatanodeDescriptor\u003e datanodeList : nodeGroupMap.values()) {\n       if (datanodeList.size() \u003d\u003d 1 ) {\n         // exactlyOne contains nodes on nodegroup with exactly one replica\n         exactlyOne.add(datanodeList.get(0));\n       } else {\n         // moreThanOne contains nodes on nodegroup with more than one replica\n         moreThanOne.addAll(datanodeList);\n       }\n     }\n     \n-    Iterator\u003cDatanodeDescriptor\u003e iter \u003d\n-        moreThanOne.isEmpty() ? exactlyOne.iterator() : moreThanOne.iterator();\n-    return iter;\n+    return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Collection\u003cDatanodeDescriptor\u003e pickupReplicaSet(\n      Collection\u003cDatanodeDescriptor\u003e first,\n      Collection\u003cDatanodeDescriptor\u003e second) {\n    // If no replica within same rack, return directly.\n    if (first.isEmpty()) {\n      return second;\n    }\n    // Split data nodes in the first set into two sets, \n    // moreThanOne contains nodes on nodegroup with more than one replica\n    // exactlyOne contains the remaining nodes\n    Map\u003cString, List\u003cDatanodeDescriptor\u003e\u003e nodeGroupMap \u003d \n        new HashMap\u003cString, List\u003cDatanodeDescriptor\u003e\u003e();\n    \n    for(DatanodeDescriptor node : first) {\n      final String nodeGroupName \u003d \n          NetworkTopology.getLastHalf(node.getNetworkLocation());\n      List\u003cDatanodeDescriptor\u003e datanodeList \u003d \n          nodeGroupMap.get(nodeGroupName);\n      if (datanodeList \u003d\u003d null) {\n        datanodeList \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n        nodeGroupMap.put(nodeGroupName, datanodeList);\n      }\n      datanodeList.add(node);\n    }\n    \n    final List\u003cDatanodeDescriptor\u003e moreThanOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n    final List\u003cDatanodeDescriptor\u003e exactlyOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n    // split nodes into two sets\n    for(List\u003cDatanodeDescriptor\u003e datanodeList : nodeGroupMap.values()) {\n      if (datanodeList.size() \u003d\u003d 1 ) {\n        // exactlyOne contains nodes on nodegroup with exactly one replica\n        exactlyOne.add(datanodeList.get(0));\n      } else {\n        // moreThanOne contains nodes on nodegroup with more than one replica\n        moreThanOne.addAll(datanodeList);\n      }\n    }\n    \n    return moreThanOne.isEmpty()? exactlyOne : moreThanOne;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyWithNodeGroup.java",
          "extendedDetails": {}
        }
      ]
    },
    "4d0cab2729e2bdb1742b62dba69bd30ab69c868e": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3601. Add BlockPlacementPolicyWithNodeGroup to support block placement with 4-layer network topology.  Contributed by Junping Du\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1357442 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/07/12 6:31 PM",
      "commitName": "4d0cab2729e2bdb1742b62dba69bd30ab69c868e",
      "commitAuthor": "Tsz-wo Sze",
      "diff": "@@ -0,0 +1,42 @@\n+  public Iterator\u003cDatanodeDescriptor\u003e pickupReplicaSet(\n+      Collection\u003cDatanodeDescriptor\u003e first,\n+      Collection\u003cDatanodeDescriptor\u003e second) {\n+    // If no replica within same rack, return directly.\n+    if (first.isEmpty()) {\n+      return second.iterator();\n+    }\n+    // Split data nodes in the first set into two sets, \n+    // moreThanOne contains nodes on nodegroup with more than one replica\n+    // exactlyOne contains the remaining nodes\n+    Map\u003cString, List\u003cDatanodeDescriptor\u003e\u003e nodeGroupMap \u003d \n+        new HashMap\u003cString, List\u003cDatanodeDescriptor\u003e\u003e();\n+    \n+    for(DatanodeDescriptor node : first) {\n+      final String nodeGroupName \u003d \n+          NetworkTopology.getLastHalf(node.getNetworkLocation());\n+      List\u003cDatanodeDescriptor\u003e datanodeList \u003d \n+          nodeGroupMap.get(nodeGroupName);\n+      if (datanodeList \u003d\u003d null) {\n+        datanodeList \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n+        nodeGroupMap.put(nodeGroupName, datanodeList);\n+      }\n+      datanodeList.add(node);\n+    }\n+    \n+    final List\u003cDatanodeDescriptor\u003e moreThanOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n+    final List\u003cDatanodeDescriptor\u003e exactlyOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n+    // split nodes into two sets\n+    for(List\u003cDatanodeDescriptor\u003e datanodeList : nodeGroupMap.values()) {\n+      if (datanodeList.size() \u003d\u003d 1 ) {\n+        // exactlyOne contains nodes on nodegroup with exactly one replica\n+        exactlyOne.add(datanodeList.get(0));\n+      } else {\n+        // moreThanOne contains nodes on nodegroup with more than one replica\n+        moreThanOne.addAll(datanodeList);\n+      }\n+    }\n+    \n+    Iterator\u003cDatanodeDescriptor\u003e iter \u003d\n+        moreThanOne.isEmpty() ? exactlyOne.iterator() : moreThanOne.iterator();\n+    return iter;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Iterator\u003cDatanodeDescriptor\u003e pickupReplicaSet(\n      Collection\u003cDatanodeDescriptor\u003e first,\n      Collection\u003cDatanodeDescriptor\u003e second) {\n    // If no replica within same rack, return directly.\n    if (first.isEmpty()) {\n      return second.iterator();\n    }\n    // Split data nodes in the first set into two sets, \n    // moreThanOne contains nodes on nodegroup with more than one replica\n    // exactlyOne contains the remaining nodes\n    Map\u003cString, List\u003cDatanodeDescriptor\u003e\u003e nodeGroupMap \u003d \n        new HashMap\u003cString, List\u003cDatanodeDescriptor\u003e\u003e();\n    \n    for(DatanodeDescriptor node : first) {\n      final String nodeGroupName \u003d \n          NetworkTopology.getLastHalf(node.getNetworkLocation());\n      List\u003cDatanodeDescriptor\u003e datanodeList \u003d \n          nodeGroupMap.get(nodeGroupName);\n      if (datanodeList \u003d\u003d null) {\n        datanodeList \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n        nodeGroupMap.put(nodeGroupName, datanodeList);\n      }\n      datanodeList.add(node);\n    }\n    \n    final List\u003cDatanodeDescriptor\u003e moreThanOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n    final List\u003cDatanodeDescriptor\u003e exactlyOne \u003d new ArrayList\u003cDatanodeDescriptor\u003e();\n    // split nodes into two sets\n    for(List\u003cDatanodeDescriptor\u003e datanodeList : nodeGroupMap.values()) {\n      if (datanodeList.size() \u003d\u003d 1 ) {\n        // exactlyOne contains nodes on nodegroup with exactly one replica\n        exactlyOne.add(datanodeList.get(0));\n      } else {\n        // moreThanOne contains nodes on nodegroup with more than one replica\n        moreThanOne.addAll(datanodeList);\n      }\n    }\n    \n    Iterator\u003cDatanodeDescriptor\u003e iter \u003d\n        moreThanOne.isEmpty() ? exactlyOne.iterator() : moreThanOne.iterator();\n    return iter;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyWithNodeGroup.java"
    }
  }
}