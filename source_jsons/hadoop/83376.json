{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ServiceLauncher.java",
  "functionName": "coreServiceLaunch",
  "functionId": "coreServiceLaunch___conf-Configuration__instance-S__processedArgs-List__String____addShutdownHook-boolean__execute-boolean",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/service/launcher/ServiceLauncher.java",
  "functionStartLine": 570,
  "functionEndLine": 645,
  "numCommitsSeen": 5,
  "timeTaken": 2262,
  "changeHistory": [
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
    "373bb4931fb392e3ca6bfd78992887e5a405e186"
  ],
  "changeHistoryShort": {
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": "Ymultichange(Yparameterchange,Ybodychange)",
    "373bb4931fb392e3ca6bfd78992887e5a405e186": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
      "commitDate": "12/07/19 5:02 AM",
      "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
          "commitDate": "12/07/19 5:02 AM",
          "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "10/10/18 9:51 PM",
          "commitNameOld": "7b57f2f71fbaa5af4897309597cca70a95b04edd",
          "commitAuthorOld": "Takanobu Asanuma",
          "daysBetweenCommits": 274.3,
          "commitsBetweenForRepo": 2016,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,76 @@\n   protected int coreServiceLaunch(Configuration conf,\n+      S instance,\n       List\u003cString\u003e processedArgs,\n       boolean addShutdownHook,\n       boolean execute) throws Exception {\n \n     // create the service instance\n-    instantiateService(conf);\n+    if (instance \u003d\u003d null) {\n+      instantiateService(conf);\n+    } else {\n+      // service already exists, so instantiate\n+      configuration \u003d conf;\n+      service \u003d instance;\n+    }\n     ServiceShutdownHook shutdownHook \u003d null;\n \n     // and the shutdown hook if requested\n     if (addShutdownHook) {\n       shutdownHook \u003d new ServiceShutdownHook(service);\n       shutdownHook.register(SHUTDOWN_PRIORITY);\n     }\n     String name \u003d getServiceName();\n     LOG.debug(\"Launched service {}\", name);\n     LaunchableService launchableService \u003d null;\n \n     if (service instanceof LaunchableService) {\n       // it\u0027s a LaunchableService, pass in the conf and arguments before init)\n       LOG.debug(\"Service {} implements LaunchableService\", name);\n       launchableService \u003d (LaunchableService) service;\n       if (launchableService.isInState(Service.STATE.INITED)) {\n         LOG.warn(\"LaunchableService {}\" \n             + \" initialized in constructor before CLI arguments passed in\",\n             name);\n       }\n       Configuration newconf \u003d launchableService.bindArgs(configuration,\n           processedArgs);\n       if (newconf !\u003d null) {\n         configuration \u003d newconf;\n       }\n     }\n \n     //some class constructors init; here this is picked up on.\n     if (!service.isInState(Service.STATE.INITED)) {\n       service.init(configuration);\n     }\n     int exitCode;\n \n     try {\n       // start the service\n       service.start();\n       exitCode \u003d EXIT_SUCCESS;\n       if (execute \u0026\u0026 service.isInState(Service.STATE.STARTED)) {\n         if (launchableService !\u003d null) {\n           // assume that runnable services are meant to run from here\n           try {\n             exitCode \u003d launchableService.execute();\n             LOG.debug(\"Service {} execution returned exit code {}\",\n                 name, exitCode);\n           } finally {\n             // then stop the service\n             service.stop();\n           }\n         } else {\n           //run the service until it stops or an interrupt happens\n           // on a different thread.\n           LOG.debug(\"waiting for service threads to terminate\");\n           service.waitForServiceToStop(0);\n         }\n       }\n     } finally {\n       if (shutdownHook !\u003d null) {\n         shutdownHook.unregister();\n       }\n     }\n     return exitCode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected int coreServiceLaunch(Configuration conf,\n      S instance,\n      List\u003cString\u003e processedArgs,\n      boolean addShutdownHook,\n      boolean execute) throws Exception {\n\n    // create the service instance\n    if (instance \u003d\u003d null) {\n      instantiateService(conf);\n    } else {\n      // service already exists, so instantiate\n      configuration \u003d conf;\n      service \u003d instance;\n    }\n    ServiceShutdownHook shutdownHook \u003d null;\n\n    // and the shutdown hook if requested\n    if (addShutdownHook) {\n      shutdownHook \u003d new ServiceShutdownHook(service);\n      shutdownHook.register(SHUTDOWN_PRIORITY);\n    }\n    String name \u003d getServiceName();\n    LOG.debug(\"Launched service {}\", name);\n    LaunchableService launchableService \u003d null;\n\n    if (service instanceof LaunchableService) {\n      // it\u0027s a LaunchableService, pass in the conf and arguments before init)\n      LOG.debug(\"Service {} implements LaunchableService\", name);\n      launchableService \u003d (LaunchableService) service;\n      if (launchableService.isInState(Service.STATE.INITED)) {\n        LOG.warn(\"LaunchableService {}\" \n            + \" initialized in constructor before CLI arguments passed in\",\n            name);\n      }\n      Configuration newconf \u003d launchableService.bindArgs(configuration,\n          processedArgs);\n      if (newconf !\u003d null) {\n        configuration \u003d newconf;\n      }\n    }\n\n    //some class constructors init; here this is picked up on.\n    if (!service.isInState(Service.STATE.INITED)) {\n      service.init(configuration);\n    }\n    int exitCode;\n\n    try {\n      // start the service\n      service.start();\n      exitCode \u003d EXIT_SUCCESS;\n      if (execute \u0026\u0026 service.isInState(Service.STATE.STARTED)) {\n        if (launchableService !\u003d null) {\n          // assume that runnable services are meant to run from here\n          try {\n            exitCode \u003d launchableService.execute();\n            LOG.debug(\"Service {} execution returned exit code {}\",\n                name, exitCode);\n          } finally {\n            // then stop the service\n            service.stop();\n          }\n        } else {\n          //run the service until it stops or an interrupt happens\n          // on a different thread.\n          LOG.debug(\"waiting for service threads to terminate\");\n          service.waitForServiceToStop(0);\n        }\n      }\n    } finally {\n      if (shutdownHook !\u003d null) {\n        shutdownHook.unregister();\n      }\n    }\n    return exitCode;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/service/launcher/ServiceLauncher.java",
          "extendedDetails": {
            "oldValue": "[conf-Configuration, processedArgs-List\u003cString\u003e, addShutdownHook-boolean, execute-boolean]",
            "newValue": "[conf-Configuration, instance-S, processedArgs-List\u003cString\u003e, addShutdownHook-boolean, execute-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
          "commitDate": "12/07/19 5:02 AM",
          "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "10/10/18 9:51 PM",
          "commitNameOld": "7b57f2f71fbaa5af4897309597cca70a95b04edd",
          "commitAuthorOld": "Takanobu Asanuma",
          "daysBetweenCommits": 274.3,
          "commitsBetweenForRepo": 2016,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,69 +1,76 @@\n   protected int coreServiceLaunch(Configuration conf,\n+      S instance,\n       List\u003cString\u003e processedArgs,\n       boolean addShutdownHook,\n       boolean execute) throws Exception {\n \n     // create the service instance\n-    instantiateService(conf);\n+    if (instance \u003d\u003d null) {\n+      instantiateService(conf);\n+    } else {\n+      // service already exists, so instantiate\n+      configuration \u003d conf;\n+      service \u003d instance;\n+    }\n     ServiceShutdownHook shutdownHook \u003d null;\n \n     // and the shutdown hook if requested\n     if (addShutdownHook) {\n       shutdownHook \u003d new ServiceShutdownHook(service);\n       shutdownHook.register(SHUTDOWN_PRIORITY);\n     }\n     String name \u003d getServiceName();\n     LOG.debug(\"Launched service {}\", name);\n     LaunchableService launchableService \u003d null;\n \n     if (service instanceof LaunchableService) {\n       // it\u0027s a LaunchableService, pass in the conf and arguments before init)\n       LOG.debug(\"Service {} implements LaunchableService\", name);\n       launchableService \u003d (LaunchableService) service;\n       if (launchableService.isInState(Service.STATE.INITED)) {\n         LOG.warn(\"LaunchableService {}\" \n             + \" initialized in constructor before CLI arguments passed in\",\n             name);\n       }\n       Configuration newconf \u003d launchableService.bindArgs(configuration,\n           processedArgs);\n       if (newconf !\u003d null) {\n         configuration \u003d newconf;\n       }\n     }\n \n     //some class constructors init; here this is picked up on.\n     if (!service.isInState(Service.STATE.INITED)) {\n       service.init(configuration);\n     }\n     int exitCode;\n \n     try {\n       // start the service\n       service.start();\n       exitCode \u003d EXIT_SUCCESS;\n       if (execute \u0026\u0026 service.isInState(Service.STATE.STARTED)) {\n         if (launchableService !\u003d null) {\n           // assume that runnable services are meant to run from here\n           try {\n             exitCode \u003d launchableService.execute();\n             LOG.debug(\"Service {} execution returned exit code {}\",\n                 name, exitCode);\n           } finally {\n             // then stop the service\n             service.stop();\n           }\n         } else {\n           //run the service until it stops or an interrupt happens\n           // on a different thread.\n           LOG.debug(\"waiting for service threads to terminate\");\n           service.waitForServiceToStop(0);\n         }\n       }\n     } finally {\n       if (shutdownHook !\u003d null) {\n         shutdownHook.unregister();\n       }\n     }\n     return exitCode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected int coreServiceLaunch(Configuration conf,\n      S instance,\n      List\u003cString\u003e processedArgs,\n      boolean addShutdownHook,\n      boolean execute) throws Exception {\n\n    // create the service instance\n    if (instance \u003d\u003d null) {\n      instantiateService(conf);\n    } else {\n      // service already exists, so instantiate\n      configuration \u003d conf;\n      service \u003d instance;\n    }\n    ServiceShutdownHook shutdownHook \u003d null;\n\n    // and the shutdown hook if requested\n    if (addShutdownHook) {\n      shutdownHook \u003d new ServiceShutdownHook(service);\n      shutdownHook.register(SHUTDOWN_PRIORITY);\n    }\n    String name \u003d getServiceName();\n    LOG.debug(\"Launched service {}\", name);\n    LaunchableService launchableService \u003d null;\n\n    if (service instanceof LaunchableService) {\n      // it\u0027s a LaunchableService, pass in the conf and arguments before init)\n      LOG.debug(\"Service {} implements LaunchableService\", name);\n      launchableService \u003d (LaunchableService) service;\n      if (launchableService.isInState(Service.STATE.INITED)) {\n        LOG.warn(\"LaunchableService {}\" \n            + \" initialized in constructor before CLI arguments passed in\",\n            name);\n      }\n      Configuration newconf \u003d launchableService.bindArgs(configuration,\n          processedArgs);\n      if (newconf !\u003d null) {\n        configuration \u003d newconf;\n      }\n    }\n\n    //some class constructors init; here this is picked up on.\n    if (!service.isInState(Service.STATE.INITED)) {\n      service.init(configuration);\n    }\n    int exitCode;\n\n    try {\n      // start the service\n      service.start();\n      exitCode \u003d EXIT_SUCCESS;\n      if (execute \u0026\u0026 service.isInState(Service.STATE.STARTED)) {\n        if (launchableService !\u003d null) {\n          // assume that runnable services are meant to run from here\n          try {\n            exitCode \u003d launchableService.execute();\n            LOG.debug(\"Service {} execution returned exit code {}\",\n                name, exitCode);\n          } finally {\n            // then stop the service\n            service.stop();\n          }\n        } else {\n          //run the service until it stops or an interrupt happens\n          // on a different thread.\n          LOG.debug(\"waiting for service threads to terminate\");\n          service.waitForServiceToStop(0);\n        }\n      }\n    } finally {\n      if (shutdownHook !\u003d null) {\n        shutdownHook.unregister();\n      }\n    }\n    return exitCode;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/service/launcher/ServiceLauncher.java",
          "extendedDetails": {}
        }
      ]
    },
    "373bb4931fb392e3ca6bfd78992887e5a405e186": {
      "type": "Yintroduced",
      "commitMessage": "YARN-679. Add an entry point that can start any Yarn service. Contributed by Steve Loughran.\n",
      "commitDate": "28/04/17 10:45 AM",
      "commitName": "373bb4931fb392e3ca6bfd78992887e5a405e186",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,69 @@\n+  protected int coreServiceLaunch(Configuration conf,\n+      List\u003cString\u003e processedArgs,\n+      boolean addShutdownHook,\n+      boolean execute) throws Exception {\n+\n+    // create the service instance\n+    instantiateService(conf);\n+    ServiceShutdownHook shutdownHook \u003d null;\n+\n+    // and the shutdown hook if requested\n+    if (addShutdownHook) {\n+      shutdownHook \u003d new ServiceShutdownHook(service);\n+      shutdownHook.register(SHUTDOWN_PRIORITY);\n+    }\n+    String name \u003d getServiceName();\n+    LOG.debug(\"Launched service {}\", name);\n+    LaunchableService launchableService \u003d null;\n+\n+    if (service instanceof LaunchableService) {\n+      // it\u0027s a LaunchableService, pass in the conf and arguments before init)\n+      LOG.debug(\"Service {} implements LaunchableService\", name);\n+      launchableService \u003d (LaunchableService) service;\n+      if (launchableService.isInState(Service.STATE.INITED)) {\n+        LOG.warn(\"LaunchableService {}\" \n+            + \" initialized in constructor before CLI arguments passed in\",\n+            name);\n+      }\n+      Configuration newconf \u003d launchableService.bindArgs(configuration,\n+          processedArgs);\n+      if (newconf !\u003d null) {\n+        configuration \u003d newconf;\n+      }\n+    }\n+\n+    //some class constructors init; here this is picked up on.\n+    if (!service.isInState(Service.STATE.INITED)) {\n+      service.init(configuration);\n+    }\n+    int exitCode;\n+\n+    try {\n+      // start the service\n+      service.start();\n+      exitCode \u003d EXIT_SUCCESS;\n+      if (execute \u0026\u0026 service.isInState(Service.STATE.STARTED)) {\n+        if (launchableService !\u003d null) {\n+          // assume that runnable services are meant to run from here\n+          try {\n+            exitCode \u003d launchableService.execute();\n+            LOG.debug(\"Service {} execution returned exit code {}\",\n+                name, exitCode);\n+          } finally {\n+            // then stop the service\n+            service.stop();\n+          }\n+        } else {\n+          //run the service until it stops or an interrupt happens\n+          // on a different thread.\n+          LOG.debug(\"waiting for service threads to terminate\");\n+          service.waitForServiceToStop(0);\n+        }\n+      }\n+    } finally {\n+      if (shutdownHook !\u003d null) {\n+        shutdownHook.unregister();\n+      }\n+    }\n+    return exitCode;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected int coreServiceLaunch(Configuration conf,\n      List\u003cString\u003e processedArgs,\n      boolean addShutdownHook,\n      boolean execute) throws Exception {\n\n    // create the service instance\n    instantiateService(conf);\n    ServiceShutdownHook shutdownHook \u003d null;\n\n    // and the shutdown hook if requested\n    if (addShutdownHook) {\n      shutdownHook \u003d new ServiceShutdownHook(service);\n      shutdownHook.register(SHUTDOWN_PRIORITY);\n    }\n    String name \u003d getServiceName();\n    LOG.debug(\"Launched service {}\", name);\n    LaunchableService launchableService \u003d null;\n\n    if (service instanceof LaunchableService) {\n      // it\u0027s a LaunchableService, pass in the conf and arguments before init)\n      LOG.debug(\"Service {} implements LaunchableService\", name);\n      launchableService \u003d (LaunchableService) service;\n      if (launchableService.isInState(Service.STATE.INITED)) {\n        LOG.warn(\"LaunchableService {}\" \n            + \" initialized in constructor before CLI arguments passed in\",\n            name);\n      }\n      Configuration newconf \u003d launchableService.bindArgs(configuration,\n          processedArgs);\n      if (newconf !\u003d null) {\n        configuration \u003d newconf;\n      }\n    }\n\n    //some class constructors init; here this is picked up on.\n    if (!service.isInState(Service.STATE.INITED)) {\n      service.init(configuration);\n    }\n    int exitCode;\n\n    try {\n      // start the service\n      service.start();\n      exitCode \u003d EXIT_SUCCESS;\n      if (execute \u0026\u0026 service.isInState(Service.STATE.STARTED)) {\n        if (launchableService !\u003d null) {\n          // assume that runnable services are meant to run from here\n          try {\n            exitCode \u003d launchableService.execute();\n            LOG.debug(\"Service {} execution returned exit code {}\",\n                name, exitCode);\n          } finally {\n            // then stop the service\n            service.stop();\n          }\n        } else {\n          //run the service until it stops or an interrupt happens\n          // on a different thread.\n          LOG.debug(\"waiting for service threads to terminate\");\n          service.waitForServiceToStop(0);\n        }\n      }\n    } finally {\n      if (shutdownHook !\u003d null) {\n        shutdownHook.unregister();\n      }\n    }\n    return exitCode;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/service/launcher/ServiceLauncher.java"
    }
  }
}