{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockSender.java",
  "functionName": "sendPacket",
  "functionId": "sendPacket___pkt-ByteBuffer__maxChunks-int__out-OutputStream__transferTo-boolean__throttler-DataTransferThrottler",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
  "functionStartLine": 546,
  "functionEndLine": 669,
  "numCommitsSeen": 65,
  "timeTaken": 7006,
  "changeHistory": [
    "fccfb02672178d05f9d804f3a40f6b6b7d11efeb",
    "360a96f342f3c8cb8246f011abb9bcb0b6ef3eaa",
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389",
    "df983b524ab68ea0c70cee9033bfff2d28052cbf",
    "dcedb72af468128458e597f08d22f5c34b744ae5",
    "aeecfa24f4fb6af289920cbf8830c394e66bd78e",
    "5c0bffddc0cb824a8a2751bcd0dc3e15ce081727",
    "8bb9a5000ed06856abbad268c43ce1d5ad5bdd43",
    "6e62a1a6728b1f782f64065424f92b292c3f163a",
    "c0af72c7f74b6925786e24543cac433b906dd6d3",
    "c2866ac34d063a4d2e150fe35632111b37a1514d",
    "cfb468332e482a51f0a8aea61da4fe5245419a89",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
    "9ea7c06468d236452f03c38a31d1a45f7f09dc50",
    "c1ea9b4490e7d6d030eeaeeff2fad3767d2cfd4a",
    "e0f96aa2499c8662e8945e076868511c37569309",
    "b8389e4c73b70e454525b8adcd5b0a52ae5d1db1",
    "e90a5b40430cc1fbce075d34b31e3cc05fd9831f"
  ],
  "changeHistoryShort": {
    "fccfb02672178d05f9d804f3a40f6b6b7d11efeb": "Ybodychange",
    "360a96f342f3c8cb8246f011abb9bcb0b6ef3eaa": "Ybodychange",
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389": "Ybodychange",
    "df983b524ab68ea0c70cee9033bfff2d28052cbf": "Ybodychange",
    "dcedb72af468128458e597f08d22f5c34b744ae5": "Ybodychange",
    "aeecfa24f4fb6af289920cbf8830c394e66bd78e": "Ybodychange",
    "5c0bffddc0cb824a8a2751bcd0dc3e15ce081727": "Ybodychange",
    "8bb9a5000ed06856abbad268c43ce1d5ad5bdd43": "Ybodychange",
    "6e62a1a6728b1f782f64065424f92b292c3f163a": "Ybodychange",
    "c0af72c7f74b6925786e24543cac433b906dd6d3": "Ybodychange",
    "c2866ac34d063a4d2e150fe35632111b37a1514d": "Ybodychange",
    "cfb468332e482a51f0a8aea61da4fe5245419a89": "Ybodychange",
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": "Ybodychange",
    "9ea7c06468d236452f03c38a31d1a45f7f09dc50": "Ybodychange",
    "c1ea9b4490e7d6d030eeaeeff2fad3767d2cfd4a": "Ybodychange",
    "e0f96aa2499c8662e8945e076868511c37569309": "Ybodychange",
    "b8389e4c73b70e454525b8adcd5b0a52ae5d1db1": "Ybodychange",
    "e90a5b40430cc1fbce075d34b31e3cc05fd9831f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fccfb02672178d05f9d804f3a40f6b6b7d11efeb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15199. NPE in BlockSender. Contributed by Ayush Saxena.\n",
      "commitDate": "28/02/20 5:03 AM",
      "commitName": "fccfb02672178d05f9d804f3a40f6b6b7d11efeb",
      "commitAuthor": "Surendra Singh Lilhore",
      "commitDateOld": "02/09/19 9:47 AM",
      "commitNameOld": "915cbc91c0a12cc7b4d3ef4ea951941defbbcb33",
      "commitAuthorOld": "Stephen O\u0027Donnell",
      "daysBetweenCommits": 178.84,
      "commitsBetweenForRepo": 817,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,124 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 ris.getChecksumIn() !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       try {\n         ris.readDataFully(buf, dataOff, dataLen);\n       } catch (IOException ioe) {\n         if (ioe.getMessage().startsWith(EIO_ERROR)) {\n           throw new DiskFileCorruptException(\"A disk IO error occurred\", ioe);\n         }\n         throw ioe;\n       }\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)ris.getDataIn()).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n         fileIoProvider.transferToSocketFully(\n             ris.getVolumeRef().getVolume(), sockOut, fileCh, blockInPosition,\n             dataLen, waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          * \n          * Reporting of this case is done in DataXceiver#run\n          */\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n-        /*\n-         * If we got an EIO when reading files or transferTo the client socket,\n-         * it\u0027s very likely caused by bad disk track or other file corruptions.\n-         */\n-        if (ioem.startsWith(EIO_ERROR)) {\n-          throw new DiskFileCorruptException(\"A disk IO error occurred\", e);\n-        }\n-        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n-          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n-          datanode.getBlockScanner().markSuspectBlock(\n-              ris.getVolumeRef().getVolume().getStorageID(),\n-              block);\n+        if (ioem !\u003d null) {\n+          /*\n+           * If we got an EIO when reading files or transferTo the client\n+           * socket, it\u0027s very likely caused by bad disk track or other file\n+           * corruptions.\n+           */\n+          if (ioem.startsWith(EIO_ERROR)) {\n+            throw new DiskFileCorruptException(\"A disk IO error occurred\", e);\n+          }\n+          if (!ioem.startsWith(\"Broken pipe\")\n+              \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n+            LOG.error(\"BlockSender.sendChunks() exception: \", e);\n+            datanode.getBlockScanner().markSuspectBlock(\n+                ris.getVolumeRef().getVolume().getStorageID(), block);\n+          }\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 ris.getChecksumIn() !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      try {\n        ris.readDataFully(buf, dataOff, dataLen);\n      } catch (IOException ioe) {\n        if (ioe.getMessage().startsWith(EIO_ERROR)) {\n          throw new DiskFileCorruptException(\"A disk IO error occurred\", ioe);\n        }\n        throw ioe;\n      }\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n\n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)ris.getDataIn()).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        fileIoProvider.transferToSocketFully(\n            ris.getVolumeRef().getVolume(), sockOut, fileCh, blockInPosition,\n            dataLen, waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         * \n         * Reporting of this case is done in DataXceiver#run\n         */\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (ioem !\u003d null) {\n          /*\n           * If we got an EIO when reading files or transferTo the client\n           * socket, it\u0027s very likely caused by bad disk track or other file\n           * corruptions.\n           */\n          if (ioem.startsWith(EIO_ERROR)) {\n            throw new DiskFileCorruptException(\"A disk IO error occurred\", e);\n          }\n          if (!ioem.startsWith(\"Broken pipe\")\n              \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n            LOG.error(\"BlockSender.sendChunks() exception: \", e);\n            datanode.getBlockScanner().markSuspectBlock(\n                ris.getVolumeRef().getVolume().getStorageID(), block);\n          }\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "360a96f342f3c8cb8246f011abb9bcb0b6ef3eaa": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13709. Report bad block to NN when transfer block encounter EIO exception. Contributed by Chen Zhang.\n",
      "commitDate": "19/08/19 1:08 PM",
      "commitName": "360a96f342f3c8cb8246f011abb9bcb0b6ef3eaa",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "19/10/18 10:36 AM",
      "commitNameOld": "8b64fbab1a4c7d65a5daf515c2d170d6a2fd4917",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 304.11,
      "commitsBetweenForRepo": 2233,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,121 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 ris.getChecksumIn() !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n-      ris.readDataFully(buf, dataOff, dataLen);\n+      try {\n+        ris.readDataFully(buf, dataOff, dataLen);\n+      } catch (IOException ioe) {\n+        if (ioe.getMessage().startsWith(EIO_ERROR)) {\n+          throw new DiskFileCorruptException(\"A disk IO error occurred\", ioe);\n+        }\n+        throw ioe;\n+      }\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)ris.getDataIn()).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n         fileIoProvider.transferToSocketFully(\n             ris.getVolumeRef().getVolume(), sockOut, fileCh, blockInPosition,\n             dataLen, waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          * \n          * Reporting of this case is done in DataXceiver#run\n          */\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n+        /*\n+         * If we got an EIO when reading files or transferTo the client socket,\n+         * it\u0027s very likely caused by bad disk track or other file corruptions.\n+         */\n+        if (ioem.startsWith(EIO_ERROR)) {\n+          throw new DiskFileCorruptException(\"A disk IO error occurred\", e);\n+        }\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n           datanode.getBlockScanner().markSuspectBlock(\n               ris.getVolumeRef().getVolume().getStorageID(),\n               block);\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 ris.getChecksumIn() !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      try {\n        ris.readDataFully(buf, dataOff, dataLen);\n      } catch (IOException ioe) {\n        if (ioe.getMessage().startsWith(EIO_ERROR)) {\n          throw new DiskFileCorruptException(\"A disk IO error occurred\", ioe);\n        }\n        throw ioe;\n      }\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n\n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)ris.getDataIn()).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        fileIoProvider.transferToSocketFully(\n            ris.getVolumeRef().getVolume(), sockOut, fileCh, blockInPosition,\n            dataLen, waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         * \n         * Reporting of this case is done in DataXceiver#run\n         */\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        /*\n         * If we got an EIO when reading files or transferTo the client socket,\n         * it\u0027s very likely caused by bad disk track or other file corruptions.\n         */\n        if (ioem.startsWith(EIO_ERROR)) {\n          throw new DiskFileCorruptException(\"A disk IO error occurred\", e);\n        }\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n          datanode.getBlockScanner().markSuspectBlock(\n              ris.getVolumeRef().getVolume().getStorageID(),\n              block);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10958. Add instrumentation hooks around Datanode disk IO.\n",
      "commitDate": "14/12/16 11:18 AM",
      "commitName": "6ba9587d370fbf39c129c08c00ebbb894ccc1389",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "06/12/16 11:05 AM",
      "commitNameOld": "df983b524ab68ea0c70cee9033bfff2d28052cbf",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 8.01,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,108 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 ris.getChecksumIn() !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       ris.readDataFully(buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)ris.getDataIn()).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n-        sockOut.transferToFully(fileCh, blockInPosition, dataLen,\n-            waitTime, transferTime);\n+        fileIoProvider.transferToSocketFully(\n+            ris.getVolumeRef().getVolume(), sockOut, fileCh, blockInPosition,\n+            dataLen, waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          * \n          * Reporting of this case is done in DataXceiver#run\n          */\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n           datanode.getBlockScanner().markSuspectBlock(\n               ris.getVolumeRef().getVolume().getStorageID(),\n               block);\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 ris.getChecksumIn() !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      ris.readDataFully(buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n\n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)ris.getDataIn()).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        fileIoProvider.transferToSocketFully(\n            ris.getVolumeRef().getVolume(), sockOut, fileCh, blockInPosition,\n            dataLen, waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         * \n         * Reporting of this case is done in DataXceiver#run\n         */\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n          datanode.getBlockScanner().markSuspectBlock(\n              ris.getVolumeRef().getVolume().getStorageID(),\n              block);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "df983b524ab68ea0c70cee9033bfff2d28052cbf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10930. Refactor: Wrap Datanode IO related operations. Contributed by Xiaoyu Yao.\n",
      "commitDate": "06/12/16 11:05 AM",
      "commitName": "df983b524ab68ea0c70cee9033bfff2d28052cbf",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "05/12/16 12:44 PM",
      "commitNameOld": "dcedb72af468128458e597f08d22f5c34b744ae5",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 0.93,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,107 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n-    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n+    if (checksumSize \u003e 0 \u0026\u0026 ris.getChecksumIn() !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n-      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n+      ris.readDataFully(buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n-        \n+\n         // no need to flush since we know out is not a buffered stream\n-        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n+        FileChannel fileCh \u003d ((FileInputStream)ris.getDataIn()).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n-        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n+        sockOut.transferToFully(fileCh, blockInPosition, dataLen,\n             waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          * \n          * Reporting of this case is done in DataXceiver#run\n          */\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n           datanode.getBlockScanner().markSuspectBlock(\n-              volumeRef.getVolume().getStorageID(),\n+              ris.getVolumeRef().getVolume().getStorageID(),\n               block);\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 ris.getChecksumIn() !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      ris.readDataFully(buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n\n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)ris.getDataIn()).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen,\n            waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         * \n         * Reporting of this case is done in DataXceiver#run\n         */\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n          datanode.getBlockScanner().markSuspectBlock(\n              ris.getVolumeRef().getVolume().getStorageID(),\n              block);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "dcedb72af468128458e597f08d22f5c34b744ae5": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-10930. Refactor: Wrap Datanode IO related operations. Contributed by Xiaoyu Yao.\"\n\nThis reverts commit aeecfa24f4fb6af289920cbf8830c394e66bd78e.\n",
      "commitDate": "05/12/16 12:44 PM",
      "commitName": "dcedb72af468128458e597f08d22f5c34b744ae5",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "29/11/16 8:52 PM",
      "commitNameOld": "aeecfa24f4fb6af289920cbf8830c394e66bd78e",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 5.66,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,107 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n-    if (checksumSize \u003e 0 \u0026\u0026 ris.getChecksumIn() !\u003d null) {\n+    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n-      ris.readDataFully(buf, dataOff, dataLen);\n+      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n-\n+        \n         // no need to flush since we know out is not a buffered stream\n-        FileChannel fileCh \u003d ((FileInputStream)ris.getDataIn()).getChannel();\n+        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n-        sockOut.transferToFully(fileCh, blockInPosition, dataLen,\n+        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n             waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          * \n          * Reporting of this case is done in DataXceiver#run\n          */\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n           datanode.getBlockScanner().markSuspectBlock(\n-              ris.getVolumeRef().getVolume().getStorageID(),\n+              volumeRef.getVolume().getStorageID(),\n               block);\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n        \n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n            waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         * \n         * Reporting of this case is done in DataXceiver#run\n         */\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n          datanode.getBlockScanner().markSuspectBlock(\n              volumeRef.getVolume().getStorageID(),\n              block);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "aeecfa24f4fb6af289920cbf8830c394e66bd78e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10930. Refactor: Wrap Datanode IO related operations. Contributed by Xiaoyu Yao.\n",
      "commitDate": "29/11/16 8:52 PM",
      "commitName": "aeecfa24f4fb6af289920cbf8830c394e66bd78e",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "27/10/16 4:14 AM",
      "commitNameOld": "1cf6ec4ad4e1f4ea71f912923b5e8627b61ef482",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 33.74,
      "commitsBetweenForRepo": 277,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,107 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n-    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n+    if (checksumSize \u003e 0 \u0026\u0026 ris.getChecksumIn() !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n-      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n+      ris.readDataFully(buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n-        \n+\n         // no need to flush since we know out is not a buffered stream\n-        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n+        FileChannel fileCh \u003d ((FileInputStream)ris.getDataIn()).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n-        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n+        sockOut.transferToFully(fileCh, blockInPosition, dataLen,\n             waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          * \n          * Reporting of this case is done in DataXceiver#run\n          */\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n           datanode.getBlockScanner().markSuspectBlock(\n-              volumeRef.getVolume().getStorageID(),\n+              ris.getVolumeRef().getVolume().getStorageID(),\n               block);\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 ris.getChecksumIn() !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      ris.readDataFully(buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n\n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)ris.getDataIn()).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen,\n            waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         * \n         * Reporting of this case is done in DataXceiver#run\n         */\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n          datanode.getBlockScanner().markSuspectBlock(\n              ris.getVolumeRef().getVolume().getStorageID(),\n              block);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "5c0bffddc0cb824a8a2751bcd0dc3e15ce081727": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10627. Volume Scanner marks a block as \"suspect\" even if the exception is network-related. Contributed by Rushabh S Shah.\n",
      "commitDate": "20/10/16 8:48 AM",
      "commitName": "5c0bffddc0cb824a8a2751bcd0dc3e15ce081727",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "13/09/16 12:54 PM",
      "commitNameOld": "86c9862bec0248d671e657aa56094a2919b8ac14",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 36.83,
      "commitsBetweenForRepo": 249,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,107 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n         \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n         sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n             waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          * \n          * Reporting of this case is done in DataXceiver#run\n          */\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n-        }\n-        datanode.getBlockScanner().markSuspectBlock(\n+          datanode.getBlockScanner().markSuspectBlock(\n               volumeRef.getVolume().getStorageID(),\n               block);\n+        }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n        \n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n            waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         * \n         * Reporting of this case is done in DataXceiver#run\n         */\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n          datanode.getBlockScanner().markSuspectBlock(\n              volumeRef.getVolume().getStorageID(),\n              block);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "8bb9a5000ed06856abbad268c43ce1d5ad5bdd43": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7686. Re-add rapid rescan of possibly corrupt block feature to the block scanner (cmccabe)\n",
      "commitDate": "13/02/15 2:35 PM",
      "commitName": "8bb9a5000ed06856abbad268c43ce1d5ad5bdd43",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "30/01/15 4:01 PM",
      "commitNameOld": "09ad9a868a89922e9b55b3e7c5b9f41fa54d3770",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 13.94,
      "commitsBetweenForRepo": 176,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,107 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n         \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n         sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n             waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          * \n          * Reporting of this case is done in DataXceiver#run\n          */\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n         }\n+        datanode.getBlockScanner().markSuspectBlock(\n+              volumeRef.getVolume().getStorageID(),\n+              block);\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n        \n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n            waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         * \n         * Reporting of this case is done in DataXceiver#run\n         */\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n        }\n        datanode.getBlockScanner().markSuspectBlock(\n              volumeRef.getVolume().getStorageID(),\n              block);\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "6e62a1a6728b1f782f64065424f92b292c3f163a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7430. Refactor the BlockScanner to use O(1) memory and use multiple threads (cmccabe)\n",
      "commitDate": "21/01/15 7:00 PM",
      "commitName": "6e62a1a6728b1f782f64065424f92b292c3f163a",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "21/01/15 12:41 PM",
      "commitNameOld": "c0af72c7f74b6925786e24543cac433b906dd6d3",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,104 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n         \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n         sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n             waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          * \n          * Reporting of this case is done in DataXceiver#run\n          */\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n-          //Something might be wrong with the block. Make this block the high \n-          //priority block for verification.\n-          datanode.blockScanner.addBlock(block, true);\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n        \n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n            waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         * \n         * Reporting of this case is done in DataXceiver#run\n         */\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "c0af72c7f74b6925786e24543cac433b906dd6d3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7548. Corrupt block reporting delayed until datablock scanner thread detects it. Contributed by Rushabh Shah.\n",
      "commitDate": "21/01/15 12:41 PM",
      "commitName": "c0af72c7f74b6925786e24543cac433b906dd6d3",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "20/01/15 7:05 PM",
      "commitNameOld": "b7f4a3156c0f5c600816c469637237ba6c9b330c",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 0.73,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,107 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n         \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n         sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n             waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          * \n          * Reporting of this case is done in DataXceiver#run\n          */\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n+          //Something might be wrong with the block. Make this block the high \n+          //priority block for verification.\n+          datanode.blockScanner.addBlock(block, true);\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n        \n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n            waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         * \n         * Reporting of this case is done in DataXceiver#run\n         */\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n          //Something might be wrong with the block. Make this block the high \n          //priority block for verification.\n          datanode.blockScanner.addBlock(block, true);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "c2866ac34d063a4d2e150fe35632111b37a1514d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3342. SocketTimeoutException in BlockSender.sendChunks could have a better error message. Contributed by Yongjun Zhang.\n",
      "commitDate": "30/10/14 11:04 AM",
      "commitName": "c2866ac34d063a4d2e150fe35632111b37a1514d",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "27/10/14 9:38 AM",
      "commitNameOld": "463aec11718e47d4aabb86a7a539cb973460aae6",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 3.06,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,104 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n         \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n         sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n             waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n+         * \n+         * Reporting of this case is done in DataXceiver#run\n          */\n-        if (LOG.isTraceEnabled()) {\n-          LOG.trace(\"Failed to send data:\", e);\n-        } else {\n-          LOG.info(\"Failed to send data: \" + e);\n-        }\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n        \n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n            waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         * \n         * Reporting of this case is done in DataXceiver#run\n         */\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "cfb468332e482a51f0a8aea61da4fe5245419a89": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6123. Do not log stack trace for ReplicaAlreadyExistsException and SocketTimeoutException.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1579396 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/03/14 2:04 PM",
      "commitName": "cfb468332e482a51f0a8aea61da4fe5245419a89",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "19/11/13 4:48 PM",
      "commitNameOld": "efea68dc3538de9aafae206d64903506e41fc9e1",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 119.84,
      "commitsBetweenForRepo": 846,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,107 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n         \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n         sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n             waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          */\n-          LOG.info(\"exception: \", e);\n+        if (LOG.isTraceEnabled()) {\n+          LOG.trace(\"Failed to send data:\", e);\n+        } else {\n+          LOG.info(\"Failed to send data: \" + e);\n+        }\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n        \n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n            waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         */\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Failed to send data:\", e);\n        } else {\n          LOG.info(\"Failed to send data: \" + e);\n        }\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "cea7bbc630deede93dbe6a1bbda56ad49de4f3de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4122. Cleanup HDFS logs and reduce the size of logged messages. Contributed by Suresh Srinivas.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1403120 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/10/12 4:10 PM",
      "commitName": "cea7bbc630deede93dbe6a1bbda56ad49de4f3de",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "15/08/12 6:32 PM",
      "commitNameOld": "3cab01ba6e0349126a23063e135cd5c814a4ae18",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 73.9,
      "commitsBetweenForRepo": 454,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,103 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     // The packet buffer is organized as follows:\n     // _______HHHHCCCCD?D?D?D?\n     //        ^   ^\n     //        |   \\ checksumOff\n     //        \\ headerOff\n     // _ padding, since the header is variable-length\n     // H \u003d header and length prefixes\n     // C \u003d checksums\n     // D? \u003d data, if transferTo is false.\n     \n     int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n     \n     // Per above, the header doesn\u0027t start at the beginning of the\n     // buffer\n     int headerOff \u003d pkt.position() - headerLen;\n     \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         // First write header and checksums\n         sockOut.write(buf, headerOff, dataOff - headerOff);\n         \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n         sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n             waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n         out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          */\n-          LOG.info(\"BlockSender.sendChunks() exception: \", e);\n+          LOG.info(\"exception: \", e);\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n        \n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n            waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         */\n          LOG.info(\"exception: \", e);\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "9ea7c06468d236452f03c38a31d1a45f7f09dc50": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3721. hsync support broke wire compatibility. Contributed by Todd Lipcon and Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1371495 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/08/12 2:31 PM",
      "commitName": "9ea7c06468d236452f03c38a31d1a45f7f09dc50",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "07/08/12 1:17 PM",
      "commitNameOld": "c12e994eda0f7e0c34fb0c0ff208789586c7142c",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 2.05,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,103 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n-    writePacketHeader(pkt, dataLen, packetLen);\n-\n+    // The packet buffer is organized as follows:\n+    // _______HHHHCCCCD?D?D?D?\n+    //        ^   ^\n+    //        |   \\ checksumOff\n+    //        \\ headerOff\n+    // _ padding, since the header is variable-length\n+    // H \u003d header and length prefixes\n+    // C \u003d checksums\n+    // D? \u003d data, if transferTo is false.\n+    \n+    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n+    \n+    // Per above, the header doesn\u0027t start at the beginning of the\n+    // buffer\n+    int headerOff \u003d pkt.position() - headerLen;\n+    \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n-        sockOut.write(buf, 0, dataOff); // First write checksum\n+        // First write header and checksums\n+        sockOut.write(buf, headerOff, dataOff - headerOff);\n         \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n         LongWritable waitTime \u003d new LongWritable();\n         LongWritable transferTime \u003d new LongWritable();\n         sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n             waitTime, transferTime);\n         datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n         datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n       } else {\n         // normal transfer\n-        out.write(buf, 0, dataOff + dataLen);\n+        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          */\n           LOG.info(\"BlockSender.sendChunks() exception: \", e);\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    // The packet buffer is organized as follows:\n    // _______HHHHCCCCD?D?D?D?\n    //        ^   ^\n    //        |   \\ checksumOff\n    //        \\ headerOff\n    // _ padding, since the header is variable-length\n    // H \u003d header and length prefixes\n    // C \u003d checksums\n    // D? \u003d data, if transferTo is false.\n    \n    int headerLen \u003d writePacketHeader(pkt, dataLen, packetLen);\n    \n    // Per above, the header doesn\u0027t start at the beginning of the\n    // buffer\n    int headerOff \u003d pkt.position() - headerLen;\n    \n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        // First write header and checksums\n        sockOut.write(buf, headerOff, dataOff - headerOff);\n        \n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n            waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, headerOff, dataOff + dataLen - headerOff);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         */\n          LOG.info(\"BlockSender.sendChunks() exception: \", e);\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "c1ea9b4490e7d6d030eeaeeff2fad3767d2cfd4a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3650. Use MutableQuantiles to provide latency histograms for various operations. Contributed by Andrew Wang.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1366246 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/07/12 5:26 PM",
      "commitName": "c1ea9b4490e7d6d030eeaeeff2fad3767d2cfd4a",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "15/07/12 7:58 PM",
      "commitNameOld": "0e8e499ff482c165d21c8e4f5ff9c33f306ca0d9",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 10.89,
      "commitsBetweenForRepo": 61,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,88 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     writePacketHeader(pkt, dataLen, packetLen);\n \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         sockOut.write(buf, 0, dataOff); // First write checksum\n         \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n+        LongWritable waitTime \u003d new LongWritable();\n+        LongWritable transferTime \u003d new LongWritable();\n         sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n-            datanode.metrics.getSendDataPacketBlockedOnNetworkNanos(),\n-            datanode.metrics.getSendDataPacketTransferNanos());\n+            waitTime, transferTime);\n+        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n+        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n         blockInPosition +\u003d dataLen;\n-      } else { \n+      } else {\n         // normal transfer\n         out.write(buf, 0, dataOff + dataLen);\n       }\n     } catch (IOException e) {\n       if (e instanceof SocketTimeoutException) {\n         /*\n          * writing to client timed out.  This happens if the client reads\n          * part of a block and then decides not to read the rest (but leaves\n          * the socket open).\n          */\n           LOG.info(\"BlockSender.sendChunks() exception: \", e);\n       } else {\n         /* Exception while writing to the client. Connection closure from\n          * the other end is mostly the case and we do not care much about\n          * it. But other things can go wrong, especially in transferTo(),\n          * which we do not want to ignore.\n          *\n          * The message parsing below should not be considered as a good\n          * coding example. NEVER do it to drive a program logic. NEVER.\n          * It was done here because the NIO throws an IOException for EPIPE.\n          */\n         String ioem \u003d e.getMessage();\n         if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n           LOG.error(\"BlockSender.sendChunks() exception: \", e);\n         }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    writePacketHeader(pkt, dataLen, packetLen);\n\n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        sockOut.write(buf, 0, dataOff); // First write checksum\n        \n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n        LongWritable waitTime \u003d new LongWritable();\n        LongWritable transferTime \u003d new LongWritable();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n            waitTime, transferTime);\n        datanode.metrics.addSendDataPacketBlockedOnNetworkNanos(waitTime.get());\n        datanode.metrics.addSendDataPacketTransferNanos(transferTime.get());\n        blockInPosition +\u003d dataLen;\n      } else {\n        // normal transfer\n        out.write(buf, 0, dataOff + dataLen);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         */\n          LOG.info(\"BlockSender.sendChunks() exception: \", e);\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "e0f96aa2499c8662e8945e076868511c37569309": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3555. idle client socket triggers DN ERROR log (should be INFO or DEBUG). Contributed by Andy Isaacson. (harsh)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1359619 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/12 4:52 AM",
      "commitName": "e0f96aa2499c8662e8945e076868511c37569309",
      "commitAuthor": "Harsh J",
      "commitDateOld": "03/07/12 1:45 PM",
      "commitNameOld": "b8389e4c73b70e454525b8adcd5b0a52ae5d1db1",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 6.63,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,85 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     writePacketHeader(pkt, dataLen, packetLen);\n \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         sockOut.write(buf, 0, dataOff); // First write checksum\n         \n         // no need to flush since we know out is not a buffered stream\n         FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n         sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n             datanode.metrics.getSendDataPacketBlockedOnNetworkNanos(),\n             datanode.metrics.getSendDataPacketTransferNanos());\n         blockInPosition +\u003d dataLen;\n       } else { \n         // normal transfer\n         out.write(buf, 0, dataOff + dataLen);\n       }\n     } catch (IOException e) {\n-      /* Exception while writing to the client. Connection closure from\n-       * the other end is mostly the case and we do not care much about\n-       * it. But other things can go wrong, especially in transferTo(),\n-       * which we do not want to ignore.\n-       *\n-       * The message parsing below should not be considered as a good\n-       * coding example. NEVER do it to drive a program logic. NEVER.\n-       * It was done here because the NIO throws an IOException for EPIPE.\n-       */\n-      String ioem \u003d e.getMessage();\n-      if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n-        LOG.error(\"BlockSender.sendChunks() exception: \", e);\n+      if (e instanceof SocketTimeoutException) {\n+        /*\n+         * writing to client timed out.  This happens if the client reads\n+         * part of a block and then decides not to read the rest (but leaves\n+         * the socket open).\n+         */\n+          LOG.info(\"BlockSender.sendChunks() exception: \", e);\n+      } else {\n+        /* Exception while writing to the client. Connection closure from\n+         * the other end is mostly the case and we do not care much about\n+         * it. But other things can go wrong, especially in transferTo(),\n+         * which we do not want to ignore.\n+         *\n+         * The message parsing below should not be considered as a good\n+         * coding example. NEVER do it to drive a program logic. NEVER.\n+         * It was done here because the NIO throws an IOException for EPIPE.\n+         */\n+        String ioem \u003d e.getMessage();\n+        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n+          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n+        }\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    writePacketHeader(pkt, dataLen, packetLen);\n\n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        sockOut.write(buf, 0, dataOff); // First write checksum\n        \n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n            datanode.metrics.getSendDataPacketBlockedOnNetworkNanos(),\n            datanode.metrics.getSendDataPacketTransferNanos());\n        blockInPosition +\u003d dataLen;\n      } else { \n        // normal transfer\n        out.write(buf, 0, dataOff + dataLen);\n      }\n    } catch (IOException e) {\n      if (e instanceof SocketTimeoutException) {\n        /*\n         * writing to client timed out.  This happens if the client reads\n         * part of a block and then decides not to read the rest (but leaves\n         * the socket open).\n         */\n          LOG.info(\"BlockSender.sendChunks() exception: \", e);\n      } else {\n        /* Exception while writing to the client. Connection closure from\n         * the other end is mostly the case and we do not care much about\n         * it. But other things can go wrong, especially in transferTo(),\n         * which we do not want to ignore.\n         *\n         * The message parsing below should not be considered as a good\n         * coding example. NEVER do it to drive a program logic. NEVER.\n         * It was done here because the NIO throws an IOException for EPIPE.\n         */\n        String ioem \u003d e.getMessage();\n        if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n          LOG.error(\"BlockSender.sendChunks() exception: \", e);\n        }\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "b8389e4c73b70e454525b8adcd5b0a52ae5d1db1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3343. Improve metrics for DN read latency. Contributed by Andrew Wang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1356928 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/07/12 1:45 PM",
      "commitName": "b8389e4c73b70e454525b8adcd5b0a52ae5d1db1",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "30/05/12 12:10 PM",
      "commitNameOld": "83cf475050dba27e72b4e399491638c670621175",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 34.07,
      "commitsBetweenForRepo": 150,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,76 @@\n   private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n       boolean transferTo, DataTransferThrottler throttler) throws IOException {\n     int dataLen \u003d (int) Math.min(endOffset - offset,\n                              (chunkSize * (long) maxChunks));\n     \n     int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n     int checksumDataLen \u003d numChunks * checksumSize;\n     int packetLen \u003d dataLen + checksumDataLen + 4;\n     boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n \n     writePacketHeader(pkt, dataLen, packetLen);\n \n     int checksumOff \u003d pkt.position();\n     byte[] buf \u003d pkt.array();\n     \n     if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n       readChecksum(buf, checksumOff, checksumDataLen);\n \n       // write in progress that we need to use to get last checksum\n       if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n         int start \u003d checksumOff + checksumDataLen - checksumSize;\n         byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n         \n         if (updatedChecksum !\u003d null) {\n           System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n         }\n       }\n     }\n     \n     int dataOff \u003d checksumOff + checksumDataLen;\n     if (!transferTo) { // normal transfer\n       IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n \n       if (verifyChecksum) {\n         verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n       }\n     }\n     \n     try {\n       if (transferTo) {\n         SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n         sockOut.write(buf, 0, dataOff); // First write checksum\n         \n-        // no need to flush. since we know out is not a buffered stream. \n-        sockOut.transferToFully(((FileInputStream)blockIn).getChannel(), \n-                                blockInPosition, dataLen);\n+        // no need to flush since we know out is not a buffered stream\n+        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n+        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n+            datanode.metrics.getSendDataPacketBlockedOnNetworkNanos(),\n+            datanode.metrics.getSendDataPacketTransferNanos());\n         blockInPosition +\u003d dataLen;\n       } else { \n         // normal transfer\n         out.write(buf, 0, dataOff + dataLen);\n       }\n     } catch (IOException e) {\n       /* Exception while writing to the client. Connection closure from\n        * the other end is mostly the case and we do not care much about\n        * it. But other things can go wrong, especially in transferTo(),\n        * which we do not want to ignore.\n        *\n        * The message parsing below should not be considered as a good\n        * coding example. NEVER do it to drive a program logic. NEVER.\n        * It was done here because the NIO throws an IOException for EPIPE.\n        */\n       String ioem \u003d e.getMessage();\n       if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n         LOG.error(\"BlockSender.sendChunks() exception: \", e);\n       }\n       throw ioeToSocketException(e);\n     }\n \n     if (throttler !\u003d null) { // rebalancing so throttle\n       throttler.throttle(packetLen);\n     }\n \n     return dataLen;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    writePacketHeader(pkt, dataLen, packetLen);\n\n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        sockOut.write(buf, 0, dataOff); // First write checksum\n        \n        // no need to flush since we know out is not a buffered stream\n        FileChannel fileCh \u003d ((FileInputStream)blockIn).getChannel();\n        sockOut.transferToFully(fileCh, blockInPosition, dataLen, \n            datanode.metrics.getSendDataPacketBlockedOnNetworkNanos(),\n            datanode.metrics.getSendDataPacketTransferNanos());\n        blockInPosition +\u003d dataLen;\n      } else { \n        // normal transfer\n        out.write(buf, 0, dataOff + dataLen);\n      }\n    } catch (IOException e) {\n      /* Exception while writing to the client. Connection closure from\n       * the other end is mostly the case and we do not care much about\n       * it. But other things can go wrong, especially in transferTo(),\n       * which we do not want to ignore.\n       *\n       * The message parsing below should not be considered as a good\n       * coding example. NEVER do it to drive a program logic. NEVER.\n       * It was done here because the NIO throws an IOException for EPIPE.\n       */\n      String ioem \u003d e.getMessage();\n      if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n        LOG.error(\"BlockSender.sendChunks() exception: \", e);\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java",
      "extendedDetails": {}
    },
    "e90a5b40430cc1fbce075d34b31e3cc05fd9831f": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2371. Refactor BlockSender.java for better readability. Contributed by Suresh Srinivas.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1177161 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/09/11 9:40 PM",
      "commitName": "e90a5b40430cc1fbce075d34b31e3cc05fd9831f",
      "commitAuthor": "Suresh Srinivas",
      "diff": "@@ -0,0 +1,74 @@\n+  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n+      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n+    int dataLen \u003d (int) Math.min(endOffset - offset,\n+                             (chunkSize * (long) maxChunks));\n+    \n+    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n+    int checksumDataLen \u003d numChunks * checksumSize;\n+    int packetLen \u003d dataLen + checksumDataLen + 4;\n+    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n+\n+    writePacketHeader(pkt, dataLen, packetLen);\n+\n+    int checksumOff \u003d pkt.position();\n+    byte[] buf \u003d pkt.array();\n+    \n+    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n+      readChecksum(buf, checksumOff, checksumDataLen);\n+\n+      // write in progress that we need to use to get last checksum\n+      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n+        int start \u003d checksumOff + checksumDataLen - checksumSize;\n+        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n+        \n+        if (updatedChecksum !\u003d null) {\n+          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n+        }\n+      }\n+    }\n+    \n+    int dataOff \u003d checksumOff + checksumDataLen;\n+    if (!transferTo) { // normal transfer\n+      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n+\n+      if (verifyChecksum) {\n+        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n+      }\n+    }\n+    \n+    try {\n+      if (transferTo) {\n+        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n+        sockOut.write(buf, 0, dataOff); // First write checksum\n+        \n+        // no need to flush. since we know out is not a buffered stream. \n+        sockOut.transferToFully(((FileInputStream)blockIn).getChannel(), \n+                                blockInPosition, dataLen);\n+        blockInPosition +\u003d dataLen;\n+      } else { \n+        // normal transfer\n+        out.write(buf, 0, dataOff + dataLen);\n+      }\n+    } catch (IOException e) {\n+      /* Exception while writing to the client. Connection closure from\n+       * the other end is mostly the case and we do not care much about\n+       * it. But other things can go wrong, especially in transferTo(),\n+       * which we do not want to ignore.\n+       *\n+       * The message parsing below should not be considered as a good\n+       * coding example. NEVER do it to drive a program logic. NEVER.\n+       * It was done here because the NIO throws an IOException for EPIPE.\n+       */\n+      String ioem \u003d e.getMessage();\n+      if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n+        LOG.error(\"BlockSender.sendChunks() exception: \", e);\n+      }\n+      throw ioeToSocketException(e);\n+    }\n+\n+    if (throttler !\u003d null) { // rebalancing so throttle\n+      throttler.throttle(packetLen);\n+    }\n+\n+    return dataLen;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private int sendPacket(ByteBuffer pkt, int maxChunks, OutputStream out,\n      boolean transferTo, DataTransferThrottler throttler) throws IOException {\n    int dataLen \u003d (int) Math.min(endOffset - offset,\n                             (chunkSize * (long) maxChunks));\n    \n    int numChunks \u003d numberOfChunks(dataLen); // Number of chunks be sent in the packet\n    int checksumDataLen \u003d numChunks * checksumSize;\n    int packetLen \u003d dataLen + checksumDataLen + 4;\n    boolean lastDataPacket \u003d offset + dataLen \u003d\u003d endOffset \u0026\u0026 dataLen \u003e 0;\n\n    writePacketHeader(pkt, dataLen, packetLen);\n\n    int checksumOff \u003d pkt.position();\n    byte[] buf \u003d pkt.array();\n    \n    if (checksumSize \u003e 0 \u0026\u0026 checksumIn !\u003d null) {\n      readChecksum(buf, checksumOff, checksumDataLen);\n\n      // write in progress that we need to use to get last checksum\n      if (lastDataPacket \u0026\u0026 lastChunkChecksum !\u003d null) {\n        int start \u003d checksumOff + checksumDataLen - checksumSize;\n        byte[] updatedChecksum \u003d lastChunkChecksum.getChecksum();\n        \n        if (updatedChecksum !\u003d null) {\n          System.arraycopy(updatedChecksum, 0, buf, start, checksumSize);\n        }\n      }\n    }\n    \n    int dataOff \u003d checksumOff + checksumDataLen;\n    if (!transferTo) { // normal transfer\n      IOUtils.readFully(blockIn, buf, dataOff, dataLen);\n\n      if (verifyChecksum) {\n        verifyChecksum(buf, dataOff, dataLen, numChunks, checksumOff);\n      }\n    }\n    \n    try {\n      if (transferTo) {\n        SocketOutputStream sockOut \u003d (SocketOutputStream)out;\n        sockOut.write(buf, 0, dataOff); // First write checksum\n        \n        // no need to flush. since we know out is not a buffered stream. \n        sockOut.transferToFully(((FileInputStream)blockIn).getChannel(), \n                                blockInPosition, dataLen);\n        blockInPosition +\u003d dataLen;\n      } else { \n        // normal transfer\n        out.write(buf, 0, dataOff + dataLen);\n      }\n    } catch (IOException e) {\n      /* Exception while writing to the client. Connection closure from\n       * the other end is mostly the case and we do not care much about\n       * it. But other things can go wrong, especially in transferTo(),\n       * which we do not want to ignore.\n       *\n       * The message parsing below should not be considered as a good\n       * coding example. NEVER do it to drive a program logic. NEVER.\n       * It was done here because the NIO throws an IOException for EPIPE.\n       */\n      String ioem \u003d e.getMessage();\n      if (!ioem.startsWith(\"Broken pipe\") \u0026\u0026 !ioem.startsWith(\"Connection reset\")) {\n        LOG.error(\"BlockSender.sendChunks() exception: \", e);\n      }\n      throw ioeToSocketException(e);\n    }\n\n    if (throttler !\u003d null) { // rebalancing so throttle\n      throttler.throttle(packetLen);\n    }\n\n    return dataLen;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/BlockSender.java"
    }
  }
}