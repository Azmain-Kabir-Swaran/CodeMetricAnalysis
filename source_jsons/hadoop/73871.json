{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Server.java",
  "functionName": "saslReadAndProcess",
  "functionId": "saslReadAndProcess___buffer-RpcWritable.Buffer",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
  "functionStartLine": 1944,
  "functionEndLine": 1962,
  "numCommitsSeen": 371,
  "timeTaken": 8426,
  "changeHistory": [
    "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
    "580a8334963709e728ed677c815fb7fef9bca70e",
    "c03c8fe199429a43c6aa944016566738abd9b193",
    "f5312aedb9fa3dc895d61844b5c3202b02554f80",
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
    "5f9b4c14a175873b4f82654513e289c657c694eb",
    "fc0a4de670c3e6dcf5d30305d3969fe4946a0fed",
    "3337588975fa24c0044408c6caf91abea4dca4d4",
    "fe8f635b78d59e286771ec75ff73245b40d30907",
    "1594dd6965c412a08339a0079ee1416dd6f595f9",
    "d94899877709836153244c2f0c5f14c37c9d4795",
    "4ceca97606e7258e807867bbcd8cc60d0cce7439",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "8a2b40d0726215e48b53ab22382dd49379c36249",
    "c0d70530b173beb2d53a4175236520df8e3967c8",
    "4b9c956bc56cec2c5b669102340d0912e0db3517",
    "f4998a781376e1f15a2b72135eaa3db38bebde99",
    "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf",
    "c4c122a0def592136e03a653c9fdc4f464ed0854",
    "ffdde40b9f189cb30dee4c5187d63b61809f2d62",
    "1793e7d9094cd984ae402177c5935239059d74e8",
    "940389afce6a1b9b9e1519aed528cbc444786756"
  ],
  "changeHistoryShort": {
    "b6bb99c18a772d2179d5cc6757cddf141e8d39c0": "Ymultichange(Yexceptionschange,Ybodychange)",
    "580a8334963709e728ed677c815fb7fef9bca70e": "Ymultichange(Yparameterchange,Ybodychange)",
    "c03c8fe199429a43c6aa944016566738abd9b193": "Ybodychange",
    "f5312aedb9fa3dc895d61844b5c3202b02554f80": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d": "Ymultichange(Yparameterchange,Yreturntypechange,Yexceptionschange,Ybodychange)",
    "5f9b4c14a175873b4f82654513e289c657c694eb": "Ybodychange",
    "fc0a4de670c3e6dcf5d30305d3969fe4946a0fed": "Ybodychange",
    "3337588975fa24c0044408c6caf91abea4dca4d4": "Ybodychange",
    "fe8f635b78d59e286771ec75ff73245b40d30907": "Ybodychange",
    "1594dd6965c412a08339a0079ee1416dd6f595f9": "Ybodychange",
    "d94899877709836153244c2f0c5f14c37c9d4795": "Ybodychange",
    "4ceca97606e7258e807867bbcd8cc60d0cce7439": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "8a2b40d0726215e48b53ab22382dd49379c36249": "Ybodychange",
    "c0d70530b173beb2d53a4175236520df8e3967c8": "Ybodychange",
    "4b9c956bc56cec2c5b669102340d0912e0db3517": "Ybodychange",
    "f4998a781376e1f15a2b72135eaa3db38bebde99": "Ybodychange",
    "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf": "Ybodychange",
    "c4c122a0def592136e03a653c9fdc4f464ed0854": "Ybodychange",
    "ffdde40b9f189cb30dee4c5187d63b61809f2d62": "Ybodychange",
    "1793e7d9094cd984ae402177c5935239059d74e8": "Ybodychange",
    "940389afce6a1b9b9e1519aed528cbc444786756": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b6bb99c18a772d2179d5cc6757cddf141e8d39c0": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.\n",
      "commitDate": "09/02/17 8:47 AM",
      "commitName": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.\n",
          "commitDate": "09/02/17 8:47 AM",
          "commitName": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "28/11/16 9:07 PM",
          "commitNameOld": "67d9f2808efb34b9a7b0b824cb4033b95ad33474",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 72.49,
          "commitsBetweenForRepo": 352,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,19 @@\n     private void saslReadAndProcess(RpcWritable.Buffer buffer) throws\n-    WrappedRpcServerException, IOException, InterruptedException {\n+        RpcServerException, IOException, InterruptedException {\n       final RpcSaslProto saslMessage \u003d\n           getMessage(RpcSaslProto.getDefaultInstance(), buffer);\n       switch (saslMessage.getState()) {\n         case WRAP: {\n           if (!saslContextEstablished || !useWrap) {\n-            throw new WrappedRpcServerException(\n+            throw new FatalRpcServerException(\n                 RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                 new SaslException(\"Server is not wrapping data\"));\n           }\n           // loops over decoded data and calls processOneRpc\n           unwrapPacketAndProcessRpcs(saslMessage.getToken().toByteArray());\n           break;\n         }\n         default:\n           saslProcess(saslMessage);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void saslReadAndProcess(RpcWritable.Buffer buffer) throws\n        RpcServerException, IOException, InterruptedException {\n      final RpcSaslProto saslMessage \u003d\n          getMessage(RpcSaslProto.getDefaultInstance(), buffer);\n      switch (saslMessage.getState()) {\n        case WRAP: {\n          if (!saslContextEstablished || !useWrap) {\n            throw new FatalRpcServerException(\n                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                new SaslException(\"Server is not wrapping data\"));\n          }\n          // loops over decoded data and calls processOneRpc\n          unwrapPacketAndProcessRpcs(saslMessage.getToken().toByteArray());\n          break;\n        }\n        default:\n          saslProcess(saslMessage);\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[WrappedRpcServerException, IOException, InterruptedException]",
            "newValue": "[RpcServerException, IOException, InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14034. Allow ipc layer exceptions to selectively close connections. Contributed by Daryn Sharp.\n",
          "commitDate": "09/02/17 8:47 AM",
          "commitName": "b6bb99c18a772d2179d5cc6757cddf141e8d39c0",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "28/11/16 9:07 PM",
          "commitNameOld": "67d9f2808efb34b9a7b0b824cb4033b95ad33474",
          "commitAuthorOld": "Akira Ajisaka",
          "daysBetweenCommits": 72.49,
          "commitsBetweenForRepo": 352,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,19 @@\n     private void saslReadAndProcess(RpcWritable.Buffer buffer) throws\n-    WrappedRpcServerException, IOException, InterruptedException {\n+        RpcServerException, IOException, InterruptedException {\n       final RpcSaslProto saslMessage \u003d\n           getMessage(RpcSaslProto.getDefaultInstance(), buffer);\n       switch (saslMessage.getState()) {\n         case WRAP: {\n           if (!saslContextEstablished || !useWrap) {\n-            throw new WrappedRpcServerException(\n+            throw new FatalRpcServerException(\n                 RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                 new SaslException(\"Server is not wrapping data\"));\n           }\n           // loops over decoded data and calls processOneRpc\n           unwrapPacketAndProcessRpcs(saslMessage.getToken().toByteArray());\n           break;\n         }\n         default:\n           saslProcess(saslMessage);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void saslReadAndProcess(RpcWritable.Buffer buffer) throws\n        RpcServerException, IOException, InterruptedException {\n      final RpcSaslProto saslMessage \u003d\n          getMessage(RpcSaslProto.getDefaultInstance(), buffer);\n      switch (saslMessage.getState()) {\n        case WRAP: {\n          if (!saslContextEstablished || !useWrap) {\n            throw new FatalRpcServerException(\n                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                new SaslException(\"Server is not wrapping data\"));\n          }\n          // loops over decoded data and calls processOneRpc\n          unwrapPacketAndProcessRpcs(saslMessage.getToken().toByteArray());\n          break;\n        }\n        default:\n          saslProcess(saslMessage);\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "580a8334963709e728ed677c815fb7fef9bca70e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-13483. Optimize IPC server protobuf decoding. Contributed by Daryn Sharp.\n",
      "commitDate": "03/08/16 11:22 AM",
      "commitName": "580a8334963709e728ed677c815fb7fef9bca70e",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-13483. Optimize IPC server protobuf decoding. Contributed by Daryn Sharp.\n",
          "commitDate": "03/08/16 11:22 AM",
          "commitName": "580a8334963709e728ed677c815fb7fef9bca70e",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/08/16 7:31 AM",
          "commitNameOld": "2d8227605fe22c1c05f31729edc8939013763c05",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,19 @@\n-    private void saslReadAndProcess(DataInputStream dis) throws\n+    private void saslReadAndProcess(RpcWritable.Buffer buffer) throws\n     WrappedRpcServerException, IOException, InterruptedException {\n       final RpcSaslProto saslMessage \u003d\n-          decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);\n+          getMessage(RpcSaslProto.getDefaultInstance(), buffer);\n       switch (saslMessage.getState()) {\n         case WRAP: {\n           if (!saslContextEstablished || !useWrap) {\n             throw new WrappedRpcServerException(\n                 RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                 new SaslException(\"Server is not wrapping data\"));\n           }\n           // loops over decoded data and calls processOneRpc\n           unwrapPacketAndProcessRpcs(saslMessage.getToken().toByteArray());\n           break;\n         }\n         default:\n           saslProcess(saslMessage);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void saslReadAndProcess(RpcWritable.Buffer buffer) throws\n    WrappedRpcServerException, IOException, InterruptedException {\n      final RpcSaslProto saslMessage \u003d\n          getMessage(RpcSaslProto.getDefaultInstance(), buffer);\n      switch (saslMessage.getState()) {\n        case WRAP: {\n          if (!saslContextEstablished || !useWrap) {\n            throw new WrappedRpcServerException(\n                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                new SaslException(\"Server is not wrapping data\"));\n          }\n          // loops over decoded data and calls processOneRpc\n          unwrapPacketAndProcessRpcs(saslMessage.getToken().toByteArray());\n          break;\n        }\n        default:\n          saslProcess(saslMessage);\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[dis-DataInputStream]",
            "newValue": "[buffer-RpcWritable.Buffer]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13483. Optimize IPC server protobuf decoding. Contributed by Daryn Sharp.\n",
          "commitDate": "03/08/16 11:22 AM",
          "commitName": "580a8334963709e728ed677c815fb7fef9bca70e",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "03/08/16 7:31 AM",
          "commitNameOld": "2d8227605fe22c1c05f31729edc8939013763c05",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 0.16,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,19 +1,19 @@\n-    private void saslReadAndProcess(DataInputStream dis) throws\n+    private void saslReadAndProcess(RpcWritable.Buffer buffer) throws\n     WrappedRpcServerException, IOException, InterruptedException {\n       final RpcSaslProto saslMessage \u003d\n-          decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);\n+          getMessage(RpcSaslProto.getDefaultInstance(), buffer);\n       switch (saslMessage.getState()) {\n         case WRAP: {\n           if (!saslContextEstablished || !useWrap) {\n             throw new WrappedRpcServerException(\n                 RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                 new SaslException(\"Server is not wrapping data\"));\n           }\n           // loops over decoded data and calls processOneRpc\n           unwrapPacketAndProcessRpcs(saslMessage.getToken().toByteArray());\n           break;\n         }\n         default:\n           saslProcess(saslMessage);\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void saslReadAndProcess(RpcWritable.Buffer buffer) throws\n    WrappedRpcServerException, IOException, InterruptedException {\n      final RpcSaslProto saslMessage \u003d\n          getMessage(RpcSaslProto.getDefaultInstance(), buffer);\n      switch (saslMessage.getState()) {\n        case WRAP: {\n          if (!saslContextEstablished || !useWrap) {\n            throw new WrappedRpcServerException(\n                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                new SaslException(\"Server is not wrapping data\"));\n          }\n          // loops over decoded data and calls processOneRpc\n          unwrapPacketAndProcessRpcs(saslMessage.getToken().toByteArray());\n          break;\n        }\n        default:\n          saslProcess(saslMessage);\n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "c03c8fe199429a43c6aa944016566738abd9b193": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9820. RPCv9 wire protocol is insufficient to support multiplexing. Contributed by Daryn Sharp.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1512091 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/08/13 4:02 PM",
      "commitName": "c03c8fe199429a43c6aa944016566738abd9b193",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "05/08/13 4:01 PM",
      "commitNameOld": "63a1273f2a8e0b668ff70330262adedee63112d9",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 3.0,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,19 @@\n     private void saslReadAndProcess(DataInputStream dis) throws\n-        WrappedRpcServerException, IOException, InterruptedException {\n-      if (saslContextEstablished) {\n-        throw new WrappedRpcServerException(\n-            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n-            new SaslException(\"Negotiation is already complete\"));\n-      }\n-      RpcSaslProto saslResponse \u003d null;\n-      try {\n-        try {\n-          saslResponse \u003d processSaslMessage(dis);\n-        } catch (IOException e) {\n-          IOException sendToClient \u003d e;\n-          Throwable cause \u003d e;\n-          while (cause !\u003d null) {\n-            if (cause instanceof InvalidToken) {\n-              sendToClient \u003d (InvalidToken) cause;\n-              break;\n-            }\n-            cause \u003d cause.getCause();\n+    WrappedRpcServerException, IOException, InterruptedException {\n+      final RpcSaslProto saslMessage \u003d\n+          decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);\n+      switch (saslMessage.getState()) {\n+        case WRAP: {\n+          if (!saslContextEstablished || !useWrap) {\n+            throw new WrappedRpcServerException(\n+                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+                new SaslException(\"Server is not wrapping data\"));\n           }\n-          rpcMetrics.incrAuthenticationFailures();\n-          String clientIP \u003d this.toString();\n-          // attempting user could be null\n-          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n-            \" (\" + e.getLocalizedMessage() + \")\");\n-          throw sendToClient;\n+          // loops over decoded data and calls processOneRpc\n+          unwrapPacketAndProcessRpcs(saslMessage.getToken().toByteArray());\n+          break;\n         }\n-        \n-        if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n-                + saslServer.getNegotiatedProperty(Sasl.QOP));\n-          }\n-          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n-          }\n-          rpcMetrics.incrAuthenticationSuccesses();\n-          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n-          saslContextEstablished \u003d true;\n-        }\n-      } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n-        throw wrse;\n-      } catch (IOException ioe) {\n-        throw new WrappedRpcServerException(\n-            RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n-      }\n-      // send back response if any, may throw IOException\n-      if (saslResponse !\u003d null) {\n-        doSaslReply(saslResponse);\n-      }\n-      // do NOT enable wrapping until the last auth response is sent\n-      if (saslContextEstablished) {\n-        String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n-        useWrap \u003d (qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop));        \n+        default:\n+          saslProcess(saslMessage);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(DataInputStream dis) throws\n    WrappedRpcServerException, IOException, InterruptedException {\n      final RpcSaslProto saslMessage \u003d\n          decodeProtobufFromStream(RpcSaslProto.newBuilder(), dis);\n      switch (saslMessage.getState()) {\n        case WRAP: {\n          if (!saslContextEstablished || !useWrap) {\n            throw new WrappedRpcServerException(\n                RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n                new SaslException(\"Server is not wrapping data\"));\n          }\n          // loops over decoded data and calls processOneRpc\n          unwrapPacketAndProcessRpcs(saslMessage.getToken().toByteArray());\n          break;\n        }\n        default:\n          saslProcess(saslMessage);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "f5312aedb9fa3dc895d61844b5c3202b02554f80": {
      "type": "Ymultichange(Yreturntypechange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-9816. RPC Sasl QOP is broken (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1510772 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/08/13 3:02 PM",
      "commitName": "f5312aedb9fa3dc895d61844b5c3202b02554f80",
      "commitAuthor": "Daryn Sharp",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-9816. RPC Sasl QOP is broken (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1510772 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/08/13 3:02 PM",
          "commitName": "f5312aedb9fa3dc895d61844b5c3202b02554f80",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "29/07/13 7:44 AM",
          "commitNameOld": "65be21267587f04a2c33af65b951211cc9085b15",
          "commitAuthorOld": "Daryn Sharp",
          "daysBetweenCommits": 7.3,
          "commitsBetweenForRepo": 49,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,58 @@\n-    private RpcSaslProto saslReadAndProcess(DataInputStream dis) throws\n-        WrappedRpcServerException, InterruptedException {\n+    private void saslReadAndProcess(DataInputStream dis) throws\n+        WrappedRpcServerException, IOException, InterruptedException {\n       if (saslContextEstablished) {\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n             new SaslException(\"Negotiation is already complete\"));\n       }\n       RpcSaslProto saslResponse \u003d null;\n       try {\n         try {\n           saslResponse \u003d processSaslMessage(dis);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n             \" (\" + e.getLocalizedMessage() + \")\");\n           throw sendToClient;\n         }\n         \n         if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n-          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n-          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n         throw wrse;\n       } catch (IOException ioe) {\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n       }\n-      return saslResponse; \n+      // send back response if any, may throw IOException\n+      if (saslResponse !\u003d null) {\n+        doSaslReply(saslResponse);\n+      }\n+      // do NOT enable wrapping until the last auth response is sent\n+      if (saslContextEstablished) {\n+        String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n+        useWrap \u003d (qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop));        \n+      }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void saslReadAndProcess(DataInputStream dis) throws\n        WrappedRpcServerException, IOException, InterruptedException {\n      if (saslContextEstablished) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            new SaslException(\"Negotiation is already complete\"));\n      }\n      RpcSaslProto saslResponse \u003d null;\n      try {\n        try {\n          saslResponse \u003d processSaslMessage(dis);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n            \" (\" + e.getLocalizedMessage() + \")\");\n          throw sendToClient;\n        }\n        \n        if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n        throw wrse;\n      } catch (IOException ioe) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n      }\n      // send back response if any, may throw IOException\n      if (saslResponse !\u003d null) {\n        doSaslReply(saslResponse);\n      }\n      // do NOT enable wrapping until the last auth response is sent\n      if (saslContextEstablished) {\n        String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n        useWrap \u003d (qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop));        \n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "RpcSaslProto",
            "newValue": "void"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-9816. RPC Sasl QOP is broken (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1510772 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/08/13 3:02 PM",
          "commitName": "f5312aedb9fa3dc895d61844b5c3202b02554f80",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "29/07/13 7:44 AM",
          "commitNameOld": "65be21267587f04a2c33af65b951211cc9085b15",
          "commitAuthorOld": "Daryn Sharp",
          "daysBetweenCommits": 7.3,
          "commitsBetweenForRepo": 49,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,58 @@\n-    private RpcSaslProto saslReadAndProcess(DataInputStream dis) throws\n-        WrappedRpcServerException, InterruptedException {\n+    private void saslReadAndProcess(DataInputStream dis) throws\n+        WrappedRpcServerException, IOException, InterruptedException {\n       if (saslContextEstablished) {\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n             new SaslException(\"Negotiation is already complete\"));\n       }\n       RpcSaslProto saslResponse \u003d null;\n       try {\n         try {\n           saslResponse \u003d processSaslMessage(dis);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n             \" (\" + e.getLocalizedMessage() + \")\");\n           throw sendToClient;\n         }\n         \n         if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n-          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n-          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n         throw wrse;\n       } catch (IOException ioe) {\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n       }\n-      return saslResponse; \n+      // send back response if any, may throw IOException\n+      if (saslResponse !\u003d null) {\n+        doSaslReply(saslResponse);\n+      }\n+      // do NOT enable wrapping until the last auth response is sent\n+      if (saslContextEstablished) {\n+        String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n+        useWrap \u003d (qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop));        \n+      }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void saslReadAndProcess(DataInputStream dis) throws\n        WrappedRpcServerException, IOException, InterruptedException {\n      if (saslContextEstablished) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            new SaslException(\"Negotiation is already complete\"));\n      }\n      RpcSaslProto saslResponse \u003d null;\n      try {\n        try {\n          saslResponse \u003d processSaslMessage(dis);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n            \" (\" + e.getLocalizedMessage() + \")\");\n          throw sendToClient;\n        }\n        \n        if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n        throw wrse;\n      } catch (IOException ioe) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n      }\n      // send back response if any, may throw IOException\n      if (saslResponse !\u003d null) {\n        doSaslReply(saslResponse);\n      }\n      // do NOT enable wrapping until the last auth response is sent\n      if (saslContextEstablished) {\n        String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n        useWrap \u003d (qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop));        \n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[WrappedRpcServerException, InterruptedException]",
            "newValue": "[WrappedRpcServerException, IOException, InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-9816. RPC Sasl QOP is broken (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1510772 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "05/08/13 3:02 PM",
          "commitName": "f5312aedb9fa3dc895d61844b5c3202b02554f80",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "29/07/13 7:44 AM",
          "commitNameOld": "65be21267587f04a2c33af65b951211cc9085b15",
          "commitAuthorOld": "Daryn Sharp",
          "daysBetweenCommits": 7.3,
          "commitsBetweenForRepo": 49,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,58 @@\n-    private RpcSaslProto saslReadAndProcess(DataInputStream dis) throws\n-        WrappedRpcServerException, InterruptedException {\n+    private void saslReadAndProcess(DataInputStream dis) throws\n+        WrappedRpcServerException, IOException, InterruptedException {\n       if (saslContextEstablished) {\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n             new SaslException(\"Negotiation is already complete\"));\n       }\n       RpcSaslProto saslResponse \u003d null;\n       try {\n         try {\n           saslResponse \u003d processSaslMessage(dis);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n             \" (\" + e.getLocalizedMessage() + \")\");\n           throw sendToClient;\n         }\n         \n         if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n-          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n-          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n         throw wrse;\n       } catch (IOException ioe) {\n         throw new WrappedRpcServerException(\n             RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n       }\n-      return saslResponse; \n+      // send back response if any, may throw IOException\n+      if (saslResponse !\u003d null) {\n+        doSaslReply(saslResponse);\n+      }\n+      // do NOT enable wrapping until the last auth response is sent\n+      if (saslContextEstablished) {\n+        String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n+        useWrap \u003d (qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop));        \n+      }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    private void saslReadAndProcess(DataInputStream dis) throws\n        WrappedRpcServerException, IOException, InterruptedException {\n      if (saslContextEstablished) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            new SaslException(\"Negotiation is already complete\"));\n      }\n      RpcSaslProto saslResponse \u003d null;\n      try {\n        try {\n          saslResponse \u003d processSaslMessage(dis);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n            \" (\" + e.getLocalizedMessage() + \")\");\n          throw sendToClient;\n        }\n        \n        if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n        throw wrse;\n      } catch (IOException ioe) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n      }\n      // send back response if any, may throw IOException\n      if (saslResponse !\u003d null) {\n        doSaslReply(saslResponse);\n      }\n      // do NOT enable wrapping until the last auth response is sent\n      if (saslContextEstablished) {\n        String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n        useWrap \u003d (qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop));        \n      }\n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "a3a9d72e98a9cc0f94af7c832dd13c408856636d": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/13 10:59 AM",
      "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
      "commitAuthor": "Daryn Sharp",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,52 @@\n-    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n-        InterruptedException {\n-      if (!saslContextEstablished) {\n-        RpcSaslProto saslResponse;\n+    private RpcSaslProto saslReadAndProcess(DataInputStream dis) throws\n+        WrappedRpcServerException, InterruptedException {\n+      if (saslContextEstablished) {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+            new SaslException(\"Negotiation is already complete\"));\n+      }\n+      RpcSaslProto saslResponse \u003d null;\n+      try {\n         try {\n-          saslResponse \u003d processSaslMessage(saslToken);\n+          saslResponse \u003d processSaslMessage(dis);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n             \" (\" + e.getLocalizedMessage() + \")\");\n-          // wait to send response until failure is logged\n-          doSaslReply(sendToClient);\n-          throw e;\n+          throw sendToClient;\n         }\n         \n         if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n-        // send reply here to avoid a successful auth being logged as a\n-        // failure if response can\u0027t be sent\n-        doSaslReply(saslResponse);\n-      } else {\n-        if (LOG.isDebugEnabled())\n-          LOG.debug(\"Have read input token of size \" + saslToken.length\n-              + \" for processing by saslServer.unwrap()\");\n-        \n-        if (!useWrap) {\n-          processOneRpc(saslToken);\n-        } else {\n-          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n-              saslToken.length);\n-          processUnwrappedData(plaintextData);\n-        }\n+      } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n+        throw wrse;\n+      } catch (IOException ioe) {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n       }\n+      return saslResponse; \n     }\n\\ No newline at end of file\n",
          "actualSource": "    private RpcSaslProto saslReadAndProcess(DataInputStream dis) throws\n        WrappedRpcServerException, InterruptedException {\n      if (saslContextEstablished) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            new SaslException(\"Negotiation is already complete\"));\n      }\n      RpcSaslProto saslResponse \u003d null;\n      try {\n        try {\n          saslResponse \u003d processSaslMessage(dis);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n            \" (\" + e.getLocalizedMessage() + \")\");\n          throw sendToClient;\n        }\n        \n        if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n        throw wrse;\n      } catch (IOException ioe) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n      }\n      return saslResponse; \n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[saslToken-byte[]]",
            "newValue": "[dis-DataInputStream]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,52 @@\n-    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n-        InterruptedException {\n-      if (!saslContextEstablished) {\n-        RpcSaslProto saslResponse;\n+    private RpcSaslProto saslReadAndProcess(DataInputStream dis) throws\n+        WrappedRpcServerException, InterruptedException {\n+      if (saslContextEstablished) {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+            new SaslException(\"Negotiation is already complete\"));\n+      }\n+      RpcSaslProto saslResponse \u003d null;\n+      try {\n         try {\n-          saslResponse \u003d processSaslMessage(saslToken);\n+          saslResponse \u003d processSaslMessage(dis);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n             \" (\" + e.getLocalizedMessage() + \")\");\n-          // wait to send response until failure is logged\n-          doSaslReply(sendToClient);\n-          throw e;\n+          throw sendToClient;\n         }\n         \n         if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n-        // send reply here to avoid a successful auth being logged as a\n-        // failure if response can\u0027t be sent\n-        doSaslReply(saslResponse);\n-      } else {\n-        if (LOG.isDebugEnabled())\n-          LOG.debug(\"Have read input token of size \" + saslToken.length\n-              + \" for processing by saslServer.unwrap()\");\n-        \n-        if (!useWrap) {\n-          processOneRpc(saslToken);\n-        } else {\n-          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n-              saslToken.length);\n-          processUnwrappedData(plaintextData);\n-        }\n+      } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n+        throw wrse;\n+      } catch (IOException ioe) {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n       }\n+      return saslResponse; \n     }\n\\ No newline at end of file\n",
          "actualSource": "    private RpcSaslProto saslReadAndProcess(DataInputStream dis) throws\n        WrappedRpcServerException, InterruptedException {\n      if (saslContextEstablished) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            new SaslException(\"Negotiation is already complete\"));\n      }\n      RpcSaslProto saslResponse \u003d null;\n      try {\n        try {\n          saslResponse \u003d processSaslMessage(dis);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n            \" (\" + e.getLocalizedMessage() + \")\");\n          throw sendToClient;\n        }\n        \n        if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n        throw wrse;\n      } catch (IOException ioe) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n      }\n      return saslResponse; \n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "RpcSaslProto"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,52 @@\n-    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n-        InterruptedException {\n-      if (!saslContextEstablished) {\n-        RpcSaslProto saslResponse;\n+    private RpcSaslProto saslReadAndProcess(DataInputStream dis) throws\n+        WrappedRpcServerException, InterruptedException {\n+      if (saslContextEstablished) {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+            new SaslException(\"Negotiation is already complete\"));\n+      }\n+      RpcSaslProto saslResponse \u003d null;\n+      try {\n         try {\n-          saslResponse \u003d processSaslMessage(saslToken);\n+          saslResponse \u003d processSaslMessage(dis);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n             \" (\" + e.getLocalizedMessage() + \")\");\n-          // wait to send response until failure is logged\n-          doSaslReply(sendToClient);\n-          throw e;\n+          throw sendToClient;\n         }\n         \n         if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n-        // send reply here to avoid a successful auth being logged as a\n-        // failure if response can\u0027t be sent\n-        doSaslReply(saslResponse);\n-      } else {\n-        if (LOG.isDebugEnabled())\n-          LOG.debug(\"Have read input token of size \" + saslToken.length\n-              + \" for processing by saslServer.unwrap()\");\n-        \n-        if (!useWrap) {\n-          processOneRpc(saslToken);\n-        } else {\n-          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n-              saslToken.length);\n-          processUnwrappedData(plaintextData);\n-        }\n+      } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n+        throw wrse;\n+      } catch (IOException ioe) {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n       }\n+      return saslResponse; \n     }\n\\ No newline at end of file\n",
          "actualSource": "    private RpcSaslProto saslReadAndProcess(DataInputStream dis) throws\n        WrappedRpcServerException, InterruptedException {\n      if (saslContextEstablished) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            new SaslException(\"Negotiation is already complete\"));\n      }\n      RpcSaslProto saslResponse \u003d null;\n      try {\n        try {\n          saslResponse \u003d processSaslMessage(dis);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n            \" (\" + e.getLocalizedMessage() + \")\");\n          throw sendToClient;\n        }\n        \n        if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n        throw wrse;\n      } catch (IOException ioe) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n      }\n      return saslResponse; \n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {
            "oldValue": "[IOException, InterruptedException]",
            "newValue": "[WrappedRpcServerException, InterruptedException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-9683. [RPC v9] Wrap IpcConnectionContext in RPC headers (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503811 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/13 10:59 AM",
          "commitName": "a3a9d72e98a9cc0f94af7c832dd13c408856636d",
          "commitAuthor": "Daryn Sharp",
          "commitDateOld": "09/07/13 4:45 PM",
          "commitNameOld": "0a5f16a89e3942953d7d6c2d26542764298c6430",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 6.76,
          "commitsBetweenForRepo": 40,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,52 @@\n-    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n-        InterruptedException {\n-      if (!saslContextEstablished) {\n-        RpcSaslProto saslResponse;\n+    private RpcSaslProto saslReadAndProcess(DataInputStream dis) throws\n+        WrappedRpcServerException, InterruptedException {\n+      if (saslContextEstablished) {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n+            new SaslException(\"Negotiation is already complete\"));\n+      }\n+      RpcSaslProto saslResponse \u003d null;\n+      try {\n         try {\n-          saslResponse \u003d processSaslMessage(saslToken);\n+          saslResponse \u003d processSaslMessage(dis);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n             \" (\" + e.getLocalizedMessage() + \")\");\n-          // wait to send response until failure is logged\n-          doSaslReply(sendToClient);\n-          throw e;\n+          throw sendToClient;\n         }\n         \n         if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n-        // send reply here to avoid a successful auth being logged as a\n-        // failure if response can\u0027t be sent\n-        doSaslReply(saslResponse);\n-      } else {\n-        if (LOG.isDebugEnabled())\n-          LOG.debug(\"Have read input token of size \" + saslToken.length\n-              + \" for processing by saslServer.unwrap()\");\n-        \n-        if (!useWrap) {\n-          processOneRpc(saslToken);\n-        } else {\n-          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n-              saslToken.length);\n-          processUnwrappedData(plaintextData);\n-        }\n+      } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n+        throw wrse;\n+      } catch (IOException ioe) {\n+        throw new WrappedRpcServerException(\n+            RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n       }\n+      return saslResponse; \n     }\n\\ No newline at end of file\n",
          "actualSource": "    private RpcSaslProto saslReadAndProcess(DataInputStream dis) throws\n        WrappedRpcServerException, InterruptedException {\n      if (saslContextEstablished) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_INVALID_RPC_HEADER,\n            new SaslException(\"Negotiation is already complete\"));\n      }\n      RpcSaslProto saslResponse \u003d null;\n      try {\n        try {\n          saslResponse \u003d processSaslMessage(dis);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n            \" (\" + e.getLocalizedMessage() + \")\");\n          throw sendToClient;\n        }\n        \n        if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } catch (WrappedRpcServerException wrse) { // don\u0027t re-wrap\n        throw wrse;\n      } catch (IOException ioe) {\n        throw new WrappedRpcServerException(\n            RpcErrorCodeProto.FATAL_UNAUTHORIZED, ioe);\n      }\n      return saslResponse; \n    }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
          "extendedDetails": {}
        }
      ]
    },
    "5f9b4c14a175873b4f82654513e289c657c694eb": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9421. [RPC v9] Convert SASL to use ProtoBuf and provide negotiation capabilities (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1495577 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/06/13 1:09 PM",
      "commitName": "5f9b4c14a175873b4f82654513e289c657c694eb",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "10/06/13 8:30 PM",
      "commitNameOld": "a841be808a780db0653b17bb702037f422c5b1ec",
      "commitAuthorOld": "Luke Lu",
      "daysBetweenCommits": 10.69,
      "commitsBetweenForRepo": 113,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,58 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n-        byte[] replyToken \u003d null;\n+        RpcSaslProto saslResponse;\n         try {\n-          if (LOG.isDebugEnabled())\n-            LOG.debug(\"Have read input token of size \" + saslToken.length\n-                + \" for processing by saslServer.evaluateResponse()\");\n-          replyToken \u003d saslServer.evaluateResponse(saslToken);\n+          saslResponse \u003d processSaslMessage(saslToken);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n-          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n-              sendToClient.getLocalizedMessage());\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n             \" (\" + e.getLocalizedMessage() + \")\");\n+          // wait to send response until failure is logged\n+          doSaslReply(sendToClient);\n           throw e;\n         }\n-        if (saslServer.isComplete() \u0026\u0026 replyToken \u003d\u003d null) {\n-          // send final response for success\n-          replyToken \u003d new byte[0];\n-        }\n-        if (replyToken !\u003d null) {\n-          if (LOG.isDebugEnabled())\n-            LOG.debug(\"Will send token of size \" + replyToken.length\n-                + \" from saslServer.\");\n-          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n-              null);\n-        }\n-        if (saslServer.isComplete()) {\n+        \n+        if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n+        // send reply here to avoid a successful auth being logged as a\n+        // failure if response can\u0027t be sent\n+        doSaslReply(saslResponse);\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         \n         if (!useWrap) {\n           processOneRpc(saslToken);\n         } else {\n           byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n               saslToken.length);\n           processUnwrappedData(plaintextData);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        RpcSaslProto saslResponse;\n        try {\n          saslResponse \u003d processSaslMessage(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n            \" (\" + e.getLocalizedMessage() + \")\");\n          // wait to send response until failure is logged\n          doSaslReply(sendToClient);\n          throw e;\n        }\n        \n        if (saslServer !\u003d null \u0026\u0026 saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n        // send reply here to avoid a successful auth being logged as a\n        // failure if response can\u0027t be sent\n        doSaslReply(saslResponse);\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "fc0a4de670c3e6dcf5d30305d3969fe4946a0fed": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9358. \"Auth failed\" log should include exception string. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1461788 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/03/13 11:51 AM",
      "commitName": "fc0a4de670c3e6dcf5d30305d3969fe4946a0fed",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "26/03/13 4:29 PM",
      "commitNameOld": "5319818487d5c139de06155834deecb18c10b7a1",
      "commitAuthorOld": "Luke Lu",
      "daysBetweenCommits": 0.81,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,68 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         byte[] replyToken \u003d null;\n         try {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           replyToken \u003d saslServer.evaluateResponse(saslToken);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n               sendToClient.getLocalizedMessage());\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n-          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n+          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n+            \" (\" + e.getLocalizedMessage() + \")\");\n           throw e;\n         }\n         if (saslServer.isComplete() \u0026\u0026 replyToken \u003d\u003d null) {\n           // send final response for success\n           replyToken \u003d new byte[0];\n         }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n               null);\n         }\n         if (saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         \n         if (!useWrap) {\n           processOneRpc(saslToken);\n         } else {\n           byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n               saslToken.length);\n           processUnwrappedData(plaintextData);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser +\n            \" (\" + e.getLocalizedMessage() + \")\");\n          throw e;\n        }\n        if (saslServer.isComplete() \u0026\u0026 replyToken \u003d\u003d null) {\n          // send final response for success\n          replyToken \u003d new byte[0];\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "3337588975fa24c0044408c6caf91abea4dca4d4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9070. Kerberos SASL server cannot find kerberos key. Contributed by Daryn Sharp.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1417729 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/12/12 6:53 PM",
      "commitName": "3337588975fa24c0044408c6caf91abea4dca4d4",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "13/11/12 9:10 AM",
      "commitNameOld": "fe8f635b78d59e286771ec75ff73245b40d30907",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 22.41,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,67 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         byte[] replyToken \u003d null;\n         try {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           replyToken \u003d saslServer.evaluateResponse(saslToken);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n               sendToClient.getLocalizedMessage());\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n           throw e;\n         }\n-        if (replyToken \u003d\u003d null \u0026\u0026 authMethod \u003d\u003d AuthMethod.PLAIN) {\n-          // client needs at least response to know if it should use SIMPLE\n+        if (saslServer.isComplete() \u0026\u0026 replyToken \u003d\u003d null) {\n+          // send final response for success\n           replyToken \u003d new byte[0];\n         }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n               null);\n         }\n         if (saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         \n         if (!useWrap) {\n           processOneRpc(saslToken);\n         } else {\n           byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n               saslToken.length);\n           processUnwrappedData(plaintextData);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n          throw e;\n        }\n        if (saslServer.isComplete() \u0026\u0026 replyToken \u003d\u003d null) {\n          // send final response for success\n          replyToken \u003d new byte[0];\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "fe8f635b78d59e286771ec75ff73245b40d30907": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8999. SASL negotiation is flawed (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1408837 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/11/12 9:10 AM",
      "commitName": "fe8f635b78d59e286771ec75ff73245b40d30907",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "12/11/12 2:13 PM",
      "commitNameOld": "4755ef989ac771ad3c2c40f9914455725c931447",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,67 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         byte[] replyToken \u003d null;\n         try {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           replyToken \u003d saslServer.evaluateResponse(saslToken);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n               sendToClient.getLocalizedMessage());\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n           throw e;\n         }\n+        if (replyToken \u003d\u003d null \u0026\u0026 authMethod \u003d\u003d AuthMethod.PLAIN) {\n+          // client needs at least response to know if it should use SIMPLE\n+          replyToken \u003d new byte[0];\n+        }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n               null);\n         }\n         if (saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         \n         if (!useWrap) {\n           processOneRpc(saslToken);\n         } else {\n           byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n               saslToken.length);\n           processUnwrappedData(plaintextData);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n          throw e;\n        }\n        if (replyToken \u003d\u003d null \u0026\u0026 authMethod \u003d\u003d AuthMethod.PLAIN) {\n          // client needs at least response to know if it should use SIMPLE\n          replyToken \u003d new byte[0];\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "1594dd6965c412a08339a0079ee1416dd6f595f9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9015. Standardize creation of SaslRpcServers (daryn via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1406851 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/11/12 2:50 PM",
      "commitName": "1594dd6965c412a08339a0079ee1416dd6f595f9",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "05/11/12 10:37 AM",
      "commitNameOld": "b1aa62a848646f78e019c74186d9696e9101afcf",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 2.18,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,63 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         byte[] replyToken \u003d null;\n         try {\n-          if (saslServer \u003d\u003d null) {\n-            switch (authMethod) {\n-            case DIGEST:\n-              if (secretManager \u003d\u003d null) {\n-                throw new AccessControlException(\n-                    \"Server is not configured to do DIGEST authentication.\");\n-              }\n-              secretManager.checkAvailableForRead();\n-              saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n-                  .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n-                  SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n-                      secretManager, this));\n-              break;\n-            default:\n-              UserGroupInformation current \u003d UserGroupInformation\n-                  .getCurrentUser();\n-              String fullName \u003d current.getUserName();\n-              if (LOG.isDebugEnabled())\n-                LOG.debug(\"Kerberos principal name is \" + fullName);\n-              final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n-              if (names.length !\u003d 3) {\n-                throw new AccessControlException(\n-                    \"Kerberos principal name does NOT have the expected \"\n-                        + \"hostname part: \" + fullName);\n-              }\n-              current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n-                @Override\n-                public Object run() throws SaslException {\n-                  saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n-                      .getMechanismName(), names[0], names[1],\n-                      SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n-                  return null;\n-                }\n-              });\n-            }\n-            if (saslServer \u003d\u003d null)\n-              throw new AccessControlException(\n-                  \"Unable to find SASL server implementation for \"\n-                      + authMethod.getMechanismName());\n-            if (LOG.isDebugEnabled())\n-              LOG.debug(\"Created SASL server with mechanism \u003d \"\n-                  + authMethod.getMechanismName());\n-          }\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           replyToken \u003d saslServer.evaluateResponse(saslToken);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n               sendToClient.getLocalizedMessage());\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n           throw e;\n         }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n               null);\n         }\n         if (saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         \n         if (!useWrap) {\n           processOneRpc(saslToken);\n         } else {\n           byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n               saslToken.length);\n           processUnwrappedData(plaintextData);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n          throw e;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "d94899877709836153244c2f0c5f14c37c9d4795": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8347. Hadoop Common logs misspell \u0027successful\u0027. Contributed by Philip Zeyliger\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1333321 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/05/12 11:35 PM",
      "commitName": "d94899877709836153244c2f0c5f14c37c9d4795",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "01/05/12 2:46 PM",
      "commitNameOld": "70c392df0e8f8aa809b5000e8b416ab7f878eb5d",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 1.37,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         byte[] replyToken \u003d null;\n         try {\n           if (saslServer \u003d\u003d null) {\n             switch (authMethod) {\n             case DIGEST:\n               if (secretManager \u003d\u003d null) {\n                 throw new AccessControlException(\n                     \"Server is not configured to do DIGEST authentication.\");\n               }\n               secretManager.checkAvailableForRead();\n               saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                   .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                   SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                       secretManager, this));\n               break;\n             default:\n               UserGroupInformation current \u003d UserGroupInformation\n                   .getCurrentUser();\n               String fullName \u003d current.getUserName();\n               if (LOG.isDebugEnabled())\n                 LOG.debug(\"Kerberos principal name is \" + fullName);\n               final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n               if (names.length !\u003d 3) {\n                 throw new AccessControlException(\n                     \"Kerberos principal name does NOT have the expected \"\n                         + \"hostname part: \" + fullName);\n               }\n               current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                 @Override\n                 public Object run() throws SaslException {\n                   saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                       .getMechanismName(), names[0], names[1],\n                       SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                   return null;\n                 }\n               });\n             }\n             if (saslServer \u003d\u003d null)\n               throw new AccessControlException(\n                   \"Unable to find SASL server implementation for \"\n                       + authMethod.getMechanismName());\n             if (LOG.isDebugEnabled())\n               LOG.debug(\"Created SASL server with mechanism \u003d \"\n                   + authMethod.getMechanismName());\n           }\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           replyToken \u003d saslServer.evaluateResponse(saslToken);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n               sendToClient.getLocalizedMessage());\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n           throw e;\n         }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n               null);\n         }\n         if (saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n-          AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n+          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         \n         if (!useWrap) {\n           processOneRpc(saslToken);\n         } else {\n           byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n               saslToken.length);\n           processUnwrappedData(plaintextData);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (saslServer \u003d\u003d null) {\n            switch (authMethod) {\n            case DIGEST:\n              if (secretManager \u003d\u003d null) {\n                throw new AccessControlException(\n                    \"Server is not configured to do DIGEST authentication.\");\n              }\n              secretManager.checkAvailableForRead();\n              saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                  .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                  SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                      secretManager, this));\n              break;\n            default:\n              UserGroupInformation current \u003d UserGroupInformation\n                  .getCurrentUser();\n              String fullName \u003d current.getUserName();\n              if (LOG.isDebugEnabled())\n                LOG.debug(\"Kerberos principal name is \" + fullName);\n              final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n              if (names.length !\u003d 3) {\n                throw new AccessControlException(\n                    \"Kerberos principal name does NOT have the expected \"\n                        + \"hostname part: \" + fullName);\n              }\n              current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                @Override\n                public Object run() throws SaslException {\n                  saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                      .getMechanismName(), names[0], names[1],\n                      SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                  return null;\n                }\n              });\n            }\n            if (saslServer \u003d\u003d null)\n              throw new AccessControlException(\n                  \"Unable to find SASL server implementation for \"\n                      + authMethod.getMechanismName());\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Created SASL server with mechanism \u003d \"\n                  + authMethod.getMechanismName());\n          }\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n          throw e;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "4ceca97606e7258e807867bbcd8cc60d0cce7439": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3083. Cannot run an MR job with HA and security enabled when second-listed NN active. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1303098 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/03/12 12:00 PM",
      "commitName": "4ceca97606e7258e807867bbcd8cc60d0cce7439",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "29/02/12 3:47 PM",
      "commitNameOld": "1ba357553aafe30ecf33b9c7863c44c0b8021e78",
      "commitAuthorOld": "",
      "daysBetweenCommits": 19.8,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,106 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         byte[] replyToken \u003d null;\n         try {\n           if (saslServer \u003d\u003d null) {\n             switch (authMethod) {\n             case DIGEST:\n               if (secretManager \u003d\u003d null) {\n                 throw new AccessControlException(\n                     \"Server is not configured to do DIGEST authentication.\");\n               }\n+              secretManager.checkAvailableForRead();\n               saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                   .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                   SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                       secretManager, this));\n               break;\n             default:\n               UserGroupInformation current \u003d UserGroupInformation\n                   .getCurrentUser();\n               String fullName \u003d current.getUserName();\n               if (LOG.isDebugEnabled())\n                 LOG.debug(\"Kerberos principal name is \" + fullName);\n               final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n               if (names.length !\u003d 3) {\n                 throw new AccessControlException(\n                     \"Kerberos principal name does NOT have the expected \"\n                         + \"hostname part: \" + fullName);\n               }\n               current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                 @Override\n                 public Object run() throws SaslException {\n                   saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                       .getMechanismName(), names[0], names[1],\n                       SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                   return null;\n                 }\n               });\n             }\n             if (saslServer \u003d\u003d null)\n               throw new AccessControlException(\n                   \"Unable to find SASL server implementation for \"\n                       + authMethod.getMechanismName());\n             if (LOG.isDebugEnabled())\n               LOG.debug(\"Created SASL server with mechanism \u003d \"\n                   + authMethod.getMechanismName());\n           }\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           replyToken \u003d saslServer.evaluateResponse(saslToken);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n               sendToClient.getLocalizedMessage());\n           rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n           throw e;\n         }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n               null);\n         }\n         if (saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n           rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         \n         if (!useWrap) {\n           processOneRpc(saslToken);\n         } else {\n           byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n               saslToken.length);\n           processUnwrappedData(plaintextData);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (saslServer \u003d\u003d null) {\n            switch (authMethod) {\n            case DIGEST:\n              if (secretManager \u003d\u003d null) {\n                throw new AccessControlException(\n                    \"Server is not configured to do DIGEST authentication.\");\n              }\n              secretManager.checkAvailableForRead();\n              saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                  .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                  SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                      secretManager, this));\n              break;\n            default:\n              UserGroupInformation current \u003d UserGroupInformation\n                  .getCurrentUser();\n              String fullName \u003d current.getUserName();\n              if (LOG.isDebugEnabled())\n                LOG.debug(\"Kerberos principal name is \" + fullName);\n              final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n              if (names.length !\u003d 3) {\n                throw new AccessControlException(\n                    \"Kerberos principal name does NOT have the expected \"\n                        + \"hostname part: \" + fullName);\n              }\n              current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                @Override\n                public Object run() throws SaslException {\n                  saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                      .getMechanismName(), names[0], names[1],\n                      SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                  return null;\n                }\n              });\n            }\n            if (saslServer \u003d\u003d null)\n              throw new AccessControlException(\n                  \"Unable to find SASL server implementation for \"\n                      + authMethod.getMechanismName());\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Created SASL server with mechanism \u003d \"\n                  + authMethod.getMechanismName());\n          }\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n          throw e;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (saslServer \u003d\u003d null) {\n            switch (authMethod) {\n            case DIGEST:\n              if (secretManager \u003d\u003d null) {\n                throw new AccessControlException(\n                    \"Server is not configured to do DIGEST authentication.\");\n              }\n              saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                  .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                  SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                      secretManager, this));\n              break;\n            default:\n              UserGroupInformation current \u003d UserGroupInformation\n                  .getCurrentUser();\n              String fullName \u003d current.getUserName();\n              if (LOG.isDebugEnabled())\n                LOG.debug(\"Kerberos principal name is \" + fullName);\n              final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n              if (names.length !\u003d 3) {\n                throw new AccessControlException(\n                    \"Kerberos principal name does NOT have the expected \"\n                        + \"hostname part: \" + fullName);\n              }\n              current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                @Override\n                public Object run() throws SaslException {\n                  saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                      .getMechanismName(), names[0], names[1],\n                      SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                  return null;\n                }\n              });\n            }\n            if (saslServer \u003d\u003d null)\n              throw new AccessControlException(\n                  \"Unable to find SASL server implementation for \"\n                      + authMethod.getMechanismName());\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Created SASL server with mechanism \u003d \"\n                  + authMethod.getMechanismName());\n          }\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n          throw e;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (saslServer \u003d\u003d null) {\n            switch (authMethod) {\n            case DIGEST:\n              if (secretManager \u003d\u003d null) {\n                throw new AccessControlException(\n                    \"Server is not configured to do DIGEST authentication.\");\n              }\n              saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                  .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                  SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                      secretManager, this));\n              break;\n            default:\n              UserGroupInformation current \u003d UserGroupInformation\n                  .getCurrentUser();\n              String fullName \u003d current.getUserName();\n              if (LOG.isDebugEnabled())\n                LOG.debug(\"Kerberos principal name is \" + fullName);\n              final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n              if (names.length !\u003d 3) {\n                throw new AccessControlException(\n                    \"Kerberos principal name does NOT have the expected \"\n                        + \"hostname part: \" + fullName);\n              }\n              current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                @Override\n                public Object run() throws SaslException {\n                  saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                      .getMechanismName(), names[0], names[1],\n                      SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                  return null;\n                }\n              });\n            }\n            if (saslServer \u003d\u003d null)\n              throw new AccessControlException(\n                  \"Unable to find SASL server implementation for \"\n                      + authMethod.getMechanismName());\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Created SASL server with mechanism \u003d \"\n                  + authMethod.getMechanismName());\n          }\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n          throw e;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (saslServer \u003d\u003d null) {\n            switch (authMethod) {\n            case DIGEST:\n              if (secretManager \u003d\u003d null) {\n                throw new AccessControlException(\n                    \"Server is not configured to do DIGEST authentication.\");\n              }\n              saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                  .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                  SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                      secretManager, this));\n              break;\n            default:\n              UserGroupInformation current \u003d UserGroupInformation\n                  .getCurrentUser();\n              String fullName \u003d current.getUserName();\n              if (LOG.isDebugEnabled())\n                LOG.debug(\"Kerberos principal name is \" + fullName);\n              final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n              if (names.length !\u003d 3) {\n                throw new AccessControlException(\n                    \"Kerberos principal name does NOT have the expected \"\n                        + \"hostname part: \" + fullName);\n              }\n              current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                @Override\n                public Object run() throws SaslException {\n                  saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                      .getMechanismName(), names[0], names[1],\n                      SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                  return null;\n                }\n              });\n            }\n            if (saslServer \u003d\u003d null)\n              throw new AccessControlException(\n                  \"Unable to find SASL server implementation for \"\n                      + authMethod.getMechanismName());\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Created SASL server with mechanism \u003d \"\n                  + authMethod.getMechanismName());\n          }\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n          throw e;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "common/src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "common/src/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "8a2b40d0726215e48b53ab22382dd49379c36249": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6920. Metrics instrumentation to move new metrics2 framework. Contributed by Luke Lu.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1101682 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/11 4:56 PM",
      "commitName": "8a2b40d0726215e48b53ab22382dd49379c36249",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "10/05/11 3:24 PM",
      "commitNameOld": "c0d70530b173beb2d53a4175236520df8e3967c8",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,105 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         byte[] replyToken \u003d null;\n         try {\n           if (saslServer \u003d\u003d null) {\n             switch (authMethod) {\n             case DIGEST:\n               if (secretManager \u003d\u003d null) {\n                 throw new AccessControlException(\n                     \"Server is not configured to do DIGEST authentication.\");\n               }\n               saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                   .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                   SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                       secretManager, this));\n               break;\n             default:\n               UserGroupInformation current \u003d UserGroupInformation\n                   .getCurrentUser();\n               String fullName \u003d current.getUserName();\n               if (LOG.isDebugEnabled())\n                 LOG.debug(\"Kerberos principal name is \" + fullName);\n               final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n               if (names.length !\u003d 3) {\n                 throw new AccessControlException(\n                     \"Kerberos principal name does NOT have the expected \"\n                         + \"hostname part: \" + fullName);\n               }\n               current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                 @Override\n                 public Object run() throws SaslException {\n                   saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                       .getMechanismName(), names[0], names[1],\n                       SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                   return null;\n                 }\n               });\n             }\n             if (saslServer \u003d\u003d null)\n               throw new AccessControlException(\n                   \"Unable to find SASL server implementation for \"\n                       + authMethod.getMechanismName());\n             if (LOG.isDebugEnabled())\n               LOG.debug(\"Created SASL server with mechanism \u003d \"\n                   + authMethod.getMechanismName());\n           }\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           replyToken \u003d saslServer.evaluateResponse(saslToken);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n               sendToClient.getLocalizedMessage());\n-          rpcMetrics.authenticationFailures.inc();\n+          rpcMetrics.incrAuthenticationFailures();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n           throw e;\n         }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n               null);\n         }\n         if (saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server successfully authenticated client: \" + user);\n           }\n-          rpcMetrics.authenticationSuccesses.inc();\n+          rpcMetrics.incrAuthenticationSuccesses();\n           AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         \n         if (!useWrap) {\n           processOneRpc(saslToken);\n         } else {\n           byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n               saslToken.length);\n           processUnwrappedData(plaintextData);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (saslServer \u003d\u003d null) {\n            switch (authMethod) {\n            case DIGEST:\n              if (secretManager \u003d\u003d null) {\n                throw new AccessControlException(\n                    \"Server is not configured to do DIGEST authentication.\");\n              }\n              saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                  .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                  SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                      secretManager, this));\n              break;\n            default:\n              UserGroupInformation current \u003d UserGroupInformation\n                  .getCurrentUser();\n              String fullName \u003d current.getUserName();\n              if (LOG.isDebugEnabled())\n                LOG.debug(\"Kerberos principal name is \" + fullName);\n              final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n              if (names.length !\u003d 3) {\n                throw new AccessControlException(\n                    \"Kerberos principal name does NOT have the expected \"\n                        + \"hostname part: \" + fullName);\n              }\n              current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                @Override\n                public Object run() throws SaslException {\n                  saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                      .getMechanismName(), names[0], names[1],\n                      SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                  return null;\n                }\n              });\n            }\n            if (saslServer \u003d\u003d null)\n              throw new AccessControlException(\n                  \"Unable to find SASL server implementation for \"\n                      + authMethod.getMechanismName());\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Created SASL server with mechanism \u003d \"\n                  + authMethod.getMechanismName());\n          }\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.incrAuthenticationFailures();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n          throw e;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.incrAuthenticationSuccesses();\n          AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "c0d70530b173beb2d53a4175236520df8e3967c8": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7272. Remove unnecessary security related info logs. Contributed by Suresh Srinivas.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1101668 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/05/11 3:24 PM",
      "commitName": "c0d70530b173beb2d53a4175236520df8e3967c8",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "21/03/11 2:10 PM",
      "commitNameOld": "0d55e1a14430ee18a84de6f985da86dc61d7ae80",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 50.05,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,105 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         byte[] replyToken \u003d null;\n         try {\n           if (saslServer \u003d\u003d null) {\n             switch (authMethod) {\n             case DIGEST:\n               if (secretManager \u003d\u003d null) {\n                 throw new AccessControlException(\n                     \"Server is not configured to do DIGEST authentication.\");\n               }\n               saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                   .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                   SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                       secretManager, this));\n               break;\n             default:\n               UserGroupInformation current \u003d UserGroupInformation\n                   .getCurrentUser();\n               String fullName \u003d current.getUserName();\n               if (LOG.isDebugEnabled())\n                 LOG.debug(\"Kerberos principal name is \" + fullName);\n               final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n               if (names.length !\u003d 3) {\n                 throw new AccessControlException(\n                     \"Kerberos principal name does NOT have the expected \"\n                         + \"hostname part: \" + fullName);\n               }\n               current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                 @Override\n                 public Object run() throws SaslException {\n                   saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                       .getMechanismName(), names[0], names[1],\n                       SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                   return null;\n                 }\n               });\n             }\n             if (saslServer \u003d\u003d null)\n               throw new AccessControlException(\n                   \"Unable to find SASL server implementation for \"\n                       + authMethod.getMechanismName());\n             if (LOG.isDebugEnabled())\n               LOG.debug(\"Created SASL server with mechanism \u003d \"\n                   + authMethod.getMechanismName());\n           }\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           replyToken \u003d saslServer.evaluateResponse(saslToken);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n               sendToClient.getLocalizedMessage());\n           rpcMetrics.authenticationFailures.inc();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n           throw e;\n         }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n               null);\n         }\n         if (saslServer.isComplete()) {\n-          LOG.info(\"SASL server context established. Negotiated QoP is \"\n-              + saslServer.getNegotiatedProperty(Sasl.QOP));\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n+                + saslServer.getNegotiatedProperty(Sasl.QOP));\n+          }\n           String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n           useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n-          LOG.info(\"SASL server successfully authenticated client: \" + user);\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n+          }\n           rpcMetrics.authenticationSuccesses.inc();\n           AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         \n         if (!useWrap) {\n           processOneRpc(saslToken);\n         } else {\n           byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n               saslToken.length);\n           processUnwrappedData(plaintextData);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (saslServer \u003d\u003d null) {\n            switch (authMethod) {\n            case DIGEST:\n              if (secretManager \u003d\u003d null) {\n                throw new AccessControlException(\n                    \"Server is not configured to do DIGEST authentication.\");\n              }\n              saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                  .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                  SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                      secretManager, this));\n              break;\n            default:\n              UserGroupInformation current \u003d UserGroupInformation\n                  .getCurrentUser();\n              String fullName \u003d current.getUserName();\n              if (LOG.isDebugEnabled())\n                LOG.debug(\"Kerberos principal name is \" + fullName);\n              final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n              if (names.length !\u003d 3) {\n                throw new AccessControlException(\n                    \"Kerberos principal name does NOT have the expected \"\n                        + \"hostname part: \" + fullName);\n              }\n              current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                @Override\n                public Object run() throws SaslException {\n                  saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                      .getMechanismName(), names[0], names[1],\n                      SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                  return null;\n                }\n              });\n            }\n            if (saslServer \u003d\u003d null)\n              throw new AccessControlException(\n                  \"Unable to find SASL server implementation for \"\n                      + authMethod.getMechanismName());\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Created SASL server with mechanism \u003d \"\n                  + authMethod.getMechanismName());\n          }\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.authenticationFailures.inc();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n          throw e;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server successfully authenticated client: \" + user);\n          }\n          rpcMetrics.authenticationSuccesses.inc();\n          AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "4b9c956bc56cec2c5b669102340d0912e0db3517": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6674. Makes use of the SASL authentication options in the SASL RPC. Contributed by Jitendra Pandey.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@951624 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/06/10 5:34 PM",
      "commitName": "4b9c956bc56cec2c5b669102340d0912e0db3517",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "26/05/10 1:31 PM",
      "commitNameOld": "24a2f1fafe2e13963c510cc04b3177c300af8aae",
      "commitAuthorOld": "Jakob Homan",
      "daysBetweenCommits": 9.17,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,101 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         byte[] replyToken \u003d null;\n         try {\n           if (saslServer \u003d\u003d null) {\n             switch (authMethod) {\n             case DIGEST:\n               if (secretManager \u003d\u003d null) {\n                 throw new AccessControlException(\n                     \"Server is not configured to do DIGEST authentication.\");\n               }\n               saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                   .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                   SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                       secretManager, this));\n               break;\n             default:\n               UserGroupInformation current \u003d UserGroupInformation\n                   .getCurrentUser();\n               String fullName \u003d current.getUserName();\n               if (LOG.isDebugEnabled())\n                 LOG.debug(\"Kerberos principal name is \" + fullName);\n               final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n               if (names.length !\u003d 3) {\n                 throw new AccessControlException(\n                     \"Kerberos principal name does NOT have the expected \"\n                         + \"hostname part: \" + fullName);\n               }\n               current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                 @Override\n                 public Object run() throws SaslException {\n                   saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                       .getMechanismName(), names[0], names[1],\n                       SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                   return null;\n                 }\n               });\n             }\n             if (saslServer \u003d\u003d null)\n               throw new AccessControlException(\n                   \"Unable to find SASL server implementation for \"\n                       + authMethod.getMechanismName());\n             if (LOG.isDebugEnabled())\n               LOG.debug(\"Created SASL server with mechanism \u003d \"\n                   + authMethod.getMechanismName());\n           }\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           replyToken \u003d saslServer.evaluateResponse(saslToken);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n               sendToClient.getLocalizedMessage());\n           rpcMetrics.authenticationFailures.inc();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n           AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n           throw e;\n         }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n               null);\n         }\n         if (saslServer.isComplete()) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n-                + saslServer.getNegotiatedProperty(Sasl.QOP));\n-          }\n+          LOG.info(\"SASL server context established. Negotiated QoP is \"\n+              + saslServer.getNegotiatedProperty(Sasl.QOP));\n+          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n+          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           LOG.info(\"SASL server successfully authenticated client: \" + user);\n           rpcMetrics.authenticationSuccesses.inc();\n           AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n-        byte[] plaintextData \u003d saslServer\n-            .unwrap(saslToken, 0, saslToken.length);\n-        processUnwrappedData(plaintextData);\n+        \n+        if (!useWrap) {\n+          processOneRpc(saslToken);\n+        } else {\n+          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n+              saslToken.length);\n+          processUnwrappedData(plaintextData);\n+        }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (saslServer \u003d\u003d null) {\n            switch (authMethod) {\n            case DIGEST:\n              if (secretManager \u003d\u003d null) {\n                throw new AccessControlException(\n                    \"Server is not configured to do DIGEST authentication.\");\n              }\n              saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                  .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                  SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                      secretManager, this));\n              break;\n            default:\n              UserGroupInformation current \u003d UserGroupInformation\n                  .getCurrentUser();\n              String fullName \u003d current.getUserName();\n              if (LOG.isDebugEnabled())\n                LOG.debug(\"Kerberos principal name is \" + fullName);\n              final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n              if (names.length !\u003d 3) {\n                throw new AccessControlException(\n                    \"Kerberos principal name does NOT have the expected \"\n                        + \"hostname part: \" + fullName);\n              }\n              current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                @Override\n                public Object run() throws SaslException {\n                  saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                      .getMechanismName(), names[0], names[1],\n                      SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                  return null;\n                }\n              });\n            }\n            if (saslServer \u003d\u003d null)\n              throw new AccessControlException(\n                  \"Unable to find SASL server implementation for \"\n                      + authMethod.getMechanismName());\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Created SASL server with mechanism \u003d \"\n                  + authMethod.getMechanismName());\n          }\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.authenticationFailures.inc();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n          throw e;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          LOG.info(\"SASL server context established. Negotiated QoP is \"\n              + saslServer.getNegotiatedProperty(Sasl.QOP));\n          String qop \u003d (String) saslServer.getNegotiatedProperty(Sasl.QOP);\n          useWrap \u003d qop !\u003d null \u0026\u0026 !\"auth\".equalsIgnoreCase(qop);\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          LOG.info(\"SASL server successfully authenticated client: \" + user);\n          rpcMetrics.authenticationSuccesses.inc();\n          AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        \n        if (!useWrap) {\n          processOneRpc(saslToken);\n        } else {\n          byte[] plaintextData \u003d saslServer.unwrap(saslToken, 0,\n              saslToken.length);\n          processUnwrappedData(plaintextData);\n        }\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "f4998a781376e1f15a2b72135eaa3db38bebde99": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6781. security audit log shouldn\u0027t have exception in it.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@946815 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/05/10 4:11 PM",
      "commitName": "f4998a781376e1f15a2b72135eaa3db38bebde99",
      "commitAuthor": "Boris Shkolnik",
      "commitDateOld": "13/05/10 1:52 PM",
      "commitNameOld": "d9b6103f8f63f66c254a7bd3a423a2a5fb6672e3",
      "commitAuthorOld": "Boris Shkolnik",
      "daysBetweenCommits": 7.1,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,96 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         byte[] replyToken \u003d null;\n         try {\n           if (saslServer \u003d\u003d null) {\n             switch (authMethod) {\n             case DIGEST:\n               if (secretManager \u003d\u003d null) {\n                 throw new AccessControlException(\n                     \"Server is not configured to do DIGEST authentication.\");\n               }\n               saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                   .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                   SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                       secretManager, this));\n               break;\n             default:\n               UserGroupInformation current \u003d UserGroupInformation\n                   .getCurrentUser();\n               String fullName \u003d current.getUserName();\n               if (LOG.isDebugEnabled())\n                 LOG.debug(\"Kerberos principal name is \" + fullName);\n               final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n               if (names.length !\u003d 3) {\n                 throw new AccessControlException(\n                     \"Kerberos principal name does NOT have the expected \"\n                         + \"hostname part: \" + fullName);\n               }\n               current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                 @Override\n                 public Object run() throws SaslException {\n                   saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                       .getMechanismName(), names[0], names[1],\n                       SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                   return null;\n                 }\n               });\n             }\n             if (saslServer \u003d\u003d null)\n               throw new AccessControlException(\n                   \"Unable to find SASL server implementation for \"\n                       + authMethod.getMechanismName());\n             if (LOG.isDebugEnabled())\n               LOG.debug(\"Created SASL server with mechanism \u003d \"\n                   + authMethod.getMechanismName());\n           }\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Have read input token of size \" + saslToken.length\n                 + \" for processing by saslServer.evaluateResponse()\");\n           replyToken \u003d saslServer.evaluateResponse(saslToken);\n         } catch (IOException e) {\n           IOException sendToClient \u003d e;\n           Throwable cause \u003d e;\n           while (cause !\u003d null) {\n             if (cause instanceof InvalidToken) {\n               sendToClient \u003d (InvalidToken) cause;\n               break;\n             }\n             cause \u003d cause.getCause();\n           }\n           doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n               sendToClient.getLocalizedMessage());\n           rpcMetrics.authenticationFailures.inc();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n-          auditLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser, e);\n+          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n           throw e;\n         }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n               null);\n         }\n         if (saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           LOG.info(\"SASL server successfully authenticated client: \" + user);\n           rpcMetrics.authenticationSuccesses.inc();\n-          auditLOG.info(AUTH_SUCCESSFULL_FOR + user);\n+          AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         byte[] plaintextData \u003d saslServer\n             .unwrap(saslToken, 0, saslToken.length);\n         processUnwrappedData(plaintextData);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (saslServer \u003d\u003d null) {\n            switch (authMethod) {\n            case DIGEST:\n              if (secretManager \u003d\u003d null) {\n                throw new AccessControlException(\n                    \"Server is not configured to do DIGEST authentication.\");\n              }\n              saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                  .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                  SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                      secretManager, this));\n              break;\n            default:\n              UserGroupInformation current \u003d UserGroupInformation\n                  .getCurrentUser();\n              String fullName \u003d current.getUserName();\n              if (LOG.isDebugEnabled())\n                LOG.debug(\"Kerberos principal name is \" + fullName);\n              final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n              if (names.length !\u003d 3) {\n                throw new AccessControlException(\n                    \"Kerberos principal name does NOT have the expected \"\n                        + \"hostname part: \" + fullName);\n              }\n              current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                @Override\n                public Object run() throws SaslException {\n                  saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                      .getMechanismName(), names[0], names[1],\n                      SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                  return null;\n                }\n              });\n            }\n            if (saslServer \u003d\u003d null)\n              throw new AccessControlException(\n                  \"Unable to find SASL server implementation for \"\n                      + authMethod.getMechanismName());\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Created SASL server with mechanism \u003d \"\n                  + authMethod.getMechanismName());\n          }\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.authenticationFailures.inc();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          AUDITLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser);\n          throw e;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          LOG.info(\"SASL server successfully authenticated client: \" + user);\n          rpcMetrics.authenticationSuccesses.inc();\n          AUDITLOG.info(AUTH_SUCCESSFULL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        byte[] plaintextData \u003d saslServer\n            .unwrap(saslToken, 0, saslToken.length);\n        processUnwrappedData(plaintextData);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6589. Provide better error messages when RPC authentication fails.\n(Kan Zhang via omalley)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@916915 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/02/10 10:17 PM",
      "commitName": "c93a9128ff14605fe9c08c0f5bb3fa374d852eaf",
      "commitAuthor": "Owen O\u0027Malley",
      "commitDateOld": "26/02/10 10:35 AM",
      "commitNameOld": "c4c122a0def592136e03a653c9fdc4f464ed0854",
      "commitAuthorOld": "Boris Shkolnik",
      "daysBetweenCommits": 0.49,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,96 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n-        if (saslServer \u003d\u003d null) {\n-          switch (authMethod) {\n-          case DIGEST:\n-            saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n-                .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n-                SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n-                    secretManager, this));\n-            break;\n-          default:\n-            UserGroupInformation current \u003d UserGroupInformation\n-                .getCurrentUser();\n-            String fullName \u003d current.getUserName();\n-            if (LOG.isDebugEnabled())\n-              LOG.debug(\"Kerberos principal name is \" + fullName);\n-            final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n-            if (names.length !\u003d 3) {\n-              throw new IOException(\n-                  \"Kerberos principal name does NOT have the expected \"\n-                      + \"hostname part: \" + fullName);\n-            }\n-            current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n-              @Override\n-              public Object run() throws IOException {\n-                saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n-                    .getMechanismName(), names[0], names[1],\n-                    SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n-                return null;\n-              }\n-            });\n-          }\n-          if (saslServer \u003d\u003d null)\n-            throw new IOException(\n-                \"Unable to find SASL server implementation for \"\n-                    + authMethod.getMechanismName());\n-          if (LOG.isDebugEnabled())\n-            LOG.debug(\"Created SASL server with mechanism \u003d \"\n-                + authMethod.getMechanismName());\n-        }\n-        if (LOG.isDebugEnabled())\n-          LOG.debug(\"Have read input token of size \" + saslToken.length\n-              + \" for processing by saslServer.evaluateResponse()\");\n-        byte[] replyToken;\n+        byte[] replyToken \u003d null;\n         try {\n+          if (saslServer \u003d\u003d null) {\n+            switch (authMethod) {\n+            case DIGEST:\n+              if (secretManager \u003d\u003d null) {\n+                throw new AccessControlException(\n+                    \"Server is not configured to do DIGEST authentication.\");\n+              }\n+              saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n+                  .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n+                  SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n+                      secretManager, this));\n+              break;\n+            default:\n+              UserGroupInformation current \u003d UserGroupInformation\n+                  .getCurrentUser();\n+              String fullName \u003d current.getUserName();\n+              if (LOG.isDebugEnabled())\n+                LOG.debug(\"Kerberos principal name is \" + fullName);\n+              final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n+              if (names.length !\u003d 3) {\n+                throw new AccessControlException(\n+                    \"Kerberos principal name does NOT have the expected \"\n+                        + \"hostname part: \" + fullName);\n+              }\n+              current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+                @Override\n+                public Object run() throws SaslException {\n+                  saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n+                      .getMechanismName(), names[0], names[1],\n+                      SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n+                  return null;\n+                }\n+              });\n+            }\n+            if (saslServer \u003d\u003d null)\n+              throw new AccessControlException(\n+                  \"Unable to find SASL server implementation for \"\n+                      + authMethod.getMechanismName());\n+            if (LOG.isDebugEnabled())\n+              LOG.debug(\"Created SASL server with mechanism \u003d \"\n+                  + authMethod.getMechanismName());\n+          }\n+          if (LOG.isDebugEnabled())\n+            LOG.debug(\"Have read input token of size \" + saslToken.length\n+                + \" for processing by saslServer.evaluateResponse()\");\n           replyToken \u003d saslServer.evaluateResponse(saslToken);\n-        } catch (SaslException se) {\n+        } catch (IOException e) {\n+          IOException sendToClient \u003d e;\n+          Throwable cause \u003d e;\n+          while (cause !\u003d null) {\n+            if (cause instanceof InvalidToken) {\n+              sendToClient \u003d (InvalidToken) cause;\n+              break;\n+            }\n+            cause \u003d cause.getCause();\n+          }\n+          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n+              sendToClient.getLocalizedMessage());\n           rpcMetrics.authenticationFailures.inc();\n           String clientIP \u003d this.toString();\n           // attempting user could be null\n-          auditLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser, se);\n-          throw se;\n+          auditLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser, e);\n+          throw e;\n         }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n-          saslCall.connection \u003d this;\n-          saslResponse.reset();\n-          DataOutputStream out \u003d new DataOutputStream(saslResponse);\n-          out.writeInt(replyToken.length);\n-          out.write(replyToken, 0, replyToken.length);\n-          saslCall.setResponse(ByteBuffer.wrap(saslResponse.toByteArray()));\n-          responder.doRespond(saslCall);\n+          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n+              null);\n         }\n         if (saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           LOG.info(\"SASL server successfully authenticated client: \" + user);\n           rpcMetrics.authenticationSuccesses.inc();\n           auditLOG.info(AUTH_SUCCESSFULL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         byte[] plaintextData \u003d saslServer\n             .unwrap(saslToken, 0, saslToken.length);\n         processUnwrappedData(plaintextData);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        byte[] replyToken \u003d null;\n        try {\n          if (saslServer \u003d\u003d null) {\n            switch (authMethod) {\n            case DIGEST:\n              if (secretManager \u003d\u003d null) {\n                throw new AccessControlException(\n                    \"Server is not configured to do DIGEST authentication.\");\n              }\n              saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                  .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                  SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                      secretManager, this));\n              break;\n            default:\n              UserGroupInformation current \u003d UserGroupInformation\n                  .getCurrentUser();\n              String fullName \u003d current.getUserName();\n              if (LOG.isDebugEnabled())\n                LOG.debug(\"Kerberos principal name is \" + fullName);\n              final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n              if (names.length !\u003d 3) {\n                throw new AccessControlException(\n                    \"Kerberos principal name does NOT have the expected \"\n                        + \"hostname part: \" + fullName);\n              }\n              current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n                @Override\n                public Object run() throws SaslException {\n                  saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                      .getMechanismName(), names[0], names[1],\n                      SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                  return null;\n                }\n              });\n            }\n            if (saslServer \u003d\u003d null)\n              throw new AccessControlException(\n                  \"Unable to find SASL server implementation for \"\n                      + authMethod.getMechanismName());\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Created SASL server with mechanism \u003d \"\n                  + authMethod.getMechanismName());\n          }\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Have read input token of size \" + saslToken.length\n                + \" for processing by saslServer.evaluateResponse()\");\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (IOException e) {\n          IOException sendToClient \u003d e;\n          Throwable cause \u003d e;\n          while (cause !\u003d null) {\n            if (cause instanceof InvalidToken) {\n              sendToClient \u003d (InvalidToken) cause;\n              break;\n            }\n            cause \u003d cause.getCause();\n          }\n          doSaslReply(SaslStatus.ERROR, null, sendToClient.getClass().getName(), \n              sendToClient.getLocalizedMessage());\n          rpcMetrics.authenticationFailures.inc();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          auditLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser, e);\n          throw e;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          doSaslReply(SaslStatus.SUCCESS, new BytesWritable(replyToken), null,\n              null);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          LOG.info(\"SASL server successfully authenticated client: \" + user);\n          rpcMetrics.authenticationSuccesses.inc();\n          auditLOG.info(AUTH_SUCCESSFULL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        byte[] plaintextData \u003d saslServer\n            .unwrap(saslToken, 0, saslToken.length);\n        processUnwrappedData(plaintextData);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "c4c122a0def592136e03a653c9fdc4f464ed0854": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6586. Log authentication and authorization failures and successes for RPC\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@916779 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/02/10 10:35 AM",
      "commitName": "c4c122a0def592136e03a653c9fdc4f464ed0854",
      "commitAuthor": "Boris Shkolnik",
      "commitDateOld": "25/02/10 5:37 PM",
      "commitNameOld": "ea650d8d6c139ab7d6078c09da5c3cf72f2915fb",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,86 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         if (saslServer \u003d\u003d null) {\n           switch (authMethod) {\n           case DIGEST:\n             saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                 .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                 SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n-                    secretManager));\n+                    secretManager, this));\n             break;\n           default:\n             UserGroupInformation current \u003d UserGroupInformation\n                 .getCurrentUser();\n             String fullName \u003d current.getUserName();\n             if (LOG.isDebugEnabled())\n               LOG.debug(\"Kerberos principal name is \" + fullName);\n             final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n             if (names.length !\u003d 3) {\n               throw new IOException(\n                   \"Kerberos principal name does NOT have the expected \"\n                       + \"hostname part: \" + fullName);\n             }\n             current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws IOException {\n                 saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                     .getMechanismName(), names[0], names[1],\n                     SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                 return null;\n               }\n             });\n           }\n           if (saslServer \u003d\u003d null)\n             throw new IOException(\n                 \"Unable to find SASL server implementation for \"\n                     + authMethod.getMechanismName());\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Created SASL server with mechanism \u003d \"\n                 + authMethod.getMechanismName());\n         }\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.evaluateResponse()\");\n         byte[] replyToken;\n         try {\n           replyToken \u003d saslServer.evaluateResponse(saslToken);\n         } catch (SaslException se) {\n           rpcMetrics.authenticationFailures.inc();\n+          String clientIP \u003d this.toString();\n+          // attempting user could be null\n+          auditLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser, se);\n           throw se;\n         }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           saslCall.connection \u003d this;\n           saslResponse.reset();\n           DataOutputStream out \u003d new DataOutputStream(saslResponse);\n           out.writeInt(replyToken.length);\n           out.write(replyToken, 0, replyToken.length);\n           saslCall.setResponse(ByteBuffer.wrap(saslResponse.toByteArray()));\n           responder.doRespond(saslCall);\n         }\n         if (saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           LOG.info(\"SASL server successfully authenticated client: \" + user);\n+          rpcMetrics.authenticationSuccesses.inc();\n+          auditLOG.info(AUTH_SUCCESSFULL_FOR + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         byte[] plaintextData \u003d saslServer\n             .unwrap(saslToken, 0, saslToken.length);\n         processUnwrappedData(plaintextData);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        if (saslServer \u003d\u003d null) {\n          switch (authMethod) {\n          case DIGEST:\n            saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                    secretManager, this));\n            break;\n          default:\n            UserGroupInformation current \u003d UserGroupInformation\n                .getCurrentUser();\n            String fullName \u003d current.getUserName();\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Kerberos principal name is \" + fullName);\n            final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n            if (names.length !\u003d 3) {\n              throw new IOException(\n                  \"Kerberos principal name does NOT have the expected \"\n                      + \"hostname part: \" + fullName);\n            }\n            current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws IOException {\n                saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                    .getMechanismName(), names[0], names[1],\n                    SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                return null;\n              }\n            });\n          }\n          if (saslServer \u003d\u003d null)\n            throw new IOException(\n                \"Unable to find SASL server implementation for \"\n                    + authMethod.getMechanismName());\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Created SASL server with mechanism \u003d \"\n                + authMethod.getMechanismName());\n        }\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.evaluateResponse()\");\n        byte[] replyToken;\n        try {\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (SaslException se) {\n          rpcMetrics.authenticationFailures.inc();\n          String clientIP \u003d this.toString();\n          // attempting user could be null\n          auditLOG.warn(AUTH_FAILED_FOR + clientIP + \":\" + attemptingUser, se);\n          throw se;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          saslCall.connection \u003d this;\n          saslResponse.reset();\n          DataOutputStream out \u003d new DataOutputStream(saslResponse);\n          out.writeInt(replyToken.length);\n          out.write(replyToken, 0, replyToken.length);\n          saslCall.setResponse(ByteBuffer.wrap(saslResponse.toByteArray()));\n          responder.doRespond(saslCall);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          LOG.info(\"SASL server successfully authenticated client: \" + user);\n          rpcMetrics.authenticationSuccesses.inc();\n          auditLOG.info(AUTH_SUCCESSFULL_FOR + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        byte[] plaintextData \u003d saslServer\n            .unwrap(saslToken, 0, saslToken.length);\n        processUnwrappedData(plaintextData);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "ffdde40b9f189cb30dee4c5187d63b61809f2d62": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6583. Captures authentication and authorization metrics. Contributed by Devaraj Das.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@915095 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/02/10 2:26 PM",
      "commitName": "ffdde40b9f189cb30dee4c5187d63b61809f2d62",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "19/02/10 5:23 PM",
      "commitNameOld": "9871771bb55b3da4fd03435ddb5990e20e546c0e",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 2.88,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,81 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         if (saslServer \u003d\u003d null) {\n           switch (authMethod) {\n           case DIGEST:\n             saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                 .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                 SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                     secretManager));\n             break;\n           default:\n             UserGroupInformation current \u003d UserGroupInformation\n                 .getCurrentUser();\n             String fullName \u003d current.getUserName();\n             if (LOG.isDebugEnabled())\n               LOG.debug(\"Kerberos principal name is \" + fullName);\n             final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n             if (names.length !\u003d 3) {\n               throw new IOException(\n                   \"Kerberos principal name does NOT have the expected \"\n                       + \"hostname part: \" + fullName);\n             }\n             current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws IOException {\n                 saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                     .getMechanismName(), names[0], names[1],\n                     SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                 return null;\n               }\n             });\n           }\n           if (saslServer \u003d\u003d null)\n             throw new IOException(\n                 \"Unable to find SASL server implementation for \"\n                     + authMethod.getMechanismName());\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Created SASL server with mechanism \u003d \"\n                 + authMethod.getMechanismName());\n         }\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.evaluateResponse()\");\n-        byte[] replyToken \u003d saslServer.evaluateResponse(saslToken);\n+        byte[] replyToken;\n+        try {\n+          replyToken \u003d saslServer.evaluateResponse(saslToken);\n+        } catch (SaslException se) {\n+          rpcMetrics.authenticationFailures.inc();\n+          throw se;\n+        }\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           saslCall.connection \u003d this;\n           saslResponse.reset();\n           DataOutputStream out \u003d new DataOutputStream(saslResponse);\n           out.writeInt(replyToken.length);\n           out.write(replyToken, 0, replyToken.length);\n           saslCall.setResponse(ByteBuffer.wrap(saslResponse.toByteArray()));\n           responder.doRespond(saslCall);\n         }\n         if (saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n           user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           LOG.info(\"SASL server successfully authenticated client: \" + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         byte[] plaintextData \u003d saslServer\n             .unwrap(saslToken, 0, saslToken.length);\n         processUnwrappedData(plaintextData);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        if (saslServer \u003d\u003d null) {\n          switch (authMethod) {\n          case DIGEST:\n            saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                    secretManager));\n            break;\n          default:\n            UserGroupInformation current \u003d UserGroupInformation\n                .getCurrentUser();\n            String fullName \u003d current.getUserName();\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Kerberos principal name is \" + fullName);\n            final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n            if (names.length !\u003d 3) {\n              throw new IOException(\n                  \"Kerberos principal name does NOT have the expected \"\n                      + \"hostname part: \" + fullName);\n            }\n            current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws IOException {\n                saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                    .getMechanismName(), names[0], names[1],\n                    SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                return null;\n              }\n            });\n          }\n          if (saslServer \u003d\u003d null)\n            throw new IOException(\n                \"Unable to find SASL server implementation for \"\n                    + authMethod.getMechanismName());\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Created SASL server with mechanism \u003d \"\n                + authMethod.getMechanismName());\n        }\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.evaluateResponse()\");\n        byte[] replyToken;\n        try {\n          replyToken \u003d saslServer.evaluateResponse(saslToken);\n        } catch (SaslException se) {\n          rpcMetrics.authenticationFailures.inc();\n          throw se;\n        }\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          saslCall.connection \u003d this;\n          saslResponse.reset();\n          DataOutputStream out \u003d new DataOutputStream(saslResponse);\n          out.writeInt(replyToken.length);\n          out.write(replyToken, 0, replyToken.length);\n          saslCall.setResponse(ByteBuffer.wrap(saslResponse.toByteArray()));\n          responder.doRespond(saslCall);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          LOG.info(\"SASL server successfully authenticated client: \" + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        byte[] plaintextData \u003d saslServer\n            .unwrap(saslToken, 0, saslToken.length);\n        processUnwrappedData(plaintextData);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "1793e7d9094cd984ae402177c5935239059d74e8": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6510. Adds a way for superusers to impersonate other users in a secure environment. Contributed by Jitendra Nath Pandey.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@907549 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/02/10 8:55 PM",
      "commitName": "1793e7d9094cd984ae402177c5935239059d74e8",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "02/02/10 5:30 PM",
      "commitNameOld": "940389afce6a1b9b9e1519aed528cbc444786756",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 5.14,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,75 @@\n     private void saslReadAndProcess(byte[] saslToken) throws IOException,\n         InterruptedException {\n       if (!saslContextEstablished) {\n         if (saslServer \u003d\u003d null) {\n           switch (authMethod) {\n           case DIGEST:\n             saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                 .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                 SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                     secretManager));\n             break;\n           default:\n             UserGroupInformation current \u003d UserGroupInformation\n                 .getCurrentUser();\n             String fullName \u003d current.getUserName();\n             if (LOG.isDebugEnabled())\n               LOG.debug(\"Kerberos principal name is \" + fullName);\n             final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n             if (names.length !\u003d 3) {\n               throw new IOException(\n                   \"Kerberos principal name does NOT have the expected \"\n                       + \"hostname part: \" + fullName);\n             }\n             current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws IOException {\n                 saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                     .getMechanismName(), names[0], names[1],\n                     SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                 return null;\n               }\n             });\n           }\n           if (saslServer \u003d\u003d null)\n             throw new IOException(\n                 \"Unable to find SASL server implementation for \"\n                     + authMethod.getMechanismName());\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Created SASL server with mechanism \u003d \"\n                 + authMethod.getMechanismName());\n         }\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.evaluateResponse()\");\n         byte[] replyToken \u003d saslServer.evaluateResponse(saslToken);\n         if (replyToken !\u003d null) {\n           if (LOG.isDebugEnabled())\n             LOG.debug(\"Will send token of size \" + replyToken.length\n                 + \" from saslServer.\");\n           saslCall.connection \u003d this;\n           saslResponse.reset();\n           DataOutputStream out \u003d new DataOutputStream(saslResponse);\n           out.writeInt(replyToken.length);\n           out.write(replyToken, 0, replyToken.length);\n           saslCall.setResponse(ByteBuffer.wrap(saslResponse.toByteArray()));\n           responder.doRespond(saslCall);\n         }\n         if (saslServer.isComplete()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                 + saslServer.getNegotiatedProperty(Sasl.QOP));\n           }\n-          user \u003d UserGroupInformation.createRemoteUser(saslServer\n-              .getAuthorizationID());\n+          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n           LOG.info(\"SASL server successfully authenticated client: \" + user);\n           saslContextEstablished \u003d true;\n         }\n       } else {\n         if (LOG.isDebugEnabled())\n           LOG.debug(\"Have read input token of size \" + saslToken.length\n               + \" for processing by saslServer.unwrap()\");\n         byte[] plaintextData \u003d saslServer\n             .unwrap(saslToken, 0, saslToken.length);\n         processUnwrappedData(plaintextData);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        if (saslServer \u003d\u003d null) {\n          switch (authMethod) {\n          case DIGEST:\n            saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                    secretManager));\n            break;\n          default:\n            UserGroupInformation current \u003d UserGroupInformation\n                .getCurrentUser();\n            String fullName \u003d current.getUserName();\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Kerberos principal name is \" + fullName);\n            final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n            if (names.length !\u003d 3) {\n              throw new IOException(\n                  \"Kerberos principal name does NOT have the expected \"\n                      + \"hostname part: \" + fullName);\n            }\n            current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws IOException {\n                saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                    .getMechanismName(), names[0], names[1],\n                    SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                return null;\n              }\n            });\n          }\n          if (saslServer \u003d\u003d null)\n            throw new IOException(\n                \"Unable to find SASL server implementation for \"\n                    + authMethod.getMechanismName());\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Created SASL server with mechanism \u003d \"\n                + authMethod.getMechanismName());\n        }\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.evaluateResponse()\");\n        byte[] replyToken \u003d saslServer.evaluateResponse(saslToken);\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          saslCall.connection \u003d this;\n          saslResponse.reset();\n          DataOutputStream out \u003d new DataOutputStream(saslResponse);\n          out.writeInt(replyToken.length);\n          out.write(replyToken, 0, replyToken.length);\n          saslCall.setResponse(ByteBuffer.wrap(saslResponse.toByteArray()));\n          responder.doRespond(saslCall);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          user \u003d getAuthorizedUgi(saslServer.getAuthorizationID());\n          LOG.info(\"SASL server successfully authenticated client: \" + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        byte[] plaintextData \u003d saslServer\n            .unwrap(saslToken, 0, saslToken.length);\n        processUnwrappedData(plaintextData);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "940389afce6a1b9b9e1519aed528cbc444786756": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-6419. Adds SASL based authentication to RPC. Contributed by Kan Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@905860 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/02/10 5:30 PM",
      "commitName": "940389afce6a1b9b9e1519aed528cbc444786756",
      "commitAuthor": "Devaraj Das",
      "diff": "@@ -0,0 +1,76 @@\n+    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n+        InterruptedException {\n+      if (!saslContextEstablished) {\n+        if (saslServer \u003d\u003d null) {\n+          switch (authMethod) {\n+          case DIGEST:\n+            saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n+                .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n+                SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n+                    secretManager));\n+            break;\n+          default:\n+            UserGroupInformation current \u003d UserGroupInformation\n+                .getCurrentUser();\n+            String fullName \u003d current.getUserName();\n+            if (LOG.isDebugEnabled())\n+              LOG.debug(\"Kerberos principal name is \" + fullName);\n+            final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n+            if (names.length !\u003d 3) {\n+              throw new IOException(\n+                  \"Kerberos principal name does NOT have the expected \"\n+                      + \"hostname part: \" + fullName);\n+            }\n+            current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+              @Override\n+              public Object run() throws IOException {\n+                saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n+                    .getMechanismName(), names[0], names[1],\n+                    SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n+                return null;\n+              }\n+            });\n+          }\n+          if (saslServer \u003d\u003d null)\n+            throw new IOException(\n+                \"Unable to find SASL server implementation for \"\n+                    + authMethod.getMechanismName());\n+          if (LOG.isDebugEnabled())\n+            LOG.debug(\"Created SASL server with mechanism \u003d \"\n+                + authMethod.getMechanismName());\n+        }\n+        if (LOG.isDebugEnabled())\n+          LOG.debug(\"Have read input token of size \" + saslToken.length\n+              + \" for processing by saslServer.evaluateResponse()\");\n+        byte[] replyToken \u003d saslServer.evaluateResponse(saslToken);\n+        if (replyToken !\u003d null) {\n+          if (LOG.isDebugEnabled())\n+            LOG.debug(\"Will send token of size \" + replyToken.length\n+                + \" from saslServer.\");\n+          saslCall.connection \u003d this;\n+          saslResponse.reset();\n+          DataOutputStream out \u003d new DataOutputStream(saslResponse);\n+          out.writeInt(replyToken.length);\n+          out.write(replyToken, 0, replyToken.length);\n+          saslCall.setResponse(ByteBuffer.wrap(saslResponse.toByteArray()));\n+          responder.doRespond(saslCall);\n+        }\n+        if (saslServer.isComplete()) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n+                + saslServer.getNegotiatedProperty(Sasl.QOP));\n+          }\n+          user \u003d UserGroupInformation.createRemoteUser(saslServer\n+              .getAuthorizationID());\n+          LOG.info(\"SASL server successfully authenticated client: \" + user);\n+          saslContextEstablished \u003d true;\n+        }\n+      } else {\n+        if (LOG.isDebugEnabled())\n+          LOG.debug(\"Have read input token of size \" + saslToken.length\n+              + \" for processing by saslServer.unwrap()\");\n+        byte[] plaintextData \u003d saslServer\n+            .unwrap(saslToken, 0, saslToken.length);\n+        processUnwrappedData(plaintextData);\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void saslReadAndProcess(byte[] saslToken) throws IOException,\n        InterruptedException {\n      if (!saslContextEstablished) {\n        if (saslServer \u003d\u003d null) {\n          switch (authMethod) {\n          case DIGEST:\n            saslServer \u003d Sasl.createSaslServer(AuthMethod.DIGEST\n                .getMechanismName(), null, SaslRpcServer.SASL_DEFAULT_REALM,\n                SaslRpcServer.SASL_PROPS, new SaslDigestCallbackHandler(\n                    secretManager));\n            break;\n          default:\n            UserGroupInformation current \u003d UserGroupInformation\n                .getCurrentUser();\n            String fullName \u003d current.getUserName();\n            if (LOG.isDebugEnabled())\n              LOG.debug(\"Kerberos principal name is \" + fullName);\n            final String names[] \u003d SaslRpcServer.splitKerberosName(fullName);\n            if (names.length !\u003d 3) {\n              throw new IOException(\n                  \"Kerberos principal name does NOT have the expected \"\n                      + \"hostname part: \" + fullName);\n            }\n            current.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws IOException {\n                saslServer \u003d Sasl.createSaslServer(AuthMethod.KERBEROS\n                    .getMechanismName(), names[0], names[1],\n                    SaslRpcServer.SASL_PROPS, new SaslGssCallbackHandler());\n                return null;\n              }\n            });\n          }\n          if (saslServer \u003d\u003d null)\n            throw new IOException(\n                \"Unable to find SASL server implementation for \"\n                    + authMethod.getMechanismName());\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Created SASL server with mechanism \u003d \"\n                + authMethod.getMechanismName());\n        }\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.evaluateResponse()\");\n        byte[] replyToken \u003d saslServer.evaluateResponse(saslToken);\n        if (replyToken !\u003d null) {\n          if (LOG.isDebugEnabled())\n            LOG.debug(\"Will send token of size \" + replyToken.length\n                + \" from saslServer.\");\n          saslCall.connection \u003d this;\n          saslResponse.reset();\n          DataOutputStream out \u003d new DataOutputStream(saslResponse);\n          out.writeInt(replyToken.length);\n          out.write(replyToken, 0, replyToken.length);\n          saslCall.setResponse(ByteBuffer.wrap(saslResponse.toByteArray()));\n          responder.doRespond(saslCall);\n        }\n        if (saslServer.isComplete()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"SASL server context established. Negotiated QoP is \"\n                + saslServer.getNegotiatedProperty(Sasl.QOP));\n          }\n          user \u003d UserGroupInformation.createRemoteUser(saslServer\n              .getAuthorizationID());\n          LOG.info(\"SASL server successfully authenticated client: \" + user);\n          saslContextEstablished \u003d true;\n        }\n      } else {\n        if (LOG.isDebugEnabled())\n          LOG.debug(\"Have read input token of size \" + saslToken.length\n              + \" for processing by saslServer.unwrap()\");\n        byte[] plaintextData \u003d saslServer\n            .unwrap(saslToken, 0, saslToken.length);\n        processUnwrappedData(plaintextData);\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java"
    }
  }
}