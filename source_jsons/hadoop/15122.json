{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "OfflineImageReconstructor.java",
  "functionName": "processXml",
  "functionId": "processXml",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java",
  "functionStartLine": 1749,
  "functionEndLine": 1813,
  "numCommitsSeen": 15,
  "timeTaken": 1132,
  "changeHistory": [
    "700b0e4019cf483f7532609711812150b8c44742"
  ],
  "changeHistoryShort": {
    "700b0e4019cf483f7532609711812150b8c44742": "Yintroduced"
  },
  "changeHistoryDetails": {
    "700b0e4019cf483f7532609711812150b8c44742": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9835. OIV: add ReverseXML processor which reconstructs an fsimage from an XML file (cmccabe)\n",
      "commitDate": "02/03/16 5:56 PM",
      "commitName": "700b0e4019cf483f7532609711812150b8c44742",
      "commitAuthor": "Colin Patrick Mccabe",
      "diff": "@@ -0,0 +1,65 @@\n+  private void processXml() throws Exception {\n+    LOG.debug(\"Loading \u003cfsimage\u003e.\");\n+    expectTag(\"fsimage\", false);\n+    // Read the \u003cversion\u003e tag.\n+    readVersion();\n+    // Write the HDFSIMG1 magic number which begins the fsimage file.\n+    out.write(FSImageUtil.MAGIC_HEADER);\n+    // Write a series of fsimage sections.\n+    sectionStartOffset \u003d FSImageUtil.MAGIC_HEADER.length;\n+    final HashSet\u003cString\u003e unprocessedSections \u003d\n+        new HashSet\u003c\u003e(sections.keySet());\n+    while (!unprocessedSections.isEmpty()) {\n+      XMLEvent ev \u003d expectTag(\"[section header]\", true);\n+      if (ev.getEventType() \u003d\u003d XMLStreamConstants.END_ELEMENT) {\n+        if (ev.asEndElement().getName().getLocalPart().equals(\"fsimage\")) {\n+          throw new IOException(\"FSImage XML ended prematurely, without \" +\n+              \"including section(s) \" + StringUtils.join(\", \",\n+              unprocessedSections));\n+        }\n+        throw new IOException(\"Got unexpected tag end event for \" +\n+            ev.asEndElement().getName().getLocalPart() + \" while looking \" +\n+            \"for section header tag.\");\n+      } else if (ev.getEventType() !\u003d XMLStreamConstants.START_ELEMENT) {\n+        throw new IOException(\"Expected section header START_ELEMENT; \" +\n+            \"got event of type \" + ev.getEventType());\n+      }\n+      String sectionName \u003d ev.asStartElement().getName().getLocalPart();\n+      if (!unprocessedSections.contains(sectionName)) {\n+        throw new IOException(\"Unknown or duplicate section found for \" +\n+            sectionName);\n+      }\n+      SectionProcessor sectionProcessor \u003d sections.get(sectionName);\n+      if (sectionProcessor \u003d\u003d null) {\n+        throw new IOException(\"Unknown FSImage section \" + sectionName +\n+            \".  Valid section names are [\" +\n+            StringUtils.join(\", \", sections.keySet()) + \"]\");\n+      }\n+      unprocessedSections.remove(sectionName);\n+      sectionProcessor.process();\n+    }\n+\n+    // Write the StringTable section to disk.\n+    // This has to be done after the other sections, since some of them\n+    // add entries to the string table.\n+    writeStringTableSection();\n+\n+    // Write the FileSummary section to disk.\n+    // This section is always last.\n+    long prevOffset \u003d out.getCount();\n+    FileSummary fileSummary \u003d fileSummaryBld.build();\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Writing FileSummary: {\" +\n+          TextFormat.printToString(fileSummary) + \"}\");\n+    }\n+    // Even though the last 4 bytes of the file gives the FileSummary length,\n+    // we still write a varint first that also contains the length.\n+    fileSummary.writeDelimitedTo(out);\n+\n+    // Write the length of the FileSummary section as a fixed-size big\n+    // endian 4-byte quantity.\n+    int summaryLen \u003d Ints.checkedCast(out.getCount() - prevOffset);\n+    byte[] summaryLenBytes \u003d new byte[4];\n+    ByteBuffer.wrap(summaryLenBytes).asIntBuffer().put(summaryLen);\n+    out.write(summaryLenBytes);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void processXml() throws Exception {\n    LOG.debug(\"Loading \u003cfsimage\u003e.\");\n    expectTag(\"fsimage\", false);\n    // Read the \u003cversion\u003e tag.\n    readVersion();\n    // Write the HDFSIMG1 magic number which begins the fsimage file.\n    out.write(FSImageUtil.MAGIC_HEADER);\n    // Write a series of fsimage sections.\n    sectionStartOffset \u003d FSImageUtil.MAGIC_HEADER.length;\n    final HashSet\u003cString\u003e unprocessedSections \u003d\n        new HashSet\u003c\u003e(sections.keySet());\n    while (!unprocessedSections.isEmpty()) {\n      XMLEvent ev \u003d expectTag(\"[section header]\", true);\n      if (ev.getEventType() \u003d\u003d XMLStreamConstants.END_ELEMENT) {\n        if (ev.asEndElement().getName().getLocalPart().equals(\"fsimage\")) {\n          throw new IOException(\"FSImage XML ended prematurely, without \" +\n              \"including section(s) \" + StringUtils.join(\", \",\n              unprocessedSections));\n        }\n        throw new IOException(\"Got unexpected tag end event for \" +\n            ev.asEndElement().getName().getLocalPart() + \" while looking \" +\n            \"for section header tag.\");\n      } else if (ev.getEventType() !\u003d XMLStreamConstants.START_ELEMENT) {\n        throw new IOException(\"Expected section header START_ELEMENT; \" +\n            \"got event of type \" + ev.getEventType());\n      }\n      String sectionName \u003d ev.asStartElement().getName().getLocalPart();\n      if (!unprocessedSections.contains(sectionName)) {\n        throw new IOException(\"Unknown or duplicate section found for \" +\n            sectionName);\n      }\n      SectionProcessor sectionProcessor \u003d sections.get(sectionName);\n      if (sectionProcessor \u003d\u003d null) {\n        throw new IOException(\"Unknown FSImage section \" + sectionName +\n            \".  Valid section names are [\" +\n            StringUtils.join(\", \", sections.keySet()) + \"]\");\n      }\n      unprocessedSections.remove(sectionName);\n      sectionProcessor.process();\n    }\n\n    // Write the StringTable section to disk.\n    // This has to be done after the other sections, since some of them\n    // add entries to the string table.\n    writeStringTableSection();\n\n    // Write the FileSummary section to disk.\n    // This section is always last.\n    long prevOffset \u003d out.getCount();\n    FileSummary fileSummary \u003d fileSummaryBld.build();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Writing FileSummary: {\" +\n          TextFormat.printToString(fileSummary) + \"}\");\n    }\n    // Even though the last 4 bytes of the file gives the FileSummary length,\n    // we still write a varint first that also contains the length.\n    fileSummary.writeDelimitedTo(out);\n\n    // Write the length of the FileSummary section as a fixed-size big\n    // endian 4-byte quantity.\n    int summaryLen \u003d Ints.checkedCast(out.getCount() - prevOffset);\n    byte[] summaryLenBytes \u003d new byte[4];\n    ByteBuffer.wrap(summaryLenBytes).asIntBuffer().put(summaryLen);\n    out.write(summaryLenBytes);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/offlineImageViewer/OfflineImageReconstructor.java"
    }
  }
}