{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "MRAppMaster.java",
  "functionName": "shouldAttemptRecovery",
  "functionId": "shouldAttemptRecovery",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
  "functionStartLine": 1353,
  "functionEndLine": 1399,
  "numCommitsSeen": 234,
  "timeTaken": 4516,
  "changeHistory": [
    "de7a0a92ca1983b35ca4beb7ab712fd700a9e6e0",
    "9e62bcca4e2ee4aaa3844d1d975dc0adc93ab602",
    "bb7ce82816574f67aa1898f67e0e0cff54fa67be",
    "ded91b4cfa22c8d7c498ea21c8c1ac52fe9a9e29",
    "b64572b06b1282128180b9ebdd971f9b1e973e61",
    "6a1c41111edcdc58c846fc50e53554fbba230171"
  ],
  "changeHistoryShort": {
    "de7a0a92ca1983b35ca4beb7ab712fd700a9e6e0": "Ymultichange(Yrename,Yreturntypechange,Ybodychange)",
    "9e62bcca4e2ee4aaa3844d1d975dc0adc93ab602": "Ybodychange",
    "bb7ce82816574f67aa1898f67e0e0cff54fa67be": "Ymultichange(Yexceptionschange,Ybodychange)",
    "ded91b4cfa22c8d7c498ea21c8c1ac52fe9a9e29": "Ybodychange",
    "b64572b06b1282128180b9ebdd971f9b1e973e61": "Ybodychange",
    "6a1c41111edcdc58c846fc50e53554fbba230171": "Yintroduced"
  },
  "changeHistoryDetails": {
    "de7a0a92ca1983b35ca4beb7ab712fd700a9e6e0": {
      "type": "Ymultichange(Yrename,Yreturntypechange,Ybodychange)",
      "commitMessage": "MAPREDUCE-6638. Do not attempt to recover progress from previous job attempts if spill encryption is enabled. (Haibo Chen via kasha)\n",
      "commitDate": "03/10/16 10:30 AM",
      "commitName": "de7a0a92ca1983b35ca4beb7ab712fd700a9e6e0",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "MAPREDUCE-6638. Do not attempt to recover progress from previous job attempts if spill encryption is enabled. (Haibo Chen via kasha)\n",
          "commitDate": "03/10/16 10:30 AM",
          "commitName": "de7a0a92ca1983b35ca4beb7ab712fd700a9e6e0",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
          "commitAuthorOld": "Li Lu",
          "daysBetweenCommits": 85.07,
          "commitsBetweenForRepo": 598,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,47 @@\n-  private void processRecovery() throws IOException{\n-    if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n-      return;  // no need to recover on the first attempt\n+  private boolean shouldAttemptRecovery() throws IOException {\n+    if (isFirstAttempt()) {\n+      return false;  // no need to recover on the first attempt\n     }\n \n     boolean recoveryEnabled \u003d getConfig().getBoolean(\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n+    if (!recoveryEnabled) {\n+      LOG.info(\"Not attempting to recover. Recovery disabled. To enable \" +\n+          \"recovery, set \" + MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE);\n+      return false;\n+    }\n \n     boolean recoverySupportedByCommitter \u003d isRecoverySupported();\n+    if (!recoverySupportedByCommitter) {\n+      LOG.info(\"Not attempting to recover. Recovery is not supported by \" +\n+          committer.getClass() + \". Use an OutputCommitter that supports\" +\n+              \" recovery.\");\n+      return false;\n+    }\n \n-    // If a shuffle secret was not provided by the job client then this app\n-    // attempt will generate one.  However that disables recovery if there\n-    // are reducers as the shuffle secret would be app attempt specific.\n-    int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n+    int reducerCount \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n+\n+    // If a shuffle secret was not provided by the job client, one will be\n+    // generated in this job attempt. However, that disables recovery if\n+    // there are reducers as the shuffle secret would be job attempt specific.\n     boolean shuffleKeyValidForRecovery \u003d\n         TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n-\n-    if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n-        \u0026\u0026 (numReduceTasks \u003c\u003d 0 || shuffleKeyValidForRecovery)) {\n-      LOG.info(\"Recovery is enabled. \"\n-          + \"Will try to recover from previous life on best effort basis.\");\n-      try {\n-        parsePreviousJobHistory();\n-      } catch (IOException e) {\n-        LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n-        // try to get just the AMInfos\n-        amInfos.addAll(readJustAMInfos());\n-      }\n-    } else {\n-      LOG.info(\"Will not try to recover. recoveryEnabled: \"\n-            + recoveryEnabled + \" recoverySupportedByCommitter: \"\n-            + recoverySupportedByCommitter + \" numReduceTasks: \"\n-            + numReduceTasks + \" shuffleKeyValidForRecovery: \"\n-            + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n-            + appAttemptID.getAttemptId());\n-      // Get the amInfos anyways whether recovery is enabled or not\n-      amInfos.addAll(readJustAMInfos());\n+    if (reducerCount \u003e 0 \u0026\u0026 !shuffleKeyValidForRecovery) {\n+      LOG.info(\"Not attempting to recover. The shuffle key is invalid for \" +\n+          \"recovery.\");\n+      return false;\n     }\n+\n+    // If the intermediate data is encrypted, recovering the job requires the\n+    // access to the key. Until the encryption key is persisted, we should\n+    // avoid attempts to recover.\n+    boolean spillEncrypted \u003d CryptoUtils.isEncryptedSpillEnabled(getConfig());\n+    if (reducerCount \u003e 0 \u0026\u0026 spillEncrypted) {\n+      LOG.info(\"Not attempting to recover. Intermediate spill encryption\" +\n+          \" is enabled.\");\n+      return false;\n+    }\n+\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean shouldAttemptRecovery() throws IOException {\n    if (isFirstAttempt()) {\n      return false;  // no need to recover on the first attempt\n    }\n\n    boolean recoveryEnabled \u003d getConfig().getBoolean(\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n    if (!recoveryEnabled) {\n      LOG.info(\"Not attempting to recover. Recovery disabled. To enable \" +\n          \"recovery, set \" + MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE);\n      return false;\n    }\n\n    boolean recoverySupportedByCommitter \u003d isRecoverySupported();\n    if (!recoverySupportedByCommitter) {\n      LOG.info(\"Not attempting to recover. Recovery is not supported by \" +\n          committer.getClass() + \". Use an OutputCommitter that supports\" +\n              \" recovery.\");\n      return false;\n    }\n\n    int reducerCount \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n\n    // If a shuffle secret was not provided by the job client, one will be\n    // generated in this job attempt. However, that disables recovery if\n    // there are reducers as the shuffle secret would be job attempt specific.\n    boolean shuffleKeyValidForRecovery \u003d\n        TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n    if (reducerCount \u003e 0 \u0026\u0026 !shuffleKeyValidForRecovery) {\n      LOG.info(\"Not attempting to recover. The shuffle key is invalid for \" +\n          \"recovery.\");\n      return false;\n    }\n\n    // If the intermediate data is encrypted, recovering the job requires the\n    // access to the key. Until the encryption key is persisted, we should\n    // avoid attempts to recover.\n    boolean spillEncrypted \u003d CryptoUtils.isEncryptedSpillEnabled(getConfig());\n    if (reducerCount \u003e 0 \u0026\u0026 spillEncrypted) {\n      LOG.info(\"Not attempting to recover. Intermediate spill encryption\" +\n          \" is enabled.\");\n      return false;\n    }\n\n    return true;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
          "extendedDetails": {
            "oldValue": "processRecovery",
            "newValue": "shouldAttemptRecovery"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "MAPREDUCE-6638. Do not attempt to recover progress from previous job attempts if spill encryption is enabled. (Haibo Chen via kasha)\n",
          "commitDate": "03/10/16 10:30 AM",
          "commitName": "de7a0a92ca1983b35ca4beb7ab712fd700a9e6e0",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
          "commitAuthorOld": "Li Lu",
          "daysBetweenCommits": 85.07,
          "commitsBetweenForRepo": 598,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,47 @@\n-  private void processRecovery() throws IOException{\n-    if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n-      return;  // no need to recover on the first attempt\n+  private boolean shouldAttemptRecovery() throws IOException {\n+    if (isFirstAttempt()) {\n+      return false;  // no need to recover on the first attempt\n     }\n \n     boolean recoveryEnabled \u003d getConfig().getBoolean(\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n+    if (!recoveryEnabled) {\n+      LOG.info(\"Not attempting to recover. Recovery disabled. To enable \" +\n+          \"recovery, set \" + MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE);\n+      return false;\n+    }\n \n     boolean recoverySupportedByCommitter \u003d isRecoverySupported();\n+    if (!recoverySupportedByCommitter) {\n+      LOG.info(\"Not attempting to recover. Recovery is not supported by \" +\n+          committer.getClass() + \". Use an OutputCommitter that supports\" +\n+              \" recovery.\");\n+      return false;\n+    }\n \n-    // If a shuffle secret was not provided by the job client then this app\n-    // attempt will generate one.  However that disables recovery if there\n-    // are reducers as the shuffle secret would be app attempt specific.\n-    int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n+    int reducerCount \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n+\n+    // If a shuffle secret was not provided by the job client, one will be\n+    // generated in this job attempt. However, that disables recovery if\n+    // there are reducers as the shuffle secret would be job attempt specific.\n     boolean shuffleKeyValidForRecovery \u003d\n         TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n-\n-    if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n-        \u0026\u0026 (numReduceTasks \u003c\u003d 0 || shuffleKeyValidForRecovery)) {\n-      LOG.info(\"Recovery is enabled. \"\n-          + \"Will try to recover from previous life on best effort basis.\");\n-      try {\n-        parsePreviousJobHistory();\n-      } catch (IOException e) {\n-        LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n-        // try to get just the AMInfos\n-        amInfos.addAll(readJustAMInfos());\n-      }\n-    } else {\n-      LOG.info(\"Will not try to recover. recoveryEnabled: \"\n-            + recoveryEnabled + \" recoverySupportedByCommitter: \"\n-            + recoverySupportedByCommitter + \" numReduceTasks: \"\n-            + numReduceTasks + \" shuffleKeyValidForRecovery: \"\n-            + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n-            + appAttemptID.getAttemptId());\n-      // Get the amInfos anyways whether recovery is enabled or not\n-      amInfos.addAll(readJustAMInfos());\n+    if (reducerCount \u003e 0 \u0026\u0026 !shuffleKeyValidForRecovery) {\n+      LOG.info(\"Not attempting to recover. The shuffle key is invalid for \" +\n+          \"recovery.\");\n+      return false;\n     }\n+\n+    // If the intermediate data is encrypted, recovering the job requires the\n+    // access to the key. Until the encryption key is persisted, we should\n+    // avoid attempts to recover.\n+    boolean spillEncrypted \u003d CryptoUtils.isEncryptedSpillEnabled(getConfig());\n+    if (reducerCount \u003e 0 \u0026\u0026 spillEncrypted) {\n+      LOG.info(\"Not attempting to recover. Intermediate spill encryption\" +\n+          \" is enabled.\");\n+      return false;\n+    }\n+\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean shouldAttemptRecovery() throws IOException {\n    if (isFirstAttempt()) {\n      return false;  // no need to recover on the first attempt\n    }\n\n    boolean recoveryEnabled \u003d getConfig().getBoolean(\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n    if (!recoveryEnabled) {\n      LOG.info(\"Not attempting to recover. Recovery disabled. To enable \" +\n          \"recovery, set \" + MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE);\n      return false;\n    }\n\n    boolean recoverySupportedByCommitter \u003d isRecoverySupported();\n    if (!recoverySupportedByCommitter) {\n      LOG.info(\"Not attempting to recover. Recovery is not supported by \" +\n          committer.getClass() + \". Use an OutputCommitter that supports\" +\n              \" recovery.\");\n      return false;\n    }\n\n    int reducerCount \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n\n    // If a shuffle secret was not provided by the job client, one will be\n    // generated in this job attempt. However, that disables recovery if\n    // there are reducers as the shuffle secret would be job attempt specific.\n    boolean shuffleKeyValidForRecovery \u003d\n        TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n    if (reducerCount \u003e 0 \u0026\u0026 !shuffleKeyValidForRecovery) {\n      LOG.info(\"Not attempting to recover. The shuffle key is invalid for \" +\n          \"recovery.\");\n      return false;\n    }\n\n    // If the intermediate data is encrypted, recovering the job requires the\n    // access to the key. Until the encryption key is persisted, we should\n    // avoid attempts to recover.\n    boolean spillEncrypted \u003d CryptoUtils.isEncryptedSpillEnabled(getConfig());\n    if (reducerCount \u003e 0 \u0026\u0026 spillEncrypted) {\n      LOG.info(\"Not attempting to recover. Intermediate spill encryption\" +\n          \" is enabled.\");\n      return false;\n    }\n\n    return true;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-6638. Do not attempt to recover progress from previous job attempts if spill encryption is enabled. (Haibo Chen via kasha)\n",
          "commitDate": "03/10/16 10:30 AM",
          "commitName": "de7a0a92ca1983b35ca4beb7ab712fd700a9e6e0",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
          "commitAuthorOld": "Li Lu",
          "daysBetweenCommits": 85.07,
          "commitsBetweenForRepo": 598,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,47 @@\n-  private void processRecovery() throws IOException{\n-    if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n-      return;  // no need to recover on the first attempt\n+  private boolean shouldAttemptRecovery() throws IOException {\n+    if (isFirstAttempt()) {\n+      return false;  // no need to recover on the first attempt\n     }\n \n     boolean recoveryEnabled \u003d getConfig().getBoolean(\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n+    if (!recoveryEnabled) {\n+      LOG.info(\"Not attempting to recover. Recovery disabled. To enable \" +\n+          \"recovery, set \" + MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE);\n+      return false;\n+    }\n \n     boolean recoverySupportedByCommitter \u003d isRecoverySupported();\n+    if (!recoverySupportedByCommitter) {\n+      LOG.info(\"Not attempting to recover. Recovery is not supported by \" +\n+          committer.getClass() + \". Use an OutputCommitter that supports\" +\n+              \" recovery.\");\n+      return false;\n+    }\n \n-    // If a shuffle secret was not provided by the job client then this app\n-    // attempt will generate one.  However that disables recovery if there\n-    // are reducers as the shuffle secret would be app attempt specific.\n-    int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n+    int reducerCount \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n+\n+    // If a shuffle secret was not provided by the job client, one will be\n+    // generated in this job attempt. However, that disables recovery if\n+    // there are reducers as the shuffle secret would be job attempt specific.\n     boolean shuffleKeyValidForRecovery \u003d\n         TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n-\n-    if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n-        \u0026\u0026 (numReduceTasks \u003c\u003d 0 || shuffleKeyValidForRecovery)) {\n-      LOG.info(\"Recovery is enabled. \"\n-          + \"Will try to recover from previous life on best effort basis.\");\n-      try {\n-        parsePreviousJobHistory();\n-      } catch (IOException e) {\n-        LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n-        // try to get just the AMInfos\n-        amInfos.addAll(readJustAMInfos());\n-      }\n-    } else {\n-      LOG.info(\"Will not try to recover. recoveryEnabled: \"\n-            + recoveryEnabled + \" recoverySupportedByCommitter: \"\n-            + recoverySupportedByCommitter + \" numReduceTasks: \"\n-            + numReduceTasks + \" shuffleKeyValidForRecovery: \"\n-            + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n-            + appAttemptID.getAttemptId());\n-      // Get the amInfos anyways whether recovery is enabled or not\n-      amInfos.addAll(readJustAMInfos());\n+    if (reducerCount \u003e 0 \u0026\u0026 !shuffleKeyValidForRecovery) {\n+      LOG.info(\"Not attempting to recover. The shuffle key is invalid for \" +\n+          \"recovery.\");\n+      return false;\n     }\n+\n+    // If the intermediate data is encrypted, recovering the job requires the\n+    // access to the key. Until the encryption key is persisted, we should\n+    // avoid attempts to recover.\n+    boolean spillEncrypted \u003d CryptoUtils.isEncryptedSpillEnabled(getConfig());\n+    if (reducerCount \u003e 0 \u0026\u0026 spillEncrypted) {\n+      LOG.info(\"Not attempting to recover. Intermediate spill encryption\" +\n+          \" is enabled.\");\n+      return false;\n+    }\n+\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean shouldAttemptRecovery() throws IOException {\n    if (isFirstAttempt()) {\n      return false;  // no need to recover on the first attempt\n    }\n\n    boolean recoveryEnabled \u003d getConfig().getBoolean(\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n    if (!recoveryEnabled) {\n      LOG.info(\"Not attempting to recover. Recovery disabled. To enable \" +\n          \"recovery, set \" + MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE);\n      return false;\n    }\n\n    boolean recoverySupportedByCommitter \u003d isRecoverySupported();\n    if (!recoverySupportedByCommitter) {\n      LOG.info(\"Not attempting to recover. Recovery is not supported by \" +\n          committer.getClass() + \". Use an OutputCommitter that supports\" +\n              \" recovery.\");\n      return false;\n    }\n\n    int reducerCount \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n\n    // If a shuffle secret was not provided by the job client, one will be\n    // generated in this job attempt. However, that disables recovery if\n    // there are reducers as the shuffle secret would be job attempt specific.\n    boolean shuffleKeyValidForRecovery \u003d\n        TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n    if (reducerCount \u003e 0 \u0026\u0026 !shuffleKeyValidForRecovery) {\n      LOG.info(\"Not attempting to recover. The shuffle key is invalid for \" +\n          \"recovery.\");\n      return false;\n    }\n\n    // If the intermediate data is encrypted, recovering the job requires the\n    // access to the key. Until the encryption key is persisted, we should\n    // avoid attempts to recover.\n    boolean spillEncrypted \u003d CryptoUtils.isEncryptedSpillEnabled(getConfig());\n    if (reducerCount \u003e 0 \u0026\u0026 spillEncrypted) {\n      LOG.info(\"Not attempting to recover. Intermediate spill encryption\" +\n          \" is enabled.\");\n      return false;\n    }\n\n    return true;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
          "extendedDetails": {}
        }
      ]
    },
    "9e62bcca4e2ee4aaa3844d1d975dc0adc93ab602": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5957. AM throws ClassNotFoundException with job classloader enabled if custom output format/committer is used. Contributed by Sangjin Lee\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612358 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/07/14 10:54 AM",
      "commitName": "9e62bcca4e2ee4aaa3844d1d975dc0adc93ab602",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "11/07/14 1:45 AM",
      "commitNameOld": "64306aa1b5f280e5ffaf2186bef706acd93b1412",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 10.38,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,40 @@\n   private void processRecovery() throws IOException{\n     if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n       return;  // no need to recover on the first attempt\n     }\n \n     boolean recoveryEnabled \u003d getConfig().getBoolean(\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n \n-    boolean recoverySupportedByCommitter \u003d isRecoverySupported(committer);\n+    boolean recoverySupportedByCommitter \u003d isRecoverySupported();\n \n     // If a shuffle secret was not provided by the job client then this app\n     // attempt will generate one.  However that disables recovery if there\n     // are reducers as the shuffle secret would be app attempt specific.\n     int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n     boolean shuffleKeyValidForRecovery \u003d\n         TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n \n     if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n         \u0026\u0026 (numReduceTasks \u003c\u003d 0 || shuffleKeyValidForRecovery)) {\n       LOG.info(\"Recovery is enabled. \"\n           + \"Will try to recover from previous life on best effort basis.\");\n       try {\n         parsePreviousJobHistory();\n       } catch (IOException e) {\n         LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n         // try to get just the AMInfos\n         amInfos.addAll(readJustAMInfos());\n       }\n     } else {\n       LOG.info(\"Will not try to recover. recoveryEnabled: \"\n             + recoveryEnabled + \" recoverySupportedByCommitter: \"\n             + recoverySupportedByCommitter + \" numReduceTasks: \"\n             + numReduceTasks + \" shuffleKeyValidForRecovery: \"\n             + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n             + appAttemptID.getAttemptId());\n       // Get the amInfos anyways whether recovery is enabled or not\n       amInfos.addAll(readJustAMInfos());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processRecovery() throws IOException{\n    if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n      return;  // no need to recover on the first attempt\n    }\n\n    boolean recoveryEnabled \u003d getConfig().getBoolean(\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n\n    boolean recoverySupportedByCommitter \u003d isRecoverySupported();\n\n    // If a shuffle secret was not provided by the job client then this app\n    // attempt will generate one.  However that disables recovery if there\n    // are reducers as the shuffle secret would be app attempt specific.\n    int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n    boolean shuffleKeyValidForRecovery \u003d\n        TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n\n    if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n        \u0026\u0026 (numReduceTasks \u003c\u003d 0 || shuffleKeyValidForRecovery)) {\n      LOG.info(\"Recovery is enabled. \"\n          + \"Will try to recover from previous life on best effort basis.\");\n      try {\n        parsePreviousJobHistory();\n      } catch (IOException e) {\n        LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n        // try to get just the AMInfos\n        amInfos.addAll(readJustAMInfos());\n      }\n    } else {\n      LOG.info(\"Will not try to recover. recoveryEnabled: \"\n            + recoveryEnabled + \" recoverySupportedByCommitter: \"\n            + recoverySupportedByCommitter + \" numReduceTasks: \"\n            + numReduceTasks + \" shuffleKeyValidForRecovery: \"\n            + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n            + appAttemptID.getAttemptId());\n      // Get the amInfos anyways whether recovery is enabled or not\n      amInfos.addAll(readJustAMInfos());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "bb7ce82816574f67aa1898f67e0e0cff54fa67be": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "MAPREDUCE-5812. Make job context available to OutputCommitter.isRecoverySupported(). Contributed by Mohammad Kamrul Islam\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1590668 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/04/14 8:18 AM",
      "commitName": "bb7ce82816574f67aa1898f67e0e0cff54fa67be",
      "commitAuthor": "Jason Darrell Lowe",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "MAPREDUCE-5812. Make job context available to OutputCommitter.isRecoverySupported(). Contributed by Mohammad Kamrul Islam\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1590668 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "28/04/14 8:18 AM",
          "commitName": "bb7ce82816574f67aa1898f67e0e0cff54fa67be",
          "commitAuthor": "Jason Darrell Lowe",
          "commitDateOld": "26/04/14 10:59 AM",
          "commitNameOld": "39abe6682275a96554f23e39685a75dfe2ec93d6",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 1.89,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,40 @@\n-  private void processRecovery() {\n+  private void processRecovery() throws IOException{\n     if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n       return;  // no need to recover on the first attempt\n     }\n \n     boolean recoveryEnabled \u003d getConfig().getBoolean(\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n-    boolean recoverySupportedByCommitter \u003d\n-        committer !\u003d null \u0026\u0026 committer.isRecoverySupported();\n+\n+    boolean recoverySupportedByCommitter \u003d isRecoverySupported(committer);\n \n     // If a shuffle secret was not provided by the job client then this app\n     // attempt will generate one.  However that disables recovery if there\n     // are reducers as the shuffle secret would be app attempt specific.\n     int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n     boolean shuffleKeyValidForRecovery \u003d\n         TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n \n     if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n         \u0026\u0026 (numReduceTasks \u003c\u003d 0 || shuffleKeyValidForRecovery)) {\n       LOG.info(\"Recovery is enabled. \"\n           + \"Will try to recover from previous life on best effort basis.\");\n       try {\n         parsePreviousJobHistory();\n       } catch (IOException e) {\n         LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n         // try to get just the AMInfos\n         amInfos.addAll(readJustAMInfos());\n       }\n     } else {\n       LOG.info(\"Will not try to recover. recoveryEnabled: \"\n             + recoveryEnabled + \" recoverySupportedByCommitter: \"\n             + recoverySupportedByCommitter + \" numReduceTasks: \"\n             + numReduceTasks + \" shuffleKeyValidForRecovery: \"\n             + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n             + appAttemptID.getAttemptId());\n       // Get the amInfos anyways whether recovery is enabled or not\n       amInfos.addAll(readJustAMInfos());\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void processRecovery() throws IOException{\n    if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n      return;  // no need to recover on the first attempt\n    }\n\n    boolean recoveryEnabled \u003d getConfig().getBoolean(\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n\n    boolean recoverySupportedByCommitter \u003d isRecoverySupported(committer);\n\n    // If a shuffle secret was not provided by the job client then this app\n    // attempt will generate one.  However that disables recovery if there\n    // are reducers as the shuffle secret would be app attempt specific.\n    int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n    boolean shuffleKeyValidForRecovery \u003d\n        TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n\n    if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n        \u0026\u0026 (numReduceTasks \u003c\u003d 0 || shuffleKeyValidForRecovery)) {\n      LOG.info(\"Recovery is enabled. \"\n          + \"Will try to recover from previous life on best effort basis.\");\n      try {\n        parsePreviousJobHistory();\n      } catch (IOException e) {\n        LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n        // try to get just the AMInfos\n        amInfos.addAll(readJustAMInfos());\n      }\n    } else {\n      LOG.info(\"Will not try to recover. recoveryEnabled: \"\n            + recoveryEnabled + \" recoverySupportedByCommitter: \"\n            + recoverySupportedByCommitter + \" numReduceTasks: \"\n            + numReduceTasks + \" shuffleKeyValidForRecovery: \"\n            + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n            + appAttemptID.getAttemptId());\n      // Get the amInfos anyways whether recovery is enabled or not\n      amInfos.addAll(readJustAMInfos());\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-5812. Make job context available to OutputCommitter.isRecoverySupported(). Contributed by Mohammad Kamrul Islam\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1590668 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "28/04/14 8:18 AM",
          "commitName": "bb7ce82816574f67aa1898f67e0e0cff54fa67be",
          "commitAuthor": "Jason Darrell Lowe",
          "commitDateOld": "26/04/14 10:59 AM",
          "commitNameOld": "39abe6682275a96554f23e39685a75dfe2ec93d6",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 1.89,
          "commitsBetweenForRepo": 3,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,40 @@\n-  private void processRecovery() {\n+  private void processRecovery() throws IOException{\n     if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n       return;  // no need to recover on the first attempt\n     }\n \n     boolean recoveryEnabled \u003d getConfig().getBoolean(\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n-    boolean recoverySupportedByCommitter \u003d\n-        committer !\u003d null \u0026\u0026 committer.isRecoverySupported();\n+\n+    boolean recoverySupportedByCommitter \u003d isRecoverySupported(committer);\n \n     // If a shuffle secret was not provided by the job client then this app\n     // attempt will generate one.  However that disables recovery if there\n     // are reducers as the shuffle secret would be app attempt specific.\n     int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n     boolean shuffleKeyValidForRecovery \u003d\n         TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n \n     if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n         \u0026\u0026 (numReduceTasks \u003c\u003d 0 || shuffleKeyValidForRecovery)) {\n       LOG.info(\"Recovery is enabled. \"\n           + \"Will try to recover from previous life on best effort basis.\");\n       try {\n         parsePreviousJobHistory();\n       } catch (IOException e) {\n         LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n         // try to get just the AMInfos\n         amInfos.addAll(readJustAMInfos());\n       }\n     } else {\n       LOG.info(\"Will not try to recover. recoveryEnabled: \"\n             + recoveryEnabled + \" recoverySupportedByCommitter: \"\n             + recoverySupportedByCommitter + \" numReduceTasks: \"\n             + numReduceTasks + \" shuffleKeyValidForRecovery: \"\n             + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n             + appAttemptID.getAttemptId());\n       // Get the amInfos anyways whether recovery is enabled or not\n       amInfos.addAll(readJustAMInfos());\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void processRecovery() throws IOException{\n    if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n      return;  // no need to recover on the first attempt\n    }\n\n    boolean recoveryEnabled \u003d getConfig().getBoolean(\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n\n    boolean recoverySupportedByCommitter \u003d isRecoverySupported(committer);\n\n    // If a shuffle secret was not provided by the job client then this app\n    // attempt will generate one.  However that disables recovery if there\n    // are reducers as the shuffle secret would be app attempt specific.\n    int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n    boolean shuffleKeyValidForRecovery \u003d\n        TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n\n    if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n        \u0026\u0026 (numReduceTasks \u003c\u003d 0 || shuffleKeyValidForRecovery)) {\n      LOG.info(\"Recovery is enabled. \"\n          + \"Will try to recover from previous life on best effort basis.\");\n      try {\n        parsePreviousJobHistory();\n      } catch (IOException e) {\n        LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n        // try to get just the AMInfos\n        amInfos.addAll(readJustAMInfos());\n      }\n    } else {\n      LOG.info(\"Will not try to recover. recoveryEnabled: \"\n            + recoveryEnabled + \" recoverySupportedByCommitter: \"\n            + recoverySupportedByCommitter + \" numReduceTasks: \"\n            + numReduceTasks + \" shuffleKeyValidForRecovery: \"\n            + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n            + appAttemptID.getAttemptId());\n      // Get the amInfos anyways whether recovery is enabled or not\n      amInfos.addAll(readJustAMInfos());\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
          "extendedDetails": {}
        }
      ]
    },
    "ded91b4cfa22c8d7c498ea21c8c1ac52fe9a9e29": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5468. Fix MR AM recovery for map-only jobs. Contributed by Vinod K. V.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1516358 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/08/13 6:52 PM",
      "commitName": "ded91b4cfa22c8d7c498ea21c8c1ac52fe9a9e29",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "21/08/13 11:16 AM",
      "commitNameOld": "2d614a916cc5958b709bddbee71d2dcb9cbb2bf9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.32,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,40 @@\n   private void processRecovery() {\n     if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n       return;  // no need to recover on the first attempt\n     }\n \n     boolean recoveryEnabled \u003d getConfig().getBoolean(\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n     boolean recoverySupportedByCommitter \u003d\n         committer !\u003d null \u0026\u0026 committer.isRecoverySupported();\n \n     // If a shuffle secret was not provided by the job client then this app\n     // attempt will generate one.  However that disables recovery if there\n     // are reducers as the shuffle secret would be app attempt specific.\n     int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n-    boolean shuffleKeyValidForRecovery \u003d (numReduceTasks \u003e 0 \u0026\u0026\n-        TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null);\n+    boolean shuffleKeyValidForRecovery \u003d\n+        TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n \n     if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n-          \u0026\u0026 shuffleKeyValidForRecovery) {\n+        \u0026\u0026 (numReduceTasks \u003c\u003d 0 || shuffleKeyValidForRecovery)) {\n       LOG.info(\"Recovery is enabled. \"\n           + \"Will try to recover from previous life on best effort basis.\");\n       try {\n         parsePreviousJobHistory();\n       } catch (IOException e) {\n         LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n         // try to get just the AMInfos\n         amInfos.addAll(readJustAMInfos());\n       }\n     } else {\n       LOG.info(\"Will not try to recover. recoveryEnabled: \"\n             + recoveryEnabled + \" recoverySupportedByCommitter: \"\n-            + recoverySupportedByCommitter + \" shuffleKeyValidForRecovery: \"\n+            + recoverySupportedByCommitter + \" numReduceTasks: \"\n+            + numReduceTasks + \" shuffleKeyValidForRecovery: \"\n             + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n             + appAttemptID.getAttemptId());\n       // Get the amInfos anyways whether recovery is enabled or not\n       amInfos.addAll(readJustAMInfos());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processRecovery() {\n    if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n      return;  // no need to recover on the first attempt\n    }\n\n    boolean recoveryEnabled \u003d getConfig().getBoolean(\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n    boolean recoverySupportedByCommitter \u003d\n        committer !\u003d null \u0026\u0026 committer.isRecoverySupported();\n\n    // If a shuffle secret was not provided by the job client then this app\n    // attempt will generate one.  However that disables recovery if there\n    // are reducers as the shuffle secret would be app attempt specific.\n    int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n    boolean shuffleKeyValidForRecovery \u003d\n        TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null;\n\n    if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n        \u0026\u0026 (numReduceTasks \u003c\u003d 0 || shuffleKeyValidForRecovery)) {\n      LOG.info(\"Recovery is enabled. \"\n          + \"Will try to recover from previous life on best effort basis.\");\n      try {\n        parsePreviousJobHistory();\n      } catch (IOException e) {\n        LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n        // try to get just the AMInfos\n        amInfos.addAll(readJustAMInfos());\n      }\n    } else {\n      LOG.info(\"Will not try to recover. recoveryEnabled: \"\n            + recoveryEnabled + \" recoverySupportedByCommitter: \"\n            + recoverySupportedByCommitter + \" numReduceTasks: \"\n            + numReduceTasks + \" shuffleKeyValidForRecovery: \"\n            + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n            + appAttemptID.getAttemptId());\n      // Get the amInfos anyways whether recovery is enabled or not\n      amInfos.addAll(readJustAMInfos());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "b64572b06b1282128180b9ebdd971f9b1e973e61": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5199. Removing ApplicationTokens file as it is no longer needed. Contributed by Daryn Sharp.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1492848 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/06/13 1:20 PM",
      "commitName": "b64572b06b1282128180b9ebdd971f9b1e973e61",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/06/13 8:54 AM",
      "commitNameOld": "0928502029ef141759008997335ea2cd836a7154",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   private void processRecovery() {\n     if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n       return;  // no need to recover on the first attempt\n     }\n \n     boolean recoveryEnabled \u003d getConfig().getBoolean(\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n         MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n     boolean recoverySupportedByCommitter \u003d\n         committer !\u003d null \u0026\u0026 committer.isRecoverySupported();\n \n     // If a shuffle secret was not provided by the job client then this app\n     // attempt will generate one.  However that disables recovery if there\n     // are reducers as the shuffle secret would be app attempt specific.\n     int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n     boolean shuffleKeyValidForRecovery \u003d (numReduceTasks \u003e 0 \u0026\u0026\n-        TokenCache.getShuffleSecretKey(fsTokens) !\u003d null);\n+        TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null);\n \n     if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n           \u0026\u0026 shuffleKeyValidForRecovery) {\n       LOG.info(\"Recovery is enabled. \"\n           + \"Will try to recover from previous life on best effort basis.\");\n       try {\n         parsePreviousJobHistory();\n       } catch (IOException e) {\n         LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n         // try to get just the AMInfos\n         amInfos.addAll(readJustAMInfos());\n       }\n     } else {\n       LOG.info(\"Will not try to recover. recoveryEnabled: \"\n             + recoveryEnabled + \" recoverySupportedByCommitter: \"\n             + recoverySupportedByCommitter + \" shuffleKeyValidForRecovery: \"\n             + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n             + appAttemptID.getAttemptId());\n       // Get the amInfos anyways whether recovery is enabled or not\n       amInfos.addAll(readJustAMInfos());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processRecovery() {\n    if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n      return;  // no need to recover on the first attempt\n    }\n\n    boolean recoveryEnabled \u003d getConfig().getBoolean(\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n    boolean recoverySupportedByCommitter \u003d\n        committer !\u003d null \u0026\u0026 committer.isRecoverySupported();\n\n    // If a shuffle secret was not provided by the job client then this app\n    // attempt will generate one.  However that disables recovery if there\n    // are reducers as the shuffle secret would be app attempt specific.\n    int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n    boolean shuffleKeyValidForRecovery \u003d (numReduceTasks \u003e 0 \u0026\u0026\n        TokenCache.getShuffleSecretKey(jobCredentials) !\u003d null);\n\n    if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n          \u0026\u0026 shuffleKeyValidForRecovery) {\n      LOG.info(\"Recovery is enabled. \"\n          + \"Will try to recover from previous life on best effort basis.\");\n      try {\n        parsePreviousJobHistory();\n      } catch (IOException e) {\n        LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n        // try to get just the AMInfos\n        amInfos.addAll(readJustAMInfos());\n      }\n    } else {\n      LOG.info(\"Will not try to recover. recoveryEnabled: \"\n            + recoveryEnabled + \" recoverySupportedByCommitter: \"\n            + recoverySupportedByCommitter + \" shuffleKeyValidForRecovery: \"\n            + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n            + appAttemptID.getAttemptId());\n      // Get the amInfos anyways whether recovery is enabled or not\n      amInfos.addAll(readJustAMInfos());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java",
      "extendedDetails": {}
    },
    "6a1c41111edcdc58c846fc50e53554fbba230171": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-5079. Changes job recovery to restore state directly from job history, instaed of simulating state machine events. Contributed by Jason Lowe and Robert Parker.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1466767 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/04/13 9:52 PM",
      "commitName": "6a1c41111edcdc58c846fc50e53554fbba230171",
      "commitAuthor": "Siddharth Seth",
      "diff": "@@ -0,0 +1,39 @@\n+  private void processRecovery() {\n+    if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n+      return;  // no need to recover on the first attempt\n+    }\n+\n+    boolean recoveryEnabled \u003d getConfig().getBoolean(\n+        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n+        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n+    boolean recoverySupportedByCommitter \u003d\n+        committer !\u003d null \u0026\u0026 committer.isRecoverySupported();\n+\n+    // If a shuffle secret was not provided by the job client then this app\n+    // attempt will generate one.  However that disables recovery if there\n+    // are reducers as the shuffle secret would be app attempt specific.\n+    int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n+    boolean shuffleKeyValidForRecovery \u003d (numReduceTasks \u003e 0 \u0026\u0026\n+        TokenCache.getShuffleSecretKey(fsTokens) !\u003d null);\n+\n+    if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n+          \u0026\u0026 shuffleKeyValidForRecovery) {\n+      LOG.info(\"Recovery is enabled. \"\n+          + \"Will try to recover from previous life on best effort basis.\");\n+      try {\n+        parsePreviousJobHistory();\n+      } catch (IOException e) {\n+        LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n+        // try to get just the AMInfos\n+        amInfos.addAll(readJustAMInfos());\n+      }\n+    } else {\n+      LOG.info(\"Will not try to recover. recoveryEnabled: \"\n+            + recoveryEnabled + \" recoverySupportedByCommitter: \"\n+            + recoverySupportedByCommitter + \" shuffleKeyValidForRecovery: \"\n+            + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n+            + appAttemptID.getAttemptId());\n+      // Get the amInfos anyways whether recovery is enabled or not\n+      amInfos.addAll(readJustAMInfos());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void processRecovery() {\n    if (appAttemptID.getAttemptId() \u003d\u003d 1) {\n      return;  // no need to recover on the first attempt\n    }\n\n    boolean recoveryEnabled \u003d getConfig().getBoolean(\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE,\n        MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE_DEFAULT);\n    boolean recoverySupportedByCommitter \u003d\n        committer !\u003d null \u0026\u0026 committer.isRecoverySupported();\n\n    // If a shuffle secret was not provided by the job client then this app\n    // attempt will generate one.  However that disables recovery if there\n    // are reducers as the shuffle secret would be app attempt specific.\n    int numReduceTasks \u003d getConfig().getInt(MRJobConfig.NUM_REDUCES, 0);\n    boolean shuffleKeyValidForRecovery \u003d (numReduceTasks \u003e 0 \u0026\u0026\n        TokenCache.getShuffleSecretKey(fsTokens) !\u003d null);\n\n    if (recoveryEnabled \u0026\u0026 recoverySupportedByCommitter\n          \u0026\u0026 shuffleKeyValidForRecovery) {\n      LOG.info(\"Recovery is enabled. \"\n          + \"Will try to recover from previous life on best effort basis.\");\n      try {\n        parsePreviousJobHistory();\n      } catch (IOException e) {\n        LOG.warn(\"Unable to parse prior job history, aborting recovery\", e);\n        // try to get just the AMInfos\n        amInfos.addAll(readJustAMInfos());\n      }\n    } else {\n      LOG.info(\"Will not try to recover. recoveryEnabled: \"\n            + recoveryEnabled + \" recoverySupportedByCommitter: \"\n            + recoverySupportedByCommitter + \" shuffleKeyValidForRecovery: \"\n            + shuffleKeyValidForRecovery + \" ApplicationAttemptID: \"\n            + appAttemptID.getAttemptId());\n      // Get the amInfos anyways whether recovery is enabled or not\n      amInfos.addAll(readJustAMInfos());\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/MRAppMaster.java"
    }
  }
}