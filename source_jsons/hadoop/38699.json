{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FiCaSchedulerApp.java",
  "functionName": "commonCheckContainerAllocation",
  "functionId": "commonCheckContainerAllocation___allocation-ContainerAllocationProposal__FiCaSchedulerApp,FiCaSchedulerNode____schedulerContainer-SchedulerContainer__FiCaSchedulerApp,FiCaSchedulerNode__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
  "functionStartLine": 347,
  "functionEndLine": 426,
  "numCommitsSeen": 160,
  "timeTaken": 6149,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "5be9f4a5d05c9cb99348719fe35626b1de3055db",
    "7eb783e2634d8c11fb646f1f2fdf597336325312",
    "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c",
    "e81596d06d226f1cfa44b2390ce3095ed4dee621",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "5be9f4a5d05c9cb99348719fe35626b1de3055db": "Ybodychange",
    "7eb783e2634d8c11fb646f1f2fdf597336325312": "Ybodychange",
    "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c": "Ybodychange",
    "e81596d06d226f1cfa44b2390ce3095ed4dee621": "Ymultichange(Yparameterchange,Ybodychange)",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "07/03/19 1:47 PM",
      "commitNameOld": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,80 @@\n   private boolean commonCheckContainerAllocation(\n       ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n       SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n     // Make sure node is not reserved by anyone else\n     RMContainer reservedContainerOnNode \u003d\n         schedulerContainer.getSchedulerNode().getReservedContainer();\n     if (reservedContainerOnNode !\u003d null) {\n       // adding NP check as this proposal could not be allocated from reserved\n       // container in async-scheduling mode\n       if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n         return false;\n       }\n       RMContainer fromReservedContainer \u003d\n           allocation.getAllocateFromReservedContainer().getRmContainer();\n \n       if (fromReservedContainer !\u003d reservedContainerOnNode) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\n-              \"Try to allocate from a non-existed reserved container\");\n-        }\n+        LOG.debug(\"Try to allocate from a non-existed reserved container\");\n         return false;\n       }\n     }\n     // If allocate from reserved container, make sure node is still reserved\n     if (allocation.getAllocateFromReservedContainer() !\u003d null\n         \u0026\u0026 reservedContainerOnNode \u003d\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Try to allocate from reserved container \" + allocation\n             .getAllocateFromReservedContainer().getRmContainer()\n             .getContainerId() + \", but node is not reserved\");\n       }\n       return false;\n     }\n \n     // Do we have enough space on this node?\n     Resource availableResource \u003d Resources.clone(\n         schedulerContainer.getSchedulerNode().getUnallocatedResource());\n \n     // If we have any to-release container in non-reserved state, they are\n     // from lazy-preemption, add their consumption to available resource\n     // of this node\n     if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n         .isEmpty()) {\n       for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n           releaseContainer : allocation.getToRelease()) {\n         // Make sure to-release reserved containers are not outdated\n         if (releaseContainer.getRmContainer().getState()\n             \u003d\u003d RMContainerState.RESERVED\n             \u0026\u0026 releaseContainer.getRmContainer() !\u003d releaseContainer\n             .getSchedulerNode().getReservedContainer()) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Failed to accept this proposal because \"\n                 + \"it tries to release an outdated reserved container \"\n                 + releaseContainer.getRmContainer().getContainerId()\n                 + \" on node \" + releaseContainer.getSchedulerNode().getNodeID()\n                 + \" whose reserved container is \"\n                 + releaseContainer.getSchedulerNode().getReservedContainer());\n           }\n           return false;\n         }\n         // Only consider non-reserved container (reserved container will\n         // not affect available resource of node) on the same node\n         if (releaseContainer.getRmContainer().getState()\n             !\u003d RMContainerState.RESERVED\n             \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n             .getSchedulerNode()) {\n           Resources.addTo(availableResource,\n               releaseContainer.getRmContainer().getAllocatedResource());\n         }\n       }\n     }\n     if (!Resources.fitsIn(rc, allocation.getAllocatedOrReservedResource(),\n         availableResource)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n             + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n             + availableResource);\n       }\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean commonCheckContainerAllocation(\n      ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n      SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n    // Make sure node is not reserved by anyone else\n    RMContainer reservedContainerOnNode \u003d\n        schedulerContainer.getSchedulerNode().getReservedContainer();\n    if (reservedContainerOnNode !\u003d null) {\n      // adding NP check as this proposal could not be allocated from reserved\n      // container in async-scheduling mode\n      if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n        return false;\n      }\n      RMContainer fromReservedContainer \u003d\n          allocation.getAllocateFromReservedContainer().getRmContainer();\n\n      if (fromReservedContainer !\u003d reservedContainerOnNode) {\n        LOG.debug(\"Try to allocate from a non-existed reserved container\");\n        return false;\n      }\n    }\n    // If allocate from reserved container, make sure node is still reserved\n    if (allocation.getAllocateFromReservedContainer() !\u003d null\n        \u0026\u0026 reservedContainerOnNode \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Try to allocate from reserved container \" + allocation\n            .getAllocateFromReservedContainer().getRmContainer()\n            .getContainerId() + \", but node is not reserved\");\n      }\n      return false;\n    }\n\n    // Do we have enough space on this node?\n    Resource availableResource \u003d Resources.clone(\n        schedulerContainer.getSchedulerNode().getUnallocatedResource());\n\n    // If we have any to-release container in non-reserved state, they are\n    // from lazy-preemption, add their consumption to available resource\n    // of this node\n    if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n        .isEmpty()) {\n      for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n          releaseContainer : allocation.getToRelease()) {\n        // Make sure to-release reserved containers are not outdated\n        if (releaseContainer.getRmContainer().getState()\n            \u003d\u003d RMContainerState.RESERVED\n            \u0026\u0026 releaseContainer.getRmContainer() !\u003d releaseContainer\n            .getSchedulerNode().getReservedContainer()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Failed to accept this proposal because \"\n                + \"it tries to release an outdated reserved container \"\n                + releaseContainer.getRmContainer().getContainerId()\n                + \" on node \" + releaseContainer.getSchedulerNode().getNodeID()\n                + \" whose reserved container is \"\n                + releaseContainer.getSchedulerNode().getReservedContainer());\n          }\n          return false;\n        }\n        // Only consider non-reserved container (reserved container will\n        // not affect available resource of node) on the same node\n        if (releaseContainer.getRmContainer().getState()\n            !\u003d RMContainerState.RESERVED\n            \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n            .getSchedulerNode()) {\n          Resources.addTo(availableResource,\n              releaseContainer.getRmContainer().getAllocatedResource());\n        }\n      }\n    }\n    if (!Resources.fitsIn(rc, allocation.getAllocatedOrReservedResource(),\n        availableResource)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n            + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n            + availableResource);\n      }\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "5be9f4a5d05c9cb99348719fe35626b1de3055db": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8546. Resource leak caused by a reserved container being released more than once under async scheduling. Contributed by Tao Yang.\n",
      "commitDate": "25/07/18 2:35 AM",
      "commitName": "5be9f4a5d05c9cb99348719fe35626b1de3055db",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "03/07/18 9:59 AM",
      "commitNameOld": "51654a3962bcd0482c0e1dd32765e9533e3f9158",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 21.69,
      "commitsBetweenForRepo": 134,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,83 @@\n   private boolean commonCheckContainerAllocation(\n       ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n       SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n     // Make sure node is not reserved by anyone else\n     RMContainer reservedContainerOnNode \u003d\n         schedulerContainer.getSchedulerNode().getReservedContainer();\n     if (reservedContainerOnNode !\u003d null) {\n       // adding NP check as this proposal could not be allocated from reserved\n       // container in async-scheduling mode\n       if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n         return false;\n       }\n       RMContainer fromReservedContainer \u003d\n           allocation.getAllocateFromReservedContainer().getRmContainer();\n \n       if (fromReservedContainer !\u003d reservedContainerOnNode) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Try to allocate from a non-existed reserved container\");\n         }\n         return false;\n       }\n     }\n     // If allocate from reserved container, make sure node is still reserved\n     if (allocation.getAllocateFromReservedContainer() !\u003d null\n         \u0026\u0026 reservedContainerOnNode \u003d\u003d null) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Try to allocate from reserved container \" + allocation\n             .getAllocateFromReservedContainer().getRmContainer()\n             .getContainerId() + \", but node is not reserved\");\n       }\n       return false;\n     }\n \n     // Do we have enough space on this node?\n     Resource availableResource \u003d Resources.clone(\n         schedulerContainer.getSchedulerNode().getUnallocatedResource());\n \n     // If we have any to-release container in non-reserved state, they are\n     // from lazy-preemption, add their consumption to available resource\n     // of this node\n     if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n         .isEmpty()) {\n       for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n           releaseContainer : allocation.getToRelease()) {\n+        // Make sure to-release reserved containers are not outdated\n+        if (releaseContainer.getRmContainer().getState()\n+            \u003d\u003d RMContainerState.RESERVED\n+            \u0026\u0026 releaseContainer.getRmContainer() !\u003d releaseContainer\n+            .getSchedulerNode().getReservedContainer()) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Failed to accept this proposal because \"\n+                + \"it tries to release an outdated reserved container \"\n+                + releaseContainer.getRmContainer().getContainerId()\n+                + \" on node \" + releaseContainer.getSchedulerNode().getNodeID()\n+                + \" whose reserved container is \"\n+                + releaseContainer.getSchedulerNode().getReservedContainer());\n+          }\n+          return false;\n+        }\n         // Only consider non-reserved container (reserved container will\n         // not affect available resource of node) on the same node\n         if (releaseContainer.getRmContainer().getState()\n             !\u003d RMContainerState.RESERVED\n             \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n             .getSchedulerNode()) {\n           Resources.addTo(availableResource,\n               releaseContainer.getRmContainer().getAllocatedResource());\n         }\n       }\n     }\n     if (!Resources.fitsIn(rc, allocation.getAllocatedOrReservedResource(),\n         availableResource)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n             + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n             + availableResource);\n       }\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean commonCheckContainerAllocation(\n      ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n      SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n    // Make sure node is not reserved by anyone else\n    RMContainer reservedContainerOnNode \u003d\n        schedulerContainer.getSchedulerNode().getReservedContainer();\n    if (reservedContainerOnNode !\u003d null) {\n      // adding NP check as this proposal could not be allocated from reserved\n      // container in async-scheduling mode\n      if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n        return false;\n      }\n      RMContainer fromReservedContainer \u003d\n          allocation.getAllocateFromReservedContainer().getRmContainer();\n\n      if (fromReservedContainer !\u003d reservedContainerOnNode) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Try to allocate from a non-existed reserved container\");\n        }\n        return false;\n      }\n    }\n    // If allocate from reserved container, make sure node is still reserved\n    if (allocation.getAllocateFromReservedContainer() !\u003d null\n        \u0026\u0026 reservedContainerOnNode \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Try to allocate from reserved container \" + allocation\n            .getAllocateFromReservedContainer().getRmContainer()\n            .getContainerId() + \", but node is not reserved\");\n      }\n      return false;\n    }\n\n    // Do we have enough space on this node?\n    Resource availableResource \u003d Resources.clone(\n        schedulerContainer.getSchedulerNode().getUnallocatedResource());\n\n    // If we have any to-release container in non-reserved state, they are\n    // from lazy-preemption, add their consumption to available resource\n    // of this node\n    if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n        .isEmpty()) {\n      for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n          releaseContainer : allocation.getToRelease()) {\n        // Make sure to-release reserved containers are not outdated\n        if (releaseContainer.getRmContainer().getState()\n            \u003d\u003d RMContainerState.RESERVED\n            \u0026\u0026 releaseContainer.getRmContainer() !\u003d releaseContainer\n            .getSchedulerNode().getReservedContainer()) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Failed to accept this proposal because \"\n                + \"it tries to release an outdated reserved container \"\n                + releaseContainer.getRmContainer().getContainerId()\n                + \" on node \" + releaseContainer.getSchedulerNode().getNodeID()\n                + \" whose reserved container is \"\n                + releaseContainer.getSchedulerNode().getReservedContainer());\n          }\n          return false;\n        }\n        // Only consider non-reserved container (reserved container will\n        // not affect available resource of node) on the same node\n        if (releaseContainer.getRmContainer().getState()\n            !\u003d RMContainerState.RESERVED\n            \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n            .getSchedulerNode()) {\n          Resources.addTo(availableResource,\n              releaseContainer.getRmContainer().getAllocatedResource());\n        }\n      }\n    }\n    if (!Resources.fitsIn(rc, allocation.getAllocatedOrReservedResource(),\n        availableResource)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n            + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n            + availableResource);\n      }\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "7eb783e2634d8c11fb646f1f2fdf597336325312": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8127. Resource leak when async scheduling is enabled. Contributed by Tao Yang.\n",
      "commitDate": "11/04/18 2:15 AM",
      "commitName": "7eb783e2634d8c11fb646f1f2fdf597336325312",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "28/03/18 11:07 AM",
      "commitNameOld": "47f711eebca315804c80012eea5f31275ac25518",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 13.63,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,68 @@\n   private boolean commonCheckContainerAllocation(\n       ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n       SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n     // Make sure node is not reserved by anyone else\n     RMContainer reservedContainerOnNode \u003d\n         schedulerContainer.getSchedulerNode().getReservedContainer();\n     if (reservedContainerOnNode !\u003d null) {\n       // adding NP check as this proposal could not be allocated from reserved\n       // container in async-scheduling mode\n       if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n         return false;\n       }\n       RMContainer fromReservedContainer \u003d\n           allocation.getAllocateFromReservedContainer().getRmContainer();\n \n       if (fromReservedContainer !\u003d reservedContainerOnNode) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Try to allocate from a non-existed reserved container\");\n         }\n         return false;\n       }\n     }\n+    // If allocate from reserved container, make sure node is still reserved\n+    if (allocation.getAllocateFromReservedContainer() !\u003d null\n+        \u0026\u0026 reservedContainerOnNode \u003d\u003d null) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Try to allocate from reserved container \" + allocation\n+            .getAllocateFromReservedContainer().getRmContainer()\n+            .getContainerId() + \", but node is not reserved\");\n+      }\n+      return false;\n+    }\n \n     // Do we have enough space on this node?\n     Resource availableResource \u003d Resources.clone(\n         schedulerContainer.getSchedulerNode().getUnallocatedResource());\n \n     // If we have any to-release container in non-reserved state, they are\n     // from lazy-preemption, add their consumption to available resource\n     // of this node\n     if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n         .isEmpty()) {\n       for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n           releaseContainer : allocation.getToRelease()) {\n         // Only consider non-reserved container (reserved container will\n         // not affect available resource of node) on the same node\n         if (releaseContainer.getRmContainer().getState()\n             !\u003d RMContainerState.RESERVED\n             \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n             .getSchedulerNode()) {\n           Resources.addTo(availableResource,\n               releaseContainer.getRmContainer().getAllocatedResource());\n         }\n       }\n     }\n     if (!Resources.fitsIn(rc, allocation.getAllocatedOrReservedResource(),\n         availableResource)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n             + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n             + availableResource);\n       }\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean commonCheckContainerAllocation(\n      ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n      SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n    // Make sure node is not reserved by anyone else\n    RMContainer reservedContainerOnNode \u003d\n        schedulerContainer.getSchedulerNode().getReservedContainer();\n    if (reservedContainerOnNode !\u003d null) {\n      // adding NP check as this proposal could not be allocated from reserved\n      // container in async-scheduling mode\n      if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n        return false;\n      }\n      RMContainer fromReservedContainer \u003d\n          allocation.getAllocateFromReservedContainer().getRmContainer();\n\n      if (fromReservedContainer !\u003d reservedContainerOnNode) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Try to allocate from a non-existed reserved container\");\n        }\n        return false;\n      }\n    }\n    // If allocate from reserved container, make sure node is still reserved\n    if (allocation.getAllocateFromReservedContainer() !\u003d null\n        \u0026\u0026 reservedContainerOnNode \u003d\u003d null) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Try to allocate from reserved container \" + allocation\n            .getAllocateFromReservedContainer().getRmContainer()\n            .getContainerId() + \", but node is not reserved\");\n      }\n      return false;\n    }\n\n    // Do we have enough space on this node?\n    Resource availableResource \u003d Resources.clone(\n        schedulerContainer.getSchedulerNode().getUnallocatedResource());\n\n    // If we have any to-release container in non-reserved state, they are\n    // from lazy-preemption, add their consumption to available resource\n    // of this node\n    if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n        .isEmpty()) {\n      for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n          releaseContainer : allocation.getToRelease()) {\n        // Only consider non-reserved container (reserved container will\n        // not affect available resource of node) on the same node\n        if (releaseContainer.getRmContainer().getState()\n            !\u003d RMContainerState.RESERVED\n            \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n            .getSchedulerNode()) {\n          Resources.addTo(availableResource,\n              releaseContainer.getRmContainer().getAllocatedResource());\n        }\n      }\n    }\n    if (!Resources.fitsIn(rc, allocation.getAllocatedOrReservedResource(),\n        availableResource)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n            + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n            + availableResource);\n      }\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7591. NPE in async-scheduling mode of CapacityScheduler. (Tao Yang via wangda)\n\nChange-Id: I46689e530550ee0a6ac7a29786aab2cc1bdf314f\n",
      "commitDate": "08/12/17 3:17 PM",
      "commitName": "adca1a72e4eca2ea634551e9fb8e9b878c36cb5c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/12/17 6:56 PM",
      "commitNameOld": "d52627a7cbddfd981db973e223aefffde1ebf82d",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.85,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,58 @@\n   private boolean commonCheckContainerAllocation(\n       ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n       SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n     // Make sure node is not reserved by anyone else\n     RMContainer reservedContainerOnNode \u003d\n         schedulerContainer.getSchedulerNode().getReservedContainer();\n     if (reservedContainerOnNode !\u003d null) {\n+      // adding NP check as this proposal could not be allocated from reserved\n+      // container in async-scheduling mode\n+      if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n+        return false;\n+      }\n       RMContainer fromReservedContainer \u003d\n           allocation.getAllocateFromReservedContainer().getRmContainer();\n \n       if (fromReservedContainer !\u003d reservedContainerOnNode) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Try to allocate from a non-existed reserved container\");\n         }\n         return false;\n       }\n     }\n \n     // Do we have enough space on this node?\n     Resource availableResource \u003d Resources.clone(\n         schedulerContainer.getSchedulerNode().getUnallocatedResource());\n \n     // If we have any to-release container in non-reserved state, they are\n     // from lazy-preemption, add their consumption to available resource\n     // of this node\n     if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n         .isEmpty()) {\n       for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n           releaseContainer : allocation.getToRelease()) {\n         // Only consider non-reserved container (reserved container will\n         // not affect available resource of node) on the same node\n         if (releaseContainer.getRmContainer().getState()\n             !\u003d RMContainerState.RESERVED\n             \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n             .getSchedulerNode()) {\n           Resources.addTo(availableResource,\n               releaseContainer.getRmContainer().getAllocatedResource());\n         }\n       }\n     }\n     if (!Resources.fitsIn(rc, allocation.getAllocatedOrReservedResource(),\n         availableResource)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n             + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n             + availableResource);\n       }\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean commonCheckContainerAllocation(\n      ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n      SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n    // Make sure node is not reserved by anyone else\n    RMContainer reservedContainerOnNode \u003d\n        schedulerContainer.getSchedulerNode().getReservedContainer();\n    if (reservedContainerOnNode !\u003d null) {\n      // adding NP check as this proposal could not be allocated from reserved\n      // container in async-scheduling mode\n      if (allocation.getAllocateFromReservedContainer() \u003d\u003d null) {\n        return false;\n      }\n      RMContainer fromReservedContainer \u003d\n          allocation.getAllocateFromReservedContainer().getRmContainer();\n\n      if (fromReservedContainer !\u003d reservedContainerOnNode) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Try to allocate from a non-existed reserved container\");\n        }\n        return false;\n      }\n    }\n\n    // Do we have enough space on this node?\n    Resource availableResource \u003d Resources.clone(\n        schedulerContainer.getSchedulerNode().getUnallocatedResource());\n\n    // If we have any to-release container in non-reserved state, they are\n    // from lazy-preemption, add their consumption to available resource\n    // of this node\n    if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n        .isEmpty()) {\n      for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n          releaseContainer : allocation.getToRelease()) {\n        // Only consider non-reserved container (reserved container will\n        // not affect available resource of node) on the same node\n        if (releaseContainer.getRmContainer().getState()\n            !\u003d RMContainerState.RESERVED\n            \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n            .getSchedulerNode()) {\n          Resources.addTo(availableResource,\n              releaseContainer.getRmContainer().getAllocatedResource());\n        }\n      }\n    }\n    if (!Resources.fitsIn(rc, allocation.getAllocatedOrReservedResource(),\n        availableResource)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n            + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n            + availableResource);\n      }\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "e81596d06d226f1cfa44b2390ce3095ed4dee621": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7172. ResourceCalculator.fitsIn() should not take a cluster resource parameter. (Sen Zhao via wangda)\n\nChange-Id: Icc3670c9381ce7591ca69ec12da5aa52d3612d34\n",
      "commitDate": "17/09/17 9:20 PM",
      "commitName": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7172. ResourceCalculator.fitsIn() should not take a cluster resource parameter. (Sen Zhao via wangda)\n\nChange-Id: Icc3670c9381ce7591ca69ec12da5aa52d3612d34\n",
          "commitDate": "17/09/17 9:20 PM",
          "commitName": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "03/08/17 6:57 AM",
          "commitNameOld": "f64cfeaf61ec65a465decdd8215f567d4e6677a9",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 45.6,
          "commitsBetweenForRepo": 408,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,55 +1,53 @@\n   private boolean commonCheckContainerAllocation(\n-      Resource cluster,\n       ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n       SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n     // Make sure node is not reserved by anyone else\n     RMContainer reservedContainerOnNode \u003d\n         schedulerContainer.getSchedulerNode().getReservedContainer();\n     if (reservedContainerOnNode !\u003d null) {\n       RMContainer fromReservedContainer \u003d\n           allocation.getAllocateFromReservedContainer().getRmContainer();\n \n       if (fromReservedContainer !\u003d reservedContainerOnNode) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Try to allocate from a non-existed reserved container\");\n         }\n         return false;\n       }\n     }\n \n     // Do we have enough space on this node?\n     Resource availableResource \u003d Resources.clone(\n         schedulerContainer.getSchedulerNode().getUnallocatedResource());\n \n     // If we have any to-release container in non-reserved state, they are\n     // from lazy-preemption, add their consumption to available resource\n     // of this node\n     if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n         .isEmpty()) {\n       for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n           releaseContainer : allocation.getToRelease()) {\n         // Only consider non-reserved container (reserved container will\n         // not affect available resource of node) on the same node\n         if (releaseContainer.getRmContainer().getState()\n             !\u003d RMContainerState.RESERVED\n             \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n             .getSchedulerNode()) {\n           Resources.addTo(availableResource,\n               releaseContainer.getRmContainer().getAllocatedResource());\n         }\n       }\n     }\n-    if (!Resources.fitsIn(rc, cluster,\n-        allocation.getAllocatedOrReservedResource(),\n+    if (!Resources.fitsIn(rc, allocation.getAllocatedOrReservedResource(),\n         availableResource)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n             + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n             + availableResource);\n       }\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean commonCheckContainerAllocation(\n      ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n      SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n    // Make sure node is not reserved by anyone else\n    RMContainer reservedContainerOnNode \u003d\n        schedulerContainer.getSchedulerNode().getReservedContainer();\n    if (reservedContainerOnNode !\u003d null) {\n      RMContainer fromReservedContainer \u003d\n          allocation.getAllocateFromReservedContainer().getRmContainer();\n\n      if (fromReservedContainer !\u003d reservedContainerOnNode) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Try to allocate from a non-existed reserved container\");\n        }\n        return false;\n      }\n    }\n\n    // Do we have enough space on this node?\n    Resource availableResource \u003d Resources.clone(\n        schedulerContainer.getSchedulerNode().getUnallocatedResource());\n\n    // If we have any to-release container in non-reserved state, they are\n    // from lazy-preemption, add their consumption to available resource\n    // of this node\n    if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n        .isEmpty()) {\n      for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n          releaseContainer : allocation.getToRelease()) {\n        // Only consider non-reserved container (reserved container will\n        // not affect available resource of node) on the same node\n        if (releaseContainer.getRmContainer().getState()\n            !\u003d RMContainerState.RESERVED\n            \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n            .getSchedulerNode()) {\n          Resources.addTo(availableResource,\n              releaseContainer.getRmContainer().getAllocatedResource());\n        }\n      }\n    }\n    if (!Resources.fitsIn(rc, allocation.getAllocatedOrReservedResource(),\n        availableResource)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n            + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n            + availableResource);\n      }\n      return false;\n    }\n\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {
            "oldValue": "[cluster-Resource, allocation-ContainerAllocationProposal\u003cFiCaSchedulerApp,FiCaSchedulerNode\u003e, schedulerContainer-SchedulerContainer\u003cFiCaSchedulerApp,FiCaSchedulerNode\u003e]",
            "newValue": "[allocation-ContainerAllocationProposal\u003cFiCaSchedulerApp,FiCaSchedulerNode\u003e, schedulerContainer-SchedulerContainer\u003cFiCaSchedulerApp,FiCaSchedulerNode\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7172. ResourceCalculator.fitsIn() should not take a cluster resource parameter. (Sen Zhao via wangda)\n\nChange-Id: Icc3670c9381ce7591ca69ec12da5aa52d3612d34\n",
          "commitDate": "17/09/17 9:20 PM",
          "commitName": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "03/08/17 6:57 AM",
          "commitNameOld": "f64cfeaf61ec65a465decdd8215f567d4e6677a9",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 45.6,
          "commitsBetweenForRepo": 408,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,55 +1,53 @@\n   private boolean commonCheckContainerAllocation(\n-      Resource cluster,\n       ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n       SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n     // Make sure node is not reserved by anyone else\n     RMContainer reservedContainerOnNode \u003d\n         schedulerContainer.getSchedulerNode().getReservedContainer();\n     if (reservedContainerOnNode !\u003d null) {\n       RMContainer fromReservedContainer \u003d\n           allocation.getAllocateFromReservedContainer().getRmContainer();\n \n       if (fromReservedContainer !\u003d reservedContainerOnNode) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\n               \"Try to allocate from a non-existed reserved container\");\n         }\n         return false;\n       }\n     }\n \n     // Do we have enough space on this node?\n     Resource availableResource \u003d Resources.clone(\n         schedulerContainer.getSchedulerNode().getUnallocatedResource());\n \n     // If we have any to-release container in non-reserved state, they are\n     // from lazy-preemption, add their consumption to available resource\n     // of this node\n     if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n         .isEmpty()) {\n       for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n           releaseContainer : allocation.getToRelease()) {\n         // Only consider non-reserved container (reserved container will\n         // not affect available resource of node) on the same node\n         if (releaseContainer.getRmContainer().getState()\n             !\u003d RMContainerState.RESERVED\n             \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n             .getSchedulerNode()) {\n           Resources.addTo(availableResource,\n               releaseContainer.getRmContainer().getAllocatedResource());\n         }\n       }\n     }\n-    if (!Resources.fitsIn(rc, cluster,\n-        allocation.getAllocatedOrReservedResource(),\n+    if (!Resources.fitsIn(rc, allocation.getAllocatedOrReservedResource(),\n         availableResource)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n             + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n             + availableResource);\n       }\n       return false;\n     }\n \n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean commonCheckContainerAllocation(\n      ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n      SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n    // Make sure node is not reserved by anyone else\n    RMContainer reservedContainerOnNode \u003d\n        schedulerContainer.getSchedulerNode().getReservedContainer();\n    if (reservedContainerOnNode !\u003d null) {\n      RMContainer fromReservedContainer \u003d\n          allocation.getAllocateFromReservedContainer().getRmContainer();\n\n      if (fromReservedContainer !\u003d reservedContainerOnNode) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Try to allocate from a non-existed reserved container\");\n        }\n        return false;\n      }\n    }\n\n    // Do we have enough space on this node?\n    Resource availableResource \u003d Resources.clone(\n        schedulerContainer.getSchedulerNode().getUnallocatedResource());\n\n    // If we have any to-release container in non-reserved state, they are\n    // from lazy-preemption, add their consumption to available resource\n    // of this node\n    if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n        .isEmpty()) {\n      for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n          releaseContainer : allocation.getToRelease()) {\n        // Only consider non-reserved container (reserved container will\n        // not affect available resource of node) on the same node\n        if (releaseContainer.getRmContainer().getState()\n            !\u003d RMContainerState.RESERVED\n            \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n            .getSchedulerNode()) {\n          Resources.addTo(availableResource,\n              releaseContainer.getRmContainer().getAllocatedResource());\n        }\n      }\n    }\n    if (!Resources.fitsIn(rc, allocation.getAllocatedOrReservedResource(),\n        availableResource)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n            + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n            + availableResource);\n      }\n      return false;\n    }\n\n    return true;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {}
        }
      ]
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "07/11/16 10:14 AM",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,55 @@\n+  private boolean commonCheckContainerAllocation(\n+      Resource cluster,\n+      ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n+      SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n+    // Make sure node is not reserved by anyone else\n+    RMContainer reservedContainerOnNode \u003d\n+        schedulerContainer.getSchedulerNode().getReservedContainer();\n+    if (reservedContainerOnNode !\u003d null) {\n+      RMContainer fromReservedContainer \u003d\n+          allocation.getAllocateFromReservedContainer().getRmContainer();\n+\n+      if (fromReservedContainer !\u003d reservedContainerOnNode) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\n+              \"Try to allocate from a non-existed reserved container\");\n+        }\n+        return false;\n+      }\n+    }\n+\n+    // Do we have enough space on this node?\n+    Resource availableResource \u003d Resources.clone(\n+        schedulerContainer.getSchedulerNode().getUnallocatedResource());\n+\n+    // If we have any to-release container in non-reserved state, they are\n+    // from lazy-preemption, add their consumption to available resource\n+    // of this node\n+    if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n+        .isEmpty()) {\n+      for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n+          releaseContainer : allocation.getToRelease()) {\n+        // Only consider non-reserved container (reserved container will\n+        // not affect available resource of node) on the same node\n+        if (releaseContainer.getRmContainer().getState()\n+            !\u003d RMContainerState.RESERVED\n+            \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n+            .getSchedulerNode()) {\n+          Resources.addTo(availableResource,\n+              releaseContainer.getRmContainer().getAllocatedResource());\n+        }\n+      }\n+    }\n+    if (!Resources.fitsIn(rc, cluster,\n+        allocation.getAllocatedOrReservedResource(),\n+        availableResource)) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n+            + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n+            + availableResource);\n+      }\n+      return false;\n+    }\n+\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean commonCheckContainerAllocation(\n      Resource cluster,\n      ContainerAllocationProposal\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e allocation,\n      SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e schedulerContainer) {\n    // Make sure node is not reserved by anyone else\n    RMContainer reservedContainerOnNode \u003d\n        schedulerContainer.getSchedulerNode().getReservedContainer();\n    if (reservedContainerOnNode !\u003d null) {\n      RMContainer fromReservedContainer \u003d\n          allocation.getAllocateFromReservedContainer().getRmContainer();\n\n      if (fromReservedContainer !\u003d reservedContainerOnNode) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\n              \"Try to allocate from a non-existed reserved container\");\n        }\n        return false;\n      }\n    }\n\n    // Do we have enough space on this node?\n    Resource availableResource \u003d Resources.clone(\n        schedulerContainer.getSchedulerNode().getUnallocatedResource());\n\n    // If we have any to-release container in non-reserved state, they are\n    // from lazy-preemption, add their consumption to available resource\n    // of this node\n    if (allocation.getToRelease() !\u003d null \u0026\u0026 !allocation.getToRelease()\n        .isEmpty()) {\n      for (SchedulerContainer\u003cFiCaSchedulerApp, FiCaSchedulerNode\u003e\n          releaseContainer : allocation.getToRelease()) {\n        // Only consider non-reserved container (reserved container will\n        // not affect available resource of node) on the same node\n        if (releaseContainer.getRmContainer().getState()\n            !\u003d RMContainerState.RESERVED\n            \u0026\u0026 releaseContainer.getSchedulerNode() \u003d\u003d schedulerContainer\n            .getSchedulerNode()) {\n          Resources.addTo(availableResource,\n              releaseContainer.getRmContainer().getAllocatedResource());\n        }\n      }\n    }\n    if (!Resources.fitsIn(rc, cluster,\n        allocation.getAllocatedOrReservedResource(),\n        availableResource)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Node doesn\u0027t have enough available resource, asked\u003d\"\n            + allocation.getAllocatedOrReservedResource() + \" available\u003d\"\n            + availableResource);\n      }\n      return false;\n    }\n\n    return true;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java"
    }
  }
}