{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerScheduler.java",
  "functionName": "scheduleContainer",
  "functionId": "scheduleContainer___container-Container",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
  "functionStartLine": 472,
  "functionEndLine": 511,
  "numCommitsSeen": 22,
  "timeTaken": 3376,
  "changeHistory": [
    "489411579c5e30c1dc855c4fd3d5f7f68a58b27e",
    "4f8194430fc6a69d9cc99b78828fd7045d5683e8",
    "2ae72692fc370267141a1ee55ef372ff62302b54",
    "5b007921cdf01ecc8ed97c164b7d327b8304c529",
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6"
  ],
  "changeHistoryShort": {
    "489411579c5e30c1dc855c4fd3d5f7f68a58b27e": "Ybodychange",
    "4f8194430fc6a69d9cc99b78828fd7045d5683e8": "Ybodychange",
    "2ae72692fc370267141a1ee55ef372ff62302b54": "Ybodychange",
    "5b007921cdf01ecc8ed97c164b7d327b8304c529": "Ybodychange",
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6": "Yintroduced"
  },
  "changeHistoryDetails": {
    "489411579c5e30c1dc855c4fd3d5f7f68a58b27e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9169. Add metrics for queued opportunistic and guaranteed containers. Contributed by Abhishek Modi.\n",
      "commitDate": "07/01/19 3:16 PM",
      "commitName": "489411579c5e30c1dc855c4fd3d5f7f68a58b27e",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "04/01/19 11:16 AM",
      "commitNameOld": "6e35f7130fb3fb17665e818f838ed750425348c0",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 3.17,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,40 @@\n   protected void scheduleContainer(Container container) {\n     boolean isGuaranteedContainer \u003d container.getContainerTokenIdentifier().\n         getExecutionType() \u003d\u003d ExecutionType.GUARANTEED;\n \n     // Given a guaranteed container, we enqueue it first and then try to start\n     // as many queuing guaranteed containers as possible followed by queuing\n     // opportunistic containers based on remaining resources available. If the\n     // container still stays in the queue afterwards, we need to preempt just\n     // enough number of opportunistic containers.\n     if (isGuaranteedContainer) {\n       enqueueContainer(container);\n \n       // When opportunistic container not allowed (which is determined by\n       // max-queue length of pending opportunistic containers \u003c\u003d 0), start\n       // guaranteed containers without looking at available resources.\n       boolean forceStartGuaranteedContainers \u003d (maxOppQueueLength \u003c\u003d 0);\n       startPendingContainers(forceStartGuaranteedContainers);\n \n       // if the guaranteed container is queued, we need to preempt opportunistic\n       // containers for make room for it\n       if (queuedGuaranteedContainers.containsKey(container.getContainerId())) {\n         reclaimOpportunisticContainerResources(container);\n       }\n     } else {\n       // Given an opportunistic container, we first try to start as many queuing\n       // guaranteed containers as possible followed by queuing opportunistic\n       // containers based on remaining resource available, then enqueue the\n       // opportunistic container. If the container is enqueued, we do another\n       // pass to try to start the newly enqueued opportunistic container.\n       startPendingContainers(false);\n       boolean containerQueued \u003d enqueueContainer(container);\n       // container may not get queued because the max opportunistic container\n       // queue length is reached. If so, there is no point doing another pass\n       if (containerQueued) {\n         startPendingContainers(false);\n       }\n     }\n+    metrics.setQueuedContainers(queuedOpportunisticContainers.size(),\n+        queuedGuaranteedContainers.size());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void scheduleContainer(Container container) {\n    boolean isGuaranteedContainer \u003d container.getContainerTokenIdentifier().\n        getExecutionType() \u003d\u003d ExecutionType.GUARANTEED;\n\n    // Given a guaranteed container, we enqueue it first and then try to start\n    // as many queuing guaranteed containers as possible followed by queuing\n    // opportunistic containers based on remaining resources available. If the\n    // container still stays in the queue afterwards, we need to preempt just\n    // enough number of opportunistic containers.\n    if (isGuaranteedContainer) {\n      enqueueContainer(container);\n\n      // When opportunistic container not allowed (which is determined by\n      // max-queue length of pending opportunistic containers \u003c\u003d 0), start\n      // guaranteed containers without looking at available resources.\n      boolean forceStartGuaranteedContainers \u003d (maxOppQueueLength \u003c\u003d 0);\n      startPendingContainers(forceStartGuaranteedContainers);\n\n      // if the guaranteed container is queued, we need to preempt opportunistic\n      // containers for make room for it\n      if (queuedGuaranteedContainers.containsKey(container.getContainerId())) {\n        reclaimOpportunisticContainerResources(container);\n      }\n    } else {\n      // Given an opportunistic container, we first try to start as many queuing\n      // guaranteed containers as possible followed by queuing opportunistic\n      // containers based on remaining resource available, then enqueue the\n      // opportunistic container. If the container is enqueued, we do another\n      // pass to try to start the newly enqueued opportunistic container.\n      startPendingContainers(false);\n      boolean containerQueued \u003d enqueueContainer(container);\n      // container may not get queued because the max opportunistic container\n      // queue length is reached. If so, there is no point doing another pass\n      if (containerQueued) {\n        startPendingContainers(false);\n      }\n    }\n    metrics.setQueuedContainers(queuedOpportunisticContainers.size(),\n        queuedGuaranteedContainers.size());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "4f8194430fc6a69d9cc99b78828fd7045d5683e8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5216. Expose configurable preemption policy for OPPORTUNISTIC containers running on the NM. (Hitesh Sharma via asuresh)\n",
      "commitDate": "14/09/17 8:51 AM",
      "commitName": "4f8194430fc6a69d9cc99b78828fd7045d5683e8",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "12/09/17 4:10 PM",
      "commitNameOld": "2ae72692fc370267141a1ee55ef372ff62302b54",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 1.7,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n   protected void scheduleContainer(Container container) {\n     boolean isGuaranteedContainer \u003d container.getContainerTokenIdentifier().\n         getExecutionType() \u003d\u003d ExecutionType.GUARANTEED;\n \n     // Given a guaranteed container, we enqueue it first and then try to start\n     // as many queuing guaranteed containers as possible followed by queuing\n     // opportunistic containers based on remaining resources available. If the\n     // container still stays in the queue afterwards, we need to preempt just\n     // enough number of opportunistic containers.\n     if (isGuaranteedContainer) {\n       enqueueContainer(container);\n \n       // When opportunistic container not allowed (which is determined by\n       // max-queue length of pending opportunistic containers \u003c\u003d 0), start\n       // guaranteed containers without looking at available resources.\n       boolean forceStartGuaranteedContainers \u003d (maxOppQueueLength \u003c\u003d 0);\n       startPendingContainers(forceStartGuaranteedContainers);\n \n       // if the guaranteed container is queued, we need to preempt opportunistic\n       // containers for make room for it\n       if (queuedGuaranteedContainers.containsKey(container.getContainerId())) {\n-        killOpportunisticContainers(container);\n+        reclaimOpportunisticContainerResources(container);\n       }\n     } else {\n       // Given an opportunistic container, we first try to start as many queuing\n       // guaranteed containers as possible followed by queuing opportunistic\n       // containers based on remaining resource available, then enqueue the\n       // opportunistic container. If the container is enqueued, we do another\n       // pass to try to start the newly enqueued opportunistic container.\n       startPendingContainers(false);\n       boolean containerQueued \u003d enqueueContainer(container);\n       // container may not get queued because the max opportunistic container\n       // queue length is reached. If so, there is no point doing another pass\n       if (containerQueued) {\n         startPendingContainers(false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void scheduleContainer(Container container) {\n    boolean isGuaranteedContainer \u003d container.getContainerTokenIdentifier().\n        getExecutionType() \u003d\u003d ExecutionType.GUARANTEED;\n\n    // Given a guaranteed container, we enqueue it first and then try to start\n    // as many queuing guaranteed containers as possible followed by queuing\n    // opportunistic containers based on remaining resources available. If the\n    // container still stays in the queue afterwards, we need to preempt just\n    // enough number of opportunistic containers.\n    if (isGuaranteedContainer) {\n      enqueueContainer(container);\n\n      // When opportunistic container not allowed (which is determined by\n      // max-queue length of pending opportunistic containers \u003c\u003d 0), start\n      // guaranteed containers without looking at available resources.\n      boolean forceStartGuaranteedContainers \u003d (maxOppQueueLength \u003c\u003d 0);\n      startPendingContainers(forceStartGuaranteedContainers);\n\n      // if the guaranteed container is queued, we need to preempt opportunistic\n      // containers for make room for it\n      if (queuedGuaranteedContainers.containsKey(container.getContainerId())) {\n        reclaimOpportunisticContainerResources(container);\n      }\n    } else {\n      // Given an opportunistic container, we first try to start as many queuing\n      // guaranteed containers as possible followed by queuing opportunistic\n      // containers based on remaining resource available, then enqueue the\n      // opportunistic container. If the container is enqueued, we do another\n      // pass to try to start the newly enqueued opportunistic container.\n      startPendingContainers(false);\n      boolean containerQueued \u003d enqueueContainer(container);\n      // container may not get queued because the max opportunistic container\n      // queue length is reached. If so, there is no point doing another pass\n      if (containerQueued) {\n        startPendingContainers(false);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "2ae72692fc370267141a1ee55ef372ff62302b54": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7185. ContainerScheduler should only look at availableResource for GUARANTEED containers when OPPORTUNISTIC container queuing is enabled. (Wangda Tan via asuresh)\n",
      "commitDate": "12/09/17 4:10 PM",
      "commitName": "2ae72692fc370267141a1ee55ef372ff62302b54",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "20/08/17 7:54 AM",
      "commitNameOld": "8410d862d3a72740f461ef91dddb5325955e1ca5",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 23.34,
      "commitsBetweenForRepo": 250,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,38 @@\n   protected void scheduleContainer(Container container) {\n     boolean isGuaranteedContainer \u003d container.getContainerTokenIdentifier().\n         getExecutionType() \u003d\u003d ExecutionType.GUARANTEED;\n \n     // Given a guaranteed container, we enqueue it first and then try to start\n     // as many queuing guaranteed containers as possible followed by queuing\n     // opportunistic containers based on remaining resources available. If the\n     // container still stays in the queue afterwards, we need to preempt just\n     // enough number of opportunistic containers.\n     if (isGuaranteedContainer) {\n       enqueueContainer(container);\n-      startPendingContainers();\n+\n+      // When opportunistic container not allowed (which is determined by\n+      // max-queue length of pending opportunistic containers \u003c\u003d 0), start\n+      // guaranteed containers without looking at available resources.\n+      boolean forceStartGuaranteedContainers \u003d (maxOppQueueLength \u003c\u003d 0);\n+      startPendingContainers(forceStartGuaranteedContainers);\n \n       // if the guaranteed container is queued, we need to preempt opportunistic\n       // containers for make room for it\n       if (queuedGuaranteedContainers.containsKey(container.getContainerId())) {\n         killOpportunisticContainers(container);\n       }\n     } else {\n       // Given an opportunistic container, we first try to start as many queuing\n       // guaranteed containers as possible followed by queuing opportunistic\n       // containers based on remaining resource available, then enqueue the\n       // opportunistic container. If the container is enqueued, we do another\n       // pass to try to start the newly enqueued opportunistic container.\n-      startPendingContainers();\n+      startPendingContainers(false);\n       boolean containerQueued \u003d enqueueContainer(container);\n       // container may not get queued because the max opportunistic container\n       // queue length is reached. If so, there is no point doing another pass\n       if (containerQueued) {\n-        startPendingContainers();\n+        startPendingContainers(false);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void scheduleContainer(Container container) {\n    boolean isGuaranteedContainer \u003d container.getContainerTokenIdentifier().\n        getExecutionType() \u003d\u003d ExecutionType.GUARANTEED;\n\n    // Given a guaranteed container, we enqueue it first and then try to start\n    // as many queuing guaranteed containers as possible followed by queuing\n    // opportunistic containers based on remaining resources available. If the\n    // container still stays in the queue afterwards, we need to preempt just\n    // enough number of opportunistic containers.\n    if (isGuaranteedContainer) {\n      enqueueContainer(container);\n\n      // When opportunistic container not allowed (which is determined by\n      // max-queue length of pending opportunistic containers \u003c\u003d 0), start\n      // guaranteed containers without looking at available resources.\n      boolean forceStartGuaranteedContainers \u003d (maxOppQueueLength \u003c\u003d 0);\n      startPendingContainers(forceStartGuaranteedContainers);\n\n      // if the guaranteed container is queued, we need to preempt opportunistic\n      // containers for make room for it\n      if (queuedGuaranteedContainers.containsKey(container.getContainerId())) {\n        killOpportunisticContainers(container);\n      }\n    } else {\n      // Given an opportunistic container, we first try to start as many queuing\n      // guaranteed containers as possible followed by queuing opportunistic\n      // containers based on remaining resource available, then enqueue the\n      // opportunistic container. If the container is enqueued, we do another\n      // pass to try to start the newly enqueued opportunistic container.\n      startPendingContainers(false);\n      boolean containerQueued \u003d enqueueContainer(container);\n      // container may not get queued because the max opportunistic container\n      // queue length is reached. If so, there is no point doing another pass\n      if (containerQueued) {\n        startPendingContainers(false);\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "5b007921cdf01ecc8ed97c164b7d327b8304c529": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6706. Refactor ContainerScheduler to make oversubscription change easier. (Haibo Chen via asuresh)\n",
      "commitDate": "17/07/17 2:11 PM",
      "commitName": "5b007921cdf01ecc8ed97c164b7d327b8304c529",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "16/12/16 8:14 AM",
      "commitNameOld": "2273a74c1f3895163046cca09ff5e983df301d22",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 213.21,
      "commitsBetweenForRepo": 1093,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,33 @@\n   protected void scheduleContainer(Container container) {\n-    if (maxOppQueueLength \u003c\u003d 0) {\n-      startAllocatedContainer(container);\n-      return;\n-    }\n-    if (queuedGuaranteedContainers.isEmpty() \u0026\u0026\n-        queuedOpportunisticContainers.isEmpty() \u0026\u0026\n-        this.utilizationTracker.hasResourcesAvailable(container)) {\n-      startAllocatedContainer(container);\n-    } else {\n-      LOG.info(\"No available resources for container {} to start its execution \"\n-          + \"immediately.\", container.getContainerId());\n-      boolean isQueued \u003d true;\n-      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n-          ExecutionType.GUARANTEED) {\n-        queuedGuaranteedContainers.put(container.getContainerId(), container);\n-        // Kill running opportunistic containers to make space for\n-        // guaranteed container.\n+    boolean isGuaranteedContainer \u003d container.getContainerTokenIdentifier().\n+        getExecutionType() \u003d\u003d ExecutionType.GUARANTEED;\n+\n+    // Given a guaranteed container, we enqueue it first and then try to start\n+    // as many queuing guaranteed containers as possible followed by queuing\n+    // opportunistic containers based on remaining resources available. If the\n+    // container still stays in the queue afterwards, we need to preempt just\n+    // enough number of opportunistic containers.\n+    if (isGuaranteedContainer) {\n+      enqueueContainer(container);\n+      startPendingContainers();\n+\n+      // if the guaranteed container is queued, we need to preempt opportunistic\n+      // containers for make room for it\n+      if (queuedGuaranteedContainers.containsKey(container.getContainerId())) {\n         killOpportunisticContainers(container);\n-      } else {\n-        if (queuedOpportunisticContainers.size() \u003c\u003d maxOppQueueLength) {\n-          LOG.info(\"Opportunistic container {} will be queued at the NM.\",\n-              container.getContainerId());\n-          queuedOpportunisticContainers.put(\n-              container.getContainerId(), container);\n-        } else {\n-          isQueued \u003d false;\n-          LOG.info(\"Opportunistic container [{}] will not be queued at the NM\" +\n-              \"since max queue length [{}] has been reached\",\n-              container.getContainerId(), maxOppQueueLength);\n-          container.sendKillEvent(\n-              ContainerExitStatus.KILLED_BY_CONTAINER_SCHEDULER,\n-              \"Opportunistic container queue is full.\");\n-        }\n       }\n-      if (isQueued) {\n-        try {\n-          this.context.getNMStateStore().storeContainerQueued(\n-              container.getContainerId());\n-        } catch (IOException e) {\n-          LOG.warn(\"Could not store container [\" + container.getContainerId()\n-              + \"] state. The Container has been queued.\", e);\n-        }\n+    } else {\n+      // Given an opportunistic container, we first try to start as many queuing\n+      // guaranteed containers as possible followed by queuing opportunistic\n+      // containers based on remaining resource available, then enqueue the\n+      // opportunistic container. If the container is enqueued, we do another\n+      // pass to try to start the newly enqueued opportunistic container.\n+      startPendingContainers();\n+      boolean containerQueued \u003d enqueueContainer(container);\n+      // container may not get queued because the max opportunistic container\n+      // queue length is reached. If so, there is no point doing another pass\n+      if (containerQueued) {\n+        startPendingContainers();\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void scheduleContainer(Container container) {\n    boolean isGuaranteedContainer \u003d container.getContainerTokenIdentifier().\n        getExecutionType() \u003d\u003d ExecutionType.GUARANTEED;\n\n    // Given a guaranteed container, we enqueue it first and then try to start\n    // as many queuing guaranteed containers as possible followed by queuing\n    // opportunistic containers based on remaining resources available. If the\n    // container still stays in the queue afterwards, we need to preempt just\n    // enough number of opportunistic containers.\n    if (isGuaranteedContainer) {\n      enqueueContainer(container);\n      startPendingContainers();\n\n      // if the guaranteed container is queued, we need to preempt opportunistic\n      // containers for make room for it\n      if (queuedGuaranteedContainers.containsKey(container.getContainerId())) {\n        killOpportunisticContainers(container);\n      }\n    } else {\n      // Given an opportunistic container, we first try to start as many queuing\n      // guaranteed containers as possible followed by queuing opportunistic\n      // containers based on remaining resource available, then enqueue the\n      // opportunistic container. If the container is enqueued, we do another\n      // pass to try to start the newly enqueued opportunistic container.\n      startPendingContainers();\n      boolean containerQueued \u003d enqueueContainer(container);\n      // container may not get queued because the max opportunistic container\n      // queue length is reached. If so, there is no point doing another pass\n      if (containerQueued) {\n        startPendingContainers();\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "3219b7b4ac7d12aee343f6ab2980b3357fc618b6": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4597. Introduce ContainerScheduler and a SCHEDULED state to NodeManager container lifecycle. (asuresh)\n",
      "commitDate": "15/11/16 7:56 AM",
      "commitName": "3219b7b4ac7d12aee343f6ab2980b3357fc618b6",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,46 @@\n+  protected void scheduleContainer(Container container) {\n+    if (maxOppQueueLength \u003c\u003d 0) {\n+      startAllocatedContainer(container);\n+      return;\n+    }\n+    if (queuedGuaranteedContainers.isEmpty() \u0026\u0026\n+        queuedOpportunisticContainers.isEmpty() \u0026\u0026\n+        this.utilizationTracker.hasResourcesAvailable(container)) {\n+      startAllocatedContainer(container);\n+    } else {\n+      LOG.info(\"No available resources for container {} to start its execution \"\n+          + \"immediately.\", container.getContainerId());\n+      boolean isQueued \u003d true;\n+      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n+          ExecutionType.GUARANTEED) {\n+        queuedGuaranteedContainers.put(container.getContainerId(), container);\n+        // Kill running opportunistic containers to make space for\n+        // guaranteed container.\n+        killOpportunisticContainers(container);\n+      } else {\n+        if (queuedOpportunisticContainers.size() \u003c\u003d maxOppQueueLength) {\n+          LOG.info(\"Opportunistic container {} will be queued at the NM.\",\n+              container.getContainerId());\n+          queuedOpportunisticContainers.put(\n+              container.getContainerId(), container);\n+        } else {\n+          isQueued \u003d false;\n+          LOG.info(\"Opportunistic container [{}] will not be queued at the NM\" +\n+              \"since max queue length [{}] has been reached\",\n+              container.getContainerId(), maxOppQueueLength);\n+          container.sendKillEvent(\n+              ContainerExitStatus.KILLED_BY_CONTAINER_SCHEDULER,\n+              \"Opportunistic container queue is full.\");\n+        }\n+      }\n+      if (isQueued) {\n+        try {\n+          this.context.getNMStateStore().storeContainerQueued(\n+              container.getContainerId());\n+        } catch (IOException e) {\n+          LOG.warn(\"Could not store container [\" + container.getContainerId()\n+              + \"] state. The Container has been queued.\", e);\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void scheduleContainer(Container container) {\n    if (maxOppQueueLength \u003c\u003d 0) {\n      startAllocatedContainer(container);\n      return;\n    }\n    if (queuedGuaranteedContainers.isEmpty() \u0026\u0026\n        queuedOpportunisticContainers.isEmpty() \u0026\u0026\n        this.utilizationTracker.hasResourcesAvailable(container)) {\n      startAllocatedContainer(container);\n    } else {\n      LOG.info(\"No available resources for container {} to start its execution \"\n          + \"immediately.\", container.getContainerId());\n      boolean isQueued \u003d true;\n      if (container.getContainerTokenIdentifier().getExecutionType() \u003d\u003d\n          ExecutionType.GUARANTEED) {\n        queuedGuaranteedContainers.put(container.getContainerId(), container);\n        // Kill running opportunistic containers to make space for\n        // guaranteed container.\n        killOpportunisticContainers(container);\n      } else {\n        if (queuedOpportunisticContainers.size() \u003c\u003d maxOppQueueLength) {\n          LOG.info(\"Opportunistic container {} will be queued at the NM.\",\n              container.getContainerId());\n          queuedOpportunisticContainers.put(\n              container.getContainerId(), container);\n        } else {\n          isQueued \u003d false;\n          LOG.info(\"Opportunistic container [{}] will not be queued at the NM\" +\n              \"since max queue length [{}] has been reached\",\n              container.getContainerId(), maxOppQueueLength);\n          container.sendKillEvent(\n              ContainerExitStatus.KILLED_BY_CONTAINER_SCHEDULER,\n              \"Opportunistic container queue is full.\");\n        }\n      }\n      if (isQueued) {\n        try {\n          this.context.getNMStateStore().storeContainerQueued(\n              container.getContainerId());\n        } catch (IOException e) {\n          LOG.warn(\"Could not store container [\" + container.getContainerId()\n              + \"] state. The Container has been queued.\", e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java"
    }
  }
}