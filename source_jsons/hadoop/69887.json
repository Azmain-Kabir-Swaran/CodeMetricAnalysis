{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbfsHttpOperation.java",
  "functionName": "processResponse",
  "functionId": "processResponse___buffer-byte[](modifiers-final)__offset-int(modifiers-final)__length-int(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsHttpOperation.java",
  "functionStartLine": 308,
  "functionEndLine": 391,
  "numCommitsSeen": 11,
  "timeTaken": 1304,
  "changeHistory": [
    "65f60e56b082faf92e1cd3daee2569d8fc669c67",
    "b54b0c1b676c616aef9574e4e88ea30c314c79dc",
    "f044deedbbfee0812316d587139cb828f27172e9"
  ],
  "changeHistoryShort": {
    "65f60e56b082faf92e1cd3daee2569d8fc669c67": "Ybodychange",
    "b54b0c1b676c616aef9574e4e88ea30c314c79dc": "Ybodychange",
    "f044deedbbfee0812316d587139cb828f27172e9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "65f60e56b082faf92e1cd3daee2569d8fc669c67": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16068. ABFS Authentication and Delegation Token plugins to optionally be bound to specific URI of the store.\n\nContributed by Steve Loughran.\n",
      "commitDate": "28/02/19 6:22 AM",
      "commitName": "65f60e56b082faf92e1cd3daee2569d8fc669c67",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/09/18 12:54 PM",
      "commitNameOld": "dd2b22fa31b4e8c9a9a1da05ae214605fdb5c25e",
      "commitAuthorOld": "Thomas Marquardt",
      "daysBetweenCommits": 163.77,
      "commitsBetweenForRepo": 1290,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,84 @@\n   public void processResponse(final byte[] buffer, final int offset, final int length) throws IOException {\n \n     // get the response\n     long startTime \u003d 0;\n     if (this.isTraceEnabled) {\n       startTime \u003d System.nanoTime();\n     }\n \n     this.statusCode \u003d this.connection.getResponseCode();\n \n     if (this.isTraceEnabled) {\n       this.recvResponseTimeMs \u003d elapsedTimeMs(startTime);\n     }\n \n     this.statusDescription \u003d this.connection.getResponseMessage();\n \n     this.requestId \u003d this.connection.getHeaderField(HttpHeaderConfigurations.X_MS_REQUEST_ID);\n     if (this.requestId \u003d\u003d null) {\n       this.requestId \u003d AbfsHttpConstants.EMPTY_STRING;\n     }\n+    // dump the headers\n+    AbfsIoUtils.dumpHeadersToDebugLog(\"Response Headers\",\n+        connection.getHeaderFields());\n \n     if (AbfsHttpConstants.HTTP_METHOD_HEAD.equals(this.method)) {\n       // If it is HEAD, and it is ERROR\n       return;\n     }\n \n     if (this.isTraceEnabled) {\n       startTime \u003d System.nanoTime();\n     }\n \n     if (statusCode \u003e\u003d HttpURLConnection.HTTP_BAD_REQUEST) {\n       processStorageErrorResponse();\n       if (this.isTraceEnabled) {\n         this.recvResponseTimeMs +\u003d elapsedTimeMs(startTime);\n       }\n       this.bytesReceived \u003d this.connection.getHeaderFieldLong(HttpHeaderConfigurations.CONTENT_LENGTH, 0);\n     } else {\n       // consume the input stream to release resources\n       int totalBytesRead \u003d 0;\n \n       try (InputStream stream \u003d this.connection.getInputStream()) {\n         if (isNullInputStream(stream)) {\n           return;\n         }\n         boolean endOfStream \u003d false;\n \n         // this is a list operation and need to retrieve the data\n         // need a better solution\n         if (AbfsHttpConstants.HTTP_METHOD_GET.equals(this.method) \u0026\u0026 buffer \u003d\u003d null) {\n           parseListFilesResponse(stream);\n         } else {\n           if (buffer !\u003d null) {\n             while (totalBytesRead \u003c length) {\n               int bytesRead \u003d stream.read(buffer, offset + totalBytesRead, length - totalBytesRead);\n               if (bytesRead \u003d\u003d -1) {\n                 endOfStream \u003d true;\n                 break;\n               }\n               totalBytesRead +\u003d bytesRead;\n             }\n           }\n           if (!endOfStream \u0026\u0026 stream.read() !\u003d -1) {\n             // read and discard\n             int bytesRead \u003d 0;\n             byte[] b \u003d new byte[CLEAN_UP_BUFFER_SIZE];\n             while ((bytesRead \u003d stream.read(b)) \u003e\u003d 0) {\n               totalBytesRead +\u003d bytesRead;\n             }\n           }\n         }\n       } catch (IOException ex) {\n         LOG.error(\"UnexpectedError: \", ex);\n         throw ex;\n       } finally {\n         if (this.isTraceEnabled) {\n           this.recvResponseTimeMs +\u003d elapsedTimeMs(startTime);\n         }\n         this.bytesReceived \u003d totalBytesRead;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void processResponse(final byte[] buffer, final int offset, final int length) throws IOException {\n\n    // get the response\n    long startTime \u003d 0;\n    if (this.isTraceEnabled) {\n      startTime \u003d System.nanoTime();\n    }\n\n    this.statusCode \u003d this.connection.getResponseCode();\n\n    if (this.isTraceEnabled) {\n      this.recvResponseTimeMs \u003d elapsedTimeMs(startTime);\n    }\n\n    this.statusDescription \u003d this.connection.getResponseMessage();\n\n    this.requestId \u003d this.connection.getHeaderField(HttpHeaderConfigurations.X_MS_REQUEST_ID);\n    if (this.requestId \u003d\u003d null) {\n      this.requestId \u003d AbfsHttpConstants.EMPTY_STRING;\n    }\n    // dump the headers\n    AbfsIoUtils.dumpHeadersToDebugLog(\"Response Headers\",\n        connection.getHeaderFields());\n\n    if (AbfsHttpConstants.HTTP_METHOD_HEAD.equals(this.method)) {\n      // If it is HEAD, and it is ERROR\n      return;\n    }\n\n    if (this.isTraceEnabled) {\n      startTime \u003d System.nanoTime();\n    }\n\n    if (statusCode \u003e\u003d HttpURLConnection.HTTP_BAD_REQUEST) {\n      processStorageErrorResponse();\n      if (this.isTraceEnabled) {\n        this.recvResponseTimeMs +\u003d elapsedTimeMs(startTime);\n      }\n      this.bytesReceived \u003d this.connection.getHeaderFieldLong(HttpHeaderConfigurations.CONTENT_LENGTH, 0);\n    } else {\n      // consume the input stream to release resources\n      int totalBytesRead \u003d 0;\n\n      try (InputStream stream \u003d this.connection.getInputStream()) {\n        if (isNullInputStream(stream)) {\n          return;\n        }\n        boolean endOfStream \u003d false;\n\n        // this is a list operation and need to retrieve the data\n        // need a better solution\n        if (AbfsHttpConstants.HTTP_METHOD_GET.equals(this.method) \u0026\u0026 buffer \u003d\u003d null) {\n          parseListFilesResponse(stream);\n        } else {\n          if (buffer !\u003d null) {\n            while (totalBytesRead \u003c length) {\n              int bytesRead \u003d stream.read(buffer, offset + totalBytesRead, length - totalBytesRead);\n              if (bytesRead \u003d\u003d -1) {\n                endOfStream \u003d true;\n                break;\n              }\n              totalBytesRead +\u003d bytesRead;\n            }\n          }\n          if (!endOfStream \u0026\u0026 stream.read() !\u003d -1) {\n            // read and discard\n            int bytesRead \u003d 0;\n            byte[] b \u003d new byte[CLEAN_UP_BUFFER_SIZE];\n            while ((bytesRead \u003d stream.read(b)) \u003e\u003d 0) {\n              totalBytesRead +\u003d bytesRead;\n            }\n          }\n        }\n      } catch (IOException ex) {\n        LOG.error(\"UnexpectedError: \", ex);\n        throw ex;\n      } finally {\n        if (this.isTraceEnabled) {\n          this.recvResponseTimeMs +\u003d elapsedTimeMs(startTime);\n        }\n        this.bytesReceived \u003d totalBytesRead;\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsHttpOperation.java",
      "extendedDetails": {}
    },
    "b54b0c1b676c616aef9574e4e88ea30c314c79dc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15659. Code changes for bug fix and new tests.\nContributed by Da Zhou.\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "b54b0c1b676c616aef9574e4e88ea30c314c79dc",
      "commitAuthor": "Thomas Marquardt",
      "commitDateOld": "17/09/18 12:54 PM",
      "commitNameOld": "ce03a93f78c4d97ccb48a3906fcd77ad0ac756be",
      "commitAuthorOld": "Thomas Marquardt",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,81 @@\n   public void processResponse(final byte[] buffer, final int offset, final int length) throws IOException {\n \n     // get the response\n     long startTime \u003d 0;\n     if (this.isTraceEnabled) {\n       startTime \u003d System.nanoTime();\n     }\n \n     this.statusCode \u003d this.connection.getResponseCode();\n \n     if (this.isTraceEnabled) {\n       this.recvResponseTimeMs \u003d elapsedTimeMs(startTime);\n     }\n \n     this.statusDescription \u003d this.connection.getResponseMessage();\n \n     this.requestId \u003d this.connection.getHeaderField(HttpHeaderConfigurations.X_MS_REQUEST_ID);\n     if (this.requestId \u003d\u003d null) {\n       this.requestId \u003d AbfsHttpConstants.EMPTY_STRING;\n     }\n \n     if (AbfsHttpConstants.HTTP_METHOD_HEAD.equals(this.method)) {\n       // If it is HEAD, and it is ERROR\n       return;\n     }\n \n     if (this.isTraceEnabled) {\n       startTime \u003d System.nanoTime();\n     }\n \n     if (statusCode \u003e\u003d HttpURLConnection.HTTP_BAD_REQUEST) {\n       processStorageErrorResponse();\n       if (this.isTraceEnabled) {\n         this.recvResponseTimeMs +\u003d elapsedTimeMs(startTime);\n       }\n       this.bytesReceived \u003d this.connection.getHeaderFieldLong(HttpHeaderConfigurations.CONTENT_LENGTH, 0);\n     } else {\n       // consume the input stream to release resources\n       int totalBytesRead \u003d 0;\n \n       try (InputStream stream \u003d this.connection.getInputStream()) {\n         if (isNullInputStream(stream)) {\n           return;\n         }\n         boolean endOfStream \u003d false;\n \n         // this is a list operation and need to retrieve the data\n         // need a better solution\n         if (AbfsHttpConstants.HTTP_METHOD_GET.equals(this.method) \u0026\u0026 buffer \u003d\u003d null) {\n           parseListFilesResponse(stream);\n         } else {\n           if (buffer !\u003d null) {\n             while (totalBytesRead \u003c length) {\n               int bytesRead \u003d stream.read(buffer, offset + totalBytesRead, length - totalBytesRead);\n               if (bytesRead \u003d\u003d -1) {\n                 endOfStream \u003d true;\n                 break;\n               }\n               totalBytesRead +\u003d bytesRead;\n             }\n           }\n           if (!endOfStream \u0026\u0026 stream.read() !\u003d -1) {\n             // read and discard\n             int bytesRead \u003d 0;\n             byte[] b \u003d new byte[CLEAN_UP_BUFFER_SIZE];\n             while ((bytesRead \u003d stream.read(b)) \u003e\u003d 0) {\n               totalBytesRead +\u003d bytesRead;\n             }\n           }\n         }\n       } catch (IOException ex) {\n-        this.LOG.error(\"UnexpectedError: \", ex);\n+        LOG.error(\"UnexpectedError: \", ex);\n         throw ex;\n       } finally {\n         if (this.isTraceEnabled) {\n           this.recvResponseTimeMs +\u003d elapsedTimeMs(startTime);\n         }\n         this.bytesReceived \u003d totalBytesRead;\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void processResponse(final byte[] buffer, final int offset, final int length) throws IOException {\n\n    // get the response\n    long startTime \u003d 0;\n    if (this.isTraceEnabled) {\n      startTime \u003d System.nanoTime();\n    }\n\n    this.statusCode \u003d this.connection.getResponseCode();\n\n    if (this.isTraceEnabled) {\n      this.recvResponseTimeMs \u003d elapsedTimeMs(startTime);\n    }\n\n    this.statusDescription \u003d this.connection.getResponseMessage();\n\n    this.requestId \u003d this.connection.getHeaderField(HttpHeaderConfigurations.X_MS_REQUEST_ID);\n    if (this.requestId \u003d\u003d null) {\n      this.requestId \u003d AbfsHttpConstants.EMPTY_STRING;\n    }\n\n    if (AbfsHttpConstants.HTTP_METHOD_HEAD.equals(this.method)) {\n      // If it is HEAD, and it is ERROR\n      return;\n    }\n\n    if (this.isTraceEnabled) {\n      startTime \u003d System.nanoTime();\n    }\n\n    if (statusCode \u003e\u003d HttpURLConnection.HTTP_BAD_REQUEST) {\n      processStorageErrorResponse();\n      if (this.isTraceEnabled) {\n        this.recvResponseTimeMs +\u003d elapsedTimeMs(startTime);\n      }\n      this.bytesReceived \u003d this.connection.getHeaderFieldLong(HttpHeaderConfigurations.CONTENT_LENGTH, 0);\n    } else {\n      // consume the input stream to release resources\n      int totalBytesRead \u003d 0;\n\n      try (InputStream stream \u003d this.connection.getInputStream()) {\n        if (isNullInputStream(stream)) {\n          return;\n        }\n        boolean endOfStream \u003d false;\n\n        // this is a list operation and need to retrieve the data\n        // need a better solution\n        if (AbfsHttpConstants.HTTP_METHOD_GET.equals(this.method) \u0026\u0026 buffer \u003d\u003d null) {\n          parseListFilesResponse(stream);\n        } else {\n          if (buffer !\u003d null) {\n            while (totalBytesRead \u003c length) {\n              int bytesRead \u003d stream.read(buffer, offset + totalBytesRead, length - totalBytesRead);\n              if (bytesRead \u003d\u003d -1) {\n                endOfStream \u003d true;\n                break;\n              }\n              totalBytesRead +\u003d bytesRead;\n            }\n          }\n          if (!endOfStream \u0026\u0026 stream.read() !\u003d -1) {\n            // read and discard\n            int bytesRead \u003d 0;\n            byte[] b \u003d new byte[CLEAN_UP_BUFFER_SIZE];\n            while ((bytesRead \u003d stream.read(b)) \u003e\u003d 0) {\n              totalBytesRead +\u003d bytesRead;\n            }\n          }\n        }\n      } catch (IOException ex) {\n        LOG.error(\"UnexpectedError: \", ex);\n        throw ex;\n      } finally {\n        if (this.isTraceEnabled) {\n          this.recvResponseTimeMs +\u003d elapsedTimeMs(startTime);\n        }\n        this.bytesReceived \u003d totalBytesRead;\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsHttpOperation.java",
      "extendedDetails": {}
    },
    "f044deedbbfee0812316d587139cb828f27172e9": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15407. HADOOP-15540. Support Windows Azure Storage - Blob file system \"ABFS\" in Hadoop: Core Commit.\n\nContributed by Shane Mainali, Thomas Marquardt, Zichen Sun, Georgi Chalakov, Esfandiar Manii, Amit Singh, Dana Kaban, Da Zhou, Junhua Gu, Saher Ahwal, Saurabh Pant, James Baker, Shaoyu Zhang, Lawrence Chen, Kevin Chen and Steve Loughran\n",
      "commitDate": "17/09/18 12:54 PM",
      "commitName": "f044deedbbfee0812316d587139cb828f27172e9",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,81 @@\n+  public void processResponse(final byte[] buffer, final int offset, final int length) throws IOException {\n+\n+    // get the response\n+    long startTime \u003d 0;\n+    if (this.isTraceEnabled) {\n+      startTime \u003d System.nanoTime();\n+    }\n+\n+    this.statusCode \u003d this.connection.getResponseCode();\n+\n+    if (this.isTraceEnabled) {\n+      this.recvResponseTimeMs \u003d elapsedTimeMs(startTime);\n+    }\n+\n+    this.statusDescription \u003d this.connection.getResponseMessage();\n+\n+    this.requestId \u003d this.connection.getHeaderField(HttpHeaderConfigurations.X_MS_REQUEST_ID);\n+    if (this.requestId \u003d\u003d null) {\n+      this.requestId \u003d AbfsHttpConstants.EMPTY_STRING;\n+    }\n+\n+    if (AbfsHttpConstants.HTTP_METHOD_HEAD.equals(this.method)) {\n+      // If it is HEAD, and it is ERROR\n+      return;\n+    }\n+\n+    if (this.isTraceEnabled) {\n+      startTime \u003d System.nanoTime();\n+    }\n+\n+    if (statusCode \u003e\u003d HttpURLConnection.HTTP_BAD_REQUEST) {\n+      processStorageErrorResponse();\n+      if (this.isTraceEnabled) {\n+        this.recvResponseTimeMs +\u003d elapsedTimeMs(startTime);\n+      }\n+      this.bytesReceived \u003d this.connection.getHeaderFieldLong(HttpHeaderConfigurations.CONTENT_LENGTH, 0);\n+    } else {\n+      // consume the input stream to release resources\n+      int totalBytesRead \u003d 0;\n+\n+      try (InputStream stream \u003d this.connection.getInputStream()) {\n+        if (isNullInputStream(stream)) {\n+          return;\n+        }\n+        boolean endOfStream \u003d false;\n+\n+        // this is a list operation and need to retrieve the data\n+        // need a better solution\n+        if (AbfsHttpConstants.HTTP_METHOD_GET.equals(this.method) \u0026\u0026 buffer \u003d\u003d null) {\n+          parseListFilesResponse(stream);\n+        } else {\n+          if (buffer !\u003d null) {\n+            while (totalBytesRead \u003c length) {\n+              int bytesRead \u003d stream.read(buffer, offset + totalBytesRead, length - totalBytesRead);\n+              if (bytesRead \u003d\u003d -1) {\n+                endOfStream \u003d true;\n+                break;\n+              }\n+              totalBytesRead +\u003d bytesRead;\n+            }\n+          }\n+          if (!endOfStream \u0026\u0026 stream.read() !\u003d -1) {\n+            // read and discard\n+            int bytesRead \u003d 0;\n+            byte[] b \u003d new byte[CLEAN_UP_BUFFER_SIZE];\n+            while ((bytesRead \u003d stream.read(b)) \u003e\u003d 0) {\n+              totalBytesRead +\u003d bytesRead;\n+            }\n+          }\n+        }\n+      } catch (IOException ex) {\n+        this.LOG.error(\"UnexpectedError: \", ex);\n+        throw ex;\n+      } finally {\n+        if (this.isTraceEnabled) {\n+          this.recvResponseTimeMs +\u003d elapsedTimeMs(startTime);\n+        }\n+        this.bytesReceived \u003d totalBytesRead;\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void processResponse(final byte[] buffer, final int offset, final int length) throws IOException {\n\n    // get the response\n    long startTime \u003d 0;\n    if (this.isTraceEnabled) {\n      startTime \u003d System.nanoTime();\n    }\n\n    this.statusCode \u003d this.connection.getResponseCode();\n\n    if (this.isTraceEnabled) {\n      this.recvResponseTimeMs \u003d elapsedTimeMs(startTime);\n    }\n\n    this.statusDescription \u003d this.connection.getResponseMessage();\n\n    this.requestId \u003d this.connection.getHeaderField(HttpHeaderConfigurations.X_MS_REQUEST_ID);\n    if (this.requestId \u003d\u003d null) {\n      this.requestId \u003d AbfsHttpConstants.EMPTY_STRING;\n    }\n\n    if (AbfsHttpConstants.HTTP_METHOD_HEAD.equals(this.method)) {\n      // If it is HEAD, and it is ERROR\n      return;\n    }\n\n    if (this.isTraceEnabled) {\n      startTime \u003d System.nanoTime();\n    }\n\n    if (statusCode \u003e\u003d HttpURLConnection.HTTP_BAD_REQUEST) {\n      processStorageErrorResponse();\n      if (this.isTraceEnabled) {\n        this.recvResponseTimeMs +\u003d elapsedTimeMs(startTime);\n      }\n      this.bytesReceived \u003d this.connection.getHeaderFieldLong(HttpHeaderConfigurations.CONTENT_LENGTH, 0);\n    } else {\n      // consume the input stream to release resources\n      int totalBytesRead \u003d 0;\n\n      try (InputStream stream \u003d this.connection.getInputStream()) {\n        if (isNullInputStream(stream)) {\n          return;\n        }\n        boolean endOfStream \u003d false;\n\n        // this is a list operation and need to retrieve the data\n        // need a better solution\n        if (AbfsHttpConstants.HTTP_METHOD_GET.equals(this.method) \u0026\u0026 buffer \u003d\u003d null) {\n          parseListFilesResponse(stream);\n        } else {\n          if (buffer !\u003d null) {\n            while (totalBytesRead \u003c length) {\n              int bytesRead \u003d stream.read(buffer, offset + totalBytesRead, length - totalBytesRead);\n              if (bytesRead \u003d\u003d -1) {\n                endOfStream \u003d true;\n                break;\n              }\n              totalBytesRead +\u003d bytesRead;\n            }\n          }\n          if (!endOfStream \u0026\u0026 stream.read() !\u003d -1) {\n            // read and discard\n            int bytesRead \u003d 0;\n            byte[] b \u003d new byte[CLEAN_UP_BUFFER_SIZE];\n            while ((bytesRead \u003d stream.read(b)) \u003e\u003d 0) {\n              totalBytesRead +\u003d bytesRead;\n            }\n          }\n        }\n      } catch (IOException ex) {\n        this.LOG.error(\"UnexpectedError: \", ex);\n        throw ex;\n      } finally {\n        if (this.isTraceEnabled) {\n          this.recvResponseTimeMs +\u003d elapsedTimeMs(startTime);\n        }\n        this.bytesReceived \u003d totalBytesRead;\n      }\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsHttpOperation.java"
    }
  }
}