{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DistributedOpportunisticContainerAllocator.java",
  "functionName": "allocateContainers",
  "functionId": "allocateContainers___blackList-ResourceBlacklistRequest__oppResourceReqs-List__ResourceRequest____applicationAttemptId-ApplicationAttemptId__opportContext-OpportunisticContainerContext__rmIdentifier-long__appSubmitter-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/DistributedOpportunisticContainerAllocator.java",
  "functionStartLine": 85,
  "functionEndLine": 138,
  "numCommitsSeen": 27,
  "timeTaken": 6102,
  "changeHistory": [
    "4d3c580b03475a6ec9323d11e6875c542f8e3f6d",
    "96e3027e46a953ca995e4b44ef50bc2a30c7e838",
    "aeadb9432f84e679f00a9a12f63675c456bc14a8",
    "b733348dde18a242e6c9074c512116a8baf1d281",
    "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
    "283fa33febe043bd7b4fa87546be26c9c5a8f8b5",
    "10be45986cdf86a89055065b752959bd6369d54f",
    "82c9e061017c32e633e0b0cbb7978749a6df4fb2"
  ],
  "changeHistoryShort": {
    "4d3c580b03475a6ec9323d11e6875c542f8e3f6d": "Ymultichange(Ymovefromfile,Ybodychange)",
    "96e3027e46a953ca995e4b44ef50bc2a30c7e838": "Ybodychange",
    "aeadb9432f84e679f00a9a12f63675c456bc14a8": "Ybodychange",
    "b733348dde18a242e6c9074c512116a8baf1d281": "Ybodychange",
    "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8": "Ymultichange(Yparameterchange,Ybodychange)",
    "283fa33febe043bd7b4fa87546be26c9c5a8f8b5": "Ymultichange(Yparameterchange,Ybodychange)",
    "10be45986cdf86a89055065b752959bd6369d54f": "Ybodychange",
    "82c9e061017c32e633e0b0cbb7978749a6df4fb2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4d3c580b03475a6ec9323d11e6875c542f8e3f6d": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "YARN-9859. Refactoring of OpportunisticContainerAllocator. Contributed by Abhishek Modi.\n",
      "commitDate": "30/09/19 11:10 AM",
      "commitName": "4d3c580b03475a6ec9323d11e6875c542f8e3f6d",
      "commitAuthor": "Abhishek Modi",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-9859. Refactoring of OpportunisticContainerAllocator. Contributed by Abhishek Modi.\n",
          "commitDate": "30/09/19 11:10 AM",
          "commitName": "4d3c580b03475a6ec9323d11e6875c542f8e3f6d",
          "commitAuthor": "Abhishek Modi",
          "commitDateOld": "30/09/19 8:06 AM",
          "commitNameOld": "98ca07ebed2ae3d7e41e5029b5bba6d089d41d43",
          "commitAuthorOld": "bshashikant",
          "daysBetweenCommits": 0.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,64 +1,54 @@\n   public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n       List\u003cResourceRequest\u003e oppResourceReqs,\n       ApplicationAttemptId applicationAttemptId,\n       OpportunisticContainerContext opportContext, long rmIdentifier,\n       String appSubmitter) throws YarnException {\n \n     // Update black list.\n-    if (blackList !\u003d null) {\n-      opportContext.getBlacklist().removeAll(blackList.getBlacklistRemovals());\n-      opportContext.getBlacklist().addAll(blackList.getBlacklistAdditions());\n-    }\n+    updateBlacklist(blackList, opportContext);\n \n     // Add OPPORTUNISTIC requests to the outstanding ones.\n     opportContext.addToOutstandingReqs(oppResourceReqs);\n     Set\u003cString\u003e nodeBlackList \u003d new HashSet\u003c\u003e(opportContext.getBlacklist());\n     Set\u003cString\u003e allocatedNodes \u003d new HashSet\u003c\u003e();\n     List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n \n     // Satisfy the outstanding OPPORTUNISTIC requests.\n     boolean continueLoop \u003d true;\n     while (continueLoop) {\n       continueLoop \u003d false;\n       List\u003cMap\u003cResource, List\u003cAllocation\u003e\u003e\u003e allocations \u003d new ArrayList\u003c\u003e();\n       for (SchedulerRequestKey schedulerKey :\n           opportContext.getOutstandingOpReqs().descendingKeySet()) {\n         // Allocated containers :\n         //  Key \u003d Requested Capability,\n         //  Value \u003d List of Containers of given cap (the actual container size\n         //          might be different than what is requested, which is why\n         //          we need the requested capability (key) to match against\n         //          the outstanding reqs)\n         int remAllocs \u003d -1;\n+        int maxAllocationsPerAMHeartbeat \u003d getMaxAllocationsPerAMHeartbeat();\n         if (maxAllocationsPerAMHeartbeat \u003e 0) {\n           remAllocs \u003d\n               maxAllocationsPerAMHeartbeat - allocatedContainers.size()\n                   - getTotalAllocations(allocations);\n           if (remAllocs \u003c\u003d 0) {\n             LOG.info(\"Not allocating more containers as we have reached max \"\n                     + \"allocations per AM heartbeat {}\",\n                 maxAllocationsPerAMHeartbeat);\n             break;\n           }\n         }\n         Map\u003cResource, List\u003cAllocation\u003e\u003e allocation \u003d allocate(\n             rmIdentifier, opportContext, schedulerKey, applicationAttemptId,\n             appSubmitter, nodeBlackList, allocatedNodes, remAllocs);\n         if (allocation.size() \u003e 0) {\n           allocations.add(allocation);\n           continueLoop \u003d true;\n         }\n       }\n-      for (Map\u003cResource, List\u003cAllocation\u003e\u003e allocation : allocations) {\n-        for (Map.Entry\u003cResource, List\u003cAllocation\u003e\u003e e : allocation.entrySet()) {\n-          opportContext.matchAllocationToOutstandingRequest(\n-              e.getKey(), e.getValue());\n-          for (Allocation alloc : e.getValue()) {\n-            allocatedContainers.add(alloc.getContainer());\n-          }\n-        }\n-      }\n+      matchAllocation(allocations, allocatedContainers, opportContext);\n     }\n \n     return allocatedContainers;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n      List\u003cResourceRequest\u003e oppResourceReqs,\n      ApplicationAttemptId applicationAttemptId,\n      OpportunisticContainerContext opportContext, long rmIdentifier,\n      String appSubmitter) throws YarnException {\n\n    // Update black list.\n    updateBlacklist(blackList, opportContext);\n\n    // Add OPPORTUNISTIC requests to the outstanding ones.\n    opportContext.addToOutstandingReqs(oppResourceReqs);\n    Set\u003cString\u003e nodeBlackList \u003d new HashSet\u003c\u003e(opportContext.getBlacklist());\n    Set\u003cString\u003e allocatedNodes \u003d new HashSet\u003c\u003e();\n    List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n\n    // Satisfy the outstanding OPPORTUNISTIC requests.\n    boolean continueLoop \u003d true;\n    while (continueLoop) {\n      continueLoop \u003d false;\n      List\u003cMap\u003cResource, List\u003cAllocation\u003e\u003e\u003e allocations \u003d new ArrayList\u003c\u003e();\n      for (SchedulerRequestKey schedulerKey :\n          opportContext.getOutstandingOpReqs().descendingKeySet()) {\n        // Allocated containers :\n        //  Key \u003d Requested Capability,\n        //  Value \u003d List of Containers of given cap (the actual container size\n        //          might be different than what is requested, which is why\n        //          we need the requested capability (key) to match against\n        //          the outstanding reqs)\n        int remAllocs \u003d -1;\n        int maxAllocationsPerAMHeartbeat \u003d getMaxAllocationsPerAMHeartbeat();\n        if (maxAllocationsPerAMHeartbeat \u003e 0) {\n          remAllocs \u003d\n              maxAllocationsPerAMHeartbeat - allocatedContainers.size()\n                  - getTotalAllocations(allocations);\n          if (remAllocs \u003c\u003d 0) {\n            LOG.info(\"Not allocating more containers as we have reached max \"\n                    + \"allocations per AM heartbeat {}\",\n                maxAllocationsPerAMHeartbeat);\n            break;\n          }\n        }\n        Map\u003cResource, List\u003cAllocation\u003e\u003e allocation \u003d allocate(\n            rmIdentifier, opportContext, schedulerKey, applicationAttemptId,\n            appSubmitter, nodeBlackList, allocatedNodes, remAllocs);\n        if (allocation.size() \u003e 0) {\n          allocations.add(allocation);\n          continueLoop \u003d true;\n        }\n      }\n      matchAllocation(allocations, allocatedContainers, opportContext);\n    }\n\n    return allocatedContainers;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/DistributedOpportunisticContainerAllocator.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/OpportunisticContainerAllocator.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/DistributedOpportunisticContainerAllocator.java",
            "oldMethodName": "allocateContainers",
            "newMethodName": "allocateContainers"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-9859. Refactoring of OpportunisticContainerAllocator. Contributed by Abhishek Modi.\n",
          "commitDate": "30/09/19 11:10 AM",
          "commitName": "4d3c580b03475a6ec9323d11e6875c542f8e3f6d",
          "commitAuthor": "Abhishek Modi",
          "commitDateOld": "30/09/19 8:06 AM",
          "commitNameOld": "98ca07ebed2ae3d7e41e5029b5bba6d089d41d43",
          "commitAuthorOld": "bshashikant",
          "daysBetweenCommits": 0.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,64 +1,54 @@\n   public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n       List\u003cResourceRequest\u003e oppResourceReqs,\n       ApplicationAttemptId applicationAttemptId,\n       OpportunisticContainerContext opportContext, long rmIdentifier,\n       String appSubmitter) throws YarnException {\n \n     // Update black list.\n-    if (blackList !\u003d null) {\n-      opportContext.getBlacklist().removeAll(blackList.getBlacklistRemovals());\n-      opportContext.getBlacklist().addAll(blackList.getBlacklistAdditions());\n-    }\n+    updateBlacklist(blackList, opportContext);\n \n     // Add OPPORTUNISTIC requests to the outstanding ones.\n     opportContext.addToOutstandingReqs(oppResourceReqs);\n     Set\u003cString\u003e nodeBlackList \u003d new HashSet\u003c\u003e(opportContext.getBlacklist());\n     Set\u003cString\u003e allocatedNodes \u003d new HashSet\u003c\u003e();\n     List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n \n     // Satisfy the outstanding OPPORTUNISTIC requests.\n     boolean continueLoop \u003d true;\n     while (continueLoop) {\n       continueLoop \u003d false;\n       List\u003cMap\u003cResource, List\u003cAllocation\u003e\u003e\u003e allocations \u003d new ArrayList\u003c\u003e();\n       for (SchedulerRequestKey schedulerKey :\n           opportContext.getOutstandingOpReqs().descendingKeySet()) {\n         // Allocated containers :\n         //  Key \u003d Requested Capability,\n         //  Value \u003d List of Containers of given cap (the actual container size\n         //          might be different than what is requested, which is why\n         //          we need the requested capability (key) to match against\n         //          the outstanding reqs)\n         int remAllocs \u003d -1;\n+        int maxAllocationsPerAMHeartbeat \u003d getMaxAllocationsPerAMHeartbeat();\n         if (maxAllocationsPerAMHeartbeat \u003e 0) {\n           remAllocs \u003d\n               maxAllocationsPerAMHeartbeat - allocatedContainers.size()\n                   - getTotalAllocations(allocations);\n           if (remAllocs \u003c\u003d 0) {\n             LOG.info(\"Not allocating more containers as we have reached max \"\n                     + \"allocations per AM heartbeat {}\",\n                 maxAllocationsPerAMHeartbeat);\n             break;\n           }\n         }\n         Map\u003cResource, List\u003cAllocation\u003e\u003e allocation \u003d allocate(\n             rmIdentifier, opportContext, schedulerKey, applicationAttemptId,\n             appSubmitter, nodeBlackList, allocatedNodes, remAllocs);\n         if (allocation.size() \u003e 0) {\n           allocations.add(allocation);\n           continueLoop \u003d true;\n         }\n       }\n-      for (Map\u003cResource, List\u003cAllocation\u003e\u003e allocation : allocations) {\n-        for (Map.Entry\u003cResource, List\u003cAllocation\u003e\u003e e : allocation.entrySet()) {\n-          opportContext.matchAllocationToOutstandingRequest(\n-              e.getKey(), e.getValue());\n-          for (Allocation alloc : e.getValue()) {\n-            allocatedContainers.add(alloc.getContainer());\n-          }\n-        }\n-      }\n+      matchAllocation(allocations, allocatedContainers, opportContext);\n     }\n \n     return allocatedContainers;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n      List\u003cResourceRequest\u003e oppResourceReqs,\n      ApplicationAttemptId applicationAttemptId,\n      OpportunisticContainerContext opportContext, long rmIdentifier,\n      String appSubmitter) throws YarnException {\n\n    // Update black list.\n    updateBlacklist(blackList, opportContext);\n\n    // Add OPPORTUNISTIC requests to the outstanding ones.\n    opportContext.addToOutstandingReqs(oppResourceReqs);\n    Set\u003cString\u003e nodeBlackList \u003d new HashSet\u003c\u003e(opportContext.getBlacklist());\n    Set\u003cString\u003e allocatedNodes \u003d new HashSet\u003c\u003e();\n    List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n\n    // Satisfy the outstanding OPPORTUNISTIC requests.\n    boolean continueLoop \u003d true;\n    while (continueLoop) {\n      continueLoop \u003d false;\n      List\u003cMap\u003cResource, List\u003cAllocation\u003e\u003e\u003e allocations \u003d new ArrayList\u003c\u003e();\n      for (SchedulerRequestKey schedulerKey :\n          opportContext.getOutstandingOpReqs().descendingKeySet()) {\n        // Allocated containers :\n        //  Key \u003d Requested Capability,\n        //  Value \u003d List of Containers of given cap (the actual container size\n        //          might be different than what is requested, which is why\n        //          we need the requested capability (key) to match against\n        //          the outstanding reqs)\n        int remAllocs \u003d -1;\n        int maxAllocationsPerAMHeartbeat \u003d getMaxAllocationsPerAMHeartbeat();\n        if (maxAllocationsPerAMHeartbeat \u003e 0) {\n          remAllocs \u003d\n              maxAllocationsPerAMHeartbeat - allocatedContainers.size()\n                  - getTotalAllocations(allocations);\n          if (remAllocs \u003c\u003d 0) {\n            LOG.info(\"Not allocating more containers as we have reached max \"\n                    + \"allocations per AM heartbeat {}\",\n                maxAllocationsPerAMHeartbeat);\n            break;\n          }\n        }\n        Map\u003cResource, List\u003cAllocation\u003e\u003e allocation \u003d allocate(\n            rmIdentifier, opportContext, schedulerKey, applicationAttemptId,\n            appSubmitter, nodeBlackList, allocatedNodes, remAllocs);\n        if (allocation.size() \u003e 0) {\n          allocations.add(allocation);\n          continueLoop \u003d true;\n        }\n      }\n      matchAllocation(allocations, allocatedContainers, opportContext);\n    }\n\n    return allocatedContainers;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/DistributedOpportunisticContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "96e3027e46a953ca995e4b44ef50bc2a30c7e838": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2889. Limit the number of opportunistic container allocated per AM heartbeat. Contributed by Abhishek Modi.\n",
      "commitDate": "22/04/19 9:49 AM",
      "commitName": "96e3027e46a953ca995e4b44ef50bc2a30c7e838",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "19/04/19 9:41 AM",
      "commitNameOld": "aeadb9432f84e679f00a9a12f63675c456bc14a8",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 3.01,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,64 @@\n   public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n       List\u003cResourceRequest\u003e oppResourceReqs,\n       ApplicationAttemptId applicationAttemptId,\n       OpportunisticContainerContext opportContext, long rmIdentifier,\n       String appSubmitter) throws YarnException {\n \n     // Update black list.\n     if (blackList !\u003d null) {\n       opportContext.getBlacklist().removeAll(blackList.getBlacklistRemovals());\n       opportContext.getBlacklist().addAll(blackList.getBlacklistAdditions());\n     }\n \n     // Add OPPORTUNISTIC requests to the outstanding ones.\n     opportContext.addToOutstandingReqs(oppResourceReqs);\n-\n     Set\u003cString\u003e nodeBlackList \u003d new HashSet\u003c\u003e(opportContext.getBlacklist());\n     Set\u003cString\u003e allocatedNodes \u003d new HashSet\u003c\u003e();\n     List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n \n     // Satisfy the outstanding OPPORTUNISTIC requests.\n     boolean continueLoop \u003d true;\n     while (continueLoop) {\n       continueLoop \u003d false;\n       List\u003cMap\u003cResource, List\u003cAllocation\u003e\u003e\u003e allocations \u003d new ArrayList\u003c\u003e();\n       for (SchedulerRequestKey schedulerKey :\n           opportContext.getOutstandingOpReqs().descendingKeySet()) {\n         // Allocated containers :\n         //  Key \u003d Requested Capability,\n         //  Value \u003d List of Containers of given cap (the actual container size\n         //          might be different than what is requested, which is why\n         //          we need the requested capability (key) to match against\n         //          the outstanding reqs)\n+        int remAllocs \u003d -1;\n+        if (maxAllocationsPerAMHeartbeat \u003e 0) {\n+          remAllocs \u003d\n+              maxAllocationsPerAMHeartbeat - allocatedContainers.size()\n+                  - getTotalAllocations(allocations);\n+          if (remAllocs \u003c\u003d 0) {\n+            LOG.info(\"Not allocating more containers as we have reached max \"\n+                    + \"allocations per AM heartbeat {}\",\n+                maxAllocationsPerAMHeartbeat);\n+            break;\n+          }\n+        }\n         Map\u003cResource, List\u003cAllocation\u003e\u003e allocation \u003d allocate(\n             rmIdentifier, opportContext, schedulerKey, applicationAttemptId,\n-            appSubmitter, nodeBlackList, allocatedNodes);\n+            appSubmitter, nodeBlackList, allocatedNodes, remAllocs);\n         if (allocation.size() \u003e 0) {\n           allocations.add(allocation);\n           continueLoop \u003d true;\n         }\n       }\n       for (Map\u003cResource, List\u003cAllocation\u003e\u003e allocation : allocations) {\n         for (Map.Entry\u003cResource, List\u003cAllocation\u003e\u003e e : allocation.entrySet()) {\n           opportContext.matchAllocationToOutstandingRequest(\n               e.getKey(), e.getValue());\n           for (Allocation alloc : e.getValue()) {\n             allocatedContainers.add(alloc.getContainer());\n           }\n         }\n       }\n     }\n \n     return allocatedContainers;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n      List\u003cResourceRequest\u003e oppResourceReqs,\n      ApplicationAttemptId applicationAttemptId,\n      OpportunisticContainerContext opportContext, long rmIdentifier,\n      String appSubmitter) throws YarnException {\n\n    // Update black list.\n    if (blackList !\u003d null) {\n      opportContext.getBlacklist().removeAll(blackList.getBlacklistRemovals());\n      opportContext.getBlacklist().addAll(blackList.getBlacklistAdditions());\n    }\n\n    // Add OPPORTUNISTIC requests to the outstanding ones.\n    opportContext.addToOutstandingReqs(oppResourceReqs);\n    Set\u003cString\u003e nodeBlackList \u003d new HashSet\u003c\u003e(opportContext.getBlacklist());\n    Set\u003cString\u003e allocatedNodes \u003d new HashSet\u003c\u003e();\n    List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n\n    // Satisfy the outstanding OPPORTUNISTIC requests.\n    boolean continueLoop \u003d true;\n    while (continueLoop) {\n      continueLoop \u003d false;\n      List\u003cMap\u003cResource, List\u003cAllocation\u003e\u003e\u003e allocations \u003d new ArrayList\u003c\u003e();\n      for (SchedulerRequestKey schedulerKey :\n          opportContext.getOutstandingOpReqs().descendingKeySet()) {\n        // Allocated containers :\n        //  Key \u003d Requested Capability,\n        //  Value \u003d List of Containers of given cap (the actual container size\n        //          might be different than what is requested, which is why\n        //          we need the requested capability (key) to match against\n        //          the outstanding reqs)\n        int remAllocs \u003d -1;\n        if (maxAllocationsPerAMHeartbeat \u003e 0) {\n          remAllocs \u003d\n              maxAllocationsPerAMHeartbeat - allocatedContainers.size()\n                  - getTotalAllocations(allocations);\n          if (remAllocs \u003c\u003d 0) {\n            LOG.info(\"Not allocating more containers as we have reached max \"\n                    + \"allocations per AM heartbeat {}\",\n                maxAllocationsPerAMHeartbeat);\n            break;\n          }\n        }\n        Map\u003cResource, List\u003cAllocation\u003e\u003e allocation \u003d allocate(\n            rmIdentifier, opportContext, schedulerKey, applicationAttemptId,\n            appSubmitter, nodeBlackList, allocatedNodes, remAllocs);\n        if (allocation.size() \u003e 0) {\n          allocations.add(allocation);\n          continueLoop \u003d true;\n        }\n      }\n      for (Map\u003cResource, List\u003cAllocation\u003e\u003e allocation : allocations) {\n        for (Map.Entry\u003cResource, List\u003cAllocation\u003e\u003e e : allocation.entrySet()) {\n          opportContext.matchAllocationToOutstandingRequest(\n              e.getKey(), e.getValue());\n          for (Allocation alloc : e.getValue()) {\n            allocatedContainers.add(alloc.getContainer());\n          }\n        }\n      }\n    }\n\n    return allocatedContainers;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/OpportunisticContainerAllocator.java",
      "extendedDetails": {}
    },
    "aeadb9432f84e679f00a9a12f63675c456bc14a8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9448. Fix Opportunistic Scheduling for node local allocations. Contributed by Abhishek Modi.\n",
      "commitDate": "19/04/19 9:41 AM",
      "commitName": "aeadb9432f84e679f00a9a12f63675c456bc14a8",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "11/04/19 11:49 AM",
      "commitNameOld": "ed3747c1ccc303e206de50c2b74f3c318cb1c416",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 7.91,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,53 @@\n   public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n       List\u003cResourceRequest\u003e oppResourceReqs,\n       ApplicationAttemptId applicationAttemptId,\n       OpportunisticContainerContext opportContext, long rmIdentifier,\n       String appSubmitter) throws YarnException {\n \n     // Update black list.\n     if (blackList !\u003d null) {\n       opportContext.getBlacklist().removeAll(blackList.getBlacklistRemovals());\n       opportContext.getBlacklist().addAll(blackList.getBlacklistAdditions());\n     }\n \n     // Add OPPORTUNISTIC requests to the outstanding ones.\n     opportContext.addToOutstandingReqs(oppResourceReqs);\n \n     Set\u003cString\u003e nodeBlackList \u003d new HashSet\u003c\u003e(opportContext.getBlacklist());\n+    Set\u003cString\u003e allocatedNodes \u003d new HashSet\u003c\u003e();\n     List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n \n     // Satisfy the outstanding OPPORTUNISTIC requests.\n     boolean continueLoop \u003d true;\n     while (continueLoop) {\n       continueLoop \u003d false;\n       List\u003cMap\u003cResource, List\u003cAllocation\u003e\u003e\u003e allocations \u003d new ArrayList\u003c\u003e();\n       for (SchedulerRequestKey schedulerKey :\n           opportContext.getOutstandingOpReqs().descendingKeySet()) {\n         // Allocated containers :\n         //  Key \u003d Requested Capability,\n         //  Value \u003d List of Containers of given cap (the actual container size\n         //          might be different than what is requested, which is why\n         //          we need the requested capability (key) to match against\n         //          the outstanding reqs)\n         Map\u003cResource, List\u003cAllocation\u003e\u003e allocation \u003d allocate(\n             rmIdentifier, opportContext, schedulerKey, applicationAttemptId,\n-            appSubmitter, nodeBlackList);\n+            appSubmitter, nodeBlackList, allocatedNodes);\n         if (allocation.size() \u003e 0) {\n           allocations.add(allocation);\n           continueLoop \u003d true;\n         }\n       }\n       for (Map\u003cResource, List\u003cAllocation\u003e\u003e allocation : allocations) {\n         for (Map.Entry\u003cResource, List\u003cAllocation\u003e\u003e e : allocation.entrySet()) {\n           opportContext.matchAllocationToOutstandingRequest(\n               e.getKey(), e.getValue());\n           for (Allocation alloc : e.getValue()) {\n             allocatedContainers.add(alloc.getContainer());\n           }\n         }\n       }\n     }\n \n     return allocatedContainers;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n      List\u003cResourceRequest\u003e oppResourceReqs,\n      ApplicationAttemptId applicationAttemptId,\n      OpportunisticContainerContext opportContext, long rmIdentifier,\n      String appSubmitter) throws YarnException {\n\n    // Update black list.\n    if (blackList !\u003d null) {\n      opportContext.getBlacklist().removeAll(blackList.getBlacklistRemovals());\n      opportContext.getBlacklist().addAll(blackList.getBlacklistAdditions());\n    }\n\n    // Add OPPORTUNISTIC requests to the outstanding ones.\n    opportContext.addToOutstandingReqs(oppResourceReqs);\n\n    Set\u003cString\u003e nodeBlackList \u003d new HashSet\u003c\u003e(opportContext.getBlacklist());\n    Set\u003cString\u003e allocatedNodes \u003d new HashSet\u003c\u003e();\n    List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n\n    // Satisfy the outstanding OPPORTUNISTIC requests.\n    boolean continueLoop \u003d true;\n    while (continueLoop) {\n      continueLoop \u003d false;\n      List\u003cMap\u003cResource, List\u003cAllocation\u003e\u003e\u003e allocations \u003d new ArrayList\u003c\u003e();\n      for (SchedulerRequestKey schedulerKey :\n          opportContext.getOutstandingOpReqs().descendingKeySet()) {\n        // Allocated containers :\n        //  Key \u003d Requested Capability,\n        //  Value \u003d List of Containers of given cap (the actual container size\n        //          might be different than what is requested, which is why\n        //          we need the requested capability (key) to match against\n        //          the outstanding reqs)\n        Map\u003cResource, List\u003cAllocation\u003e\u003e allocation \u003d allocate(\n            rmIdentifier, opportContext, schedulerKey, applicationAttemptId,\n            appSubmitter, nodeBlackList, allocatedNodes);\n        if (allocation.size() \u003e 0) {\n          allocations.add(allocation);\n          continueLoop \u003d true;\n        }\n      }\n      for (Map\u003cResource, List\u003cAllocation\u003e\u003e allocation : allocations) {\n        for (Map.Entry\u003cResource, List\u003cAllocation\u003e\u003e e : allocation.entrySet()) {\n          opportContext.matchAllocationToOutstandingRequest(\n              e.getKey(), e.getValue());\n          for (Allocation alloc : e.getValue()) {\n            allocatedContainers.add(alloc.getContainer());\n          }\n        }\n      }\n    }\n\n    return allocatedContainers;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/OpportunisticContainerAllocator.java",
      "extendedDetails": {}
    },
    "b733348dde18a242e6c9074c512116a8baf1d281": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7258. Add Node and Rack Hints to Opportunistic Scheduler. (Kartheek Muthyala via asuresh).\n",
      "commitDate": "05/10/17 9:58 AM",
      "commitName": "b733348dde18a242e6c9074c512116a8baf1d281",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "03/10/17 2:06 PM",
      "commitNameOld": "4a877737182808fe3392a116762ba59973a477a6",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 1.83,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,52 @@\n   public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n       List\u003cResourceRequest\u003e oppResourceReqs,\n       ApplicationAttemptId applicationAttemptId,\n       OpportunisticContainerContext opportContext, long rmIdentifier,\n       String appSubmitter) throws YarnException {\n \n     // Update black list.\n     if (blackList !\u003d null) {\n       opportContext.getBlacklist().removeAll(blackList.getBlacklistRemovals());\n       opportContext.getBlacklist().addAll(blackList.getBlacklistAdditions());\n     }\n \n     // Add OPPORTUNISTIC requests to the outstanding ones.\n     opportContext.addToOutstandingReqs(oppResourceReqs);\n \n-    // Satisfy the outstanding OPPORTUNISTIC requests.\n+    Set\u003cString\u003e nodeBlackList \u003d new HashSet\u003c\u003e(opportContext.getBlacklist());\n     List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n-    for (SchedulerRequestKey schedulerKey :\n-        opportContext.getOutstandingOpReqs().descendingKeySet()) {\n-      // Allocated containers :\n-      //  Key \u003d Requested Capability,\n-      //  Value \u003d List of Containers of given cap (the actual container size\n-      //          might be different than what is requested, which is why\n-      //          we need the requested capability (key) to match against\n-      //          the outstanding reqs)\n-      Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n-          opportContext, schedulerKey, applicationAttemptId, appSubmitter);\n-      for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n-        opportContext.matchAllocationToOutstandingRequest(\n-            e.getKey(), e.getValue());\n-        allocatedContainers.addAll(e.getValue());\n+\n+    // Satisfy the outstanding OPPORTUNISTIC requests.\n+    boolean continueLoop \u003d true;\n+    while (continueLoop) {\n+      continueLoop \u003d false;\n+      List\u003cMap\u003cResource, List\u003cAllocation\u003e\u003e\u003e allocations \u003d new ArrayList\u003c\u003e();\n+      for (SchedulerRequestKey schedulerKey :\n+          opportContext.getOutstandingOpReqs().descendingKeySet()) {\n+        // Allocated containers :\n+        //  Key \u003d Requested Capability,\n+        //  Value \u003d List of Containers of given cap (the actual container size\n+        //          might be different than what is requested, which is why\n+        //          we need the requested capability (key) to match against\n+        //          the outstanding reqs)\n+        Map\u003cResource, List\u003cAllocation\u003e\u003e allocation \u003d allocate(\n+            rmIdentifier, opportContext, schedulerKey, applicationAttemptId,\n+            appSubmitter, nodeBlackList);\n+        if (allocation.size() \u003e 0) {\n+          allocations.add(allocation);\n+          continueLoop \u003d true;\n+        }\n+      }\n+      for (Map\u003cResource, List\u003cAllocation\u003e\u003e allocation : allocations) {\n+        for (Map.Entry\u003cResource, List\u003cAllocation\u003e\u003e e : allocation.entrySet()) {\n+          opportContext.matchAllocationToOutstandingRequest(\n+              e.getKey(), e.getValue());\n+          for (Allocation alloc : e.getValue()) {\n+            allocatedContainers.add(alloc.getContainer());\n+          }\n+        }\n       }\n     }\n \n     return allocatedContainers;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n      List\u003cResourceRequest\u003e oppResourceReqs,\n      ApplicationAttemptId applicationAttemptId,\n      OpportunisticContainerContext opportContext, long rmIdentifier,\n      String appSubmitter) throws YarnException {\n\n    // Update black list.\n    if (blackList !\u003d null) {\n      opportContext.getBlacklist().removeAll(blackList.getBlacklistRemovals());\n      opportContext.getBlacklist().addAll(blackList.getBlacklistAdditions());\n    }\n\n    // Add OPPORTUNISTIC requests to the outstanding ones.\n    opportContext.addToOutstandingReqs(oppResourceReqs);\n\n    Set\u003cString\u003e nodeBlackList \u003d new HashSet\u003c\u003e(opportContext.getBlacklist());\n    List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n\n    // Satisfy the outstanding OPPORTUNISTIC requests.\n    boolean continueLoop \u003d true;\n    while (continueLoop) {\n      continueLoop \u003d false;\n      List\u003cMap\u003cResource, List\u003cAllocation\u003e\u003e\u003e allocations \u003d new ArrayList\u003c\u003e();\n      for (SchedulerRequestKey schedulerKey :\n          opportContext.getOutstandingOpReqs().descendingKeySet()) {\n        // Allocated containers :\n        //  Key \u003d Requested Capability,\n        //  Value \u003d List of Containers of given cap (the actual container size\n        //          might be different than what is requested, which is why\n        //          we need the requested capability (key) to match against\n        //          the outstanding reqs)\n        Map\u003cResource, List\u003cAllocation\u003e\u003e allocation \u003d allocate(\n            rmIdentifier, opportContext, schedulerKey, applicationAttemptId,\n            appSubmitter, nodeBlackList);\n        if (allocation.size() \u003e 0) {\n          allocations.add(allocation);\n          continueLoop \u003d true;\n        }\n      }\n      for (Map\u003cResource, List\u003cAllocation\u003e\u003e allocation : allocations) {\n        for (Map.Entry\u003cResource, List\u003cAllocation\u003e\u003e e : allocation.entrySet()) {\n          opportContext.matchAllocationToOutstandingRequest(\n              e.getKey(), e.getValue());\n          for (Allocation alloc : e.getValue()) {\n            allocatedContainers.add(alloc.getContainer());\n          }\n        }\n      }\n    }\n\n    return allocatedContainers;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/OpportunisticContainerAllocator.java",
      "extendedDetails": {}
    },
    "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5938. Refactoring OpportunisticContainerAllocator to use SchedulerRequestKey instead of Priority and other misc fixes (asuresh)\n",
      "commitDate": "27/12/16 12:40 PM",
      "commitName": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5938. Refactoring OpportunisticContainerAllocator to use SchedulerRequestKey instead of Priority and other misc fixes (asuresh)\n",
          "commitDate": "27/12/16 12:40 PM",
          "commitName": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "09/11/16 12:11 AM",
          "commitNameOld": "283fa33febe043bd7b4fa87546be26c9c5a8f8b5",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 48.52,
          "commitsBetweenForRepo": 269,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,36 @@\n-  public List\u003cContainer\u003e allocateContainers(\n-      AllocateRequest request, ApplicationAttemptId applicationAttemptId,\n+  public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n+      List\u003cResourceRequest\u003e oppResourceReqs,\n+      ApplicationAttemptId applicationAttemptId,\n       OpportunisticContainerContext opportContext, long rmIdentifier,\n       String appSubmitter) throws YarnException {\n-    // Update released containers.\n-    List\u003cContainerId\u003e releasedContainers \u003d request.getReleaseList();\n-    int numReleasedContainers \u003d releasedContainers.size();\n-    if (numReleasedContainers \u003e 0) {\n-      LOG.info(\"AttemptID: \" + applicationAttemptId + \" released: \"\n-          + numReleasedContainers);\n-      opportContext.getContainersAllocated().removeAll(releasedContainers);\n-    }\n \n     // Update black list.\n-    ResourceBlacklistRequest rbr \u003d request.getResourceBlacklistRequest();\n-    if (rbr !\u003d null) {\n-      opportContext.getBlacklist().removeAll(rbr.getBlacklistRemovals());\n-      opportContext.getBlacklist().addAll(rbr.getBlacklistAdditions());\n+    if (blackList !\u003d null) {\n+      opportContext.getBlacklist().removeAll(blackList.getBlacklistRemovals());\n+      opportContext.getBlacklist().addAll(blackList.getBlacklistAdditions());\n     }\n \n     // Add OPPORTUNISTIC requests to the outstanding ones.\n-    opportContext.addToOutstandingReqs(request.getAskList());\n+    opportContext.addToOutstandingReqs(oppResourceReqs);\n \n     // Satisfy the outstanding OPPORTUNISTIC requests.\n     List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n-    for (Priority priority :\n+    for (SchedulerRequestKey schedulerKey :\n         opportContext.getOutstandingOpReqs().descendingKeySet()) {\n       // Allocated containers :\n       //  Key \u003d Requested Capability,\n       //  Value \u003d List of Containers of given cap (the actual container size\n       //          might be different than what is requested, which is why\n       //          we need the requested capability (key) to match against\n       //          the outstanding reqs)\n       Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n-          opportContext, priority, applicationAttemptId, appSubmitter);\n+          opportContext, schedulerKey, applicationAttemptId, appSubmitter);\n       for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n         opportContext.matchAllocationToOutstandingRequest(\n             e.getKey(), e.getValue());\n         allocatedContainers.addAll(e.getValue());\n       }\n     }\n \n     return allocatedContainers;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n      List\u003cResourceRequest\u003e oppResourceReqs,\n      ApplicationAttemptId applicationAttemptId,\n      OpportunisticContainerContext opportContext, long rmIdentifier,\n      String appSubmitter) throws YarnException {\n\n    // Update black list.\n    if (blackList !\u003d null) {\n      opportContext.getBlacklist().removeAll(blackList.getBlacklistRemovals());\n      opportContext.getBlacklist().addAll(blackList.getBlacklistAdditions());\n    }\n\n    // Add OPPORTUNISTIC requests to the outstanding ones.\n    opportContext.addToOutstandingReqs(oppResourceReqs);\n\n    // Satisfy the outstanding OPPORTUNISTIC requests.\n    List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n    for (SchedulerRequestKey schedulerKey :\n        opportContext.getOutstandingOpReqs().descendingKeySet()) {\n      // Allocated containers :\n      //  Key \u003d Requested Capability,\n      //  Value \u003d List of Containers of given cap (the actual container size\n      //          might be different than what is requested, which is why\n      //          we need the requested capability (key) to match against\n      //          the outstanding reqs)\n      Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n          opportContext, schedulerKey, applicationAttemptId, appSubmitter);\n      for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n        opportContext.matchAllocationToOutstandingRequest(\n            e.getKey(), e.getValue());\n        allocatedContainers.addAll(e.getValue());\n      }\n    }\n\n    return allocatedContainers;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/OpportunisticContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "[request-AllocateRequest, applicationAttemptId-ApplicationAttemptId, opportContext-OpportunisticContainerContext, rmIdentifier-long, appSubmitter-String]",
            "newValue": "[blackList-ResourceBlacklistRequest, oppResourceReqs-List\u003cResourceRequest\u003e, applicationAttemptId-ApplicationAttemptId, opportContext-OpportunisticContainerContext, rmIdentifier-long, appSubmitter-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5938. Refactoring OpportunisticContainerAllocator to use SchedulerRequestKey instead of Priority and other misc fixes (asuresh)\n",
          "commitDate": "27/12/16 12:40 PM",
          "commitName": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "09/11/16 12:11 AM",
          "commitNameOld": "283fa33febe043bd7b4fa87546be26c9c5a8f8b5",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 48.52,
          "commitsBetweenForRepo": 269,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,36 @@\n-  public List\u003cContainer\u003e allocateContainers(\n-      AllocateRequest request, ApplicationAttemptId applicationAttemptId,\n+  public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n+      List\u003cResourceRequest\u003e oppResourceReqs,\n+      ApplicationAttemptId applicationAttemptId,\n       OpportunisticContainerContext opportContext, long rmIdentifier,\n       String appSubmitter) throws YarnException {\n-    // Update released containers.\n-    List\u003cContainerId\u003e releasedContainers \u003d request.getReleaseList();\n-    int numReleasedContainers \u003d releasedContainers.size();\n-    if (numReleasedContainers \u003e 0) {\n-      LOG.info(\"AttemptID: \" + applicationAttemptId + \" released: \"\n-          + numReleasedContainers);\n-      opportContext.getContainersAllocated().removeAll(releasedContainers);\n-    }\n \n     // Update black list.\n-    ResourceBlacklistRequest rbr \u003d request.getResourceBlacklistRequest();\n-    if (rbr !\u003d null) {\n-      opportContext.getBlacklist().removeAll(rbr.getBlacklistRemovals());\n-      opportContext.getBlacklist().addAll(rbr.getBlacklistAdditions());\n+    if (blackList !\u003d null) {\n+      opportContext.getBlacklist().removeAll(blackList.getBlacklistRemovals());\n+      opportContext.getBlacklist().addAll(blackList.getBlacklistAdditions());\n     }\n \n     // Add OPPORTUNISTIC requests to the outstanding ones.\n-    opportContext.addToOutstandingReqs(request.getAskList());\n+    opportContext.addToOutstandingReqs(oppResourceReqs);\n \n     // Satisfy the outstanding OPPORTUNISTIC requests.\n     List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n-    for (Priority priority :\n+    for (SchedulerRequestKey schedulerKey :\n         opportContext.getOutstandingOpReqs().descendingKeySet()) {\n       // Allocated containers :\n       //  Key \u003d Requested Capability,\n       //  Value \u003d List of Containers of given cap (the actual container size\n       //          might be different than what is requested, which is why\n       //          we need the requested capability (key) to match against\n       //          the outstanding reqs)\n       Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n-          opportContext, priority, applicationAttemptId, appSubmitter);\n+          opportContext, schedulerKey, applicationAttemptId, appSubmitter);\n       for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n         opportContext.matchAllocationToOutstandingRequest(\n             e.getKey(), e.getValue());\n         allocatedContainers.addAll(e.getValue());\n       }\n     }\n \n     return allocatedContainers;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cContainer\u003e allocateContainers(ResourceBlacklistRequest blackList,\n      List\u003cResourceRequest\u003e oppResourceReqs,\n      ApplicationAttemptId applicationAttemptId,\n      OpportunisticContainerContext opportContext, long rmIdentifier,\n      String appSubmitter) throws YarnException {\n\n    // Update black list.\n    if (blackList !\u003d null) {\n      opportContext.getBlacklist().removeAll(blackList.getBlacklistRemovals());\n      opportContext.getBlacklist().addAll(blackList.getBlacklistAdditions());\n    }\n\n    // Add OPPORTUNISTIC requests to the outstanding ones.\n    opportContext.addToOutstandingReqs(oppResourceReqs);\n\n    // Satisfy the outstanding OPPORTUNISTIC requests.\n    List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n    for (SchedulerRequestKey schedulerKey :\n        opportContext.getOutstandingOpReqs().descendingKeySet()) {\n      // Allocated containers :\n      //  Key \u003d Requested Capability,\n      //  Value \u003d List of Containers of given cap (the actual container size\n      //          might be different than what is requested, which is why\n      //          we need the requested capability (key) to match against\n      //          the outstanding reqs)\n      Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n          opportContext, schedulerKey, applicationAttemptId, appSubmitter);\n      for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n        opportContext.matchAllocationToOutstandingRequest(\n            e.getKey(), e.getValue());\n        allocatedContainers.addAll(e.getValue());\n      }\n    }\n\n    return allocatedContainers;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/OpportunisticContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "283fa33febe043bd7b4fa87546be26c9c5a8f8b5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5823. Update NMTokens in case of requests with only opportunistic containers. (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "09/11/16 12:11 AM",
      "commitName": "283fa33febe043bd7b4fa87546be26c9c5a8f8b5",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5823. Update NMTokens in case of requests with only opportunistic containers. (Konstantinos Karanasos via asuresh)\n",
          "commitDate": "09/11/16 12:11 AM",
          "commitName": "283fa33febe043bd7b4fa87546be26c9c5a8f8b5",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "29/10/16 2:03 AM",
          "commitNameOld": "aa3cab1eb29c56368d15882d7260a994e615e8d8",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 10.96,
          "commitsBetweenForRepo": 107,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,44 @@\n   public List\u003cContainer\u003e allocateContainers(\n       AllocateRequest request, ApplicationAttemptId applicationAttemptId,\n-      OpportunisticContainerContext appContext, long rmIdentifier,\n+      OpportunisticContainerContext opportContext, long rmIdentifier,\n       String appSubmitter) throws YarnException {\n-    // Partition requests into GUARANTEED and OPPORTUNISTIC reqs\n-    PartitionedResourceRequests partitionedAsks \u003d\n-        partitionAskList(request.getAskList());\n-\n-    if (partitionedAsks.getOpportunistic().isEmpty()) {\n-      return Collections.emptyList();\n-    }\n-\n+    // Update released containers.\n     List\u003cContainerId\u003e releasedContainers \u003d request.getReleaseList();\n     int numReleasedContainers \u003d releasedContainers.size();\n     if (numReleasedContainers \u003e 0) {\n       LOG.info(\"AttemptID: \" + applicationAttemptId + \" released: \"\n           + numReleasedContainers);\n-      appContext.getContainersAllocated().removeAll(releasedContainers);\n+      opportContext.getContainersAllocated().removeAll(releasedContainers);\n     }\n \n-    // Also, update black list\n+    // Update black list.\n     ResourceBlacklistRequest rbr \u003d request.getResourceBlacklistRequest();\n     if (rbr !\u003d null) {\n-      appContext.getBlacklist().removeAll(rbr.getBlacklistRemovals());\n-      appContext.getBlacklist().addAll(rbr.getBlacklistAdditions());\n+      opportContext.getBlacklist().removeAll(rbr.getBlacklistRemovals());\n+      opportContext.getBlacklist().addAll(rbr.getBlacklistAdditions());\n     }\n \n-    // Add OPPORTUNISTIC reqs to the outstanding reqs\n-    appContext.addToOutstandingReqs(partitionedAsks.getOpportunistic());\n+    // Add OPPORTUNISTIC requests to the outstanding ones.\n+    opportContext.addToOutstandingReqs(request.getAskList());\n \n+    // Satisfy the outstanding OPPORTUNISTIC requests.\n     List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n     for (Priority priority :\n-        appContext.getOutstandingOpReqs().descendingKeySet()) {\n+        opportContext.getOutstandingOpReqs().descendingKeySet()) {\n       // Allocated containers :\n       //  Key \u003d Requested Capability,\n       //  Value \u003d List of Containers of given cap (the actual container size\n       //          might be different than what is requested, which is why\n       //          we need the requested capability (key) to match against\n       //          the outstanding reqs)\n       Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n-          appContext, priority, applicationAttemptId, appSubmitter);\n+          opportContext, priority, applicationAttemptId, appSubmitter);\n       for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n-        appContext.matchAllocationToOutstandingRequest(\n+        opportContext.matchAllocationToOutstandingRequest(\n             e.getKey(), e.getValue());\n         allocatedContainers.addAll(e.getValue());\n       }\n     }\n \n-    // Send all the GUARANTEED Reqs to RM\n-    request.setAskList(partitionedAsks.getGuaranteed());\n     return allocatedContainers;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cContainer\u003e allocateContainers(\n      AllocateRequest request, ApplicationAttemptId applicationAttemptId,\n      OpportunisticContainerContext opportContext, long rmIdentifier,\n      String appSubmitter) throws YarnException {\n    // Update released containers.\n    List\u003cContainerId\u003e releasedContainers \u003d request.getReleaseList();\n    int numReleasedContainers \u003d releasedContainers.size();\n    if (numReleasedContainers \u003e 0) {\n      LOG.info(\"AttemptID: \" + applicationAttemptId + \" released: \"\n          + numReleasedContainers);\n      opportContext.getContainersAllocated().removeAll(releasedContainers);\n    }\n\n    // Update black list.\n    ResourceBlacklistRequest rbr \u003d request.getResourceBlacklistRequest();\n    if (rbr !\u003d null) {\n      opportContext.getBlacklist().removeAll(rbr.getBlacklistRemovals());\n      opportContext.getBlacklist().addAll(rbr.getBlacklistAdditions());\n    }\n\n    // Add OPPORTUNISTIC requests to the outstanding ones.\n    opportContext.addToOutstandingReqs(request.getAskList());\n\n    // Satisfy the outstanding OPPORTUNISTIC requests.\n    List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n    for (Priority priority :\n        opportContext.getOutstandingOpReqs().descendingKeySet()) {\n      // Allocated containers :\n      //  Key \u003d Requested Capability,\n      //  Value \u003d List of Containers of given cap (the actual container size\n      //          might be different than what is requested, which is why\n      //          we need the requested capability (key) to match against\n      //          the outstanding reqs)\n      Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n          opportContext, priority, applicationAttemptId, appSubmitter);\n      for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n        opportContext.matchAllocationToOutstandingRequest(\n            e.getKey(), e.getValue());\n        allocatedContainers.addAll(e.getValue());\n      }\n    }\n\n    return allocatedContainers;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/OpportunisticContainerAllocator.java",
          "extendedDetails": {
            "oldValue": "[request-AllocateRequest, applicationAttemptId-ApplicationAttemptId, appContext-OpportunisticContainerContext, rmIdentifier-long, appSubmitter-String]",
            "newValue": "[request-AllocateRequest, applicationAttemptId-ApplicationAttemptId, opportContext-OpportunisticContainerContext, rmIdentifier-long, appSubmitter-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5823. Update NMTokens in case of requests with only opportunistic containers. (Konstantinos Karanasos via asuresh)\n",
          "commitDate": "09/11/16 12:11 AM",
          "commitName": "283fa33febe043bd7b4fa87546be26c9c5a8f8b5",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "29/10/16 2:03 AM",
          "commitNameOld": "aa3cab1eb29c56368d15882d7260a994e615e8d8",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 10.96,
          "commitsBetweenForRepo": 107,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,44 @@\n   public List\u003cContainer\u003e allocateContainers(\n       AllocateRequest request, ApplicationAttemptId applicationAttemptId,\n-      OpportunisticContainerContext appContext, long rmIdentifier,\n+      OpportunisticContainerContext opportContext, long rmIdentifier,\n       String appSubmitter) throws YarnException {\n-    // Partition requests into GUARANTEED and OPPORTUNISTIC reqs\n-    PartitionedResourceRequests partitionedAsks \u003d\n-        partitionAskList(request.getAskList());\n-\n-    if (partitionedAsks.getOpportunistic().isEmpty()) {\n-      return Collections.emptyList();\n-    }\n-\n+    // Update released containers.\n     List\u003cContainerId\u003e releasedContainers \u003d request.getReleaseList();\n     int numReleasedContainers \u003d releasedContainers.size();\n     if (numReleasedContainers \u003e 0) {\n       LOG.info(\"AttemptID: \" + applicationAttemptId + \" released: \"\n           + numReleasedContainers);\n-      appContext.getContainersAllocated().removeAll(releasedContainers);\n+      opportContext.getContainersAllocated().removeAll(releasedContainers);\n     }\n \n-    // Also, update black list\n+    // Update black list.\n     ResourceBlacklistRequest rbr \u003d request.getResourceBlacklistRequest();\n     if (rbr !\u003d null) {\n-      appContext.getBlacklist().removeAll(rbr.getBlacklistRemovals());\n-      appContext.getBlacklist().addAll(rbr.getBlacklistAdditions());\n+      opportContext.getBlacklist().removeAll(rbr.getBlacklistRemovals());\n+      opportContext.getBlacklist().addAll(rbr.getBlacklistAdditions());\n     }\n \n-    // Add OPPORTUNISTIC reqs to the outstanding reqs\n-    appContext.addToOutstandingReqs(partitionedAsks.getOpportunistic());\n+    // Add OPPORTUNISTIC requests to the outstanding ones.\n+    opportContext.addToOutstandingReqs(request.getAskList());\n \n+    // Satisfy the outstanding OPPORTUNISTIC requests.\n     List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n     for (Priority priority :\n-        appContext.getOutstandingOpReqs().descendingKeySet()) {\n+        opportContext.getOutstandingOpReqs().descendingKeySet()) {\n       // Allocated containers :\n       //  Key \u003d Requested Capability,\n       //  Value \u003d List of Containers of given cap (the actual container size\n       //          might be different than what is requested, which is why\n       //          we need the requested capability (key) to match against\n       //          the outstanding reqs)\n       Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n-          appContext, priority, applicationAttemptId, appSubmitter);\n+          opportContext, priority, applicationAttemptId, appSubmitter);\n       for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n-        appContext.matchAllocationToOutstandingRequest(\n+        opportContext.matchAllocationToOutstandingRequest(\n             e.getKey(), e.getValue());\n         allocatedContainers.addAll(e.getValue());\n       }\n     }\n \n-    // Send all the GUARANTEED Reqs to RM\n-    request.setAskList(partitionedAsks.getGuaranteed());\n     return allocatedContainers;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cContainer\u003e allocateContainers(\n      AllocateRequest request, ApplicationAttemptId applicationAttemptId,\n      OpportunisticContainerContext opportContext, long rmIdentifier,\n      String appSubmitter) throws YarnException {\n    // Update released containers.\n    List\u003cContainerId\u003e releasedContainers \u003d request.getReleaseList();\n    int numReleasedContainers \u003d releasedContainers.size();\n    if (numReleasedContainers \u003e 0) {\n      LOG.info(\"AttemptID: \" + applicationAttemptId + \" released: \"\n          + numReleasedContainers);\n      opportContext.getContainersAllocated().removeAll(releasedContainers);\n    }\n\n    // Update black list.\n    ResourceBlacklistRequest rbr \u003d request.getResourceBlacklistRequest();\n    if (rbr !\u003d null) {\n      opportContext.getBlacklist().removeAll(rbr.getBlacklistRemovals());\n      opportContext.getBlacklist().addAll(rbr.getBlacklistAdditions());\n    }\n\n    // Add OPPORTUNISTIC requests to the outstanding ones.\n    opportContext.addToOutstandingReqs(request.getAskList());\n\n    // Satisfy the outstanding OPPORTUNISTIC requests.\n    List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n    for (Priority priority :\n        opportContext.getOutstandingOpReqs().descendingKeySet()) {\n      // Allocated containers :\n      //  Key \u003d Requested Capability,\n      //  Value \u003d List of Containers of given cap (the actual container size\n      //          might be different than what is requested, which is why\n      //          we need the requested capability (key) to match against\n      //          the outstanding reqs)\n      Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n          opportContext, priority, applicationAttemptId, appSubmitter);\n      for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n        opportContext.matchAllocationToOutstandingRequest(\n            e.getKey(), e.getValue());\n        allocatedContainers.addAll(e.getValue());\n      }\n    }\n\n    return allocatedContainers;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/OpportunisticContainerAllocator.java",
          "extendedDetails": {}
        }
      ]
    },
    "10be45986cdf86a89055065b752959bd6369d54f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5486. Update OpportunisticContainerAllocatorAMService::allocate method to handle OPPORTUNISTIC container requests. (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "29/09/16 3:11 PM",
      "commitName": "10be45986cdf86a89055065b752959bd6369d54f",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "30/08/16 3:52 PM",
      "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 29.97,
      "commitsBetweenForRepo": 164,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,52 @@\n   public List\u003cContainer\u003e allocateContainers(\n       AllocateRequest request, ApplicationAttemptId applicationAttemptId,\n       OpportunisticContainerContext appContext, long rmIdentifier,\n       String appSubmitter) throws YarnException {\n     // Partition requests into GUARANTEED and OPPORTUNISTIC reqs\n     PartitionedResourceRequests partitionedAsks \u003d\n         partitionAskList(request.getAskList());\n \n+    if (partitionedAsks.getOpportunistic().isEmpty()) {\n+      return Collections.emptyList();\n+    }\n+\n     List\u003cContainerId\u003e releasedContainers \u003d request.getReleaseList();\n     int numReleasedContainers \u003d releasedContainers.size();\n     if (numReleasedContainers \u003e 0) {\n       LOG.info(\"AttemptID: \" + applicationAttemptId + \" released: \"\n           + numReleasedContainers);\n       appContext.getContainersAllocated().removeAll(releasedContainers);\n     }\n \n     // Also, update black list\n     ResourceBlacklistRequest rbr \u003d request.getResourceBlacklistRequest();\n     if (rbr !\u003d null) {\n       appContext.getBlacklist().removeAll(rbr.getBlacklistRemovals());\n       appContext.getBlacklist().addAll(rbr.getBlacklistAdditions());\n     }\n \n     // Add OPPORTUNISTIC reqs to the outstanding reqs\n     appContext.addToOutstandingReqs(partitionedAsks.getOpportunistic());\n \n     List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n     for (Priority priority :\n         appContext.getOutstandingOpReqs().descendingKeySet()) {\n       // Allocated containers :\n       //  Key \u003d Requested Capability,\n-      //  Value \u003d List of Containers of given Cap (The actual container size\n-      //          might be different than what is requested.. which is why\n+      //  Value \u003d List of Containers of given cap (the actual container size\n+      //          might be different than what is requested, which is why\n       //          we need the requested capability (key) to match against\n       //          the outstanding reqs)\n       Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n           appContext, priority, applicationAttemptId, appSubmitter);\n       for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n         appContext.matchAllocationToOutstandingRequest(\n             e.getKey(), e.getValue());\n         allocatedContainers.addAll(e.getValue());\n       }\n     }\n \n     // Send all the GUARANTEED Reqs to RM\n     request.setAskList(partitionedAsks.getGuaranteed());\n     return allocatedContainers;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainer\u003e allocateContainers(\n      AllocateRequest request, ApplicationAttemptId applicationAttemptId,\n      OpportunisticContainerContext appContext, long rmIdentifier,\n      String appSubmitter) throws YarnException {\n    // Partition requests into GUARANTEED and OPPORTUNISTIC reqs\n    PartitionedResourceRequests partitionedAsks \u003d\n        partitionAskList(request.getAskList());\n\n    if (partitionedAsks.getOpportunistic().isEmpty()) {\n      return Collections.emptyList();\n    }\n\n    List\u003cContainerId\u003e releasedContainers \u003d request.getReleaseList();\n    int numReleasedContainers \u003d releasedContainers.size();\n    if (numReleasedContainers \u003e 0) {\n      LOG.info(\"AttemptID: \" + applicationAttemptId + \" released: \"\n          + numReleasedContainers);\n      appContext.getContainersAllocated().removeAll(releasedContainers);\n    }\n\n    // Also, update black list\n    ResourceBlacklistRequest rbr \u003d request.getResourceBlacklistRequest();\n    if (rbr !\u003d null) {\n      appContext.getBlacklist().removeAll(rbr.getBlacklistRemovals());\n      appContext.getBlacklist().addAll(rbr.getBlacklistAdditions());\n    }\n\n    // Add OPPORTUNISTIC reqs to the outstanding reqs\n    appContext.addToOutstandingReqs(partitionedAsks.getOpportunistic());\n\n    List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n    for (Priority priority :\n        appContext.getOutstandingOpReqs().descendingKeySet()) {\n      // Allocated containers :\n      //  Key \u003d Requested Capability,\n      //  Value \u003d List of Containers of given cap (the actual container size\n      //          might be different than what is requested, which is why\n      //          we need the requested capability (key) to match against\n      //          the outstanding reqs)\n      Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n          appContext, priority, applicationAttemptId, appSubmitter);\n      for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n        appContext.matchAllocationToOutstandingRequest(\n            e.getKey(), e.getValue());\n        allocatedContainers.addAll(e.getValue());\n      }\n    }\n\n    // Send all the GUARANTEED Reqs to RM\n    request.setAskList(partitionedAsks.getGuaranteed());\n    return allocatedContainers;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/OpportunisticContainerAllocator.java",
      "extendedDetails": {}
    },
    "82c9e061017c32e633e0b0cbb7978749a6df4fb2": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5457. Refactor DistributedScheduling framework to pull out common functionality. (asuresh)\n",
      "commitDate": "09/08/16 12:42 AM",
      "commitName": "82c9e061017c32e633e0b0cbb7978749a6df4fb2",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,48 @@\n+  public List\u003cContainer\u003e allocateContainers(\n+      AllocateRequest request, ApplicationAttemptId applicationAttemptId,\n+      OpportunisticContainerContext appContext, long rmIdentifier,\n+      String appSubmitter) throws YarnException {\n+    // Partition requests into GUARANTEED and OPPORTUNISTIC reqs\n+    PartitionedResourceRequests partitionedAsks \u003d\n+        partitionAskList(request.getAskList());\n+\n+    List\u003cContainerId\u003e releasedContainers \u003d request.getReleaseList();\n+    int numReleasedContainers \u003d releasedContainers.size();\n+    if (numReleasedContainers \u003e 0) {\n+      LOG.info(\"AttemptID: \" + applicationAttemptId + \" released: \"\n+          + numReleasedContainers);\n+      appContext.getContainersAllocated().removeAll(releasedContainers);\n+    }\n+\n+    // Also, update black list\n+    ResourceBlacklistRequest rbr \u003d request.getResourceBlacklistRequest();\n+    if (rbr !\u003d null) {\n+      appContext.getBlacklist().removeAll(rbr.getBlacklistRemovals());\n+      appContext.getBlacklist().addAll(rbr.getBlacklistAdditions());\n+    }\n+\n+    // Add OPPORTUNISTIC reqs to the outstanding reqs\n+    appContext.addToOutstandingReqs(partitionedAsks.getOpportunistic());\n+\n+    List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n+    for (Priority priority :\n+        appContext.getOutstandingOpReqs().descendingKeySet()) {\n+      // Allocated containers :\n+      //  Key \u003d Requested Capability,\n+      //  Value \u003d List of Containers of given Cap (The actual container size\n+      //          might be different than what is requested.. which is why\n+      //          we need the requested capability (key) to match against\n+      //          the outstanding reqs)\n+      Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n+          appContext, priority, applicationAttemptId, appSubmitter);\n+      for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n+        appContext.matchAllocationToOutstandingRequest(\n+            e.getKey(), e.getValue());\n+        allocatedContainers.addAll(e.getValue());\n+      }\n+    }\n+\n+    // Send all the GUARANTEED Reqs to RM\n+    request.setAskList(partitionedAsks.getGuaranteed());\n+    return allocatedContainers;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cContainer\u003e allocateContainers(\n      AllocateRequest request, ApplicationAttemptId applicationAttemptId,\n      OpportunisticContainerContext appContext, long rmIdentifier,\n      String appSubmitter) throws YarnException {\n    // Partition requests into GUARANTEED and OPPORTUNISTIC reqs\n    PartitionedResourceRequests partitionedAsks \u003d\n        partitionAskList(request.getAskList());\n\n    List\u003cContainerId\u003e releasedContainers \u003d request.getReleaseList();\n    int numReleasedContainers \u003d releasedContainers.size();\n    if (numReleasedContainers \u003e 0) {\n      LOG.info(\"AttemptID: \" + applicationAttemptId + \" released: \"\n          + numReleasedContainers);\n      appContext.getContainersAllocated().removeAll(releasedContainers);\n    }\n\n    // Also, update black list\n    ResourceBlacklistRequest rbr \u003d request.getResourceBlacklistRequest();\n    if (rbr !\u003d null) {\n      appContext.getBlacklist().removeAll(rbr.getBlacklistRemovals());\n      appContext.getBlacklist().addAll(rbr.getBlacklistAdditions());\n    }\n\n    // Add OPPORTUNISTIC reqs to the outstanding reqs\n    appContext.addToOutstandingReqs(partitionedAsks.getOpportunistic());\n\n    List\u003cContainer\u003e allocatedContainers \u003d new ArrayList\u003c\u003e();\n    for (Priority priority :\n        appContext.getOutstandingOpReqs().descendingKeySet()) {\n      // Allocated containers :\n      //  Key \u003d Requested Capability,\n      //  Value \u003d List of Containers of given Cap (The actual container size\n      //          might be different than what is requested.. which is why\n      //          we need the requested capability (key) to match against\n      //          the outstanding reqs)\n      Map\u003cResource, List\u003cContainer\u003e\u003e allocated \u003d allocate(rmIdentifier,\n          appContext, priority, applicationAttemptId, appSubmitter);\n      for (Map.Entry\u003cResource, List\u003cContainer\u003e\u003e e : allocated.entrySet()) {\n        appContext.matchAllocationToOutstandingRequest(\n            e.getKey(), e.getValue());\n        allocatedContainers.addAll(e.getValue());\n      }\n    }\n\n    // Send all the GUARANTEED Reqs to RM\n    request.setAskList(partitionedAsks.getGuaranteed());\n    return allocatedContainers;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/scheduler/OpportunisticContainerAllocator.java"
    }
  }
}