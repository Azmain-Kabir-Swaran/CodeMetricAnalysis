{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AFileSystem.java",
  "functionName": "innerRename",
  "functionId": "innerRename___source-Path__dest-Path",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
  "functionStartLine": 1456,
  "functionEndLine": 1480,
  "numCommitsSeen": 235,
  "timeTaken": 11888,
  "changeHistory": [
    "56dee667707926f3796c7757be1a133a362f05c9",
    "511df1e837b19ccb9271520589452d82d50ac69d",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
    "a36274d69947648dbe82721220cc5240ec5d396d",
    "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744",
    "ef450df443f1dea1c52082cf281f25db7141972f",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
    "621b43e254afaff708cd6fc4698b29628f6abc33",
    "6c399a88e9b5ef8f822a9bd469dbf9fdb3141e38",
    "d60a60be8aa450c44d3be69d26c88025e253ac0c",
    "ee0c722dc8fb81ec902cd1da5958ce5adb0ab08f",
    "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25",
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944",
    "39ec1515a205952eda7e171408a8b83eceb4abde",
    "27c4e90efce04e1b1302f668b5eb22412e00d033",
    "29ae25801380b94442253c4202dee782dc4713f5",
    "709ff99cff4124823bde631e272af7be9a22f83b",
    "aa1c437b6a806de612f030a68984c606c623f1d9",
    "6ba52d88ec11444cbac946ffadbc645acd0657de",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0"
  ],
  "changeHistoryShort": {
    "56dee667707926f3796c7757be1a133a362f05c9": "Ybodychange",
    "511df1e837b19ccb9271520589452d82d50ac69d": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ymultichange(Yreturntypechange,Ybodychange)",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": "Ybodychange",
    "a36274d69947648dbe82721220cc5240ec5d396d": "Ybodychange",
    "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744": "Ybodychange",
    "ef450df443f1dea1c52082cf281f25db7141972f": "Ybodychange",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Ymultichange(Yparameterchange,Ybodychange)",
    "6c399a88e9b5ef8f822a9bd469dbf9fdb3141e38": "Ybodychange",
    "d60a60be8aa450c44d3be69d26c88025e253ac0c": "Ymultichange(Yexceptionschange,Ybodychange)",
    "ee0c722dc8fb81ec902cd1da5958ce5adb0ab08f": "Ybodychange",
    "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25": "Ybodychange",
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944": "Ybodychange",
    "39ec1515a205952eda7e171408a8b83eceb4abde": "Ymultichange(Yrename,Ymodifierchange,Yexceptionschange)",
    "27c4e90efce04e1b1302f668b5eb22412e00d033": "Ybodychange",
    "29ae25801380b94442253c4202dee782dc4713f5": "Ybodychange",
    "709ff99cff4124823bde631e272af7be9a22f83b": "Ybodychange",
    "aa1c437b6a806de612f030a68984c606c623f1d9": "Ybodychange",
    "6ba52d88ec11444cbac946ffadbc645acd0657de": "Ybodychange",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "56dee667707926f3796c7757be1a133a362f05c9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16823. Large DeleteObject requests are their own Thundering Herd.\n\nContributed by Steve Loughran.\n\nDuring S3A rename() and delete() calls, the list of objects delete is\nbuilt up into batches of a thousand and then POSTed in a single large\nDeleteObjects request.\n\nBut as the IO capacity allowed on an S3 partition may only be 3500 writes\nper second *and* each entry in that POST counts as a single write, then\none of those posts alone can trigger throttling on an already loaded\nS3 directory tree. Which can trigger backoff and retry, with the same\nthousand entry post, and so recreate the exact same problem.\n\nFixes\n\n* Page size for delete object requests is set in\n  fs.s3a.bulk.delete.page.size; the default is 250.\n* The property fs.s3a.experimental.aws.s3.throttling (default\u003dtrue)\n  can be set to false to disable throttle retry logic in the AWS\n  client SDK -it is all handled in the S3A client. This\n  gives more visibility in to when operations are being throttled\n* Bulk delete throttling events are logged to the log\n  org.apache.hadoop.fs.s3a.throttled log at INFO; if this appears\n  often then choose a smaller page size.\n* The metric \"store_io_throttled\" adds the entire count of delete\n  requests when a single DeleteObjects request is throttled.\n* A new quantile, \"store_io_throttle_rate\" can track throttling\n  load over time.\n* DynamoDB metastore throttle resilience issues have also been\n  identified and fixed. Note: the fs.s3a.experimental.aws.s3.throttling\n  flag does not apply to DDB IO precisely because there may still be\n  lurking issues there and it safest to rely on the DynamoDB client\n  SDK.\n\nChange-Id: I00f85cdd94fc008864d060533f6bd4870263fd84\n",
      "commitDate": "13/02/20 11:09 AM",
      "commitName": "56dee667707926f3796c7757be1a133a362f05c9",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "30/01/20 2:16 AM",
      "commitNameOld": "5977360878e6780bd04842c8a2156f9848e1d088",
      "commitAuthorOld": "Mustafa Ä°man",
      "daysBetweenCommits": 14.37,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,25 @@\n   private long innerRename(Path source, Path dest)\n       throws RenameFailedException, FileNotFoundException, IOException,\n         AmazonClientException {\n     Path src \u003d qualify(source);\n     Path dst \u003d qualify(dest);\n \n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     entryPoint(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     Pair\u003cS3AFileStatus, S3AFileStatus\u003e p \u003d initiateRename(src, dst);\n \n     // Initiate the rename.\n     // this will call back into this class via the rename callbacks\n     // and interact directly with any metastore.\n     RenameOperation renameOperation \u003d new RenameOperation(\n         createStoreContext(),\n         src, srcKey, p.getLeft(),\n         dst, dstKey, p.getRight(),\n-        operationCallbacks);\n+        operationCallbacks,\n+        pageSize);\n     return renameOperation.execute();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long innerRename(Path source, Path dest)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    Path src \u003d qualify(source);\n    Path dst \u003d qualify(dest);\n\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    entryPoint(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    Pair\u003cS3AFileStatus, S3AFileStatus\u003e p \u003d initiateRename(src, dst);\n\n    // Initiate the rename.\n    // this will call back into this class via the rename callbacks\n    // and interact directly with any metastore.\n    RenameOperation renameOperation \u003d new RenameOperation(\n        createStoreContext(),\n        src, srcKey, p.getLeft(),\n        dst, dstKey, p.getRight(),\n        operationCallbacks,\n        pageSize);\n    return renameOperation.execute();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "511df1e837b19ccb9271520589452d82d50ac69d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16430. S3AFilesystem.delete to incrementally update s3guard with deletions\n\nContributed by Steve Loughran.\n\nThis overlaps the scanning for directory entries with batched calls to S3 DELETE and updates of the S3Guard tables.\nIt also uses S3Guard to list the files to delete, so find newly created files even when S3 listings are not use consistent.\n\nFor path which the client considers S3Guard to be authoritative, we also do a recursive LIST of the store and delete files; this is to find unindexed files and do guarantee that the delete(path, true) call really does delete everything underneath.\n\nChange-Id: Ice2f6e940c506e0b3a78fa534a99721b1698708e\n",
      "commitDate": "05/09/19 6:25 AM",
      "commitName": "511df1e837b19ccb9271520589452d82d50ac69d",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "23/07/19 6:52 AM",
      "commitNameOld": "4317d332321778269a583e2223d433107fab82eb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 43.98,
      "commitsBetweenForRepo": 415,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,24 @@\n   private long innerRename(Path source, Path dest)\n       throws RenameFailedException, FileNotFoundException, IOException,\n         AmazonClientException {\n     Path src \u003d qualify(source);\n     Path dst \u003d qualify(dest);\n \n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     entryPoint(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     Pair\u003cS3AFileStatus, S3AFileStatus\u003e p \u003d initiateRename(src, dst);\n \n     // Initiate the rename.\n     // this will call back into this class via the rename callbacks\n     // and interact directly with any metastore.\n     RenameOperation renameOperation \u003d new RenameOperation(\n         createStoreContext(),\n         src, srcKey, p.getLeft(),\n         dst, dstKey, p.getRight(),\n-        new RenameOperationCallbacksImpl());\n-    return renameOperation.executeRename();\n+        operationCallbacks);\n+    return renameOperation.execute();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private long innerRename(Path source, Path dest)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    Path src \u003d qualify(source);\n    Path dst \u003d qualify(dest);\n\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    entryPoint(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    Pair\u003cS3AFileStatus, S3AFileStatus\u003e p \u003d initiateRename(src, dst);\n\n    // Initiate the rename.\n    // this will call back into this class via the rename callbacks\n    // and interact directly with any metastore.\n    RenameOperation renameOperation \u003d new RenameOperation(\n        createStoreContext(),\n        src, srcKey, p.getLeft(),\n        dst, dstKey, p.getRight(),\n        operationCallbacks);\n    return renameOperation.execute();\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,203 +1,24 @@\n-  private boolean innerRename(Path source, Path dest)\n+  private long innerRename(Path source, Path dest)\n       throws RenameFailedException, FileNotFoundException, IOException,\n         AmazonClientException {\n     Path src \u003d qualify(source);\n     Path dst \u003d qualify(dest);\n \n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     entryPoint(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n-    if (srcKey.isEmpty()) {\n-      throw new RenameFailedException(src, dst, \"source is root directory\");\n-    }\n-    if (dstKey.isEmpty()) {\n-      throw new RenameFailedException(src, dst, \"dest is root directory\");\n-    }\n+    Pair\u003cS3AFileStatus, S3AFileStatus\u003e p \u003d initiateRename(src, dst);\n \n-    // get the source file status; this raises a FNFE if there is no source\n-    // file.\n-    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n-\n-    if (srcKey.equals(dstKey)) {\n-      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n-          dst);\n-      throw new RenameFailedException(src, dst,\n-          \"source and dest refer to the same file or directory\")\n-          .withExitCode(srcStatus.isFile());\n-    }\n-\n-    S3AFileStatus dstStatus \u003d null;\n-    try {\n-      dstStatus \u003d innerGetFileStatus(dst, true);\n-      // if there is no destination entry, an exception is raised.\n-      // hence this code sequence can assume that there is something\n-      // at the end of the path; the only detail being what it is and\n-      // whether or not it can be the destination of the rename.\n-      if (srcStatus.isDirectory()) {\n-        if (dstStatus.isFile()) {\n-          throw new RenameFailedException(src, dst,\n-              \"source is a directory and dest is a file\")\n-              .withExitCode(srcStatus.isFile());\n-        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n-          throw new RenameFailedException(src, dst,\n-              \"Destination is a non-empty directory\")\n-              .withExitCode(false);\n-        }\n-        // at this point the destination is an empty directory\n-      } else {\n-        // source is a file. The destination must be a directory,\n-        // empty or not\n-        if (dstStatus.isFile()) {\n-          throw new RenameFailedException(src, dst,\n-              \"Cannot rename onto an existing file\")\n-              .withExitCode(false);\n-        }\n-      }\n-\n-    } catch (FileNotFoundException e) {\n-      LOG.debug(\"rename: destination path {} not found\", dst);\n-      // Parent must exist\n-      Path parent \u003d dst.getParent();\n-      if (!pathToKey(parent).isEmpty()) {\n-        try {\n-          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n-              false);\n-          if (!dstParentStatus.isDirectory()) {\n-            throw new RenameFailedException(src, dst,\n-                \"destination parent is not a directory\");\n-          }\n-        } catch (FileNotFoundException e2) {\n-          throw new RenameFailedException(src, dst,\n-              \"destination has no parent \");\n-        }\n-      }\n-    }\n-\n-    // If we have a MetadataStore, track deletions/creations.\n-    Collection\u003cPath\u003e srcPaths \u003d null;\n-    List\u003cPathMetadata\u003e dstMetas \u003d null;\n-    if (hasMetadataStore()) {\n-      srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n-      dstMetas \u003d new ArrayList\u003c\u003e();\n-    }\n-    // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n-    // TODO S3Guard: performance: mark destination dirs as authoritative\n-\n-    // Ok! Time to start\n-    if (srcStatus.isFile()) {\n-      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n-      long length \u003d srcStatus.getLen();\n-      S3ObjectAttributes objectAttributes \u003d\n-          createObjectAttributes(srcStatus.getPath(),\n-              srcStatus.getETag(), srcStatus.getVersionId());\n-      S3AReadOpContext readContext \u003d createReadContext(srcStatus, inputPolicy,\n-          changeDetectionPolicy, readAhead);\n-      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n-        String newDstKey \u003d maybeAddTrailingSlash(dstKey);\n-        String filename \u003d\n-            srcKey.substring(pathToKey(src.getParent()).length()+1);\n-        newDstKey \u003d newDstKey + filename;\n-        CopyResult copyResult \u003d copyFile(srcKey, newDstKey, length,\n-            objectAttributes, readContext);\n-        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n-            keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n-            username, copyResult.getETag(), copyResult.getVersionId());\n-      } else {\n-        CopyResult copyResult \u003d copyFile(srcKey, dstKey, srcStatus.getLen(),\n-            objectAttributes, readContext);\n-        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n-            length, getDefaultBlockSize(dst), username,\n-            copyResult.getETag(), copyResult.getVersionId());\n-      }\n-      innerDelete(srcStatus, false);\n-    } else {\n-      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n-\n-      // This is a directory to directory copy\n-      dstKey \u003d maybeAddTrailingSlash(dstKey);\n-      srcKey \u003d maybeAddTrailingSlash(srcKey);\n-\n-      //Verify dest is not a child of the source directory\n-      if (dstKey.startsWith(srcKey)) {\n-        throw new RenameFailedException(srcKey, dstKey,\n-            \"cannot rename a directory to a subdirectory of itself \");\n-      }\n-\n-      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n-      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n-        // delete unnecessary fake directory.\n-        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n-      }\n-\n-      Path parentPath \u003d keyToQualifiedPath(srcKey);\n-      RemoteIterator\u003cS3ALocatedFileStatus\u003e iterator \u003d\n-          listFilesAndEmptyDirectories(parentPath, true);\n-      while (iterator.hasNext()) {\n-        S3ALocatedFileStatus status \u003d iterator.next();\n-        long length \u003d status.getLen();\n-        String key \u003d pathToKey(status.getPath());\n-        if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n-          key +\u003d \"/\";\n-        }\n-        keysToDelete\n-            .add(new DeleteObjectsRequest.KeyVersion(key));\n-        String newDstKey \u003d\n-            dstKey + key.substring(srcKey.length());\n-        S3ObjectAttributes objectAttributes \u003d\n-            createObjectAttributes(status.getPath(),\n-                status.getETag(), status.getVersionId());\n-        S3AReadOpContext readContext \u003d createReadContext(status, inputPolicy,\n-            changeDetectionPolicy, readAhead);\n-        CopyResult copyResult \u003d copyFile(key, newDstKey, length,\n-            objectAttributes, readContext);\n-\n-        if (hasMetadataStore()) {\n-          // with a metadata store, the object entries need to be updated,\n-          // including, potentially, the ancestors\n-          Path childSrc \u003d keyToQualifiedPath(key);\n-          Path childDst \u003d keyToQualifiedPath(newDstKey);\n-          if (objectRepresentsDirectory(key, length)) {\n-            S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n-                childDst, username);\n-          } else {\n-            S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n-                childDst, length, getDefaultBlockSize(childDst), username,\n-                copyResult.getETag(), copyResult.getVersionId());\n-          }\n-          // Ancestor directories may not be listed, so we explicitly add them\n-          S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n-              keyToQualifiedPath(srcKey), childSrc, childDst, username);\n-        }\n-\n-        if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n-          removeKeys(keysToDelete, true, false);\n-        }\n-      }\n-      if (!keysToDelete.isEmpty()) {\n-        removeKeys(keysToDelete, false, false);\n-      }\n-\n-      // We moved all the children, now move the top-level dir\n-      // Empty directory should have been added as the object summary\n-      if (hasMetadataStore()\n-          \u0026\u0026 srcPaths !\u003d null\n-          \u0026\u0026 !srcPaths.contains(src)) {\n-        LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n-            src, dst);\n-        S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n-            username);\n-      }\n-    }\n-\n-    metadataStore.move(srcPaths, dstMetas, ttlTimeProvider);\n-\n-    if (!src.getParent().equals(dst.getParent())) {\n-      LOG.debug(\"source \u0026 dest parents are different; fix up dir markers\");\n-      deleteUnnecessaryFakeDirectories(dst.getParent());\n-      maybeCreateFakeParentDirectory(src);\n-    }\n-    return true;\n+    // Initiate the rename.\n+    // this will call back into this class via the rename callbacks\n+    // and interact directly with any metastore.\n+    RenameOperation renameOperation \u003d new RenameOperation(\n+        createStoreContext(),\n+        src, srcKey, p.getLeft(),\n+        dst, dstKey, p.getRight(),\n+        new RenameOperationCallbacksImpl());\n+    return renameOperation.executeRename();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private long innerRename(Path source, Path dest)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    Path src \u003d qualify(source);\n    Path dst \u003d qualify(dest);\n\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    entryPoint(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    Pair\u003cS3AFileStatus, S3AFileStatus\u003e p \u003d initiateRename(src, dst);\n\n    // Initiate the rename.\n    // this will call back into this class via the rename callbacks\n    // and interact directly with any metastore.\n    RenameOperation renameOperation \u003d new RenameOperation(\n        createStoreContext(),\n        src, srcKey, p.getLeft(),\n        dst, dstKey, p.getRight(),\n        new RenameOperationCallbacksImpl());\n    return renameOperation.executeRename();\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "boolean",
            "newValue": "long"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
          "commitDate": "20/06/19 1:56 AM",
          "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "16/06/19 9:05 AM",
          "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
          "commitAuthorOld": "Gabor Bota",
          "daysBetweenCommits": 3.7,
          "commitsBetweenForRepo": 44,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,203 +1,24 @@\n-  private boolean innerRename(Path source, Path dest)\n+  private long innerRename(Path source, Path dest)\n       throws RenameFailedException, FileNotFoundException, IOException,\n         AmazonClientException {\n     Path src \u003d qualify(source);\n     Path dst \u003d qualify(dest);\n \n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     entryPoint(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n-    if (srcKey.isEmpty()) {\n-      throw new RenameFailedException(src, dst, \"source is root directory\");\n-    }\n-    if (dstKey.isEmpty()) {\n-      throw new RenameFailedException(src, dst, \"dest is root directory\");\n-    }\n+    Pair\u003cS3AFileStatus, S3AFileStatus\u003e p \u003d initiateRename(src, dst);\n \n-    // get the source file status; this raises a FNFE if there is no source\n-    // file.\n-    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n-\n-    if (srcKey.equals(dstKey)) {\n-      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n-          dst);\n-      throw new RenameFailedException(src, dst,\n-          \"source and dest refer to the same file or directory\")\n-          .withExitCode(srcStatus.isFile());\n-    }\n-\n-    S3AFileStatus dstStatus \u003d null;\n-    try {\n-      dstStatus \u003d innerGetFileStatus(dst, true);\n-      // if there is no destination entry, an exception is raised.\n-      // hence this code sequence can assume that there is something\n-      // at the end of the path; the only detail being what it is and\n-      // whether or not it can be the destination of the rename.\n-      if (srcStatus.isDirectory()) {\n-        if (dstStatus.isFile()) {\n-          throw new RenameFailedException(src, dst,\n-              \"source is a directory and dest is a file\")\n-              .withExitCode(srcStatus.isFile());\n-        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n-          throw new RenameFailedException(src, dst,\n-              \"Destination is a non-empty directory\")\n-              .withExitCode(false);\n-        }\n-        // at this point the destination is an empty directory\n-      } else {\n-        // source is a file. The destination must be a directory,\n-        // empty or not\n-        if (dstStatus.isFile()) {\n-          throw new RenameFailedException(src, dst,\n-              \"Cannot rename onto an existing file\")\n-              .withExitCode(false);\n-        }\n-      }\n-\n-    } catch (FileNotFoundException e) {\n-      LOG.debug(\"rename: destination path {} not found\", dst);\n-      // Parent must exist\n-      Path parent \u003d dst.getParent();\n-      if (!pathToKey(parent).isEmpty()) {\n-        try {\n-          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n-              false);\n-          if (!dstParentStatus.isDirectory()) {\n-            throw new RenameFailedException(src, dst,\n-                \"destination parent is not a directory\");\n-          }\n-        } catch (FileNotFoundException e2) {\n-          throw new RenameFailedException(src, dst,\n-              \"destination has no parent \");\n-        }\n-      }\n-    }\n-\n-    // If we have a MetadataStore, track deletions/creations.\n-    Collection\u003cPath\u003e srcPaths \u003d null;\n-    List\u003cPathMetadata\u003e dstMetas \u003d null;\n-    if (hasMetadataStore()) {\n-      srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n-      dstMetas \u003d new ArrayList\u003c\u003e();\n-    }\n-    // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n-    // TODO S3Guard: performance: mark destination dirs as authoritative\n-\n-    // Ok! Time to start\n-    if (srcStatus.isFile()) {\n-      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n-      long length \u003d srcStatus.getLen();\n-      S3ObjectAttributes objectAttributes \u003d\n-          createObjectAttributes(srcStatus.getPath(),\n-              srcStatus.getETag(), srcStatus.getVersionId());\n-      S3AReadOpContext readContext \u003d createReadContext(srcStatus, inputPolicy,\n-          changeDetectionPolicy, readAhead);\n-      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n-        String newDstKey \u003d maybeAddTrailingSlash(dstKey);\n-        String filename \u003d\n-            srcKey.substring(pathToKey(src.getParent()).length()+1);\n-        newDstKey \u003d newDstKey + filename;\n-        CopyResult copyResult \u003d copyFile(srcKey, newDstKey, length,\n-            objectAttributes, readContext);\n-        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n-            keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n-            username, copyResult.getETag(), copyResult.getVersionId());\n-      } else {\n-        CopyResult copyResult \u003d copyFile(srcKey, dstKey, srcStatus.getLen(),\n-            objectAttributes, readContext);\n-        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n-            length, getDefaultBlockSize(dst), username,\n-            copyResult.getETag(), copyResult.getVersionId());\n-      }\n-      innerDelete(srcStatus, false);\n-    } else {\n-      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n-\n-      // This is a directory to directory copy\n-      dstKey \u003d maybeAddTrailingSlash(dstKey);\n-      srcKey \u003d maybeAddTrailingSlash(srcKey);\n-\n-      //Verify dest is not a child of the source directory\n-      if (dstKey.startsWith(srcKey)) {\n-        throw new RenameFailedException(srcKey, dstKey,\n-            \"cannot rename a directory to a subdirectory of itself \");\n-      }\n-\n-      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n-      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n-        // delete unnecessary fake directory.\n-        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n-      }\n-\n-      Path parentPath \u003d keyToQualifiedPath(srcKey);\n-      RemoteIterator\u003cS3ALocatedFileStatus\u003e iterator \u003d\n-          listFilesAndEmptyDirectories(parentPath, true);\n-      while (iterator.hasNext()) {\n-        S3ALocatedFileStatus status \u003d iterator.next();\n-        long length \u003d status.getLen();\n-        String key \u003d pathToKey(status.getPath());\n-        if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n-          key +\u003d \"/\";\n-        }\n-        keysToDelete\n-            .add(new DeleteObjectsRequest.KeyVersion(key));\n-        String newDstKey \u003d\n-            dstKey + key.substring(srcKey.length());\n-        S3ObjectAttributes objectAttributes \u003d\n-            createObjectAttributes(status.getPath(),\n-                status.getETag(), status.getVersionId());\n-        S3AReadOpContext readContext \u003d createReadContext(status, inputPolicy,\n-            changeDetectionPolicy, readAhead);\n-        CopyResult copyResult \u003d copyFile(key, newDstKey, length,\n-            objectAttributes, readContext);\n-\n-        if (hasMetadataStore()) {\n-          // with a metadata store, the object entries need to be updated,\n-          // including, potentially, the ancestors\n-          Path childSrc \u003d keyToQualifiedPath(key);\n-          Path childDst \u003d keyToQualifiedPath(newDstKey);\n-          if (objectRepresentsDirectory(key, length)) {\n-            S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n-                childDst, username);\n-          } else {\n-            S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n-                childDst, length, getDefaultBlockSize(childDst), username,\n-                copyResult.getETag(), copyResult.getVersionId());\n-          }\n-          // Ancestor directories may not be listed, so we explicitly add them\n-          S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n-              keyToQualifiedPath(srcKey), childSrc, childDst, username);\n-        }\n-\n-        if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n-          removeKeys(keysToDelete, true, false);\n-        }\n-      }\n-      if (!keysToDelete.isEmpty()) {\n-        removeKeys(keysToDelete, false, false);\n-      }\n-\n-      // We moved all the children, now move the top-level dir\n-      // Empty directory should have been added as the object summary\n-      if (hasMetadataStore()\n-          \u0026\u0026 srcPaths !\u003d null\n-          \u0026\u0026 !srcPaths.contains(src)) {\n-        LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n-            src, dst);\n-        S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n-            username);\n-      }\n-    }\n-\n-    metadataStore.move(srcPaths, dstMetas, ttlTimeProvider);\n-\n-    if (!src.getParent().equals(dst.getParent())) {\n-      LOG.debug(\"source \u0026 dest parents are different; fix up dir markers\");\n-      deleteUnnecessaryFakeDirectories(dst.getParent());\n-      maybeCreateFakeParentDirectory(src);\n-    }\n-    return true;\n+    // Initiate the rename.\n+    // this will call back into this class via the rename callbacks\n+    // and interact directly with any metastore.\n+    RenameOperation renameOperation \u003d new RenameOperation(\n+        createStoreContext(),\n+        src, srcKey, p.getLeft(),\n+        dst, dstKey, p.getRight(),\n+        new RenameOperationCallbacksImpl());\n+    return renameOperation.executeRename();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private long innerRename(Path source, Path dest)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    Path src \u003d qualify(source);\n    Path dst \u003d qualify(dest);\n\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    entryPoint(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    Pair\u003cS3AFileStatus, S3AFileStatus\u003e p \u003d initiateRename(src, dst);\n\n    // Initiate the rename.\n    // this will call back into this class via the rename callbacks\n    // and interact directly with any metastore.\n    RenameOperation renameOperation \u003d new RenameOperation(\n        createStoreContext(),\n        src, srcKey, p.getLeft(),\n        dst, dstKey, p.getRight(),\n        new RenameOperationCallbacksImpl());\n    return renameOperation.executeRename();\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
      "commitDate": "16/06/19 9:05 AM",
      "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "19/05/19 2:29 PM",
      "commitNameOld": "a36274d69947648dbe82721220cc5240ec5d396d",
      "commitAuthorOld": "Ben Roling",
      "daysBetweenCommits": 27.77,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,203 +1,203 @@\n   private boolean innerRename(Path source, Path dest)\n       throws RenameFailedException, FileNotFoundException, IOException,\n         AmazonClientException {\n     Path src \u003d qualify(source);\n     Path dst \u003d qualify(dest);\n \n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     entryPoint(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"source is root directory\");\n     }\n     if (dstKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"dest is root directory\");\n     }\n \n     // get the source file status; this raises a FNFE if there is no source\n     // file.\n     S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n           dst);\n       throw new RenameFailedException(src, dst,\n           \"source and dest refer to the same file or directory\")\n           .withExitCode(srcStatus.isFile());\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d innerGetFileStatus(dst, true);\n       // if there is no destination entry, an exception is raised.\n       // hence this code sequence can assume that there is something\n       // at the end of the path; the only detail being what it is and\n       // whether or not it can be the destination of the rename.\n       if (srcStatus.isDirectory()) {\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"source is a directory and dest is a file\")\n               .withExitCode(srcStatus.isFile());\n         } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n           throw new RenameFailedException(src, dst,\n               \"Destination is a non-empty directory\")\n               .withExitCode(false);\n         }\n         // at this point the destination is an empty directory\n       } else {\n         // source is a file. The destination must be a directory,\n         // empty or not\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"Cannot rename onto an existing file\")\n               .withExitCode(false);\n         }\n       }\n \n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n               false);\n           if (!dstParentStatus.isDirectory()) {\n             throw new RenameFailedException(src, dst,\n                 \"destination parent is not a directory\");\n           }\n         } catch (FileNotFoundException e2) {\n           throw new RenameFailedException(src, dst,\n               \"destination has no parent \");\n         }\n       }\n     }\n \n     // If we have a MetadataStore, track deletions/creations.\n     Collection\u003cPath\u003e srcPaths \u003d null;\n     List\u003cPathMetadata\u003e dstMetas \u003d null;\n     if (hasMetadataStore()) {\n       srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n       dstMetas \u003d new ArrayList\u003c\u003e();\n     }\n     // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n     // TODO S3Guard: performance: mark destination dirs as authoritative\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       long length \u003d srcStatus.getLen();\n       S3ObjectAttributes objectAttributes \u003d\n           createObjectAttributes(srcStatus.getPath(),\n               srcStatus.getETag(), srcStatus.getVersionId());\n       S3AReadOpContext readContext \u003d createReadContext(srcStatus, inputPolicy,\n           changeDetectionPolicy, readAhead);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d maybeAddTrailingSlash(dstKey);\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         CopyResult copyResult \u003d copyFile(srcKey, newDstKey, length,\n             objectAttributes, readContext);\n         S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n             keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n             username, copyResult.getETag(), copyResult.getVersionId());\n       } else {\n         CopyResult copyResult \u003d copyFile(srcKey, dstKey, srcStatus.getLen(),\n             objectAttributes, readContext);\n         S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n             length, getDefaultBlockSize(dst), username,\n             copyResult.getETag(), copyResult.getVersionId());\n       }\n       innerDelete(srcStatus, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       dstKey \u003d maybeAddTrailingSlash(dstKey);\n       srcKey \u003d maybeAddTrailingSlash(srcKey);\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         throw new RenameFailedException(srcKey, dstKey,\n             \"cannot rename a directory to a subdirectory of itself \");\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       Path parentPath \u003d keyToQualifiedPath(srcKey);\n       RemoteIterator\u003cS3ALocatedFileStatus\u003e iterator \u003d\n           listFilesAndEmptyDirectories(parentPath, true);\n       while (iterator.hasNext()) {\n         S3ALocatedFileStatus status \u003d iterator.next();\n         long length \u003d status.getLen();\n         String key \u003d pathToKey(status.getPath());\n         if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n           key +\u003d \"/\";\n         }\n         keysToDelete\n             .add(new DeleteObjectsRequest.KeyVersion(key));\n         String newDstKey \u003d\n             dstKey + key.substring(srcKey.length());\n         S3ObjectAttributes objectAttributes \u003d\n             createObjectAttributes(status.getPath(),\n                 status.getETag(), status.getVersionId());\n         S3AReadOpContext readContext \u003d createReadContext(status, inputPolicy,\n             changeDetectionPolicy, readAhead);\n         CopyResult copyResult \u003d copyFile(key, newDstKey, length,\n             objectAttributes, readContext);\n \n         if (hasMetadataStore()) {\n           // with a metadata store, the object entries need to be updated,\n           // including, potentially, the ancestors\n           Path childSrc \u003d keyToQualifiedPath(key);\n           Path childDst \u003d keyToQualifiedPath(newDstKey);\n           if (objectRepresentsDirectory(key, length)) {\n             S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n                 childDst, username);\n           } else {\n             S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n                 childDst, length, getDefaultBlockSize(childDst), username,\n                 copyResult.getETag(), copyResult.getVersionId());\n           }\n           // Ancestor directories may not be listed, so we explicitly add them\n           S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n               keyToQualifiedPath(srcKey), childSrc, childDst, username);\n         }\n \n         if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n           removeKeys(keysToDelete, true, false);\n         }\n       }\n       if (!keysToDelete.isEmpty()) {\n         removeKeys(keysToDelete, false, false);\n       }\n \n       // We moved all the children, now move the top-level dir\n       // Empty directory should have been added as the object summary\n       if (hasMetadataStore()\n           \u0026\u0026 srcPaths !\u003d null\n           \u0026\u0026 !srcPaths.contains(src)) {\n         LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n             src, dst);\n         S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n             username);\n       }\n     }\n \n-    metadataStore.move(srcPaths, dstMetas);\n+    metadataStore.move(srcPaths, dstMetas, ttlTimeProvider);\n \n     if (!src.getParent().equals(dst.getParent())) {\n       LOG.debug(\"source \u0026 dest parents are different; fix up dir markers\");\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       maybeCreateFakeParentDirectory(src);\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerRename(Path source, Path dest)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    Path src \u003d qualify(source);\n    Path dst \u003d qualify(dest);\n\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    entryPoint(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"source is root directory\");\n    }\n    if (dstKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"dest is root directory\");\n    }\n\n    // get the source file status; this raises a FNFE if there is no source\n    // file.\n    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n          dst);\n      throw new RenameFailedException(src, dst,\n          \"source and dest refer to the same file or directory\")\n          .withExitCode(srcStatus.isFile());\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d innerGetFileStatus(dst, true);\n      // if there is no destination entry, an exception is raised.\n      // hence this code sequence can assume that there is something\n      // at the end of the path; the only detail being what it is and\n      // whether or not it can be the destination of the rename.\n      if (srcStatus.isDirectory()) {\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"source is a directory and dest is a file\")\n              .withExitCode(srcStatus.isFile());\n        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n          throw new RenameFailedException(src, dst,\n              \"Destination is a non-empty directory\")\n              .withExitCode(false);\n        }\n        // at this point the destination is an empty directory\n      } else {\n        // source is a file. The destination must be a directory,\n        // empty or not\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"Cannot rename onto an existing file\")\n              .withExitCode(false);\n        }\n      }\n\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n              false);\n          if (!dstParentStatus.isDirectory()) {\n            throw new RenameFailedException(src, dst,\n                \"destination parent is not a directory\");\n          }\n        } catch (FileNotFoundException e2) {\n          throw new RenameFailedException(src, dst,\n              \"destination has no parent \");\n        }\n      }\n    }\n\n    // If we have a MetadataStore, track deletions/creations.\n    Collection\u003cPath\u003e srcPaths \u003d null;\n    List\u003cPathMetadata\u003e dstMetas \u003d null;\n    if (hasMetadataStore()) {\n      srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n      dstMetas \u003d new ArrayList\u003c\u003e();\n    }\n    // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n    // TODO S3Guard: performance: mark destination dirs as authoritative\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      long length \u003d srcStatus.getLen();\n      S3ObjectAttributes objectAttributes \u003d\n          createObjectAttributes(srcStatus.getPath(),\n              srcStatus.getETag(), srcStatus.getVersionId());\n      S3AReadOpContext readContext \u003d createReadContext(srcStatus, inputPolicy,\n          changeDetectionPolicy, readAhead);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d maybeAddTrailingSlash(dstKey);\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        CopyResult copyResult \u003d copyFile(srcKey, newDstKey, length,\n            objectAttributes, readContext);\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n            keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n            username, copyResult.getETag(), copyResult.getVersionId());\n      } else {\n        CopyResult copyResult \u003d copyFile(srcKey, dstKey, srcStatus.getLen(),\n            objectAttributes, readContext);\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n            length, getDefaultBlockSize(dst), username,\n            copyResult.getETag(), copyResult.getVersionId());\n      }\n      innerDelete(srcStatus, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      dstKey \u003d maybeAddTrailingSlash(dstKey);\n      srcKey \u003d maybeAddTrailingSlash(srcKey);\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        throw new RenameFailedException(srcKey, dstKey,\n            \"cannot rename a directory to a subdirectory of itself \");\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      Path parentPath \u003d keyToQualifiedPath(srcKey);\n      RemoteIterator\u003cS3ALocatedFileStatus\u003e iterator \u003d\n          listFilesAndEmptyDirectories(parentPath, true);\n      while (iterator.hasNext()) {\n        S3ALocatedFileStatus status \u003d iterator.next();\n        long length \u003d status.getLen();\n        String key \u003d pathToKey(status.getPath());\n        if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n          key +\u003d \"/\";\n        }\n        keysToDelete\n            .add(new DeleteObjectsRequest.KeyVersion(key));\n        String newDstKey \u003d\n            dstKey + key.substring(srcKey.length());\n        S3ObjectAttributes objectAttributes \u003d\n            createObjectAttributes(status.getPath(),\n                status.getETag(), status.getVersionId());\n        S3AReadOpContext readContext \u003d createReadContext(status, inputPolicy,\n            changeDetectionPolicy, readAhead);\n        CopyResult copyResult \u003d copyFile(key, newDstKey, length,\n            objectAttributes, readContext);\n\n        if (hasMetadataStore()) {\n          // with a metadata store, the object entries need to be updated,\n          // including, potentially, the ancestors\n          Path childSrc \u003d keyToQualifiedPath(key);\n          Path childDst \u003d keyToQualifiedPath(newDstKey);\n          if (objectRepresentsDirectory(key, length)) {\n            S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, username);\n          } else {\n            S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, length, getDefaultBlockSize(childDst), username,\n                copyResult.getETag(), copyResult.getVersionId());\n          }\n          // Ancestor directories may not be listed, so we explicitly add them\n          S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n              keyToQualifiedPath(srcKey), childSrc, childDst, username);\n        }\n\n        if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n          removeKeys(keysToDelete, true, false);\n        }\n      }\n      if (!keysToDelete.isEmpty()) {\n        removeKeys(keysToDelete, false, false);\n      }\n\n      // We moved all the children, now move the top-level dir\n      // Empty directory should have been added as the object summary\n      if (hasMetadataStore()\n          \u0026\u0026 srcPaths !\u003d null\n          \u0026\u0026 !srcPaths.contains(src)) {\n        LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n            src, dst);\n        S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n            username);\n      }\n    }\n\n    metadataStore.move(srcPaths, dstMetas, ttlTimeProvider);\n\n    if (!src.getParent().equals(dst.getParent())) {\n      LOG.debug(\"source \u0026 dest parents are different; fix up dir markers\");\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      maybeCreateFakeParentDirectory(src);\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "a36274d69947648dbe82721220cc5240ec5d396d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
      "commitDate": "19/05/19 2:29 PM",
      "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
      "commitAuthor": "Ben Roling",
      "commitDateOld": "30/04/19 3:53 AM",
      "commitNameOld": "0af4011580878566213016af0c32633eabd15100",
      "commitAuthorOld": "Ben Roling",
      "daysBetweenCommits": 19.44,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,188 +1,203 @@\n   private boolean innerRename(Path source, Path dest)\n       throws RenameFailedException, FileNotFoundException, IOException,\n         AmazonClientException {\n     Path src \u003d qualify(source);\n     Path dst \u003d qualify(dest);\n \n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     entryPoint(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"source is root directory\");\n     }\n     if (dstKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"dest is root directory\");\n     }\n \n     // get the source file status; this raises a FNFE if there is no source\n     // file.\n     S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n           dst);\n       throw new RenameFailedException(src, dst,\n           \"source and dest refer to the same file or directory\")\n           .withExitCode(srcStatus.isFile());\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d innerGetFileStatus(dst, true);\n       // if there is no destination entry, an exception is raised.\n       // hence this code sequence can assume that there is something\n       // at the end of the path; the only detail being what it is and\n       // whether or not it can be the destination of the rename.\n       if (srcStatus.isDirectory()) {\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"source is a directory and dest is a file\")\n               .withExitCode(srcStatus.isFile());\n         } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n           throw new RenameFailedException(src, dst,\n               \"Destination is a non-empty directory\")\n               .withExitCode(false);\n         }\n         // at this point the destination is an empty directory\n       } else {\n         // source is a file. The destination must be a directory,\n         // empty or not\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"Cannot rename onto an existing file\")\n               .withExitCode(false);\n         }\n       }\n \n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n               false);\n           if (!dstParentStatus.isDirectory()) {\n             throw new RenameFailedException(src, dst,\n                 \"destination parent is not a directory\");\n           }\n         } catch (FileNotFoundException e2) {\n           throw new RenameFailedException(src, dst,\n               \"destination has no parent \");\n         }\n       }\n     }\n \n     // If we have a MetadataStore, track deletions/creations.\n     Collection\u003cPath\u003e srcPaths \u003d null;\n     List\u003cPathMetadata\u003e dstMetas \u003d null;\n     if (hasMetadataStore()) {\n       srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n       dstMetas \u003d new ArrayList\u003c\u003e();\n     }\n     // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n     // TODO S3Guard: performance: mark destination dirs as authoritative\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       long length \u003d srcStatus.getLen();\n+      S3ObjectAttributes objectAttributes \u003d\n+          createObjectAttributes(srcStatus.getPath(),\n+              srcStatus.getETag(), srcStatus.getVersionId());\n+      S3AReadOpContext readContext \u003d createReadContext(srcStatus, inputPolicy,\n+          changeDetectionPolicy, readAhead);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d maybeAddTrailingSlash(dstKey);\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n-        copyFile(srcKey, newDstKey, length);\n+        CopyResult copyResult \u003d copyFile(srcKey, newDstKey, length,\n+            objectAttributes, readContext);\n         S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n             keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n-            username);\n+            username, copyResult.getETag(), copyResult.getVersionId());\n       } else {\n-        copyFile(srcKey, dstKey, srcStatus.getLen());\n+        CopyResult copyResult \u003d copyFile(srcKey, dstKey, srcStatus.getLen(),\n+            objectAttributes, readContext);\n         S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n-            length, getDefaultBlockSize(dst), username);\n+            length, getDefaultBlockSize(dst), username,\n+            copyResult.getETag(), copyResult.getVersionId());\n       }\n       innerDelete(srcStatus, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       dstKey \u003d maybeAddTrailingSlash(dstKey);\n       srcKey \u003d maybeAddTrailingSlash(srcKey);\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         throw new RenameFailedException(srcKey, dstKey,\n             \"cannot rename a directory to a subdirectory of itself \");\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       Path parentPath \u003d keyToQualifiedPath(srcKey);\n-      RemoteIterator\u003cLocatedFileStatus\u003e iterator \u003d listFilesAndEmptyDirectories(\n-          parentPath, true);\n+      RemoteIterator\u003cS3ALocatedFileStatus\u003e iterator \u003d\n+          listFilesAndEmptyDirectories(parentPath, true);\n       while (iterator.hasNext()) {\n-        LocatedFileStatus status \u003d iterator.next();\n+        S3ALocatedFileStatus status \u003d iterator.next();\n         long length \u003d status.getLen();\n         String key \u003d pathToKey(status.getPath());\n         if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n           key +\u003d \"/\";\n         }\n         keysToDelete\n             .add(new DeleteObjectsRequest.KeyVersion(key));\n         String newDstKey \u003d\n             dstKey + key.substring(srcKey.length());\n-        copyFile(key, newDstKey, length);\n+        S3ObjectAttributes objectAttributes \u003d\n+            createObjectAttributes(status.getPath(),\n+                status.getETag(), status.getVersionId());\n+        S3AReadOpContext readContext \u003d createReadContext(status, inputPolicy,\n+            changeDetectionPolicy, readAhead);\n+        CopyResult copyResult \u003d copyFile(key, newDstKey, length,\n+            objectAttributes, readContext);\n \n         if (hasMetadataStore()) {\n           // with a metadata store, the object entries need to be updated,\n           // including, potentially, the ancestors\n           Path childSrc \u003d keyToQualifiedPath(key);\n           Path childDst \u003d keyToQualifiedPath(newDstKey);\n           if (objectRepresentsDirectory(key, length)) {\n             S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n                 childDst, username);\n           } else {\n             S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n-                childDst, length, getDefaultBlockSize(childDst), username);\n+                childDst, length, getDefaultBlockSize(childDst), username,\n+                copyResult.getETag(), copyResult.getVersionId());\n           }\n           // Ancestor directories may not be listed, so we explicitly add them\n           S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n               keyToQualifiedPath(srcKey), childSrc, childDst, username);\n         }\n \n         if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n           removeKeys(keysToDelete, true, false);\n         }\n       }\n       if (!keysToDelete.isEmpty()) {\n         removeKeys(keysToDelete, false, false);\n       }\n \n       // We moved all the children, now move the top-level dir\n       // Empty directory should have been added as the object summary\n       if (hasMetadataStore()\n           \u0026\u0026 srcPaths !\u003d null\n           \u0026\u0026 !srcPaths.contains(src)) {\n         LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n             src, dst);\n         S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n             username);\n       }\n     }\n \n     metadataStore.move(srcPaths, dstMetas);\n \n     if (!src.getParent().equals(dst.getParent())) {\n       LOG.debug(\"source \u0026 dest parents are different; fix up dir markers\");\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       maybeCreateFakeParentDirectory(src);\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerRename(Path source, Path dest)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    Path src \u003d qualify(source);\n    Path dst \u003d qualify(dest);\n\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    entryPoint(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"source is root directory\");\n    }\n    if (dstKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"dest is root directory\");\n    }\n\n    // get the source file status; this raises a FNFE if there is no source\n    // file.\n    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n          dst);\n      throw new RenameFailedException(src, dst,\n          \"source and dest refer to the same file or directory\")\n          .withExitCode(srcStatus.isFile());\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d innerGetFileStatus(dst, true);\n      // if there is no destination entry, an exception is raised.\n      // hence this code sequence can assume that there is something\n      // at the end of the path; the only detail being what it is and\n      // whether or not it can be the destination of the rename.\n      if (srcStatus.isDirectory()) {\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"source is a directory and dest is a file\")\n              .withExitCode(srcStatus.isFile());\n        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n          throw new RenameFailedException(src, dst,\n              \"Destination is a non-empty directory\")\n              .withExitCode(false);\n        }\n        // at this point the destination is an empty directory\n      } else {\n        // source is a file. The destination must be a directory,\n        // empty or not\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"Cannot rename onto an existing file\")\n              .withExitCode(false);\n        }\n      }\n\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n              false);\n          if (!dstParentStatus.isDirectory()) {\n            throw new RenameFailedException(src, dst,\n                \"destination parent is not a directory\");\n          }\n        } catch (FileNotFoundException e2) {\n          throw new RenameFailedException(src, dst,\n              \"destination has no parent \");\n        }\n      }\n    }\n\n    // If we have a MetadataStore, track deletions/creations.\n    Collection\u003cPath\u003e srcPaths \u003d null;\n    List\u003cPathMetadata\u003e dstMetas \u003d null;\n    if (hasMetadataStore()) {\n      srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n      dstMetas \u003d new ArrayList\u003c\u003e();\n    }\n    // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n    // TODO S3Guard: performance: mark destination dirs as authoritative\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      long length \u003d srcStatus.getLen();\n      S3ObjectAttributes objectAttributes \u003d\n          createObjectAttributes(srcStatus.getPath(),\n              srcStatus.getETag(), srcStatus.getVersionId());\n      S3AReadOpContext readContext \u003d createReadContext(srcStatus, inputPolicy,\n          changeDetectionPolicy, readAhead);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d maybeAddTrailingSlash(dstKey);\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        CopyResult copyResult \u003d copyFile(srcKey, newDstKey, length,\n            objectAttributes, readContext);\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n            keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n            username, copyResult.getETag(), copyResult.getVersionId());\n      } else {\n        CopyResult copyResult \u003d copyFile(srcKey, dstKey, srcStatus.getLen(),\n            objectAttributes, readContext);\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n            length, getDefaultBlockSize(dst), username,\n            copyResult.getETag(), copyResult.getVersionId());\n      }\n      innerDelete(srcStatus, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      dstKey \u003d maybeAddTrailingSlash(dstKey);\n      srcKey \u003d maybeAddTrailingSlash(srcKey);\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        throw new RenameFailedException(srcKey, dstKey,\n            \"cannot rename a directory to a subdirectory of itself \");\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      Path parentPath \u003d keyToQualifiedPath(srcKey);\n      RemoteIterator\u003cS3ALocatedFileStatus\u003e iterator \u003d\n          listFilesAndEmptyDirectories(parentPath, true);\n      while (iterator.hasNext()) {\n        S3ALocatedFileStatus status \u003d iterator.next();\n        long length \u003d status.getLen();\n        String key \u003d pathToKey(status.getPath());\n        if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n          key +\u003d \"/\";\n        }\n        keysToDelete\n            .add(new DeleteObjectsRequest.KeyVersion(key));\n        String newDstKey \u003d\n            dstKey + key.substring(srcKey.length());\n        S3ObjectAttributes objectAttributes \u003d\n            createObjectAttributes(status.getPath(),\n                status.getETag(), status.getVersionId());\n        S3AReadOpContext readContext \u003d createReadContext(status, inputPolicy,\n            changeDetectionPolicy, readAhead);\n        CopyResult copyResult \u003d copyFile(key, newDstKey, length,\n            objectAttributes, readContext);\n\n        if (hasMetadataStore()) {\n          // with a metadata store, the object entries need to be updated,\n          // including, potentially, the ancestors\n          Path childSrc \u003d keyToQualifiedPath(key);\n          Path childDst \u003d keyToQualifiedPath(newDstKey);\n          if (objectRepresentsDirectory(key, length)) {\n            S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, username);\n          } else {\n            S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, length, getDefaultBlockSize(childDst), username,\n                copyResult.getETag(), copyResult.getVersionId());\n          }\n          // Ancestor directories may not be listed, so we explicitly add them\n          S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n              keyToQualifiedPath(srcKey), childSrc, childDst, username);\n        }\n\n        if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n          removeKeys(keysToDelete, true, false);\n        }\n      }\n      if (!keysToDelete.isEmpty()) {\n        removeKeys(keysToDelete, false, false);\n      }\n\n      // We moved all the children, now move the top-level dir\n      // Empty directory should have been added as the object summary\n      if (hasMetadataStore()\n          \u0026\u0026 srcPaths !\u003d null\n          \u0026\u0026 !srcPaths.contains(src)) {\n        LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n            src, dst);\n        S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n            username);\n      }\n    }\n\n    metadataStore.move(srcPaths, dstMetas);\n\n    if (!src.getParent().equals(dst.getParent())) {\n      LOG.debug(\"source \u0026 dest parents are different; fix up dir markers\");\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      maybeCreateFakeParentDirectory(src);\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15079. ITestS3AFileOperationCost#testFakeDirectoryDeletion failing\nafter OutputCommitter patch.\nContributed by Steve Loughran\n",
      "commitDate": "15/01/18 3:33 AM",
      "commitName": "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "09/01/18 10:46 AM",
      "commitNameOld": "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 5.7,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,188 @@\n   private boolean innerRename(Path source, Path dest)\n       throws RenameFailedException, FileNotFoundException, IOException,\n         AmazonClientException {\n     Path src \u003d qualify(source);\n     Path dst \u003d qualify(dest);\n \n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     entryPoint(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"source is root directory\");\n     }\n     if (dstKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"dest is root directory\");\n     }\n \n     // get the source file status; this raises a FNFE if there is no source\n     // file.\n     S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n           dst);\n       throw new RenameFailedException(src, dst,\n           \"source and dest refer to the same file or directory\")\n           .withExitCode(srcStatus.isFile());\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d innerGetFileStatus(dst, true);\n       // if there is no destination entry, an exception is raised.\n       // hence this code sequence can assume that there is something\n       // at the end of the path; the only detail being what it is and\n       // whether or not it can be the destination of the rename.\n       if (srcStatus.isDirectory()) {\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"source is a directory and dest is a file\")\n               .withExitCode(srcStatus.isFile());\n         } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n           throw new RenameFailedException(src, dst,\n               \"Destination is a non-empty directory\")\n               .withExitCode(false);\n         }\n         // at this point the destination is an empty directory\n       } else {\n         // source is a file. The destination must be a directory,\n         // empty or not\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"Cannot rename onto an existing file\")\n               .withExitCode(false);\n         }\n       }\n \n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n               false);\n           if (!dstParentStatus.isDirectory()) {\n             throw new RenameFailedException(src, dst,\n                 \"destination parent is not a directory\");\n           }\n         } catch (FileNotFoundException e2) {\n           throw new RenameFailedException(src, dst,\n               \"destination has no parent \");\n         }\n       }\n     }\n \n     // If we have a MetadataStore, track deletions/creations.\n     Collection\u003cPath\u003e srcPaths \u003d null;\n     List\u003cPathMetadata\u003e dstMetas \u003d null;\n     if (hasMetadataStore()) {\n       srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n       dstMetas \u003d new ArrayList\u003c\u003e();\n     }\n     // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n     // TODO S3Guard: performance: mark destination dirs as authoritative\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       long length \u003d srcStatus.getLen();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n-        String newDstKey \u003d dstKey;\n-        if (!newDstKey.endsWith(\"/\")) {\n-          newDstKey \u003d newDstKey + \"/\";\n-        }\n+        String newDstKey \u003d maybeAddTrailingSlash(dstKey);\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey, length);\n         S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n             keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n             username);\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n         S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n             length, getDefaultBlockSize(dst), username);\n       }\n       innerDelete(srcStatus, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n-      if (!dstKey.endsWith(\"/\")) {\n-        dstKey \u003d dstKey + \"/\";\n-      }\n-\n-      if (!srcKey.endsWith(\"/\")) {\n-        srcKey \u003d srcKey + \"/\";\n-      }\n+      dstKey \u003d maybeAddTrailingSlash(dstKey);\n+      srcKey \u003d maybeAddTrailingSlash(srcKey);\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         throw new RenameFailedException(srcKey, dstKey,\n             \"cannot rename a directory to a subdirectory of itself \");\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       Path parentPath \u003d keyToQualifiedPath(srcKey);\n       RemoteIterator\u003cLocatedFileStatus\u003e iterator \u003d listFilesAndEmptyDirectories(\n           parentPath, true);\n       while (iterator.hasNext()) {\n         LocatedFileStatus status \u003d iterator.next();\n         long length \u003d status.getLen();\n         String key \u003d pathToKey(status.getPath());\n         if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n           key +\u003d \"/\";\n         }\n         keysToDelete\n             .add(new DeleteObjectsRequest.KeyVersion(key));\n         String newDstKey \u003d\n             dstKey + key.substring(srcKey.length());\n         copyFile(key, newDstKey, length);\n \n         if (hasMetadataStore()) {\n           // with a metadata store, the object entries need to be updated,\n           // including, potentially, the ancestors\n           Path childSrc \u003d keyToQualifiedPath(key);\n           Path childDst \u003d keyToQualifiedPath(newDstKey);\n           if (objectRepresentsDirectory(key, length)) {\n             S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n                 childDst, username);\n           } else {\n             S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n                 childDst, length, getDefaultBlockSize(childDst), username);\n           }\n           // Ancestor directories may not be listed, so we explicitly add them\n           S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n               keyToQualifiedPath(srcKey), childSrc, childDst, username);\n         }\n \n         if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n           removeKeys(keysToDelete, true, false);\n         }\n       }\n       if (!keysToDelete.isEmpty()) {\n         removeKeys(keysToDelete, false, false);\n       }\n \n       // We moved all the children, now move the top-level dir\n       // Empty directory should have been added as the object summary\n       if (hasMetadataStore()\n           \u0026\u0026 srcPaths !\u003d null\n           \u0026\u0026 !srcPaths.contains(src)) {\n         LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n             src, dst);\n         S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n             username);\n       }\n     }\n \n     metadataStore.move(srcPaths, dstMetas);\n \n-    if (src.getParent() !\u003d dst.getParent()) {\n+    if (!src.getParent().equals(dst.getParent())) {\n+      LOG.debug(\"source \u0026 dest parents are different; fix up dir markers\");\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       maybeCreateFakeParentDirectory(src);\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerRename(Path source, Path dest)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    Path src \u003d qualify(source);\n    Path dst \u003d qualify(dest);\n\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    entryPoint(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"source is root directory\");\n    }\n    if (dstKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"dest is root directory\");\n    }\n\n    // get the source file status; this raises a FNFE if there is no source\n    // file.\n    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n          dst);\n      throw new RenameFailedException(src, dst,\n          \"source and dest refer to the same file or directory\")\n          .withExitCode(srcStatus.isFile());\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d innerGetFileStatus(dst, true);\n      // if there is no destination entry, an exception is raised.\n      // hence this code sequence can assume that there is something\n      // at the end of the path; the only detail being what it is and\n      // whether or not it can be the destination of the rename.\n      if (srcStatus.isDirectory()) {\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"source is a directory and dest is a file\")\n              .withExitCode(srcStatus.isFile());\n        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n          throw new RenameFailedException(src, dst,\n              \"Destination is a non-empty directory\")\n              .withExitCode(false);\n        }\n        // at this point the destination is an empty directory\n      } else {\n        // source is a file. The destination must be a directory,\n        // empty or not\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"Cannot rename onto an existing file\")\n              .withExitCode(false);\n        }\n      }\n\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n              false);\n          if (!dstParentStatus.isDirectory()) {\n            throw new RenameFailedException(src, dst,\n                \"destination parent is not a directory\");\n          }\n        } catch (FileNotFoundException e2) {\n          throw new RenameFailedException(src, dst,\n              \"destination has no parent \");\n        }\n      }\n    }\n\n    // If we have a MetadataStore, track deletions/creations.\n    Collection\u003cPath\u003e srcPaths \u003d null;\n    List\u003cPathMetadata\u003e dstMetas \u003d null;\n    if (hasMetadataStore()) {\n      srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n      dstMetas \u003d new ArrayList\u003c\u003e();\n    }\n    // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n    // TODO S3Guard: performance: mark destination dirs as authoritative\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      long length \u003d srcStatus.getLen();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d maybeAddTrailingSlash(dstKey);\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, length);\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n            keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n            username);\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n            length, getDefaultBlockSize(dst), username);\n      }\n      innerDelete(srcStatus, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      dstKey \u003d maybeAddTrailingSlash(dstKey);\n      srcKey \u003d maybeAddTrailingSlash(srcKey);\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        throw new RenameFailedException(srcKey, dstKey,\n            \"cannot rename a directory to a subdirectory of itself \");\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      Path parentPath \u003d keyToQualifiedPath(srcKey);\n      RemoteIterator\u003cLocatedFileStatus\u003e iterator \u003d listFilesAndEmptyDirectories(\n          parentPath, true);\n      while (iterator.hasNext()) {\n        LocatedFileStatus status \u003d iterator.next();\n        long length \u003d status.getLen();\n        String key \u003d pathToKey(status.getPath());\n        if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n          key +\u003d \"/\";\n        }\n        keysToDelete\n            .add(new DeleteObjectsRequest.KeyVersion(key));\n        String newDstKey \u003d\n            dstKey + key.substring(srcKey.length());\n        copyFile(key, newDstKey, length);\n\n        if (hasMetadataStore()) {\n          // with a metadata store, the object entries need to be updated,\n          // including, potentially, the ancestors\n          Path childSrc \u003d keyToQualifiedPath(key);\n          Path childDst \u003d keyToQualifiedPath(newDstKey);\n          if (objectRepresentsDirectory(key, length)) {\n            S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, username);\n          } else {\n            S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, length, getDefaultBlockSize(childDst), username);\n          }\n          // Ancestor directories may not be listed, so we explicitly add them\n          S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n              keyToQualifiedPath(srcKey), childSrc, childDst, username);\n        }\n\n        if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n          removeKeys(keysToDelete, true, false);\n        }\n      }\n      if (!keysToDelete.isEmpty()) {\n        removeKeys(keysToDelete, false, false);\n      }\n\n      // We moved all the children, now move the top-level dir\n      // Empty directory should have been added as the object summary\n      if (hasMetadataStore()\n          \u0026\u0026 srcPaths !\u003d null\n          \u0026\u0026 !srcPaths.contains(src)) {\n        LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n            src, dst);\n        S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n            username);\n      }\n    }\n\n    metadataStore.move(srcPaths, dstMetas);\n\n    if (!src.getParent().equals(dst.getParent())) {\n      LOG.debug(\"source \u0026 dest parents are different; fix up dir markers\");\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      maybeCreateFakeParentDirectory(src);\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "ef450df443f1dea1c52082cf281f25db7141972f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15113. NPE in S3A getFileStatus: null instrumentation on using closed instance.\nContributed by Steve Loughran.\n",
      "commitDate": "21/12/17 6:15 AM",
      "commitName": "ef450df443f1dea1c52082cf281f25db7141972f",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/12/17 1:19 PM",
      "commitNameOld": "35ad9b1dd279b769381ea1625d9bf776c309c5cb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 2.71,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private boolean innerRename(Path source, Path dest)\n       throws RenameFailedException, FileNotFoundException, IOException,\n         AmazonClientException {\n     Path src \u003d qualify(source);\n     Path dst \u003d qualify(dest);\n \n     LOG.debug(\"Rename path {} to {}\", src, dst);\n-    incrementStatistic(INVOCATION_RENAME);\n+    entryPoint(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"source is root directory\");\n     }\n     if (dstKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"dest is root directory\");\n     }\n \n     // get the source file status; this raises a FNFE if there is no source\n     // file.\n     S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n           dst);\n       throw new RenameFailedException(src, dst,\n           \"source and dest refer to the same file or directory\")\n           .withExitCode(srcStatus.isFile());\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d innerGetFileStatus(dst, true);\n       // if there is no destination entry, an exception is raised.\n       // hence this code sequence can assume that there is something\n       // at the end of the path; the only detail being what it is and\n       // whether or not it can be the destination of the rename.\n       if (srcStatus.isDirectory()) {\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"source is a directory and dest is a file\")\n               .withExitCode(srcStatus.isFile());\n         } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n           throw new RenameFailedException(src, dst,\n               \"Destination is a non-empty directory\")\n               .withExitCode(false);\n         }\n         // at this point the destination is an empty directory\n       } else {\n         // source is a file. The destination must be a directory,\n         // empty or not\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"Cannot rename onto an existing file\")\n               .withExitCode(false);\n         }\n       }\n \n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n               false);\n           if (!dstParentStatus.isDirectory()) {\n             throw new RenameFailedException(src, dst,\n                 \"destination parent is not a directory\");\n           }\n         } catch (FileNotFoundException e2) {\n           throw new RenameFailedException(src, dst,\n               \"destination has no parent \");\n         }\n       }\n     }\n \n     // If we have a MetadataStore, track deletions/creations.\n     Collection\u003cPath\u003e srcPaths \u003d null;\n     List\u003cPathMetadata\u003e dstMetas \u003d null;\n     if (hasMetadataStore()) {\n       srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n       dstMetas \u003d new ArrayList\u003c\u003e();\n     }\n     // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n     // TODO S3Guard: performance: mark destination dirs as authoritative\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       long length \u003d srcStatus.getLen();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey, length);\n         S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n             keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n             username);\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n         S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n             length, getDefaultBlockSize(dst), username);\n       }\n       innerDelete(srcStatus, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         throw new RenameFailedException(srcKey, dstKey,\n             \"cannot rename a directory to a subdirectory of itself \");\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       Path parentPath \u003d keyToQualifiedPath(srcKey);\n       RemoteIterator\u003cLocatedFileStatus\u003e iterator \u003d listFilesAndEmptyDirectories(\n           parentPath, true);\n       while (iterator.hasNext()) {\n         LocatedFileStatus status \u003d iterator.next();\n         long length \u003d status.getLen();\n         String key \u003d pathToKey(status.getPath());\n         if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n           key +\u003d \"/\";\n         }\n         keysToDelete\n             .add(new DeleteObjectsRequest.KeyVersion(key));\n         String newDstKey \u003d\n             dstKey + key.substring(srcKey.length());\n         copyFile(key, newDstKey, length);\n \n         if (hasMetadataStore()) {\n           // with a metadata store, the object entries need to be updated,\n           // including, potentially, the ancestors\n           Path childSrc \u003d keyToQualifiedPath(key);\n           Path childDst \u003d keyToQualifiedPath(newDstKey);\n           if (objectRepresentsDirectory(key, length)) {\n             S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n                 childDst, username);\n           } else {\n             S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n                 childDst, length, getDefaultBlockSize(childDst), username);\n           }\n           // Ancestor directories may not be listed, so we explicitly add them\n           S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n               keyToQualifiedPath(srcKey), childSrc, childDst, username);\n         }\n \n         if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n           removeKeys(keysToDelete, true, false);\n         }\n       }\n       if (!keysToDelete.isEmpty()) {\n         removeKeys(keysToDelete, false, false);\n       }\n \n       // We moved all the children, now move the top-level dir\n       // Empty directory should have been added as the object summary\n       if (hasMetadataStore()\n           \u0026\u0026 srcPaths !\u003d null\n           \u0026\u0026 !srcPaths.contains(src)) {\n         LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n             src, dst);\n         S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n             username);\n       }\n     }\n \n     metadataStore.move(srcPaths, dstMetas);\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       maybeCreateFakeParentDirectory(src);\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerRename(Path source, Path dest)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    Path src \u003d qualify(source);\n    Path dst \u003d qualify(dest);\n\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    entryPoint(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"source is root directory\");\n    }\n    if (dstKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"dest is root directory\");\n    }\n\n    // get the source file status; this raises a FNFE if there is no source\n    // file.\n    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n          dst);\n      throw new RenameFailedException(src, dst,\n          \"source and dest refer to the same file or directory\")\n          .withExitCode(srcStatus.isFile());\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d innerGetFileStatus(dst, true);\n      // if there is no destination entry, an exception is raised.\n      // hence this code sequence can assume that there is something\n      // at the end of the path; the only detail being what it is and\n      // whether or not it can be the destination of the rename.\n      if (srcStatus.isDirectory()) {\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"source is a directory and dest is a file\")\n              .withExitCode(srcStatus.isFile());\n        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n          throw new RenameFailedException(src, dst,\n              \"Destination is a non-empty directory\")\n              .withExitCode(false);\n        }\n        // at this point the destination is an empty directory\n      } else {\n        // source is a file. The destination must be a directory,\n        // empty or not\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"Cannot rename onto an existing file\")\n              .withExitCode(false);\n        }\n      }\n\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n              false);\n          if (!dstParentStatus.isDirectory()) {\n            throw new RenameFailedException(src, dst,\n                \"destination parent is not a directory\");\n          }\n        } catch (FileNotFoundException e2) {\n          throw new RenameFailedException(src, dst,\n              \"destination has no parent \");\n        }\n      }\n    }\n\n    // If we have a MetadataStore, track deletions/creations.\n    Collection\u003cPath\u003e srcPaths \u003d null;\n    List\u003cPathMetadata\u003e dstMetas \u003d null;\n    if (hasMetadataStore()) {\n      srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n      dstMetas \u003d new ArrayList\u003c\u003e();\n    }\n    // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n    // TODO S3Guard: performance: mark destination dirs as authoritative\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      long length \u003d srcStatus.getLen();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, length);\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n            keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n            username);\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n            length, getDefaultBlockSize(dst), username);\n      }\n      innerDelete(srcStatus, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        throw new RenameFailedException(srcKey, dstKey,\n            \"cannot rename a directory to a subdirectory of itself \");\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      Path parentPath \u003d keyToQualifiedPath(srcKey);\n      RemoteIterator\u003cLocatedFileStatus\u003e iterator \u003d listFilesAndEmptyDirectories(\n          parentPath, true);\n      while (iterator.hasNext()) {\n        LocatedFileStatus status \u003d iterator.next();\n        long length \u003d status.getLen();\n        String key \u003d pathToKey(status.getPath());\n        if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n          key +\u003d \"/\";\n        }\n        keysToDelete\n            .add(new DeleteObjectsRequest.KeyVersion(key));\n        String newDstKey \u003d\n            dstKey + key.substring(srcKey.length());\n        copyFile(key, newDstKey, length);\n\n        if (hasMetadataStore()) {\n          // with a metadata store, the object entries need to be updated,\n          // including, potentially, the ancestors\n          Path childSrc \u003d keyToQualifiedPath(key);\n          Path childDst \u003d keyToQualifiedPath(newDstKey);\n          if (objectRepresentsDirectory(key, length)) {\n            S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, username);\n          } else {\n            S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, length, getDefaultBlockSize(childDst), username);\n          }\n          // Ancestor directories may not be listed, so we explicitly add them\n          S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n              keyToQualifiedPath(srcKey), childSrc, childDst, username);\n        }\n\n        if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n          removeKeys(keysToDelete, true, false);\n        }\n      }\n      if (!keysToDelete.isEmpty()) {\n        removeKeys(keysToDelete, false, false);\n      }\n\n      // We moved all the children, now move the top-level dir\n      // Empty directory should have been added as the object summary\n      if (hasMetadataStore()\n          \u0026\u0026 srcPaths !\u003d null\n          \u0026\u0026 !srcPaths.contains(src)) {\n        LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n            src, dst);\n        S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n            username);\n      }\n    }\n\n    metadataStore.move(srcPaths, dstMetas);\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      maybeCreateFakeParentDirectory(src);\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "25/09/17 3:59 PM",
      "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 57.69,
      "commitsBetweenForRepo": 477,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,195 +1,195 @@\n   private boolean innerRename(Path source, Path dest)\n       throws RenameFailedException, FileNotFoundException, IOException,\n         AmazonClientException {\n     Path src \u003d qualify(source);\n     Path dst \u003d qualify(dest);\n \n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     incrementStatistic(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"source is root directory\");\n     }\n     if (dstKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"dest is root directory\");\n     }\n \n     // get the source file status; this raises a FNFE if there is no source\n     // file.\n     S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n           dst);\n       throw new RenameFailedException(src, dst,\n           \"source and dest refer to the same file or directory\")\n           .withExitCode(srcStatus.isFile());\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d innerGetFileStatus(dst, true);\n       // if there is no destination entry, an exception is raised.\n       // hence this code sequence can assume that there is something\n       // at the end of the path; the only detail being what it is and\n       // whether or not it can be the destination of the rename.\n       if (srcStatus.isDirectory()) {\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"source is a directory and dest is a file\")\n               .withExitCode(srcStatus.isFile());\n         } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n           throw new RenameFailedException(src, dst,\n               \"Destination is a non-empty directory\")\n               .withExitCode(false);\n         }\n         // at this point the destination is an empty directory\n       } else {\n         // source is a file. The destination must be a directory,\n         // empty or not\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"Cannot rename onto an existing file\")\n               .withExitCode(false);\n         }\n       }\n \n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n               false);\n           if (!dstParentStatus.isDirectory()) {\n             throw new RenameFailedException(src, dst,\n                 \"destination parent is not a directory\");\n           }\n         } catch (FileNotFoundException e2) {\n           throw new RenameFailedException(src, dst,\n               \"destination has no parent \");\n         }\n       }\n     }\n \n     // If we have a MetadataStore, track deletions/creations.\n     Collection\u003cPath\u003e srcPaths \u003d null;\n     List\u003cPathMetadata\u003e dstMetas \u003d null;\n     if (hasMetadataStore()) {\n       srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n       dstMetas \u003d new ArrayList\u003c\u003e();\n     }\n     // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n     // TODO S3Guard: performance: mark destination dirs as authoritative\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       long length \u003d srcStatus.getLen();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey, length);\n         S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n             keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n             username);\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n         S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n             length, getDefaultBlockSize(dst), username);\n       }\n       innerDelete(srcStatus, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         throw new RenameFailedException(srcKey, dstKey,\n             \"cannot rename a directory to a subdirectory of itself \");\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n-      Path parentPath \u003d keyToPath(srcKey);\n+      Path parentPath \u003d keyToQualifiedPath(srcKey);\n       RemoteIterator\u003cLocatedFileStatus\u003e iterator \u003d listFilesAndEmptyDirectories(\n           parentPath, true);\n       while (iterator.hasNext()) {\n         LocatedFileStatus status \u003d iterator.next();\n         long length \u003d status.getLen();\n         String key \u003d pathToKey(status.getPath());\n         if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n           key +\u003d \"/\";\n         }\n         keysToDelete\n             .add(new DeleteObjectsRequest.KeyVersion(key));\n         String newDstKey \u003d\n             dstKey + key.substring(srcKey.length());\n         copyFile(key, newDstKey, length);\n \n         if (hasMetadataStore()) {\n           // with a metadata store, the object entries need to be updated,\n           // including, potentially, the ancestors\n           Path childSrc \u003d keyToQualifiedPath(key);\n           Path childDst \u003d keyToQualifiedPath(newDstKey);\n           if (objectRepresentsDirectory(key, length)) {\n             S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n                 childDst, username);\n           } else {\n             S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n                 childDst, length, getDefaultBlockSize(childDst), username);\n           }\n           // Ancestor directories may not be listed, so we explicitly add them\n           S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n               keyToQualifiedPath(srcKey), childSrc, childDst, username);\n         }\n \n         if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n           removeKeys(keysToDelete, true, false);\n         }\n       }\n       if (!keysToDelete.isEmpty()) {\n         removeKeys(keysToDelete, false, false);\n       }\n \n       // We moved all the children, now move the top-level dir\n       // Empty directory should have been added as the object summary\n       if (hasMetadataStore()\n           \u0026\u0026 srcPaths !\u003d null\n           \u0026\u0026 !srcPaths.contains(src)) {\n         LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n             src, dst);\n         S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n             username);\n       }\n     }\n \n     metadataStore.move(srcPaths, dstMetas);\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n-      createFakeDirectoryIfNecessary(src.getParent());\n+      maybeCreateFakeParentDirectory(src);\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerRename(Path source, Path dest)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    Path src \u003d qualify(source);\n    Path dst \u003d qualify(dest);\n\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    incrementStatistic(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"source is root directory\");\n    }\n    if (dstKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"dest is root directory\");\n    }\n\n    // get the source file status; this raises a FNFE if there is no source\n    // file.\n    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n          dst);\n      throw new RenameFailedException(src, dst,\n          \"source and dest refer to the same file or directory\")\n          .withExitCode(srcStatus.isFile());\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d innerGetFileStatus(dst, true);\n      // if there is no destination entry, an exception is raised.\n      // hence this code sequence can assume that there is something\n      // at the end of the path; the only detail being what it is and\n      // whether or not it can be the destination of the rename.\n      if (srcStatus.isDirectory()) {\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"source is a directory and dest is a file\")\n              .withExitCode(srcStatus.isFile());\n        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n          throw new RenameFailedException(src, dst,\n              \"Destination is a non-empty directory\")\n              .withExitCode(false);\n        }\n        // at this point the destination is an empty directory\n      } else {\n        // source is a file. The destination must be a directory,\n        // empty or not\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"Cannot rename onto an existing file\")\n              .withExitCode(false);\n        }\n      }\n\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n              false);\n          if (!dstParentStatus.isDirectory()) {\n            throw new RenameFailedException(src, dst,\n                \"destination parent is not a directory\");\n          }\n        } catch (FileNotFoundException e2) {\n          throw new RenameFailedException(src, dst,\n              \"destination has no parent \");\n        }\n      }\n    }\n\n    // If we have a MetadataStore, track deletions/creations.\n    Collection\u003cPath\u003e srcPaths \u003d null;\n    List\u003cPathMetadata\u003e dstMetas \u003d null;\n    if (hasMetadataStore()) {\n      srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n      dstMetas \u003d new ArrayList\u003c\u003e();\n    }\n    // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n    // TODO S3Guard: performance: mark destination dirs as authoritative\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      long length \u003d srcStatus.getLen();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, length);\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n            keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n            username);\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n            length, getDefaultBlockSize(dst), username);\n      }\n      innerDelete(srcStatus, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        throw new RenameFailedException(srcKey, dstKey,\n            \"cannot rename a directory to a subdirectory of itself \");\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      Path parentPath \u003d keyToQualifiedPath(srcKey);\n      RemoteIterator\u003cLocatedFileStatus\u003e iterator \u003d listFilesAndEmptyDirectories(\n          parentPath, true);\n      while (iterator.hasNext()) {\n        LocatedFileStatus status \u003d iterator.next();\n        long length \u003d status.getLen();\n        String key \u003d pathToKey(status.getPath());\n        if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n          key +\u003d \"/\";\n        }\n        keysToDelete\n            .add(new DeleteObjectsRequest.KeyVersion(key));\n        String newDstKey \u003d\n            dstKey + key.substring(srcKey.length());\n        copyFile(key, newDstKey, length);\n\n        if (hasMetadataStore()) {\n          // with a metadata store, the object entries need to be updated,\n          // including, potentially, the ancestors\n          Path childSrc \u003d keyToQualifiedPath(key);\n          Path childDst \u003d keyToQualifiedPath(newDstKey);\n          if (objectRepresentsDirectory(key, length)) {\n            S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, username);\n          } else {\n            S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, length, getDefaultBlockSize(childDst), username);\n          }\n          // Ancestor directories may not be listed, so we explicitly add them\n          S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n              keyToQualifiedPath(srcKey), childSrc, childDst, username);\n        }\n\n        if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n          removeKeys(keysToDelete, true, false);\n        }\n      }\n      if (!keysToDelete.isEmpty()) {\n        removeKeys(keysToDelete, false, false);\n      }\n\n      // We moved all the children, now move the top-level dir\n      // Empty directory should have been added as the object summary\n      if (hasMetadataStore()\n          \u0026\u0026 srcPaths !\u003d null\n          \u0026\u0026 !srcPaths.contains(src)) {\n        LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n            src, dst);\n        S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n            username);\n      }\n    }\n\n    metadataStore.move(srcPaths, dstMetas);\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      maybeCreateFakeParentDirectory(src);\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
          "commitDate": "01/09/17 6:13 AM",
          "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "05/06/17 11:26 AM",
          "commitNameOld": "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 87.78,
          "commitsBetweenForRepo": 591,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,151 +1,195 @@\n-  private boolean innerRename(Path src, Path dst)\n+  private boolean innerRename(Path source, Path dest)\n       throws RenameFailedException, FileNotFoundException, IOException,\n         AmazonClientException {\n+    Path src \u003d qualify(source);\n+    Path dst \u003d qualify(dest);\n+\n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     incrementStatistic(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"source is root directory\");\n     }\n     if (dstKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"dest is root directory\");\n     }\n \n     // get the source file status; this raises a FNFE if there is no source\n     // file.\n-    S3AFileStatus srcStatus \u003d getFileStatus(src);\n+    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n           dst);\n       throw new RenameFailedException(src, dst,\n           \"source and dest refer to the same file or directory\")\n           .withExitCode(srcStatus.isFile());\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n-      dstStatus \u003d getFileStatus(dst);\n+      dstStatus \u003d innerGetFileStatus(dst, true);\n       // if there is no destination entry, an exception is raised.\n       // hence this code sequence can assume that there is something\n       // at the end of the path; the only detail being what it is and\n       // whether or not it can be the destination of the rename.\n       if (srcStatus.isDirectory()) {\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"source is a directory and dest is a file\")\n               .withExitCode(srcStatus.isFile());\n-        } else if (!dstStatus.isEmptyDirectory()) {\n+        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n           throw new RenameFailedException(src, dst,\n               \"Destination is a non-empty directory\")\n               .withExitCode(false);\n         }\n         // at this point the destination is an empty directory\n       } else {\n         // source is a file. The destination must be a directory,\n         // empty or not\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"Cannot rename onto an existing file\")\n               .withExitCode(false);\n         }\n       }\n \n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n-          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n+          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n+              false);\n           if (!dstParentStatus.isDirectory()) {\n             throw new RenameFailedException(src, dst,\n                 \"destination parent is not a directory\");\n           }\n         } catch (FileNotFoundException e2) {\n           throw new RenameFailedException(src, dst,\n               \"destination has no parent \");\n         }\n       }\n     }\n \n+    // If we have a MetadataStore, track deletions/creations.\n+    Collection\u003cPath\u003e srcPaths \u003d null;\n+    List\u003cPathMetadata\u003e dstMetas \u003d null;\n+    if (hasMetadataStore()) {\n+      srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n+      dstMetas \u003d new ArrayList\u003c\u003e();\n+    }\n+    // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n+    // TODO S3Guard: performance: mark destination dirs as authoritative\n+\n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n+      long length \u003d srcStatus.getLen();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n-        copyFile(srcKey, newDstKey, srcStatus.getLen());\n+        copyFile(srcKey, newDstKey, length);\n+        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n+            keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n+            username);\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n+        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n+            length, getDefaultBlockSize(dst), username);\n       }\n       innerDelete(srcStatus, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         throw new RenameFailedException(srcKey, dstKey,\n             \"cannot rename a directory to a subdirectory of itself \");\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n-      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n+      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n-      ListObjectsRequest request \u003d new ListObjectsRequest();\n-      request.setBucketName(bucket);\n-      request.setPrefix(srcKey);\n-      request.setMaxKeys(maxKeys);\n+      Path parentPath \u003d keyToPath(srcKey);\n+      RemoteIterator\u003cLocatedFileStatus\u003e iterator \u003d listFilesAndEmptyDirectories(\n+          parentPath, true);\n+      while (iterator.hasNext()) {\n+        LocatedFileStatus status \u003d iterator.next();\n+        long length \u003d status.getLen();\n+        String key \u003d pathToKey(status.getPath());\n+        if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n+          key +\u003d \"/\";\n+        }\n+        keysToDelete\n+            .add(new DeleteObjectsRequest.KeyVersion(key));\n+        String newDstKey \u003d\n+            dstKey + key.substring(srcKey.length());\n+        copyFile(key, newDstKey, length);\n \n-      ObjectListing objects \u003d listObjects(request);\n-\n-      while (true) {\n-        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n-          keysToDelete.add(\n-              new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n-          String newDstKey \u003d\n-              dstKey + summary.getKey().substring(srcKey.length());\n-          copyFile(summary.getKey(), newDstKey, summary.getSize());\n-\n-          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n-            removeKeys(keysToDelete, true, false);\n+        if (hasMetadataStore()) {\n+          // with a metadata store, the object entries need to be updated,\n+          // including, potentially, the ancestors\n+          Path childSrc \u003d keyToQualifiedPath(key);\n+          Path childDst \u003d keyToQualifiedPath(newDstKey);\n+          if (objectRepresentsDirectory(key, length)) {\n+            S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n+                childDst, username);\n+          } else {\n+            S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n+                childDst, length, getDefaultBlockSize(childDst), username);\n           }\n+          // Ancestor directories may not be listed, so we explicitly add them\n+          S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n+              keyToQualifiedPath(srcKey), childSrc, childDst, username);\n         }\n \n-        if (objects.isTruncated()) {\n-          objects \u003d continueListObjects(objects);\n-        } else {\n-          if (!keysToDelete.isEmpty()) {\n-            removeKeys(keysToDelete, false, false);\n-          }\n-          break;\n+        if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n+          removeKeys(keysToDelete, true, false);\n         }\n       }\n+      if (!keysToDelete.isEmpty()) {\n+        removeKeys(keysToDelete, false, false);\n+      }\n+\n+      // We moved all the children, now move the top-level dir\n+      // Empty directory should have been added as the object summary\n+      if (hasMetadataStore()\n+          \u0026\u0026 srcPaths !\u003d null\n+          \u0026\u0026 !srcPaths.contains(src)) {\n+        LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n+            src, dst);\n+        S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n+            username);\n+      }\n     }\n \n+    metadataStore.move(srcPaths, dstMetas);\n+\n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean innerRename(Path source, Path dest)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    Path src \u003d qualify(source);\n    Path dst \u003d qualify(dest);\n\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    incrementStatistic(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"source is root directory\");\n    }\n    if (dstKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"dest is root directory\");\n    }\n\n    // get the source file status; this raises a FNFE if there is no source\n    // file.\n    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n          dst);\n      throw new RenameFailedException(src, dst,\n          \"source and dest refer to the same file or directory\")\n          .withExitCode(srcStatus.isFile());\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d innerGetFileStatus(dst, true);\n      // if there is no destination entry, an exception is raised.\n      // hence this code sequence can assume that there is something\n      // at the end of the path; the only detail being what it is and\n      // whether or not it can be the destination of the rename.\n      if (srcStatus.isDirectory()) {\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"source is a directory and dest is a file\")\n              .withExitCode(srcStatus.isFile());\n        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n          throw new RenameFailedException(src, dst,\n              \"Destination is a non-empty directory\")\n              .withExitCode(false);\n        }\n        // at this point the destination is an empty directory\n      } else {\n        // source is a file. The destination must be a directory,\n        // empty or not\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"Cannot rename onto an existing file\")\n              .withExitCode(false);\n        }\n      }\n\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n              false);\n          if (!dstParentStatus.isDirectory()) {\n            throw new RenameFailedException(src, dst,\n                \"destination parent is not a directory\");\n          }\n        } catch (FileNotFoundException e2) {\n          throw new RenameFailedException(src, dst,\n              \"destination has no parent \");\n        }\n      }\n    }\n\n    // If we have a MetadataStore, track deletions/creations.\n    Collection\u003cPath\u003e srcPaths \u003d null;\n    List\u003cPathMetadata\u003e dstMetas \u003d null;\n    if (hasMetadataStore()) {\n      srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n      dstMetas \u003d new ArrayList\u003c\u003e();\n    }\n    // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n    // TODO S3Guard: performance: mark destination dirs as authoritative\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      long length \u003d srcStatus.getLen();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, length);\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n            keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n            username);\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n            length, getDefaultBlockSize(dst), username);\n      }\n      innerDelete(srcStatus, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        throw new RenameFailedException(srcKey, dstKey,\n            \"cannot rename a directory to a subdirectory of itself \");\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      Path parentPath \u003d keyToPath(srcKey);\n      RemoteIterator\u003cLocatedFileStatus\u003e iterator \u003d listFilesAndEmptyDirectories(\n          parentPath, true);\n      while (iterator.hasNext()) {\n        LocatedFileStatus status \u003d iterator.next();\n        long length \u003d status.getLen();\n        String key \u003d pathToKey(status.getPath());\n        if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n          key +\u003d \"/\";\n        }\n        keysToDelete\n            .add(new DeleteObjectsRequest.KeyVersion(key));\n        String newDstKey \u003d\n            dstKey + key.substring(srcKey.length());\n        copyFile(key, newDstKey, length);\n\n        if (hasMetadataStore()) {\n          // with a metadata store, the object entries need to be updated,\n          // including, potentially, the ancestors\n          Path childSrc \u003d keyToQualifiedPath(key);\n          Path childDst \u003d keyToQualifiedPath(newDstKey);\n          if (objectRepresentsDirectory(key, length)) {\n            S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, username);\n          } else {\n            S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, length, getDefaultBlockSize(childDst), username);\n          }\n          // Ancestor directories may not be listed, so we explicitly add them\n          S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n              keyToQualifiedPath(srcKey), childSrc, childDst, username);\n        }\n\n        if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n          removeKeys(keysToDelete, true, false);\n        }\n      }\n      if (!keysToDelete.isEmpty()) {\n        removeKeys(keysToDelete, false, false);\n      }\n\n      // We moved all the children, now move the top-level dir\n      // Empty directory should have been added as the object summary\n      if (hasMetadataStore()\n          \u0026\u0026 srcPaths !\u003d null\n          \u0026\u0026 !srcPaths.contains(src)) {\n        LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n            src, dst);\n        S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n            username);\n      }\n    }\n\n    metadataStore.move(srcPaths, dstMetas);\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[src-Path, dst-Path]",
            "newValue": "[source-Path, dest-Path]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
          "commitDate": "01/09/17 6:13 AM",
          "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "05/06/17 11:26 AM",
          "commitNameOld": "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 87.78,
          "commitsBetweenForRepo": 591,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,151 +1,195 @@\n-  private boolean innerRename(Path src, Path dst)\n+  private boolean innerRename(Path source, Path dest)\n       throws RenameFailedException, FileNotFoundException, IOException,\n         AmazonClientException {\n+    Path src \u003d qualify(source);\n+    Path dst \u003d qualify(dest);\n+\n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     incrementStatistic(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"source is root directory\");\n     }\n     if (dstKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"dest is root directory\");\n     }\n \n     // get the source file status; this raises a FNFE if there is no source\n     // file.\n-    S3AFileStatus srcStatus \u003d getFileStatus(src);\n+    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n           dst);\n       throw new RenameFailedException(src, dst,\n           \"source and dest refer to the same file or directory\")\n           .withExitCode(srcStatus.isFile());\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n-      dstStatus \u003d getFileStatus(dst);\n+      dstStatus \u003d innerGetFileStatus(dst, true);\n       // if there is no destination entry, an exception is raised.\n       // hence this code sequence can assume that there is something\n       // at the end of the path; the only detail being what it is and\n       // whether or not it can be the destination of the rename.\n       if (srcStatus.isDirectory()) {\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"source is a directory and dest is a file\")\n               .withExitCode(srcStatus.isFile());\n-        } else if (!dstStatus.isEmptyDirectory()) {\n+        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n           throw new RenameFailedException(src, dst,\n               \"Destination is a non-empty directory\")\n               .withExitCode(false);\n         }\n         // at this point the destination is an empty directory\n       } else {\n         // source is a file. The destination must be a directory,\n         // empty or not\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"Cannot rename onto an existing file\")\n               .withExitCode(false);\n         }\n       }\n \n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n-          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n+          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n+              false);\n           if (!dstParentStatus.isDirectory()) {\n             throw new RenameFailedException(src, dst,\n                 \"destination parent is not a directory\");\n           }\n         } catch (FileNotFoundException e2) {\n           throw new RenameFailedException(src, dst,\n               \"destination has no parent \");\n         }\n       }\n     }\n \n+    // If we have a MetadataStore, track deletions/creations.\n+    Collection\u003cPath\u003e srcPaths \u003d null;\n+    List\u003cPathMetadata\u003e dstMetas \u003d null;\n+    if (hasMetadataStore()) {\n+      srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n+      dstMetas \u003d new ArrayList\u003c\u003e();\n+    }\n+    // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n+    // TODO S3Guard: performance: mark destination dirs as authoritative\n+\n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n+      long length \u003d srcStatus.getLen();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n-        copyFile(srcKey, newDstKey, srcStatus.getLen());\n+        copyFile(srcKey, newDstKey, length);\n+        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n+            keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n+            username);\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n+        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n+            length, getDefaultBlockSize(dst), username);\n       }\n       innerDelete(srcStatus, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         throw new RenameFailedException(srcKey, dstKey,\n             \"cannot rename a directory to a subdirectory of itself \");\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n-      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n+      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n-      ListObjectsRequest request \u003d new ListObjectsRequest();\n-      request.setBucketName(bucket);\n-      request.setPrefix(srcKey);\n-      request.setMaxKeys(maxKeys);\n+      Path parentPath \u003d keyToPath(srcKey);\n+      RemoteIterator\u003cLocatedFileStatus\u003e iterator \u003d listFilesAndEmptyDirectories(\n+          parentPath, true);\n+      while (iterator.hasNext()) {\n+        LocatedFileStatus status \u003d iterator.next();\n+        long length \u003d status.getLen();\n+        String key \u003d pathToKey(status.getPath());\n+        if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n+          key +\u003d \"/\";\n+        }\n+        keysToDelete\n+            .add(new DeleteObjectsRequest.KeyVersion(key));\n+        String newDstKey \u003d\n+            dstKey + key.substring(srcKey.length());\n+        copyFile(key, newDstKey, length);\n \n-      ObjectListing objects \u003d listObjects(request);\n-\n-      while (true) {\n-        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n-          keysToDelete.add(\n-              new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n-          String newDstKey \u003d\n-              dstKey + summary.getKey().substring(srcKey.length());\n-          copyFile(summary.getKey(), newDstKey, summary.getSize());\n-\n-          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n-            removeKeys(keysToDelete, true, false);\n+        if (hasMetadataStore()) {\n+          // with a metadata store, the object entries need to be updated,\n+          // including, potentially, the ancestors\n+          Path childSrc \u003d keyToQualifiedPath(key);\n+          Path childDst \u003d keyToQualifiedPath(newDstKey);\n+          if (objectRepresentsDirectory(key, length)) {\n+            S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n+                childDst, username);\n+          } else {\n+            S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n+                childDst, length, getDefaultBlockSize(childDst), username);\n           }\n+          // Ancestor directories may not be listed, so we explicitly add them\n+          S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n+              keyToQualifiedPath(srcKey), childSrc, childDst, username);\n         }\n \n-        if (objects.isTruncated()) {\n-          objects \u003d continueListObjects(objects);\n-        } else {\n-          if (!keysToDelete.isEmpty()) {\n-            removeKeys(keysToDelete, false, false);\n-          }\n-          break;\n+        if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n+          removeKeys(keysToDelete, true, false);\n         }\n       }\n+      if (!keysToDelete.isEmpty()) {\n+        removeKeys(keysToDelete, false, false);\n+      }\n+\n+      // We moved all the children, now move the top-level dir\n+      // Empty directory should have been added as the object summary\n+      if (hasMetadataStore()\n+          \u0026\u0026 srcPaths !\u003d null\n+          \u0026\u0026 !srcPaths.contains(src)) {\n+        LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n+            src, dst);\n+        S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n+            username);\n+      }\n     }\n \n+    metadataStore.move(srcPaths, dstMetas);\n+\n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean innerRename(Path source, Path dest)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    Path src \u003d qualify(source);\n    Path dst \u003d qualify(dest);\n\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    incrementStatistic(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"source is root directory\");\n    }\n    if (dstKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"dest is root directory\");\n    }\n\n    // get the source file status; this raises a FNFE if there is no source\n    // file.\n    S3AFileStatus srcStatus \u003d innerGetFileStatus(src, true);\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n          dst);\n      throw new RenameFailedException(src, dst,\n          \"source and dest refer to the same file or directory\")\n          .withExitCode(srcStatus.isFile());\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d innerGetFileStatus(dst, true);\n      // if there is no destination entry, an exception is raised.\n      // hence this code sequence can assume that there is something\n      // at the end of the path; the only detail being what it is and\n      // whether or not it can be the destination of the rename.\n      if (srcStatus.isDirectory()) {\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"source is a directory and dest is a file\")\n              .withExitCode(srcStatus.isFile());\n        } else if (dstStatus.isEmptyDirectory() !\u003d Tristate.TRUE) {\n          throw new RenameFailedException(src, dst,\n              \"Destination is a non-empty directory\")\n              .withExitCode(false);\n        }\n        // at this point the destination is an empty directory\n      } else {\n        // source is a file. The destination must be a directory,\n        // empty or not\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"Cannot rename onto an existing file\")\n              .withExitCode(false);\n        }\n      }\n\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d innerGetFileStatus(dst.getParent(),\n              false);\n          if (!dstParentStatus.isDirectory()) {\n            throw new RenameFailedException(src, dst,\n                \"destination parent is not a directory\");\n          }\n        } catch (FileNotFoundException e2) {\n          throw new RenameFailedException(src, dst,\n              \"destination has no parent \");\n        }\n      }\n    }\n\n    // If we have a MetadataStore, track deletions/creations.\n    Collection\u003cPath\u003e srcPaths \u003d null;\n    List\u003cPathMetadata\u003e dstMetas \u003d null;\n    if (hasMetadataStore()) {\n      srcPaths \u003d new HashSet\u003c\u003e(); // srcPaths need fast look up before put\n      dstMetas \u003d new ArrayList\u003c\u003e();\n    }\n    // TODO S3Guard HADOOP-13761: retries when source paths are not visible yet\n    // TODO S3Guard: performance: mark destination dirs as authoritative\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      long length \u003d srcStatus.getLen();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, length);\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src,\n            keyToQualifiedPath(newDstKey), length, getDefaultBlockSize(dst),\n            username);\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n        S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, src, dst,\n            length, getDefaultBlockSize(dst), username);\n      }\n      innerDelete(srcStatus, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        throw new RenameFailedException(srcKey, dstKey,\n            \"cannot rename a directory to a subdirectory of itself \");\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory() \u003d\u003d Tristate.TRUE) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      Path parentPath \u003d keyToPath(srcKey);\n      RemoteIterator\u003cLocatedFileStatus\u003e iterator \u003d listFilesAndEmptyDirectories(\n          parentPath, true);\n      while (iterator.hasNext()) {\n        LocatedFileStatus status \u003d iterator.next();\n        long length \u003d status.getLen();\n        String key \u003d pathToKey(status.getPath());\n        if (status.isDirectory() \u0026\u0026 !key.endsWith(\"/\")) {\n          key +\u003d \"/\";\n        }\n        keysToDelete\n            .add(new DeleteObjectsRequest.KeyVersion(key));\n        String newDstKey \u003d\n            dstKey + key.substring(srcKey.length());\n        copyFile(key, newDstKey, length);\n\n        if (hasMetadataStore()) {\n          // with a metadata store, the object entries need to be updated,\n          // including, potentially, the ancestors\n          Path childSrc \u003d keyToQualifiedPath(key);\n          Path childDst \u003d keyToQualifiedPath(newDstKey);\n          if (objectRepresentsDirectory(key, length)) {\n            S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, username);\n          } else {\n            S3Guard.addMoveFile(metadataStore, srcPaths, dstMetas, childSrc,\n                childDst, length, getDefaultBlockSize(childDst), username);\n          }\n          // Ancestor directories may not be listed, so we explicitly add them\n          S3Guard.addMoveAncestors(metadataStore, srcPaths, dstMetas,\n              keyToQualifiedPath(srcKey), childSrc, childDst, username);\n        }\n\n        if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n          removeKeys(keysToDelete, true, false);\n        }\n      }\n      if (!keysToDelete.isEmpty()) {\n        removeKeys(keysToDelete, false, false);\n      }\n\n      // We moved all the children, now move the top-level dir\n      // Empty directory should have been added as the object summary\n      if (hasMetadataStore()\n          \u0026\u0026 srcPaths !\u003d null\n          \u0026\u0026 !srcPaths.contains(src)) {\n        LOG.debug(\"To move the non-empty top-level dir src\u003d{} and dst\u003d{}\",\n            src, dst);\n        S3Guard.addMoveDir(metadataStore, srcPaths, dstMetas, src, dst,\n            username);\n      }\n    }\n\n    metadataStore.move(srcPaths, dstMetas);\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "6c399a88e9b5ef8f822a9bd469dbf9fdb3141e38": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14059. typo in s3a rename(self, subdir) error message. Contributed by Steve Loughran.\n",
      "commitDate": "20/03/17 11:29 AM",
      "commitName": "6c399a88e9b5ef8f822a9bd469dbf9fdb3141e38",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "25/02/17 7:35 AM",
      "commitNameOld": "dab00da19f25619ccc71c7f803a235b21766bf1e",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 23.12,
      "commitsBetweenForRepo": 133,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,151 @@\n   private boolean innerRename(Path src, Path dst)\n       throws RenameFailedException, FileNotFoundException, IOException,\n         AmazonClientException {\n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     incrementStatistic(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"source is root directory\");\n     }\n     if (dstKey.isEmpty()) {\n       throw new RenameFailedException(src, dst, \"dest is root directory\");\n     }\n \n     // get the source file status; this raises a FNFE if there is no source\n     // file.\n     S3AFileStatus srcStatus \u003d getFileStatus(src);\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n           dst);\n       throw new RenameFailedException(src, dst,\n           \"source and dest refer to the same file or directory\")\n           .withExitCode(srcStatus.isFile());\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n       // if there is no destination entry, an exception is raised.\n       // hence this code sequence can assume that there is something\n       // at the end of the path; the only detail being what it is and\n       // whether or not it can be the destination of the rename.\n       if (srcStatus.isDirectory()) {\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"source is a directory and dest is a file\")\n               .withExitCode(srcStatus.isFile());\n         } else if (!dstStatus.isEmptyDirectory()) {\n           throw new RenameFailedException(src, dst,\n               \"Destination is a non-empty directory\")\n               .withExitCode(false);\n         }\n         // at this point the destination is an empty directory\n       } else {\n         // source is a file. The destination must be a directory,\n         // empty or not\n         if (dstStatus.isFile()) {\n           throw new RenameFailedException(src, dst,\n               \"Cannot rename onto an existing file\")\n               .withExitCode(false);\n         }\n       }\n \n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             throw new RenameFailedException(src, dst,\n                 \"destination parent is not a directory\");\n           }\n         } catch (FileNotFoundException e2) {\n           throw new RenameFailedException(src, dst,\n               \"destination has no parent \");\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey, srcStatus.getLen());\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n       }\n       innerDelete(srcStatus, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         throw new RenameFailedException(srcKey, dstKey,\n-            \"cannot rename a directory to a subdirectory o fitself \");\n+            \"cannot rename a directory to a subdirectory of itself \");\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d listObjects(request);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(\n               new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d\n               dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey, summary.getSize());\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             removeKeys(keysToDelete, true, false);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d continueListObjects(objects);\n         } else {\n           if (!keysToDelete.isEmpty()) {\n             removeKeys(keysToDelete, false, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerRename(Path src, Path dst)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    incrementStatistic(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"source is root directory\");\n    }\n    if (dstKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"dest is root directory\");\n    }\n\n    // get the source file status; this raises a FNFE if there is no source\n    // file.\n    S3AFileStatus srcStatus \u003d getFileStatus(src);\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n          dst);\n      throw new RenameFailedException(src, dst,\n          \"source and dest refer to the same file or directory\")\n          .withExitCode(srcStatus.isFile());\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n      // if there is no destination entry, an exception is raised.\n      // hence this code sequence can assume that there is something\n      // at the end of the path; the only detail being what it is and\n      // whether or not it can be the destination of the rename.\n      if (srcStatus.isDirectory()) {\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"source is a directory and dest is a file\")\n              .withExitCode(srcStatus.isFile());\n        } else if (!dstStatus.isEmptyDirectory()) {\n          throw new RenameFailedException(src, dst,\n              \"Destination is a non-empty directory\")\n              .withExitCode(false);\n        }\n        // at this point the destination is an empty directory\n      } else {\n        // source is a file. The destination must be a directory,\n        // empty or not\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"Cannot rename onto an existing file\")\n              .withExitCode(false);\n        }\n      }\n\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            throw new RenameFailedException(src, dst,\n                \"destination parent is not a directory\");\n          }\n        } catch (FileNotFoundException e2) {\n          throw new RenameFailedException(src, dst,\n              \"destination has no parent \");\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, srcStatus.getLen());\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n      }\n      innerDelete(srcStatus, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        throw new RenameFailedException(srcKey, dstKey,\n            \"cannot rename a directory to a subdirectory of itself \");\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d listObjects(request);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(\n              new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d\n              dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey, summary.getSize());\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true, false);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d continueListObjects(objects);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "d60a60be8aa450c44d3be69d26c88025e253ac0c": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HADOOP-13823. s3a rename: fail if dest file exists. Contributed by Steve Loughran\n",
      "commitDate": "28/11/16 4:30 PM",
      "commitName": "d60a60be8aa450c44d3be69d26c88025e253ac0c",
      "commitAuthor": "Mingliang Liu",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-13823. s3a rename: fail if dest file exists. Contributed by Steve Loughran\n",
          "commitDate": "28/11/16 4:30 PM",
          "commitName": "d60a60be8aa450c44d3be69d26c88025e253ac0c",
          "commitAuthor": "Mingliang Liu",
          "commitDateOld": "31/10/16 1:54 PM",
          "commitNameOld": "a1761a841e95ef7d2296ac3e40b3a26d97787eab",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 28.15,
          "commitsBetweenForRepo": 215,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,136 +1,151 @@\n-  private boolean innerRename(Path src, Path dst) throws IOException,\n-      AmazonClientException {\n+  private boolean innerRename(Path src, Path dst)\n+      throws RenameFailedException, FileNotFoundException, IOException,\n+        AmazonClientException {\n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     incrementStatistic(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n-    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n-      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n-      return false;\n+    if (srcKey.isEmpty()) {\n+      throw new RenameFailedException(src, dst, \"source is root directory\");\n+    }\n+    if (dstKey.isEmpty()) {\n+      throw new RenameFailedException(src, dst, \"dest is root directory\");\n     }\n \n-    S3AFileStatus srcStatus;\n-    try {\n-      srcStatus \u003d getFileStatus(src);\n-    } catch (FileNotFoundException e) {\n-      LOG.error(\"rename: src not found {}\", src);\n-      return false;\n-    }\n+    // get the source file status; this raises a FNFE if there is no source\n+    // file.\n+    S3AFileStatus srcStatus \u003d getFileStatus(src);\n \n     if (srcKey.equals(dstKey)) {\n-      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n+      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n           dst);\n-      return srcStatus.isFile();\n+      throw new RenameFailedException(src, dst,\n+          \"source and dest refer to the same file or directory\")\n+          .withExitCode(srcStatus.isFile());\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n-\n-      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n-        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n-            src, dst);\n-        return false;\n+      // if there is no destination entry, an exception is raised.\n+      // hence this code sequence can assume that there is something\n+      // at the end of the path; the only detail being what it is and\n+      // whether or not it can be the destination of the rename.\n+      if (srcStatus.isDirectory()) {\n+        if (dstStatus.isFile()) {\n+          throw new RenameFailedException(src, dst,\n+              \"source is a directory and dest is a file\")\n+              .withExitCode(srcStatus.isFile());\n+        } else if (!dstStatus.isEmptyDirectory()) {\n+          throw new RenameFailedException(src, dst,\n+              \"Destination is a non-empty directory\")\n+              .withExitCode(false);\n+        }\n+        // at this point the destination is an empty directory\n+      } else {\n+        // source is a file. The destination must be a directory,\n+        // empty or not\n+        if (dstStatus.isFile()) {\n+          throw new RenameFailedException(src, dst,\n+              \"Cannot rename onto an existing file\")\n+              .withExitCode(false);\n+        }\n       }\n \n-      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n-        return false;\n-      }\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n-            return false;\n+            throw new RenameFailedException(src, dst,\n+                \"destination parent is not a directory\");\n           }\n         } catch (FileNotFoundException e2) {\n-          LOG.debug(\"rename: destination path {} has no parent {}\",\n-              dst, parent);\n-          return false;\n+          throw new RenameFailedException(src, dst,\n+              \"destination has no parent \");\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey, srcStatus.getLen());\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n       }\n       innerDelete(srcStatus, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n-        LOG.debug(\"cannot rename a directory {}\" +\n-              \" to a subdirectory of self: {}\", srcKey, dstKey);\n-        return false;\n+        throw new RenameFailedException(srcKey, dstKey,\n+            \"cannot rename a directory to a subdirectory o fitself \");\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d listObjects(request);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(\n               new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d\n               dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey, summary.getSize());\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             removeKeys(keysToDelete, true, false);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d continueListObjects(objects);\n         } else {\n           if (!keysToDelete.isEmpty()) {\n             removeKeys(keysToDelete, false, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean innerRename(Path src, Path dst)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    incrementStatistic(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"source is root directory\");\n    }\n    if (dstKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"dest is root directory\");\n    }\n\n    // get the source file status; this raises a FNFE if there is no source\n    // file.\n    S3AFileStatus srcStatus \u003d getFileStatus(src);\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n          dst);\n      throw new RenameFailedException(src, dst,\n          \"source and dest refer to the same file or directory\")\n          .withExitCode(srcStatus.isFile());\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n      // if there is no destination entry, an exception is raised.\n      // hence this code sequence can assume that there is something\n      // at the end of the path; the only detail being what it is and\n      // whether or not it can be the destination of the rename.\n      if (srcStatus.isDirectory()) {\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"source is a directory and dest is a file\")\n              .withExitCode(srcStatus.isFile());\n        } else if (!dstStatus.isEmptyDirectory()) {\n          throw new RenameFailedException(src, dst,\n              \"Destination is a non-empty directory\")\n              .withExitCode(false);\n        }\n        // at this point the destination is an empty directory\n      } else {\n        // source is a file. The destination must be a directory,\n        // empty or not\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"Cannot rename onto an existing file\")\n              .withExitCode(false);\n        }\n      }\n\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            throw new RenameFailedException(src, dst,\n                \"destination parent is not a directory\");\n          }\n        } catch (FileNotFoundException e2) {\n          throw new RenameFailedException(src, dst,\n              \"destination has no parent \");\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, srcStatus.getLen());\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n      }\n      innerDelete(srcStatus, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        throw new RenameFailedException(srcKey, dstKey,\n            \"cannot rename a directory to a subdirectory o fitself \");\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d listObjects(request);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(\n              new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d\n              dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey, summary.getSize());\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true, false);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d continueListObjects(objects);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[IOException, AmazonClientException]",
            "newValue": "[RenameFailedException, FileNotFoundException, IOException, AmazonClientException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13823. s3a rename: fail if dest file exists. Contributed by Steve Loughran\n",
          "commitDate": "28/11/16 4:30 PM",
          "commitName": "d60a60be8aa450c44d3be69d26c88025e253ac0c",
          "commitAuthor": "Mingliang Liu",
          "commitDateOld": "31/10/16 1:54 PM",
          "commitNameOld": "a1761a841e95ef7d2296ac3e40b3a26d97787eab",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 28.15,
          "commitsBetweenForRepo": 215,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,136 +1,151 @@\n-  private boolean innerRename(Path src, Path dst) throws IOException,\n-      AmazonClientException {\n+  private boolean innerRename(Path src, Path dst)\n+      throws RenameFailedException, FileNotFoundException, IOException,\n+        AmazonClientException {\n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     incrementStatistic(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n-    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n-      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n-      return false;\n+    if (srcKey.isEmpty()) {\n+      throw new RenameFailedException(src, dst, \"source is root directory\");\n+    }\n+    if (dstKey.isEmpty()) {\n+      throw new RenameFailedException(src, dst, \"dest is root directory\");\n     }\n \n-    S3AFileStatus srcStatus;\n-    try {\n-      srcStatus \u003d getFileStatus(src);\n-    } catch (FileNotFoundException e) {\n-      LOG.error(\"rename: src not found {}\", src);\n-      return false;\n-    }\n+    // get the source file status; this raises a FNFE if there is no source\n+    // file.\n+    S3AFileStatus srcStatus \u003d getFileStatus(src);\n \n     if (srcKey.equals(dstKey)) {\n-      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n+      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n           dst);\n-      return srcStatus.isFile();\n+      throw new RenameFailedException(src, dst,\n+          \"source and dest refer to the same file or directory\")\n+          .withExitCode(srcStatus.isFile());\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n-\n-      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n-        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n-            src, dst);\n-        return false;\n+      // if there is no destination entry, an exception is raised.\n+      // hence this code sequence can assume that there is something\n+      // at the end of the path; the only detail being what it is and\n+      // whether or not it can be the destination of the rename.\n+      if (srcStatus.isDirectory()) {\n+        if (dstStatus.isFile()) {\n+          throw new RenameFailedException(src, dst,\n+              \"source is a directory and dest is a file\")\n+              .withExitCode(srcStatus.isFile());\n+        } else if (!dstStatus.isEmptyDirectory()) {\n+          throw new RenameFailedException(src, dst,\n+              \"Destination is a non-empty directory\")\n+              .withExitCode(false);\n+        }\n+        // at this point the destination is an empty directory\n+      } else {\n+        // source is a file. The destination must be a directory,\n+        // empty or not\n+        if (dstStatus.isFile()) {\n+          throw new RenameFailedException(src, dst,\n+              \"Cannot rename onto an existing file\")\n+              .withExitCode(false);\n+        }\n       }\n \n-      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n-        return false;\n-      }\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n-            return false;\n+            throw new RenameFailedException(src, dst,\n+                \"destination parent is not a directory\");\n           }\n         } catch (FileNotFoundException e2) {\n-          LOG.debug(\"rename: destination path {} has no parent {}\",\n-              dst, parent);\n-          return false;\n+          throw new RenameFailedException(src, dst,\n+              \"destination has no parent \");\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey, srcStatus.getLen());\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n       }\n       innerDelete(srcStatus, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n-        LOG.debug(\"cannot rename a directory {}\" +\n-              \" to a subdirectory of self: {}\", srcKey, dstKey);\n-        return false;\n+        throw new RenameFailedException(srcKey, dstKey,\n+            \"cannot rename a directory to a subdirectory o fitself \");\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d listObjects(request);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(\n               new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d\n               dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey, summary.getSize());\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             removeKeys(keysToDelete, true, false);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d continueListObjects(objects);\n         } else {\n           if (!keysToDelete.isEmpty()) {\n             removeKeys(keysToDelete, false, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean innerRename(Path src, Path dst)\n      throws RenameFailedException, FileNotFoundException, IOException,\n        AmazonClientException {\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    incrementStatistic(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"source is root directory\");\n    }\n    if (dstKey.isEmpty()) {\n      throw new RenameFailedException(src, dst, \"dest is root directory\");\n    }\n\n    // get the source file status; this raises a FNFE if there is no source\n    // file.\n    S3AFileStatus srcStatus \u003d getFileStatus(src);\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dest refer to the same file or directory: {}\",\n          dst);\n      throw new RenameFailedException(src, dst,\n          \"source and dest refer to the same file or directory\")\n          .withExitCode(srcStatus.isFile());\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n      // if there is no destination entry, an exception is raised.\n      // hence this code sequence can assume that there is something\n      // at the end of the path; the only detail being what it is and\n      // whether or not it can be the destination of the rename.\n      if (srcStatus.isDirectory()) {\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"source is a directory and dest is a file\")\n              .withExitCode(srcStatus.isFile());\n        } else if (!dstStatus.isEmptyDirectory()) {\n          throw new RenameFailedException(src, dst,\n              \"Destination is a non-empty directory\")\n              .withExitCode(false);\n        }\n        // at this point the destination is an empty directory\n      } else {\n        // source is a file. The destination must be a directory,\n        // empty or not\n        if (dstStatus.isFile()) {\n          throw new RenameFailedException(src, dst,\n              \"Cannot rename onto an existing file\")\n              .withExitCode(false);\n        }\n      }\n\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            throw new RenameFailedException(src, dst,\n                \"destination parent is not a directory\");\n          }\n        } catch (FileNotFoundException e2) {\n          throw new RenameFailedException(src, dst,\n              \"destination has no parent \");\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, srcStatus.getLen());\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n      }\n      innerDelete(srcStatus, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        throw new RenameFailedException(srcKey, dstKey,\n            \"cannot rename a directory to a subdirectory o fitself \");\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d listObjects(request);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(\n              new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d\n              dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey, summary.getSize());\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true, false);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d continueListObjects(objects);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "ee0c722dc8fb81ec902cd1da5958ce5adb0ab08f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13164 Optimize S3AFileSystem::deleteUnnecessaryFakeDirectories. Contributed by Rajesh Balamohan.\n",
      "commitDate": "29/09/16 9:01 AM",
      "commitName": "ee0c722dc8fb81ec902cd1da5958ce5adb0ab08f",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "28/09/16 4:19 PM",
      "commitNameOld": "47f80922dc7cb2fa6d084e6fb1f354c4ec1d4c69",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 0.7,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,136 @@\n   private boolean innerRename(Path src, Path dst) throws IOException,\n       AmazonClientException {\n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     incrementStatistic(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty() || dstKey.isEmpty()) {\n       LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n           dst);\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n         LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n             src, dst);\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           LOG.debug(\"rename: destination path {} has no parent {}\",\n               dst, parent);\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey, srcStatus.getLen());\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n       }\n       innerDelete(srcStatus, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         LOG.debug(\"cannot rename a directory {}\" +\n               \" to a subdirectory of self: {}\", srcKey, dstKey);\n         return false;\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d listObjects(request);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(\n               new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d\n               dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey, summary.getSize());\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n-            removeKeys(keysToDelete, true);\n+            removeKeys(keysToDelete, true, false);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d continueListObjects(objects);\n         } else {\n           if (!keysToDelete.isEmpty()) {\n-            removeKeys(keysToDelete, false);\n+            removeKeys(keysToDelete, false, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerRename(Path src, Path dst) throws IOException,\n      AmazonClientException {\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    incrementStatistic(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n          dst);\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n            src, dst);\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          LOG.debug(\"rename: destination path {} has no parent {}\",\n              dst, parent);\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, srcStatus.getLen());\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n      }\n      innerDelete(srcStatus, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        LOG.debug(\"cannot rename a directory {}\" +\n              \" to a subdirectory of self: {}\", srcKey, dstKey);\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d listObjects(request);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(\n              new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d\n              dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey, summary.getSize());\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true, false);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d continueListObjects(objects);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13406 S3AFileSystem: Consider reusing filestatus in delete() and mkdirs(). Contributed by Rajesh Balamohan\n",
      "commitDate": "25/07/16 6:45 AM",
      "commitName": "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/07/16 5:42 AM",
      "commitNameOld": "37362c2f922b8d038002e61132b110ae4dd6d5ba",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 5.04,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,134 @@\n   private boolean innerRename(Path src, Path dst) throws IOException,\n       AmazonClientException {\n     LOG.debug(\"Rename path {} to {}\", src, dst);\n     incrementStatistic(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty() || dstKey.isEmpty()) {\n       LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n           dst);\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n         LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n             src, dst);\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           LOG.debug(\"rename: destination path {} has no parent {}\",\n               dst, parent);\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey, srcStatus.getLen());\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n       }\n-      delete(src, false);\n+      innerDelete(srcStatus, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         LOG.debug(\"cannot rename a directory {}\" +\n               \" to a subdirectory of self: {}\", srcKey, dstKey);\n         return false;\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d listObjects(request);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey, summary.getSize());\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             removeKeys(keysToDelete, true);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d continueListObjects(objects);\n         } else {\n           if (!keysToDelete.isEmpty()) {\n             removeKeys(keysToDelete, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerRename(Path src, Path dst) throws IOException,\n      AmazonClientException {\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    incrementStatistic(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n          dst);\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n            src, dst);\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          LOG.debug(\"rename: destination path {} has no parent {}\",\n              dst, parent);\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, srcStatus.getLen());\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n      }\n      innerDelete(srcStatus, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        LOG.debug(\"cannot rename a directory {}\" +\n              \" to a subdirectory of self: {}\", srcKey, dstKey);\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d listObjects(request);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey, summary.getSize());\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d continueListObjects(objects);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13171. Add StorageStatistics to S3A; instrument some more operations. Contributed by Steve Loughran.\n",
      "commitDate": "03/06/16 8:55 AM",
      "commitName": "c58a59f7081d55dd2108545ebf9ee48cf43ca944",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "01/06/16 2:49 PM",
      "commitNameOld": "16b1cc7af9bd63b65ef50e1056f275a7baf111a2",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 1.75,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,134 @@\n   private boolean innerRename(Path src, Path dst) throws IOException,\n       AmazonClientException {\n     LOG.debug(\"Rename path {} to {}\", src, dst);\n+    incrementStatistic(INVOCATION_RENAME);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty() || dstKey.isEmpty()) {\n       LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n           dst);\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n         LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n             src, dst);\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           LOG.debug(\"rename: destination path {} has no parent {}\",\n               dst, parent);\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey, srcStatus.getLen());\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n       }\n       delete(src, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         LOG.debug(\"cannot rename a directory {}\" +\n               \" to a subdirectory of self: {}\", srcKey, dstKey);\n         return false;\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n-      ObjectListing objects \u003d s3.listObjects(request);\n-      statistics.incrementReadOps(1);\n+      ObjectListing objects \u003d listObjects(request);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey, summary.getSize());\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             removeKeys(keysToDelete, true);\n           }\n         }\n \n         if (objects.isTruncated()) {\n-          objects \u003d s3.listNextBatchOfObjects(objects);\n-          statistics.incrementReadOps(1);\n+          objects \u003d continueListObjects(objects);\n         } else {\n           if (!keysToDelete.isEmpty()) {\n             removeKeys(keysToDelete, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private boolean innerRename(Path src, Path dst) throws IOException,\n      AmazonClientException {\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n    incrementStatistic(INVOCATION_RENAME);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n          dst);\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n            src, dst);\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          LOG.debug(\"rename: destination path {} has no parent {}\",\n              dst, parent);\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, srcStatus.getLen());\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n      }\n      delete(src, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        LOG.debug(\"cannot rename a directory {}\" +\n              \" to a subdirectory of self: {}\", srcKey, dstKey);\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d listObjects(request);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey, summary.getSize());\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d continueListObjects(objects);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "39ec1515a205952eda7e171408a8b83eceb4abde": {
      "type": "Ymultichange(Yrename,Ymodifierchange,Yexceptionschange)",
      "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
      "commitDate": "21/05/16 8:39 AM",
      "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
      "commitAuthor": "Steve Loughran",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
          "commitDate": "21/05/16 8:39 AM",
          "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "20/05/16 5:52 AM",
          "commitNameOld": "757050ff355d40bc28f9dbfd0c0083c5f337d270",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,134 +1,135 @@\n-  public boolean rename(Path src, Path dst) throws IOException {\n+  private boolean innerRename(Path src, Path dst) throws IOException,\n+      AmazonClientException {\n     LOG.debug(\"Rename path {} to {}\", src, dst);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty() || dstKey.isEmpty()) {\n       LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n           dst);\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n         LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n             src, dst);\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           LOG.debug(\"rename: destination path {} has no parent {}\",\n               dst, parent);\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey, srcStatus.getLen());\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n       }\n       delete(src, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         LOG.debug(\"cannot rename a directory {}\" +\n               \" to a subdirectory of self: {}\", srcKey, dstKey);\n         return false;\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey, summary.getSize());\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             removeKeys(keysToDelete, true);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           if (!keysToDelete.isEmpty()) {\n             removeKeys(keysToDelete, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean innerRename(Path src, Path dst) throws IOException,\n      AmazonClientException {\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n          dst);\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n            src, dst);\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          LOG.debug(\"rename: destination path {} has no parent {}\",\n              dst, parent);\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, srcStatus.getLen());\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n      }\n      delete(src, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        LOG.debug(\"cannot rename a directory {}\" +\n              \" to a subdirectory of self: {}\", srcKey, dstKey);\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey, summary.getSize());\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "rename",
            "newValue": "innerRename"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
          "commitDate": "21/05/16 8:39 AM",
          "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "20/05/16 5:52 AM",
          "commitNameOld": "757050ff355d40bc28f9dbfd0c0083c5f337d270",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,134 +1,135 @@\n-  public boolean rename(Path src, Path dst) throws IOException {\n+  private boolean innerRename(Path src, Path dst) throws IOException,\n+      AmazonClientException {\n     LOG.debug(\"Rename path {} to {}\", src, dst);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty() || dstKey.isEmpty()) {\n       LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n           dst);\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n         LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n             src, dst);\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           LOG.debug(\"rename: destination path {} has no parent {}\",\n               dst, parent);\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey, srcStatus.getLen());\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n       }\n       delete(src, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         LOG.debug(\"cannot rename a directory {}\" +\n               \" to a subdirectory of self: {}\", srcKey, dstKey);\n         return false;\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey, summary.getSize());\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             removeKeys(keysToDelete, true);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           if (!keysToDelete.isEmpty()) {\n             removeKeys(keysToDelete, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean innerRename(Path src, Path dst) throws IOException,\n      AmazonClientException {\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n          dst);\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n            src, dst);\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          LOG.debug(\"rename: destination path {} has no parent {}\",\n              dst, parent);\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, srcStatus.getLen());\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n      }\n      delete(src, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        LOG.debug(\"cannot rename a directory {}\" +\n              \" to a subdirectory of self: {}\", srcKey, dstKey);\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey, summary.getSize());\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HADOOP-13130. s3a failures can surface as RTEs, not IOEs. (Steve Loughran)\n",
          "commitDate": "21/05/16 8:39 AM",
          "commitName": "39ec1515a205952eda7e171408a8b83eceb4abde",
          "commitAuthor": "Steve Loughran",
          "commitDateOld": "20/05/16 5:52 AM",
          "commitNameOld": "757050ff355d40bc28f9dbfd0c0083c5f337d270",
          "commitAuthorOld": "Steve Loughran",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,134 +1,135 @@\n-  public boolean rename(Path src, Path dst) throws IOException {\n+  private boolean innerRename(Path src, Path dst) throws IOException,\n+      AmazonClientException {\n     LOG.debug(\"Rename path {} to {}\", src, dst);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty() || dstKey.isEmpty()) {\n       LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n       LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n           dst);\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n         LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n             src, dst);\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n       LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           LOG.debug(\"rename: destination path {} has no parent {}\",\n               dst, parent);\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey, srcStatus.getLen());\n       } else {\n         copyFile(srcKey, dstKey, srcStatus.getLen());\n       }\n       delete(src, false);\n     } else {\n       LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         LOG.debug(\"cannot rename a directory {}\" +\n               \" to a subdirectory of self: {}\", srcKey, dstKey);\n         return false;\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey, summary.getSize());\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             removeKeys(keysToDelete, true);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           if (!keysToDelete.isEmpty()) {\n             removeKeys(keysToDelete, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private boolean innerRename(Path src, Path dst) throws IOException,\n      AmazonClientException {\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n          dst);\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n            src, dst);\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          LOG.debug(\"rename: destination path {} has no parent {}\",\n              dst, parent);\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, srcStatus.getLen());\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n      }\n      delete(src, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        LOG.debug(\"cannot rename a directory {}\" +\n              \" to a subdirectory of self: {}\", srcKey, dstKey);\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey, summary.getSize());\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[IOException, AmazonClientException]"
          }
        }
      ]
    },
    "27c4e90efce04e1b1302f668b5eb22412e00d033": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
      "commitDate": "12/05/16 11:24 AM",
      "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/05/16 5:57 AM",
      "commitNameOld": "def2a6d3856452d5c804f04e5bf485541a3bc53a",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,134 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Rename path {} to {}\", src, dst);\n-    }\n+    LOG.debug(\"Rename path {} to {}\", src, dst);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty() || dstKey.isEmpty()) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"rename: src or dst are empty\");\n-      }\n+      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"rename: src and dst refer to the same file or directory\");\n-      }\n+      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n+          dst);\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"rename: src is a directory and dst is a file\");\n-        }\n+        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n+            src, dst);\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n+      LOG.debug(\"rename: destination path {} not found\", dst);\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n+          LOG.debug(\"rename: destination path {} has no parent {}\",\n+              dst, parent);\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n-      }\n+      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n-        copyFile(srcKey, newDstKey);\n+        copyFile(srcKey, newDstKey, srcStatus.getLen());\n       } else {\n-        copyFile(srcKey, dstKey);\n+        copyFile(srcKey, dstKey, srcStatus.getLen());\n       }\n       delete(src, false);\n     } else {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n-      }\n+      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n-        }\n+        LOG.debug(\"cannot rename a directory {}\" +\n+              \" to a subdirectory of self: {}\", srcKey, dstKey);\n         return false;\n       }\n \n-      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d\n-        new ArrayList\u003c\u003e();\n+      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n-          copyFile(summary.getKey(), newDstKey);\n+          copyFile(summary.getKey(), newDstKey, summary.getSize());\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             removeKeys(keysToDelete, true);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           if (!keysToDelete.isEmpty()) {\n             removeKeys(keysToDelete, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    LOG.debug(\"Rename path {} to {}\", src, dst);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n      LOG.debug(\"rename: source {} or dest {}, is empty\", srcKey, dstKey);\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      LOG.debug(\"rename: src and dst refer to the same file or directory: {}\",\n          dst);\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        LOG.debug(\"rename: src {} is a directory and dst {} is a file\",\n            src, dst);\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      LOG.debug(\"rename: destination path {} not found\", dst);\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          LOG.debug(\"rename: destination path {} has no parent {}\",\n              dst, parent);\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      LOG.debug(\"rename: renaming file {} to {}\", src, dst);\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey, srcStatus.getLen());\n      } else {\n        copyFile(srcKey, dstKey, srcStatus.getLen());\n      }\n      delete(src, false);\n    } else {\n      LOG.debug(\"rename: renaming directory {} to {}\", src, dst);\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        LOG.debug(\"cannot rename a directory {}\" +\n              \" to a subdirectory of self: {}\", srcKey, dstKey);\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey, summary.getSize());\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "29ae25801380b94442253c4202dee782dc4713f5": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12292. Make use of DeleteObjects optional.  (Thomas Demoor via stevel)\n",
      "commitDate": "06/02/16 7:05 AM",
      "commitName": "29ae25801380b94442253c4202dee782dc4713f5",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/01/16 12:19 PM",
      "commitNameOld": "126705f67eaa6d866f7572fbddf133c5d7552353",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 24.78,
      "commitsBetweenForRepo": 186,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,143 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Rename path {} to {}\", src, dst);\n     }\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.isEmpty() || dstKey.isEmpty()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: src or dst are empty\");\n       }\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: src and dst refer to the same file or directory\");\n       }\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"rename: src is a directory and dst is a file\");\n         }\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n       }\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey);\n       } else {\n         copyFile(srcKey, dstKey);\n       }\n       delete(src, false);\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n       }\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n         }\n         return false;\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n         new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey);\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n-            DeleteObjectsRequest deleteRequest \u003d\n-                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n-            s3.deleteObjects(deleteRequest);\n-            statistics.incrementWriteOps(1);\n-            keysToDelete.clear();\n+            removeKeys(keysToDelete, true);\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n-          if (keysToDelete.size() \u003e 0) {\n-            DeleteObjectsRequest deleteRequest \u003d\n-                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n-            s3.deleteObjects(deleteRequest);\n-            statistics.incrementWriteOps(1);\n+          if (!keysToDelete.isEmpty()) {\n+            removeKeys(keysToDelete, false);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Rename path {} to {}\", src, dst);\n    }\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src or dst are empty\");\n      }\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src and dst refer to the same file or directory\");\n      }\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"rename: src is a directory and dst is a file\");\n        }\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n      }\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey);\n      } else {\n        copyFile(srcKey, dstKey);\n      }\n      delete(src, false);\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n      }\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n        }\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n        new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey);\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            removeKeys(keysToDelete, true);\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (!keysToDelete.isEmpty()) {\n            removeKeys(keysToDelete, false);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "709ff99cff4124823bde631e272af7be9a22f83b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11584 s3a file block size set to 0 in getFileStatus. (Brahma Reddy Battula via stevel)\n",
      "commitDate": "21/02/15 4:03 AM",
      "commitName": "709ff99cff4124823bde631e272af7be9a22f83b",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "20/02/15 12:51 PM",
      "commitNameOld": "aa1c437b6a806de612f030a68984c606c623f1d9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.63,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,150 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Rename path {} to {}\", src, dst);\n     }\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n-    if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n+    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: src or dst are empty\");\n       }\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: src and dst refer to the same file or directory\");\n       }\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"rename: src is a directory and dst is a file\");\n         }\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n       }\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey);\n       } else {\n         copyFile(srcKey, dstKey);\n       }\n       delete(src, false);\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n       }\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n         }\n         return false;\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n-        new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n+        new ArrayList\u003c\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey);\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             DeleteObjectsRequest deleteRequest \u003d\n                 new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n             s3.deleteObjects(deleteRequest);\n             statistics.incrementWriteOps(1);\n             keysToDelete.clear();\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           if (keysToDelete.size() \u003e 0) {\n             DeleteObjectsRequest deleteRequest \u003d\n                 new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n             s3.deleteObjects(deleteRequest);\n             statistics.incrementWriteOps(1);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Rename path {} to {}\", src, dst);\n    }\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.isEmpty() || dstKey.isEmpty()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src or dst are empty\");\n      }\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src and dst refer to the same file or directory\");\n      }\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"rename: src is a directory and dst is a file\");\n        }\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n      }\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey);\n      } else {\n        copyFile(srcKey, dstKey);\n      }\n      delete(src, false);\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n      }\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n        }\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n        new ArrayList\u003c\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey);\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            DeleteObjectsRequest deleteRequest \u003d\n                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n            s3.deleteObjects(deleteRequest);\n            statistics.incrementWriteOps(1);\n            keysToDelete.clear();\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (keysToDelete.size() \u003e 0) {\n            DeleteObjectsRequest deleteRequest \u003d\n                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n            s3.deleteObjects(deleteRequest);\n            statistics.incrementWriteOps(1);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "aa1c437b6a806de612f030a68984c606c623f1d9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11607. Reduce log spew in S3AFileSystem. (Lei (Eddy) Xu via stevel)\n",
      "commitDate": "20/02/15 12:51 PM",
      "commitName": "aa1c437b6a806de612f030a68984c606c623f1d9",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/02/15 12:06 PM",
      "commitNameOld": "00b80958d862dbcc08d6f186c09963d3351ba0fd",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 3.03,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,150 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n-    LOG.info(\"Rename path \" + src + \" to \" + dst);\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Rename path {} to {}\", src, dst);\n+    }\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: src or dst are empty\");\n       }\n       return false;\n     }\n \n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n-      LOG.info(\"rename: src not found \" + src);\n+      LOG.error(\"rename: src not found {}\", src);\n       return false;\n     }\n \n     if (srcKey.equals(dstKey)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: src and dst refer to the same file or directory\");\n       }\n       return srcStatus.isFile();\n     }\n \n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"rename: src is a directory and dst is a file\");\n         }\n         return false;\n       }\n \n       if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n         return false;\n       }\n     } catch (FileNotFoundException e) {\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n       }\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n         String newDstKey \u003d dstKey;\n         if (!newDstKey.endsWith(\"/\")) {\n           newDstKey \u003d newDstKey + \"/\";\n         }\n         String filename \u003d\n             srcKey.substring(pathToKey(src.getParent()).length()+1);\n         newDstKey \u003d newDstKey + filename;\n         copyFile(srcKey, newDstKey);\n       } else {\n         copyFile(srcKey, dstKey);\n       }\n       delete(src, false);\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n       }\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n       //Verify dest is not a child of the source directory\n       if (dstKey.startsWith(srcKey)) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n         }\n         return false;\n       }\n \n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n         new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n         // delete unnecessary fake directory.\n         keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey);\n \n           if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n             DeleteObjectsRequest deleteRequest \u003d\n                 new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n             s3.deleteObjects(deleteRequest);\n             statistics.incrementWriteOps(1);\n             keysToDelete.clear();\n           }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n           if (keysToDelete.size() \u003e 0) {\n             DeleteObjectsRequest deleteRequest \u003d\n                 new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n             s3.deleteObjects(deleteRequest);\n             statistics.incrementWriteOps(1);\n           }\n           break;\n         }\n       }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Rename path {} to {}\", src, dst);\n    }\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src or dst are empty\");\n      }\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.error(\"rename: src not found {}\", src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src and dst refer to the same file or directory\");\n      }\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"rename: src is a directory and dst is a file\");\n        }\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n      }\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey);\n      } else {\n        copyFile(srcKey, dstKey);\n      }\n      delete(src, false);\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n      }\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n        }\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n        new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey);\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            DeleteObjectsRequest deleteRequest \u003d\n                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n            s3.deleteObjects(deleteRequest);\n            statistics.incrementWriteOps(1);\n            keysToDelete.clear();\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (keysToDelete.size() \u003e 0) {\n            DeleteObjectsRequest deleteRequest \u003d\n                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n            s3.deleteObjects(deleteRequest);\n            statistics.incrementWriteOps(1);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "6ba52d88ec11444cbac946ffadbc645acd0657de": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10714. AmazonS3Client.deleteObjects() need to be limited to 1000 entries per call. Contributed by Juan Yu.\n",
      "commitDate": "05/11/14 5:17 PM",
      "commitName": "6ba52d88ec11444cbac946ffadbc645acd0657de",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "15/09/14 4:49 PM",
      "commitNameOld": "0ac760a58d96b36ab30e9d60679bbea6365ef120",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 51.06,
      "commitsBetweenForRepo": 536,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,148 @@\n   public boolean rename(Path src, Path dst) throws IOException {\n     LOG.info(\"Rename path \" + src + \" to \" + dst);\n \n     String srcKey \u003d pathToKey(src);\n     String dstKey \u003d pathToKey(dst);\n \n     if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n-      LOG.info(\"rename: src or dst are empty\");\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"rename: src or dst are empty\");\n+      }\n       return false;\n     }\n \n-    if (srcKey.equals(dstKey)) {\n-      LOG.info(\"rename: src and dst refer to the same file\");\n-      return true;\n-    }\n-\n     S3AFileStatus srcStatus;\n     try {\n       srcStatus \u003d getFileStatus(src);\n     } catch (FileNotFoundException e) {\n       LOG.info(\"rename: src not found \" + src);\n       return false;\n     }\n \n+    if (srcKey.equals(dstKey)) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"rename: src and dst refer to the same file or directory\");\n+      }\n+      return srcStatus.isFile();\n+    }\n+\n     S3AFileStatus dstStatus \u003d null;\n     try {\n       dstStatus \u003d getFileStatus(dst);\n \n-      if (srcStatus.isFile() \u0026\u0026 dstStatus.isDirectory()) {\n-        LOG.info(\"rename: src is a file and dst is a directory\");\n-        return false;\n-      }\n-\n       if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n-        LOG.info(\"rename: src is a directory and dst is a file\");\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"rename: src is a directory and dst is a file\");\n+        }\n         return false;\n       }\n \n+      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n+        return false;\n+      }\n     } catch (FileNotFoundException e) {\n       // Parent must exist\n       Path parent \u003d dst.getParent();\n       if (!pathToKey(parent).isEmpty()) {\n         try {\n           S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n           if (!dstParentStatus.isDirectory()) {\n             return false;\n           }\n         } catch (FileNotFoundException e2) {\n           return false;\n         }\n       }\n     }\n \n     // Ok! Time to start\n     if (srcStatus.isFile()) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n       }\n-      copyFile(srcKey, dstKey);\n+      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n+        String newDstKey \u003d dstKey;\n+        if (!newDstKey.endsWith(\"/\")) {\n+          newDstKey \u003d newDstKey + \"/\";\n+        }\n+        String filename \u003d\n+            srcKey.substring(pathToKey(src.getParent()).length()+1);\n+        newDstKey \u003d newDstKey + filename;\n+        copyFile(srcKey, newDstKey);\n+      } else {\n+        copyFile(srcKey, dstKey);\n+      }\n       delete(src, false);\n     } else {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n       }\n \n       // This is a directory to directory copy\n       if (!dstKey.endsWith(\"/\")) {\n         dstKey \u003d dstKey + \"/\";\n       }\n \n       if (!srcKey.endsWith(\"/\")) {\n         srcKey \u003d srcKey + \"/\";\n       }\n \n+      //Verify dest is not a child of the source directory\n+      if (dstKey.startsWith(srcKey)) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n+        }\n+        return false;\n+      }\n+\n       List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n         new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n       if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n-        copyFile(srcKey, dstKey);\n-        statistics.incrementWriteOps(1);\n-        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(srcKey));\n+        // delete unnecessary fake directory.\n+        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n       }\n \n       ListObjectsRequest request \u003d new ListObjectsRequest();\n       request.setBucketName(bucket);\n       request.setPrefix(srcKey);\n       request.setMaxKeys(maxKeys);\n \n       ObjectListing objects \u003d s3.listObjects(request);\n       statistics.incrementReadOps(1);\n \n       while (true) {\n         for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n           keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n           String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n           copyFile(summary.getKey(), newDstKey);\n+\n+          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n+            DeleteObjectsRequest deleteRequest \u003d\n+                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n+            s3.deleteObjects(deleteRequest);\n+            statistics.incrementWriteOps(1);\n+            keysToDelete.clear();\n+          }\n         }\n \n         if (objects.isTruncated()) {\n           objects \u003d s3.listNextBatchOfObjects(objects);\n           statistics.incrementReadOps(1);\n         } else {\n+          if (keysToDelete.size() \u003e 0) {\n+            DeleteObjectsRequest deleteRequest \u003d\n+                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n+            s3.deleteObjects(deleteRequest);\n+            statistics.incrementWriteOps(1);\n+          }\n           break;\n         }\n       }\n-\n-\n-      if (!keysToDelete.isEmpty()) {\n-        DeleteObjectsRequest deleteRequest \u003d new DeleteObjectsRequest(bucket);\n-        deleteRequest.setKeys(keysToDelete);\n-        s3.deleteObjects(deleteRequest);\n-        statistics.incrementWriteOps(1);\n-      }\n     }\n \n     if (src.getParent() !\u003d dst.getParent()) {\n       deleteUnnecessaryFakeDirectories(dst.getParent());\n       createFakeDirectoryIfNecessary(src.getParent());\n     }\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    LOG.info(\"Rename path \" + src + \" to \" + dst);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src or dst are empty\");\n      }\n      return false;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.info(\"rename: src not found \" + src);\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: src and dst refer to the same file or directory\");\n      }\n      return srcStatus.isFile();\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"rename: src is a directory and dst is a file\");\n        }\n        return false;\n      }\n\n      if (dstStatus.isDirectory() \u0026\u0026 !dstStatus.isEmptyDirectory()) {\n        return false;\n      }\n    } catch (FileNotFoundException e) {\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n      }\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isDirectory()) {\n        String newDstKey \u003d dstKey;\n        if (!newDstKey.endsWith(\"/\")) {\n          newDstKey \u003d newDstKey + \"/\";\n        }\n        String filename \u003d\n            srcKey.substring(pathToKey(src.getParent()).length()+1);\n        newDstKey \u003d newDstKey + filename;\n        copyFile(srcKey, newDstKey);\n      } else {\n        copyFile(srcKey, dstKey);\n      }\n      delete(src, false);\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n      }\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      //Verify dest is not a child of the source directory\n      if (dstKey.startsWith(srcKey)) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"cannot rename a directory to a subdirectory of self\");\n        }\n        return false;\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n        new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        // delete unnecessary fake directory.\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(dstKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey);\n\n          if (keysToDelete.size() \u003d\u003d MAX_ENTRIES_TO_DELETE) {\n            DeleteObjectsRequest deleteRequest \u003d\n                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n            s3.deleteObjects(deleteRequest);\n            statistics.incrementWriteOps(1);\n            keysToDelete.clear();\n          }\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          if (keysToDelete.size() \u003e 0) {\n            DeleteObjectsRequest deleteRequest \u003d\n                new DeleteObjectsRequest(bucket).withKeys(keysToDelete);\n            s3.deleteObjects(deleteRequest);\n            statistics.incrementWriteOps(1);\n          }\n          break;\n        }\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10400. Incorporate new S3A FileSystem implementation. Contributed by Jordan Mendelson and Dave Wang.\n",
      "commitDate": "15/09/14 8:27 AM",
      "commitName": "24d920b80eb3626073925a1d0b6dcf148add8cc0",
      "commitAuthor": "Aaron T. Myers",
      "diff": "@@ -0,0 +1,120 @@\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.info(\"Rename path \" + src + \" to \" + dst);\n+\n+    String srcKey \u003d pathToKey(src);\n+    String dstKey \u003d pathToKey(dst);\n+\n+    if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n+      LOG.info(\"rename: src or dst are empty\");\n+      return false;\n+    }\n+\n+    if (srcKey.equals(dstKey)) {\n+      LOG.info(\"rename: src and dst refer to the same file\");\n+      return true;\n+    }\n+\n+    S3AFileStatus srcStatus;\n+    try {\n+      srcStatus \u003d getFileStatus(src);\n+    } catch (FileNotFoundException e) {\n+      LOG.info(\"rename: src not found \" + src);\n+      return false;\n+    }\n+\n+    S3AFileStatus dstStatus \u003d null;\n+    try {\n+      dstStatus \u003d getFileStatus(dst);\n+\n+      if (srcStatus.isFile() \u0026\u0026 dstStatus.isDirectory()) {\n+        LOG.info(\"rename: src is a file and dst is a directory\");\n+        return false;\n+      }\n+\n+      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n+        LOG.info(\"rename: src is a directory and dst is a file\");\n+        return false;\n+      }\n+\n+    } catch (FileNotFoundException e) {\n+      // Parent must exist\n+      Path parent \u003d dst.getParent();\n+      if (!pathToKey(parent).isEmpty()) {\n+        try {\n+          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n+          if (!dstParentStatus.isDirectory()) {\n+            return false;\n+          }\n+        } catch (FileNotFoundException e2) {\n+          return false;\n+        }\n+      }\n+    }\n+\n+    // Ok! Time to start\n+    if (srcStatus.isFile()) {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n+      }\n+      copyFile(srcKey, dstKey);\n+      delete(src, false);\n+    } else {\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n+      }\n+\n+      // This is a directory to directory copy\n+      if (!dstKey.endsWith(\"/\")) {\n+        dstKey \u003d dstKey + \"/\";\n+      }\n+\n+      if (!srcKey.endsWith(\"/\")) {\n+        srcKey \u003d srcKey + \"/\";\n+      }\n+\n+      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n+        new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n+      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n+        copyFile(srcKey, dstKey);\n+        statistics.incrementWriteOps(1);\n+        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(srcKey));\n+      }\n+\n+      ListObjectsRequest request \u003d new ListObjectsRequest();\n+      request.setBucketName(bucket);\n+      request.setPrefix(srcKey);\n+      request.setMaxKeys(maxKeys);\n+\n+      ObjectListing objects \u003d s3.listObjects(request);\n+      statistics.incrementReadOps(1);\n+\n+      while (true) {\n+        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n+          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n+          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n+          copyFile(summary.getKey(), newDstKey);\n+        }\n+\n+        if (objects.isTruncated()) {\n+          objects \u003d s3.listNextBatchOfObjects(objects);\n+          statistics.incrementReadOps(1);\n+        } else {\n+          break;\n+        }\n+      }\n+\n+\n+      if (!keysToDelete.isEmpty()) {\n+        DeleteObjectsRequest deleteRequest \u003d new DeleteObjectsRequest(bucket);\n+        deleteRequest.setKeys(keysToDelete);\n+        s3.deleteObjects(deleteRequest);\n+        statistics.incrementWriteOps(1);\n+      }\n+    }\n+\n+    if (src.getParent() !\u003d dst.getParent()) {\n+      deleteUnnecessaryFakeDirectories(dst.getParent());\n+      createFakeDirectoryIfNecessary(src.getParent());\n+    }\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean rename(Path src, Path dst) throws IOException {\n    LOG.info(\"Rename path \" + src + \" to \" + dst);\n\n    String srcKey \u003d pathToKey(src);\n    String dstKey \u003d pathToKey(dst);\n\n    if (srcKey.length() \u003d\u003d 0 || dstKey.length() \u003d\u003d 0) {\n      LOG.info(\"rename: src or dst are empty\");\n      return false;\n    }\n\n    if (srcKey.equals(dstKey)) {\n      LOG.info(\"rename: src and dst refer to the same file\");\n      return true;\n    }\n\n    S3AFileStatus srcStatus;\n    try {\n      srcStatus \u003d getFileStatus(src);\n    } catch (FileNotFoundException e) {\n      LOG.info(\"rename: src not found \" + src);\n      return false;\n    }\n\n    S3AFileStatus dstStatus \u003d null;\n    try {\n      dstStatus \u003d getFileStatus(dst);\n\n      if (srcStatus.isFile() \u0026\u0026 dstStatus.isDirectory()) {\n        LOG.info(\"rename: src is a file and dst is a directory\");\n        return false;\n      }\n\n      if (srcStatus.isDirectory() \u0026\u0026 dstStatus.isFile()) {\n        LOG.info(\"rename: src is a directory and dst is a file\");\n        return false;\n      }\n\n    } catch (FileNotFoundException e) {\n      // Parent must exist\n      Path parent \u003d dst.getParent();\n      if (!pathToKey(parent).isEmpty()) {\n        try {\n          S3AFileStatus dstParentStatus \u003d getFileStatus(dst.getParent());\n          if (!dstParentStatus.isDirectory()) {\n            return false;\n          }\n        } catch (FileNotFoundException e2) {\n          return false;\n        }\n      }\n    }\n\n    // Ok! Time to start\n    if (srcStatus.isFile()) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming file \" + src + \" to \" + dst);\n      }\n      copyFile(srcKey, dstKey);\n      delete(src, false);\n    } else {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"rename: renaming directory \" + src + \" to \" + dst);\n      }\n\n      // This is a directory to directory copy\n      if (!dstKey.endsWith(\"/\")) {\n        dstKey \u003d dstKey + \"/\";\n      }\n\n      if (!srcKey.endsWith(\"/\")) {\n        srcKey \u003d srcKey + \"/\";\n      }\n\n      List\u003cDeleteObjectsRequest.KeyVersion\u003e keysToDelete \u003d \n        new ArrayList\u003cDeleteObjectsRequest.KeyVersion\u003e();\n      if (dstStatus !\u003d null \u0026\u0026 dstStatus.isEmptyDirectory()) {\n        copyFile(srcKey, dstKey);\n        statistics.incrementWriteOps(1);\n        keysToDelete.add(new DeleteObjectsRequest.KeyVersion(srcKey));\n      }\n\n      ListObjectsRequest request \u003d new ListObjectsRequest();\n      request.setBucketName(bucket);\n      request.setPrefix(srcKey);\n      request.setMaxKeys(maxKeys);\n\n      ObjectListing objects \u003d s3.listObjects(request);\n      statistics.incrementReadOps(1);\n\n      while (true) {\n        for (S3ObjectSummary summary : objects.getObjectSummaries()) {\n          keysToDelete.add(new DeleteObjectsRequest.KeyVersion(summary.getKey()));\n          String newDstKey \u003d dstKey + summary.getKey().substring(srcKey.length());\n          copyFile(summary.getKey(), newDstKey);\n        }\n\n        if (objects.isTruncated()) {\n          objects \u003d s3.listNextBatchOfObjects(objects);\n          statistics.incrementReadOps(1);\n        } else {\n          break;\n        }\n      }\n\n\n      if (!keysToDelete.isEmpty()) {\n        DeleteObjectsRequest deleteRequest \u003d new DeleteObjectsRequest(bucket);\n        deleteRequest.setKeys(keysToDelete);\n        s3.deleteObjects(deleteRequest);\n        statistics.incrementWriteOps(1);\n      }\n    }\n\n    if (src.getParent() !\u003d dst.getParent()) {\n      deleteUnnecessaryFakeDirectories(dst.getParent());\n      createFakeDirectoryIfNecessary(src.getParent());\n    }\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java"
    }
  }
}