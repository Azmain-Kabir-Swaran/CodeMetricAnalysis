{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainersLauncher.java",
  "functionName": "handle",
  "functionId": "handle___event-ContainersLauncherEvent",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
  "functionStartLine": 122,
  "functionEndLine": 218,
  "numCommitsSeen": 30,
  "timeTaken": 10732,
  "changeHistory": [
    "e815fd9c49e80b9200dd8852abe74fe219ad9110",
    "5ce70e1211e624d58e8bb1181aec00729ebdc085",
    "cd04e954d2db27f0a15b7d1c492b7cdb656a51db",
    "a50be1b8f432f50c940b66d12c7de87b95ea47c0",
    "66ca0a65408521d5f9b080dd16b353b49fb8eaea",
    "864fbacd4548004b1de8b0812627976acd22aff5",
    "40b5a59b726733df456330a26f03d5174cc0bc1c",
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
    "8f08532bde153811368e1b8336446fba4743f9d2",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b",
    "74d20250ffe16a85c6ef70b70e1254a77eaf03a3",
    "49afc64cd469bc3a775c18e0458661e39270b7a5",
    "ff69557040fb414254e75bf57287aee1dc7ad855",
    "ac933234aca037f8d73537412c8f9567a2cbe60a",
    "2692675fc3b5046d2ec88542c30203c87e135b70",
    "27e8c86999bc6a972a99216060b11ef35b7de858",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
    "2fe343f96348e894e6ed16c447c8c77ba1611d11",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "e815fd9c49e80b9200dd8852abe74fe219ad9110": "Ybodychange",
    "5ce70e1211e624d58e8bb1181aec00729ebdc085": "Ybodychange",
    "cd04e954d2db27f0a15b7d1c492b7cdb656a51db": "Ybodychange",
    "a50be1b8f432f50c940b66d12c7de87b95ea47c0": "Ybodychange",
    "66ca0a65408521d5f9b080dd16b353b49fb8eaea": "Ybodychange",
    "864fbacd4548004b1de8b0812627976acd22aff5": "Ybodychange",
    "40b5a59b726733df456330a26f03d5174cc0bc1c": "Ybodychange",
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f": "Ybodychange",
    "8f08532bde153811368e1b8336446fba4743f9d2": "Ybodychange",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": "Ybodychange",
    "74d20250ffe16a85c6ef70b70e1254a77eaf03a3": "Ybodychange",
    "49afc64cd469bc3a775c18e0458661e39270b7a5": "Ybodychange",
    "ff69557040fb414254e75bf57287aee1dc7ad855": "Ybodychange",
    "ac933234aca037f8d73537412c8f9567a2cbe60a": "Ybodychange",
    "2692675fc3b5046d2ec88542c30203c87e135b70": "Ybodychange",
    "27e8c86999bc6a972a99216060b11ef35b7de858": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": "Ybodychange",
    "2fe343f96348e894e6ed16c447c8c77ba1611d11": "Ybodychange",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e815fd9c49e80b9200dd8852abe74fe219ad9110": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9126.  Fix container clean up for reinitialization.\n            Contributed by Chandni Singh\n",
      "commitDate": "19/12/18 11:55 AM",
      "commitName": "e815fd9c49e80b9200dd8852abe74fe219ad9110",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "10/10/18 7:52 AM",
      "commitNameOld": "5ce70e1211e624d58e8bb1181aec00729ebdc085",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 70.21,
      "commitsBetweenForRepo": 546,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,97 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case RELAUNCH_CONTAINER:\n         app \u003d context.getApplications().get(\n                 containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerRelaunch relaunch \u003d\n             new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                 event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(relaunch);\n         running.put(containerId, relaunch);\n         break;\n       case RECOVER_CONTAINER:\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n             exec, app, event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case RECOVER_PAUSED_CONTAINER:\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoverPausedContainerLaunch(context, getConfig(),\n             dispatcher, exec, app, event.getContainer(), dirsHandler,\n             containerManager);\n         containerLauncher.submit(launch);\n         break;\n       case CLEANUP_CONTAINER:\n+        cleanup(event, containerId, true);\n+        break;\n       case CLEANUP_CONTAINER_FOR_REINIT:\n-        ContainerLaunch existingLaunch \u003d running.remove(containerId);\n-        if (existingLaunch \u003d\u003d null) {\n-          // Container not launched.\n-          // triggering KILLING to CONTAINER_CLEANEDUP_AFTER_KILL transition.\n-          dispatcher.getEventHandler().handle(\n-              new ContainerExitEvent(containerId,\n-                  ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n-                  Shell.WINDOWS ? ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n-                  ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n-                  \"Container terminated before launch.\"));\n-          return;\n-        }\n-\n-        // Cleanup a container whether it is running/killed/completed, so that\n-        // no sub-processes are alive.\n-        ContainerCleanup cleanup \u003d new ContainerCleanup(context, getConfig(),\n-            dispatcher, exec, event.getContainer(), existingLaunch);\n-        containerLauncher.submit(cleanup);\n+        cleanup(event, containerId, false);\n         break;\n       case SIGNAL_CONTAINER:\n         SignalContainersLauncherEvent signalEvent \u003d\n             (SignalContainersLauncherEvent) event;\n         ContainerLaunch runningContainer \u003d running.get(containerId);\n         if (runningContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n           return;\n         }\n \n         try {\n           runningContainer.signalContainer(signalEvent.getCommand());\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while signaling container \" + containerId\n               + \" with command \" + signalEvent.getCommand());\n         }\n         break;\n       case PAUSE_CONTAINER:\n         ContainerLaunch launchedContainer \u003d running.get(containerId);\n         if (launchedContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Pause the container\n         try {\n           launchedContainer.pauseContainer();\n         } catch (Exception e) {\n           LOG.info(\"Got exception while pausing container: \" +\n             StringUtils.stringifyException(e));\n         }\n         break;\n       case RESUME_CONTAINER:\n         ContainerLaunch launchCont \u003d running.get(containerId);\n         if (launchCont \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Resume the container.\n         try {\n           launchCont.resumeContainer();\n         } catch (Exception e) {\n           LOG.info(\"Got exception while resuming container: \" +\n             StringUtils.stringifyException(e));\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RELAUNCH_CONTAINER:\n        app \u003d context.getApplications().get(\n                containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerRelaunch relaunch \u003d\n            new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(relaunch);\n        running.put(containerId, relaunch);\n        break;\n      case RECOVER_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RECOVER_PAUSED_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoverPausedContainerLaunch(context, getConfig(),\n            dispatcher, exec, app, event.getContainer(), dirsHandler,\n            containerManager);\n        containerLauncher.submit(launch);\n        break;\n      case CLEANUP_CONTAINER:\n        cleanup(event, containerId, true);\n        break;\n      case CLEANUP_CONTAINER_FOR_REINIT:\n        cleanup(event, containerId, false);\n        break;\n      case SIGNAL_CONTAINER:\n        SignalContainersLauncherEvent signalEvent \u003d\n            (SignalContainersLauncherEvent) event;\n        ContainerLaunch runningContainer \u003d running.get(containerId);\n        if (runningContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n          return;\n        }\n\n        try {\n          runningContainer.signalContainer(signalEvent.getCommand());\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while signaling container \" + containerId\n              + \" with command \" + signalEvent.getCommand());\n        }\n        break;\n      case PAUSE_CONTAINER:\n        ContainerLaunch launchedContainer \u003d running.get(containerId);\n        if (launchedContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Pause the container\n        try {\n          launchedContainer.pauseContainer();\n        } catch (Exception e) {\n          LOG.info(\"Got exception while pausing container: \" +\n            StringUtils.stringifyException(e));\n        }\n        break;\n      case RESUME_CONTAINER:\n        ContainerLaunch launchCont \u003d running.get(containerId);\n        if (launchCont \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Resume the container.\n        try {\n          launchCont.resumeContainer();\n        } catch (Exception e) {\n          LOG.info(\"Got exception while resuming container: \" +\n            StringUtils.stringifyException(e));\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "5ce70e1211e624d58e8bb1181aec00729ebdc085": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7644. NM gets backed up deleting docker containers. Contributed by Chandni Singh\n",
      "commitDate": "10/10/18 7:52 AM",
      "commitName": "5ce70e1211e624d58e8bb1181aec00729ebdc085",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "09/08/18 8:17 AM",
      "commitNameOld": "cd04e954d2db27f0a15b7d1c492b7cdb656a51db",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 61.98,
      "commitsBetweenForRepo": 582,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,112 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case RELAUNCH_CONTAINER:\n         app \u003d context.getApplications().get(\n                 containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerRelaunch relaunch \u003d\n             new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                 event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(relaunch);\n         running.put(containerId, relaunch);\n         break;\n       case RECOVER_CONTAINER:\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n             exec, app, event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case RECOVER_PAUSED_CONTAINER:\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoverPausedContainerLaunch(context, getConfig(),\n             dispatcher, exec, app, event.getContainer(), dirsHandler,\n             containerManager);\n         containerLauncher.submit(launch);\n         break;\n       case CLEANUP_CONTAINER:\n       case CLEANUP_CONTAINER_FOR_REINIT:\n-        ContainerLaunch launcher \u003d running.remove(containerId);\n-        if (launcher \u003d\u003d null) {\n+        ContainerLaunch existingLaunch \u003d running.remove(containerId);\n+        if (existingLaunch \u003d\u003d null) {\n           // Container not launched.\n           // triggering KILLING to CONTAINER_CLEANEDUP_AFTER_KILL transition.\n           dispatcher.getEventHandler().handle(\n               new ContainerExitEvent(containerId,\n                   ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                   Shell.WINDOWS ? ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                   ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                   \"Container terminated before launch.\"));\n           return;\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n-        try {\n-          launcher.cleanupContainer();\n-        } catch (IOException e) {\n-          LOG.warn(\"Got exception while cleaning container \" + containerId\n-              + \". Ignoring.\");\n-        }\n+        ContainerCleanup cleanup \u003d new ContainerCleanup(context, getConfig(),\n+            dispatcher, exec, event.getContainer(), existingLaunch);\n+        containerLauncher.submit(cleanup);\n         break;\n       case SIGNAL_CONTAINER:\n         SignalContainersLauncherEvent signalEvent \u003d\n             (SignalContainersLauncherEvent) event;\n         ContainerLaunch runningContainer \u003d running.get(containerId);\n         if (runningContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n           return;\n         }\n \n         try {\n           runningContainer.signalContainer(signalEvent.getCommand());\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while signaling container \" + containerId\n               + \" with command \" + signalEvent.getCommand());\n         }\n         break;\n       case PAUSE_CONTAINER:\n         ContainerLaunch launchedContainer \u003d running.get(containerId);\n         if (launchedContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Pause the container\n         try {\n           launchedContainer.pauseContainer();\n         } catch (Exception e) {\n           LOG.info(\"Got exception while pausing container: \" +\n             StringUtils.stringifyException(e));\n         }\n         break;\n       case RESUME_CONTAINER:\n         ContainerLaunch launchCont \u003d running.get(containerId);\n         if (launchCont \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Resume the container.\n         try {\n           launchCont.resumeContainer();\n         } catch (Exception e) {\n           LOG.info(\"Got exception while resuming container: \" +\n             StringUtils.stringifyException(e));\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RELAUNCH_CONTAINER:\n        app \u003d context.getApplications().get(\n                containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerRelaunch relaunch \u003d\n            new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(relaunch);\n        running.put(containerId, relaunch);\n        break;\n      case RECOVER_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RECOVER_PAUSED_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoverPausedContainerLaunch(context, getConfig(),\n            dispatcher, exec, app, event.getContainer(), dirsHandler,\n            containerManager);\n        containerLauncher.submit(launch);\n        break;\n      case CLEANUP_CONTAINER:\n      case CLEANUP_CONTAINER_FOR_REINIT:\n        ContainerLaunch existingLaunch \u003d running.remove(containerId);\n        if (existingLaunch \u003d\u003d null) {\n          // Container not launched.\n          // triggering KILLING to CONTAINER_CLEANEDUP_AFTER_KILL transition.\n          dispatcher.getEventHandler().handle(\n              new ContainerExitEvent(containerId,\n                  ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                  Shell.WINDOWS ? ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                  ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                  \"Container terminated before launch.\"));\n          return;\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        ContainerCleanup cleanup \u003d new ContainerCleanup(context, getConfig(),\n            dispatcher, exec, event.getContainer(), existingLaunch);\n        containerLauncher.submit(cleanup);\n        break;\n      case SIGNAL_CONTAINER:\n        SignalContainersLauncherEvent signalEvent \u003d\n            (SignalContainersLauncherEvent) event;\n        ContainerLaunch runningContainer \u003d running.get(containerId);\n        if (runningContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n          return;\n        }\n\n        try {\n          runningContainer.signalContainer(signalEvent.getCommand());\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while signaling container \" + containerId\n              + \" with command \" + signalEvent.getCommand());\n        }\n        break;\n      case PAUSE_CONTAINER:\n        ContainerLaunch launchedContainer \u003d running.get(containerId);\n        if (launchedContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Pause the container\n        try {\n          launchedContainer.pauseContainer();\n        } catch (Exception e) {\n          LOG.info(\"Got exception while pausing container: \" +\n            StringUtils.stringifyException(e));\n        }\n        break;\n      case RESUME_CONTAINER:\n        ContainerLaunch launchCont \u003d running.get(containerId);\n        if (launchCont \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Resume the container.\n        try {\n          launchCont.resumeContainer();\n        } catch (Exception e) {\n          LOG.info(\"Got exception while resuming container: \" +\n            StringUtils.stringifyException(e));\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "cd04e954d2db27f0a15b7d1c492b7cdb656a51db": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8331. Race condition in NM container launched after done. Contributed by Pradeep Ambati\n",
      "commitDate": "09/08/18 8:17 AM",
      "commitName": "cd04e954d2db27f0a15b7d1c492b7cdb656a51db",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "16/10/17 1:12 PM",
      "commitNameOld": "a50be1b8f432f50c940b66d12c7de87b95ea47c0",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 296.8,
      "commitsBetweenForRepo": 2649,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,115 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case RELAUNCH_CONTAINER:\n         app \u003d context.getApplications().get(\n                 containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerRelaunch relaunch \u003d\n             new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                 event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(relaunch);\n         running.put(containerId, relaunch);\n         break;\n       case RECOVER_CONTAINER:\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n             exec, app, event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case RECOVER_PAUSED_CONTAINER:\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoverPausedContainerLaunch(context, getConfig(),\n             dispatcher, exec, app, event.getContainer(), dirsHandler,\n             containerManager);\n         containerLauncher.submit(launch);\n         break;\n       case CLEANUP_CONTAINER:\n       case CLEANUP_CONTAINER_FOR_REINIT:\n         ContainerLaunch launcher \u003d running.remove(containerId);\n         if (launcher \u003d\u003d null) {\n-          // Container not launched. So nothing needs to be done.\n+          // Container not launched.\n+          // triggering KILLING to CONTAINER_CLEANEDUP_AFTER_KILL transition.\n+          dispatcher.getEventHandler().handle(\n+              new ContainerExitEvent(containerId,\n+                  ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n+                  Shell.WINDOWS ? ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n+                  ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n+                  \"Container terminated before launch.\"));\n           return;\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n       case SIGNAL_CONTAINER:\n         SignalContainersLauncherEvent signalEvent \u003d\n             (SignalContainersLauncherEvent) event;\n         ContainerLaunch runningContainer \u003d running.get(containerId);\n         if (runningContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n           return;\n         }\n \n         try {\n           runningContainer.signalContainer(signalEvent.getCommand());\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while signaling container \" + containerId\n               + \" with command \" + signalEvent.getCommand());\n         }\n         break;\n       case PAUSE_CONTAINER:\n         ContainerLaunch launchedContainer \u003d running.get(containerId);\n         if (launchedContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Pause the container\n         try {\n           launchedContainer.pauseContainer();\n         } catch (Exception e) {\n           LOG.info(\"Got exception while pausing container: \" +\n             StringUtils.stringifyException(e));\n         }\n         break;\n       case RESUME_CONTAINER:\n         ContainerLaunch launchCont \u003d running.get(containerId);\n         if (launchCont \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Resume the container.\n         try {\n           launchCont.resumeContainer();\n         } catch (Exception e) {\n           LOG.info(\"Got exception while resuming container: \" +\n             StringUtils.stringifyException(e));\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RELAUNCH_CONTAINER:\n        app \u003d context.getApplications().get(\n                containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerRelaunch relaunch \u003d\n            new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(relaunch);\n        running.put(containerId, relaunch);\n        break;\n      case RECOVER_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RECOVER_PAUSED_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoverPausedContainerLaunch(context, getConfig(),\n            dispatcher, exec, app, event.getContainer(), dirsHandler,\n            containerManager);\n        containerLauncher.submit(launch);\n        break;\n      case CLEANUP_CONTAINER:\n      case CLEANUP_CONTAINER_FOR_REINIT:\n        ContainerLaunch launcher \u003d running.remove(containerId);\n        if (launcher \u003d\u003d null) {\n          // Container not launched.\n          // triggering KILLING to CONTAINER_CLEANEDUP_AFTER_KILL transition.\n          dispatcher.getEventHandler().handle(\n              new ContainerExitEvent(containerId,\n                  ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                  Shell.WINDOWS ? ContainerExecutor.ExitCode.FORCE_KILLED.getExitCode() :\n                  ContainerExecutor.ExitCode.TERMINATED.getExitCode(),\n                  \"Container terminated before launch.\"));\n          return;\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n      case SIGNAL_CONTAINER:\n        SignalContainersLauncherEvent signalEvent \u003d\n            (SignalContainersLauncherEvent) event;\n        ContainerLaunch runningContainer \u003d running.get(containerId);\n        if (runningContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n          return;\n        }\n\n        try {\n          runningContainer.signalContainer(signalEvent.getCommand());\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while signaling container \" + containerId\n              + \" with command \" + signalEvent.getCommand());\n        }\n        break;\n      case PAUSE_CONTAINER:\n        ContainerLaunch launchedContainer \u003d running.get(containerId);\n        if (launchedContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Pause the container\n        try {\n          launchedContainer.pauseContainer();\n        } catch (Exception e) {\n          LOG.info(\"Got exception while pausing container: \" +\n            StringUtils.stringifyException(e));\n        }\n        break;\n      case RESUME_CONTAINER:\n        ContainerLaunch launchCont \u003d running.get(containerId);\n        if (launchCont \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Resume the container.\n        try {\n          launchCont.resumeContainer();\n        } catch (Exception e) {\n          LOG.info(\"Got exception while resuming container: \" +\n            StringUtils.stringifyException(e));\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "a50be1b8f432f50c940b66d12c7de87b95ea47c0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7275. NM Statestore cleanup for Container updates. (Kartheek Muthyala via asuresh)\n",
      "commitDate": "16/10/17 1:12 PM",
      "commitName": "a50be1b8f432f50c940b66d12c7de87b95ea47c0",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "14/09/17 8:51 AM",
      "commitNameOld": "66ca0a65408521d5f9b080dd16b353b49fb8eaea",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 32.18,
      "commitsBetweenForRepo": 252,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,108 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case RELAUNCH_CONTAINER:\n         app \u003d context.getApplications().get(\n                 containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerRelaunch relaunch \u003d\n             new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                 event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(relaunch);\n         running.put(containerId, relaunch);\n         break;\n       case RECOVER_CONTAINER:\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n             exec, app, event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case RECOVER_PAUSED_CONTAINER:\n-        // Recovery for paused containers is not supported, thus here\n-        // we locate any paused containers, and terminate them.\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoverPausedContainerLaunch(context, getConfig(),\n             dispatcher, exec, app, event.getContainer(), dirsHandler,\n             containerManager);\n         containerLauncher.submit(launch);\n         break;\n       case CLEANUP_CONTAINER:\n       case CLEANUP_CONTAINER_FOR_REINIT:\n         ContainerLaunch launcher \u003d running.remove(containerId);\n         if (launcher \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n       case SIGNAL_CONTAINER:\n         SignalContainersLauncherEvent signalEvent \u003d\n             (SignalContainersLauncherEvent) event;\n         ContainerLaunch runningContainer \u003d running.get(containerId);\n         if (runningContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n           return;\n         }\n \n         try {\n           runningContainer.signalContainer(signalEvent.getCommand());\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while signaling container \" + containerId\n               + \" with command \" + signalEvent.getCommand());\n         }\n         break;\n       case PAUSE_CONTAINER:\n         ContainerLaunch launchedContainer \u003d running.get(containerId);\n         if (launchedContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Pause the container\n         try {\n           launchedContainer.pauseContainer();\n         } catch (Exception e) {\n           LOG.info(\"Got exception while pausing container: \" +\n             StringUtils.stringifyException(e));\n         }\n         break;\n       case RESUME_CONTAINER:\n         ContainerLaunch launchCont \u003d running.get(containerId);\n         if (launchCont \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Resume the container.\n         try {\n           launchCont.resumeContainer();\n         } catch (Exception e) {\n           LOG.info(\"Got exception while resuming container: \" +\n             StringUtils.stringifyException(e));\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RELAUNCH_CONTAINER:\n        app \u003d context.getApplications().get(\n                containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerRelaunch relaunch \u003d\n            new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(relaunch);\n        running.put(containerId, relaunch);\n        break;\n      case RECOVER_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RECOVER_PAUSED_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoverPausedContainerLaunch(context, getConfig(),\n            dispatcher, exec, app, event.getContainer(), dirsHandler,\n            containerManager);\n        containerLauncher.submit(launch);\n        break;\n      case CLEANUP_CONTAINER:\n      case CLEANUP_CONTAINER_FOR_REINIT:\n        ContainerLaunch launcher \u003d running.remove(containerId);\n        if (launcher \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n      case SIGNAL_CONTAINER:\n        SignalContainersLauncherEvent signalEvent \u003d\n            (SignalContainersLauncherEvent) event;\n        ContainerLaunch runningContainer \u003d running.get(containerId);\n        if (runningContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n          return;\n        }\n\n        try {\n          runningContainer.signalContainer(signalEvent.getCommand());\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while signaling container \" + containerId\n              + \" with command \" + signalEvent.getCommand());\n        }\n        break;\n      case PAUSE_CONTAINER:\n        ContainerLaunch launchedContainer \u003d running.get(containerId);\n        if (launchedContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Pause the container\n        try {\n          launchedContainer.pauseContainer();\n        } catch (Exception e) {\n          LOG.info(\"Got exception while pausing container: \" +\n            StringUtils.stringifyException(e));\n        }\n        break;\n      case RESUME_CONTAINER:\n        ContainerLaunch launchCont \u003d running.get(containerId);\n        if (launchCont \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Resume the container.\n        try {\n          launchCont.resumeContainer();\n        } catch (Exception e) {\n          LOG.info(\"Got exception while resuming container: \" +\n            StringUtils.stringifyException(e));\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "66ca0a65408521d5f9b080dd16b353b49fb8eaea": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6059. Update paused container state in the NM state store. (Hitesh Sharma via asuresh)\n",
      "commitDate": "14/09/17 8:51 AM",
      "commitName": "66ca0a65408521d5f9b080dd16b353b49fb8eaea",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "14/09/17 8:48 AM",
      "commitNameOld": "864fbacd4548004b1de8b0812627976acd22aff5",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,110 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case RELAUNCH_CONTAINER:\n         app \u003d context.getApplications().get(\n                 containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerRelaunch relaunch \u003d\n             new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                 event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(relaunch);\n         running.put(containerId, relaunch);\n         break;\n       case RECOVER_CONTAINER:\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n             exec, app, event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n+      case RECOVER_PAUSED_CONTAINER:\n+        // Recovery for paused containers is not supported, thus here\n+        // we locate any paused containers, and terminate them.\n+        app \u003d context.getApplications().get(\n+            containerId.getApplicationAttemptId().getApplicationId());\n+        launch \u003d new RecoverPausedContainerLaunch(context, getConfig(),\n+            dispatcher, exec, app, event.getContainer(), dirsHandler,\n+            containerManager);\n+        containerLauncher.submit(launch);\n+        break;\n       case CLEANUP_CONTAINER:\n       case CLEANUP_CONTAINER_FOR_REINIT:\n         ContainerLaunch launcher \u003d running.remove(containerId);\n         if (launcher \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n       case SIGNAL_CONTAINER:\n         SignalContainersLauncherEvent signalEvent \u003d\n             (SignalContainersLauncherEvent) event;\n         ContainerLaunch runningContainer \u003d running.get(containerId);\n         if (runningContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n           return;\n         }\n \n         try {\n           runningContainer.signalContainer(signalEvent.getCommand());\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while signaling container \" + containerId\n               + \" with command \" + signalEvent.getCommand());\n         }\n         break;\n       case PAUSE_CONTAINER:\n         ContainerLaunch launchedContainer \u003d running.get(containerId);\n         if (launchedContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Pause the container\n         try {\n           launchedContainer.pauseContainer();\n         } catch (Exception e) {\n           LOG.info(\"Got exception while pausing container: \" +\n             StringUtils.stringifyException(e));\n         }\n         break;\n       case RESUME_CONTAINER:\n         ContainerLaunch launchCont \u003d running.get(containerId);\n         if (launchCont \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Resume the container.\n         try {\n           launchCont.resumeContainer();\n         } catch (Exception e) {\n           LOG.info(\"Got exception while resuming container: \" +\n             StringUtils.stringifyException(e));\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RELAUNCH_CONTAINER:\n        app \u003d context.getApplications().get(\n                containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerRelaunch relaunch \u003d\n            new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(relaunch);\n        running.put(containerId, relaunch);\n        break;\n      case RECOVER_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RECOVER_PAUSED_CONTAINER:\n        // Recovery for paused containers is not supported, thus here\n        // we locate any paused containers, and terminate them.\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoverPausedContainerLaunch(context, getConfig(),\n            dispatcher, exec, app, event.getContainer(), dirsHandler,\n            containerManager);\n        containerLauncher.submit(launch);\n        break;\n      case CLEANUP_CONTAINER:\n      case CLEANUP_CONTAINER_FOR_REINIT:\n        ContainerLaunch launcher \u003d running.remove(containerId);\n        if (launcher \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n      case SIGNAL_CONTAINER:\n        SignalContainersLauncherEvent signalEvent \u003d\n            (SignalContainersLauncherEvent) event;\n        ContainerLaunch runningContainer \u003d running.get(containerId);\n        if (runningContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n          return;\n        }\n\n        try {\n          runningContainer.signalContainer(signalEvent.getCommand());\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while signaling container \" + containerId\n              + \" with command \" + signalEvent.getCommand());\n        }\n        break;\n      case PAUSE_CONTAINER:\n        ContainerLaunch launchedContainer \u003d running.get(containerId);\n        if (launchedContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Pause the container\n        try {\n          launchedContainer.pauseContainer();\n        } catch (Exception e) {\n          LOG.info(\"Got exception while pausing container: \" +\n            StringUtils.stringifyException(e));\n        }\n        break;\n      case RESUME_CONTAINER:\n        ContainerLaunch launchCont \u003d running.get(containerId);\n        if (launchCont \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Resume the container.\n        try {\n          launchCont.resumeContainer();\n        } catch (Exception e) {\n          LOG.info(\"Got exception while resuming container: \" +\n            StringUtils.stringifyException(e));\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "864fbacd4548004b1de8b0812627976acd22aff5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5292. NM Container lifecycle and state transitions to support for PAUSED container state. (Hitesh Sharma via asuresh)\n",
      "commitDate": "14/09/17 8:48 AM",
      "commitName": "864fbacd4548004b1de8b0812627976acd22aff5",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "22/08/17 1:14 AM",
      "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 23.32,
      "commitsBetweenForRepo": 264,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,100 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case RELAUNCH_CONTAINER:\n         app \u003d context.getApplications().get(\n                 containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerRelaunch relaunch \u003d\n             new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                 event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(relaunch);\n         running.put(containerId, relaunch);\n         break;\n       case RECOVER_CONTAINER:\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n             exec, app, event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case CLEANUP_CONTAINER:\n       case CLEANUP_CONTAINER_FOR_REINIT:\n         ContainerLaunch launcher \u003d running.remove(containerId);\n         if (launcher \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n       case SIGNAL_CONTAINER:\n         SignalContainersLauncherEvent signalEvent \u003d\n             (SignalContainersLauncherEvent) event;\n         ContainerLaunch runningContainer \u003d running.get(containerId);\n         if (runningContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n           return;\n         }\n \n         try {\n           runningContainer.signalContainer(signalEvent.getCommand());\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while signaling container \" + containerId\n               + \" with command \" + signalEvent.getCommand());\n         }\n         break;\n+      case PAUSE_CONTAINER:\n+        ContainerLaunch launchedContainer \u003d running.get(containerId);\n+        if (launchedContainer \u003d\u003d null) {\n+          // Container not launched. So nothing needs to be done.\n+          return;\n+        }\n+\n+        // Pause the container\n+        try {\n+          launchedContainer.pauseContainer();\n+        } catch (Exception e) {\n+          LOG.info(\"Got exception while pausing container: \" +\n+            StringUtils.stringifyException(e));\n+        }\n+        break;\n+      case RESUME_CONTAINER:\n+        ContainerLaunch launchCont \u003d running.get(containerId);\n+        if (launchCont \u003d\u003d null) {\n+          // Container not launched. So nothing needs to be done.\n+          return;\n+        }\n+\n+        // Resume the container.\n+        try {\n+          launchCont.resumeContainer();\n+        } catch (Exception e) {\n+          LOG.info(\"Got exception while resuming container: \" +\n+            StringUtils.stringifyException(e));\n+        }\n+        break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RELAUNCH_CONTAINER:\n        app \u003d context.getApplications().get(\n                containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerRelaunch relaunch \u003d\n            new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(relaunch);\n        running.put(containerId, relaunch);\n        break;\n      case RECOVER_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case CLEANUP_CONTAINER:\n      case CLEANUP_CONTAINER_FOR_REINIT:\n        ContainerLaunch launcher \u003d running.remove(containerId);\n        if (launcher \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n      case SIGNAL_CONTAINER:\n        SignalContainersLauncherEvent signalEvent \u003d\n            (SignalContainersLauncherEvent) event;\n        ContainerLaunch runningContainer \u003d running.get(containerId);\n        if (runningContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n          return;\n        }\n\n        try {\n          runningContainer.signalContainer(signalEvent.getCommand());\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while signaling container \" + containerId\n              + \" with command \" + signalEvent.getCommand());\n        }\n        break;\n      case PAUSE_CONTAINER:\n        ContainerLaunch launchedContainer \u003d running.get(containerId);\n        if (launchedContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Pause the container\n        try {\n          launchedContainer.pauseContainer();\n        } catch (Exception e) {\n          LOG.info(\"Got exception while pausing container: \" +\n            StringUtils.stringifyException(e));\n        }\n        break;\n      case RESUME_CONTAINER:\n        ContainerLaunch launchCont \u003d running.get(containerId);\n        if (launchCont \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Resume the container.\n        try {\n          launchCont.resumeContainer();\n        } catch (Exception e) {\n          LOG.info(\"Got exception while resuming container: \" +\n            StringUtils.stringifyException(e));\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "40b5a59b726733df456330a26f03d5174cc0bc1c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5620. Core changes in NodeManager to support re-initialization of Containers with new launchContext. (asuresh)\n",
      "commitDate": "15/09/16 7:15 AM",
      "commitName": "40b5a59b726733df456330a26f03d5174cc0bc1c",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "29/04/16 3:39 AM",
      "commitNameOld": "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 139.15,
      "commitsBetweenForRepo": 1032,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,70 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case RELAUNCH_CONTAINER:\n         app \u003d context.getApplications().get(\n                 containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerRelaunch relaunch \u003d\n             new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                 event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(relaunch);\n         running.put(containerId, relaunch);\n         break;\n       case RECOVER_CONTAINER:\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n             exec, app, event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case CLEANUP_CONTAINER:\n+      case CLEANUP_CONTAINER_FOR_REINIT:\n         ContainerLaunch launcher \u003d running.remove(containerId);\n         if (launcher \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n       case SIGNAL_CONTAINER:\n         SignalContainersLauncherEvent signalEvent \u003d\n             (SignalContainersLauncherEvent) event;\n         ContainerLaunch runningContainer \u003d running.get(containerId);\n         if (runningContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n           return;\n         }\n \n         try {\n           runningContainer.signalContainer(signalEvent.getCommand());\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while signaling container \" + containerId\n               + \" with command \" + signalEvent.getCommand());\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RELAUNCH_CONTAINER:\n        app \u003d context.getApplications().get(\n                containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerRelaunch relaunch \u003d\n            new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(relaunch);\n        running.put(containerId, relaunch);\n        break;\n      case RECOVER_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case CLEANUP_CONTAINER:\n      case CLEANUP_CONTAINER_FOR_REINIT:\n        ContainerLaunch launcher \u003d running.remove(containerId);\n        if (launcher \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n      case SIGNAL_CONTAINER:\n        SignalContainersLauncherEvent signalEvent \u003d\n            (SignalContainersLauncherEvent) event;\n        ContainerLaunch runningContainer \u003d running.get(containerId);\n        if (runningContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n          return;\n        }\n\n        try {\n          runningContainer.signalContainer(signalEvent.getCommand());\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while signaling container \" + containerId\n              + \" with command \" + signalEvent.getCommand());\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3998. Add support in the NodeManager to re-launch containers. Contributed by Jun Gong.\n",
      "commitDate": "29/04/16 3:39 AM",
      "commitName": "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "10/02/16 10:36 PM",
      "commitNameOld": "fa00d3e20560bee412b49e5792595749a247a8ab",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 78.17,
      "commitsBetweenForRepo": 480,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,69 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n+      case RELAUNCH_CONTAINER:\n+        app \u003d context.getApplications().get(\n+                containerId.getApplicationAttemptId().getApplicationId());\n+\n+        ContainerRelaunch relaunch \u003d\n+            new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n+                event.getContainer(), dirsHandler, containerManager);\n+        containerLauncher.submit(relaunch);\n+        running.put(containerId, relaunch);\n+        break;\n       case RECOVER_CONTAINER:\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n             exec, app, event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case CLEANUP_CONTAINER:\n         ContainerLaunch launcher \u003d running.remove(containerId);\n         if (launcher \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n       case SIGNAL_CONTAINER:\n         SignalContainersLauncherEvent signalEvent \u003d\n             (SignalContainersLauncherEvent) event;\n         ContainerLaunch runningContainer \u003d running.get(containerId);\n         if (runningContainer \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n           return;\n         }\n \n         try {\n           runningContainer.signalContainer(signalEvent.getCommand());\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while signaling container \" + containerId\n               + \" with command \" + signalEvent.getCommand());\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RELAUNCH_CONTAINER:\n        app \u003d context.getApplications().get(\n                containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerRelaunch relaunch \u003d\n            new ContainerRelaunch(context, getConfig(), dispatcher, exec, app,\n                event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(relaunch);\n        running.put(containerId, relaunch);\n        break;\n      case RECOVER_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case CLEANUP_CONTAINER:\n        ContainerLaunch launcher \u003d running.remove(containerId);\n        if (launcher \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n      case SIGNAL_CONTAINER:\n        SignalContainersLauncherEvent signalEvent \u003d\n            (SignalContainersLauncherEvent) event;\n        ContainerLaunch runningContainer \u003d running.get(containerId);\n        if (runningContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n          return;\n        }\n\n        try {\n          runningContainer.signalContainer(signalEvent.getCommand());\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while signaling container \" + containerId\n              + \" with command \" + signalEvent.getCommand());\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "8f08532bde153811368e1b8336446fba4743f9d2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1897. CLI and core support for signal container functionality. Contributed by Ming Ma\n",
      "commitDate": "02/10/15 6:50 PM",
      "commitName": "8f08532bde153811368e1b8336446fba4743f9d2",
      "commitAuthor": "Xuan",
      "commitDateOld": "12/08/14 3:56 AM",
      "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 416.62,
      "commitsBetweenForRepo": 3583,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,59 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case RECOVER_CONTAINER:\n         app \u003d context.getApplications().get(\n             containerId.getApplicationAttemptId().getApplicationId());\n         launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n             exec, app, event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n       case CLEANUP_CONTAINER:\n         ContainerLaunch launcher \u003d running.remove(containerId);\n         if (launcher \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n+      case SIGNAL_CONTAINER:\n+        SignalContainersLauncherEvent signalEvent \u003d\n+            (SignalContainersLauncherEvent) event;\n+        ContainerLaunch runningContainer \u003d running.get(containerId);\n+        if (runningContainer \u003d\u003d null) {\n+          // Container not launched. So nothing needs to be done.\n+          LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n+          return;\n+        }\n+\n+        try {\n+          runningContainer.signalContainer(signalEvent.getCommand());\n+        } catch (IOException e) {\n+          LOG.warn(\"Got exception while signaling container \" + containerId\n+              + \" with command \" + signalEvent.getCommand());\n+        }\n+        break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RECOVER_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case CLEANUP_CONTAINER:\n        ContainerLaunch launcher \u003d running.remove(containerId);\n        if (launcher \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n      case SIGNAL_CONTAINER:\n        SignalContainersLauncherEvent signalEvent \u003d\n            (SignalContainersLauncherEvent) event;\n        ContainerLaunch runningContainer \u003d running.get(containerId);\n        if (runningContainer \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          LOG.info(\"Container \" + containerId + \" not running, nothing to signal.\");\n          return;\n        }\n\n        try {\n          runningContainer.signalContainer(signalEvent.getCommand());\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while signaling container \" + containerId\n              + \" with command \" + signalEvent.getCommand());\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1337. Recover containers upon nodemanager restart. (Contributed by Jason Lowe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617448 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 3:56 AM",
      "commitName": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthor": "Junping Du",
      "commitDateOld": "30/09/13 5:18 PM",
      "commitNameOld": "74d20250ffe16a85c6ef70b70e1254a77eaf03a3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 315.44,
      "commitsBetweenForRepo": 2140,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,42 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler, containerManager);\n         containerLauncher.submit(launch);\n         running.put(containerId, launch);\n         break;\n+      case RECOVER_CONTAINER:\n+        app \u003d context.getApplications().get(\n+            containerId.getApplicationAttemptId().getApplicationId());\n+        launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n+            exec, app, event.getContainer(), dirsHandler, containerManager);\n+        containerLauncher.submit(launch);\n+        running.put(containerId, launch);\n+        break;\n       case CLEANUP_CONTAINER:\n         ContainerLaunch launcher \u003d running.remove(containerId);\n         if (launcher \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case RECOVER_CONTAINER:\n        app \u003d context.getApplications().get(\n            containerId.getApplicationAttemptId().getApplicationId());\n        launch \u003d new RecoveredContainerLaunch(context, getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case CLEANUP_CONTAINER:\n        ContainerLaunch launcher \u003d running.remove(containerId);\n        if (launcher \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "74d20250ffe16a85c6ef70b70e1254a77eaf03a3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1070. Fixed race conditions in NodeManager during container-kill. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527827 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/09/13 5:18 PM",
      "commitName": "74d20250ffe16a85c6ef70b70e1254a77eaf03a3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "04/09/13 1:42 PM",
      "commitNameOld": "49afc64cd469bc3a775c18e0458661e39270b7a5",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 26.15,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,34 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler, containerManager);\n-        running.put(containerId,\n-            new RunningContainer(containerLauncher.submit(launch), \n-                launch));\n+        containerLauncher.submit(launch);\n+        running.put(containerId, launch);\n         break;\n       case CLEANUP_CONTAINER:\n-        RunningContainer rContainerDatum \u003d running.remove(containerId);\n-        if (rContainerDatum \u003d\u003d null) {\n+        ContainerLaunch launcher \u003d running.remove(containerId);\n+        if (launcher \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n-        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n-        if (rContainer !\u003d null \n-            \u0026\u0026 !rContainer.isDone()) {\n-          // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n-          // If it is going to be canceled, make sure CONTAINER_KILLED_ON_REQUEST\n-          // will not be missed if the container is already at KILLING\n-          if (rContainer.cancel(false)) {\n-            if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n-              dispatcher.getEventHandler().handle(\n-                  new ContainerExitEvent(containerId,\n-                      ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n-                      Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() : \n-                        ExitCode.TERMINATED.getExitCode(),\n-                      \"Container terminated before launch.\"));\n-            }\n-          }\n-        }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n-          rContainerDatum.launcher.cleanupContainer();\n+          launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler, containerManager);\n        containerLauncher.submit(launch);\n        running.put(containerId, launch);\n        break;\n      case CLEANUP_CONTAINER:\n        ContainerLaunch launcher \u003d running.remove(containerId);\n        if (launcher \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "49afc64cd469bc3a775c18e0458661e39270b7a5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1065. NM should provide AuxillaryService data to the container (Xuan Gong via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1520135 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/13 1:42 PM",
      "commitName": "49afc64cd469bc3a775c18e0458661e39270b7a5",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "01/09/13 8:10 PM",
      "commitNameOld": "ff69557040fb414254e75bf57287aee1dc7ad855",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.73,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n-              event.getContainer(), dirsHandler);\n+              event.getContainer(), dirsHandler, containerManager);\n         running.put(containerId,\n             new RunningContainer(containerLauncher.submit(launch), \n                 launch));\n         break;\n       case CLEANUP_CONTAINER:\n         RunningContainer rContainerDatum \u003d running.remove(containerId);\n         if (rContainerDatum \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n         Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n         if (rContainer !\u003d null \n             \u0026\u0026 !rContainer.isDone()) {\n           // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n           // If it is going to be canceled, make sure CONTAINER_KILLED_ON_REQUEST\n           // will not be missed if the container is already at KILLING\n           if (rContainer.cancel(false)) {\n             if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n               dispatcher.getEventHandler().handle(\n                   new ContainerExitEvent(containerId,\n                       ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                       Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() : \n                         ExitCode.TERMINATED.getExitCode(),\n                       \"Container terminated before launch.\"));\n             }\n           }\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           rContainerDatum.launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler, containerManager);\n        running.put(containerId,\n            new RunningContainer(containerLauncher.submit(launch), \n                launch));\n        break;\n      case CLEANUP_CONTAINER:\n        RunningContainer rContainerDatum \u003d running.remove(containerId);\n        if (rContainerDatum \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n        if (rContainer !\u003d null \n            \u0026\u0026 !rContainer.isDone()) {\n          // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n          // If it is going to be canceled, make sure CONTAINER_KILLED_ON_REQUEST\n          // will not be missed if the container is already at KILLING\n          if (rContainer.cancel(false)) {\n            if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n              dispatcher.getEventHandler().handle(\n                  new ContainerExitEvent(containerId,\n                      ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                      Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() : \n                        ExitCode.TERMINATED.getExitCode(),\n                      \"Container terminated before launch.\"));\n            }\n          }\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          rContainerDatum.launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "ff69557040fb414254e75bf57287aee1dc7ad855": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1077. Fixed TestContainerLaunch test failure on Windows. Contributed by Chuan Liu.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1519333 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/09/13 8:10 PM",
      "commitName": "ff69557040fb414254e75bf57287aee1dc7ad855",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/08/13 5:49 PM",
      "commitNameOld": "ac933234aca037f8d73537412c8f9567a2cbe60a",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 30.1,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,52 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler);\n         running.put(containerId,\n             new RunningContainer(containerLauncher.submit(launch), \n                 launch));\n         break;\n       case CLEANUP_CONTAINER:\n         RunningContainer rContainerDatum \u003d running.remove(containerId);\n         if (rContainerDatum \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n         Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n         if (rContainer !\u003d null \n             \u0026\u0026 !rContainer.isDone()) {\n           // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n           // If it is going to be canceled, make sure CONTAINER_KILLED_ON_REQUEST\n           // will not be missed if the container is already at KILLING\n           if (rContainer.cancel(false)) {\n             if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n               dispatcher.getEventHandler().handle(\n                   new ContainerExitEvent(containerId,\n                       ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n-                      ExitCode.TERMINATED.getExitCode(),\n+                      Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() : \n+                        ExitCode.TERMINATED.getExitCode(),\n                       \"Container terminated before launch.\"));\n             }\n           }\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           rContainerDatum.launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler);\n        running.put(containerId,\n            new RunningContainer(containerLauncher.submit(launch), \n                launch));\n        break;\n      case CLEANUP_CONTAINER:\n        RunningContainer rContainerDatum \u003d running.remove(containerId);\n        if (rContainerDatum \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n        if (rContainer !\u003d null \n            \u0026\u0026 !rContainer.isDone()) {\n          // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n          // If it is going to be canceled, make sure CONTAINER_KILLED_ON_REQUEST\n          // will not be missed if the container is already at KILLING\n          if (rContainer.cancel(false)) {\n            if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n              dispatcher.getEventHandler().handle(\n                  new ContainerExitEvent(containerId,\n                      ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                      Shell.WINDOWS ? ExitCode.FORCE_KILLED.getExitCode() : \n                        ExitCode.TERMINATED.getExitCode(),\n                      \"Container terminated before launch.\"));\n            }\n          }\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          rContainerDatum.launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "ac933234aca037f8d73537412c8f9567a2cbe60a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-906. Fixed a bug in NodeManager where cancelling ContainerLaunch at KILLING state causes that the container to hang. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1509924 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/13 5:49 PM",
      "commitName": "ac933234aca037f8d73537412c8f9567a2cbe60a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/06/13 11:39 PM",
      "commitNameOld": "b9efe6bd4a1277b4067ecde715a7713a85968886",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 46.76,
      "commitsBetweenForRepo": 278,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,51 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d\n             new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n               event.getContainer(), dirsHandler);\n         running.put(containerId,\n             new RunningContainer(containerLauncher.submit(launch), \n                 launch));\n         break;\n       case CLEANUP_CONTAINER:\n         RunningContainer rContainerDatum \u003d running.remove(containerId);\n         if (rContainerDatum \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n         Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n         if (rContainer !\u003d null \n             \u0026\u0026 !rContainer.isDone()) {\n-          // Cancel the future so that it won\u0027t be launched \n-          // if it isn\u0027t already.\n-          rContainer.cancel(false);\n+          // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n+          // If it is going to be canceled, make sure CONTAINER_KILLED_ON_REQUEST\n+          // will not be missed if the container is already at KILLING\n+          if (rContainer.cancel(false)) {\n+            if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n+              dispatcher.getEventHandler().handle(\n+                  new ContainerExitEvent(containerId,\n+                      ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n+                      ExitCode.TERMINATED.getExitCode(),\n+                      \"Container terminated before launch.\"));\n+            }\n+          }\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           rContainerDatum.launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler);\n        running.put(containerId,\n            new RunningContainer(containerLauncher.submit(launch), \n                launch));\n        break;\n      case CLEANUP_CONTAINER:\n        RunningContainer rContainerDatum \u003d running.remove(containerId);\n        if (rContainerDatum \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n        if (rContainer !\u003d null \n            \u0026\u0026 !rContainer.isDone()) {\n          // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n          // If it is going to be canceled, make sure CONTAINER_KILLED_ON_REQUEST\n          // will not be missed if the container is already at KILLING\n          if (rContainer.cancel(false)) {\n            if (container.getContainerState() \u003d\u003d ContainerState.KILLING) {\n              dispatcher.getEventHandler().handle(\n                  new ContainerExitEvent(containerId,\n                      ContainerEventType.CONTAINER_KILLED_ON_REQUEST,\n                      ExitCode.TERMINATED.getExitCode(),\n                      \"Container terminated before launch.\"));\n            }\n          }\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          rContainerDatum.launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "2692675fc3b5046d2ec88542c30203c87e135b70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-684. ContainerManager.startContainer should use ContainerTokenIdentifier instead of the entire Container. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488085 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/13 9:13 PM",
      "commitName": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "23/04/13 2:39 PM",
      "commitNameOld": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 37.27,
      "commitsBetweenForRepo": 222,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,42 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n-    ContainerId containerId \u003d container.getContainer().getId();\n+    ContainerId containerId \u003d container.getContainerId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n-        ContainerLaunch launch \u003d new ContainerLaunch(getConfig(), dispatcher,\n-            exec, app, event.getContainer(), dirsHandler);\n+        ContainerLaunch launch \u003d\n+            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n+              event.getContainer(), dirsHandler);\n         running.put(containerId,\n             new RunningContainer(containerLauncher.submit(launch), \n                 launch));\n         break;\n       case CLEANUP_CONTAINER:\n         RunningContainer rContainerDatum \u003d running.remove(containerId);\n         if (rContainerDatum \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n         Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n         if (rContainer !\u003d null \n             \u0026\u0026 !rContainer.isDone()) {\n           // Cancel the future so that it won\u0027t be launched \n           // if it isn\u0027t already.\n           rContainer.cancel(false);\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           rContainerDatum.launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d\n            new ContainerLaunch(context, getConfig(), dispatcher, exec, app,\n              event.getContainer(), dirsHandler);\n        running.put(containerId,\n            new RunningContainer(containerLauncher.submit(launch), \n                launch));\n        break;\n      case CLEANUP_CONTAINER:\n        RunningContainer rContainerDatum \u003d running.remove(containerId);\n        if (rContainerDatum \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n        if (rContainer !\u003d null \n            \u0026\u0026 !rContainer.isDone()) {\n          // Cancel the future so that it won\u0027t be launched \n          // if it isn\u0027t already.\n          rContainer.cancel(false);\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          rContainerDatum.launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "27e8c86999bc6a972a99216060b11ef35b7de858": {
      "type": "Ybodychange",
      "commitMessage": "YARN-561. Modified NodeManager to set key information into the environment of every container that it launches. Contributed by Xuan Gong.\nMAPREDUCE-5175. Updated MR App to not set envs that will be set by NMs anyways after YARN-561. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1471156 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/13 2:39 PM",
      "commitName": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 258.68,
      "commitsBetweenForRepo": 1352,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n-    ContainerId containerId \u003d container.getContainerID();\n+    ContainerId containerId \u003d container.getContainer().getId();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n \n         ContainerLaunch launch \u003d new ContainerLaunch(getConfig(), dispatcher,\n             exec, app, event.getContainer(), dirsHandler);\n         running.put(containerId,\n             new RunningContainer(containerLauncher.submit(launch), \n                 launch));\n         break;\n       case CLEANUP_CONTAINER:\n         RunningContainer rContainerDatum \u003d running.remove(containerId);\n         if (rContainerDatum \u003d\u003d null) {\n           // Container not launched. So nothing needs to be done.\n           return;\n         }\n         Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n         if (rContainer !\u003d null \n             \u0026\u0026 !rContainer.isDone()) {\n           // Cancel the future so that it won\u0027t be launched \n           // if it isn\u0027t already.\n           rContainer.cancel(false);\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           rContainerDatum.launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainer().getId();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d new ContainerLaunch(getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler);\n        running.put(containerId,\n            new RunningContainer(containerLauncher.submit(launch), \n                launch));\n        break;\n      case CLEANUP_CONTAINER:\n        RunningContainer rContainerDatum \u003d running.remove(containerId);\n        if (rContainerDatum \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n        if (rContainer !\u003d null \n            \u0026\u0026 !rContainer.isDone()) {\n          // Cancel the future so that it won\u0027t be launched \n          // if it isn\u0027t already.\n          rContainer.cancel(false);\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          rContainerDatum.launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerID();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d new ContainerLaunch(getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler);\n        running.put(containerId,\n            new RunningContainer(containerLauncher.submit(launch), \n                launch));\n        break;\n      case CLEANUP_CONTAINER:\n        RunningContainer rContainerDatum \u003d running.remove(containerId);\n        if (rContainerDatum \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n        if (rContainer !\u003d null \n            \u0026\u0026 !rContainer.isDone()) {\n          // Cancel the future so that it won\u0027t be launched \n          // if it isn\u0027t already.\n          rContainer.cancel(false);\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          rContainerDatum.launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java"
      }
    },
    "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3121. NodeManager should handle disk-failures (Ravi Gummadi via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208131 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/11 3:17 PM",
      "commitName": "ea17da82f7fc4b7fcc05bba82d141e27289fd7cb",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "27/10/11 5:03 AM",
      "commitNameOld": "2fe343f96348e894e6ed16c447c8c77ba1611d11",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 33.47,
      "commitsBetweenForRepo": 215,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,41 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerID();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n-      ContainerLaunch launch \u003d\n-          new ContainerLaunch(getConfig(), dispatcher, exec, app,\n-              event.getContainer());\n+\n+        ContainerLaunch launch \u003d new ContainerLaunch(getConfig(), dispatcher,\n+            exec, app, event.getContainer(), dirsHandler);\n         running.put(containerId,\n             new RunningContainer(containerLauncher.submit(launch), \n                 launch));\n         break;\n       case CLEANUP_CONTAINER:\n         RunningContainer rContainerDatum \u003d running.remove(containerId);\n+        if (rContainerDatum \u003d\u003d null) {\n+          // Container not launched. So nothing needs to be done.\n+          return;\n+        }\n         Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n         if (rContainer !\u003d null \n             \u0026\u0026 !rContainer.isDone()) {\n           // Cancel the future so that it won\u0027t be launched \n           // if it isn\u0027t already.\n           rContainer.cancel(false);\n         }\n \n         // Cleanup a container whether it is running/killed/completed, so that\n         // no sub-processes are alive.\n         try {\n           rContainerDatum.launcher.cleanupContainer();\n         } catch (IOException e) {\n           LOG.warn(\"Got exception while cleaning container \" + containerId\n               + \". Ignoring.\");\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerID();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n\n        ContainerLaunch launch \u003d new ContainerLaunch(getConfig(), dispatcher,\n            exec, app, event.getContainer(), dirsHandler);\n        running.put(containerId,\n            new RunningContainer(containerLauncher.submit(launch), \n                launch));\n        break;\n      case CLEANUP_CONTAINER:\n        RunningContainer rContainerDatum \u003d running.remove(containerId);\n        if (rContainerDatum \u003d\u003d null) {\n          // Container not launched. So nothing needs to be done.\n          return;\n        }\n        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n        if (rContainer !\u003d null \n            \u0026\u0026 !rContainer.isDone()) {\n          // Cancel the future so that it won\u0027t be launched \n          // if it isn\u0027t already.\n          rContainer.cancel(false);\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          rContainerDatum.launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "2fe343f96348e894e6ed16c447c8c77ba1611d11": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3240. Fixed NodeManager to be able to forcefully cleanup its containers (process-trees) irrespective of whether the container succeeded, or killed. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189711 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 5:03 AM",
      "commitName": "2fe343f96348e894e6ed16c447c8c77ba1611d11",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/10/11 12:27 PM",
      "commitNameOld": "68328ae92632afc9cdd6e75b7a8d832723ddbe3b",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 10.69,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,37 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerID();\n-    String userName \u003d container.getUser();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n           context.getApplications().get(\n               containerId.getApplicationAttemptId().getApplicationId());\n       ContainerLaunch launch \u003d\n           new ContainerLaunch(getConfig(), dispatcher, exec, app,\n               event.getContainer());\n         running.put(containerId,\n-            new RunningContainer(userName,\n-                containerLauncher.submit(launch)));\n+            new RunningContainer(containerLauncher.submit(launch), \n+                launch));\n         break;\n       case CLEANUP_CONTAINER:\n         RunningContainer rContainerDatum \u003d running.remove(containerId);\n         Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n-        if (rContainer !\u003d null) {\n-  \n-          if (rContainer.isDone()) {\n-            // The future is already done by this time.\n-            break;\n-          }\n-  \n-          // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n+        if (rContainer !\u003d null \n+            \u0026\u0026 !rContainer.isDone()) {\n+          // Cancel the future so that it won\u0027t be launched \n+          // if it isn\u0027t already.\n           rContainer.cancel(false);\n-  \n-          // Kill the container\n-          String processId \u003d exec.getProcessId(containerId);\n-          if (processId !\u003d null) {\n-            try {\n-              exec.signalContainer(rContainerDatum.user,\n-                  processId, Signal.KILL);\n-            } catch (IOException e) {\n-              // TODO Auto-generated catch block\n-              e.printStackTrace();\n-            }\n-          }\n+        }\n+\n+        // Cleanup a container whether it is running/killed/completed, so that\n+        // no sub-processes are alive.\n+        try {\n+          rContainerDatum.launcher.cleanupContainer();\n+        } catch (IOException e) {\n+          LOG.warn(\"Got exception while cleaning container \" + containerId\n+              + \". Ignoring.\");\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerID();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n      ContainerLaunch launch \u003d\n          new ContainerLaunch(getConfig(), dispatcher, exec, app,\n              event.getContainer());\n        running.put(containerId,\n            new RunningContainer(containerLauncher.submit(launch), \n                launch));\n        break;\n      case CLEANUP_CONTAINER:\n        RunningContainer rContainerDatum \u003d running.remove(containerId);\n        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n        if (rContainer !\u003d null \n            \u0026\u0026 !rContainer.isDone()) {\n          // Cancel the future so that it won\u0027t be launched \n          // if it isn\u0027t already.\n          rContainer.cancel(false);\n        }\n\n        // Cleanup a container whether it is running/killed/completed, so that\n        // no sub-processes are alive.\n        try {\n          rContainerDatum.launcher.cleanupContainer();\n        } catch (IOException e) {\n          LOG.warn(\"Got exception while cleaning container \" + containerId\n              + \". Ignoring.\");\n        }\n        break;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2896. Simplify all apis to in org.apache.hadoop.yarn.api.records.* to be get/set only. Added javadocs to all public records.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169980 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/09/11 5:05 PM",
      "commitName": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 18.99,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,45 @@\n   public void handle(ContainersLauncherEvent event) {\n     // TODO: ContainersLauncher launches containers one by one!!\n     Container container \u003d event.getContainer();\n     ContainerId containerId \u003d container.getContainerID();\n     String userName \u003d container.getUser();\n     switch (event.getType()) {\n       case LAUNCH_CONTAINER:\n         Application app \u003d\n-          context.getApplications().get(containerId.getAppId());\n+          context.getApplications().get(\n+              containerId.getApplicationAttemptId().getApplicationId());\n       ContainerLaunch launch \u003d\n           new ContainerLaunch(getConfig(), dispatcher, exec, app,\n               event.getContainer());\n         running.put(containerId,\n             new RunningContainer(userName,\n                 containerLauncher.submit(launch)));\n         break;\n       case CLEANUP_CONTAINER:\n         RunningContainer rContainerDatum \u003d running.remove(containerId);\n         Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n         if (rContainer !\u003d null) {\n   \n           if (rContainer.isDone()) {\n             // The future is already done by this time.\n             break;\n           }\n   \n           // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n           rContainer.cancel(false);\n   \n           // Kill the container\n           String processId \u003d exec.getProcessId(containerId);\n           if (processId !\u003d null) {\n             try {\n               exec.signalContainer(rContainerDatum.user,\n                   processId, Signal.KILL);\n             } catch (IOException e) {\n               // TODO Auto-generated catch block\n               e.printStackTrace();\n             }\n           }\n         }\n         break;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerID();\n    String userName \u003d container.getUser();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(\n              containerId.getApplicationAttemptId().getApplicationId());\n      ContainerLaunch launch \u003d\n          new ContainerLaunch(getConfig(), dispatcher, exec, app,\n              event.getContainer());\n        running.put(containerId,\n            new RunningContainer(userName,\n                containerLauncher.submit(launch)));\n        break;\n      case CLEANUP_CONTAINER:\n        RunningContainer rContainerDatum \u003d running.remove(containerId);\n        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n        if (rContainer !\u003d null) {\n  \n          if (rContainer.isDone()) {\n            // The future is already done by this time.\n            break;\n          }\n  \n          // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n          rContainer.cancel(false);\n  \n          // Kill the container\n          String processId \u003d exec.getProcessId(containerId);\n          if (processId !\u003d null) {\n            try {\n              exec.signalContainer(rContainerDatum.user,\n                  processId, Signal.KILL);\n            } catch (IOException e) {\n              // TODO Auto-generated catch block\n              e.printStackTrace();\n            }\n          }\n        }\n        break;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerID();\n    String userName \u003d container.getUser();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(containerId.getAppId());\n      ContainerLaunch launch \u003d\n          new ContainerLaunch(getConfig(), dispatcher, exec, app,\n              event.getContainer());\n        running.put(containerId,\n            new RunningContainer(userName,\n                containerLauncher.submit(launch)));\n        break;\n      case CLEANUP_CONTAINER:\n        RunningContainer rContainerDatum \u003d running.remove(containerId);\n        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n        if (rContainer !\u003d null) {\n  \n          if (rContainer.isDone()) {\n            // The future is already done by this time.\n            break;\n          }\n  \n          // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n          rContainer.cancel(false);\n  \n          // Kill the container\n          String processId \u003d exec.getProcessId(containerId);\n          if (processId !\u003d null) {\n            try {\n              exec.signalContainer(rContainerDatum.user,\n                  processId, Signal.KILL);\n            } catch (IOException e) {\n              // TODO Auto-generated catch block\n              e.printStackTrace();\n            }\n          }\n        }\n        break;\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,44 @@\n+  public void handle(ContainersLauncherEvent event) {\n+    // TODO: ContainersLauncher launches containers one by one!!\n+    Container container \u003d event.getContainer();\n+    ContainerId containerId \u003d container.getContainerID();\n+    String userName \u003d container.getUser();\n+    switch (event.getType()) {\n+      case LAUNCH_CONTAINER:\n+        Application app \u003d\n+          context.getApplications().get(containerId.getAppId());\n+      ContainerLaunch launch \u003d\n+          new ContainerLaunch(getConfig(), dispatcher, exec, app,\n+              event.getContainer());\n+        running.put(containerId,\n+            new RunningContainer(userName,\n+                containerLauncher.submit(launch)));\n+        break;\n+      case CLEANUP_CONTAINER:\n+        RunningContainer rContainerDatum \u003d running.remove(containerId);\n+        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n+        if (rContainer !\u003d null) {\n+  \n+          if (rContainer.isDone()) {\n+            // The future is already done by this time.\n+            break;\n+          }\n+  \n+          // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n+          rContainer.cancel(false);\n+  \n+          // Kill the container\n+          String processId \u003d exec.getProcessId(containerId);\n+          if (processId !\u003d null) {\n+            try {\n+              exec.signalContainer(rContainerDatum.user,\n+                  processId, Signal.KILL);\n+            } catch (IOException e) {\n+              // TODO Auto-generated catch block\n+              e.printStackTrace();\n+            }\n+          }\n+        }\n+        break;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void handle(ContainersLauncherEvent event) {\n    // TODO: ContainersLauncher launches containers one by one!!\n    Container container \u003d event.getContainer();\n    ContainerId containerId \u003d container.getContainerID();\n    String userName \u003d container.getUser();\n    switch (event.getType()) {\n      case LAUNCH_CONTAINER:\n        Application app \u003d\n          context.getApplications().get(containerId.getAppId());\n      ContainerLaunch launch \u003d\n          new ContainerLaunch(getConfig(), dispatcher, exec, app,\n              event.getContainer());\n        running.put(containerId,\n            new RunningContainer(userName,\n                containerLauncher.submit(launch)));\n        break;\n      case CLEANUP_CONTAINER:\n        RunningContainer rContainerDatum \u003d running.remove(containerId);\n        Future\u003cInteger\u003e rContainer \u003d rContainerDatum.runningcontainer;\n        if (rContainer !\u003d null) {\n  \n          if (rContainer.isDone()) {\n            // The future is already done by this time.\n            break;\n          }\n  \n          // Cancel the future so that it won\u0027t be launched if it isn\u0027t already.\n          rContainer.cancel(false);\n  \n          // Kill the container\n          String processId \u003d exec.getProcessId(containerId);\n          if (processId !\u003d null) {\n            try {\n              exec.signalContainer(rContainerDatum.user,\n                  processId, Signal.KILL);\n            } catch (IOException e) {\n              // TODO Auto-generated catch block\n              e.printStackTrace();\n            }\n          }\n        }\n        break;\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/ContainersLauncher.java"
    }
  }
}