{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AliyunOSSInputStream.java",
  "functionName": "read",
  "functionId": "read___buf-byte[]__off-int__len-int",
  "sourceFilePath": "hadoop-tools/hadoop-aliyun/src/main/java/org/apache/hadoop/fs/aliyun/oss/AliyunOSSInputStream.java",
  "functionStartLine": 219,
  "functionEndLine": 268,
  "numCommitsSeen": 8,
  "timeTaken": 1060,
  "changeHistory": [
    "9195a6e302028ed3921d1016ac2fa5754f06ebf0",
    "d33e928fbeb1764a724c8f3c051bb0d8be82bbff",
    "a5d5342228050a778b20e95adf7885bdba39985d"
  ],
  "changeHistoryShort": {
    "9195a6e302028ed3921d1016ac2fa5754f06ebf0": "Ybodychange",
    "d33e928fbeb1764a724c8f3c051bb0d8be82bbff": "Ybodychange",
    "a5d5342228050a778b20e95adf7885bdba39985d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9195a6e302028ed3921d1016ac2fa5754f06ebf0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15027. AliyunOSS: Support multi-thread pre-read to improve sequential read from Hadoop to Aliyun OSS performance. (Contributed by Jinhu Wu)\n",
      "commitDate": "16/01/18 11:55 PM",
      "commitName": "9195a6e302028ed3921d1016ac2fa5754f06ebf0",
      "commitAuthor": "Sammi Chen",
      "commitDateOld": "15/02/17 12:34 AM",
      "commitNameOld": "cd3e59a3dcc69f68711777d448da5228a55846b3",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 335.97,
      "commitsBetweenForRepo": 2216,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,50 @@\n   public synchronized int read(byte[] buf, int off, int len)\n       throws IOException {\n     checkNotClosed();\n \n     if (buf \u003d\u003d null) {\n       throw new NullPointerException();\n     } else if (off \u003c 0 || len \u003c 0 || len \u003e buf.length - off) {\n       throw new IndexOutOfBoundsException();\n     } else if (len \u003d\u003d 0) {\n       return 0;\n     }\n \n     int bytesRead \u003d 0;\n     // Not EOF, and read not done\n     while (position \u003c contentLength \u0026\u0026 bytesRead \u003c len) {\n       if (partRemaining \u003d\u003d 0) {\n         reopen(position);\n       }\n \n-      int tries \u003d MAX_RETRIES;\n-      boolean retry;\n-      int bytes \u003d -1;\n-      do {\n-        retry \u003d false;\n-        try {\n-          bytes \u003d wrappedStream.read(buf, off + bytesRead, len - bytesRead);\n-        } catch (Exception e) {\n-          handleReadException(e, --tries);\n-          retry \u003d true;\n+      int bytes \u003d 0;\n+      for (int i \u003d this.buffer.length - (int)partRemaining;\n+           i \u003c this.buffer.length; i++) {\n+        buf[off + bytesRead] \u003d this.buffer[i];\n+        bytes++;\n+        bytesRead++;\n+        if (off + bytesRead \u003e\u003d len) {\n+          break;\n         }\n-      } while (retry);\n+      }\n \n       if (bytes \u003e 0) {\n-        bytesRead +\u003d bytes;\n         position +\u003d bytes;\n         partRemaining -\u003d bytes;\n       } else if (partRemaining !\u003d 0) {\n         throw new IOException(\"Failed to read from stream. Remaining:\" +\n             partRemaining);\n       }\n     }\n \n     if (statistics !\u003d null \u0026\u0026 bytesRead \u003e 0) {\n       statistics.incrementBytesRead(bytesRead);\n     }\n \n     // Read nothing, but attempt to read something\n     if (bytesRead \u003d\u003d 0 \u0026\u0026 len \u003e 0) {\n       return -1;\n     } else {\n       return bytesRead;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized int read(byte[] buf, int off, int len)\n      throws IOException {\n    checkNotClosed();\n\n    if (buf \u003d\u003d null) {\n      throw new NullPointerException();\n    } else if (off \u003c 0 || len \u003c 0 || len \u003e buf.length - off) {\n      throw new IndexOutOfBoundsException();\n    } else if (len \u003d\u003d 0) {\n      return 0;\n    }\n\n    int bytesRead \u003d 0;\n    // Not EOF, and read not done\n    while (position \u003c contentLength \u0026\u0026 bytesRead \u003c len) {\n      if (partRemaining \u003d\u003d 0) {\n        reopen(position);\n      }\n\n      int bytes \u003d 0;\n      for (int i \u003d this.buffer.length - (int)partRemaining;\n           i \u003c this.buffer.length; i++) {\n        buf[off + bytesRead] \u003d this.buffer[i];\n        bytes++;\n        bytesRead++;\n        if (off + bytesRead \u003e\u003d len) {\n          break;\n        }\n      }\n\n      if (bytes \u003e 0) {\n        position +\u003d bytes;\n        partRemaining -\u003d bytes;\n      } else if (partRemaining !\u003d 0) {\n        throw new IOException(\"Failed to read from stream. Remaining:\" +\n            partRemaining);\n      }\n    }\n\n    if (statistics !\u003d null \u0026\u0026 bytesRead \u003e 0) {\n      statistics.incrementBytesRead(bytesRead);\n    }\n\n    // Read nothing, but attempt to read something\n    if (bytesRead \u003d\u003d 0 \u0026\u0026 len \u003e 0) {\n      return -1;\n    } else {\n      return bytesRead;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aliyun/src/main/java/org/apache/hadoop/fs/aliyun/oss/AliyunOSSInputStream.java",
      "extendedDetails": {}
    },
    "d33e928fbeb1764a724c8f3c051bb0d8be82bbff": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13529. Do some code refactoring. Contributed by Genmao Yu.\n",
      "commitDate": "06/09/16 8:15 PM",
      "commitName": "d33e928fbeb1764a724c8f3c051bb0d8be82bbff",
      "commitAuthor": "Mingfei",
      "commitDateOld": "06/09/16 8:15 PM",
      "commitNameOld": "4d84c814fcaf074022593c057d8f8dec4cd461fa",
      "commitAuthorOld": "Mingfei",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public synchronized int read(byte[] buf, int off, int len)\n       throws IOException {\n     checkNotClosed();\n \n     if (buf \u003d\u003d null) {\n       throw new NullPointerException();\n     } else if (off \u003c 0 || len \u003c 0 || len \u003e buf.length - off) {\n       throw new IndexOutOfBoundsException();\n     } else if (len \u003d\u003d 0) {\n       return 0;\n     }\n \n     int bytesRead \u003d 0;\n     // Not EOF, and read not done\n-    while (position \u003c dataLen \u0026\u0026 bytesRead \u003c len) {\n+    while (position \u003c contentLength \u0026\u0026 bytesRead \u003c len) {\n       if (partRemaining \u003d\u003d 0) {\n         reopen(position);\n       }\n \n       int tries \u003d MAX_RETRIES;\n       boolean retry;\n       int bytes \u003d -1;\n       do {\n         retry \u003d false;\n         try {\n           bytes \u003d wrappedStream.read(buf, off + bytesRead, len - bytesRead);\n         } catch (Exception e) {\n           handleReadException(e, --tries);\n           retry \u003d true;\n         }\n       } while (retry);\n \n       if (bytes \u003e 0) {\n         bytesRead +\u003d bytes;\n         position +\u003d bytes;\n         partRemaining -\u003d bytes;\n       } else if (partRemaining !\u003d 0) {\n         throw new IOException(\"Failed to read from stream. Remaining:\" +\n             partRemaining);\n       }\n     }\n \n     if (statistics !\u003d null \u0026\u0026 bytesRead \u003e 0) {\n       statistics.incrementBytesRead(bytesRead);\n     }\n \n     // Read nothing, but attempt to read something\n     if (bytesRead \u003d\u003d 0 \u0026\u0026 len \u003e 0) {\n       return -1;\n     } else {\n       return bytesRead;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized int read(byte[] buf, int off, int len)\n      throws IOException {\n    checkNotClosed();\n\n    if (buf \u003d\u003d null) {\n      throw new NullPointerException();\n    } else if (off \u003c 0 || len \u003c 0 || len \u003e buf.length - off) {\n      throw new IndexOutOfBoundsException();\n    } else if (len \u003d\u003d 0) {\n      return 0;\n    }\n\n    int bytesRead \u003d 0;\n    // Not EOF, and read not done\n    while (position \u003c contentLength \u0026\u0026 bytesRead \u003c len) {\n      if (partRemaining \u003d\u003d 0) {\n        reopen(position);\n      }\n\n      int tries \u003d MAX_RETRIES;\n      boolean retry;\n      int bytes \u003d -1;\n      do {\n        retry \u003d false;\n        try {\n          bytes \u003d wrappedStream.read(buf, off + bytesRead, len - bytesRead);\n        } catch (Exception e) {\n          handleReadException(e, --tries);\n          retry \u003d true;\n        }\n      } while (retry);\n\n      if (bytes \u003e 0) {\n        bytesRead +\u003d bytes;\n        position +\u003d bytes;\n        partRemaining -\u003d bytes;\n      } else if (partRemaining !\u003d 0) {\n        throw new IOException(\"Failed to read from stream. Remaining:\" +\n            partRemaining);\n      }\n    }\n\n    if (statistics !\u003d null \u0026\u0026 bytesRead \u003e 0) {\n      statistics.incrementBytesRead(bytesRead);\n    }\n\n    // Read nothing, but attempt to read something\n    if (bytesRead \u003d\u003d 0 \u0026\u0026 len \u003e 0) {\n      return -1;\n    } else {\n      return bytesRead;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aliyun/src/main/java/org/apache/hadoop/fs/aliyun/oss/AliyunOSSInputStream.java",
      "extendedDetails": {}
    },
    "a5d5342228050a778b20e95adf7885bdba39985d": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-12756. Incorporate Aliyun OSS file system implementation. Contributed by Mingfei Shi and Lin Zhou\n",
      "commitDate": "06/09/16 8:15 PM",
      "commitName": "a5d5342228050a778b20e95adf7885bdba39985d",
      "commitAuthor": "Kai Zheng",
      "diff": "@@ -0,0 +1,53 @@\n+  public synchronized int read(byte[] buf, int off, int len)\n+      throws IOException {\n+    checkNotClosed();\n+\n+    if (buf \u003d\u003d null) {\n+      throw new NullPointerException();\n+    } else if (off \u003c 0 || len \u003c 0 || len \u003e buf.length - off) {\n+      throw new IndexOutOfBoundsException();\n+    } else if (len \u003d\u003d 0) {\n+      return 0;\n+    }\n+\n+    int bytesRead \u003d 0;\n+    // Not EOF, and read not done\n+    while (position \u003c dataLen \u0026\u0026 bytesRead \u003c len) {\n+      if (partRemaining \u003d\u003d 0) {\n+        reopen(position);\n+      }\n+\n+      int tries \u003d MAX_RETRIES;\n+      boolean retry;\n+      int bytes \u003d -1;\n+      do {\n+        retry \u003d false;\n+        try {\n+          bytes \u003d wrappedStream.read(buf, off + bytesRead, len - bytesRead);\n+        } catch (Exception e) {\n+          handleReadException(e, --tries);\n+          retry \u003d true;\n+        }\n+      } while (retry);\n+\n+      if (bytes \u003e 0) {\n+        bytesRead +\u003d bytes;\n+        position +\u003d bytes;\n+        partRemaining -\u003d bytes;\n+      } else if (partRemaining !\u003d 0) {\n+        throw new IOException(\"Failed to read from stream. Remaining:\" +\n+            partRemaining);\n+      }\n+    }\n+\n+    if (statistics !\u003d null \u0026\u0026 bytesRead \u003e 0) {\n+      statistics.incrementBytesRead(bytesRead);\n+    }\n+\n+    // Read nothing, but attempt to read something\n+    if (bytesRead \u003d\u003d 0 \u0026\u0026 len \u003e 0) {\n+      return -1;\n+    } else {\n+      return bytesRead;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized int read(byte[] buf, int off, int len)\n      throws IOException {\n    checkNotClosed();\n\n    if (buf \u003d\u003d null) {\n      throw new NullPointerException();\n    } else if (off \u003c 0 || len \u003c 0 || len \u003e buf.length - off) {\n      throw new IndexOutOfBoundsException();\n    } else if (len \u003d\u003d 0) {\n      return 0;\n    }\n\n    int bytesRead \u003d 0;\n    // Not EOF, and read not done\n    while (position \u003c dataLen \u0026\u0026 bytesRead \u003c len) {\n      if (partRemaining \u003d\u003d 0) {\n        reopen(position);\n      }\n\n      int tries \u003d MAX_RETRIES;\n      boolean retry;\n      int bytes \u003d -1;\n      do {\n        retry \u003d false;\n        try {\n          bytes \u003d wrappedStream.read(buf, off + bytesRead, len - bytesRead);\n        } catch (Exception e) {\n          handleReadException(e, --tries);\n          retry \u003d true;\n        }\n      } while (retry);\n\n      if (bytes \u003e 0) {\n        bytesRead +\u003d bytes;\n        position +\u003d bytes;\n        partRemaining -\u003d bytes;\n      } else if (partRemaining !\u003d 0) {\n        throw new IOException(\"Failed to read from stream. Remaining:\" +\n            partRemaining);\n      }\n    }\n\n    if (statistics !\u003d null \u0026\u0026 bytesRead \u003e 0) {\n      statistics.incrementBytesRead(bytesRead);\n    }\n\n    // Read nothing, but attempt to read something\n    if (bytesRead \u003d\u003d 0 \u0026\u0026 len \u003e 0) {\n      return -1;\n    } else {\n      return bytesRead;\n    }\n  }",
      "path": "hadoop-tools/hadoop-aliyun/src/main/java/org/apache/hadoop/fs/aliyun/oss/AliyunOSSInputStream.java"
    }
  }
}