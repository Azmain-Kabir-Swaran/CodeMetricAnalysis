{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSImageFormatPBSnapshot.java",
  "functionName": "loadFileDiffList",
  "functionId": "loadFileDiffList___in-InputStream__file-INodeFile__size-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
  "functionStartLine": 211,
  "functionEndLine": 279,
  "numCommitsSeen": 34,
  "timeTaken": 7158,
  "changeHistory": [
    "55c07bbed2f475f7b584a86112ee1b6fe0221e98",
    "a2a5d7b5bca715835d92816e7b267b59f7270708",
    "06022b8fdc40e50eaac63758246353058e8cfa6d",
    "745d04be59accf80feda0ad38efcc74ba362f2ca",
    "7e091de1366f4b57b5433bc19d738199dc05313d",
    "cdc13efb1af54d931585d25c5ba696a012412828",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "4c039b0876bb9399c2b4a751ad7b99b36349117b",
    "9f2f583f401189c3f4a2687795a9e3e0b288322b",
    "ba9371492036983a9899398907ab41fe548f29b3",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f",
    "0653918dad855b394e8e3b8b3f512f474d872ee9",
    "bb84f1fccb18c6c7373851e05d2451d55e908242",
    "042b33f20b01aadb5cd03da731ae7a3d94026aac",
    "6f41baa6233dad92865af23ec6b7a89733c11ddd",
    "ac23a55547716df29b3e25c98a113399e184d9d1",
    "ea0b21af158016651cb77560778834eb95e6b68d",
    "d03acc756094a332f98167426a39db8faf38f450",
    "5c978a43c3052cc1466b23653c354399186b4e10",
    "a2edb11b68ae01a44092cb14ac2717a6aad93305"
  ],
  "changeHistoryShort": {
    "55c07bbed2f475f7b584a86112ee1b6fe0221e98": "Ybodychange",
    "a2a5d7b5bca715835d92816e7b267b59f7270708": "Ybodychange",
    "06022b8fdc40e50eaac63758246353058e8cfa6d": "Ybodychange",
    "745d04be59accf80feda0ad38efcc74ba362f2ca": "Ybodychange",
    "7e091de1366f4b57b5433bc19d738199dc05313d": "Ybodychange",
    "cdc13efb1af54d931585d25c5ba696a012412828": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Ybodychange",
    "4c039b0876bb9399c2b4a751ad7b99b36349117b": "Ybodychange",
    "9f2f583f401189c3f4a2687795a9e3e0b288322b": "Ybodychange",
    "ba9371492036983a9899398907ab41fe548f29b3": "Ybodychange",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Ybodychange",
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": "Ybodychange",
    "0653918dad855b394e8e3b8b3f512f474d872ee9": "Ybodychange",
    "bb84f1fccb18c6c7373851e05d2451d55e908242": "Ybodychange",
    "042b33f20b01aadb5cd03da731ae7a3d94026aac": "Ybodychange",
    "6f41baa6233dad92865af23ec6b7a89733c11ddd": "Ybodychange",
    "ac23a55547716df29b3e25c98a113399e184d9d1": "Ybodychange",
    "ea0b21af158016651cb77560778834eb95e6b68d": "Ybodychange",
    "d03acc756094a332f98167426a39db8faf38f450": "Ybodychange",
    "5c978a43c3052cc1466b23653c354399186b4e10": "Ybodychange",
    "a2edb11b68ae01a44092cb14ac2717a6aad93305": "Yintroduced"
  },
  "changeHistoryDetails": {
    "55c07bbed2f475f7b584a86112ee1b6fe0221e98": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11382. Persist Erasure Coding Policy ID in a new optional field in INodeFile in FSImage. Contributed by Manoj Govindassamy.\n",
      "commitDate": "27/02/17 5:07 PM",
      "commitName": "55c07bbed2f475f7b584a86112ee1b6fe0221e98",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "18/01/17 1:31 PM",
      "commitNameOld": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 40.15,
      "commitsBetweenForRepo": 201,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,69 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       final BlockManager bm \u003d fsn.getBlockManager();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             int[] entries \u003d AclEntryStatusFormat\n                 .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                     fileInPb.getAcl(), state.getStringTable()));\n             acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n+          boolean isStriped \u003d\n+              (fileInPb.getBlockType() \u003d\u003d BlockTypeProto .STRIPED);\n+          Short replication \u003d\n+              (!isStriped ? (short)fileInPb.getReplication() : null);\n+          Byte ecPolicyID \u003d\n+              (isStriped ? (byte)fileInPb.getErasureCodingPolicyID() : null);\n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n-              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n+              fileInPb.getAccessTime(), replication, ecPolicyID,\n               fileInPb.getPreferredBlockSize(),\n               (byte)fileInPb.getStoragePolicyID(), xAttrs,\n               PBHelperClient.convert(fileInPb.getBlockType()));\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n         // in file diff there can only be contiguous blocks\n         BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n         for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n           Block blk \u003d PBHelperClient.convert(bpl.get(j));\n           BlockInfo storedBlock \u003d bm.getStoredBlock(blk);\n           if(storedBlock \u003d\u003d null) {\n             storedBlock \u003d (BlockInfoContiguous) fsn.getBlockManager()\n                 .addBlockCollectionWithCheck(new BlockInfoContiguous(blk,\n                     copy.getFileReplication()), file);\n           }\n           blocks[j] \u003d storedBlock;\n         }\n         if(blocks.length \u003e 0) {\n           diff.setBlocks(blocks);\n         }\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n       short repl \u003d file.getPreferredBlockReplication();\n       for (BlockInfo b : file.getBlocks()) {\n         if (b.getReplication() \u003c repl) {\n           bm.setReplication(b.getReplication(), repl, b);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      final BlockManager bm \u003d fsn.getBlockManager();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          boolean isStriped \u003d\n              (fileInPb.getBlockType() \u003d\u003d BlockTypeProto .STRIPED);\n          Short replication \u003d\n              (!isStriped ? (short)fileInPb.getReplication() : null);\n          Byte ecPolicyID \u003d\n              (isStriped ? (byte)fileInPb.getErasureCodingPolicyID() : null);\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), replication, ecPolicyID,\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs,\n              PBHelperClient.convert(fileInPb.getBlockType()));\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n        // in file diff there can only be contiguous blocks\n        BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n          Block blk \u003d PBHelperClient.convert(bpl.get(j));\n          BlockInfo storedBlock \u003d bm.getStoredBlock(blk);\n          if(storedBlock \u003d\u003d null) {\n            storedBlock \u003d (BlockInfoContiguous) fsn.getBlockManager()\n                .addBlockCollectionWithCheck(new BlockInfoContiguous(blk,\n                    copy.getFileReplication()), file);\n          }\n          blocks[j] \u003d storedBlock;\n        }\n        if(blocks.length \u003e 0) {\n          diff.setBlocks(blocks);\n        }\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n      short repl \u003d file.getPreferredBlockReplication();\n      for (BlockInfo b : file.getBlocks()) {\n        if (b.getReplication() \u003c repl) {\n          bm.setReplication(b.getReplication(), repl, b);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "a2a5d7b5bca715835d92816e7b267b59f7270708": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10759. Change fsimage bool isStriped from boolean to an enum. Contributed by Ewan Higgs.\n",
      "commitDate": "18/01/17 1:31 PM",
      "commitName": "a2a5d7b5bca715835d92816e7b267b59f7270708",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "22/09/15 1:27 PM",
      "commitNameOld": "1080c3730068177ddd10dc313890ac1f5dc58f1a",
      "commitAuthorOld": "",
      "daysBetweenCommits": 484.04,
      "commitsBetweenForRepo": 3347,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,63 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       final BlockManager bm \u003d fsn.getBlockManager();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             int[] entries \u003d AclEntryStatusFormat\n                 .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                     fileInPb.getAcl(), state.getStringTable()));\n             acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n               (byte)fileInPb.getStoragePolicyID(), xAttrs,\n-              fileInPb.getIsStriped());\n+              PBHelperClient.convert(fileInPb.getBlockType()));\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n         // in file diff there can only be contiguous blocks\n         BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n         for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n           Block blk \u003d PBHelperClient.convert(bpl.get(j));\n           BlockInfo storedBlock \u003d bm.getStoredBlock(blk);\n           if(storedBlock \u003d\u003d null) {\n             storedBlock \u003d (BlockInfoContiguous) fsn.getBlockManager()\n                 .addBlockCollectionWithCheck(new BlockInfoContiguous(blk,\n                     copy.getFileReplication()), file);\n           }\n           blocks[j] \u003d storedBlock;\n         }\n         if(blocks.length \u003e 0) {\n           diff.setBlocks(blocks);\n         }\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n       short repl \u003d file.getPreferredBlockReplication();\n       for (BlockInfo b : file.getBlocks()) {\n         if (b.getReplication() \u003c repl) {\n           bm.setReplication(b.getReplication(), repl, b);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      final BlockManager bm \u003d fsn.getBlockManager();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs,\n              PBHelperClient.convert(fileInPb.getBlockType()));\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n        // in file diff there can only be contiguous blocks\n        BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n          Block blk \u003d PBHelperClient.convert(bpl.get(j));\n          BlockInfo storedBlock \u003d bm.getStoredBlock(blk);\n          if(storedBlock \u003d\u003d null) {\n            storedBlock \u003d (BlockInfoContiguous) fsn.getBlockManager()\n                .addBlockCollectionWithCheck(new BlockInfoContiguous(blk,\n                    copy.getFileReplication()), file);\n          }\n          blocks[j] \u003d storedBlock;\n        }\n        if(blocks.length \u003e 0) {\n          diff.setBlocks(blocks);\n        }\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n      short repl \u003d file.getPreferredBlockReplication();\n      for (BlockInfo b : file.getBlocks()) {\n        if (b.getReplication() \u003c repl) {\n          bm.setReplication(b.getReplication(), repl, b);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "06022b8fdc40e50eaac63758246353058e8cfa6d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9111. Move hdfs-client protobuf convert methods from PBHelper to PBHelperClient. Contributed by Mingliang Liu.\n",
      "commitDate": "21/09/15 6:53 PM",
      "commitName": "06022b8fdc40e50eaac63758246353058e8cfa6d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "22/08/15 12:09 AM",
      "commitNameOld": "745d04be59accf80feda0ad38efcc74ba362f2ca",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 30.78,
      "commitsBetweenForRepo": 178,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       final BlockManager bm \u003d fsn.getBlockManager();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             int[] entries \u003d AclEntryStatusFormat\n                 .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                     fileInPb.getAcl(), state.getStringTable()));\n             acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n               (byte)fileInPb.getStoragePolicyID(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n         BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n         for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n-          Block blk \u003d PBHelper.convert(bpl.get(j));\n+          Block blk \u003d PBHelperClient.convert(bpl.get(j));\n           BlockInfo storedBlock \u003d bm.getStoredBlock(blk);\n           if(storedBlock \u003d\u003d null) {\n             storedBlock \u003d bm.addBlockCollection(\n                 new BlockInfoContiguous(blk, copy.getFileReplication()), file);\n           }\n           blocks[j] \u003d storedBlock;\n         }\n         if(blocks.length \u003e 0) {\n           diff.setBlocks(blocks);\n         }\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n       short repl \u003d file.getPreferredBlockReplication();\n       for (BlockInfo b : file.getBlocks()) {\n         if (b.getReplication() \u003c repl) {\n           bm.setReplication(b.getReplication(), repl, b);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      final BlockManager bm \u003d fsn.getBlockManager();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n        BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n          Block blk \u003d PBHelperClient.convert(bpl.get(j));\n          BlockInfo storedBlock \u003d bm.getStoredBlock(blk);\n          if(storedBlock \u003d\u003d null) {\n            storedBlock \u003d bm.addBlockCollection(\n                new BlockInfoContiguous(blk, copy.getFileReplication()), file);\n          }\n          blocks[j] \u003d storedBlock;\n        }\n        if(blocks.length \u003e 0) {\n          diff.setBlocks(blocks);\n        }\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n      short repl \u003d file.getPreferredBlockReplication();\n      for (BlockInfo b : file.getBlocks()) {\n        if (b.getReplication() \u003c repl) {\n          bm.setReplication(b.getReplication(), repl, b);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "745d04be59accf80feda0ad38efcc74ba362f2ca": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8823. Move replication factor into individual blocks. Contributed by Haohui Mai.\n",
      "commitDate": "22/08/15 12:09 AM",
      "commitName": "745d04be59accf80feda0ad38efcc74ba362f2ca",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "01/06/15 11:42 AM",
      "commitNameOld": "cdc13efb1af54d931585d25c5ba696a012412828",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 81.52,
      "commitsBetweenForRepo": 501,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,60 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n+      final BlockManager bm \u003d fsn.getBlockManager();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             int[] entries \u003d AclEntryStatusFormat\n                 .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                     fileInPb.getAcl(), state.getStringTable()));\n             acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n               (byte)fileInPb.getStoragePolicyID(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n         BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n         for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n           Block blk \u003d PBHelper.convert(bpl.get(j));\n-          BlockInfo storedBlock \u003d  fsn.getBlockManager().getStoredBlock(blk);\n+          BlockInfo storedBlock \u003d bm.getStoredBlock(blk);\n           if(storedBlock \u003d\u003d null) {\n-            storedBlock \u003d fsn.getBlockManager().addBlockCollection(\n+            storedBlock \u003d bm.addBlockCollection(\n                 new BlockInfoContiguous(blk, copy.getFileReplication()), file);\n           }\n           blocks[j] \u003d storedBlock;\n         }\n         if(blocks.length \u003e 0) {\n           diff.setBlocks(blocks);\n         }\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n+      short repl \u003d file.getPreferredBlockReplication();\n+      for (BlockInfo b : file.getBlocks()) {\n+        if (b.getReplication() \u003c repl) {\n+          bm.setReplication(b.getReplication(), repl, b);\n+        }\n+      }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      final BlockManager bm \u003d fsn.getBlockManager();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n        BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n          Block blk \u003d PBHelper.convert(bpl.get(j));\n          BlockInfo storedBlock \u003d bm.getStoredBlock(blk);\n          if(storedBlock \u003d\u003d null) {\n            storedBlock \u003d bm.addBlockCollection(\n                new BlockInfoContiguous(blk, copy.getFileReplication()), file);\n          }\n          blocks[j] \u003d storedBlock;\n        }\n        if(blocks.length \u003e 0) {\n          diff.setBlocks(blocks);\n        }\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n      short repl \u003d file.getPreferredBlockReplication();\n      for (BlockInfo b : file.getBlocks()) {\n        if (b.getReplication() \u003c repl) {\n          bm.setReplication(b.getReplication(), repl, b);\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "7e091de1366f4b57b5433bc19d738199dc05313d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8058. Erasure coding: use BlockInfo[] for both striped and contiguous blocks in INodeFile. Contributed by Zhe Zhang and Yi Liu.\n",
      "commitDate": "15/07/15 9:49 AM",
      "commitName": "7e091de1366f4b57b5433bc19d738199dc05313d",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "26/05/15 11:59 AM",
      "commitNameOld": "4c039b0876bb9399c2b4a751ad7b99b36349117b",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 49.91,
      "commitsBetweenForRepo": 113,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,57 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             int[] entries \u003d AclEntryStatusFormat\n                 .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                     fileInPb.getAcl(), state.getStringTable()));\n             acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n-              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n+              (byte)fileInPb.getStoragePolicyID(), xAttrs,\n+              fileInPb.getIsStriped());\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n         // in file diff there can only be contiguous blocks\n         BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[bpl.size()];\n         for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n           Block blk \u003d PBHelper.convert(bpl.get(j));\n           BlockInfoContiguous storedBlock \u003d\n               (BlockInfoContiguous) fsn.getBlockManager().getStoredBlock(blk);\n           if(storedBlock \u003d\u003d null) {\n             storedBlock \u003d (BlockInfoContiguous) fsn.getBlockManager()\n                 .addBlockCollectionWithCheck(new BlockInfoContiguous(blk,\n                     copy.getFileReplication()), file);\n           }\n           blocks[j] \u003d storedBlock;\n         }\n         if(blocks.length \u003e 0) {\n           diff.setBlocks(blocks);\n         }\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs,\n              fileInPb.getIsStriped());\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n        // in file diff there can only be contiguous blocks\n        BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[bpl.size()];\n        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n          Block blk \u003d PBHelper.convert(bpl.get(j));\n          BlockInfoContiguous storedBlock \u003d\n              (BlockInfoContiguous) fsn.getBlockManager().getStoredBlock(blk);\n          if(storedBlock \u003d\u003d null) {\n            storedBlock \u003d (BlockInfoContiguous) fsn.getBlockManager()\n                .addBlockCollectionWithCheck(new BlockInfoContiguous(blk,\n                    copy.getFileReplication()), file);\n          }\n          blocks[j] \u003d storedBlock;\n        }\n        if(blocks.length \u003e 0) {\n          diff.setBlocks(blocks);\n        }\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "cdc13efb1af54d931585d25c5ba696a012412828": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8489. Subclass BlockInfo to represent contiguous blocks. Contributed by Zhe Zhang.\n",
      "commitDate": "01/06/15 11:42 AM",
      "commitName": "cdc13efb1af54d931585d25c5ba696a012412828",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "27/05/15 3:42 PM",
      "commitNameOld": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.83,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             int[] entries \u003d AclEntryStatusFormat\n                 .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                     fileInPb.getAcl(), state.getStringTable()));\n             acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n               (byte)fileInPb.getStoragePolicyID(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n         BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n         for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n           Block blk \u003d PBHelper.convert(bpl.get(j));\n           BlockInfo storedBlock \u003d  fsn.getBlockManager().getStoredBlock(blk);\n           if(storedBlock \u003d\u003d null) {\n             storedBlock \u003d fsn.getBlockManager().addBlockCollection(\n-                new BlockInfo(blk, copy.getFileReplication()), file);\n+                new BlockInfoContiguous(blk, copy.getFileReplication()), file);\n           }\n           blocks[j] \u003d storedBlock;\n         }\n         if(blocks.length \u003e 0) {\n           diff.setBlocks(blocks);\n         }\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n        BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n          Block blk \u003d PBHelper.convert(bpl.get(j));\n          BlockInfo storedBlock \u003d  fsn.getBlockManager().getStoredBlock(blk);\n          if(storedBlock \u003d\u003d null) {\n            storedBlock \u003d fsn.getBlockManager().addBlockCollection(\n                new BlockInfoContiguous(blk, copy.getFileReplication()), file);\n          }\n          blocks[j] \u003d storedBlock;\n        }\n        if(blocks.length \u003e 0) {\n          diff.setBlocks(blocks);\n        }\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/02/15 3:38 PM",
      "commitNameOld": "8b465b4b8caed31ca9daeaae108f9a868a30a455",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 94.96,
      "commitsBetweenForRepo": 877,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             int[] entries \u003d AclEntryStatusFormat\n                 .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                     fileInPb.getAcl(), state.getStringTable()));\n             acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n               (byte)fileInPb.getStoragePolicyID(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n-        BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[bpl.size()];\n+        BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n         for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n           Block blk \u003d PBHelper.convert(bpl.get(j));\n-          BlockInfoContiguous storedBlock \u003d  fsn.getBlockManager().getStoredBlock(blk);\n+          BlockInfo storedBlock \u003d  fsn.getBlockManager().getStoredBlock(blk);\n           if(storedBlock \u003d\u003d null) {\n             storedBlock \u003d fsn.getBlockManager().addBlockCollection(\n-                new BlockInfoContiguous(blk, copy.getFileReplication()), file);\n+                new BlockInfo(blk, copy.getFileReplication()), file);\n           }\n           blocks[j] \u003d storedBlock;\n         }\n         if(blocks.length \u003e 0) {\n           diff.setBlocks(blocks);\n         }\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n        BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n          Block blk \u003d PBHelper.convert(bpl.get(j));\n          BlockInfo storedBlock \u003d  fsn.getBlockManager().getStoredBlock(blk);\n          if(storedBlock \u003d\u003d null) {\n            storedBlock \u003d fsn.getBlockManager().addBlockCollection(\n                new BlockInfo(blk, copy.getFileReplication()), file);\n          }\n          blocks[j] \u003d storedBlock;\n        }\n        if(blocks.length \u003e 0) {\n          diff.setBlocks(blocks);\n        }\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "4c039b0876bb9399c2b4a751ad7b99b36349117b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7994. Detect if resevered EC Block ID is already used during namenode startup. Contributed by Hui Zheng\n",
      "commitDate": "26/05/15 11:59 AM",
      "commitName": "4c039b0876bb9399c2b4a751ad7b99b36349117b",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "26/05/15 11:07 AM",
      "commitNameOld": "9f2f583f401189c3f4a2687795a9e3e0b288322b",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             int[] entries \u003d AclEntryStatusFormat\n                 .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                     fileInPb.getAcl(), state.getStringTable()));\n             acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n               (byte)fileInPb.getStoragePolicyID(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n         // in file diff there can only be contiguous blocks\n         BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[bpl.size()];\n         for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n           Block blk \u003d PBHelper.convert(bpl.get(j));\n           BlockInfoContiguous storedBlock \u003d\n               (BlockInfoContiguous) fsn.getBlockManager().getStoredBlock(blk);\n           if(storedBlock \u003d\u003d null) {\n             storedBlock \u003d (BlockInfoContiguous) fsn.getBlockManager()\n-                .addBlockCollection(new BlockInfoContiguous(blk,\n+                .addBlockCollectionWithCheck(new BlockInfoContiguous(blk,\n                     copy.getFileReplication()), file);\n           }\n           blocks[j] \u003d storedBlock;\n         }\n         if(blocks.length \u003e 0) {\n           diff.setBlocks(blocks);\n         }\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n        // in file diff there can only be contiguous blocks\n        BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[bpl.size()];\n        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n          Block blk \u003d PBHelper.convert(bpl.get(j));\n          BlockInfoContiguous storedBlock \u003d\n              (BlockInfoContiguous) fsn.getBlockManager().getStoredBlock(blk);\n          if(storedBlock \u003d\u003d null) {\n            storedBlock \u003d (BlockInfoContiguous) fsn.getBlockManager()\n                .addBlockCollectionWithCheck(new BlockInfoContiguous(blk,\n                    copy.getFileReplication()), file);\n          }\n          blocks[j] \u003d storedBlock;\n        }\n        if(blocks.length \u003e 0) {\n          diff.setBlocks(blocks);\n        }\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "9f2f583f401189c3f4a2687795a9e3e0b288322b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7749. Erasure Coding: Add striped block support in INodeFile. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:07 AM",
      "commitName": "9f2f583f401189c3f4a2687795a9e3e0b288322b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:07 AM",
      "commitNameOld": "ba9371492036983a9899398907ab41fe548f29b3",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,56 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             int[] entries \u003d AclEntryStatusFormat\n                 .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                     fileInPb.getAcl(), state.getStringTable()));\n             acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n               (byte)fileInPb.getStoragePolicyID(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n-        // TODO: also persist striped blocks\n+        // in file diff there can only be contiguous blocks\n         BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[bpl.size()];\n         for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n           Block blk \u003d PBHelper.convert(bpl.get(j));\n           BlockInfoContiguous storedBlock \u003d\n               (BlockInfoContiguous) fsn.getBlockManager().getStoredBlock(blk);\n           if(storedBlock \u003d\u003d null) {\n-            storedBlock \u003d fsn.getBlockManager().addBlockCollection(\n-                new BlockInfoContiguous(blk, copy.getFileReplication()), file);\n+            storedBlock \u003d (BlockInfoContiguous) fsn.getBlockManager()\n+                .addBlockCollection(new BlockInfoContiguous(blk,\n+                    copy.getFileReplication()), file);\n           }\n           blocks[j] \u003d storedBlock;\n         }\n         if(blocks.length \u003e 0) {\n           diff.setBlocks(blocks);\n         }\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n        // in file diff there can only be contiguous blocks\n        BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[bpl.size()];\n        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n          Block blk \u003d PBHelper.convert(bpl.get(j));\n          BlockInfoContiguous storedBlock \u003d\n              (BlockInfoContiguous) fsn.getBlockManager().getStoredBlock(blk);\n          if(storedBlock \u003d\u003d null) {\n            storedBlock \u003d (BlockInfoContiguous) fsn.getBlockManager()\n                .addBlockCollection(new BlockInfoContiguous(blk,\n                    copy.getFileReplication()), file);\n          }\n          blocks[j] \u003d storedBlock;\n        }\n        if(blocks.length \u003e 0) {\n          diff.setBlocks(blocks);\n        }\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "ba9371492036983a9899398907ab41fe548f29b3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7716. Erasure Coding: extend BlockInfo to handle EC info. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:07 AM",
      "commitName": "ba9371492036983a9899398907ab41fe548f29b3",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "21/02/15 3:38 PM",
      "commitNameOld": "8b465b4b8caed31ca9daeaae108f9a868a30a455",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 93.77,
      "commitsBetweenForRepo": 873,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,55 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             int[] entries \u003d AclEntryStatusFormat\n                 .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                     fileInPb.getAcl(), state.getStringTable()));\n             acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n               (byte)fileInPb.getStoragePolicyID(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n+        // TODO: also persist striped blocks\n         BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[bpl.size()];\n         for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n           Block blk \u003d PBHelper.convert(bpl.get(j));\n-          BlockInfoContiguous storedBlock \u003d  fsn.getBlockManager().getStoredBlock(blk);\n+          BlockInfoContiguous storedBlock \u003d\n+              (BlockInfoContiguous) fsn.getBlockManager().getStoredBlock(blk);\n           if(storedBlock \u003d\u003d null) {\n             storedBlock \u003d fsn.getBlockManager().addBlockCollection(\n                 new BlockInfoContiguous(blk, copy.getFileReplication()), file);\n           }\n           blocks[j] \u003d storedBlock;\n         }\n         if(blocks.length \u003e 0) {\n           diff.setBlocks(blocks);\n         }\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n        // TODO: also persist striped blocks\n        BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[bpl.size()];\n        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n          Block blk \u003d PBHelper.convert(bpl.get(j));\n          BlockInfoContiguous storedBlock \u003d\n              (BlockInfoContiguous) fsn.getBlockManager().getStoredBlock(blk);\n          if(storedBlock \u003d\u003d null) {\n            storedBlock \u003d fsn.getBlockManager().addBlockCollection(\n                new BlockInfoContiguous(blk, copy.getFileReplication()), file);\n          }\n          blocks[j] \u003d storedBlock;\n        }\n        if(blocks.length \u003e 0) {\n          diff.setBlocks(blocks);\n        }\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "13/01/15 12:24 AM",
      "commitNameOld": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 26.48,
      "commitsBetweenForRepo": 218,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             int[] entries \u003d AclEntryStatusFormat\n                 .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                     fileInPb.getAcl(), state.getStringTable()));\n             acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n               (byte)fileInPb.getStoragePolicyID(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n-        BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n+        BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[bpl.size()];\n         for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n           Block blk \u003d PBHelper.convert(bpl.get(j));\n-          BlockInfo storedBlock \u003d  fsn.getBlockManager().getStoredBlock(blk);\n+          BlockInfoContiguous storedBlock \u003d  fsn.getBlockManager().getStoredBlock(blk);\n           if(storedBlock \u003d\u003d null) {\n             storedBlock \u003d fsn.getBlockManager().addBlockCollection(\n-                new BlockInfo(blk, copy.getFileReplication()), file);\n+                new BlockInfoContiguous(blk, copy.getFileReplication()), file);\n           }\n           blocks[j] \u003d storedBlock;\n         }\n         if(blocks.length \u003e 0) {\n           diff.setBlocks(blocks);\n         }\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n        BlockInfoContiguous[] blocks \u003d new BlockInfoContiguous[bpl.size()];\n        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n          Block blk \u003d PBHelper.convert(bpl.get(j));\n          BlockInfoContiguous storedBlock \u003d  fsn.getBlockManager().getStoredBlock(blk);\n          if(storedBlock \u003d\u003d null) {\n            storedBlock \u003d fsn.getBlockManager().addBlockCollection(\n                new BlockInfoContiguous(blk, copy.getFileReplication()), file);\n          }\n          blocks[j] \u003d storedBlock;\n        }\n        if(blocks.length \u003e 0) {\n          diff.setBlocks(blocks);\n        }\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "08ac06283a3e9bf0d49d873823aabd419b08e41f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7056. Snapshot support for truncate. Contributed by Konstantin Shvachko and Plamen Jeliazkov.",
      "commitDate": "13/01/15 12:24 AM",
      "commitName": "08ac06283a3e9bf0d49d873823aabd419b08e41f",
      "commitAuthor": "Konstantin V Shvachko",
      "commitDateOld": "04/12/14 8:49 PM",
      "commitNameOld": "0653918dad855b394e8e3b8b3f512f474d872ee9",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 39.15,
      "commitsBetweenForRepo": 219,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,53 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             int[] entries \u003d AclEntryStatusFormat\n                 .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                     fileInPb.getAcl(), state.getStringTable()));\n             acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n               (byte)fileInPb.getStoragePolicyID(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n+        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n+        BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n+        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n+          Block blk \u003d PBHelper.convert(bpl.get(j));\n+          BlockInfo storedBlock \u003d  fsn.getBlockManager().getStoredBlock(blk);\n+          if(storedBlock \u003d\u003d null) {\n+            storedBlock \u003d fsn.getBlockManager().addBlockCollection(\n+                new BlockInfo(blk, copy.getFileReplication()), file);\n+          }\n+          blocks[j] \u003d storedBlock;\n+        }\n+        if(blocks.length \u003e 0) {\n+          diff.setBlocks(blocks);\n+        }\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        List\u003cBlockProto\u003e bpl \u003d pbf.getBlocksList();\n        BlockInfo[] blocks \u003d new BlockInfo[bpl.size()];\n        for(int j \u003d 0, e \u003d bpl.size(); j \u003c e; ++j) {\n          Block blk \u003d PBHelper.convert(bpl.get(j));\n          BlockInfo storedBlock \u003d  fsn.getBlockManager().getStoredBlock(blk);\n          if(storedBlock \u003d\u003d null) {\n            storedBlock \u003d fsn.getBlockManager().addBlockCollection(\n                new BlockInfo(blk, copy.getFileReplication()), file);\n          }\n          blocks[j] \u003d storedBlock;\n        }\n        if(blocks.length \u003e 0) {\n          diff.setBlocks(blocks);\n        }\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "0653918dad855b394e8e3b8b3f512f474d872ee9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7454. Reduce memory footprint for AclEntries in NameNode. Contributed by Vinayakumar B.\n",
      "commitDate": "04/12/14 8:49 PM",
      "commitName": "0653918dad855b394e8e3b8b3f512f474d872ee9",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/14 10:27 PM",
      "commitNameOld": "bb84f1fccb18c6c7373851e05d2451d55e908242",
      "commitAuthorOld": "arp",
      "daysBetweenCommits": 65.97,
      "commitsBetweenForRepo": 565,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,39 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n-            acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n-                fileInPb.getAcl(), state.getStringTable()));\n+            int[] entries \u003d AclEntryStatusFormat\n+                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n+                    fileInPb.getAcl(), state.getStringTable()));\n+            acl \u003d new AclFeature(entries);\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n               (byte)fileInPb.getStoragePolicyID(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            int[] entries \u003d AclEntryStatusFormat\n                .toInt(FSImageFormatPBINode.Loader.loadAclEntries(\n                    fileInPb.getAcl(), state.getStringTable()));\n            acl \u003d new AclFeature(entries);\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "bb84f1fccb18c6c7373851e05d2451d55e908242": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7159. Use block storage policy to set lazy persist preference. (Arpit Agarwal)\n",
      "commitDate": "29/09/14 10:27 PM",
      "commitName": "bb84f1fccb18c6c7373851e05d2451d55e908242",
      "commitAuthor": "arp",
      "commitDateOld": "18/09/14 10:26 PM",
      "commitNameOld": "f8bbf80067ac03400acae4655615c9808c538ca8",
      "commitAuthorOld": "",
      "daysBetweenCommits": 11.0,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,37 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n                 fileInPb.getAcl(), state.getStringTable()));\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize(),\n-              fileInPb.hasIsLazyPersist() ? fileInPb.getIsLazyPersist() : false,\n               (byte)fileInPb.getStoragePolicyID(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n                fileInPb.getAcl(), state.getStringTable()));\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "042b33f20b01aadb5cd03da731ae7a3d94026aac": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6922. Add LazyPersist flag to INodeFile, save it in FsImage and edit logs. (Arpit Agarwal)\n",
      "commitDate": "27/08/14 9:47 PM",
      "commitName": "042b33f20b01aadb5cd03da731ae7a3d94026aac",
      "commitAuthor": "arp",
      "commitDateOld": "07/07/14 5:08 PM",
      "commitNameOld": "76a621ffd2d66bf012a554f4400091a92a5b473e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 51.19,
      "commitsBetweenForRepo": 428,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,38 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n                 fileInPb.getAcl(), state.getStringTable()));\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n-              fileInPb.getPreferredBlockSize(), xAttrs);\n+              fileInPb.getPreferredBlockSize(),\n+              fileInPb.hasIsLazyPersist() ? fileInPb.getIsLazyPersist() : false,\n+              xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n                fileInPb.getAcl(), state.getStringTable()));\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              fileInPb.hasIsLazyPersist() ? fileInPb.getIsLazyPersist() : false,\n              xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "6f41baa6233dad92865af23ec6b7a89733c11ddd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6677. Change INodeFile and FSImage to support storage policy ID.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-6584@1610525 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/07/14 1:57 PM",
      "commitName": "6f41baa6233dad92865af23ec6b7a89733c11ddd",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "07/07/14 5:08 PM",
      "commitNameOld": "76a621ffd2d66bf012a554f4400091a92a5b473e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 6.87,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,37 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n                 fileInPb.getAcl(), state.getStringTable()));\n           }\n           XAttrFeature xAttrs \u003d null;\n           if (fileInPb.hasXAttrs()) {\n             xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                 fileInPb.getXAttrs(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n-              fileInPb.getPreferredBlockSize(), xAttrs);\n+              fileInPb.getPreferredBlockSize(),\n+              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n                fileInPb.getAcl(), state.getStringTable()));\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(),\n              (byte)fileInPb.getStoragePolicyID(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "ac23a55547716df29b3e25c98a113399e184d9d1": {
      "type": "Ybodychange",
      "commitMessage": "Merge HDFS-2006 HDFS XAttrs branch to Trunk\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596575 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 6:57 AM",
      "commitName": "ac23a55547716df29b3e25c98a113399e184d9d1",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "24/03/14 10:51 PM",
      "commitNameOld": "3a61d25457606b93f7e99a48fe8f66984f4084b0",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 57.34,
      "commitsBetweenForRepo": 342,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,36 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n           if (fileInPb.hasAcl()) {\n             acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n                 fileInPb.getAcl(), state.getStringTable()));\n           }\n+          XAttrFeature xAttrs \u003d null;\n+          if (fileInPb.hasXAttrs()) {\n+            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n+                fileInPb.getXAttrs(), state.getStringTable()));\n+          }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n-              fileInPb.getPreferredBlockSize());\n+              fileInPb.getPreferredBlockSize(), xAttrs);\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n                fileInPb.getAcl(), state.getStringTable()));\n          }\n          XAttrFeature xAttrs \u003d null;\n          if (fileInPb.hasXAttrs()) {\n            xAttrs \u003d new XAttrFeature(FSImageFormatPBINode.Loader.loadXAttrs(\n                fileInPb.getXAttrs(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize(), xAttrs);\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "ea0b21af158016651cb77560778834eb95e6b68d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5933. Optimize the FSImage layout for ACLs. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1567785 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 2:56 PM",
      "commitName": "ea0b21af158016651cb77560778834eb95e6b68d",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "10/02/14 10:25 PM",
      "commitNameOld": "d03acc756094a332f98167426a39db8faf38f450",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 1.69,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n               fileInPb.getPermission(), state.getStringTable());\n \n           AclFeature acl \u003d null;\n-          if (fileInPb.hasAclId()) {\n+          if (fileInPb.hasAcl()) {\n             acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n-                fileInPb.getAclId(), state.getExtendedAclTable()));\n+                fileInPb.getAcl(), state.getStringTable()));\n           }\n \n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize());\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAcl()) {\n            acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n                fileInPb.getAcl(), state.getStringTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize());\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "d03acc756094a332f98167426a39db8faf38f450": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5914. Incorporate ACLs with the changes from HDFS-5698. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-4685@1566991 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/02/14 10:25 PM",
      "commitName": "d03acc756094a332f98167426a39db8faf38f450",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "10/02/14 10:00 PM",
      "commitNameOld": "3bf2f04baca59ee7c74f13193a569ed1d6f5458e",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,31 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n+      final LoaderContext state \u003d parent.getLoaderContext();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n-              fileInPb.getPermission(), parent.getLoaderContext()\n-                  .getStringTable());\n+              fileInPb.getPermission(), state.getStringTable());\n+\n+          AclFeature acl \u003d null;\n+          if (fileInPb.hasAclId()) {\n+            acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n+                fileInPb.getAclId(), state.getExtendedAclTable()));\n+          }\n+\n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n-              .toByteArray(), permission, null, fileInPb.getModificationTime(),\n+              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize());\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      final LoaderContext state \u003d parent.getLoaderContext();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), state.getStringTable());\n\n          AclFeature acl \u003d null;\n          if (fileInPb.hasAclId()) {\n            acl \u003d new AclFeature(FSImageFormatPBINode.Loader.loadAclEntries(\n                fileInPb.getAclId(), state.getExtendedAclTable()));\n          }\n\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, acl, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize());\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "5c978a43c3052cc1466b23653c354399186b4e10": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5915. Refactor FSImageFormatProtobuf to simplify cross section reads. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1566824 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/02/14 3:13 PM",
      "commitName": "5c978a43c3052cc1466b23653c354399186b4e10",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "09/02/14 11:18 AM",
      "commitNameOld": "a2edb11b68ae01a44092cb14ac2717a6aad93305",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 1.16,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,24 @@\n     private void loadFileDiffList(InputStream in, INodeFile file, int size)\n         throws IOException {\n       final FileDiffList diffs \u003d new FileDiffList();\n       for (int i \u003d 0; i \u003c size; i++) {\n         SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n             .parseDelimitedFrom(in);\n         INodeFileAttributes copy \u003d null;\n         if (pbf.hasSnapshotCopy()) {\n           INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n           PermissionStatus permission \u003d loadPermission(\n-              fileInPb.getPermission(), parent.getStringTable());\n+              fileInPb.getPermission(), parent.getLoaderContext()\n+                  .getStringTable());\n           copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n               .toByteArray(), permission, fileInPb.getModificationTime(),\n               fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n               fileInPb.getPreferredBlockSize());\n         }\n \n         FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n             pbf.getFileSize());\n         diffs.addFirst(diff);\n       }\n       file.addSnapshotFeature(diffs);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), parent.getLoaderContext()\n                  .getStringTable());\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize());\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java",
      "extendedDetails": {}
    },
    "a2edb11b68ae01a44092cb14ac2717a6aad93305": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5698. Use protobuf to serialize / deserialize FSImage. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1566359 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/02/14 11:18 AM",
      "commitName": "a2edb11b68ae01a44092cb14ac2717a6aad93305",
      "commitAuthor": "Jing Zhao",
      "diff": "@@ -0,0 +1,23 @@\n+    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n+        throws IOException {\n+      final FileDiffList diffs \u003d new FileDiffList();\n+      for (int i \u003d 0; i \u003c size; i++) {\n+        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n+            .parseDelimitedFrom(in);\n+        INodeFileAttributes copy \u003d null;\n+        if (pbf.hasSnapshotCopy()) {\n+          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n+          PermissionStatus permission \u003d loadPermission(\n+              fileInPb.getPermission(), parent.getStringTable());\n+          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n+              .toByteArray(), permission, fileInPb.getModificationTime(),\n+              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n+              fileInPb.getPreferredBlockSize());\n+        }\n+\n+        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n+            pbf.getFileSize());\n+        diffs.addFirst(diff);\n+      }\n+      file.addSnapshotFeature(diffs);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void loadFileDiffList(InputStream in, INodeFile file, int size)\n        throws IOException {\n      final FileDiffList diffs \u003d new FileDiffList();\n      for (int i \u003d 0; i \u003c size; i++) {\n        SnapshotDiffSection.FileDiff pbf \u003d SnapshotDiffSection.FileDiff\n            .parseDelimitedFrom(in);\n        INodeFileAttributes copy \u003d null;\n        if (pbf.hasSnapshotCopy()) {\n          INodeSection.INodeFile fileInPb \u003d pbf.getSnapshotCopy();\n          PermissionStatus permission \u003d loadPermission(\n              fileInPb.getPermission(), parent.getStringTable());\n          copy \u003d new INodeFileAttributes.SnapshotCopy(pbf.getName()\n              .toByteArray(), permission, fileInPb.getModificationTime(),\n              fileInPb.getAccessTime(), (short) fileInPb.getReplication(),\n              fileInPb.getPreferredBlockSize());\n        }\n\n        FileDiff diff \u003d new FileDiff(pbf.getSnapshotId(), copy, null,\n            pbf.getFileSize());\n        diffs.addFirst(diff);\n      }\n      file.addSnapshotFeature(diffs);\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/FSImageFormatPBSnapshot.java"
    }
  }
}