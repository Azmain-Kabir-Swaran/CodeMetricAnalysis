{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "KeyProviderCryptoExtension.java",
  "functionName": "decryptEncryptedKey",
  "functionId": "decryptEncryptedKey___encryptedKeyVersion-EncryptedKeyVersion",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/KeyProviderCryptoExtension.java",
  "functionStartLine": 438,
  "functionEndLine": 461,
  "numCommitsSeen": 20,
  "timeTaken": 1864,
  "changeHistory": [
    "4ec5acc70418a3f2327cf83ecae1789a057fdd99",
    "4ebc23ba7b16c7b9acf38b5a864682a6c8890690",
    "c60da4d3b31e5fa0c4b27cf75ab7ed4add56396a",
    "513dc29ce833f574895a6c40036758ba16823942",
    "e0f00e12ce99ebd521f2055118fac9636ab6e51f",
    "405dbd521e88b2762657b924f23e4eb6adbe5843"
  ],
  "changeHistoryShort": {
    "4ec5acc70418a3f2327cf83ecae1789a057fdd99": "Ybodychange",
    "4ebc23ba7b16c7b9acf38b5a864682a6c8890690": "Ybodychange",
    "c60da4d3b31e5fa0c4b27cf75ab7ed4add56396a": "Ybodychange",
    "513dc29ce833f574895a6c40036758ba16823942": "Ybodychange",
    "e0f00e12ce99ebd521f2055118fac9636ab6e51f": "Ybodychange",
    "405dbd521e88b2762657b924f23e4eb6adbe5843": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4ec5acc70418a3f2327cf83ecae1789a057fdd99": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14705. Add batched interface reencryptEncryptedKeys to KMS.\n",
      "commitDate": "22/08/17 7:47 AM",
      "commitName": "4ec5acc70418a3f2327cf83ecae1789a057fdd99",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "16/06/17 9:49 AM",
      "commitNameOld": "4ebc23ba7b16c7b9acf38b5a864682a6c8890690",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 66.92,
      "commitsBetweenForRepo": 413,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,24 @@\n     public KeyVersion decryptEncryptedKey(\n-        EncryptedKeyVersion encryptedKeyVersion) throws IOException,\n-        GeneralSecurityException {\n+        EncryptedKeyVersion encryptedKeyVersion)\n+        throws IOException, GeneralSecurityException {\n       // Fetch the encryption key material\n       final String encryptionKeyVersionName \u003d\n           encryptedKeyVersion.getEncryptionKeyVersionName();\n       final KeyVersion encryptionKey \u003d\n           keyProvider.getKeyVersion(encryptionKeyVersionName);\n-      Preconditions.checkNotNull(encryptionKey,\n-          \"KeyVersion name \u0027%s\u0027 does not exist\", encryptionKeyVersionName);\n+      Preconditions\n+          .checkNotNull(encryptionKey, \"KeyVersion name \u0027%s\u0027 does not exist\",\n+              encryptionKeyVersionName);\n       Preconditions.checkArgument(\n-              encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n-                    .equals(KeyProviderCryptoExtension.EEK),\n-                \"encryptedKey version name must be \u0027%s\u0027, is \u0027%s\u0027\",\n-                KeyProviderCryptoExtension.EEK,\n-                encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n-            );\n+          encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n+              .equals(KeyProviderCryptoExtension.EEK),\n+          \"encryptedKey version name must be \u0027%s\u0027, but found \u0027%s\u0027\",\n+          KeyProviderCryptoExtension.EEK,\n+          encryptedKeyVersion.getEncryptedKeyVersion().getVersionName());\n \n-      // Encryption key IV is determined from encrypted key\u0027s IV\n-      final byte[] encryptionIV \u003d\n-          EncryptedKeyVersion.deriveIV(encryptedKeyVersion.getEncryptedKeyIv());\n-\n-      CryptoCodec cc \u003d CryptoCodec.getInstance(keyProvider.getConf());\n-      Decryptor decryptor \u003d cc.createDecryptor();\n-      decryptor.init(encryptionKey.getMaterial(), encryptionIV);\n-      final KeyVersion encryptedKV \u003d\n-          encryptedKeyVersion.getEncryptedKeyVersion();\n-      int keyLen \u003d encryptedKV.getMaterial().length;\n-      ByteBuffer bbIn \u003d ByteBuffer.allocateDirect(keyLen);\n-      ByteBuffer bbOut \u003d ByteBuffer.allocateDirect(keyLen);\n-      bbIn.put(encryptedKV.getMaterial());\n-      bbIn.flip();\n-      decryptor.decrypt(bbIn, bbOut);\n-      bbOut.flip();\n-      byte[] decryptedKey \u003d new byte[keyLen];\n-      bbOut.get(decryptedKey);\n-      cc.close();\n-      return new KeyVersion(encryptionKey.getName(), EK, decryptedKey);\n+      try (CryptoCodec cc \u003d CryptoCodec.getInstance(keyProvider.getConf())) {\n+        final Decryptor decryptor \u003d cc.createDecryptor();\n+        return decryptEncryptedKey(decryptor, encryptionKey,\n+            encryptedKeyVersion);\n+      }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyVersion decryptEncryptedKey(\n        EncryptedKeyVersion encryptedKeyVersion)\n        throws IOException, GeneralSecurityException {\n      // Fetch the encryption key material\n      final String encryptionKeyVersionName \u003d\n          encryptedKeyVersion.getEncryptionKeyVersionName();\n      final KeyVersion encryptionKey \u003d\n          keyProvider.getKeyVersion(encryptionKeyVersionName);\n      Preconditions\n          .checkNotNull(encryptionKey, \"KeyVersion name \u0027%s\u0027 does not exist\",\n              encryptionKeyVersionName);\n      Preconditions.checkArgument(\n          encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n              .equals(KeyProviderCryptoExtension.EEK),\n          \"encryptedKey version name must be \u0027%s\u0027, but found \u0027%s\u0027\",\n          KeyProviderCryptoExtension.EEK,\n          encryptedKeyVersion.getEncryptedKeyVersion().getVersionName());\n\n      try (CryptoCodec cc \u003d CryptoCodec.getInstance(keyProvider.getConf())) {\n        final Decryptor decryptor \u003d cc.createDecryptor();\n        return decryptEncryptedKey(decryptor, encryptionKey,\n            encryptedKeyVersion);\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/KeyProviderCryptoExtension.java",
      "extendedDetails": {}
    },
    "4ebc23ba7b16c7b9acf38b5a864682a6c8890690": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14524. Make CryptoCodec Closeable so it can be cleaned up proactively.\n",
      "commitDate": "16/06/17 9:49 AM",
      "commitName": "4ebc23ba7b16c7b9acf38b5a864682a6c8890690",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "06/12/16 12:04 PM",
      "commitNameOld": "79d90b810c14d5e3abab75235f587663834ce36c",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 191.86,
      "commitsBetweenForRepo": 1005,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,39 @@\n     public KeyVersion decryptEncryptedKey(\n         EncryptedKeyVersion encryptedKeyVersion) throws IOException,\n         GeneralSecurityException {\n       // Fetch the encryption key material\n       final String encryptionKeyVersionName \u003d\n           encryptedKeyVersion.getEncryptionKeyVersionName();\n       final KeyVersion encryptionKey \u003d\n           keyProvider.getKeyVersion(encryptionKeyVersionName);\n       Preconditions.checkNotNull(encryptionKey,\n           \"KeyVersion name \u0027%s\u0027 does not exist\", encryptionKeyVersionName);\n       Preconditions.checkArgument(\n               encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n                     .equals(KeyProviderCryptoExtension.EEK),\n                 \"encryptedKey version name must be \u0027%s\u0027, is \u0027%s\u0027\",\n                 KeyProviderCryptoExtension.EEK,\n                 encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n             );\n \n       // Encryption key IV is determined from encrypted key\u0027s IV\n       final byte[] encryptionIV \u003d\n           EncryptedKeyVersion.deriveIV(encryptedKeyVersion.getEncryptedKeyIv());\n \n       CryptoCodec cc \u003d CryptoCodec.getInstance(keyProvider.getConf());\n       Decryptor decryptor \u003d cc.createDecryptor();\n       decryptor.init(encryptionKey.getMaterial(), encryptionIV);\n       final KeyVersion encryptedKV \u003d\n           encryptedKeyVersion.getEncryptedKeyVersion();\n       int keyLen \u003d encryptedKV.getMaterial().length;\n       ByteBuffer bbIn \u003d ByteBuffer.allocateDirect(keyLen);\n       ByteBuffer bbOut \u003d ByteBuffer.allocateDirect(keyLen);\n       bbIn.put(encryptedKV.getMaterial());\n       bbIn.flip();\n       decryptor.decrypt(bbIn, bbOut);\n       bbOut.flip();\n       byte[] decryptedKey \u003d new byte[keyLen];\n       bbOut.get(decryptedKey);\n+      cc.close();\n       return new KeyVersion(encryptionKey.getName(), EK, decryptedKey);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyVersion decryptEncryptedKey(\n        EncryptedKeyVersion encryptedKeyVersion) throws IOException,\n        GeneralSecurityException {\n      // Fetch the encryption key material\n      final String encryptionKeyVersionName \u003d\n          encryptedKeyVersion.getEncryptionKeyVersionName();\n      final KeyVersion encryptionKey \u003d\n          keyProvider.getKeyVersion(encryptionKeyVersionName);\n      Preconditions.checkNotNull(encryptionKey,\n          \"KeyVersion name \u0027%s\u0027 does not exist\", encryptionKeyVersionName);\n      Preconditions.checkArgument(\n              encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n                    .equals(KeyProviderCryptoExtension.EEK),\n                \"encryptedKey version name must be \u0027%s\u0027, is \u0027%s\u0027\",\n                KeyProviderCryptoExtension.EEK,\n                encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n            );\n\n      // Encryption key IV is determined from encrypted key\u0027s IV\n      final byte[] encryptionIV \u003d\n          EncryptedKeyVersion.deriveIV(encryptedKeyVersion.getEncryptedKeyIv());\n\n      CryptoCodec cc \u003d CryptoCodec.getInstance(keyProvider.getConf());\n      Decryptor decryptor \u003d cc.createDecryptor();\n      decryptor.init(encryptionKey.getMaterial(), encryptionIV);\n      final KeyVersion encryptedKV \u003d\n          encryptedKeyVersion.getEncryptedKeyVersion();\n      int keyLen \u003d encryptedKV.getMaterial().length;\n      ByteBuffer bbIn \u003d ByteBuffer.allocateDirect(keyLen);\n      ByteBuffer bbOut \u003d ByteBuffer.allocateDirect(keyLen);\n      bbIn.put(encryptedKV.getMaterial());\n      bbIn.flip();\n      decryptor.decrypt(bbIn, bbOut);\n      bbOut.flip();\n      byte[] decryptedKey \u003d new byte[keyLen];\n      bbOut.get(decryptedKey);\n      cc.close();\n      return new KeyVersion(encryptionKey.getName(), EK, decryptedKey);\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/KeyProviderCryptoExtension.java",
      "extendedDetails": {}
    },
    "c60da4d3b31e5fa0c4b27cf75ab7ed4add56396a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10994. KeyProviderCryptoExtension should use CryptoCodec for generation/decryption of keys. (tucu)\n",
      "commitDate": "29/08/14 2:21 PM",
      "commitName": "c60da4d3b31e5fa0c4b27cf75ab7ed4add56396a",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "14/08/14 10:45 PM",
      "commitNameOld": "be117cbcdf9e7c72bb24aaf3556cf1212963ed4b",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 14.65,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,38 @@\n     public KeyVersion decryptEncryptedKey(\n         EncryptedKeyVersion encryptedKeyVersion) throws IOException,\n         GeneralSecurityException {\n       // Fetch the encryption key material\n       final String encryptionKeyVersionName \u003d\n           encryptedKeyVersion.getEncryptionKeyVersionName();\n       final KeyVersion encryptionKey \u003d\n           keyProvider.getKeyVersion(encryptionKeyVersionName);\n       Preconditions.checkNotNull(encryptionKey,\n           \"KeyVersion name \u0027%s\u0027 does not exist\", encryptionKeyVersionName);\n       Preconditions.checkArgument(\n               encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n                     .equals(KeyProviderCryptoExtension.EEK),\n                 \"encryptedKey version name must be \u0027%s\u0027, is \u0027%s\u0027\",\n                 KeyProviderCryptoExtension.EEK,\n                 encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n             );\n-      final byte[] encryptionKeyMaterial \u003d encryptionKey.getMaterial();\n+\n       // Encryption key IV is determined from encrypted key\u0027s IV\n       final byte[] encryptionIV \u003d\n           EncryptedKeyVersion.deriveIV(encryptedKeyVersion.getEncryptedKeyIv());\n-      // Init the cipher with encryption key parameters\n-      Cipher cipher \u003d Cipher.getInstance(\"AES/CTR/NoPadding\");\n-      cipher.init(Cipher.DECRYPT_MODE,\n-          new SecretKeySpec(encryptionKeyMaterial, \"AES\"),\n-          new IvParameterSpec(encryptionIV));\n-      // Decrypt the encrypted key\n+\n+      CryptoCodec cc \u003d CryptoCodec.getInstance(keyProvider.getConf());\n+      Decryptor decryptor \u003d cc.createDecryptor();\n+      decryptor.init(encryptionKey.getMaterial(), encryptionIV);\n       final KeyVersion encryptedKV \u003d\n           encryptedKeyVersion.getEncryptedKeyVersion();\n-      final byte[] decryptedKey \u003d cipher.doFinal(encryptedKV.getMaterial());\n+      int keyLen \u003d encryptedKV.getMaterial().length;\n+      ByteBuffer bbIn \u003d ByteBuffer.allocateDirect(keyLen);\n+      ByteBuffer bbOut \u003d ByteBuffer.allocateDirect(keyLen);\n+      bbIn.put(encryptedKV.getMaterial());\n+      bbIn.flip();\n+      decryptor.decrypt(bbIn, bbOut);\n+      bbOut.flip();\n+      byte[] decryptedKey \u003d new byte[keyLen];\n+      bbOut.get(decryptedKey);\n       return new KeyVersion(encryptionKey.getName(), EK, decryptedKey);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyVersion decryptEncryptedKey(\n        EncryptedKeyVersion encryptedKeyVersion) throws IOException,\n        GeneralSecurityException {\n      // Fetch the encryption key material\n      final String encryptionKeyVersionName \u003d\n          encryptedKeyVersion.getEncryptionKeyVersionName();\n      final KeyVersion encryptionKey \u003d\n          keyProvider.getKeyVersion(encryptionKeyVersionName);\n      Preconditions.checkNotNull(encryptionKey,\n          \"KeyVersion name \u0027%s\u0027 does not exist\", encryptionKeyVersionName);\n      Preconditions.checkArgument(\n              encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n                    .equals(KeyProviderCryptoExtension.EEK),\n                \"encryptedKey version name must be \u0027%s\u0027, is \u0027%s\u0027\",\n                KeyProviderCryptoExtension.EEK,\n                encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n            );\n\n      // Encryption key IV is determined from encrypted key\u0027s IV\n      final byte[] encryptionIV \u003d\n          EncryptedKeyVersion.deriveIV(encryptedKeyVersion.getEncryptedKeyIv());\n\n      CryptoCodec cc \u003d CryptoCodec.getInstance(keyProvider.getConf());\n      Decryptor decryptor \u003d cc.createDecryptor();\n      decryptor.init(encryptionKey.getMaterial(), encryptionIV);\n      final KeyVersion encryptedKV \u003d\n          encryptedKeyVersion.getEncryptedKeyVersion();\n      int keyLen \u003d encryptedKV.getMaterial().length;\n      ByteBuffer bbIn \u003d ByteBuffer.allocateDirect(keyLen);\n      ByteBuffer bbOut \u003d ByteBuffer.allocateDirect(keyLen);\n      bbIn.put(encryptedKV.getMaterial());\n      bbIn.flip();\n      decryptor.decrypt(bbIn, bbOut);\n      bbOut.flip();\n      byte[] decryptedKey \u003d new byte[keyLen];\n      bbOut.get(decryptedKey);\n      return new KeyVersion(encryptionKey.getName(), EK, decryptedKey);\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/KeyProviderCryptoExtension.java",
      "extendedDetails": {}
    },
    "513dc29ce833f574895a6c40036758ba16823942": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10937. Need to set version name correctly before decrypting EEK. Contributed by Arun Suresh.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615841 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/08/14 7:21 PM",
      "commitName": "513dc29ce833f574895a6c40036758ba16823942",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "24/07/14 4:49 PM",
      "commitNameOld": "934ba441c1739eb72c6afcb56cd1a56a98aeda97",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 11.11,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,32 @@\n     public KeyVersion decryptEncryptedKey(\n         EncryptedKeyVersion encryptedKeyVersion) throws IOException,\n         GeneralSecurityException {\n       // Fetch the encryption key material\n       final String encryptionKeyVersionName \u003d\n           encryptedKeyVersion.getEncryptionKeyVersionName();\n       final KeyVersion encryptionKey \u003d\n           keyProvider.getKeyVersion(encryptionKeyVersionName);\n       Preconditions.checkNotNull(encryptionKey,\n           \"KeyVersion name \u0027%s\u0027 does not exist\", encryptionKeyVersionName);\n+      Preconditions.checkArgument(\n+              encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n+                    .equals(KeyProviderCryptoExtension.EEK),\n+                \"encryptedKey version name must be \u0027%s\u0027, is \u0027%s\u0027\",\n+                KeyProviderCryptoExtension.EEK,\n+                encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n+            );\n       final byte[] encryptionKeyMaterial \u003d encryptionKey.getMaterial();\n       // Encryption key IV is determined from encrypted key\u0027s IV\n       final byte[] encryptionIV \u003d\n           EncryptedKeyVersion.deriveIV(encryptedKeyVersion.getEncryptedKeyIv());\n       // Init the cipher with encryption key parameters\n       Cipher cipher \u003d Cipher.getInstance(\"AES/CTR/NoPadding\");\n       cipher.init(Cipher.DECRYPT_MODE,\n           new SecretKeySpec(encryptionKeyMaterial, \"AES\"),\n           new IvParameterSpec(encryptionIV));\n       // Decrypt the encrypted key\n       final KeyVersion encryptedKV \u003d\n           encryptedKeyVersion.getEncryptedKeyVersion();\n       final byte[] decryptedKey \u003d cipher.doFinal(encryptedKV.getMaterial());\n       return new KeyVersion(encryptionKey.getName(), EK, decryptedKey);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyVersion decryptEncryptedKey(\n        EncryptedKeyVersion encryptedKeyVersion) throws IOException,\n        GeneralSecurityException {\n      // Fetch the encryption key material\n      final String encryptionKeyVersionName \u003d\n          encryptedKeyVersion.getEncryptionKeyVersionName();\n      final KeyVersion encryptionKey \u003d\n          keyProvider.getKeyVersion(encryptionKeyVersionName);\n      Preconditions.checkNotNull(encryptionKey,\n          \"KeyVersion name \u0027%s\u0027 does not exist\", encryptionKeyVersionName);\n      Preconditions.checkArgument(\n              encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n                    .equals(KeyProviderCryptoExtension.EEK),\n                \"encryptedKey version name must be \u0027%s\u0027, is \u0027%s\u0027\",\n                KeyProviderCryptoExtension.EEK,\n                encryptedKeyVersion.getEncryptedKeyVersion().getVersionName()\n            );\n      final byte[] encryptionKeyMaterial \u003d encryptionKey.getMaterial();\n      // Encryption key IV is determined from encrypted key\u0027s IV\n      final byte[] encryptionIV \u003d\n          EncryptedKeyVersion.deriveIV(encryptedKeyVersion.getEncryptedKeyIv());\n      // Init the cipher with encryption key parameters\n      Cipher cipher \u003d Cipher.getInstance(\"AES/CTR/NoPadding\");\n      cipher.init(Cipher.DECRYPT_MODE,\n          new SecretKeySpec(encryptionKeyMaterial, \"AES\"),\n          new IvParameterSpec(encryptionIV));\n      // Decrypt the encrypted key\n      final KeyVersion encryptedKV \u003d\n          encryptedKeyVersion.getEncryptedKeyVersion();\n      final byte[] decryptedKey \u003d cipher.doFinal(encryptedKV.getMaterial());\n      return new KeyVersion(encryptionKey.getName(), EK, decryptedKey);\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/KeyProviderCryptoExtension.java",
      "extendedDetails": {}
    },
    "e0f00e12ce99ebd521f2055118fac9636ab6e51f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10881. Clarify usage of encryption and encrypted encryption key in KeyProviderCryptoExtension. (wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612737 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/14 6:24 PM",
      "commitName": "e0f00e12ce99ebd521f2055118fac9636ab6e51f",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/07/14 1:55 PM",
      "commitNameOld": "0c1469ece38556cf02a0c7bd23761d6bf79d9a64",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 1.19,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,16 +1,25 @@\n     public KeyVersion decryptEncryptedKey(\n         EncryptedKeyVersion encryptedKeyVersion) throws IOException,\n         GeneralSecurityException {\n-      KeyVersion keyVer \u003d\n-          keyProvider.getKeyVersion(encryptedKeyVersion.getKeyVersionName());\n-      Preconditions.checkNotNull(keyVer, \"KeyVersion name \u0027%s\u0027 does not exist\",\n-          encryptedKeyVersion.getKeyVersionName());\n-      KeyVersion keyVersion \u003d encryptedKeyVersion.getEncryptedKey();\n+      // Fetch the encryption key material\n+      final String encryptionKeyVersionName \u003d\n+          encryptedKeyVersion.getEncryptionKeyVersionName();\n+      final KeyVersion encryptionKey \u003d\n+          keyProvider.getKeyVersion(encryptionKeyVersionName);\n+      Preconditions.checkNotNull(encryptionKey,\n+          \"KeyVersion name \u0027%s\u0027 does not exist\", encryptionKeyVersionName);\n+      final byte[] encryptionKeyMaterial \u003d encryptionKey.getMaterial();\n+      // Encryption key IV is determined from encrypted key\u0027s IV\n+      final byte[] encryptionIV \u003d\n+          EncryptedKeyVersion.deriveIV(encryptedKeyVersion.getEncryptedKeyIv());\n+      // Init the cipher with encryption key parameters\n       Cipher cipher \u003d Cipher.getInstance(\"AES/CTR/NoPadding\");\n       cipher.init(Cipher.DECRYPT_MODE,\n-          new SecretKeySpec(keyVersion.getMaterial(), \"AES\"),\n-          new IvParameterSpec(flipIV(encryptedKeyVersion.getIv())));\n-      byte[] ek \u003d\n-          cipher.doFinal(encryptedKeyVersion.getEncryptedKey().getMaterial());\n-      return new KeyVersion(keyVer.getName(), EK, ek);\n+          new SecretKeySpec(encryptionKeyMaterial, \"AES\"),\n+          new IvParameterSpec(encryptionIV));\n+      // Decrypt the encrypted key\n+      final KeyVersion encryptedKV \u003d\n+          encryptedKeyVersion.getEncryptedKeyVersion();\n+      final byte[] decryptedKey \u003d cipher.doFinal(encryptedKV.getMaterial());\n+      return new KeyVersion(encryptionKey.getName(), EK, decryptedKey);\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyVersion decryptEncryptedKey(\n        EncryptedKeyVersion encryptedKeyVersion) throws IOException,\n        GeneralSecurityException {\n      // Fetch the encryption key material\n      final String encryptionKeyVersionName \u003d\n          encryptedKeyVersion.getEncryptionKeyVersionName();\n      final KeyVersion encryptionKey \u003d\n          keyProvider.getKeyVersion(encryptionKeyVersionName);\n      Preconditions.checkNotNull(encryptionKey,\n          \"KeyVersion name \u0027%s\u0027 does not exist\", encryptionKeyVersionName);\n      final byte[] encryptionKeyMaterial \u003d encryptionKey.getMaterial();\n      // Encryption key IV is determined from encrypted key\u0027s IV\n      final byte[] encryptionIV \u003d\n          EncryptedKeyVersion.deriveIV(encryptedKeyVersion.getEncryptedKeyIv());\n      // Init the cipher with encryption key parameters\n      Cipher cipher \u003d Cipher.getInstance(\"AES/CTR/NoPadding\");\n      cipher.init(Cipher.DECRYPT_MODE,\n          new SecretKeySpec(encryptionKeyMaterial, \"AES\"),\n          new IvParameterSpec(encryptionIV));\n      // Decrypt the encrypted key\n      final KeyVersion encryptedKV \u003d\n          encryptedKeyVersion.getEncryptedKeyVersion();\n      final byte[] decryptedKey \u003d cipher.doFinal(encryptedKV.getMaterial());\n      return new KeyVersion(encryptionKey.getName(), EK, decryptedKey);\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/KeyProviderCryptoExtension.java",
      "extendedDetails": {}
    },
    "405dbd521e88b2762657b924f23e4eb6adbe5843": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10719. Add generateEncryptedKey and decryptEncryptedKey methods to KeyProvider. (asuresh via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1607918 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/07/14 12:41 PM",
      "commitName": "405dbd521e88b2762657b924f23e4eb6adbe5843",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,16 @@\n+    public KeyVersion decryptEncryptedKey(\n+        EncryptedKeyVersion encryptedKeyVersion) throws IOException,\n+        GeneralSecurityException {\n+      KeyVersion keyVer \u003d\n+          keyProvider.getKeyVersion(encryptedKeyVersion.getKeyVersionName());\n+      Preconditions.checkNotNull(keyVer, \"KeyVersion name \u0027%s\u0027 does not exist\",\n+          encryptedKeyVersion.getKeyVersionName());\n+      KeyVersion keyVersion \u003d encryptedKeyVersion.getEncryptedKey();\n+      Cipher cipher \u003d Cipher.getInstance(\"AES/CTR/NoPadding\");\n+      cipher.init(Cipher.DECRYPT_MODE,\n+          new SecretKeySpec(keyVersion.getMaterial(), \"AES\"),\n+          new IvParameterSpec(flipIV(encryptedKeyVersion.getIv())));\n+      byte[] ek \u003d\n+          cipher.doFinal(encryptedKeyVersion.getEncryptedKey().getMaterial());\n+      return new KeyVersion(keyVer.getName(), EK, ek);\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public KeyVersion decryptEncryptedKey(\n        EncryptedKeyVersion encryptedKeyVersion) throws IOException,\n        GeneralSecurityException {\n      KeyVersion keyVer \u003d\n          keyProvider.getKeyVersion(encryptedKeyVersion.getKeyVersionName());\n      Preconditions.checkNotNull(keyVer, \"KeyVersion name \u0027%s\u0027 does not exist\",\n          encryptedKeyVersion.getKeyVersionName());\n      KeyVersion keyVersion \u003d encryptedKeyVersion.getEncryptedKey();\n      Cipher cipher \u003d Cipher.getInstance(\"AES/CTR/NoPadding\");\n      cipher.init(Cipher.DECRYPT_MODE,\n          new SecretKeySpec(keyVersion.getMaterial(), \"AES\"),\n          new IvParameterSpec(flipIV(encryptedKeyVersion.getIv())));\n      byte[] ek \u003d\n          cipher.doFinal(encryptedKeyVersion.getEncryptedKey().getMaterial());\n      return new KeyVersion(keyVer.getName(), EK, ek);\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/KeyProviderCryptoExtension.java"
    }
  }
}