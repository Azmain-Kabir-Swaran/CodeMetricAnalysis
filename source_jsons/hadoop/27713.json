{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RouterPolicyFacade.java",
  "functionName": "getHomeSubcluster",
  "functionId": "getHomeSubcluster___appSubmissionContext-ApplicationSubmissionContext__blackListSubClusters-List__SubClusterId__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/RouterPolicyFacade.java",
  "functionStartLine": 127,
  "functionEndLine": 205,
  "numCommitsSeen": 9,
  "timeTaken": 1973,
  "changeHistory": [
    "825108d08a9b49d7c19915624f9167101528cb95",
    "4cfec943b177e2123a935e70d39776521883c2bc",
    "083a05bc1420d6d6aa30d98ab48c2ed8ead5b810"
  ],
  "changeHistoryShort": {
    "825108d08a9b49d7c19915624f9167101528cb95": "Ybodychange",
    "4cfec943b177e2123a935e70d39776521883c2bc": "Ymultichange(Yparameterchange,Ybodychange)",
    "083a05bc1420d6d6aa30d98ab48c2ed8ead5b810": "Yintroduced"
  },
  "changeHistoryDetails": {
    "825108d08a9b49d7c19915624f9167101528cb95": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6815. FederationStateStoreFacade return behavior should be consistent irrespective of whether caching is enabled or not.\n\n(cherry picked from commit 8820693cd769065eed83193b673ec5d919d69500)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "825108d08a9b49d7c19915624f9167101528cb95",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/08/17 5:28 PM",
      "commitNameOld": "43a97174fe49aa0c25d03b8a970a46d4bebf1aa8",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,79 @@\n   public SubClusterId getHomeSubcluster(\n       ApplicationSubmissionContext appSubmissionContext,\n       List\u003cSubClusterId\u003e blackListSubClusters) throws YarnException {\n \n     // the maps are concurrent, but we need to protect from reset()\n     // reinitialization mid-execution by creating a new reference local to this\n     // method.\n     Map\u003cString, SubClusterPolicyConfiguration\u003e cachedConfs \u003d globalConfMap;\n     Map\u003cString, FederationRouterPolicy\u003e policyMap \u003d globalPolicyMap;\n \n     if (appSubmissionContext \u003d\u003d null) {\n       throw new FederationPolicyException(\n           \"The ApplicationSubmissionContext \" + \"cannot be null.\");\n     }\n \n     String queue \u003d appSubmissionContext.getQueue();\n \n     // respecting YARN behavior we assume default queue if the queue is not\n     // specified. This also ensures that \"null\" can be used as a key to get the\n     // default behavior.\n     if (queue \u003d\u003d null) {\n       queue \u003d YarnConfiguration.DEFAULT_QUEUE_NAME;\n     }\n \n     // the facade might cache this request, based on its parameterization\n     SubClusterPolicyConfiguration configuration \u003d null;\n \n     try {\n       configuration \u003d federationFacade.getPolicyConfiguration(queue);\n     } catch (YarnException e) {\n-      LOG.debug(e);\n+      String errMsg \u003d \"There is no policy configured for the queue: \" + queue\n+          + \", falling back to defaults.\";\n+      LOG.warn(errMsg, e);\n     }\n \n     // If there is no policy configured for this queue, fallback to the baseline\n     // policy that is configured either in the store or via XML config (and\n     // cached)\n     if (configuration \u003d\u003d null) {\n-      try {\n-        LOG.warn(\"There is no policies configured for queue: \" + queue + \" we\"\n-            + \" fallback to default policy for: \"\n-            + YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n+      LOG.warn(\"There is no policies configured for queue: \" + queue + \" we\"\n+          + \" fallback to default policy for: \"\n+          + YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n \n-        queue \u003d YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY;\n-        configuration \u003d federationFacade.getPolicyConfiguration(\n-            YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n+      queue \u003d YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY;\n+      try {\n+        configuration \u003d federationFacade.getPolicyConfiguration(queue);\n       } catch (YarnException e) {\n-        // the fallback is not configure via store, but via XML, using\n-        // previously loaded configuration.\n-        configuration \u003d\n-            cachedConfs.get(YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n+        String errMsg \u003d \"Cannot retrieve policy configured for the queue: \"\n+            + queue + \", falling back to defaults.\";\n+        LOG.warn(errMsg, e);\n+\n       }\n     }\n \n+    // the fallback is not configure via store, but via XML, using\n+    // previously loaded configuration.\n+    if (configuration \u003d\u003d null) {\n+      configuration \u003d\n+          cachedConfs.get(YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n+    }\n+\n     // if the configuration has changed since last loaded, reinit the policy\n     // based on current configuration\n     if (!cachedConfs.containsKey(queue)\n         || !cachedConfs.get(queue).equals(configuration)) {\n       singlePolicyReinit(policyMap, cachedConfs, queue, configuration);\n     }\n \n     FederationRouterPolicy policy \u003d policyMap.get(queue);\n     if (policy \u003d\u003d null) {\n       // this should never happen, as the to maps are updated together\n       throw new FederationPolicyException(\"No FederationRouterPolicy found \"\n           + \"for queue: \" + appSubmissionContext.getQueue() + \" (for \"\n           + \"application: \" + appSubmissionContext.getApplicationId() + \") \"\n           + \"and no default specified.\");\n     }\n \n     return policy.getHomeSubcluster(appSubmissionContext, blackListSubClusters);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public SubClusterId getHomeSubcluster(\n      ApplicationSubmissionContext appSubmissionContext,\n      List\u003cSubClusterId\u003e blackListSubClusters) throws YarnException {\n\n    // the maps are concurrent, but we need to protect from reset()\n    // reinitialization mid-execution by creating a new reference local to this\n    // method.\n    Map\u003cString, SubClusterPolicyConfiguration\u003e cachedConfs \u003d globalConfMap;\n    Map\u003cString, FederationRouterPolicy\u003e policyMap \u003d globalPolicyMap;\n\n    if (appSubmissionContext \u003d\u003d null) {\n      throw new FederationPolicyException(\n          \"The ApplicationSubmissionContext \" + \"cannot be null.\");\n    }\n\n    String queue \u003d appSubmissionContext.getQueue();\n\n    // respecting YARN behavior we assume default queue if the queue is not\n    // specified. This also ensures that \"null\" can be used as a key to get the\n    // default behavior.\n    if (queue \u003d\u003d null) {\n      queue \u003d YarnConfiguration.DEFAULT_QUEUE_NAME;\n    }\n\n    // the facade might cache this request, based on its parameterization\n    SubClusterPolicyConfiguration configuration \u003d null;\n\n    try {\n      configuration \u003d federationFacade.getPolicyConfiguration(queue);\n    } catch (YarnException e) {\n      String errMsg \u003d \"There is no policy configured for the queue: \" + queue\n          + \", falling back to defaults.\";\n      LOG.warn(errMsg, e);\n    }\n\n    // If there is no policy configured for this queue, fallback to the baseline\n    // policy that is configured either in the store or via XML config (and\n    // cached)\n    if (configuration \u003d\u003d null) {\n      LOG.warn(\"There is no policies configured for queue: \" + queue + \" we\"\n          + \" fallback to default policy for: \"\n          + YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n\n      queue \u003d YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY;\n      try {\n        configuration \u003d federationFacade.getPolicyConfiguration(queue);\n      } catch (YarnException e) {\n        String errMsg \u003d \"Cannot retrieve policy configured for the queue: \"\n            + queue + \", falling back to defaults.\";\n        LOG.warn(errMsg, e);\n\n      }\n    }\n\n    // the fallback is not configure via store, but via XML, using\n    // previously loaded configuration.\n    if (configuration \u003d\u003d null) {\n      configuration \u003d\n          cachedConfs.get(YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n    }\n\n    // if the configuration has changed since last loaded, reinit the policy\n    // based on current configuration\n    if (!cachedConfs.containsKey(queue)\n        || !cachedConfs.get(queue).equals(configuration)) {\n      singlePolicyReinit(policyMap, cachedConfs, queue, configuration);\n    }\n\n    FederationRouterPolicy policy \u003d policyMap.get(queue);\n    if (policy \u003d\u003d null) {\n      // this should never happen, as the to maps are updated together\n      throw new FederationPolicyException(\"No FederationRouterPolicy found \"\n          + \"for queue: \" + appSubmissionContext.getQueue() + \" (for \"\n          + \"application: \" + appSubmissionContext.getApplicationId() + \") \"\n          + \"and no default specified.\");\n    }\n\n    return policy.getHomeSubcluster(appSubmissionContext, blackListSubClusters);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/RouterPolicyFacade.java",
      "extendedDetails": {}
    },
    "4cfec943b177e2123a935e70d39776521883c2bc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6724. Add ability to blacklist sub-clusters when invoking Routing policies. (Giovanni Matteo Fumarola via Subru).\n\n(cherry picked from commit f8e5de59697cb78686f0e605dc7e93628b5f3297)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "4cfec943b177e2123a935e70d39776521883c2bc",
      "commitAuthor": "Subru Krishnan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6724. Add ability to blacklist sub-clusters when invoking Routing policies. (Giovanni Matteo Fumarola via Subru).\n\n(cherry picked from commit f8e5de59697cb78686f0e605dc7e93628b5f3297)\n",
          "commitDate": "01/08/17 5:28 PM",
          "commitName": "4cfec943b177e2123a935e70d39776521883c2bc",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "01/08/17 5:28 PM",
          "commitNameOld": "70b1a757f13b01a9192ea5fb0820ba7babfd974e",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,71 @@\n   public SubClusterId getHomeSubcluster(\n-      ApplicationSubmissionContext appSubmissionContext) throws YarnException {\n+      ApplicationSubmissionContext appSubmissionContext,\n+      List\u003cSubClusterId\u003e blackListSubClusters) throws YarnException {\n \n     // the maps are concurrent, but we need to protect from reset()\n     // reinitialization mid-execution by creating a new reference local to this\n     // method.\n     Map\u003cString, SubClusterPolicyConfiguration\u003e cachedConfs \u003d globalConfMap;\n     Map\u003cString, FederationRouterPolicy\u003e policyMap \u003d globalPolicyMap;\n \n     if (appSubmissionContext \u003d\u003d null) {\n       throw new FederationPolicyException(\n           \"The ApplicationSubmissionContext \" + \"cannot be null.\");\n     }\n \n     String queue \u003d appSubmissionContext.getQueue();\n \n     // respecting YARN behavior we assume default queue if the queue is not\n     // specified. This also ensures that \"null\" can be used as a key to get the\n     // default behavior.\n     if (queue \u003d\u003d null) {\n       queue \u003d YarnConfiguration.DEFAULT_QUEUE_NAME;\n     }\n \n     // the facade might cache this request, based on its parameterization\n     SubClusterPolicyConfiguration configuration \u003d null;\n \n     try {\n       configuration \u003d federationFacade.getPolicyConfiguration(queue);\n     } catch (YarnException e) {\n       LOG.debug(e);\n     }\n \n     // If there is no policy configured for this queue, fallback to the baseline\n     // policy that is configured either in the store or via XML config (and\n     // cached)\n     if (configuration \u003d\u003d null) {\n       try {\n         LOG.warn(\"There is no policies configured for queue: \" + queue + \" we\"\n             + \" fallback to default policy for: \"\n             + YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n \n         queue \u003d YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY;\n         configuration \u003d federationFacade.getPolicyConfiguration(\n             YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n       } catch (YarnException e) {\n         // the fallback is not configure via store, but via XML, using\n         // previously loaded configuration.\n         configuration \u003d\n             cachedConfs.get(YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n       }\n     }\n \n     // if the configuration has changed since last loaded, reinit the policy\n     // based on current configuration\n     if (!cachedConfs.containsKey(queue)\n         || !cachedConfs.get(queue).equals(configuration)) {\n       singlePolicyReinit(policyMap, cachedConfs, queue, configuration);\n     }\n \n     FederationRouterPolicy policy \u003d policyMap.get(queue);\n     if (policy \u003d\u003d null) {\n       // this should never happen, as the to maps are updated together\n       throw new FederationPolicyException(\"No FederationRouterPolicy found \"\n           + \"for queue: \" + appSubmissionContext.getQueue() + \" (for \"\n           + \"application: \" + appSubmissionContext.getApplicationId() + \") \"\n           + \"and no default specified.\");\n     }\n \n-    return policy.getHomeSubcluster(appSubmissionContext);\n+    return policy.getHomeSubcluster(appSubmissionContext, blackListSubClusters);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public SubClusterId getHomeSubcluster(\n      ApplicationSubmissionContext appSubmissionContext,\n      List\u003cSubClusterId\u003e blackListSubClusters) throws YarnException {\n\n    // the maps are concurrent, but we need to protect from reset()\n    // reinitialization mid-execution by creating a new reference local to this\n    // method.\n    Map\u003cString, SubClusterPolicyConfiguration\u003e cachedConfs \u003d globalConfMap;\n    Map\u003cString, FederationRouterPolicy\u003e policyMap \u003d globalPolicyMap;\n\n    if (appSubmissionContext \u003d\u003d null) {\n      throw new FederationPolicyException(\n          \"The ApplicationSubmissionContext \" + \"cannot be null.\");\n    }\n\n    String queue \u003d appSubmissionContext.getQueue();\n\n    // respecting YARN behavior we assume default queue if the queue is not\n    // specified. This also ensures that \"null\" can be used as a key to get the\n    // default behavior.\n    if (queue \u003d\u003d null) {\n      queue \u003d YarnConfiguration.DEFAULT_QUEUE_NAME;\n    }\n\n    // the facade might cache this request, based on its parameterization\n    SubClusterPolicyConfiguration configuration \u003d null;\n\n    try {\n      configuration \u003d federationFacade.getPolicyConfiguration(queue);\n    } catch (YarnException e) {\n      LOG.debug(e);\n    }\n\n    // If there is no policy configured for this queue, fallback to the baseline\n    // policy that is configured either in the store or via XML config (and\n    // cached)\n    if (configuration \u003d\u003d null) {\n      try {\n        LOG.warn(\"There is no policies configured for queue: \" + queue + \" we\"\n            + \" fallback to default policy for: \"\n            + YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n\n        queue \u003d YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY;\n        configuration \u003d federationFacade.getPolicyConfiguration(\n            YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n      } catch (YarnException e) {\n        // the fallback is not configure via store, but via XML, using\n        // previously loaded configuration.\n        configuration \u003d\n            cachedConfs.get(YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n      }\n    }\n\n    // if the configuration has changed since last loaded, reinit the policy\n    // based on current configuration\n    if (!cachedConfs.containsKey(queue)\n        || !cachedConfs.get(queue).equals(configuration)) {\n      singlePolicyReinit(policyMap, cachedConfs, queue, configuration);\n    }\n\n    FederationRouterPolicy policy \u003d policyMap.get(queue);\n    if (policy \u003d\u003d null) {\n      // this should never happen, as the to maps are updated together\n      throw new FederationPolicyException(\"No FederationRouterPolicy found \"\n          + \"for queue: \" + appSubmissionContext.getQueue() + \" (for \"\n          + \"application: \" + appSubmissionContext.getApplicationId() + \") \"\n          + \"and no default specified.\");\n    }\n\n    return policy.getHomeSubcluster(appSubmissionContext, blackListSubClusters);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/RouterPolicyFacade.java",
          "extendedDetails": {
            "oldValue": "[appSubmissionContext-ApplicationSubmissionContext]",
            "newValue": "[appSubmissionContext-ApplicationSubmissionContext, blackListSubClusters-List\u003cSubClusterId\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6724. Add ability to blacklist sub-clusters when invoking Routing policies. (Giovanni Matteo Fumarola via Subru).\n\n(cherry picked from commit f8e5de59697cb78686f0e605dc7e93628b5f3297)\n",
          "commitDate": "01/08/17 5:28 PM",
          "commitName": "4cfec943b177e2123a935e70d39776521883c2bc",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "01/08/17 5:28 PM",
          "commitNameOld": "70b1a757f13b01a9192ea5fb0820ba7babfd974e",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 2,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,70 +1,71 @@\n   public SubClusterId getHomeSubcluster(\n-      ApplicationSubmissionContext appSubmissionContext) throws YarnException {\n+      ApplicationSubmissionContext appSubmissionContext,\n+      List\u003cSubClusterId\u003e blackListSubClusters) throws YarnException {\n \n     // the maps are concurrent, but we need to protect from reset()\n     // reinitialization mid-execution by creating a new reference local to this\n     // method.\n     Map\u003cString, SubClusterPolicyConfiguration\u003e cachedConfs \u003d globalConfMap;\n     Map\u003cString, FederationRouterPolicy\u003e policyMap \u003d globalPolicyMap;\n \n     if (appSubmissionContext \u003d\u003d null) {\n       throw new FederationPolicyException(\n           \"The ApplicationSubmissionContext \" + \"cannot be null.\");\n     }\n \n     String queue \u003d appSubmissionContext.getQueue();\n \n     // respecting YARN behavior we assume default queue if the queue is not\n     // specified. This also ensures that \"null\" can be used as a key to get the\n     // default behavior.\n     if (queue \u003d\u003d null) {\n       queue \u003d YarnConfiguration.DEFAULT_QUEUE_NAME;\n     }\n \n     // the facade might cache this request, based on its parameterization\n     SubClusterPolicyConfiguration configuration \u003d null;\n \n     try {\n       configuration \u003d federationFacade.getPolicyConfiguration(queue);\n     } catch (YarnException e) {\n       LOG.debug(e);\n     }\n \n     // If there is no policy configured for this queue, fallback to the baseline\n     // policy that is configured either in the store or via XML config (and\n     // cached)\n     if (configuration \u003d\u003d null) {\n       try {\n         LOG.warn(\"There is no policies configured for queue: \" + queue + \" we\"\n             + \" fallback to default policy for: \"\n             + YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n \n         queue \u003d YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY;\n         configuration \u003d federationFacade.getPolicyConfiguration(\n             YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n       } catch (YarnException e) {\n         // the fallback is not configure via store, but via XML, using\n         // previously loaded configuration.\n         configuration \u003d\n             cachedConfs.get(YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n       }\n     }\n \n     // if the configuration has changed since last loaded, reinit the policy\n     // based on current configuration\n     if (!cachedConfs.containsKey(queue)\n         || !cachedConfs.get(queue).equals(configuration)) {\n       singlePolicyReinit(policyMap, cachedConfs, queue, configuration);\n     }\n \n     FederationRouterPolicy policy \u003d policyMap.get(queue);\n     if (policy \u003d\u003d null) {\n       // this should never happen, as the to maps are updated together\n       throw new FederationPolicyException(\"No FederationRouterPolicy found \"\n           + \"for queue: \" + appSubmissionContext.getQueue() + \" (for \"\n           + \"application: \" + appSubmissionContext.getApplicationId() + \") \"\n           + \"and no default specified.\");\n     }\n \n-    return policy.getHomeSubcluster(appSubmissionContext);\n+    return policy.getHomeSubcluster(appSubmissionContext, blackListSubClusters);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public SubClusterId getHomeSubcluster(\n      ApplicationSubmissionContext appSubmissionContext,\n      List\u003cSubClusterId\u003e blackListSubClusters) throws YarnException {\n\n    // the maps are concurrent, but we need to protect from reset()\n    // reinitialization mid-execution by creating a new reference local to this\n    // method.\n    Map\u003cString, SubClusterPolicyConfiguration\u003e cachedConfs \u003d globalConfMap;\n    Map\u003cString, FederationRouterPolicy\u003e policyMap \u003d globalPolicyMap;\n\n    if (appSubmissionContext \u003d\u003d null) {\n      throw new FederationPolicyException(\n          \"The ApplicationSubmissionContext \" + \"cannot be null.\");\n    }\n\n    String queue \u003d appSubmissionContext.getQueue();\n\n    // respecting YARN behavior we assume default queue if the queue is not\n    // specified. This also ensures that \"null\" can be used as a key to get the\n    // default behavior.\n    if (queue \u003d\u003d null) {\n      queue \u003d YarnConfiguration.DEFAULT_QUEUE_NAME;\n    }\n\n    // the facade might cache this request, based on its parameterization\n    SubClusterPolicyConfiguration configuration \u003d null;\n\n    try {\n      configuration \u003d federationFacade.getPolicyConfiguration(queue);\n    } catch (YarnException e) {\n      LOG.debug(e);\n    }\n\n    // If there is no policy configured for this queue, fallback to the baseline\n    // policy that is configured either in the store or via XML config (and\n    // cached)\n    if (configuration \u003d\u003d null) {\n      try {\n        LOG.warn(\"There is no policies configured for queue: \" + queue + \" we\"\n            + \" fallback to default policy for: \"\n            + YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n\n        queue \u003d YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY;\n        configuration \u003d federationFacade.getPolicyConfiguration(\n            YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n      } catch (YarnException e) {\n        // the fallback is not configure via store, but via XML, using\n        // previously loaded configuration.\n        configuration \u003d\n            cachedConfs.get(YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n      }\n    }\n\n    // if the configuration has changed since last loaded, reinit the policy\n    // based on current configuration\n    if (!cachedConfs.containsKey(queue)\n        || !cachedConfs.get(queue).equals(configuration)) {\n      singlePolicyReinit(policyMap, cachedConfs, queue, configuration);\n    }\n\n    FederationRouterPolicy policy \u003d policyMap.get(queue);\n    if (policy \u003d\u003d null) {\n      // this should never happen, as the to maps are updated together\n      throw new FederationPolicyException(\"No FederationRouterPolicy found \"\n          + \"for queue: \" + appSubmissionContext.getQueue() + \" (for \"\n          + \"application: \" + appSubmissionContext.getApplicationId() + \") \"\n          + \"and no default specified.\");\n    }\n\n    return policy.getHomeSubcluster(appSubmissionContext, blackListSubClusters);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/RouterPolicyFacade.java",
          "extendedDetails": {}
        }
      ]
    },
    "083a05bc1420d6d6aa30d98ab48c2ed8ead5b810": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5634. Simplify initialization/use of RouterPolicy via a RouterPolicyFacade. (Carlo Curino via Subru).\n\n(cherry picked from commit d7672ce2bddb40fbaa77d3f6fec8c99f5589177f)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "083a05bc1420d6d6aa30d98ab48c2ed8ead5b810",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,70 @@\n+  public SubClusterId getHomeSubcluster(\n+      ApplicationSubmissionContext appSubmissionContext) throws YarnException {\n+\n+    // the maps are concurrent, but we need to protect from reset()\n+    // reinitialization mid-execution by creating a new reference local to this\n+    // method.\n+    Map\u003cString, SubClusterPolicyConfiguration\u003e cachedConfs \u003d globalConfMap;\n+    Map\u003cString, FederationRouterPolicy\u003e policyMap \u003d globalPolicyMap;\n+\n+    if (appSubmissionContext \u003d\u003d null) {\n+      throw new FederationPolicyException(\n+          \"The ApplicationSubmissionContext \" + \"cannot be null.\");\n+    }\n+\n+    String queue \u003d appSubmissionContext.getQueue();\n+\n+    // respecting YARN behavior we assume default queue if the queue is not\n+    // specified. This also ensures that \"null\" can be used as a key to get the\n+    // default behavior.\n+    if (queue \u003d\u003d null) {\n+      queue \u003d YarnConfiguration.DEFAULT_QUEUE_NAME;\n+    }\n+\n+    // the facade might cache this request, based on its parameterization\n+    SubClusterPolicyConfiguration configuration \u003d null;\n+\n+    try {\n+      configuration \u003d federationFacade.getPolicyConfiguration(queue);\n+    } catch (YarnException e) {\n+      LOG.debug(e);\n+    }\n+\n+    // If there is no policy configured for this queue, fallback to the baseline\n+    // policy that is configured either in the store or via XML config (and\n+    // cached)\n+    if (configuration \u003d\u003d null) {\n+      try {\n+        LOG.warn(\"There is no policies configured for queue: \" + queue + \" we\"\n+            + \" fallback to default policy for: \"\n+            + YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n+\n+        queue \u003d YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY;\n+        configuration \u003d federationFacade.getPolicyConfiguration(\n+            YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n+      } catch (YarnException e) {\n+        // the fallback is not configure via store, but via XML, using\n+        // previously loaded configuration.\n+        configuration \u003d\n+            cachedConfs.get(YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n+      }\n+    }\n+\n+    // if the configuration has changed since last loaded, reinit the policy\n+    // based on current configuration\n+    if (!cachedConfs.containsKey(queue)\n+        || !cachedConfs.get(queue).equals(configuration)) {\n+      singlePolicyReinit(policyMap, cachedConfs, queue, configuration);\n+    }\n+\n+    FederationRouterPolicy policy \u003d policyMap.get(queue);\n+    if (policy \u003d\u003d null) {\n+      // this should never happen, as the to maps are updated together\n+      throw new FederationPolicyException(\"No FederationRouterPolicy found \"\n+          + \"for queue: \" + appSubmissionContext.getQueue() + \" (for \"\n+          + \"application: \" + appSubmissionContext.getApplicationId() + \") \"\n+          + \"and no default specified.\");\n+    }\n+\n+    return policy.getHomeSubcluster(appSubmissionContext);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public SubClusterId getHomeSubcluster(\n      ApplicationSubmissionContext appSubmissionContext) throws YarnException {\n\n    // the maps are concurrent, but we need to protect from reset()\n    // reinitialization mid-execution by creating a new reference local to this\n    // method.\n    Map\u003cString, SubClusterPolicyConfiguration\u003e cachedConfs \u003d globalConfMap;\n    Map\u003cString, FederationRouterPolicy\u003e policyMap \u003d globalPolicyMap;\n\n    if (appSubmissionContext \u003d\u003d null) {\n      throw new FederationPolicyException(\n          \"The ApplicationSubmissionContext \" + \"cannot be null.\");\n    }\n\n    String queue \u003d appSubmissionContext.getQueue();\n\n    // respecting YARN behavior we assume default queue if the queue is not\n    // specified. This also ensures that \"null\" can be used as a key to get the\n    // default behavior.\n    if (queue \u003d\u003d null) {\n      queue \u003d YarnConfiguration.DEFAULT_QUEUE_NAME;\n    }\n\n    // the facade might cache this request, based on its parameterization\n    SubClusterPolicyConfiguration configuration \u003d null;\n\n    try {\n      configuration \u003d federationFacade.getPolicyConfiguration(queue);\n    } catch (YarnException e) {\n      LOG.debug(e);\n    }\n\n    // If there is no policy configured for this queue, fallback to the baseline\n    // policy that is configured either in the store or via XML config (and\n    // cached)\n    if (configuration \u003d\u003d null) {\n      try {\n        LOG.warn(\"There is no policies configured for queue: \" + queue + \" we\"\n            + \" fallback to default policy for: \"\n            + YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n\n        queue \u003d YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY;\n        configuration \u003d federationFacade.getPolicyConfiguration(\n            YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n      } catch (YarnException e) {\n        // the fallback is not configure via store, but via XML, using\n        // previously loaded configuration.\n        configuration \u003d\n            cachedConfs.get(YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);\n      }\n    }\n\n    // if the configuration has changed since last loaded, reinit the policy\n    // based on current configuration\n    if (!cachedConfs.containsKey(queue)\n        || !cachedConfs.get(queue).equals(configuration)) {\n      singlePolicyReinit(policyMap, cachedConfs, queue, configuration);\n    }\n\n    FederationRouterPolicy policy \u003d policyMap.get(queue);\n    if (policy \u003d\u003d null) {\n      // this should never happen, as the to maps are updated together\n      throw new FederationPolicyException(\"No FederationRouterPolicy found \"\n          + \"for queue: \" + appSubmissionContext.getQueue() + \" (for \"\n          + \"application: \" + appSubmissionContext.getApplicationId() + \") \"\n          + \"and no default specified.\");\n    }\n\n    return policy.getHomeSubcluster(appSubmissionContext);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/RouterPolicyFacade.java"
    }
  }
}