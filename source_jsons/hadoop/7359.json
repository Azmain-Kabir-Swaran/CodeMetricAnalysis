{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RollingWindowManager.java",
  "functionName": "snapshot",
  "functionId": "snapshot___time-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/top/window/RollingWindowManager.java",
  "functionStartLine": 189,
  "functionEndLine": 217,
  "numCommitsSeen": 9,
  "timeTaken": 3667,
  "changeHistory": [
    "5bd7b592e5fbe4d448fd127c15d29f3121b8a833",
    "802a7edfaed778daaa471ee96466c6d69b35934c",
    "5e565ce7a7e194f82e935b0e9808744e6bd64287",
    "fe124da5ffc16e4795c3dd5542accd58361e1b08",
    "b61b48999530851da177db2e8998858ffc01f77e",
    "fa7b9248e415c04bb555772f44fadaf8d9f34974",
    "dcb8e24427b02e2f3ff9a12d2eb1eb878e3443bb"
  ],
  "changeHistoryShort": {
    "5bd7b592e5fbe4d448fd127c15d29f3121b8a833": "Ybodychange",
    "802a7edfaed778daaa471ee96466c6d69b35934c": "Ybodychange",
    "5e565ce7a7e194f82e935b0e9808744e6bd64287": "Ybodychange",
    "fe124da5ffc16e4795c3dd5542accd58361e1b08": "Ybodychange",
    "b61b48999530851da177db2e8998858ffc01f77e": "Ybodychange",
    "fa7b9248e415c04bb555772f44fadaf8d9f34974": "Ymultichange(Yreturntypechange,Ybodychange)",
    "dcb8e24427b02e2f3ff9a12d2eb1eb878e3443bb": "Yintroduced"
  },
  "changeHistoryDetails": {
    "5bd7b592e5fbe4d448fd127c15d29f3121b8a833": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12985. Support MetricsSource interface for DecayRpcScheduler Metrics. Contributed by Xiaoyu Yao.\n",
      "commitDate": "20/04/16 11:10 PM",
      "commitName": "5bd7b592e5fbe4d448fd127c15d29f3121b8a833",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "10/02/16 6:49 AM",
      "commitNameOld": "802a7edfaed778daaa471ee96466c6d69b35934c",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 70.64,
      "commitsBetweenForRepo": 438,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   public TopWindow snapshot(long time) {\n     TopWindow window \u003d new TopWindow(windowLenMs);\n     Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n     LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n         metricNames.size(), metricNames);\n     for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n       String metricName \u003d entry.getKey();\n       RollingWindowMap rollingWindows \u003d entry.getValue();\n       TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n       final int size \u003d topN.size();\n       if (size \u003d\u003d 0) {\n         continue;\n       }\n       Op op \u003d new Op(metricName, topN.getTotal());\n       window.addOp(op);\n       // Reverse the users from the TopUsers using a stack, \n       // since we\u0027d like them sorted in descending rather than ascending order\n       Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n       for (int i \u003d 0; i \u003c size; i++) {\n         reverse.push(topN.poll());\n       }\n       for (int i \u003d 0; i \u003c size; i++) {\n         NameValuePair userEntry \u003d reverse.pop();\n-        User user \u003d new User(userEntry.name, userEntry.value);\n+        User user \u003d new User(userEntry.getName(), userEntry.getValue());\n         op.addUser(user);\n       }\n     }\n     return window;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TopWindow snapshot(long time) {\n    TopWindow window \u003d new TopWindow(windowLenMs);\n    Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n    LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n        metricNames.size(), metricNames);\n    for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n      String metricName \u003d entry.getKey();\n      RollingWindowMap rollingWindows \u003d entry.getValue();\n      TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n      final int size \u003d topN.size();\n      if (size \u003d\u003d 0) {\n        continue;\n      }\n      Op op \u003d new Op(metricName, topN.getTotal());\n      window.addOp(op);\n      // Reverse the users from the TopUsers using a stack, \n      // since we\u0027d like them sorted in descending rather than ascending order\n      Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n      for (int i \u003d 0; i \u003c size; i++) {\n        reverse.push(topN.poll());\n      }\n      for (int i \u003d 0; i \u003c size; i++) {\n        NameValuePair userEntry \u003d reverse.pop();\n        User user \u003d new User(userEntry.getName(), userEntry.getValue());\n        op.addUser(user);\n      }\n    }\n    return window;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/top/window/RollingWindowManager.java",
      "extendedDetails": {}
    },
    "802a7edfaed778daaa471ee96466c6d69b35934c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9686. Remove useless boxing/unboxing code. Contributed by Kousuke Saruta.\n",
      "commitDate": "10/02/16 6:49 AM",
      "commitName": "802a7edfaed778daaa471ee96466c6d69b35934c",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "10/02/16 6:43 AM",
      "commitNameOld": "5e565ce7a7e194f82e935b0e9808744e6bd64287",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   public TopWindow snapshot(long time) {\n     TopWindow window \u003d new TopWindow(windowLenMs);\n     Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n     LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n         metricNames.size(), metricNames);\n     for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n       String metricName \u003d entry.getKey();\n       RollingWindowMap rollingWindows \u003d entry.getValue();\n       TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n       final int size \u003d topN.size();\n       if (size \u003d\u003d 0) {\n         continue;\n       }\n       Op op \u003d new Op(metricName, topN.getTotal());\n       window.addOp(op);\n       // Reverse the users from the TopUsers using a stack, \n       // since we\u0027d like them sorted in descending rather than ascending order\n       Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n       for (int i \u003d 0; i \u003c size; i++) {\n         reverse.push(topN.poll());\n       }\n       for (int i \u003d 0; i \u003c size; i++) {\n         NameValuePair userEntry \u003d reverse.pop();\n-        User user \u003d new User(userEntry.name, Long.valueOf(userEntry.value));\n+        User user \u003d new User(userEntry.name, userEntry.value);\n         op.addUser(user);\n       }\n     }\n     return window;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TopWindow snapshot(long time) {\n    TopWindow window \u003d new TopWindow(windowLenMs);\n    Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n    LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n        metricNames.size(), metricNames);\n    for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n      String metricName \u003d entry.getKey();\n      RollingWindowMap rollingWindows \u003d entry.getValue();\n      TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n      final int size \u003d topN.size();\n      if (size \u003d\u003d 0) {\n        continue;\n      }\n      Op op \u003d new Op(metricName, topN.getTotal());\n      window.addOp(op);\n      // Reverse the users from the TopUsers using a stack, \n      // since we\u0027d like them sorted in descending rather than ascending order\n      Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n      for (int i \u003d 0; i \u003c size; i++) {\n        reverse.push(topN.poll());\n      }\n      for (int i \u003d 0; i \u003c size; i++) {\n        NameValuePair userEntry \u003d reverse.pop();\n        User user \u003d new User(userEntry.name, userEntry.value);\n        op.addUser(user);\n      }\n    }\n    return window;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/top/window/RollingWindowManager.java",
      "extendedDetails": {}
    },
    "5e565ce7a7e194f82e935b0e9808744e6bd64287": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9686. Remove useless boxing/unboxing code. Contributed by Kousuke Saruta.\"\n\nThis reverts commit fe124da5ffc16e4795c3dd5542accd58361e1b08.\n",
      "commitDate": "10/02/16 6:43 AM",
      "commitName": "5e565ce7a7e194f82e935b0e9808744e6bd64287",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "06/02/16 2:31 AM",
      "commitNameOld": "fe124da5ffc16e4795c3dd5542accd58361e1b08",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 4.18,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   public TopWindow snapshot(long time) {\n     TopWindow window \u003d new TopWindow(windowLenMs);\n     Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n     LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n         metricNames.size(), metricNames);\n     for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n       String metricName \u003d entry.getKey();\n       RollingWindowMap rollingWindows \u003d entry.getValue();\n       TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n       final int size \u003d topN.size();\n       if (size \u003d\u003d 0) {\n         continue;\n       }\n       Op op \u003d new Op(metricName, topN.getTotal());\n       window.addOp(op);\n       // Reverse the users from the TopUsers using a stack, \n       // since we\u0027d like them sorted in descending rather than ascending order\n       Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n       for (int i \u003d 0; i \u003c size; i++) {\n         reverse.push(topN.poll());\n       }\n       for (int i \u003d 0; i \u003c size; i++) {\n         NameValuePair userEntry \u003d reverse.pop();\n-        User user \u003d new User(userEntry.name, userEntry.value);\n+        User user \u003d new User(userEntry.name, Long.valueOf(userEntry.value));\n         op.addUser(user);\n       }\n     }\n     return window;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TopWindow snapshot(long time) {\n    TopWindow window \u003d new TopWindow(windowLenMs);\n    Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n    LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n        metricNames.size(), metricNames);\n    for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n      String metricName \u003d entry.getKey();\n      RollingWindowMap rollingWindows \u003d entry.getValue();\n      TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n      final int size \u003d topN.size();\n      if (size \u003d\u003d 0) {\n        continue;\n      }\n      Op op \u003d new Op(metricName, topN.getTotal());\n      window.addOp(op);\n      // Reverse the users from the TopUsers using a stack, \n      // since we\u0027d like them sorted in descending rather than ascending order\n      Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n      for (int i \u003d 0; i \u003c size; i++) {\n        reverse.push(topN.poll());\n      }\n      for (int i \u003d 0; i \u003c size; i++) {\n        NameValuePair userEntry \u003d reverse.pop();\n        User user \u003d new User(userEntry.name, Long.valueOf(userEntry.value));\n        op.addUser(user);\n      }\n    }\n    return window;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/top/window/RollingWindowManager.java",
      "extendedDetails": {}
    },
    "fe124da5ffc16e4795c3dd5542accd58361e1b08": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9686. Remove useless boxing/unboxing code. Contributed by Kousuke Saruta.\n",
      "commitDate": "06/02/16 2:31 AM",
      "commitName": "fe124da5ffc16e4795c3dd5542accd58361e1b08",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "06/06/15 6:47 PM",
      "commitNameOld": "b61b48999530851da177db2e8998858ffc01f77e",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 244.36,
      "commitsBetweenForRepo": 1649,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,29 @@\n   public TopWindow snapshot(long time) {\n     TopWindow window \u003d new TopWindow(windowLenMs);\n     Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n     LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n         metricNames.size(), metricNames);\n     for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n       String metricName \u003d entry.getKey();\n       RollingWindowMap rollingWindows \u003d entry.getValue();\n       TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n       final int size \u003d topN.size();\n       if (size \u003d\u003d 0) {\n         continue;\n       }\n       Op op \u003d new Op(metricName, topN.getTotal());\n       window.addOp(op);\n       // Reverse the users from the TopUsers using a stack, \n       // since we\u0027d like them sorted in descending rather than ascending order\n       Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n       for (int i \u003d 0; i \u003c size; i++) {\n         reverse.push(topN.poll());\n       }\n       for (int i \u003d 0; i \u003c size; i++) {\n         NameValuePair userEntry \u003d reverse.pop();\n-        User user \u003d new User(userEntry.name, Long.valueOf(userEntry.value));\n+        User user \u003d new User(userEntry.name, userEntry.value);\n         op.addUser(user);\n       }\n     }\n     return window;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TopWindow snapshot(long time) {\n    TopWindow window \u003d new TopWindow(windowLenMs);\n    Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n    LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n        metricNames.size(), metricNames);\n    for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n      String metricName \u003d entry.getKey();\n      RollingWindowMap rollingWindows \u003d entry.getValue();\n      TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n      final int size \u003d topN.size();\n      if (size \u003d\u003d 0) {\n        continue;\n      }\n      Op op \u003d new Op(metricName, topN.getTotal());\n      window.addOp(op);\n      // Reverse the users from the TopUsers using a stack, \n      // since we\u0027d like them sorted in descending rather than ascending order\n      Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n      for (int i \u003d 0; i \u003c size; i++) {\n        reverse.push(topN.poll());\n      }\n      for (int i \u003d 0; i \u003c size; i++) {\n        NameValuePair userEntry \u003d reverse.pop();\n        User user \u003d new User(userEntry.name, userEntry.value);\n        op.addUser(user);\n      }\n    }\n    return window;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/top/window/RollingWindowManager.java",
      "extendedDetails": {}
    },
    "b61b48999530851da177db2e8998858ffc01f77e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8116. Cleanup uncessary if LOG.isDebugEnabled() from RollingWindowManager. Contributed by Brahma Reddy Battula.\n",
      "commitDate": "06/06/15 6:47 PM",
      "commitName": "b61b48999530851da177db2e8998858ffc01f77e",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "29/03/15 9:32 PM",
      "commitNameOld": "1ed9fb76645ecd195afe0067497dca10a3fb997d",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 68.89,
      "commitsBetweenForRepo": 662,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,29 @@\n   public TopWindow snapshot(long time) {\n     TopWindow window \u003d new TopWindow(windowLenMs);\n-    if (LOG.isDebugEnabled()) {\n-      Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n-      LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n-          metricNames.size(), metricNames);\n-    }\n+    Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n+    LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n+        metricNames.size(), metricNames);\n     for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n       String metricName \u003d entry.getKey();\n       RollingWindowMap rollingWindows \u003d entry.getValue();\n       TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n       final int size \u003d topN.size();\n       if (size \u003d\u003d 0) {\n         continue;\n       }\n       Op op \u003d new Op(metricName, topN.getTotal());\n       window.addOp(op);\n       // Reverse the users from the TopUsers using a stack, \n       // since we\u0027d like them sorted in descending rather than ascending order\n       Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n       for (int i \u003d 0; i \u003c size; i++) {\n         reverse.push(topN.poll());\n       }\n       for (int i \u003d 0; i \u003c size; i++) {\n         NameValuePair userEntry \u003d reverse.pop();\n         User user \u003d new User(userEntry.name, Long.valueOf(userEntry.value));\n         op.addUser(user);\n       }\n     }\n     return window;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public TopWindow snapshot(long time) {\n    TopWindow window \u003d new TopWindow(windowLenMs);\n    Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n    LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n        metricNames.size(), metricNames);\n    for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n      String metricName \u003d entry.getKey();\n      RollingWindowMap rollingWindows \u003d entry.getValue();\n      TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n      final int size \u003d topN.size();\n      if (size \u003d\u003d 0) {\n        continue;\n      }\n      Op op \u003d new Op(metricName, topN.getTotal());\n      window.addOp(op);\n      // Reverse the users from the TopUsers using a stack, \n      // since we\u0027d like them sorted in descending rather than ascending order\n      Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n      for (int i \u003d 0; i \u003c size; i++) {\n        reverse.push(topN.poll());\n      }\n      for (int i \u003d 0; i \u003c size; i++) {\n        NameValuePair userEntry \u003d reverse.pop();\n        User user \u003d new User(userEntry.name, Long.valueOf(userEntry.value));\n        op.addUser(user);\n      }\n    }\n    return window;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/top/window/RollingWindowManager.java",
      "extendedDetails": {}
    },
    "fa7b9248e415c04bb555772f44fadaf8d9f34974": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-7426. Change nntop JMX format to be a JSON blob.\n",
      "commitDate": "12/12/14 5:04 PM",
      "commitName": "fa7b9248e415c04bb555772f44fadaf8d9f34974",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-7426. Change nntop JMX format to be a JSON blob.\n",
          "commitDate": "12/12/14 5:04 PM",
          "commitName": "fa7b9248e415c04bb555772f44fadaf8d9f34974",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "17/11/14 5:33 PM",
          "commitNameOld": "dcb8e24427b02e2f3ff9a12d2eb1eb878e3443bb",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 24.98,
          "commitsBetweenForRepo": 169,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,31 @@\n-  public MetricValueMap snapshot(long time) {\n-    MetricValueMap map \u003d new MetricValueMap();\n-    Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n-    LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n-        metricNames.size(), metricNames);\n-    for (Map.Entry\u003cString,RollingWindowMap\u003e rwEntry: metricMap.entrySet()) {\n-      String metricName \u003d rwEntry.getKey();\n-      RollingWindowMap rollingWindows \u003d rwEntry.getValue();\n-      TopN topN \u003d new TopN(topUsersCnt);\n-      Iterator\u003cMap.Entry\u003cString, RollingWindow\u003e\u003e iterator \u003d\n-          rollingWindows.entrySet().iterator();\n-      while (iterator.hasNext()) {\n-        Map.Entry\u003cString, RollingWindow\u003e entry \u003d iterator.next();\n-        String userName \u003d entry.getKey();\n-        RollingWindow aWindow \u003d entry.getValue();\n-        long windowSum \u003d aWindow.getSum(time);\n-        // do the gc here\n-        if (windowSum \u003d\u003d 0) {\n-          LOG.debug(\"gc window of metric: {} userName: {}\",\n-              metricName, userName);\n-          iterator.remove();\n-          continue;\n-        }\n-        LOG.debug(\"offer window of metric: {} userName: {} sum: {}\",\n-            metricName, userName, windowSum);\n-        topN.offer(new NameValuePair(userName, windowSum));\n-      }\n-      int n \u003d topN.size();\n-      LOG.info(\"topN size for command \" + metricName + \" is: \" + n);\n-      if (n \u003d\u003d 0) {\n+  public TopWindow snapshot(long time) {\n+    TopWindow window \u003d new TopWindow(windowLenMs);\n+    if (LOG.isDebugEnabled()) {\n+      Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n+      LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n+          metricNames.size(), metricNames);\n+    }\n+    for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n+      String metricName \u003d entry.getKey();\n+      RollingWindowMap rollingWindows \u003d entry.getValue();\n+      TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n+      final int size \u003d topN.size();\n+      if (size \u003d\u003d 0) {\n         continue;\n       }\n-      String allMetricName \u003d\n-          createMetricName(metricName, TopConf.ALL_USERS);\n-      map.put(allMetricName, Long.valueOf(topN.total));\n-      for (int i \u003d 0; i \u003c n; i++) {\n-        NameValuePair userEntry \u003d topN.poll();\n-        String userMetricName \u003d\n-            createMetricName(metricName, userEntry.name);\n-        map.put(userMetricName, Long.valueOf(userEntry.value));\n+      Op op \u003d new Op(metricName, topN.getTotal());\n+      window.addOp(op);\n+      // Reverse the users from the TopUsers using a stack, \n+      // since we\u0027d like them sorted in descending rather than ascending order\n+      Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n+      for (int i \u003d 0; i \u003c size; i++) {\n+        reverse.push(topN.poll());\n+      }\n+      for (int i \u003d 0; i \u003c size; i++) {\n+        NameValuePair userEntry \u003d reverse.pop();\n+        User user \u003d new User(userEntry.name, Long.valueOf(userEntry.value));\n+        op.addUser(user);\n       }\n     }\n-    return map;\n+    return window;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public TopWindow snapshot(long time) {\n    TopWindow window \u003d new TopWindow(windowLenMs);\n    if (LOG.isDebugEnabled()) {\n      Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n      LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n          metricNames.size(), metricNames);\n    }\n    for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n      String metricName \u003d entry.getKey();\n      RollingWindowMap rollingWindows \u003d entry.getValue();\n      TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n      final int size \u003d topN.size();\n      if (size \u003d\u003d 0) {\n        continue;\n      }\n      Op op \u003d new Op(metricName, topN.getTotal());\n      window.addOp(op);\n      // Reverse the users from the TopUsers using a stack, \n      // since we\u0027d like them sorted in descending rather than ascending order\n      Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n      for (int i \u003d 0; i \u003c size; i++) {\n        reverse.push(topN.poll());\n      }\n      for (int i \u003d 0; i \u003c size; i++) {\n        NameValuePair userEntry \u003d reverse.pop();\n        User user \u003d new User(userEntry.name, Long.valueOf(userEntry.value));\n        op.addUser(user);\n      }\n    }\n    return window;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/top/window/RollingWindowManager.java",
          "extendedDetails": {
            "oldValue": "MetricValueMap",
            "newValue": "TopWindow"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7426. Change nntop JMX format to be a JSON blob.\n",
          "commitDate": "12/12/14 5:04 PM",
          "commitName": "fa7b9248e415c04bb555772f44fadaf8d9f34974",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "17/11/14 5:33 PM",
          "commitNameOld": "dcb8e24427b02e2f3ff9a12d2eb1eb878e3443bb",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 24.98,
          "commitsBetweenForRepo": 169,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,31 @@\n-  public MetricValueMap snapshot(long time) {\n-    MetricValueMap map \u003d new MetricValueMap();\n-    Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n-    LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n-        metricNames.size(), metricNames);\n-    for (Map.Entry\u003cString,RollingWindowMap\u003e rwEntry: metricMap.entrySet()) {\n-      String metricName \u003d rwEntry.getKey();\n-      RollingWindowMap rollingWindows \u003d rwEntry.getValue();\n-      TopN topN \u003d new TopN(topUsersCnt);\n-      Iterator\u003cMap.Entry\u003cString, RollingWindow\u003e\u003e iterator \u003d\n-          rollingWindows.entrySet().iterator();\n-      while (iterator.hasNext()) {\n-        Map.Entry\u003cString, RollingWindow\u003e entry \u003d iterator.next();\n-        String userName \u003d entry.getKey();\n-        RollingWindow aWindow \u003d entry.getValue();\n-        long windowSum \u003d aWindow.getSum(time);\n-        // do the gc here\n-        if (windowSum \u003d\u003d 0) {\n-          LOG.debug(\"gc window of metric: {} userName: {}\",\n-              metricName, userName);\n-          iterator.remove();\n-          continue;\n-        }\n-        LOG.debug(\"offer window of metric: {} userName: {} sum: {}\",\n-            metricName, userName, windowSum);\n-        topN.offer(new NameValuePair(userName, windowSum));\n-      }\n-      int n \u003d topN.size();\n-      LOG.info(\"topN size for command \" + metricName + \" is: \" + n);\n-      if (n \u003d\u003d 0) {\n+  public TopWindow snapshot(long time) {\n+    TopWindow window \u003d new TopWindow(windowLenMs);\n+    if (LOG.isDebugEnabled()) {\n+      Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n+      LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n+          metricNames.size(), metricNames);\n+    }\n+    for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n+      String metricName \u003d entry.getKey();\n+      RollingWindowMap rollingWindows \u003d entry.getValue();\n+      TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n+      final int size \u003d topN.size();\n+      if (size \u003d\u003d 0) {\n         continue;\n       }\n-      String allMetricName \u003d\n-          createMetricName(metricName, TopConf.ALL_USERS);\n-      map.put(allMetricName, Long.valueOf(topN.total));\n-      for (int i \u003d 0; i \u003c n; i++) {\n-        NameValuePair userEntry \u003d topN.poll();\n-        String userMetricName \u003d\n-            createMetricName(metricName, userEntry.name);\n-        map.put(userMetricName, Long.valueOf(userEntry.value));\n+      Op op \u003d new Op(metricName, topN.getTotal());\n+      window.addOp(op);\n+      // Reverse the users from the TopUsers using a stack, \n+      // since we\u0027d like them sorted in descending rather than ascending order\n+      Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n+      for (int i \u003d 0; i \u003c size; i++) {\n+        reverse.push(topN.poll());\n+      }\n+      for (int i \u003d 0; i \u003c size; i++) {\n+        NameValuePair userEntry \u003d reverse.pop();\n+        User user \u003d new User(userEntry.name, Long.valueOf(userEntry.value));\n+        op.addUser(user);\n       }\n     }\n-    return map;\n+    return window;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public TopWindow snapshot(long time) {\n    TopWindow window \u003d new TopWindow(windowLenMs);\n    if (LOG.isDebugEnabled()) {\n      Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n      LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n          metricNames.size(), metricNames);\n    }\n    for (Map.Entry\u003cString, RollingWindowMap\u003e entry : metricMap.entrySet()) {\n      String metricName \u003d entry.getKey();\n      RollingWindowMap rollingWindows \u003d entry.getValue();\n      TopN topN \u003d getTopUsersForMetric(time, metricName, rollingWindows);\n      final int size \u003d topN.size();\n      if (size \u003d\u003d 0) {\n        continue;\n      }\n      Op op \u003d new Op(metricName, topN.getTotal());\n      window.addOp(op);\n      // Reverse the users from the TopUsers using a stack, \n      // since we\u0027d like them sorted in descending rather than ascending order\n      Stack\u003cNameValuePair\u003e reverse \u003d new Stack\u003cNameValuePair\u003e();\n      for (int i \u003d 0; i \u003c size; i++) {\n        reverse.push(topN.poll());\n      }\n      for (int i \u003d 0; i \u003c size; i++) {\n        NameValuePair userEntry \u003d reverse.pop();\n        User user \u003d new User(userEntry.name, Long.valueOf(userEntry.value));\n        op.addUser(user);\n      }\n    }\n    return window;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/top/window/RollingWindowManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "dcb8e24427b02e2f3ff9a12d2eb1eb878e3443bb": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-6982. nntop: topÂ­-like tool for name node users. (Maysam Yabandeh via wang)\n",
      "commitDate": "17/11/14 5:33 PM",
      "commitName": "dcb8e24427b02e2f3ff9a12d2eb1eb878e3443bb",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,44 @@\n+  public MetricValueMap snapshot(long time) {\n+    MetricValueMap map \u003d new MetricValueMap();\n+    Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n+    LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n+        metricNames.size(), metricNames);\n+    for (Map.Entry\u003cString,RollingWindowMap\u003e rwEntry: metricMap.entrySet()) {\n+      String metricName \u003d rwEntry.getKey();\n+      RollingWindowMap rollingWindows \u003d rwEntry.getValue();\n+      TopN topN \u003d new TopN(topUsersCnt);\n+      Iterator\u003cMap.Entry\u003cString, RollingWindow\u003e\u003e iterator \u003d\n+          rollingWindows.entrySet().iterator();\n+      while (iterator.hasNext()) {\n+        Map.Entry\u003cString, RollingWindow\u003e entry \u003d iterator.next();\n+        String userName \u003d entry.getKey();\n+        RollingWindow aWindow \u003d entry.getValue();\n+        long windowSum \u003d aWindow.getSum(time);\n+        // do the gc here\n+        if (windowSum \u003d\u003d 0) {\n+          LOG.debug(\"gc window of metric: {} userName: {}\",\n+              metricName, userName);\n+          iterator.remove();\n+          continue;\n+        }\n+        LOG.debug(\"offer window of metric: {} userName: {} sum: {}\",\n+            metricName, userName, windowSum);\n+        topN.offer(new NameValuePair(userName, windowSum));\n+      }\n+      int n \u003d topN.size();\n+      LOG.info(\"topN size for command \" + metricName + \" is: \" + n);\n+      if (n \u003d\u003d 0) {\n+        continue;\n+      }\n+      String allMetricName \u003d\n+          createMetricName(metricName, TopConf.ALL_USERS);\n+      map.put(allMetricName, Long.valueOf(topN.total));\n+      for (int i \u003d 0; i \u003c n; i++) {\n+        NameValuePair userEntry \u003d topN.poll();\n+        String userMetricName \u003d\n+            createMetricName(metricName, userEntry.name);\n+        map.put(userMetricName, Long.valueOf(userEntry.value));\n+      }\n+    }\n+    return map;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public MetricValueMap snapshot(long time) {\n    MetricValueMap map \u003d new MetricValueMap();\n    Set\u003cString\u003e metricNames \u003d metricMap.keySet();\n    LOG.debug(\"iterating in reported metrics, size\u003d{} values\u003d{}\",\n        metricNames.size(), metricNames);\n    for (Map.Entry\u003cString,RollingWindowMap\u003e rwEntry: metricMap.entrySet()) {\n      String metricName \u003d rwEntry.getKey();\n      RollingWindowMap rollingWindows \u003d rwEntry.getValue();\n      TopN topN \u003d new TopN(topUsersCnt);\n      Iterator\u003cMap.Entry\u003cString, RollingWindow\u003e\u003e iterator \u003d\n          rollingWindows.entrySet().iterator();\n      while (iterator.hasNext()) {\n        Map.Entry\u003cString, RollingWindow\u003e entry \u003d iterator.next();\n        String userName \u003d entry.getKey();\n        RollingWindow aWindow \u003d entry.getValue();\n        long windowSum \u003d aWindow.getSum(time);\n        // do the gc here\n        if (windowSum \u003d\u003d 0) {\n          LOG.debug(\"gc window of metric: {} userName: {}\",\n              metricName, userName);\n          iterator.remove();\n          continue;\n        }\n        LOG.debug(\"offer window of metric: {} userName: {} sum: {}\",\n            metricName, userName, windowSum);\n        topN.offer(new NameValuePair(userName, windowSum));\n      }\n      int n \u003d topN.size();\n      LOG.info(\"topN size for command \" + metricName + \" is: \" + n);\n      if (n \u003d\u003d 0) {\n        continue;\n      }\n      String allMetricName \u003d\n          createMetricName(metricName, TopConf.ALL_USERS);\n      map.put(allMetricName, Long.valueOf(topN.total));\n      for (int i \u003d 0; i \u003c n; i++) {\n        NameValuePair userEntry \u003d topN.poll();\n        String userMetricName \u003d\n            createMetricName(metricName, userEntry.name);\n        map.put(userMetricName, Long.valueOf(userEntry.value));\n      }\n    }\n    return map;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/top/window/RollingWindowManager.java"
    }
  }
}