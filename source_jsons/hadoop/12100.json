{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DataNode.java",
  "functionName": "parseChangedVolumes",
  "functionId": "parseChangedVolumes___newVolumes-String",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java",
  "functionStartLine": 678,
  "functionEndLine": 760,
  "numCommitsSeen": 358,
  "timeTaken": 2164,
  "changeHistory": [
    "dfcb331ba3516264398121c9f23af3a79c0509cc"
  ],
  "changeHistoryShort": {
    "dfcb331ba3516264398121c9f23af3a79c0509cc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "dfcb331ba3516264398121c9f23af3a79c0509cc": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-13076: [SPS]: Addendum. Resolve conflicts after rebasing branch to trunk. Contributed by Rakesh R.\n",
      "commitDate": "12/08/18 3:06 AM",
      "commitName": "dfcb331ba3516264398121c9f23af3a79c0509cc",
      "commitAuthor": "Rakesh Radhakrishnan",
      "diff": "@@ -0,0 +1,83 @@\n+  ChangedVolumes parseChangedVolumes(String newVolumes) throws IOException {\n+    Configuration conf \u003d new Configuration();\n+    conf.set(DFS_DATANODE_DATA_DIR_KEY, newVolumes);\n+    List\u003cStorageLocation\u003e newStorageLocations \u003d getStorageLocations(conf);\n+\n+    if (newStorageLocations.isEmpty()) {\n+      throw new IOException(\"No directory is specified.\");\n+    }\n+\n+    // Use the existing storage locations from the current conf\n+    // to detect new storage additions or removals.\n+    Map\u003cString, StorageLocation\u003e existingStorageLocations \u003d new HashMap\u003c\u003e();\n+    for (StorageLocation loc : getStorageLocations(getConf())) {\n+      existingStorageLocations.put(loc.getNormalizedUri().toString(), loc);\n+    }\n+\n+    ChangedVolumes results \u003d new ChangedVolumes();\n+    results.newLocations.addAll(newStorageLocations);\n+\n+    for (Iterator\u003cStorage.StorageDirectory\u003e it \u003d storage.dirIterator();\n+         it.hasNext(); ) {\n+      Storage.StorageDirectory dir \u003d it.next();\n+      boolean found \u003d false;\n+      for (Iterator\u003cStorageLocation\u003e newLocationItr \u003d\n+           results.newLocations.iterator(); newLocationItr.hasNext();) {\n+        StorageLocation newLocation \u003d newLocationItr.next();\n+        if (newLocation.matchesStorageDirectory(dir)) {\n+          StorageLocation oldLocation \u003d existingStorageLocations.get(\n+              newLocation.getNormalizedUri().toString());\n+          if (oldLocation !\u003d null \u0026\u0026\n+              oldLocation.getStorageType() !\u003d newLocation.getStorageType()) {\n+            throw new IOException(\"Changing storage type is not allowed.\");\n+          }\n+          // Update the unchanged locations as this location\n+          // from the new conf is really not a new one.\n+          newLocationItr.remove();\n+          results.unchangedLocations.add(newLocation);\n+          found \u003d true;\n+          break;\n+        }\n+      }\n+\n+      // New conf doesn\u0027t have the storage location which available in\n+      // the current storage locations. Add to the deactivateLocations list.\n+      if (!found) {\n+        LOG.info(\"Deactivation request received for active volume: {}\",\n+            dir.getRoot());\n+        results.deactivateLocations.add(\n+            StorageLocation.parse(dir.getRoot().toString()));\n+      }\n+    }\n+\n+    // Use the failed storage locations from the current conf\n+    // to detect removals in the new conf.\n+    if (getFSDataset().getNumFailedVolumes() \u003e 0) {\n+      for (String failedStorageLocation : getFSDataset()\n+          .getVolumeFailureSummary().getFailedStorageLocations()) {\n+        boolean found \u003d false;\n+        for (Iterator\u003cStorageLocation\u003e newLocationItr \u003d\n+             results.newLocations.iterator(); newLocationItr.hasNext();) {\n+          StorageLocation newLocation \u003d newLocationItr.next();\n+          if (newLocation.getNormalizedUri().toString().equals(\n+              failedStorageLocation)) {\n+            // The failed storage is being re-added. DataNode#refreshVolumes()\n+            // will take care of re-assessing it.\n+            found \u003d true;\n+            break;\n+          }\n+        }\n+\n+        // New conf doesn\u0027t have this failed storage location.\n+        // Add to the deactivate locations list.\n+        if (!found) {\n+          LOG.info(\"Deactivation request received for failed volume: {}\",\n+              failedStorageLocation);\n+          results.deactivateLocations.add(StorageLocation.parse(\n+              failedStorageLocation));\n+        }\n+      }\n+    }\n+\n+    return results;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  ChangedVolumes parseChangedVolumes(String newVolumes) throws IOException {\n    Configuration conf \u003d new Configuration();\n    conf.set(DFS_DATANODE_DATA_DIR_KEY, newVolumes);\n    List\u003cStorageLocation\u003e newStorageLocations \u003d getStorageLocations(conf);\n\n    if (newStorageLocations.isEmpty()) {\n      throw new IOException(\"No directory is specified.\");\n    }\n\n    // Use the existing storage locations from the current conf\n    // to detect new storage additions or removals.\n    Map\u003cString, StorageLocation\u003e existingStorageLocations \u003d new HashMap\u003c\u003e();\n    for (StorageLocation loc : getStorageLocations(getConf())) {\n      existingStorageLocations.put(loc.getNormalizedUri().toString(), loc);\n    }\n\n    ChangedVolumes results \u003d new ChangedVolumes();\n    results.newLocations.addAll(newStorageLocations);\n\n    for (Iterator\u003cStorage.StorageDirectory\u003e it \u003d storage.dirIterator();\n         it.hasNext(); ) {\n      Storage.StorageDirectory dir \u003d it.next();\n      boolean found \u003d false;\n      for (Iterator\u003cStorageLocation\u003e newLocationItr \u003d\n           results.newLocations.iterator(); newLocationItr.hasNext();) {\n        StorageLocation newLocation \u003d newLocationItr.next();\n        if (newLocation.matchesStorageDirectory(dir)) {\n          StorageLocation oldLocation \u003d existingStorageLocations.get(\n              newLocation.getNormalizedUri().toString());\n          if (oldLocation !\u003d null \u0026\u0026\n              oldLocation.getStorageType() !\u003d newLocation.getStorageType()) {\n            throw new IOException(\"Changing storage type is not allowed.\");\n          }\n          // Update the unchanged locations as this location\n          // from the new conf is really not a new one.\n          newLocationItr.remove();\n          results.unchangedLocations.add(newLocation);\n          found \u003d true;\n          break;\n        }\n      }\n\n      // New conf doesn\u0027t have the storage location which available in\n      // the current storage locations. Add to the deactivateLocations list.\n      if (!found) {\n        LOG.info(\"Deactivation request received for active volume: {}\",\n            dir.getRoot());\n        results.deactivateLocations.add(\n            StorageLocation.parse(dir.getRoot().toString()));\n      }\n    }\n\n    // Use the failed storage locations from the current conf\n    // to detect removals in the new conf.\n    if (getFSDataset().getNumFailedVolumes() \u003e 0) {\n      for (String failedStorageLocation : getFSDataset()\n          .getVolumeFailureSummary().getFailedStorageLocations()) {\n        boolean found \u003d false;\n        for (Iterator\u003cStorageLocation\u003e newLocationItr \u003d\n             results.newLocations.iterator(); newLocationItr.hasNext();) {\n          StorageLocation newLocation \u003d newLocationItr.next();\n          if (newLocation.getNormalizedUri().toString().equals(\n              failedStorageLocation)) {\n            // The failed storage is being re-added. DataNode#refreshVolumes()\n            // will take care of re-assessing it.\n            found \u003d true;\n            break;\n          }\n        }\n\n        // New conf doesn\u0027t have this failed storage location.\n        // Add to the deactivate locations list.\n        if (!found) {\n          LOG.info(\"Deactivation request received for failed volume: {}\",\n              failedStorageLocation);\n          results.deactivateLocations.add(StorageLocation.parse(\n              failedStorageLocation));\n        }\n      }\n    }\n\n    return results;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/DataNode.java"
    }
  }
}