{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "JavaKeyStoreProvider.java",
  "functionName": "createKey",
  "functionId": "createKey___name-String__material-byte[]__options-Options",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
  "functionStartLine": 434,
  "functionEndLine": 460,
  "numCommitsSeen": 26,
  "timeTaken": 2230,
  "changeHistory": [
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
    "9cedad11d8d2197a54732667a15344983de5c437",
    "946456c6d88780abe0251b098dd771e9e1e93ab3",
    "48d62fad80aaa13ee1a26fca14437722ed46da25",
    "7b5295513dce9768083ae53282013e31d74573c6",
    "38e2322d84d54896eac23afec0a1434629b8c8b2",
    "350ab4d2466117124c8563114cdb9eb83fa37a02",
    "98a98ea0c57d01b875b820f53d43dbf885d07711",
    "77306291643838ed7b57b99d6497553314a525f2"
  ],
  "changeHistoryShort": {
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": "Ybodychange",
    "9cedad11d8d2197a54732667a15344983de5c437": "Ybodychange",
    "946456c6d88780abe0251b098dd771e9e1e93ab3": "Ybodychange",
    "48d62fad80aaa13ee1a26fca14437722ed46da25": "Ybodychange",
    "7b5295513dce9768083ae53282013e31d74573c6": "Ybodychange",
    "38e2322d84d54896eac23afec0a1434629b8c8b2": "Ybodychange",
    "350ab4d2466117124c8563114cdb9eb83fa37a02": "Ybodychange",
    "98a98ea0c57d01b875b820f53d43dbf885d07711": "Ybodychange",
    "77306291643838ed7b57b99d6497553314a525f2": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d1c6accb6f87b08975175580e15f1ff1fe29ab04": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "02/03/15 9:17 PM",
      "commitName": "d1c6accb6f87b08975175580e15f1ff1fe29ab04",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "24/02/15 7:32 AM",
      "commitNameOld": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n   public KeyVersion createKey(String name, byte[] material,\n                                Options options) throws IOException {\n-    Preconditions.checkArgument(name.equals(name.toLowerCase()),\n+    Preconditions.checkArgument(name.equals(StringUtils.toLowerCase(name)),\n         \"Uppercase key names are unsupported: %s\", name);\n     writeLock.lock();\n     try {\n       try {\n         if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n           throw new IOException(\"Key \" + name + \" already exists in \" + this);\n         }\n       } catch (KeyStoreException e) {\n         throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n             e);\n       }\n       Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n           options.getDescription(), options.getAttributes(), new Date(), 1);\n       if (options.getBitLength() !\u003d 8 * material.length) {\n         throw new IOException(\"Wrong key length. Required \" +\n             options.getBitLength() + \", but got \" + (8 * material.length));\n       }\n       cache.put(name, meta);\n       String versionName \u003d buildVersionName(name, 0);\n       return innerSetKeyVersion(name, versionName, material, meta.getCipher());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public KeyVersion createKey(String name, byte[] material,\n                               Options options) throws IOException {\n    Preconditions.checkArgument(name.equals(StringUtils.toLowerCase(name)),\n        \"Uppercase key names are unsupported: %s\", name);\n    writeLock.lock();\n    try {\n      try {\n        if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n          throw new IOException(\"Key \" + name + \" already exists in \" + this);\n        }\n      } catch (KeyStoreException e) {\n        throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n            e);\n      }\n      Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n          options.getDescription(), options.getAttributes(), new Date(), 1);\n      if (options.getBitLength() !\u003d 8 * material.length) {\n        throw new IOException(\"Wrong key length. Required \" +\n            options.getBitLength() + \", but got \" + (8 * material.length));\n      }\n      cache.put(name, meta);\n      String versionName \u003d buildVersionName(name, 0);\n      return innerSetKeyVersion(name, versionName, material, meta.getCipher());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "9cedad11d8d2197a54732667a15344983de5c437": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\"\n\nThis reverts commit 946456c6d88780abe0251b098dd771e9e1e93ab3.\n\nConflicts:\n\thadoop-common-project/hadoop-common/CHANGES.txt\n\thadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/QuotaByStorageTypeEntry.java\n",
      "commitDate": "24/02/15 7:32 AM",
      "commitName": "9cedad11d8d2197a54732667a15344983de5c437",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "18/02/15 8:06 PM",
      "commitNameOld": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 5.48,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n   public KeyVersion createKey(String name, byte[] material,\n                                Options options) throws IOException {\n-    Preconditions.checkArgument(name.equals(name.toLowerCase(Locale.ENGLISH)),\n+    Preconditions.checkArgument(name.equals(name.toLowerCase()),\n         \"Uppercase key names are unsupported: %s\", name);\n     writeLock.lock();\n     try {\n       try {\n         if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n           throw new IOException(\"Key \" + name + \" already exists in \" + this);\n         }\n       } catch (KeyStoreException e) {\n         throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n             e);\n       }\n       Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n           options.getDescription(), options.getAttributes(), new Date(), 1);\n       if (options.getBitLength() !\u003d 8 * material.length) {\n         throw new IOException(\"Wrong key length. Required \" +\n             options.getBitLength() + \", but got \" + (8 * material.length));\n       }\n       cache.put(name, meta);\n       String versionName \u003d buildVersionName(name, 0);\n       return innerSetKeyVersion(name, versionName, material, meta.getCipher());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public KeyVersion createKey(String name, byte[] material,\n                               Options options) throws IOException {\n    Preconditions.checkArgument(name.equals(name.toLowerCase()),\n        \"Uppercase key names are unsupported: %s\", name);\n    writeLock.lock();\n    try {\n      try {\n        if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n          throw new IOException(\"Key \" + name + \" already exists in \" + this);\n        }\n      } catch (KeyStoreException e) {\n        throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n            e);\n      }\n      Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n          options.getDescription(), options.getAttributes(), new Date(), 1);\n      if (options.getBitLength() !\u003d 8 * material.length) {\n        throw new IOException(\"Wrong key length. Required \" +\n            options.getBitLength() + \", but got \" + (8 * material.length));\n      }\n      cache.put(name, meta);\n      String versionName \u003d buildVersionName(name, 0);\n      return innerSetKeyVersion(name, versionName, material, meta.getCipher());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "946456c6d88780abe0251b098dd771e9e1e93ab3": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11602. Fix toUpperCase/toLowerCase to use Locale.ENGLISH. (ozawa)\n",
      "commitDate": "18/02/15 8:06 PM",
      "commitName": "946456c6d88780abe0251b098dd771e9e1e93ab3",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "14/01/15 5:42 PM",
      "commitNameOld": "a5a033c7ca130528f8c509b035fc090ad4eb981a",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 35.1,
      "commitsBetweenForRepo": 350,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n   public KeyVersion createKey(String name, byte[] material,\n                                Options options) throws IOException {\n-    Preconditions.checkArgument(name.equals(name.toLowerCase()),\n+    Preconditions.checkArgument(name.equals(name.toLowerCase(Locale.ENGLISH)),\n         \"Uppercase key names are unsupported: %s\", name);\n     writeLock.lock();\n     try {\n       try {\n         if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n           throw new IOException(\"Key \" + name + \" already exists in \" + this);\n         }\n       } catch (KeyStoreException e) {\n         throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n             e);\n       }\n       Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n           options.getDescription(), options.getAttributes(), new Date(), 1);\n       if (options.getBitLength() !\u003d 8 * material.length) {\n         throw new IOException(\"Wrong key length. Required \" +\n             options.getBitLength() + \", but got \" + (8 * material.length));\n       }\n       cache.put(name, meta);\n       String versionName \u003d buildVersionName(name, 0);\n       return innerSetKeyVersion(name, versionName, material, meta.getCipher());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public KeyVersion createKey(String name, byte[] material,\n                               Options options) throws IOException {\n    Preconditions.checkArgument(name.equals(name.toLowerCase(Locale.ENGLISH)),\n        \"Uppercase key names are unsupported: %s\", name);\n    writeLock.lock();\n    try {\n      try {\n        if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n          throw new IOException(\"Key \" + name + \" already exists in \" + this);\n        }\n      } catch (KeyStoreException e) {\n        throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n            e);\n      }\n      Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n          options.getDescription(), options.getAttributes(), new Date(), 1);\n      if (options.getBitLength() !\u003d 8 * material.length) {\n        throw new IOException(\"Wrong key length. Required \" +\n            options.getBitLength() + \", but got \" + (8 * material.length));\n      }\n      cache.put(name, meta);\n      String versionName \u003d buildVersionName(name, 0);\n      return innerSetKeyVersion(name, versionName, material, meta.getCipher());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "48d62fad80aaa13ee1a26fca14437722ed46da25": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11311. Restrict uppercase key names from being created with JCEKS.\n",
      "commitDate": "17/11/14 1:59 PM",
      "commitName": "48d62fad80aaa13ee1a26fca14437722ed46da25",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "09/10/14 7:36 AM",
      "commitNameOld": "8d7c54967d5a08cdff75a782998ee89e7537b5c4",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 39.31,
      "commitsBetweenForRepo": 370,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,27 @@\n   public KeyVersion createKey(String name, byte[] material,\n                                Options options) throws IOException {\n+    Preconditions.checkArgument(name.equals(name.toLowerCase()),\n+        \"Uppercase key names are unsupported: %s\", name);\n     writeLock.lock();\n     try {\n       try {\n         if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n           throw new IOException(\"Key \" + name + \" already exists in \" + this);\n         }\n       } catch (KeyStoreException e) {\n         throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n             e);\n       }\n       Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n           options.getDescription(), options.getAttributes(), new Date(), 1);\n       if (options.getBitLength() !\u003d 8 * material.length) {\n         throw new IOException(\"Wrong key length. Required \" +\n             options.getBitLength() + \", but got \" + (8 * material.length));\n       }\n       cache.put(name, meta);\n       String versionName \u003d buildVersionName(name, 0);\n       return innerSetKeyVersion(name, versionName, material, meta.getCipher());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public KeyVersion createKey(String name, byte[] material,\n                               Options options) throws IOException {\n    Preconditions.checkArgument(name.equals(name.toLowerCase()),\n        \"Uppercase key names are unsupported: %s\", name);\n    writeLock.lock();\n    try {\n      try {\n        if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n          throw new IOException(\"Key \" + name + \" already exists in \" + this);\n        }\n      } catch (KeyStoreException e) {\n        throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n            e);\n      }\n      Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n          options.getDescription(), options.getAttributes(), new Date(), 1);\n      if (options.getBitLength() !\u003d 8 * material.length) {\n        throw new IOException(\"Wrong key length. Required \" +\n            options.getBitLength() + \", but got \" + (8 * material.length));\n      }\n      cache.put(name, meta);\n      String versionName \u003d buildVersionName(name, 0);\n      return innerSetKeyVersion(name, versionName, material, meta.getCipher());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "7b5295513dce9768083ae53282013e31d74573c6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10757. KeyProvider KeyVersion should provide the key name. (asuresh via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1607896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/07/14 10:31 AM",
      "commitName": "7b5295513dce9768083ae53282013e31d74573c6",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "19/06/14 3:18 PM",
      "commitNameOld": "38e2322d84d54896eac23afec0a1434629b8c8b2",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 14.8,
      "commitsBetweenForRepo": 101,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n   public KeyVersion createKey(String name, byte[] material,\n                                Options options) throws IOException {\n     writeLock.lock();\n     try {\n       try {\n         if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n           throw new IOException(\"Key \" + name + \" already exists in \" + this);\n         }\n       } catch (KeyStoreException e) {\n         throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n             e);\n       }\n       Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n           options.getDescription(), options.getAttributes(), new Date(), 1);\n       if (options.getBitLength() !\u003d 8 * material.length) {\n         throw new IOException(\"Wrong key length. Required \" +\n             options.getBitLength() + \", but got \" + (8 * material.length));\n       }\n       cache.put(name, meta);\n       String versionName \u003d buildVersionName(name, 0);\n-      return innerSetKeyVersion(versionName, material, meta.getCipher());\n+      return innerSetKeyVersion(name, versionName, material, meta.getCipher());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public KeyVersion createKey(String name, byte[] material,\n                               Options options) throws IOException {\n    writeLock.lock();\n    try {\n      try {\n        if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n          throw new IOException(\"Key \" + name + \" already exists in \" + this);\n        }\n      } catch (KeyStoreException e) {\n        throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n            e);\n      }\n      Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n          options.getDescription(), options.getAttributes(), new Date(), 1);\n      if (options.getBitLength() !\u003d 8 * material.length) {\n        throw new IOException(\"Wrong key length. Required \" +\n            options.getBitLength() + \", but got \" + (8 * material.length));\n      }\n      cache.put(name, meta);\n      String versionName \u003d buildVersionName(name, 0);\n      return innerSetKeyVersion(name, versionName, material, meta.getCipher());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "38e2322d84d54896eac23afec0a1434629b8c8b2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10696. Add optional attributes to KeyProvider Options and Metadata. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1604041 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/06/14 3:18 PM",
      "commitName": "38e2322d84d54896eac23afec0a1434629b8c8b2",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "18/06/14 8:45 AM",
      "commitNameOld": "c79728478caadd8374bce2bc3f466db1da1e3ad1",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 1.27,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n   public KeyVersion createKey(String name, byte[] material,\n                                Options options) throws IOException {\n     writeLock.lock();\n     try {\n       try {\n         if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n           throw new IOException(\"Key \" + name + \" already exists in \" + this);\n         }\n       } catch (KeyStoreException e) {\n         throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n             e);\n       }\n       Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n-          options.getDescription(), new Date(), 1);\n+          options.getDescription(), options.getAttributes(), new Date(), 1);\n       if (options.getBitLength() !\u003d 8 * material.length) {\n         throw new IOException(\"Wrong key length. Required \" +\n             options.getBitLength() + \", but got \" + (8 * material.length));\n       }\n       cache.put(name, meta);\n       String versionName \u003d buildVersionName(name, 0);\n       return innerSetKeyVersion(versionName, material, meta.getCipher());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public KeyVersion createKey(String name, byte[] material,\n                               Options options) throws IOException {\n    writeLock.lock();\n    try {\n      try {\n        if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n          throw new IOException(\"Key \" + name + \" already exists in \" + this);\n        }\n      } catch (KeyStoreException e) {\n        throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n            e);\n      }\n      Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n          options.getDescription(), options.getAttributes(), new Date(), 1);\n      if (options.getBitLength() !\u003d 8 * material.length) {\n        throw new IOException(\"Wrong key length. Required \" +\n            options.getBitLength() + \", but got \" + (8 * material.length));\n      }\n      cache.put(name, meta);\n      String versionName \u003d buildVersionName(name, 0);\n      return innerSetKeyVersion(versionName, material, meta.getCipher());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "350ab4d2466117124c8563114cdb9eb83fa37a02": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10430. KeyProvider Metadata should have an optional description, there should be a method to retrieve the metadata from all keys. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1586730 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/04/14 11:02 AM",
      "commitName": "350ab4d2466117124c8563114cdb9eb83fa37a02",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "09/04/14 10:09 PM",
      "commitNameOld": "b4f0259f13716180eb249fdc5d591fc86709f105",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 1.54,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n   public KeyVersion createKey(String name, byte[] material,\n                                Options options) throws IOException {\n     writeLock.lock();\n     try {\n       try {\n         if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n           throw new IOException(\"Key \" + name + \" already exists in \" + this);\n         }\n       } catch (KeyStoreException e) {\n         throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n             e);\n       }\n       Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n-          new Date(), 1);\n+          options.getDescription(), new Date(), 1);\n       if (options.getBitLength() !\u003d 8 * material.length) {\n         throw new IOException(\"Wrong key length. Required \" +\n             options.getBitLength() + \", but got \" + (8 * material.length));\n       }\n       cache.put(name, meta);\n       String versionName \u003d buildVersionName(name, 0);\n       return innerSetKeyVersion(versionName, material, meta.getCipher());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public KeyVersion createKey(String name, byte[] material,\n                               Options options) throws IOException {\n    writeLock.lock();\n    try {\n      try {\n        if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n          throw new IOException(\"Key \" + name + \" already exists in \" + this);\n        }\n      } catch (KeyStoreException e) {\n        throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n            e);\n      }\n      Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n          options.getDescription(), new Date(), 1);\n      if (options.getBitLength() !\u003d 8 * material.length) {\n        throw new IOException(\"Wrong key length. Required \" +\n            options.getBitLength() + \", but got \" + (8 * material.length));\n      }\n      cache.put(name, meta);\n      String versionName \u003d buildVersionName(name, 0);\n      return innerSetKeyVersion(versionName, material, meta.getCipher());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "98a98ea0c57d01b875b820f53d43dbf885d07711": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10427. KeyProvider implementations should be thread safe. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1586103 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/04/14 12:43 PM",
      "commitName": "98a98ea0c57d01b875b820f53d43dbf885d07711",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "28/03/14 8:57 AM",
      "commitNameOld": "92b9c6ff60bcfb270fc4d8631dcba2a3762212c2",
      "commitAuthorOld": "Owen O\u0027Malley",
      "daysBetweenCommits": 12.16,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,25 @@\n   public KeyVersion createKey(String name, byte[] material,\n                                Options options) throws IOException {\n+    writeLock.lock();\n     try {\n-      if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n-        throw new IOException(\"Key \" + name + \" already exists in \" + this);\n+      try {\n+        if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n+          throw new IOException(\"Key \" + name + \" already exists in \" + this);\n+        }\n+      } catch (KeyStoreException e) {\n+        throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n+            e);\n       }\n-    } catch (KeyStoreException e) {\n-      throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n-          e);\n+      Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n+          new Date(), 1);\n+      if (options.getBitLength() !\u003d 8 * material.length) {\n+        throw new IOException(\"Wrong key length. Required \" +\n+            options.getBitLength() + \", but got \" + (8 * material.length));\n+      }\n+      cache.put(name, meta);\n+      String versionName \u003d buildVersionName(name, 0);\n+      return innerSetKeyVersion(versionName, material, meta.getCipher());\n+    } finally {\n+      writeLock.unlock();\n     }\n-    Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n-        new Date(), 1);\n-    if (options.getBitLength() !\u003d 8 * material.length) {\n-      throw new IOException(\"Wrong key length. Required \" +\n-          options.getBitLength() + \", but got \" + (8 * material.length));\n-    }\n-    cache.put(name, meta);\n-    String versionName \u003d buildVersionName(name, 0);\n-    return innerSetKeyVersion(versionName, material, meta.getCipher());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public KeyVersion createKey(String name, byte[] material,\n                               Options options) throws IOException {\n    writeLock.lock();\n    try {\n      try {\n        if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n          throw new IOException(\"Key \" + name + \" already exists in \" + this);\n        }\n      } catch (KeyStoreException e) {\n        throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n            e);\n      }\n      Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n          new Date(), 1);\n      if (options.getBitLength() !\u003d 8 * material.length) {\n        throw new IOException(\"Wrong key length. Required \" +\n            options.getBitLength() + \", but got \" + (8 * material.length));\n      }\n      cache.put(name, meta);\n      String versionName \u003d buildVersionName(name, 0);\n      return innerSetKeyVersion(versionName, material, meta.getCipher());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java",
      "extendedDetails": {}
    },
    "77306291643838ed7b57b99d6497553314a525f2": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10141. Create KeyProvider API to separate encryption key storage\nfrom the applications. (omalley)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1552462 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/12/13 4:25 PM",
      "commitName": "77306291643838ed7b57b99d6497553314a525f2",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,20 @@\n+  public KeyVersion createKey(String name, byte[] material,\n+                               Options options) throws IOException {\n+    try {\n+      if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n+        throw new IOException(\"Key \" + name + \" already exists in \" + this);\n+      }\n+    } catch (KeyStoreException e) {\n+      throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n+          e);\n+    }\n+    Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n+        new Date(), 1);\n+    if (options.getBitLength() !\u003d 8 * material.length) {\n+      throw new IOException(\"Wrong key length. Required \" +\n+          options.getBitLength() + \", but got \" + (8 * material.length));\n+    }\n+    cache.put(name, meta);\n+    String versionName \u003d buildVersionName(name, 0);\n+    return innerSetKeyVersion(versionName, material, meta.getCipher());\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public KeyVersion createKey(String name, byte[] material,\n                               Options options) throws IOException {\n    try {\n      if (keyStore.containsAlias(name) || cache.containsKey(name)) {\n        throw new IOException(\"Key \" + name + \" already exists in \" + this);\n      }\n    } catch (KeyStoreException e) {\n      throw new IOException(\"Problem looking up key \" + name + \" in \" + this,\n          e);\n    }\n    Metadata meta \u003d new Metadata(options.getCipher(), options.getBitLength(),\n        new Date(), 1);\n    if (options.getBitLength() !\u003d 8 * material.length) {\n      throw new IOException(\"Wrong key length. Required \" +\n          options.getBitLength() + \", but got \" + (8 * material.length));\n    }\n    cache.put(name, meta);\n    String versionName \u003d buildVersionName(name, 0);\n    return innerSetKeyVersion(versionName, material, meta.getCipher());\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/JavaKeyStoreProvider.java"
    }
  }
}