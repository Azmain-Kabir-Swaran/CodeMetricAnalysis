{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "OutlierDetector.java",
  "functionName": "getOutliers",
  "functionId": "getOutliers___stats-Map__String,Double__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/metrics/OutlierDetector.java",
  "functionStartLine": 110,
  "functionEndLine": 141,
  "numCommitsSeen": 3,
  "timeTaken": 3943,
  "changeHistory": [
    "b3ec531f400dd0a6506dc71233d38ae57b764a43",
    "b57368b6f893cb27d77fc9425e116f1312f4790f"
  ],
  "changeHistoryShort": {
    "b3ec531f400dd0a6506dc71233d38ae57b764a43": "Ymultichange(Yfilerename,Ybodychange)",
    "b57368b6f893cb27d77fc9425e116f1312f4790f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b3ec531f400dd0a6506dc71233d38ae57b764a43": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "HDFS-11461. DataNode Disk Outlier Detection. Contributed by Hanisha Koneru.\n",
      "commitDate": "02/03/17 12:45 PM",
      "commitName": "b3ec531f400dd0a6506dc71233d38ae57b764a43",
      "commitAuthor": "Arpit Agarwal",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "HDFS-11461. DataNode Disk Outlier Detection. Contributed by Hanisha Koneru.\n",
          "commitDate": "02/03/17 12:45 PM",
          "commitName": "b3ec531f400dd0a6506dc71233d38ae57b764a43",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "02/03/17 10:58 AM",
          "commitNameOld": "747bafaf969857b66233a8b4660590bdd712ed7d",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,32 @@\n   public Map\u003cString, Double\u003e getOutliers(Map\u003cString, Double\u003e stats) {\n-    if (stats.size() \u003c minOutlierDetectionPeers) {\n+    if (stats.size() \u003c minNumResources) {\n       LOG.debug(\"Skipping statistical outlier detection as we don\u0027t have \" +\n-              \"latency data for enough peers. Have {}, need at least {}\",\n-          stats.size(), minOutlierDetectionPeers);\n+              \"latency data for enough resources. Have {}, need at least {}\",\n+          stats.size(), minNumResources);\n       return ImmutableMap.of();\n     }\n     // Compute the median absolute deviation of the aggregates.\n     final List\u003cDouble\u003e sorted \u003d new ArrayList\u003c\u003e(stats.values());\n     Collections.sort(sorted);\n     final Double median \u003d computeMedian(sorted);\n     final Double mad \u003d computeMad(sorted);\n     Double upperLimitLatency \u003d Math.max(\n         lowThresholdMs, median * MEDIAN_MULTIPLIER);\n     upperLimitLatency \u003d Math.max(\n         upperLimitLatency, median + (DEVIATION_MULTIPLIER * mad));\n \n-    final Map\u003cString, Double\u003e slowNodes \u003d new HashMap\u003c\u003e();\n+    final Map\u003cString, Double\u003e slowResources \u003d new HashMap\u003c\u003e();\n \n     LOG.trace(\"getOutliers: List\u003d{}, MedianLatency\u003d{}, \" +\n         \"MedianAbsoluteDeviation\u003d{}, upperLimitLatency\u003d{}\",\n         sorted, median, mad, upperLimitLatency);\n \n-    // Find nodes whose latency exceeds the threshold.\n+    // Find resources whose latency exceeds the threshold.\n     for (Map.Entry\u003cString, Double\u003e entry : stats.entrySet()) {\n       if (entry.getValue() \u003e upperLimitLatency) {\n-        slowNodes.put(entry.getKey(), entry.getValue());\n+        slowResources.put(entry.getKey(), entry.getValue());\n       }\n     }\n \n-    return slowNodes;\n+    return slowResources;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cString, Double\u003e getOutliers(Map\u003cString, Double\u003e stats) {\n    if (stats.size() \u003c minNumResources) {\n      LOG.debug(\"Skipping statistical outlier detection as we don\u0027t have \" +\n              \"latency data for enough resources. Have {}, need at least {}\",\n          stats.size(), minNumResources);\n      return ImmutableMap.of();\n    }\n    // Compute the median absolute deviation of the aggregates.\n    final List\u003cDouble\u003e sorted \u003d new ArrayList\u003c\u003e(stats.values());\n    Collections.sort(sorted);\n    final Double median \u003d computeMedian(sorted);\n    final Double mad \u003d computeMad(sorted);\n    Double upperLimitLatency \u003d Math.max(\n        lowThresholdMs, median * MEDIAN_MULTIPLIER);\n    upperLimitLatency \u003d Math.max(\n        upperLimitLatency, median + (DEVIATION_MULTIPLIER * mad));\n\n    final Map\u003cString, Double\u003e slowResources \u003d new HashMap\u003c\u003e();\n\n    LOG.trace(\"getOutliers: List\u003d{}, MedianLatency\u003d{}, \" +\n        \"MedianAbsoluteDeviation\u003d{}, upperLimitLatency\u003d{}\",\n        sorted, median, mad, upperLimitLatency);\n\n    // Find resources whose latency exceeds the threshold.\n    for (Map.Entry\u003cString, Double\u003e entry : stats.entrySet()) {\n      if (entry.getValue() \u003e upperLimitLatency) {\n        slowResources.put(entry.getKey(), entry.getValue());\n      }\n    }\n\n    return slowResources;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/metrics/OutlierDetector.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/metrics/SlowNodeDetector.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/metrics/OutlierDetector.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-11461. DataNode Disk Outlier Detection. Contributed by Hanisha Koneru.\n",
          "commitDate": "02/03/17 12:45 PM",
          "commitName": "b3ec531f400dd0a6506dc71233d38ae57b764a43",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "02/03/17 10:58 AM",
          "commitNameOld": "747bafaf969857b66233a8b4660590bdd712ed7d",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 0.07,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,32 @@\n   public Map\u003cString, Double\u003e getOutliers(Map\u003cString, Double\u003e stats) {\n-    if (stats.size() \u003c minOutlierDetectionPeers) {\n+    if (stats.size() \u003c minNumResources) {\n       LOG.debug(\"Skipping statistical outlier detection as we don\u0027t have \" +\n-              \"latency data for enough peers. Have {}, need at least {}\",\n-          stats.size(), minOutlierDetectionPeers);\n+              \"latency data for enough resources. Have {}, need at least {}\",\n+          stats.size(), minNumResources);\n       return ImmutableMap.of();\n     }\n     // Compute the median absolute deviation of the aggregates.\n     final List\u003cDouble\u003e sorted \u003d new ArrayList\u003c\u003e(stats.values());\n     Collections.sort(sorted);\n     final Double median \u003d computeMedian(sorted);\n     final Double mad \u003d computeMad(sorted);\n     Double upperLimitLatency \u003d Math.max(\n         lowThresholdMs, median * MEDIAN_MULTIPLIER);\n     upperLimitLatency \u003d Math.max(\n         upperLimitLatency, median + (DEVIATION_MULTIPLIER * mad));\n \n-    final Map\u003cString, Double\u003e slowNodes \u003d new HashMap\u003c\u003e();\n+    final Map\u003cString, Double\u003e slowResources \u003d new HashMap\u003c\u003e();\n \n     LOG.trace(\"getOutliers: List\u003d{}, MedianLatency\u003d{}, \" +\n         \"MedianAbsoluteDeviation\u003d{}, upperLimitLatency\u003d{}\",\n         sorted, median, mad, upperLimitLatency);\n \n-    // Find nodes whose latency exceeds the threshold.\n+    // Find resources whose latency exceeds the threshold.\n     for (Map.Entry\u003cString, Double\u003e entry : stats.entrySet()) {\n       if (entry.getValue() \u003e upperLimitLatency) {\n-        slowNodes.put(entry.getKey(), entry.getValue());\n+        slowResources.put(entry.getKey(), entry.getValue());\n       }\n     }\n \n-    return slowNodes;\n+    return slowResources;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cString, Double\u003e getOutliers(Map\u003cString, Double\u003e stats) {\n    if (stats.size() \u003c minNumResources) {\n      LOG.debug(\"Skipping statistical outlier detection as we don\u0027t have \" +\n              \"latency data for enough resources. Have {}, need at least {}\",\n          stats.size(), minNumResources);\n      return ImmutableMap.of();\n    }\n    // Compute the median absolute deviation of the aggregates.\n    final List\u003cDouble\u003e sorted \u003d new ArrayList\u003c\u003e(stats.values());\n    Collections.sort(sorted);\n    final Double median \u003d computeMedian(sorted);\n    final Double mad \u003d computeMad(sorted);\n    Double upperLimitLatency \u003d Math.max(\n        lowThresholdMs, median * MEDIAN_MULTIPLIER);\n    upperLimitLatency \u003d Math.max(\n        upperLimitLatency, median + (DEVIATION_MULTIPLIER * mad));\n\n    final Map\u003cString, Double\u003e slowResources \u003d new HashMap\u003c\u003e();\n\n    LOG.trace(\"getOutliers: List\u003d{}, MedianLatency\u003d{}, \" +\n        \"MedianAbsoluteDeviation\u003d{}, upperLimitLatency\u003d{}\",\n        sorted, median, mad, upperLimitLatency);\n\n    // Find resources whose latency exceeds the threshold.\n    for (Map.Entry\u003cString, Double\u003e entry : stats.entrySet()) {\n      if (entry.getValue() \u003e upperLimitLatency) {\n        slowResources.put(entry.getKey(), entry.getValue());\n      }\n    }\n\n    return slowResources;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/metrics/OutlierDetector.java",
          "extendedDetails": {}
        }
      ]
    },
    "b57368b6f893cb27d77fc9425e116f1312f4790f": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-11194. Maintain aggregated peer performance metrics on NameNode.\n",
      "commitDate": "24/01/17 4:58 PM",
      "commitName": "b57368b6f893cb27d77fc9425e116f1312f4790f",
      "commitAuthor": "Arpit Agarwal",
      "diff": "@@ -0,0 +1,32 @@\n+  public Map\u003cString, Double\u003e getOutliers(Map\u003cString, Double\u003e stats) {\n+    if (stats.size() \u003c minOutlierDetectionPeers) {\n+      LOG.debug(\"Skipping statistical outlier detection as we don\u0027t have \" +\n+              \"latency data for enough peers. Have {}, need at least {}\",\n+          stats.size(), minOutlierDetectionPeers);\n+      return ImmutableMap.of();\n+    }\n+    // Compute the median absolute deviation of the aggregates.\n+    final List\u003cDouble\u003e sorted \u003d new ArrayList\u003c\u003e(stats.values());\n+    Collections.sort(sorted);\n+    final Double median \u003d computeMedian(sorted);\n+    final Double mad \u003d computeMad(sorted);\n+    Double upperLimitLatency \u003d Math.max(\n+        lowThresholdMs, median * MEDIAN_MULTIPLIER);\n+    upperLimitLatency \u003d Math.max(\n+        upperLimitLatency, median + (DEVIATION_MULTIPLIER * mad));\n+\n+    final Map\u003cString, Double\u003e slowNodes \u003d new HashMap\u003c\u003e();\n+\n+    LOG.trace(\"getOutliers: List\u003d{}, MedianLatency\u003d{}, \" +\n+        \"MedianAbsoluteDeviation\u003d{}, upperLimitLatency\u003d{}\",\n+        sorted, median, mad, upperLimitLatency);\n+\n+    // Find nodes whose latency exceeds the threshold.\n+    for (Map.Entry\u003cString, Double\u003e entry : stats.entrySet()) {\n+      if (entry.getValue() \u003e upperLimitLatency) {\n+        slowNodes.put(entry.getKey(), entry.getValue());\n+      }\n+    }\n+\n+    return slowNodes;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cString, Double\u003e getOutliers(Map\u003cString, Double\u003e stats) {\n    if (stats.size() \u003c minOutlierDetectionPeers) {\n      LOG.debug(\"Skipping statistical outlier detection as we don\u0027t have \" +\n              \"latency data for enough peers. Have {}, need at least {}\",\n          stats.size(), minOutlierDetectionPeers);\n      return ImmutableMap.of();\n    }\n    // Compute the median absolute deviation of the aggregates.\n    final List\u003cDouble\u003e sorted \u003d new ArrayList\u003c\u003e(stats.values());\n    Collections.sort(sorted);\n    final Double median \u003d computeMedian(sorted);\n    final Double mad \u003d computeMad(sorted);\n    Double upperLimitLatency \u003d Math.max(\n        lowThresholdMs, median * MEDIAN_MULTIPLIER);\n    upperLimitLatency \u003d Math.max(\n        upperLimitLatency, median + (DEVIATION_MULTIPLIER * mad));\n\n    final Map\u003cString, Double\u003e slowNodes \u003d new HashMap\u003c\u003e();\n\n    LOG.trace(\"getOutliers: List\u003d{}, MedianLatency\u003d{}, \" +\n        \"MedianAbsoluteDeviation\u003d{}, upperLimitLatency\u003d{}\",\n        sorted, median, mad, upperLimitLatency);\n\n    // Find nodes whose latency exceeds the threshold.\n    for (Map.Entry\u003cString, Double\u003e entry : stats.entrySet()) {\n      if (entry.getValue() \u003e upperLimitLatency) {\n        slowNodes.put(entry.getKey(), entry.getValue());\n      }\n    }\n\n    return slowNodes;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/metrics/SlowNodeDetector.java"
    }
  }
}