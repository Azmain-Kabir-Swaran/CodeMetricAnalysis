{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirWriteFileOp.java",
  "functionName": "startFile",
  "functionId": "startFile___fsn-FSNamesystem__iip-INodesInPath__permissions-PermissionStatus__holder-String__clientMachine-String__flag-EnumSet__CreateFlag____createParent-boolean__replication-short__blockSize-long__feInfo-FileEncryptionInfo__toRemoveBlocks-INode.BlocksMapUpdateInfo__shouldReplicate-boolean__ecPolicyName-String__storagePolicy-String__logRetryEntry-boolean",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
  "functionStartLine": 358,
  "functionEndLine": 420,
  "numCommitsSeen": 1307,
  "timeTaken": 25000,
  "changeHistory": [
    "0d7a5ac5f526801367a9ec963e6d72783b637d55",
    "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
    "1000a2af04b24c123a3b08168f36b4e90420cab7",
    "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405",
    "a7312715a66dec5173c3a0a78dff4e0333e7f0b1",
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
    "8b7adf4ddf420a93c586c4b2eac27dd0f649682e",
    "ec252ce0fc0998ce13f31af3440c08a236328e5a",
    "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
    "22fc46d7659972ff016ccf1c6f781f0c160be26f",
    "869393643de23dcb010cc33091c8eb398de0fd6c",
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
    "3dadf369d550c2ae393b751cb5a184dbfe2814df",
    "71a81b6257c0000475ad62eb69292a20d45d269c",
    "1fc3c779a422bafdb86ad1a5b2349802dda1cb62",
    "31f117138a00794de4951ee8433e304d72b04094",
    "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
    "8f7d4bb09f760780dd193c97796ebf4d22cfd2d7",
    "24315e7d374a1ddd4329b64350cf96fc9ab6f59c",
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
    "185e0c7b4c056b88f606362c71e4a22aae7076e0",
    "368743140dd076ecd5af309c1ed83c5ae2d59fc8",
    "128ace10cdde4e966e30ac429c9a65ab8ace2d6c",
    "bb84f1fccb18c6c7373851e05d2451d55e908242"
  ],
  "changeHistoryShort": {
    "0d7a5ac5f526801367a9ec963e6d72783b637d55": "Ymultichange(Yparameterchange,Ybodychange)",
    "693169ef34f856a27dc09d90a45fb4ec5b66ed2c": "Ybodychange",
    "1000a2af04b24c123a3b08168f36b4e90420cab7": "Ybodychange",
    "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405": "Ymultichange(Yparameterchange,Ybodychange)",
    "a7312715a66dec5173c3a0a78dff4e0333e7f0b1": "Ymultichange(Yparameterchange,Ybodychange)",
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65": "Ymultichange(Yparameterchange,Ybodychange)",
    "8b7adf4ddf420a93c586c4b2eac27dd0f649682e": "Ybodychange",
    "ec252ce0fc0998ce13f31af3440c08a236328e5a": "Ybodychange",
    "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88": "Ybodychange",
    "22fc46d7659972ff016ccf1c6f781f0c160be26f": "Ybodychange",
    "869393643de23dcb010cc33091c8eb398de0fd6c": "Ybodychange",
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2": "Ybodychange",
    "3dadf369d550c2ae393b751cb5a184dbfe2814df": "Ybodychange",
    "71a81b6257c0000475ad62eb69292a20d45d269c": "Ybodychange",
    "1fc3c779a422bafdb86ad1a5b2349802dda1cb62": "Ybodychange",
    "31f117138a00794de4951ee8433e304d72b04094": "Ybodychange",
    "2b6bcfdafa91223a4116e3e9304579f5f91dccac": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yrename,Yparameterchange)",
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63": "Ybodychange",
    "8f7d4bb09f760780dd193c97796ebf4d22cfd2d7": "Ybodychange",
    "24315e7d374a1ddd4329b64350cf96fc9ab6f59c": "Ybodychange",
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0": "Ybodychange",
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": "Ybodychange",
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
    "185e0c7b4c056b88f606362c71e4a22aae7076e0": "Ybodychange",
    "368743140dd076ecd5af309c1ed83c5ae2d59fc8": "Ybodychange",
    "128ace10cdde4e966e30ac429c9a65ab8ace2d6c": "Ybodychange",
    "bb84f1fccb18c6c7373851e05d2451d55e908242": "Ybodychange"
  },
  "changeHistoryDetails": {
    "0d7a5ac5f526801367a9ec963e6d72783b637d55": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-13209. DistributedFileSystem.create should allow an option to provide StoragePolicy. Contributed by Ayush Saxena.\n",
      "commitDate": "14/02/19 8:43 AM",
      "commitName": "0d7a5ac5f526801367a9ec963e6d72783b637d55",
      "commitAuthor": "Surendra Singh Lilhore",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-13209. DistributedFileSystem.create should allow an option to provide StoragePolicy. Contributed by Ayush Saxena.\n",
          "commitDate": "14/02/19 8:43 AM",
          "commitName": "0d7a5ac5f526801367a9ec963e6d72783b637d55",
          "commitAuthor": "Surendra Singh Lilhore",
          "commitDateOld": "24/07/18 4:05 PM",
          "commitNameOld": "849c45db187224095b13fe297a4d7377fbb9d2cd",
          "commitAuthorOld": "Daniel Templeton",
          "daysBetweenCommits": 204.73,
          "commitsBetweenForRepo": 1621,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,63 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, INodesInPath iip,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n-      boolean shouldReplicate, String ecPolicyName, boolean logRetryEntry)\n+      boolean shouldReplicate, String ecPolicyName, String storagePolicy,\n+      boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     final String src \u003d iip.getPath();\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n \n     if (iip.getLastINode() !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     INodesInPath parent \u003d\n         FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n           replication, blockSize, holder, clientMachine, shouldReplicate,\n-          ecPolicyName);\n+          ecPolicyName, storagePolicy);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo,\n           XAttrSetFlag.CREATE);\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, iip, false, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, INodesInPath iip,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean shouldReplicate, String ecPolicyName, String storagePolicy,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    final String src \u003d iip.getPath();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n\n    if (iip.getLastINode() !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    INodesInPath parent \u003d\n        FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n          replication, blockSize, holder, clientMachine, shouldReplicate,\n          ecPolicyName, storagePolicy);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo,\n          XAttrSetFlag.CREATE);\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip, false, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[fsn-FSNamesystem, iip-INodesInPath, permissions-PermissionStatus, holder-String, clientMachine-String, flag-EnumSet\u003cCreateFlag\u003e, createParent-boolean, replication-short, blockSize-long, feInfo-FileEncryptionInfo, toRemoveBlocks-INode.BlocksMapUpdateInfo, shouldReplicate-boolean, ecPolicyName-String, logRetryEntry-boolean]",
            "newValue": "[fsn-FSNamesystem, iip-INodesInPath, permissions-PermissionStatus, holder-String, clientMachine-String, flag-EnumSet\u003cCreateFlag\u003e, createParent-boolean, replication-short, blockSize-long, feInfo-FileEncryptionInfo, toRemoveBlocks-INode.BlocksMapUpdateInfo, shouldReplicate-boolean, ecPolicyName-String, storagePolicy-String, logRetryEntry-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13209. DistributedFileSystem.create should allow an option to provide StoragePolicy. Contributed by Ayush Saxena.\n",
          "commitDate": "14/02/19 8:43 AM",
          "commitName": "0d7a5ac5f526801367a9ec963e6d72783b637d55",
          "commitAuthor": "Surendra Singh Lilhore",
          "commitDateOld": "24/07/18 4:05 PM",
          "commitNameOld": "849c45db187224095b13fe297a4d7377fbb9d2cd",
          "commitAuthorOld": "Daniel Templeton",
          "daysBetweenCommits": 204.73,
          "commitsBetweenForRepo": 1621,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,62 +1,63 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, INodesInPath iip,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n-      boolean shouldReplicate, String ecPolicyName, boolean logRetryEntry)\n+      boolean shouldReplicate, String ecPolicyName, String storagePolicy,\n+      boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     final String src \u003d iip.getPath();\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n \n     if (iip.getLastINode() !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     INodesInPath parent \u003d\n         FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n           replication, blockSize, holder, clientMachine, shouldReplicate,\n-          ecPolicyName);\n+          ecPolicyName, storagePolicy);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo,\n           XAttrSetFlag.CREATE);\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, iip, false, false);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, INodesInPath iip,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean shouldReplicate, String ecPolicyName, String storagePolicy,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    final String src \u003d iip.getPath();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n\n    if (iip.getLastINode() !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    INodesInPath parent \u003d\n        FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n          replication, blockSize, holder, clientMachine, shouldReplicate,\n          ecPolicyName, storagePolicy);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo,\n          XAttrSetFlag.CREATE);\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip, false, false);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "693169ef34f856a27dc09d90a45fb4ec5b66ed2c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12882. Support full open(PathHandle) contract in HDFS\n",
      "commitDate": "11/12/17 8:14 PM",
      "commitName": "693169ef34f856a27dc09d90a45fb4ec5b66ed2c",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "07/12/17 11:15 AM",
      "commitNameOld": "67662e2ac9e68f32b725c8118cf2be79a662fca5",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 4.37,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, INodesInPath iip,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean shouldReplicate, String ecPolicyName, boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     final String src \u003d iip.getPath();\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n \n     if (iip.getLastINode() !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     INodesInPath parent \u003d\n         FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n           replication, blockSize, holder, clientMachine, shouldReplicate,\n           ecPolicyName);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo,\n           XAttrSetFlag.CREATE);\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n-    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n+    return FSDirStatAndListingOp.getFileInfo(fsd, iip, false, false);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, INodesInPath iip,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean shouldReplicate, String ecPolicyName, boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    final String src \u003d iip.getPath();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n\n    if (iip.getLastINode() !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    INodesInPath parent \u003d\n        FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n          replication, blockSize, holder, clientMachine, shouldReplicate,\n          ecPolicyName);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo,\n          XAttrSetFlag.CREATE);\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip, false, false);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "1000a2af04b24c123a3b08168f36b4e90420cab7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10899. Add functionality to re-encrypt EDEKs.\n",
      "commitDate": "23/08/17 5:06 PM",
      "commitName": "1000a2af04b24c123a3b08168f36b4e90420cab7",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "16/08/17 10:17 PM",
      "commitNameOld": "96b3a6b9721e922d33fadc2459b561a85dbf9b8e",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 6.78,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,62 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, INodesInPath iip,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean shouldReplicate, String ecPolicyName, boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     final String src \u003d iip.getPath();\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n \n     if (iip.getLastINode() !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     INodesInPath parent \u003d\n         FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n           replication, blockSize, holder, clientMachine, shouldReplicate,\n           ecPolicyName);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n-      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n+      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo,\n+          XAttrSetFlag.CREATE);\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, INodesInPath iip,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean shouldReplicate, String ecPolicyName, boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    final String src \u003d iip.getPath();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n\n    if (iip.getLastINode() !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    INodesInPath parent \u003d\n        FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n          replication, blockSize, holder, clientMachine, shouldReplicate,\n          ecPolicyName);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo,\n          XAttrSetFlag.CREATE);\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-11643. Add shouldReplicate option to create builder. Contributed by SammiChen.\n",
      "commitDate": "04/05/17 11:39 AM",
      "commitName": "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-11643. Add shouldReplicate option to create builder. Contributed by SammiChen.\n",
          "commitDate": "04/05/17 11:39 AM",
          "commitName": "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "12/04/17 12:27 PM",
          "commitNameOld": "a7312715a66dec5173c3a0a78dff4e0333e7f0b1",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 21.97,
          "commitsBetweenForRepo": 111,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,61 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, INodesInPath iip,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n-      String ecPolicyName, boolean logRetryEntry)\n+      boolean shouldReplicate, String ecPolicyName, boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     final String src \u003d iip.getPath();\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n \n     if (iip.getLastINode() !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     INodesInPath parent \u003d\n         FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n-          replication, blockSize, holder, clientMachine, ecPolicyName);\n+          replication, blockSize, holder, clientMachine, shouldReplicate,\n+          ecPolicyName);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, INodesInPath iip,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean shouldReplicate, String ecPolicyName, boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    final String src \u003d iip.getPath();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n\n    if (iip.getLastINode() !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    INodesInPath parent \u003d\n        FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n          replication, blockSize, holder, clientMachine, shouldReplicate,\n          ecPolicyName);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[fsn-FSNamesystem, iip-INodesInPath, permissions-PermissionStatus, holder-String, clientMachine-String, flag-EnumSet\u003cCreateFlag\u003e, createParent-boolean, replication-short, blockSize-long, feInfo-FileEncryptionInfo, toRemoveBlocks-INode.BlocksMapUpdateInfo, ecPolicyName-String, logRetryEntry-boolean]",
            "newValue": "[fsn-FSNamesystem, iip-INodesInPath, permissions-PermissionStatus, holder-String, clientMachine-String, flag-EnumSet\u003cCreateFlag\u003e, createParent-boolean, replication-short, blockSize-long, feInfo-FileEncryptionInfo, toRemoveBlocks-INode.BlocksMapUpdateInfo, shouldReplicate-boolean, ecPolicyName-String, logRetryEntry-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-11643. Add shouldReplicate option to create builder. Contributed by SammiChen.\n",
          "commitDate": "04/05/17 11:39 AM",
          "commitName": "c2a52ef9c29459ff9ef3e23b29e14912bfdb1405",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "12/04/17 12:27 PM",
          "commitNameOld": "a7312715a66dec5173c3a0a78dff4e0333e7f0b1",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 21.97,
          "commitsBetweenForRepo": 111,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,61 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, INodesInPath iip,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n-      String ecPolicyName, boolean logRetryEntry)\n+      boolean shouldReplicate, String ecPolicyName, boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     final String src \u003d iip.getPath();\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n \n     if (iip.getLastINode() !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     INodesInPath parent \u003d\n         FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n-          replication, blockSize, holder, clientMachine, ecPolicyName);\n+          replication, blockSize, holder, clientMachine, shouldReplicate,\n+          ecPolicyName);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, INodesInPath iip,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean shouldReplicate, String ecPolicyName, boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    final String src \u003d iip.getPath();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n\n    if (iip.getLastINode() !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    INodesInPath parent \u003d\n        FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n          replication, blockSize, holder, clientMachine, shouldReplicate,\n          ecPolicyName);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "a7312715a66dec5173c3a0a78dff4e0333e7f0b1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10996. Ability to specify per-file EC policy at create time. Contributed by SammiChen.\n",
      "commitDate": "12/04/17 12:27 PM",
      "commitName": "a7312715a66dec5173c3a0a78dff4e0333e7f0b1",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10996. Ability to specify per-file EC policy at create time. Contributed by SammiChen.\n",
          "commitDate": "12/04/17 12:27 PM",
          "commitName": "a7312715a66dec5173c3a0a78dff4e0333e7f0b1",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "03/03/17 1:00 PM",
          "commitNameOld": "3085a604300ed76d06a0011bd5555e419897b6cd",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 39.94,
          "commitsBetweenForRepo": 250,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,60 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, INodesInPath iip,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n-      boolean logRetryEntry)\n+      String ecPolicyName, boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     final String src \u003d iip.getPath();\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n \n     if (iip.getLastINode() !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     INodesInPath parent \u003d\n         FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n-                    replication, blockSize, holder, clientMachine);\n+          replication, blockSize, holder, clientMachine, ecPolicyName);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, INodesInPath iip,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      String ecPolicyName, boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    final String src \u003d iip.getPath();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n\n    if (iip.getLastINode() !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    INodesInPath parent \u003d\n        FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n          replication, blockSize, holder, clientMachine, ecPolicyName);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[fsn-FSNamesystem, iip-INodesInPath, permissions-PermissionStatus, holder-String, clientMachine-String, flag-EnumSet\u003cCreateFlag\u003e, createParent-boolean, replication-short, blockSize-long, feInfo-FileEncryptionInfo, toRemoveBlocks-INode.BlocksMapUpdateInfo, logRetryEntry-boolean]",
            "newValue": "[fsn-FSNamesystem, iip-INodesInPath, permissions-PermissionStatus, holder-String, clientMachine-String, flag-EnumSet\u003cCreateFlag\u003e, createParent-boolean, replication-short, blockSize-long, feInfo-FileEncryptionInfo, toRemoveBlocks-INode.BlocksMapUpdateInfo, ecPolicyName-String, logRetryEntry-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10996. Ability to specify per-file EC policy at create time. Contributed by SammiChen.\n",
          "commitDate": "12/04/17 12:27 PM",
          "commitName": "a7312715a66dec5173c3a0a78dff4e0333e7f0b1",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "03/03/17 1:00 PM",
          "commitNameOld": "3085a604300ed76d06a0011bd5555e419897b6cd",
          "commitAuthorOld": "Andrew Wang",
          "daysBetweenCommits": 39.94,
          "commitsBetweenForRepo": 250,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,60 +1,60 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, INodesInPath iip,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n-      boolean logRetryEntry)\n+      String ecPolicyName, boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     final String src \u003d iip.getPath();\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n \n     if (iip.getLastINode() !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     INodesInPath parent \u003d\n         FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n-                    replication, blockSize, holder, clientMachine);\n+          replication, blockSize, holder, clientMachine, ecPolicyName);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, INodesInPath iip,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      String ecPolicyName, boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    final String src \u003d iip.getPath();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n\n    if (iip.getLastINode() !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    INodesInPath parent \u003d\n        FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n          replication, blockSize, holder, clientMachine, ecPolicyName);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10939. Reduce performance penalty of encryption zones. Contributed by Daryn sharp.\n",
      "commitDate": "06/10/16 1:11 PM",
      "commitName": "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
      "commitAuthor": "Kihwal Lee",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10939. Reduce performance penalty of encryption zones. Contributed by Daryn sharp.\n",
          "commitDate": "06/10/16 1:11 PM",
          "commitName": "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "06/09/16 11:02 AM",
          "commitNameOld": "f0d5382ff3e31a47d13e4cb6c3a244cca82b17ce",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 30.09,
          "commitsBetweenForRepo": 188,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,129 +1,60 @@\n   static HdfsFileStatus startFile(\n-      FSNamesystem fsn, FSPermissionChecker pc, String src,\n+      FSNamesystem fsn, INodesInPath iip,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n-      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n+      FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n-\n-    boolean create \u003d flag.contains(CreateFlag.CREATE);\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n-    CipherSuite suite \u003d null;\n-    CryptoProtocolVersion version \u003d null;\n-    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n-\n-    if (ezInfo !\u003d null) {\n-      edek \u003d ezInfo.edek;\n-      suite \u003d ezInfo.suite;\n-      version \u003d ezInfo.protocolVersion;\n-    }\n-\n+    final String src \u003d iip.getPath();\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n-    INodesInPath iip \u003d fsd.resolvePathForWrite(pc, src);\n-    src \u003d iip.getPath();\n \n-    // Verify that the destination does not exist as a directory already.\n-    final INode inode \u003d iip.getLastINode();\n-    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n-      throw new FileAlreadyExistsException(src +\n-          \" already exists as a directory\");\n-    }\n-\n-    if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n-        \u0026\u0026 !FSDirectory.isReservedRawName(src)\n-        \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n-      throw new InvalidPathException(src);\n-    }\n-\n-    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-    if (fsd.isPermissionEnabled()) {\n-      if (overwrite \u0026\u0026 myFile !\u003d null) {\n-        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n-      }\n-      /*\n-       * To overwrite existing file, need to check \u0027w\u0027 permission\n-       * of parent (equals to ancestor in this case)\n-       */\n-      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n-    }\n-\n-    if (!createParent) {\n-      fsd.verifyParentDir(iip, src);\n-    }\n-\n-    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n-      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n-          src + \" for client \" + clientMachine);\n-    }\n-\n-    FileEncryptionInfo feInfo \u003d null;\n-\n-    final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n-    if (zone !\u003d null) {\n-      // The path is now within an EZ, but we\u0027re missing encryption parameters\n-      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n-        throw new RetryStartFileException();\n-      }\n-      // Path is within an EZ and we have provided encryption parameters.\n-      // Make sure that the generated EDEK matches the settings of the EZ.\n-      final String ezKeyName \u003d zone.getKeyName();\n-      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n-        throw new RetryStartFileException();\n-      }\n-      feInfo \u003d new FileEncryptionInfo(suite, version,\n-          edek.getEncryptedKeyVersion().getMaterial(),\n-          edek.getEncryptedKeyIv(),\n-          ezKeyName, edek.getEncryptionKeyVersionName());\n-    }\n-\n-    if (myFile !\u003d null) {\n+    if (iip.getLastINode() !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     INodesInPath parent \u003d\n         FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n                     replication, blockSize, holder, clientMachine);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n-      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n-      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n+      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n     }\n-    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n-                             isLazyPersist);\n+    setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, INodesInPath iip,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    final String src \u003d iip.getPath();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n\n    if (iip.getLastINode() !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    INodesInPath parent \u003d\n        FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[fsn-FSNamesystem, pc-FSPermissionChecker, src-String, permissions-PermissionStatus, holder-String, clientMachine-String, flag-EnumSet\u003cCreateFlag\u003e, createParent-boolean, replication-short, blockSize-long, ezInfo-EncryptionKeyInfo, toRemoveBlocks-INode.BlocksMapUpdateInfo, logRetryEntry-boolean]",
            "newValue": "[fsn-FSNamesystem, iip-INodesInPath, permissions-PermissionStatus, holder-String, clientMachine-String, flag-EnumSet\u003cCreateFlag\u003e, createParent-boolean, replication-short, blockSize-long, feInfo-FileEncryptionInfo, toRemoveBlocks-INode.BlocksMapUpdateInfo, logRetryEntry-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10939. Reduce performance penalty of encryption zones. Contributed by Daryn sharp.\n",
          "commitDate": "06/10/16 1:11 PM",
          "commitName": "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
          "commitAuthor": "Kihwal Lee",
          "commitDateOld": "06/09/16 11:02 AM",
          "commitNameOld": "f0d5382ff3e31a47d13e4cb6c3a244cca82b17ce",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 30.09,
          "commitsBetweenForRepo": 188,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,129 +1,60 @@\n   static HdfsFileStatus startFile(\n-      FSNamesystem fsn, FSPermissionChecker pc, String src,\n+      FSNamesystem fsn, INodesInPath iip,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n-      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n+      FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n-\n-    boolean create \u003d flag.contains(CreateFlag.CREATE);\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n-    CipherSuite suite \u003d null;\n-    CryptoProtocolVersion version \u003d null;\n-    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n-\n-    if (ezInfo !\u003d null) {\n-      edek \u003d ezInfo.edek;\n-      suite \u003d ezInfo.suite;\n-      version \u003d ezInfo.protocolVersion;\n-    }\n-\n+    final String src \u003d iip.getPath();\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n-    INodesInPath iip \u003d fsd.resolvePathForWrite(pc, src);\n-    src \u003d iip.getPath();\n \n-    // Verify that the destination does not exist as a directory already.\n-    final INode inode \u003d iip.getLastINode();\n-    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n-      throw new FileAlreadyExistsException(src +\n-          \" already exists as a directory\");\n-    }\n-\n-    if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n-        \u0026\u0026 !FSDirectory.isReservedRawName(src)\n-        \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n-      throw new InvalidPathException(src);\n-    }\n-\n-    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-    if (fsd.isPermissionEnabled()) {\n-      if (overwrite \u0026\u0026 myFile !\u003d null) {\n-        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n-      }\n-      /*\n-       * To overwrite existing file, need to check \u0027w\u0027 permission\n-       * of parent (equals to ancestor in this case)\n-       */\n-      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n-    }\n-\n-    if (!createParent) {\n-      fsd.verifyParentDir(iip, src);\n-    }\n-\n-    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n-      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n-          src + \" for client \" + clientMachine);\n-    }\n-\n-    FileEncryptionInfo feInfo \u003d null;\n-\n-    final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n-    if (zone !\u003d null) {\n-      // The path is now within an EZ, but we\u0027re missing encryption parameters\n-      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n-        throw new RetryStartFileException();\n-      }\n-      // Path is within an EZ and we have provided encryption parameters.\n-      // Make sure that the generated EDEK matches the settings of the EZ.\n-      final String ezKeyName \u003d zone.getKeyName();\n-      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n-        throw new RetryStartFileException();\n-      }\n-      feInfo \u003d new FileEncryptionInfo(suite, version,\n-          edek.getEncryptedKeyVersion().getMaterial(),\n-          edek.getEncryptedKeyIv(),\n-          ezKeyName, edek.getEncryptionKeyVersionName());\n-    }\n-\n-    if (myFile !\u003d null) {\n+    if (iip.getLastINode() !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     INodesInPath parent \u003d\n         FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n                     replication, blockSize, holder, clientMachine);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n-      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n-      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n+      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n     }\n-    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n-                             isLazyPersist);\n+    setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, INodesInPath iip,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      FileEncryptionInfo feInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    final String src \u003d iip.getPath();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n\n    if (iip.getLastINode() !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    INodesInPath parent \u003d\n        FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, iip, feInfo);\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), iip, isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "8b7adf4ddf420a93c586c4b2eac27dd0f649682e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10768. Optimize mkdir ops. Contributed by Daryn Sharp.\n",
      "commitDate": "26/08/16 1:39 PM",
      "commitName": "8b7adf4ddf420a93c586c4b2eac27dd0f649682e",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "24/08/16 6:46 AM",
      "commitNameOld": "ec252ce0fc0998ce13f31af3440c08a236328e5a",
      "commitAuthorOld": "Daryn Sharp",
      "daysBetweenCommits": 2.29,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,129 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, FSPermissionChecker pc, String src,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n \n     boolean create \u003d flag.contains(CreateFlag.CREATE);\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     CipherSuite suite \u003d null;\n     CryptoProtocolVersion version \u003d null;\n     KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n \n     if (ezInfo !\u003d null) {\n       edek \u003d ezInfo.edek;\n       suite \u003d ezInfo.suite;\n       version \u003d ezInfo.protocolVersion;\n     }\n \n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     INodesInPath iip \u003d fsd.resolvePathForWrite(pc, src);\n     src \u003d iip.getPath();\n \n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n         \u0026\u0026 !FSDirectory.isReservedRawName(src)\n         \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n       throw new InvalidPathException(src);\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n       fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       fsd.verifyParentDir(iip, src);\n     }\n \n     if (myFile \u003d\u003d null \u0026\u0026 !create) {\n       throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n           src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     if (myFile !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n-    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n-        .createAncestorDirectories(fsd, iip, permissions);\n+    INodesInPath parent \u003d\n+        FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n-      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n+      iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n                     replication, blockSize, holder, clientMachine);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n       newNode \u003d fsd.getInode(newNode.getId()).asFile();\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                              isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    INodesInPath iip \u003d fsd.resolvePathForWrite(pc, src);\n    src \u003d iip.getPath();\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n        \u0026\u0026 !FSDirectory.isReservedRawName(src)\n        \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n      throw new InvalidPathException(src);\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    INodesInPath parent \u003d\n        FSDirMkdirOp.createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent, iip.getLastLocalName(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "ec252ce0fc0998ce13f31af3440c08a236328e5a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10762. Pass IIP for file status related methods\n",
      "commitDate": "24/08/16 6:46 AM",
      "commitName": "ec252ce0fc0998ce13f31af3440c08a236328e5a",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "22/08/16 2:57 PM",
      "commitNameOld": "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 1.66,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,129 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, FSPermissionChecker pc, String src,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n \n     boolean create \u003d flag.contains(CreateFlag.CREATE);\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     CipherSuite suite \u003d null;\n     CryptoProtocolVersion version \u003d null;\n     KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n \n     if (ezInfo !\u003d null) {\n       edek \u003d ezInfo.edek;\n       suite \u003d ezInfo.suite;\n       version \u003d ezInfo.protocolVersion;\n     }\n \n-    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     INodesInPath iip \u003d fsd.resolvePathForWrite(pc, src);\n     src \u003d iip.getPath();\n \n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n         \u0026\u0026 !FSDirectory.isReservedRawName(src)\n         \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n       throw new InvalidPathException(src);\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n       fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       fsd.verifyParentDir(iip, src);\n     }\n \n     if (myFile \u003d\u003d null \u0026\u0026 !create) {\n       throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n           src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     if (myFile !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n         .createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                     replication, blockSize, holder, clientMachine);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n       newNode \u003d fsd.getInode(newNode.getId()).asFile();\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                              isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n-    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n+    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    INodesInPath iip \u003d fsd.resolvePathForWrite(pc, src);\n    src \u003d iip.getPath();\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n        \u0026\u0026 !FSDirectory.isReservedRawName(src)\n        \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n      throw new InvalidPathException(src);\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-10762. Pass IIP for file status related methods. Contributed by Daryn Sharp.\"\n\nThis reverts commit 22fc46d7659972ff016ccf1c6f781f0c160be26f.\n",
      "commitDate": "22/08/16 2:57 PM",
      "commitName": "3ca4d6ddfd199c95677721ff3bcb95d1da45bd88",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "22/08/16 1:37 PM",
      "commitNameOld": "22fc46d7659972ff016ccf1c6f781f0c160be26f",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,130 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, FSPermissionChecker pc, String src,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n \n     boolean create \u003d flag.contains(CreateFlag.CREATE);\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     CipherSuite suite \u003d null;\n     CryptoProtocolVersion version \u003d null;\n     KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n \n     if (ezInfo !\u003d null) {\n       edek \u003d ezInfo.edek;\n       suite \u003d ezInfo.suite;\n       version \u003d ezInfo.protocolVersion;\n     }\n \n+    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     INodesInPath iip \u003d fsd.resolvePathForWrite(pc, src);\n     src \u003d iip.getPath();\n \n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n         \u0026\u0026 !FSDirectory.isReservedRawName(src)\n         \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n       throw new InvalidPathException(src);\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n       fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       fsd.verifyParentDir(iip, src);\n     }\n \n     if (myFile \u003d\u003d null \u0026\u0026 !create) {\n       throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n           src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     if (myFile !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n         .createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                     replication, blockSize, holder, clientMachine);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n       newNode \u003d fsd.getInode(newNode.getId()).asFile();\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                              isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n-    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n+    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    INodesInPath iip \u003d fsd.resolvePathForWrite(pc, src);\n    src \u003d iip.getPath();\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n        \u0026\u0026 !FSDirectory.isReservedRawName(src)\n        \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n      throw new InvalidPathException(src);\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "22fc46d7659972ff016ccf1c6f781f0c160be26f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10762. Pass IIP for file status related methods. Contributed by Daryn Sharp.\n",
      "commitDate": "22/08/16 1:37 PM",
      "commitName": "22fc46d7659972ff016ccf1c6f781f0c160be26f",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "17/08/16 1:53 PM",
      "commitNameOld": "869393643de23dcb010cc33091c8eb398de0fd6c",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 4.99,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,129 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, FSPermissionChecker pc, String src,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n \n     boolean create \u003d flag.contains(CreateFlag.CREATE);\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     CipherSuite suite \u003d null;\n     CryptoProtocolVersion version \u003d null;\n     KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n \n     if (ezInfo !\u003d null) {\n       edek \u003d ezInfo.edek;\n       suite \u003d ezInfo.suite;\n       version \u003d ezInfo.protocolVersion;\n     }\n \n-    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     INodesInPath iip \u003d fsd.resolvePathForWrite(pc, src);\n     src \u003d iip.getPath();\n \n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n         \u0026\u0026 !FSDirectory.isReservedRawName(src)\n         \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n       throw new InvalidPathException(src);\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n       fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       fsd.verifyParentDir(iip, src);\n     }\n \n     if (myFile \u003d\u003d null \u0026\u0026 !create) {\n       throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n           src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     if (myFile !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n         .createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                     replication, blockSize, holder, clientMachine);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n       newNode \u003d fsd.getInode(newNode.getId()).asFile();\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                              isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n-    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n+    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    INodesInPath iip \u003d fsd.resolvePathForWrite(pc, src);\n    src \u003d iip.getPath();\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n        \u0026\u0026 !FSDirectory.isReservedRawName(src)\n        \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n      throw new InvalidPathException(src);\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, iip);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "869393643de23dcb010cc33091c8eb398de0fd6c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10745. Directly resolve paths into INodesInPath. Contributed by Daryn Sharp.\n",
      "commitDate": "17/08/16 1:53 PM",
      "commitName": "869393643de23dcb010cc33091c8eb398de0fd6c",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "15/08/16 2:45 PM",
      "commitNameOld": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 1.96,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,130 +1,130 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, FSPermissionChecker pc, String src,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n \n     boolean create \u003d flag.contains(CreateFlag.CREATE);\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     CipherSuite suite \u003d null;\n     CryptoProtocolVersion version \u003d null;\n     KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n \n     if (ezInfo !\u003d null) {\n       edek \u003d ezInfo.edek;\n       suite \u003d ezInfo.suite;\n       version \u003d ezInfo.protocolVersion;\n     }\n \n     boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n-    src \u003d fsd.resolvePath(pc, src);\n-    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+    INodesInPath iip \u003d fsd.resolvePathForWrite(pc, src);\n+    src \u003d iip.getPath();\n \n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n         \u0026\u0026 !FSDirectory.isReservedRawName(src)\n         \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n       throw new InvalidPathException(src);\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n       fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       fsd.verifyParentDir(iip, src);\n     }\n \n     if (myFile \u003d\u003d null \u0026\u0026 !create) {\n       throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n           src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     if (myFile !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n         .createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                     replication, blockSize, holder, clientMachine);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n       newNode \u003d fsd.getInode(newNode.getId()).asFile();\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                              isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    INodesInPath iip \u003d fsd.resolvePathForWrite(pc, src);\n    src \u003d iip.getPath();\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n        \u0026\u0026 !FSDirectory.isReservedRawName(src)\n        \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n      throw new InvalidPathException(src);\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10744. Internally optimize path component resolution. Contributed by Daryn Sharp.\n",
      "commitDate": "15/08/16 2:45 PM",
      "commitName": "03dea65e0b17ca2f9460bb6110f6ab3a321b8bf2",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/08/16 7:07 AM",
      "commitNameOld": "6ae39199dac6ac7be6802b31452552c76da16e24",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 11.32,
      "commitsBetweenForRepo": 73,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,131 +1,130 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, FSPermissionChecker pc, String src,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n \n     boolean create \u003d flag.contains(CreateFlag.CREATE);\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     CipherSuite suite \u003d null;\n     CryptoProtocolVersion version \u003d null;\n     KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n \n     if (ezInfo !\u003d null) {\n       edek \u003d ezInfo.edek;\n       suite \u003d ezInfo.suite;\n       version \u003d ezInfo.protocolVersion;\n     }\n \n     boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n-    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n-    src \u003d fsd.resolvePath(pc, src, pathComponents);\n+    src \u003d fsd.resolvePath(pc, src);\n     INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n \n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n         \u0026\u0026 !FSDirectory.isReservedRawName(src)\n         \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n       throw new InvalidPathException(src);\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n       fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       fsd.verifyParentDir(iip, src);\n     }\n \n     if (myFile \u003d\u003d null \u0026\u0026 !create) {\n       throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n           src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     if (myFile !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n         .createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                     replication, blockSize, holder, clientMachine);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n       newNode \u003d fsd.getInode(newNode.getId()).asFile();\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                              isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    src \u003d fsd.resolvePath(pc, src);\n    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n        \u0026\u0026 !FSDirectory.isReservedRawName(src)\n        \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n      throw new InvalidPathException(src);\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "3dadf369d550c2ae393b751cb5a184dbfe2814df": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7087. Ability to list /.reserved. Contributed by Xiao Chen.\n",
      "commitDate": "21/10/15 4:58 PM",
      "commitName": "3dadf369d550c2ae393b751cb5a184dbfe2814df",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "29/09/15 1:39 AM",
      "commitNameOld": "8fd55202468b28422b0df888641c9b08906fe4a7",
      "commitAuthorOld": "",
      "daysBetweenCommits": 22.64,
      "commitsBetweenForRepo": 171,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,131 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, FSPermissionChecker pc, String src,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n \n     boolean create \u003d flag.contains(CreateFlag.CREATE);\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     CipherSuite suite \u003d null;\n     CryptoProtocolVersion version \u003d null;\n     KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n \n     if (ezInfo !\u003d null) {\n       edek \u003d ezInfo.edek;\n       suite \u003d ezInfo.suite;\n       version \u003d ezInfo.protocolVersion;\n     }\n \n     boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n     src \u003d fsd.resolvePath(pc, src, pathComponents);\n     INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n \n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n+    if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n+        \u0026\u0026 !FSDirectory.isReservedRawName(src)\n+        \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n+      throw new InvalidPathException(src);\n+    }\n+\n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n       fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       fsd.verifyParentDir(iip, src);\n     }\n \n     if (myFile \u003d\u003d null \u0026\u0026 !create) {\n       throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n           src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     if (myFile !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n         .createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                     replication, blockSize, holder, clientMachine);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n       newNode \u003d fsd.getInode(newNode.getId()).asFile();\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                              isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    if (FSDirectory.isExactReservedName(src) || (FSDirectory.isReservedName(src)\n        \u0026\u0026 !FSDirectory.isReservedRawName(src)\n        \u0026\u0026 !FSDirectory.isReservedInodesName(src))) {\n      throw new InvalidPathException(src);\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "71a81b6257c0000475ad62eb69292a20d45d269c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7529. Consolidate encryption zone related implementation into a single class. Contributed by Rakesh R.\n",
      "commitDate": "24/09/15 8:34 AM",
      "commitName": "71a81b6257c0000475ad62eb69292a20d45d269c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "24/08/15 3:53 PM",
      "commitNameOld": "bdd79388f39f4f35af7decd5703eff587b0ddfb7",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 30.7,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, FSPermissionChecker pc, String src,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n \n     boolean create \u003d flag.contains(CreateFlag.CREATE);\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     CipherSuite suite \u003d null;\n     CryptoProtocolVersion version \u003d null;\n     KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n \n     if (ezInfo !\u003d null) {\n       edek \u003d ezInfo.edek;\n       suite \u003d ezInfo.suite;\n       version \u003d ezInfo.protocolVersion;\n     }\n \n     boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n     src \u003d fsd.resolvePath(pc, src, pathComponents);\n     INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n \n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n       fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       fsd.verifyParentDir(iip, src);\n     }\n \n     if (myFile \u003d\u003d null \u0026\u0026 !create) {\n       throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n           src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n-    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n+    final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     if (myFile !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n         .createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                     replication, blockSize, holder, clientMachine);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n-      fsd.setFileEncryptionInfo(src, feInfo);\n+      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n       newNode \u003d fsd.getInode(newNode.getId()).asFile();\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                              isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d FSDirEncryptionZoneOp.getEZForPath(fsd, iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      FSDirEncryptionZoneOp.setFileEncryptionInfo(fsd, src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "1fc3c779a422bafdb86ad1a5b2349802dda1cb62": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8805. Archival Storage: getStoragePolicy should not need superuser privilege. Contributed by Brahma Reddy Battula.\n",
      "commitDate": "11/08/15 10:28 AM",
      "commitName": "1fc3c779a422bafdb86ad1a5b2349802dda1cb62",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "06/08/15 10:21 AM",
      "commitNameOld": "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, FSPermissionChecker pc, String src,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n \n     boolean create \u003d flag.contains(CreateFlag.CREATE);\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     CipherSuite suite \u003d null;\n     CryptoProtocolVersion version \u003d null;\n     KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n \n     if (ezInfo !\u003d null) {\n       edek \u003d ezInfo.edek;\n       suite \u003d ezInfo.suite;\n       version \u003d ezInfo.protocolVersion;\n     }\n \n     boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n     src \u003d fsd.resolvePath(pc, src, pathComponents);\n     INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n \n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n       fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       fsd.verifyParentDir(iip, src);\n     }\n \n     if (myFile \u003d\u003d null \u0026\u0026 !create) {\n       throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n           src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     if (myFile !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n         .createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                     replication, blockSize, holder, clientMachine);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       fsd.setFileEncryptionInfo(src, feInfo);\n       newNode \u003d fsd.getInode(newNode.getId()).asFile();\n     }\n     setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                              isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n-    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n+    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      fsd.setFileEncryptionInfo(src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "31f117138a00794de4951ee8433e304d72b04094": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8495. Consolidate append() related implementation into a single class. Contributed by Rakesh R.\n",
      "commitDate": "21/07/15 5:25 PM",
      "commitName": "31f117138a00794de4951ee8433e304d72b04094",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "07/07/15 10:13 AM",
      "commitNameOld": "bc99aaffe7b0ed13b1efc37b6a32cdbd344c2d75",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 14.3,
      "commitsBetweenForRepo": 88,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,125 +1,125 @@\n   static HdfsFileStatus startFile(\n       FSNamesystem fsn, FSPermissionChecker pc, String src,\n       PermissionStatus permissions, String holder, String clientMachine,\n       EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n       short replication, long blockSize,\n       EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n       boolean logRetryEntry)\n       throws IOException {\n     assert fsn.hasWriteLock();\n \n     boolean create \u003d flag.contains(CreateFlag.CREATE);\n     boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n     boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n \n     CipherSuite suite \u003d null;\n     CryptoProtocolVersion version \u003d null;\n     KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n \n     if (ezInfo !\u003d null) {\n       edek \u003d ezInfo.edek;\n       suite \u003d ezInfo.suite;\n       version \u003d ezInfo.protocolVersion;\n     }\n \n     boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n     src \u003d fsd.resolvePath(pc, src, pathComponents);\n     INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n \n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n       fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       fsd.verifyParentDir(iip, src);\n     }\n \n     if (myFile \u003d\u003d null \u0026\u0026 !create) {\n       throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n           src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     if (myFile !\u003d null) {\n       if (overwrite) {\n         List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n         List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n         long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                         toRemoveINodes, toRemoveUCFiles, now());\n         if (ret \u003e\u003d 0) {\n           iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n           FSDirDeleteOp.incrDeletedFileCount(ret);\n           fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n         // If lease soft limit time is expired, recover the lease\n         fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                  src, holder, clientMachine, false);\n         throw new FileAlreadyExistsException(src + \" for client \" +\n             clientMachine + \" already exists\");\n       }\n     }\n     fsn.checkFsObjectLimit();\n     INodeFile newNode \u003d null;\n     Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n         .createAncestorDirectories(fsd, iip, permissions);\n     if (parent !\u003d null) {\n       iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                     replication, blockSize, holder, clientMachine);\n       newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n     }\n     if (newNode \u003d\u003d null) {\n       throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n     }\n     fsn.leaseManager.addLease(\n         newNode.getFileUnderConstructionFeature().getClientName(),\n         newNode.getId());\n     if (feInfo !\u003d null) {\n       fsd.setFileEncryptionInfo(src, feInfo);\n       newNode \u003d fsd.getInode(newNode.getId()).asFile();\n     }\n-    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n+    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                              isLazyPersist);\n     fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n     if (NameNode.stateChangeLog.isDebugEnabled()) {\n       NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n           src + \" inode \" + newNode.getId() + \" \" + holder);\n     }\n     return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      fsd.setFileEncryptionInfo(src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsd.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
      "extendedDetails": {}
    },
    "2b6bcfdafa91223a4116e3e9304579f5f91dccac": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yrename,Yparameterchange)",
      "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
      "commitDate": "21/05/15 8:08 AM",
      "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
      "commitAuthor": "Haohui Mai",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
          "commitDate": "21/05/15 8:08 AM",
          "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/05/15 7:44 AM",
          "commitNameOld": "0305316d6932e6f1a05021354d77b6934e57e171",
          "commitAuthorOld": "Devaraj K",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,119 +1,125 @@\n-  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n-      INodesInPath iip, PermissionStatus permissions, String holder,\n-      String clientMachine, boolean create, boolean overwrite, \n-      boolean createParent, short replication, long blockSize, \n-      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n-      EncryptedKeyVersion edek, boolean logRetryEntry)\n+  static HdfsFileStatus startFile(\n+      FSNamesystem fsn, FSPermissionChecker pc, String src,\n+      PermissionStatus permissions, String holder, String clientMachine,\n+      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n+      short replication, long blockSize,\n+      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n+      boolean logRetryEntry)\n       throws IOException {\n-    assert hasWriteLock();\n+    assert fsn.hasWriteLock();\n+\n+    boolean create \u003d flag.contains(CreateFlag.CREATE);\n+    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n+    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n+\n+    CipherSuite suite \u003d null;\n+    CryptoProtocolVersion version \u003d null;\n+    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n+\n+    if (ezInfo !\u003d null) {\n+      edek \u003d ezInfo.edek;\n+      suite \u003d ezInfo.suite;\n+      version \u003d ezInfo.protocolVersion;\n+    }\n+\n+    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n+    FSDirectory fsd \u003d fsn.getFSDirectory();\n+    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n+    src \u003d fsd.resolvePath(pc, src, pathComponents);\n+    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-    if (isPermissionEnabled) {\n+    if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n-        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n-       * To overwrite existing file, need to check \u0027w\u0027 permission \n+       * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n-      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n+      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n+\n     if (!createParent) {\n-      dir.verifyParentDir(iip, src);\n+      fsd.verifyParentDir(iip, src);\n+    }\n+\n+    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n+      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n+          src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n-    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n+    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n-    try {\n-      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n-      if (myFile \u003d\u003d null) {\n-        if (!create) {\n-          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n-              src + \" for client \" + clientMachine);\n+    if (myFile !\u003d null) {\n+      if (overwrite) {\n+        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n+        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n+        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n+                                        toRemoveINodes, toRemoveUCFiles, now());\n+        if (ret \u003e\u003d 0) {\n+          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n+          FSDirDeleteOp.incrDeletedFileCount(ret);\n+          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n-        if (overwrite) {\n-          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n-          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n-          List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n-          long ret \u003d FSDirDeleteOp.delete(\n-              dir, iip, toRemoveBlocks, toRemoveINodes,\n-              toRemoveUCFiles, now());\n-          if (ret \u003e\u003d 0) {\n-            iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n-            FSDirDeleteOp.incrDeletedFileCount(ret);\n-            removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n-          }\n-        } else {\n-          // If lease soft limit time is expired, recover the lease\n-          recoverLeaseInternal(RecoverLeaseOp.CREATE_FILE,\n-              iip, src, holder, clientMachine, false);\n-          throw new FileAlreadyExistsException(src + \" for client \" +\n-              clientMachine + \" already exists\");\n-        }\n+        // If lease soft limit time is expired, recover the lease\n+        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n+                                 src, holder, clientMachine, false);\n+        throw new FileAlreadyExistsException(src + \" for client \" +\n+            clientMachine + \" already exists\");\n       }\n-\n-      checkFsObjectLimit();\n-      INodeFile newNode \u003d null;\n-\n-      // Always do an implicit mkdirs for parent directory tree.\n-      Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n-          .createAncestorDirectories(dir, iip, permissions);\n-      if (parent !\u003d null) {\n-        iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n-            replication, blockSize, holder, clientMachine);\n-        newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n-      }\n-\n-      if (newNode \u003d\u003d null) {\n-        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n-      }\n-      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n-          .getClientName(), newNode.getId());\n-\n-      // Set encryption attributes if necessary\n-      if (feInfo !\u003d null) {\n-        dir.setFileEncryptionInfo(src, feInfo);\n-        newNode \u003d dir.getInode(newNode.getId()).asFile();\n-      }\n-\n-      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n-\n-      // record file record in log, record new generation stamp\n-      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n-      if (NameNode.stateChangeLog.isDebugEnabled()) {\n-        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n-            src + \" inode \" + newNode.getId() + \" \" + holder);\n-      }\n-      return toRemoveBlocks;\n-    } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n-                                       ie.getMessage());\n-      throw ie;\n     }\n+    fsn.checkFsObjectLimit();\n+    INodeFile newNode \u003d null;\n+    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n+        .createAncestorDirectories(fsd, iip, permissions);\n+    if (parent !\u003d null) {\n+      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n+                    replication, blockSize, holder, clientMachine);\n+      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n+    }\n+    if (newNode \u003d\u003d null) {\n+      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n+    }\n+    fsn.leaseManager.addLease(\n+        newNode.getFileUnderConstructionFeature().getClientName(),\n+        newNode.getId());\n+    if (feInfo !\u003d null) {\n+      fsd.setFileEncryptionInfo(src, feInfo);\n+      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n+    }\n+    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n+                             isLazyPersist);\n+    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n+    if (NameNode.stateChangeLog.isDebugEnabled()) {\n+      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n+          src + \" inode \" + newNode.getId() + \" \" + holder);\n+    }\n+    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      fsd.setFileEncryptionInfo(src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
            "oldMethodName": "startFileInternal",
            "newMethodName": "startFile"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
          "commitDate": "21/05/15 8:08 AM",
          "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/05/15 7:44 AM",
          "commitNameOld": "0305316d6932e6f1a05021354d77b6934e57e171",
          "commitAuthorOld": "Devaraj K",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,119 +1,125 @@\n-  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n-      INodesInPath iip, PermissionStatus permissions, String holder,\n-      String clientMachine, boolean create, boolean overwrite, \n-      boolean createParent, short replication, long blockSize, \n-      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n-      EncryptedKeyVersion edek, boolean logRetryEntry)\n+  static HdfsFileStatus startFile(\n+      FSNamesystem fsn, FSPermissionChecker pc, String src,\n+      PermissionStatus permissions, String holder, String clientMachine,\n+      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n+      short replication, long blockSize,\n+      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n+      boolean logRetryEntry)\n       throws IOException {\n-    assert hasWriteLock();\n+    assert fsn.hasWriteLock();\n+\n+    boolean create \u003d flag.contains(CreateFlag.CREATE);\n+    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n+    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n+\n+    CipherSuite suite \u003d null;\n+    CryptoProtocolVersion version \u003d null;\n+    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n+\n+    if (ezInfo !\u003d null) {\n+      edek \u003d ezInfo.edek;\n+      suite \u003d ezInfo.suite;\n+      version \u003d ezInfo.protocolVersion;\n+    }\n+\n+    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n+    FSDirectory fsd \u003d fsn.getFSDirectory();\n+    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n+    src \u003d fsd.resolvePath(pc, src, pathComponents);\n+    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-    if (isPermissionEnabled) {\n+    if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n-        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n-       * To overwrite existing file, need to check \u0027w\u0027 permission \n+       * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n-      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n+      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n+\n     if (!createParent) {\n-      dir.verifyParentDir(iip, src);\n+      fsd.verifyParentDir(iip, src);\n+    }\n+\n+    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n+      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n+          src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n-    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n+    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n-    try {\n-      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n-      if (myFile \u003d\u003d null) {\n-        if (!create) {\n-          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n-              src + \" for client \" + clientMachine);\n+    if (myFile !\u003d null) {\n+      if (overwrite) {\n+        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n+        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n+        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n+                                        toRemoveINodes, toRemoveUCFiles, now());\n+        if (ret \u003e\u003d 0) {\n+          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n+          FSDirDeleteOp.incrDeletedFileCount(ret);\n+          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n-        if (overwrite) {\n-          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n-          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n-          List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n-          long ret \u003d FSDirDeleteOp.delete(\n-              dir, iip, toRemoveBlocks, toRemoveINodes,\n-              toRemoveUCFiles, now());\n-          if (ret \u003e\u003d 0) {\n-            iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n-            FSDirDeleteOp.incrDeletedFileCount(ret);\n-            removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n-          }\n-        } else {\n-          // If lease soft limit time is expired, recover the lease\n-          recoverLeaseInternal(RecoverLeaseOp.CREATE_FILE,\n-              iip, src, holder, clientMachine, false);\n-          throw new FileAlreadyExistsException(src + \" for client \" +\n-              clientMachine + \" already exists\");\n-        }\n+        // If lease soft limit time is expired, recover the lease\n+        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n+                                 src, holder, clientMachine, false);\n+        throw new FileAlreadyExistsException(src + \" for client \" +\n+            clientMachine + \" already exists\");\n       }\n-\n-      checkFsObjectLimit();\n-      INodeFile newNode \u003d null;\n-\n-      // Always do an implicit mkdirs for parent directory tree.\n-      Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n-          .createAncestorDirectories(dir, iip, permissions);\n-      if (parent !\u003d null) {\n-        iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n-            replication, blockSize, holder, clientMachine);\n-        newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n-      }\n-\n-      if (newNode \u003d\u003d null) {\n-        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n-      }\n-      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n-          .getClientName(), newNode.getId());\n-\n-      // Set encryption attributes if necessary\n-      if (feInfo !\u003d null) {\n-        dir.setFileEncryptionInfo(src, feInfo);\n-        newNode \u003d dir.getInode(newNode.getId()).asFile();\n-      }\n-\n-      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n-\n-      // record file record in log, record new generation stamp\n-      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n-      if (NameNode.stateChangeLog.isDebugEnabled()) {\n-        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n-            src + \" inode \" + newNode.getId() + \" \" + holder);\n-      }\n-      return toRemoveBlocks;\n-    } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n-                                       ie.getMessage());\n-      throw ie;\n     }\n+    fsn.checkFsObjectLimit();\n+    INodeFile newNode \u003d null;\n+    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n+        .createAncestorDirectories(fsd, iip, permissions);\n+    if (parent !\u003d null) {\n+      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n+                    replication, blockSize, holder, clientMachine);\n+      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n+    }\n+    if (newNode \u003d\u003d null) {\n+      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n+    }\n+    fsn.leaseManager.addLease(\n+        newNode.getFileUnderConstructionFeature().getClientName(),\n+        newNode.getId());\n+    if (feInfo !\u003d null) {\n+      fsd.setFileEncryptionInfo(src, feInfo);\n+      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n+    }\n+    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n+                             isLazyPersist);\n+    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n+    if (NameNode.stateChangeLog.isDebugEnabled()) {\n+      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n+          src + \" inode \" + newNode.getId() + \" \" + holder);\n+    }\n+    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      fsd.setFileEncryptionInfo(src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "BlocksMapUpdateInfo",
            "newValue": "HdfsFileStatus"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
          "commitDate": "21/05/15 8:08 AM",
          "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/05/15 7:44 AM",
          "commitNameOld": "0305316d6932e6f1a05021354d77b6934e57e171",
          "commitAuthorOld": "Devaraj K",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,119 +1,125 @@\n-  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n-      INodesInPath iip, PermissionStatus permissions, String holder,\n-      String clientMachine, boolean create, boolean overwrite, \n-      boolean createParent, short replication, long blockSize, \n-      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n-      EncryptedKeyVersion edek, boolean logRetryEntry)\n+  static HdfsFileStatus startFile(\n+      FSNamesystem fsn, FSPermissionChecker pc, String src,\n+      PermissionStatus permissions, String holder, String clientMachine,\n+      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n+      short replication, long blockSize,\n+      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n+      boolean logRetryEntry)\n       throws IOException {\n-    assert hasWriteLock();\n+    assert fsn.hasWriteLock();\n+\n+    boolean create \u003d flag.contains(CreateFlag.CREATE);\n+    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n+    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n+\n+    CipherSuite suite \u003d null;\n+    CryptoProtocolVersion version \u003d null;\n+    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n+\n+    if (ezInfo !\u003d null) {\n+      edek \u003d ezInfo.edek;\n+      suite \u003d ezInfo.suite;\n+      version \u003d ezInfo.protocolVersion;\n+    }\n+\n+    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n+    FSDirectory fsd \u003d fsn.getFSDirectory();\n+    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n+    src \u003d fsd.resolvePath(pc, src, pathComponents);\n+    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-    if (isPermissionEnabled) {\n+    if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n-        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n-       * To overwrite existing file, need to check \u0027w\u0027 permission \n+       * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n-      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n+      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n+\n     if (!createParent) {\n-      dir.verifyParentDir(iip, src);\n+      fsd.verifyParentDir(iip, src);\n+    }\n+\n+    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n+      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n+          src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n-    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n+    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n-    try {\n-      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n-      if (myFile \u003d\u003d null) {\n-        if (!create) {\n-          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n-              src + \" for client \" + clientMachine);\n+    if (myFile !\u003d null) {\n+      if (overwrite) {\n+        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n+        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n+        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n+                                        toRemoveINodes, toRemoveUCFiles, now());\n+        if (ret \u003e\u003d 0) {\n+          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n+          FSDirDeleteOp.incrDeletedFileCount(ret);\n+          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n-        if (overwrite) {\n-          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n-          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n-          List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n-          long ret \u003d FSDirDeleteOp.delete(\n-              dir, iip, toRemoveBlocks, toRemoveINodes,\n-              toRemoveUCFiles, now());\n-          if (ret \u003e\u003d 0) {\n-            iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n-            FSDirDeleteOp.incrDeletedFileCount(ret);\n-            removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n-          }\n-        } else {\n-          // If lease soft limit time is expired, recover the lease\n-          recoverLeaseInternal(RecoverLeaseOp.CREATE_FILE,\n-              iip, src, holder, clientMachine, false);\n-          throw new FileAlreadyExistsException(src + \" for client \" +\n-              clientMachine + \" already exists\");\n-        }\n+        // If lease soft limit time is expired, recover the lease\n+        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n+                                 src, holder, clientMachine, false);\n+        throw new FileAlreadyExistsException(src + \" for client \" +\n+            clientMachine + \" already exists\");\n       }\n-\n-      checkFsObjectLimit();\n-      INodeFile newNode \u003d null;\n-\n-      // Always do an implicit mkdirs for parent directory tree.\n-      Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n-          .createAncestorDirectories(dir, iip, permissions);\n-      if (parent !\u003d null) {\n-        iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n-            replication, blockSize, holder, clientMachine);\n-        newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n-      }\n-\n-      if (newNode \u003d\u003d null) {\n-        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n-      }\n-      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n-          .getClientName(), newNode.getId());\n-\n-      // Set encryption attributes if necessary\n-      if (feInfo !\u003d null) {\n-        dir.setFileEncryptionInfo(src, feInfo);\n-        newNode \u003d dir.getInode(newNode.getId()).asFile();\n-      }\n-\n-      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n-\n-      // record file record in log, record new generation stamp\n-      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n-      if (NameNode.stateChangeLog.isDebugEnabled()) {\n-        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n-            src + \" inode \" + newNode.getId() + \" \" + holder);\n-      }\n-      return toRemoveBlocks;\n-    } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n-                                       ie.getMessage());\n-      throw ie;\n     }\n+    fsn.checkFsObjectLimit();\n+    INodeFile newNode \u003d null;\n+    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n+        .createAncestorDirectories(fsd, iip, permissions);\n+    if (parent !\u003d null) {\n+      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n+                    replication, blockSize, holder, clientMachine);\n+      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n+    }\n+    if (newNode \u003d\u003d null) {\n+      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n+    }\n+    fsn.leaseManager.addLease(\n+        newNode.getFileUnderConstructionFeature().getClientName(),\n+        newNode.getId());\n+    if (feInfo !\u003d null) {\n+      fsd.setFileEncryptionInfo(src, feInfo);\n+      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n+    }\n+    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n+                             isLazyPersist);\n+    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n+    if (NameNode.stateChangeLog.isDebugEnabled()) {\n+      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n+          src + \" inode \" + newNode.getId() + \" \" + holder);\n+    }\n+    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      fsd.setFileEncryptionInfo(src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
          "commitDate": "21/05/15 8:08 AM",
          "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/05/15 7:44 AM",
          "commitNameOld": "0305316d6932e6f1a05021354d77b6934e57e171",
          "commitAuthorOld": "Devaraj K",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,119 +1,125 @@\n-  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n-      INodesInPath iip, PermissionStatus permissions, String holder,\n-      String clientMachine, boolean create, boolean overwrite, \n-      boolean createParent, short replication, long blockSize, \n-      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n-      EncryptedKeyVersion edek, boolean logRetryEntry)\n+  static HdfsFileStatus startFile(\n+      FSNamesystem fsn, FSPermissionChecker pc, String src,\n+      PermissionStatus permissions, String holder, String clientMachine,\n+      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n+      short replication, long blockSize,\n+      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n+      boolean logRetryEntry)\n       throws IOException {\n-    assert hasWriteLock();\n+    assert fsn.hasWriteLock();\n+\n+    boolean create \u003d flag.contains(CreateFlag.CREATE);\n+    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n+    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n+\n+    CipherSuite suite \u003d null;\n+    CryptoProtocolVersion version \u003d null;\n+    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n+\n+    if (ezInfo !\u003d null) {\n+      edek \u003d ezInfo.edek;\n+      suite \u003d ezInfo.suite;\n+      version \u003d ezInfo.protocolVersion;\n+    }\n+\n+    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n+    FSDirectory fsd \u003d fsn.getFSDirectory();\n+    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n+    src \u003d fsd.resolvePath(pc, src, pathComponents);\n+    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-    if (isPermissionEnabled) {\n+    if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n-        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n-       * To overwrite existing file, need to check \u0027w\u0027 permission \n+       * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n-      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n+      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n+\n     if (!createParent) {\n-      dir.verifyParentDir(iip, src);\n+      fsd.verifyParentDir(iip, src);\n+    }\n+\n+    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n+      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n+          src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n-    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n+    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n-    try {\n-      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n-      if (myFile \u003d\u003d null) {\n-        if (!create) {\n-          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n-              src + \" for client \" + clientMachine);\n+    if (myFile !\u003d null) {\n+      if (overwrite) {\n+        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n+        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n+        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n+                                        toRemoveINodes, toRemoveUCFiles, now());\n+        if (ret \u003e\u003d 0) {\n+          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n+          FSDirDeleteOp.incrDeletedFileCount(ret);\n+          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n-        if (overwrite) {\n-          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n-          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n-          List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n-          long ret \u003d FSDirDeleteOp.delete(\n-              dir, iip, toRemoveBlocks, toRemoveINodes,\n-              toRemoveUCFiles, now());\n-          if (ret \u003e\u003d 0) {\n-            iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n-            FSDirDeleteOp.incrDeletedFileCount(ret);\n-            removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n-          }\n-        } else {\n-          // If lease soft limit time is expired, recover the lease\n-          recoverLeaseInternal(RecoverLeaseOp.CREATE_FILE,\n-              iip, src, holder, clientMachine, false);\n-          throw new FileAlreadyExistsException(src + \" for client \" +\n-              clientMachine + \" already exists\");\n-        }\n+        // If lease soft limit time is expired, recover the lease\n+        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n+                                 src, holder, clientMachine, false);\n+        throw new FileAlreadyExistsException(src + \" for client \" +\n+            clientMachine + \" already exists\");\n       }\n-\n-      checkFsObjectLimit();\n-      INodeFile newNode \u003d null;\n-\n-      // Always do an implicit mkdirs for parent directory tree.\n-      Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n-          .createAncestorDirectories(dir, iip, permissions);\n-      if (parent !\u003d null) {\n-        iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n-            replication, blockSize, holder, clientMachine);\n-        newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n-      }\n-\n-      if (newNode \u003d\u003d null) {\n-        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n-      }\n-      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n-          .getClientName(), newNode.getId());\n-\n-      // Set encryption attributes if necessary\n-      if (feInfo !\u003d null) {\n-        dir.setFileEncryptionInfo(src, feInfo);\n-        newNode \u003d dir.getInode(newNode.getId()).asFile();\n-      }\n-\n-      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n-\n-      // record file record in log, record new generation stamp\n-      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n-      if (NameNode.stateChangeLog.isDebugEnabled()) {\n-        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n-            src + \" inode \" + newNode.getId() + \" \" + holder);\n-      }\n-      return toRemoveBlocks;\n-    } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n-                                       ie.getMessage());\n-      throw ie;\n     }\n+    fsn.checkFsObjectLimit();\n+    INodeFile newNode \u003d null;\n+    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n+        .createAncestorDirectories(fsd, iip, permissions);\n+    if (parent !\u003d null) {\n+      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n+                    replication, blockSize, holder, clientMachine);\n+      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n+    }\n+    if (newNode \u003d\u003d null) {\n+      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n+    }\n+    fsn.leaseManager.addLease(\n+        newNode.getFileUnderConstructionFeature().getClientName(),\n+        newNode.getId());\n+    if (feInfo !\u003d null) {\n+      fsd.setFileEncryptionInfo(src, feInfo);\n+      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n+    }\n+    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n+                             isLazyPersist);\n+    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n+    if (NameNode.stateChangeLog.isDebugEnabled()) {\n+      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n+          src + \" inode \" + newNode.getId() + \" \" + holder);\n+    }\n+    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      fsd.setFileEncryptionInfo(src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yrename",
          "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
          "commitDate": "21/05/15 8:08 AM",
          "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/05/15 7:44 AM",
          "commitNameOld": "0305316d6932e6f1a05021354d77b6934e57e171",
          "commitAuthorOld": "Devaraj K",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,119 +1,125 @@\n-  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n-      INodesInPath iip, PermissionStatus permissions, String holder,\n-      String clientMachine, boolean create, boolean overwrite, \n-      boolean createParent, short replication, long blockSize, \n-      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n-      EncryptedKeyVersion edek, boolean logRetryEntry)\n+  static HdfsFileStatus startFile(\n+      FSNamesystem fsn, FSPermissionChecker pc, String src,\n+      PermissionStatus permissions, String holder, String clientMachine,\n+      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n+      short replication, long blockSize,\n+      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n+      boolean logRetryEntry)\n       throws IOException {\n-    assert hasWriteLock();\n+    assert fsn.hasWriteLock();\n+\n+    boolean create \u003d flag.contains(CreateFlag.CREATE);\n+    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n+    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n+\n+    CipherSuite suite \u003d null;\n+    CryptoProtocolVersion version \u003d null;\n+    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n+\n+    if (ezInfo !\u003d null) {\n+      edek \u003d ezInfo.edek;\n+      suite \u003d ezInfo.suite;\n+      version \u003d ezInfo.protocolVersion;\n+    }\n+\n+    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n+    FSDirectory fsd \u003d fsn.getFSDirectory();\n+    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n+    src \u003d fsd.resolvePath(pc, src, pathComponents);\n+    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-    if (isPermissionEnabled) {\n+    if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n-        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n-       * To overwrite existing file, need to check \u0027w\u0027 permission \n+       * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n-      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n+      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n+\n     if (!createParent) {\n-      dir.verifyParentDir(iip, src);\n+      fsd.verifyParentDir(iip, src);\n+    }\n+\n+    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n+      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n+          src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n-    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n+    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n-    try {\n-      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n-      if (myFile \u003d\u003d null) {\n-        if (!create) {\n-          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n-              src + \" for client \" + clientMachine);\n+    if (myFile !\u003d null) {\n+      if (overwrite) {\n+        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n+        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n+        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n+                                        toRemoveINodes, toRemoveUCFiles, now());\n+        if (ret \u003e\u003d 0) {\n+          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n+          FSDirDeleteOp.incrDeletedFileCount(ret);\n+          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n-        if (overwrite) {\n-          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n-          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n-          List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n-          long ret \u003d FSDirDeleteOp.delete(\n-              dir, iip, toRemoveBlocks, toRemoveINodes,\n-              toRemoveUCFiles, now());\n-          if (ret \u003e\u003d 0) {\n-            iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n-            FSDirDeleteOp.incrDeletedFileCount(ret);\n-            removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n-          }\n-        } else {\n-          // If lease soft limit time is expired, recover the lease\n-          recoverLeaseInternal(RecoverLeaseOp.CREATE_FILE,\n-              iip, src, holder, clientMachine, false);\n-          throw new FileAlreadyExistsException(src + \" for client \" +\n-              clientMachine + \" already exists\");\n-        }\n+        // If lease soft limit time is expired, recover the lease\n+        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n+                                 src, holder, clientMachine, false);\n+        throw new FileAlreadyExistsException(src + \" for client \" +\n+            clientMachine + \" already exists\");\n       }\n-\n-      checkFsObjectLimit();\n-      INodeFile newNode \u003d null;\n-\n-      // Always do an implicit mkdirs for parent directory tree.\n-      Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n-          .createAncestorDirectories(dir, iip, permissions);\n-      if (parent !\u003d null) {\n-        iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n-            replication, blockSize, holder, clientMachine);\n-        newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n-      }\n-\n-      if (newNode \u003d\u003d null) {\n-        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n-      }\n-      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n-          .getClientName(), newNode.getId());\n-\n-      // Set encryption attributes if necessary\n-      if (feInfo !\u003d null) {\n-        dir.setFileEncryptionInfo(src, feInfo);\n-        newNode \u003d dir.getInode(newNode.getId()).asFile();\n-      }\n-\n-      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n-\n-      // record file record in log, record new generation stamp\n-      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n-      if (NameNode.stateChangeLog.isDebugEnabled()) {\n-        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n-            src + \" inode \" + newNode.getId() + \" \" + holder);\n-      }\n-      return toRemoveBlocks;\n-    } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n-                                       ie.getMessage());\n-      throw ie;\n     }\n+    fsn.checkFsObjectLimit();\n+    INodeFile newNode \u003d null;\n+    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n+        .createAncestorDirectories(fsd, iip, permissions);\n+    if (parent !\u003d null) {\n+      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n+                    replication, blockSize, holder, clientMachine);\n+      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n+    }\n+    if (newNode \u003d\u003d null) {\n+      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n+    }\n+    fsn.leaseManager.addLease(\n+        newNode.getFileUnderConstructionFeature().getClientName(),\n+        newNode.getId());\n+    if (feInfo !\u003d null) {\n+      fsd.setFileEncryptionInfo(src, feInfo);\n+      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n+    }\n+    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n+                             isLazyPersist);\n+    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n+    if (NameNode.stateChangeLog.isDebugEnabled()) {\n+      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n+          src + \" inode \" + newNode.getId() + \" \" + holder);\n+    }\n+    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      fsd.setFileEncryptionInfo(src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "startFileInternal",
            "newValue": "startFile"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8421. Move startFile() and related functions into FSDirWriteFileOp. Contributed by Haohui Mai.\n",
          "commitDate": "21/05/15 8:08 AM",
          "commitName": "2b6bcfdafa91223a4116e3e9304579f5f91dccac",
          "commitAuthor": "Haohui Mai",
          "commitDateOld": "21/05/15 7:44 AM",
          "commitNameOld": "0305316d6932e6f1a05021354d77b6934e57e171",
          "commitAuthorOld": "Devaraj K",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,119 +1,125 @@\n-  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n-      INodesInPath iip, PermissionStatus permissions, String holder,\n-      String clientMachine, boolean create, boolean overwrite, \n-      boolean createParent, short replication, long blockSize, \n-      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n-      EncryptedKeyVersion edek, boolean logRetryEntry)\n+  static HdfsFileStatus startFile(\n+      FSNamesystem fsn, FSPermissionChecker pc, String src,\n+      PermissionStatus permissions, String holder, String clientMachine,\n+      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n+      short replication, long blockSize,\n+      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n+      boolean logRetryEntry)\n       throws IOException {\n-    assert hasWriteLock();\n+    assert fsn.hasWriteLock();\n+\n+    boolean create \u003d flag.contains(CreateFlag.CREATE);\n+    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n+    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n+\n+    CipherSuite suite \u003d null;\n+    CryptoProtocolVersion version \u003d null;\n+    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n+\n+    if (ezInfo !\u003d null) {\n+      edek \u003d ezInfo.edek;\n+      suite \u003d ezInfo.suite;\n+      version \u003d ezInfo.protocolVersion;\n+    }\n+\n+    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n+    FSDirectory fsd \u003d fsn.getFSDirectory();\n+    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n+    src \u003d fsd.resolvePath(pc, src, pathComponents);\n+    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n+\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n-    final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-    if (isPermissionEnabled) {\n+    if (fsd.isPermissionEnabled()) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n-        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n+        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n-       * To overwrite existing file, need to check \u0027w\u0027 permission \n+       * To overwrite existing file, need to check \u0027w\u0027 permission\n        * of parent (equals to ancestor in this case)\n        */\n-      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n+      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n+\n     if (!createParent) {\n-      dir.verifyParentDir(iip, src);\n+      fsd.verifyParentDir(iip, src);\n+    }\n+\n+    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n+      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n+          src + \" for client \" + clientMachine);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n-    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n+    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n-    try {\n-      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n-      if (myFile \u003d\u003d null) {\n-        if (!create) {\n-          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n-              src + \" for client \" + clientMachine);\n+    if (myFile !\u003d null) {\n+      if (overwrite) {\n+        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n+        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n+        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n+                                        toRemoveINodes, toRemoveUCFiles, now());\n+        if (ret \u003e\u003d 0) {\n+          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n+          FSDirDeleteOp.incrDeletedFileCount(ret);\n+          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n         }\n       } else {\n-        if (overwrite) {\n-          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n-          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n-          List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n-          long ret \u003d FSDirDeleteOp.delete(\n-              dir, iip, toRemoveBlocks, toRemoveINodes,\n-              toRemoveUCFiles, now());\n-          if (ret \u003e\u003d 0) {\n-            iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n-            FSDirDeleteOp.incrDeletedFileCount(ret);\n-            removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n-          }\n-        } else {\n-          // If lease soft limit time is expired, recover the lease\n-          recoverLeaseInternal(RecoverLeaseOp.CREATE_FILE,\n-              iip, src, holder, clientMachine, false);\n-          throw new FileAlreadyExistsException(src + \" for client \" +\n-              clientMachine + \" already exists\");\n-        }\n+        // If lease soft limit time is expired, recover the lease\n+        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n+                                 src, holder, clientMachine, false);\n+        throw new FileAlreadyExistsException(src + \" for client \" +\n+            clientMachine + \" already exists\");\n       }\n-\n-      checkFsObjectLimit();\n-      INodeFile newNode \u003d null;\n-\n-      // Always do an implicit mkdirs for parent directory tree.\n-      Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n-          .createAncestorDirectories(dir, iip, permissions);\n-      if (parent !\u003d null) {\n-        iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n-            replication, blockSize, holder, clientMachine);\n-        newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n-      }\n-\n-      if (newNode \u003d\u003d null) {\n-        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n-      }\n-      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n-          .getClientName(), newNode.getId());\n-\n-      // Set encryption attributes if necessary\n-      if (feInfo !\u003d null) {\n-        dir.setFileEncryptionInfo(src, feInfo);\n-        newNode \u003d dir.getInode(newNode.getId()).asFile();\n-      }\n-\n-      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n-\n-      // record file record in log, record new generation stamp\n-      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n-      if (NameNode.stateChangeLog.isDebugEnabled()) {\n-        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n-            src + \" inode \" + newNode.getId() + \" \" + holder);\n-      }\n-      return toRemoveBlocks;\n-    } catch (IOException ie) {\n-      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n-                                       ie.getMessage());\n-      throw ie;\n     }\n+    fsn.checkFsObjectLimit();\n+    INodeFile newNode \u003d null;\n+    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n+        .createAncestorDirectories(fsd, iip, permissions);\n+    if (parent !\u003d null) {\n+      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n+                    replication, blockSize, holder, clientMachine);\n+      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n+    }\n+    if (newNode \u003d\u003d null) {\n+      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n+    }\n+    fsn.leaseManager.addLease(\n+        newNode.getFileUnderConstructionFeature().getClientName(),\n+        newNode.getId());\n+    if (feInfo !\u003d null) {\n+      fsd.setFileEncryptionInfo(src, feInfo);\n+      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n+    }\n+    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n+                             isLazyPersist);\n+    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n+    if (NameNode.stateChangeLog.isDebugEnabled()) {\n+      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n+          src + \" inode \" + newNode.getId() + \" \" + holder);\n+    }\n+    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus startFile(\n      FSNamesystem fsn, FSPermissionChecker pc, String src,\n      PermissionStatus permissions, String holder, String clientMachine,\n      EnumSet\u003cCreateFlag\u003e flag, boolean createParent,\n      short replication, long blockSize,\n      EncryptionKeyInfo ezInfo, INode.BlocksMapUpdateInfo toRemoveBlocks,\n      boolean logRetryEntry)\n      throws IOException {\n    assert fsn.hasWriteLock();\n\n    boolean create \u003d flag.contains(CreateFlag.CREATE);\n    boolean overwrite \u003d flag.contains(CreateFlag.OVERWRITE);\n    boolean isLazyPersist \u003d flag.contains(CreateFlag.LAZY_PERSIST);\n\n    CipherSuite suite \u003d null;\n    CryptoProtocolVersion version \u003d null;\n    KeyProviderCryptoExtension.EncryptedKeyVersion edek \u003d null;\n\n    if (ezInfo !\u003d null) {\n      edek \u003d ezInfo.edek;\n      suite \u003d ezInfo.suite;\n      version \u003d ezInfo.protocolVersion;\n    }\n\n    boolean isRawPath \u003d FSDirectory.isReservedRawName(src);\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    byte[][] pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    INodesInPath iip \u003d fsd.getINodesInPath4Write(src);\n\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (fsd.isPermissionEnabled()) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        fsd.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission\n       * of parent (equals to ancestor in this case)\n       */\n      fsd.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      fsd.verifyParentDir(iip, src);\n    }\n\n    if (myFile \u003d\u003d null \u0026\u0026 !create) {\n      throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n          src + \" for client \" + clientMachine);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d fsd.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    if (myFile !\u003d null) {\n      if (overwrite) {\n        List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n        List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n        long ret \u003d FSDirDeleteOp.delete(fsd, iip, toRemoveBlocks,\n                                        toRemoveINodes, toRemoveUCFiles, now());\n        if (ret \u003e\u003d 0) {\n          iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n          FSDirDeleteOp.incrDeletedFileCount(ret);\n          fsn.removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n        }\n      } else {\n        // If lease soft limit time is expired, recover the lease\n        fsn.recoverLeaseInternal(FSNamesystem.RecoverLeaseOp.CREATE_FILE, iip,\n                                 src, holder, clientMachine, false);\n        throw new FileAlreadyExistsException(src + \" for client \" +\n            clientMachine + \" already exists\");\n      }\n    }\n    fsn.checkFsObjectLimit();\n    INodeFile newNode \u003d null;\n    Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n        .createAncestorDirectories(fsd, iip, permissions);\n    if (parent !\u003d null) {\n      iip \u003d addFile(fsd, parent.getKey(), parent.getValue(), permissions,\n                    replication, blockSize, holder, clientMachine);\n      newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n    }\n    if (newNode \u003d\u003d null) {\n      throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n    }\n    fsn.leaseManager.addLease(\n        newNode.getFileUnderConstructionFeature().getClientName(),\n        newNode.getId());\n    if (feInfo !\u003d null) {\n      fsd.setFileEncryptionInfo(src, feInfo);\n      newNode \u003d fsd.getInode(newNode.getId()).asFile();\n    }\n    setNewINodeStoragePolicy(fsn.getBlockManager(), newNode, iip,\n                             isLazyPersist);\n    fsd.getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n    if (NameNode.stateChangeLog.isDebugEnabled()) {\n      NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n          src + \" inode \" + newNode.getId() + \" \" + holder);\n    }\n    return FSDirStatAndListingOp.getFileInfo(fsd, src, false, isRawPath, true);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirWriteFileOp.java",
          "extendedDetails": {
            "oldValue": "[pc-FSPermissionChecker, iip-INodesInPath, permissions-PermissionStatus, holder-String, clientMachine-String, create-boolean, overwrite-boolean, createParent-boolean, replication-short, blockSize-long, isLazyPersist-boolean, suite-CipherSuite, version-CryptoProtocolVersion, edek-EncryptedKeyVersion, logRetryEntry-boolean]",
            "newValue": "[fsn-FSNamesystem, pc-FSPermissionChecker, src-String, permissions-PermissionStatus, holder-String, clientMachine-String, flag-EnumSet\u003cCreateFlag\u003e, createParent-boolean, replication-short, blockSize-long, ezInfo-EncryptionKeyInfo, toRemoveBlocks-INode.BlocksMapUpdateInfo, logRetryEntry-boolean]"
          }
        }
      ]
    },
    "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6757. Simplify lease manager with INodeID. Contributed by Haohui Mai.\n",
      "commitDate": "08/05/15 11:04 PM",
      "commitName": "00fe1ed3a4b3ee35fe24be257ec36445d2f44d63",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "08/05/15 7:30 AM",
      "commitNameOld": "6f622672b62aa8d719060063ef0e47480cdc8655",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.65,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,119 @@\n   private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n       INodesInPath iip, PermissionStatus permissions, String holder,\n       String clientMachine, boolean create, boolean overwrite, \n       boolean createParent, short replication, long blockSize, \n       boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n       EncryptedKeyVersion edek, boolean logRetryEntry)\n       throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (isPermissionEnabled) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         dir.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission \n        * of parent (equals to ancestor in this case)\n        */\n       dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n     if (!createParent) {\n       dir.verifyParentDir(iip, src);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d dir.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     try {\n       BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n       if (myFile \u003d\u003d null) {\n         if (!create) {\n           throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n               src + \" for client \" + clientMachine);\n         }\n       } else {\n         if (overwrite) {\n           toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n-          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n-          long ret \u003d FSDirDeleteOp.delete(dir, iip, toRemoveBlocks,\n-                                          toRemoveINodes, now());\n+          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n+          List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n+          long ret \u003d FSDirDeleteOp.delete(\n+              dir, iip, toRemoveBlocks, toRemoveINodes,\n+              toRemoveUCFiles, now());\n           if (ret \u003e\u003d 0) {\n             iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n             FSDirDeleteOp.incrDeletedFileCount(ret);\n-            removeLeasesAndINodes(src, toRemoveINodes, true);\n+            removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n           }\n         } else {\n           // If lease soft limit time is expired, recover the lease\n           recoverLeaseInternal(RecoverLeaseOp.CREATE_FILE,\n               iip, src, holder, clientMachine, false);\n           throw new FileAlreadyExistsException(src + \" for client \" +\n               clientMachine + \" already exists\");\n         }\n       }\n \n       checkFsObjectLimit();\n       INodeFile newNode \u003d null;\n \n       // Always do an implicit mkdirs for parent directory tree.\n       Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n           .createAncestorDirectories(dir, iip, permissions);\n       if (parent !\u003d null) {\n         iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n             replication, blockSize, holder, clientMachine);\n         newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n       }\n \n       if (newNode \u003d\u003d null) {\n         throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n       }\n       leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n-          .getClientName(), src);\n+          .getClientName(), newNode.getId());\n \n       // Set encryption attributes if necessary\n       if (feInfo !\u003d null) {\n         dir.setFileEncryptionInfo(src, feInfo);\n         newNode \u003d dir.getInode(newNode.getId()).asFile();\n       }\n \n       setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n \n       // record file record in log, record new generation stamp\n       getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n       if (NameNode.stateChangeLog.isDebugEnabled()) {\n         NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n             src + \" inode \" + newNode.getId() + \" \" + holder);\n       }\n       return toRemoveBlocks;\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n           ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n      INodesInPath iip, PermissionStatus permissions, String holder,\n      String clientMachine, boolean create, boolean overwrite, \n      boolean createParent, short replication, long blockSize, \n      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n      EncryptedKeyVersion edek, boolean logRetryEntry)\n      throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (isPermissionEnabled) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission \n       * of parent (equals to ancestor in this case)\n       */\n      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n    if (!createParent) {\n      dir.verifyParentDir(iip, src);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    try {\n      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n      if (myFile \u003d\u003d null) {\n        if (!create) {\n          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n              src + \" for client \" + clientMachine);\n        }\n      } else {\n        if (overwrite) {\n          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003c\u003e();\n          List\u003cLong\u003e toRemoveUCFiles \u003d new ChunkedArrayList\u003c\u003e();\n          long ret \u003d FSDirDeleteOp.delete(\n              dir, iip, toRemoveBlocks, toRemoveINodes,\n              toRemoveUCFiles, now());\n          if (ret \u003e\u003d 0) {\n            iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n            FSDirDeleteOp.incrDeletedFileCount(ret);\n            removeLeasesAndINodes(toRemoveUCFiles, toRemoveINodes, true);\n          }\n        } else {\n          // If lease soft limit time is expired, recover the lease\n          recoverLeaseInternal(RecoverLeaseOp.CREATE_FILE,\n              iip, src, holder, clientMachine, false);\n          throw new FileAlreadyExistsException(src + \" for client \" +\n              clientMachine + \" already exists\");\n        }\n      }\n\n      checkFsObjectLimit();\n      INodeFile newNode \u003d null;\n\n      // Always do an implicit mkdirs for parent directory tree.\n      Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n          .createAncestorDirectories(dir, iip, permissions);\n      if (parent !\u003d null) {\n        iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n            replication, blockSize, holder, clientMachine);\n        newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n      }\n\n      if (newNode \u003d\u003d null) {\n        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n      }\n      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n          .getClientName(), newNode.getId());\n\n      // Set encryption attributes if necessary\n      if (feInfo !\u003d null) {\n        dir.setFileEncryptionInfo(src, feInfo);\n        newNode \u003d dir.getInode(newNode.getId()).asFile();\n      }\n\n      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n\n      // record file record in log, record new generation stamp\n      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n      if (NameNode.stateChangeLog.isDebugEnabled()) {\n        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n            src + \" inode \" + newNode.getId() + \" \" + holder);\n      }\n      return toRemoveBlocks;\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n          ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "8f7d4bb09f760780dd193c97796ebf4d22cfd2d7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7738. Revise the exception message for recover lease; add more truncate tests such as truncate with HA setup, negative tests, truncate with other operations and multiple truncates.\n",
      "commitDate": "07/02/15 3:21 PM",
      "commitName": "8f7d4bb09f760780dd193c97796ebf4d22cfd2d7",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "03/02/15 12:45 PM",
      "commitNameOld": "843806d03ab1a24f191782f42eb817505228eb9f",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 4.11,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,117 @@\n   private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n       INodesInPath iip, PermissionStatus permissions, String holder,\n       String clientMachine, boolean create, boolean overwrite, \n       boolean createParent, short replication, long blockSize, \n       boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n       EncryptedKeyVersion edek, boolean logRetryEntry)\n       throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (isPermissionEnabled) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         dir.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission \n        * of parent (equals to ancestor in this case)\n        */\n       dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n     if (!createParent) {\n       dir.verifyParentDir(iip, src);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d dir.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     try {\n       BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n       if (myFile \u003d\u003d null) {\n         if (!create) {\n           throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n               src + \" for client \" + clientMachine);\n         }\n       } else {\n         if (overwrite) {\n           toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           long ret \u003d FSDirDeleteOp.delete(dir, iip, toRemoveBlocks,\n                                           toRemoveINodes, now());\n           if (ret \u003e\u003d 0) {\n             iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n             FSDirDeleteOp.incrDeletedFileCount(ret);\n             removeLeasesAndINodes(src, toRemoveINodes, true);\n           }\n         } else {\n           // If lease soft limit time is expired, recover the lease\n-          recoverLeaseInternal(iip, src, holder, clientMachine, false);\n+          recoverLeaseInternal(RecoverLeaseOp.CREATE_FILE,\n+              iip, src, holder, clientMachine, false);\n           throw new FileAlreadyExistsException(src + \" for client \" +\n               clientMachine + \" already exists\");\n         }\n       }\n \n       checkFsObjectLimit();\n       INodeFile newNode \u003d null;\n \n       // Always do an implicit mkdirs for parent directory tree.\n       Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n           .createAncestorDirectories(dir, iip, permissions);\n       if (parent !\u003d null) {\n         iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n             replication, blockSize, holder, clientMachine);\n         newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n       }\n \n       if (newNode \u003d\u003d null) {\n         throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n       }\n       leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n           .getClientName(), src);\n \n       // Set encryption attributes if necessary\n       if (feInfo !\u003d null) {\n         dir.setFileEncryptionInfo(src, feInfo);\n         newNode \u003d dir.getInode(newNode.getId()).asFile();\n       }\n \n       setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n \n       // record file record in log, record new generation stamp\n       getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n       if (NameNode.stateChangeLog.isDebugEnabled()) {\n         NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n             src + \" inode \" + newNode.getId() + \" \" + holder);\n       }\n       return toRemoveBlocks;\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n           ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n      INodesInPath iip, PermissionStatus permissions, String holder,\n      String clientMachine, boolean create, boolean overwrite, \n      boolean createParent, short replication, long blockSize, \n      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n      EncryptedKeyVersion edek, boolean logRetryEntry)\n      throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (isPermissionEnabled) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission \n       * of parent (equals to ancestor in this case)\n       */\n      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n    if (!createParent) {\n      dir.verifyParentDir(iip, src);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    try {\n      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n      if (myFile \u003d\u003d null) {\n        if (!create) {\n          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n              src + \" for client \" + clientMachine);\n        }\n      } else {\n        if (overwrite) {\n          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          long ret \u003d FSDirDeleteOp.delete(dir, iip, toRemoveBlocks,\n                                          toRemoveINodes, now());\n          if (ret \u003e\u003d 0) {\n            iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n            FSDirDeleteOp.incrDeletedFileCount(ret);\n            removeLeasesAndINodes(src, toRemoveINodes, true);\n          }\n        } else {\n          // If lease soft limit time is expired, recover the lease\n          recoverLeaseInternal(RecoverLeaseOp.CREATE_FILE,\n              iip, src, holder, clientMachine, false);\n          throw new FileAlreadyExistsException(src + \" for client \" +\n              clientMachine + \" already exists\");\n        }\n      }\n\n      checkFsObjectLimit();\n      INodeFile newNode \u003d null;\n\n      // Always do an implicit mkdirs for parent directory tree.\n      Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n          .createAncestorDirectories(dir, iip, permissions);\n      if (parent !\u003d null) {\n        iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n            replication, blockSize, holder, clientMachine);\n        newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n      }\n\n      if (newNode \u003d\u003d null) {\n        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n      }\n      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n          .getClientName(), src);\n\n      // Set encryption attributes if necessary\n      if (feInfo !\u003d null) {\n        dir.setFileEncryptionInfo(src, feInfo);\n        newNode \u003d dir.getInode(newNode.getId()).asFile();\n      }\n\n      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n\n      // record file record in log, record new generation stamp\n      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n      if (NameNode.stateChangeLog.isDebugEnabled()) {\n        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n            src + \" inode \" + newNode.getId() + \" \" + holder);\n      }\n      return toRemoveBlocks;\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n          ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "24315e7d374a1ddd4329b64350cf96fc9ab6f59c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7573. Consolidate the implementation of delete() into a single class. Contributed by Haohui Mai.\n",
      "commitDate": "17/01/15 12:56 PM",
      "commitName": "24315e7d374a1ddd4329b64350cf96fc9ab6f59c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "15/01/15 2:39 PM",
      "commitNameOld": "44eed6cbc97649c15177f9b36f6b119cc1900f7a",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 1.93,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,116 @@\n   private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n       INodesInPath iip, PermissionStatus permissions, String holder,\n       String clientMachine, boolean create, boolean overwrite, \n       boolean createParent, short replication, long blockSize, \n       boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n       EncryptedKeyVersion edek, boolean logRetryEntry)\n       throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (isPermissionEnabled) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         dir.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission \n        * of parent (equals to ancestor in this case)\n        */\n       dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n     if (!createParent) {\n       dir.verifyParentDir(iip, src);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d dir.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     try {\n       BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n       if (myFile \u003d\u003d null) {\n         if (!create) {\n           throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n               src + \" for client \" + clientMachine);\n         }\n       } else {\n         if (overwrite) {\n           toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n-          long ret \u003d dir.delete(iip, toRemoveBlocks, toRemoveINodes, now());\n+          long ret \u003d FSDirDeleteOp.delete(dir, iip, toRemoveBlocks,\n+                                          toRemoveINodes, now());\n           if (ret \u003e\u003d 0) {\n             iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n-            incrDeletedFileCount(ret);\n-            removePathAndBlocks(src, null, toRemoveINodes, true);\n+            FSDirDeleteOp.incrDeletedFileCount(ret);\n+            removeLeasesAndINodes(src, toRemoveINodes, true);\n           }\n         } else {\n           // If lease soft limit time is expired, recover the lease\n           recoverLeaseInternal(iip, src, holder, clientMachine, false);\n           throw new FileAlreadyExistsException(src + \" for client \" +\n               clientMachine + \" already exists\");\n         }\n       }\n \n       checkFsObjectLimit();\n       INodeFile newNode \u003d null;\n \n       // Always do an implicit mkdirs for parent directory tree.\n       Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n           .createAncestorDirectories(dir, iip, permissions);\n       if (parent !\u003d null) {\n         iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n             replication, blockSize, holder, clientMachine);\n         newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n       }\n \n       if (newNode \u003d\u003d null) {\n         throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n       }\n       leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n           .getClientName(), src);\n \n       // Set encryption attributes if necessary\n       if (feInfo !\u003d null) {\n         dir.setFileEncryptionInfo(src, feInfo);\n         newNode \u003d dir.getInode(newNode.getId()).asFile();\n       }\n \n       setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n \n       // record file record in log, record new generation stamp\n       getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n       if (NameNode.stateChangeLog.isDebugEnabled()) {\n         NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n             src + \" inode \" + newNode.getId() + \" \" + holder);\n       }\n       return toRemoveBlocks;\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n           ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n      INodesInPath iip, PermissionStatus permissions, String holder,\n      String clientMachine, boolean create, boolean overwrite, \n      boolean createParent, short replication, long blockSize, \n      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n      EncryptedKeyVersion edek, boolean logRetryEntry)\n      throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (isPermissionEnabled) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission \n       * of parent (equals to ancestor in this case)\n       */\n      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n    if (!createParent) {\n      dir.verifyParentDir(iip, src);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    try {\n      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n      if (myFile \u003d\u003d null) {\n        if (!create) {\n          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n              src + \" for client \" + clientMachine);\n        }\n      } else {\n        if (overwrite) {\n          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          long ret \u003d FSDirDeleteOp.delete(dir, iip, toRemoveBlocks,\n                                          toRemoveINodes, now());\n          if (ret \u003e\u003d 0) {\n            iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n            FSDirDeleteOp.incrDeletedFileCount(ret);\n            removeLeasesAndINodes(src, toRemoveINodes, true);\n          }\n        } else {\n          // If lease soft limit time is expired, recover the lease\n          recoverLeaseInternal(iip, src, holder, clientMachine, false);\n          throw new FileAlreadyExistsException(src + \" for client \" +\n              clientMachine + \" already exists\");\n        }\n      }\n\n      checkFsObjectLimit();\n      INodeFile newNode \u003d null;\n\n      // Always do an implicit mkdirs for parent directory tree.\n      Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n          .createAncestorDirectories(dir, iip, permissions);\n      if (parent !\u003d null) {\n        iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n            replication, blockSize, holder, clientMachine);\n        newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n      }\n\n      if (newNode \u003d\u003d null) {\n        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n      }\n      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n          .getClientName(), src);\n\n      // Set encryption attributes if necessary\n      if (feInfo !\u003d null) {\n        dir.setFileEncryptionInfo(src, feInfo);\n        newNode \u003d dir.getInode(newNode.getId()).asFile();\n      }\n\n      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n\n      // record file record in log, record new generation stamp\n      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n      if (NameNode.stateChangeLog.isDebugEnabled()) {\n        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n            src + \" inode \" + newNode.getId() + \" \" + holder);\n      }\n      return toRemoveBlocks;\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n          ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "5caebbae8c2fc9ba2e32384657aee21641a1a6d0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7484. Make FSDirectory#addINode take existing INodes as its parameter. Contributed by Jing Zhao.\n",
      "commitDate": "22/12/14 11:19 PM",
      "commitName": "5caebbae8c2fc9ba2e32384657aee21641a1a6d0",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "18/12/14 11:25 AM",
      "commitNameOld": "65f2a4ee600dfffa5203450261da3c1989de25a9",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 4.5,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,115 @@\n   private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n       INodesInPath iip, PermissionStatus permissions, String holder,\n       String clientMachine, boolean create, boolean overwrite, \n       boolean createParent, short replication, long blockSize, \n       boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n       EncryptedKeyVersion edek, boolean logRetryEntry)\n       throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (isPermissionEnabled) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         dir.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission \n        * of parent (equals to ancestor in this case)\n        */\n       dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n     if (!createParent) {\n       dir.verifyParentDir(iip, src);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d dir.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     try {\n       BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n       if (myFile \u003d\u003d null) {\n         if (!create) {\n           throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n               src + \" for client \" + clientMachine);\n         }\n       } else {\n         if (overwrite) {\n           toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           long ret \u003d dir.delete(iip, toRemoveBlocks, toRemoveINodes, now());\n           if (ret \u003e\u003d 0) {\n+            iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n             incrDeletedFileCount(ret);\n             removePathAndBlocks(src, null, toRemoveINodes, true);\n           }\n         } else {\n           // If lease soft limit time is expired, recover the lease\n           recoverLeaseInternal(iip, src, holder, clientMachine, false);\n           throw new FileAlreadyExistsException(src + \" for client \" +\n               clientMachine + \" already exists\");\n         }\n       }\n \n       checkFsObjectLimit();\n       INodeFile newNode \u003d null;\n \n       // Always do an implicit mkdirs for parent directory tree.\n-      INodesInPath parentIIP \u003d iip.getParentINodesInPath();\n-      if (parentIIP !\u003d null \u0026\u0026 (parentIIP \u003d FSDirMkdirOp.mkdirsRecursively(dir,\n-          parentIIP, permissions, true, now())) !\u003d null) {\n-        iip \u003d INodesInPath.append(parentIIP, newNode, iip.getLastLocalName());\n-        newNode \u003d dir.addFile(iip, src, permissions, replication, blockSize,\n-                              holder, clientMachine);\n+      Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n+          .createAncestorDirectories(dir, iip, permissions);\n+      if (parent !\u003d null) {\n+        iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n+            replication, blockSize, holder, clientMachine);\n+        newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n       }\n \n       if (newNode \u003d\u003d null) {\n         throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n       }\n       leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n           .getClientName(), src);\n \n       // Set encryption attributes if necessary\n       if (feInfo !\u003d null) {\n         dir.setFileEncryptionInfo(src, feInfo);\n         newNode \u003d dir.getInode(newNode.getId()).asFile();\n       }\n \n       setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n \n       // record file record in log, record new generation stamp\n       getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n       if (NameNode.stateChangeLog.isDebugEnabled()) {\n         NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n             src + \" inode \" + newNode.getId() + \" \" + holder);\n       }\n       return toRemoveBlocks;\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n           ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n      INodesInPath iip, PermissionStatus permissions, String holder,\n      String clientMachine, boolean create, boolean overwrite, \n      boolean createParent, short replication, long blockSize, \n      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n      EncryptedKeyVersion edek, boolean logRetryEntry)\n      throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (isPermissionEnabled) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission \n       * of parent (equals to ancestor in this case)\n       */\n      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n    if (!createParent) {\n      dir.verifyParentDir(iip, src);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    try {\n      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n      if (myFile \u003d\u003d null) {\n        if (!create) {\n          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n              src + \" for client \" + clientMachine);\n        }\n      } else {\n        if (overwrite) {\n          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          long ret \u003d dir.delete(iip, toRemoveBlocks, toRemoveINodes, now());\n          if (ret \u003e\u003d 0) {\n            iip \u003d INodesInPath.replace(iip, iip.length() - 1, null);\n            incrDeletedFileCount(ret);\n            removePathAndBlocks(src, null, toRemoveINodes, true);\n          }\n        } else {\n          // If lease soft limit time is expired, recover the lease\n          recoverLeaseInternal(iip, src, holder, clientMachine, false);\n          throw new FileAlreadyExistsException(src + \" for client \" +\n              clientMachine + \" already exists\");\n        }\n      }\n\n      checkFsObjectLimit();\n      INodeFile newNode \u003d null;\n\n      // Always do an implicit mkdirs for parent directory tree.\n      Map.Entry\u003cINodesInPath, String\u003e parent \u003d FSDirMkdirOp\n          .createAncestorDirectories(dir, iip, permissions);\n      if (parent !\u003d null) {\n        iip \u003d dir.addFile(parent.getKey(), parent.getValue(), permissions,\n            replication, blockSize, holder, clientMachine);\n        newNode \u003d iip !\u003d null ? iip.getLastINode().asFile() : null;\n      }\n\n      if (newNode \u003d\u003d null) {\n        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n      }\n      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n          .getClientName(), src);\n\n      // Set encryption attributes if necessary\n      if (feInfo !\u003d null) {\n        dir.setFileEncryptionInfo(src, feInfo);\n        newNode \u003d dir.getInode(newNode.getId()).asFile();\n      }\n\n      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n\n      // record file record in log, record new generation stamp\n      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n      if (NameNode.stateChangeLog.isDebugEnabled()) {\n        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n            src + \" inode \" + newNode.getId() + \" \" + holder);\n      }\n      return toRemoveBlocks;\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n          ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "c78e3a7cdd10c40454e9acb06986ba6d8573cb19": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7059. Avoid resolving path multiple times. Contributed by Jing Zhao.\n",
      "commitDate": "12/12/14 3:13 PM",
      "commitName": "c78e3a7cdd10c40454e9acb06986ba6d8573cb19",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "12/12/14 11:51 AM",
      "commitNameOld": "46612c7a5135d20b20403780b47dd00654aab057",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,114 @@\n   private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n       INodesInPath iip, PermissionStatus permissions, String holder,\n       String clientMachine, boolean create, boolean overwrite, \n       boolean createParent, short replication, long blockSize, \n       boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n       EncryptedKeyVersion edek, boolean logRetryEntry)\n       throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INode inode \u003d iip.getLastINode();\n     final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (isPermissionEnabled) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         dir.checkPathAccess(pc, iip, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission \n        * of parent (equals to ancestor in this case)\n        */\n       dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n     }\n     if (!createParent) {\n       dir.verifyParentDir(iip, src);\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d dir.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     try {\n       BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n       if (myFile \u003d\u003d null) {\n         if (!create) {\n           throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n               src + \" for client \" + clientMachine);\n         }\n       } else {\n         if (overwrite) {\n           toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n-          long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n+          long ret \u003d dir.delete(iip, toRemoveBlocks, toRemoveINodes, now());\n           if (ret \u003e\u003d 0) {\n             incrDeletedFileCount(ret);\n             removePathAndBlocks(src, null, toRemoveINodes, true);\n           }\n         } else {\n           // If lease soft limit time is expired, recover the lease\n-          recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n+          recoverLeaseInternal(iip, src, holder, clientMachine, false);\n           throw new FileAlreadyExistsException(src + \" for client \" +\n               clientMachine + \" already exists\");\n         }\n       }\n \n       checkFsObjectLimit();\n       INodeFile newNode \u003d null;\n \n       // Always do an implicit mkdirs for parent directory tree.\n-      Path parent \u003d new Path(src).getParent();\n-      if (parent !\u003d null \u0026\u0026 FSDirMkdirOp.mkdirsRecursively(dir,\n-          parent.toString(), permissions, true, now())) {\n-        newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n+      INodesInPath parentIIP \u003d iip.getParentINodesInPath();\n+      if (parentIIP !\u003d null \u0026\u0026 (parentIIP \u003d FSDirMkdirOp.mkdirsRecursively(dir,\n+          parentIIP, permissions, true, now())) !\u003d null) {\n+        iip \u003d INodesInPath.append(parentIIP, newNode, iip.getLastLocalName());\n+        newNode \u003d dir.addFile(iip, src, permissions, replication, blockSize,\n                               holder, clientMachine);\n       }\n \n       if (newNode \u003d\u003d null) {\n         throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n       }\n       leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n           .getClientName(), src);\n \n       // Set encryption attributes if necessary\n       if (feInfo !\u003d null) {\n         dir.setFileEncryptionInfo(src, feInfo);\n         newNode \u003d dir.getInode(newNode.getId()).asFile();\n       }\n \n       setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n \n       // record file record in log, record new generation stamp\n       getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n       if (NameNode.stateChangeLog.isDebugEnabled()) {\n         NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n             src + \" inode \" + newNode.getId() + \" \" + holder);\n       }\n       return toRemoveBlocks;\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n           ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n      INodesInPath iip, PermissionStatus permissions, String holder,\n      String clientMachine, boolean create, boolean overwrite, \n      boolean createParent, short replication, long blockSize, \n      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n      EncryptedKeyVersion edek, boolean logRetryEntry)\n      throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (isPermissionEnabled) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission \n       * of parent (equals to ancestor in this case)\n       */\n      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n    if (!createParent) {\n      dir.verifyParentDir(iip, src);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    try {\n      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n      if (myFile \u003d\u003d null) {\n        if (!create) {\n          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n              src + \" for client \" + clientMachine);\n        }\n      } else {\n        if (overwrite) {\n          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          long ret \u003d dir.delete(iip, toRemoveBlocks, toRemoveINodes, now());\n          if (ret \u003e\u003d 0) {\n            incrDeletedFileCount(ret);\n            removePathAndBlocks(src, null, toRemoveINodes, true);\n          }\n        } else {\n          // If lease soft limit time is expired, recover the lease\n          recoverLeaseInternal(iip, src, holder, clientMachine, false);\n          throw new FileAlreadyExistsException(src + \" for client \" +\n              clientMachine + \" already exists\");\n        }\n      }\n\n      checkFsObjectLimit();\n      INodeFile newNode \u003d null;\n\n      // Always do an implicit mkdirs for parent directory tree.\n      INodesInPath parentIIP \u003d iip.getParentINodesInPath();\n      if (parentIIP !\u003d null \u0026\u0026 (parentIIP \u003d FSDirMkdirOp.mkdirsRecursively(dir,\n          parentIIP, permissions, true, now())) !\u003d null) {\n        iip \u003d INodesInPath.append(parentIIP, newNode, iip.getLastLocalName());\n        newNode \u003d dir.addFile(iip, src, permissions, replication, blockSize,\n                              holder, clientMachine);\n      }\n\n      if (newNode \u003d\u003d null) {\n        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n      }\n      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n          .getClientName(), src);\n\n      // Set encryption attributes if necessary\n      if (feInfo !\u003d null) {\n        dir.setFileEncryptionInfo(src, feInfo);\n        newNode \u003d dir.getInode(newNode.getId()).asFile();\n      }\n\n      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n\n      // record file record in log, record new generation stamp\n      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n      if (NameNode.stateChangeLog.isDebugEnabled()) {\n        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n            src + \" inode \" + newNode.getId() + \" \" + holder);\n      }\n      return toRemoveBlocks;\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n          ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "475c6b4978045d55d1ebcea69cc9a2f24355aca2": {
      "type": "Ymultichange(Yparameterchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
      "commitDate": "05/12/14 2:17 PM",
      "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
          "commitDate": "05/12/14 2:17 PM",
          "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "05/12/14 10:55 AM",
          "commitNameOld": "6a5596e3b4443462fc86f800b3c2eb839d44c3bd",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,116 +1,113 @@\n   private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n-      String src, PermissionStatus permissions, String holder, \n+      INodesInPath iip, PermissionStatus permissions, String holder,\n       String clientMachine, boolean create, boolean overwrite, \n       boolean createParent, short replication, long blockSize, \n       boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n       EncryptedKeyVersion edek, boolean logRetryEntry)\n-      throws FileAlreadyExistsException, AccessControlException,\n-      UnresolvedLinkException, FileNotFoundException,\n-      ParentNotDirectoryException, RetryStartFileException, IOException {\n+      throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n-    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n+    final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n+    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n+    if (isPermissionEnabled) {\n+      if (overwrite \u0026\u0026 myFile !\u003d null) {\n+        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n+      }\n+      /*\n+       * To overwrite existing file, need to check \u0027w\u0027 permission \n+       * of parent (equals to ancestor in this case)\n+       */\n+      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n+    }\n+    if (!createParent) {\n+      dir.verifyParentDir(iip, src);\n+    }\n+\n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d dir.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n-    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-    if (isPermissionEnabled) {\n-      if (overwrite \u0026\u0026 myFile !\u003d null) {\n-        checkPathAccess(pc, src, FsAction.WRITE);\n-      }\n-      /*\n-       * To overwrite existing file, need to check \u0027w\u0027 permission \n-       * of parent (equals to ancestor in this case)\n-       */\n-      checkAncestorAccess(pc, src, FsAction.WRITE);\n-    }\n-\n-    if (!createParent) {\n-      dir.verifyParentDir(src);\n-    }\n-\n     try {\n       BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n       if (myFile \u003d\u003d null) {\n         if (!create) {\n           throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n               src + \" for client \" + clientMachine);\n         }\n       } else {\n         if (overwrite) {\n           toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n           if (ret \u003e\u003d 0) {\n             incrDeletedFileCount(ret);\n             removePathAndBlocks(src, null, toRemoveINodes, true);\n           }\n         } else {\n           // If lease soft limit time is expired, recover the lease\n           recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n           throw new FileAlreadyExistsException(src + \" for client \" +\n               clientMachine + \" already exists\");\n         }\n       }\n \n       checkFsObjectLimit();\n       INodeFile newNode \u003d null;\n \n       // Always do an implicit mkdirs for parent directory tree.\n       Path parent \u003d new Path(src).getParent();\n       if (parent !\u003d null \u0026\u0026 FSDirMkdirOp.mkdirsRecursively(dir,\n           parent.toString(), permissions, true, now())) {\n         newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                               holder, clientMachine);\n       }\n \n       if (newNode \u003d\u003d null) {\n         throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n       }\n       leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n           .getClientName(), src);\n \n       // Set encryption attributes if necessary\n       if (feInfo !\u003d null) {\n         dir.setFileEncryptionInfo(src, feInfo);\n         newNode \u003d dir.getInode(newNode.getId()).asFile();\n       }\n \n       setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n \n       // record file record in log, record new generation stamp\n       getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n       if (NameNode.stateChangeLog.isDebugEnabled()) {\n         NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n             src + \" inode \" + newNode.getId() + \" \" + holder);\n       }\n       return toRemoveBlocks;\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n           ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n      INodesInPath iip, PermissionStatus permissions, String holder,\n      String clientMachine, boolean create, boolean overwrite, \n      boolean createParent, short replication, long blockSize, \n      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n      EncryptedKeyVersion edek, boolean logRetryEntry)\n      throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (isPermissionEnabled) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission \n       * of parent (equals to ancestor in this case)\n       */\n      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n    if (!createParent) {\n      dir.verifyParentDir(iip, src);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    try {\n      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n      if (myFile \u003d\u003d null) {\n        if (!create) {\n          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n              src + \" for client \" + clientMachine);\n        }\n      } else {\n        if (overwrite) {\n          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n          if (ret \u003e\u003d 0) {\n            incrDeletedFileCount(ret);\n            removePathAndBlocks(src, null, toRemoveINodes, true);\n          }\n        } else {\n          // If lease soft limit time is expired, recover the lease\n          recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n          throw new FileAlreadyExistsException(src + \" for client \" +\n              clientMachine + \" already exists\");\n        }\n      }\n\n      checkFsObjectLimit();\n      INodeFile newNode \u003d null;\n\n      // Always do an implicit mkdirs for parent directory tree.\n      Path parent \u003d new Path(src).getParent();\n      if (parent !\u003d null \u0026\u0026 FSDirMkdirOp.mkdirsRecursively(dir,\n          parent.toString(), permissions, true, now())) {\n        newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                              holder, clientMachine);\n      }\n\n      if (newNode \u003d\u003d null) {\n        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n      }\n      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n          .getClientName(), src);\n\n      // Set encryption attributes if necessary\n      if (feInfo !\u003d null) {\n        dir.setFileEncryptionInfo(src, feInfo);\n        newNode \u003d dir.getInode(newNode.getId()).asFile();\n      }\n\n      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n\n      // record file record in log, record new generation stamp\n      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n      if (NameNode.stateChangeLog.isDebugEnabled()) {\n        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n            src + \" inode \" + newNode.getId() + \" \" + holder);\n      }\n      return toRemoveBlocks;\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n          ie.getMessage());\n      throw ie;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[pc-FSPermissionChecker, src-String, permissions-PermissionStatus, holder-String, clientMachine-String, create-boolean, overwrite-boolean, createParent-boolean, replication-short, blockSize-long, isLazyPersist-boolean, suite-CipherSuite, version-CryptoProtocolVersion, edek-EncryptedKeyVersion, logRetryEntry-boolean]",
            "newValue": "[pc-FSPermissionChecker, iip-INodesInPath, permissions-PermissionStatus, holder-String, clientMachine-String, create-boolean, overwrite-boolean, createParent-boolean, replication-short, blockSize-long, isLazyPersist-boolean, suite-CipherSuite, version-CryptoProtocolVersion, edek-EncryptedKeyVersion, logRetryEntry-boolean]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
          "commitDate": "05/12/14 2:17 PM",
          "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "05/12/14 10:55 AM",
          "commitNameOld": "6a5596e3b4443462fc86f800b3c2eb839d44c3bd",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,116 +1,113 @@\n   private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n-      String src, PermissionStatus permissions, String holder, \n+      INodesInPath iip, PermissionStatus permissions, String holder,\n       String clientMachine, boolean create, boolean overwrite, \n       boolean createParent, short replication, long blockSize, \n       boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n       EncryptedKeyVersion edek, boolean logRetryEntry)\n-      throws FileAlreadyExistsException, AccessControlException,\n-      UnresolvedLinkException, FileNotFoundException,\n-      ParentNotDirectoryException, RetryStartFileException, IOException {\n+      throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n-    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n+    final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n+    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n+    if (isPermissionEnabled) {\n+      if (overwrite \u0026\u0026 myFile !\u003d null) {\n+        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n+      }\n+      /*\n+       * To overwrite existing file, need to check \u0027w\u0027 permission \n+       * of parent (equals to ancestor in this case)\n+       */\n+      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n+    }\n+    if (!createParent) {\n+      dir.verifyParentDir(iip, src);\n+    }\n+\n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d dir.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n-    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-    if (isPermissionEnabled) {\n-      if (overwrite \u0026\u0026 myFile !\u003d null) {\n-        checkPathAccess(pc, src, FsAction.WRITE);\n-      }\n-      /*\n-       * To overwrite existing file, need to check \u0027w\u0027 permission \n-       * of parent (equals to ancestor in this case)\n-       */\n-      checkAncestorAccess(pc, src, FsAction.WRITE);\n-    }\n-\n-    if (!createParent) {\n-      dir.verifyParentDir(src);\n-    }\n-\n     try {\n       BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n       if (myFile \u003d\u003d null) {\n         if (!create) {\n           throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n               src + \" for client \" + clientMachine);\n         }\n       } else {\n         if (overwrite) {\n           toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n           if (ret \u003e\u003d 0) {\n             incrDeletedFileCount(ret);\n             removePathAndBlocks(src, null, toRemoveINodes, true);\n           }\n         } else {\n           // If lease soft limit time is expired, recover the lease\n           recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n           throw new FileAlreadyExistsException(src + \" for client \" +\n               clientMachine + \" already exists\");\n         }\n       }\n \n       checkFsObjectLimit();\n       INodeFile newNode \u003d null;\n \n       // Always do an implicit mkdirs for parent directory tree.\n       Path parent \u003d new Path(src).getParent();\n       if (parent !\u003d null \u0026\u0026 FSDirMkdirOp.mkdirsRecursively(dir,\n           parent.toString(), permissions, true, now())) {\n         newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                               holder, clientMachine);\n       }\n \n       if (newNode \u003d\u003d null) {\n         throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n       }\n       leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n           .getClientName(), src);\n \n       // Set encryption attributes if necessary\n       if (feInfo !\u003d null) {\n         dir.setFileEncryptionInfo(src, feInfo);\n         newNode \u003d dir.getInode(newNode.getId()).asFile();\n       }\n \n       setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n \n       // record file record in log, record new generation stamp\n       getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n       if (NameNode.stateChangeLog.isDebugEnabled()) {\n         NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n             src + \" inode \" + newNode.getId() + \" \" + holder);\n       }\n       return toRemoveBlocks;\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n           ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n      INodesInPath iip, PermissionStatus permissions, String holder,\n      String clientMachine, boolean create, boolean overwrite, \n      boolean createParent, short replication, long blockSize, \n      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n      EncryptedKeyVersion edek, boolean logRetryEntry)\n      throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (isPermissionEnabled) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission \n       * of parent (equals to ancestor in this case)\n       */\n      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n    if (!createParent) {\n      dir.verifyParentDir(iip, src);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    try {\n      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n      if (myFile \u003d\u003d null) {\n        if (!create) {\n          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n              src + \" for client \" + clientMachine);\n        }\n      } else {\n        if (overwrite) {\n          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n          if (ret \u003e\u003d 0) {\n            incrDeletedFileCount(ret);\n            removePathAndBlocks(src, null, toRemoveINodes, true);\n          }\n        } else {\n          // If lease soft limit time is expired, recover the lease\n          recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n          throw new FileAlreadyExistsException(src + \" for client \" +\n              clientMachine + \" already exists\");\n        }\n      }\n\n      checkFsObjectLimit();\n      INodeFile newNode \u003d null;\n\n      // Always do an implicit mkdirs for parent directory tree.\n      Path parent \u003d new Path(src).getParent();\n      if (parent !\u003d null \u0026\u0026 FSDirMkdirOp.mkdirsRecursively(dir,\n          parent.toString(), permissions, true, now())) {\n        newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                              holder, clientMachine);\n      }\n\n      if (newNode \u003d\u003d null) {\n        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n      }\n      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n          .getClientName(), src);\n\n      // Set encryption attributes if necessary\n      if (feInfo !\u003d null) {\n        dir.setFileEncryptionInfo(src, feInfo);\n        newNode \u003d dir.getInode(newNode.getId()).asFile();\n      }\n\n      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n\n      // record file record in log, record new generation stamp\n      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n      if (NameNode.stateChangeLog.isDebugEnabled()) {\n        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n            src + \" inode \" + newNode.getId() + \" \" + holder);\n      }\n      return toRemoveBlocks;\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n          ie.getMessage());\n      throw ie;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "[FileAlreadyExistsException, AccessControlException, UnresolvedLinkException, FileNotFoundException, ParentNotDirectoryException, RetryStartFileException, IOException]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7474. Avoid resolving path in FSPermissionChecker. Contributed by Jing Zhao.\n",
          "commitDate": "05/12/14 2:17 PM",
          "commitName": "475c6b4978045d55d1ebcea69cc9a2f24355aca2",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "05/12/14 10:55 AM",
          "commitNameOld": "6a5596e3b4443462fc86f800b3c2eb839d44c3bd",
          "commitAuthorOld": "Haohui Mai",
          "daysBetweenCommits": 0.14,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,116 +1,113 @@\n   private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n-      String src, PermissionStatus permissions, String holder, \n+      INodesInPath iip, PermissionStatus permissions, String holder,\n       String clientMachine, boolean create, boolean overwrite, \n       boolean createParent, short replication, long blockSize, \n       boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n       EncryptedKeyVersion edek, boolean logRetryEntry)\n-      throws FileAlreadyExistsException, AccessControlException,\n-      UnresolvedLinkException, FileNotFoundException,\n-      ParentNotDirectoryException, RetryStartFileException, IOException {\n+      throws IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n-    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n+    final String src \u003d iip.getPath();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n+    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n+    if (isPermissionEnabled) {\n+      if (overwrite \u0026\u0026 myFile !\u003d null) {\n+        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n+      }\n+      /*\n+       * To overwrite existing file, need to check \u0027w\u0027 permission \n+       * of parent (equals to ancestor in this case)\n+       */\n+      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n+    }\n+    if (!createParent) {\n+      dir.verifyParentDir(iip, src);\n+    }\n+\n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d dir.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n-    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n-    if (isPermissionEnabled) {\n-      if (overwrite \u0026\u0026 myFile !\u003d null) {\n-        checkPathAccess(pc, src, FsAction.WRITE);\n-      }\n-      /*\n-       * To overwrite existing file, need to check \u0027w\u0027 permission \n-       * of parent (equals to ancestor in this case)\n-       */\n-      checkAncestorAccess(pc, src, FsAction.WRITE);\n-    }\n-\n-    if (!createParent) {\n-      dir.verifyParentDir(src);\n-    }\n-\n     try {\n       BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n       if (myFile \u003d\u003d null) {\n         if (!create) {\n           throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n               src + \" for client \" + clientMachine);\n         }\n       } else {\n         if (overwrite) {\n           toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n           if (ret \u003e\u003d 0) {\n             incrDeletedFileCount(ret);\n             removePathAndBlocks(src, null, toRemoveINodes, true);\n           }\n         } else {\n           // If lease soft limit time is expired, recover the lease\n           recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n           throw new FileAlreadyExistsException(src + \" for client \" +\n               clientMachine + \" already exists\");\n         }\n       }\n \n       checkFsObjectLimit();\n       INodeFile newNode \u003d null;\n \n       // Always do an implicit mkdirs for parent directory tree.\n       Path parent \u003d new Path(src).getParent();\n       if (parent !\u003d null \u0026\u0026 FSDirMkdirOp.mkdirsRecursively(dir,\n           parent.toString(), permissions, true, now())) {\n         newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                               holder, clientMachine);\n       }\n \n       if (newNode \u003d\u003d null) {\n         throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n       }\n       leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n           .getClientName(), src);\n \n       // Set encryption attributes if necessary\n       if (feInfo !\u003d null) {\n         dir.setFileEncryptionInfo(src, feInfo);\n         newNode \u003d dir.getInode(newNode.getId()).asFile();\n       }\n \n       setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n \n       // record file record in log, record new generation stamp\n       getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n       if (NameNode.stateChangeLog.isDebugEnabled()) {\n         NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n             src + \" inode \" + newNode.getId() + \" \" + holder);\n       }\n       return toRemoveBlocks;\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n           ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n      INodesInPath iip, PermissionStatus permissions, String holder,\n      String clientMachine, boolean create, boolean overwrite, \n      boolean createParent, short replication, long blockSize, \n      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n      EncryptedKeyVersion edek, boolean logRetryEntry)\n      throws IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INode inode \u003d iip.getLastINode();\n    final String src \u003d iip.getPath();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (isPermissionEnabled) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        dir.checkPathAccess(pc, iip, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission \n       * of parent (equals to ancestor in this case)\n       */\n      dir.checkAncestorAccess(pc, iip, FsAction.WRITE);\n    }\n    if (!createParent) {\n      dir.verifyParentDir(iip, src);\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    try {\n      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n      if (myFile \u003d\u003d null) {\n        if (!create) {\n          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n              src + \" for client \" + clientMachine);\n        }\n      } else {\n        if (overwrite) {\n          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n          if (ret \u003e\u003d 0) {\n            incrDeletedFileCount(ret);\n            removePathAndBlocks(src, null, toRemoveINodes, true);\n          }\n        } else {\n          // If lease soft limit time is expired, recover the lease\n          recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n          throw new FileAlreadyExistsException(src + \" for client \" +\n              clientMachine + \" already exists\");\n        }\n      }\n\n      checkFsObjectLimit();\n      INodeFile newNode \u003d null;\n\n      // Always do an implicit mkdirs for parent directory tree.\n      Path parent \u003d new Path(src).getParent();\n      if (parent !\u003d null \u0026\u0026 FSDirMkdirOp.mkdirsRecursively(dir,\n          parent.toString(), permissions, true, now())) {\n        newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                              holder, clientMachine);\n      }\n\n      if (newNode \u003d\u003d null) {\n        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n      }\n      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n          .getClientName(), src);\n\n      // Set encryption attributes if necessary\n      if (feInfo !\u003d null) {\n        dir.setFileEncryptionInfo(src, feInfo);\n        newNode \u003d dir.getInode(newNode.getId()).asFile();\n      }\n\n      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n\n      // record file record in log, record new generation stamp\n      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n      if (NameNode.stateChangeLog.isDebugEnabled()) {\n        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n            src + \" inode \" + newNode.getId() + \" \" + holder);\n      }\n      return toRemoveBlocks;\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n          ie.getMessage());\n      throw ie;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "185e0c7b4c056b88f606362c71e4a22aae7076e0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7462. Consolidate implementation of mkdirs() into a single class. Contributed by Haohui Mai.\n",
      "commitDate": "02/12/14 2:53 PM",
      "commitName": "185e0c7b4c056b88f606362c71e4a22aae7076e0",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "01/12/14 9:48 PM",
      "commitNameOld": "042699401ebe5186fa5556a79f8f9a206e5ebcd7",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,116 @@\n   private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n       String src, PermissionStatus permissions, String holder, \n       String clientMachine, boolean create, boolean overwrite, \n       boolean createParent, short replication, long blockSize, \n       boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n       EncryptedKeyVersion edek, boolean logRetryEntry)\n       throws FileAlreadyExistsException, AccessControlException,\n       UnresolvedLinkException, FileNotFoundException,\n       ParentNotDirectoryException, RetryStartFileException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n \n     final EncryptionZone zone \u003d dir.getEZForPath(iip);\n     if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (isPermissionEnabled) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         checkPathAccess(pc, src, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission \n        * of parent (equals to ancestor in this case)\n        */\n       checkAncestorAccess(pc, src, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n-      verifyParentDir(src);\n+      dir.verifyParentDir(src);\n     }\n \n     try {\n       BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n       if (myFile \u003d\u003d null) {\n         if (!create) {\n           throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n               src + \" for client \" + clientMachine);\n         }\n       } else {\n         if (overwrite) {\n           toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n           if (ret \u003e\u003d 0) {\n             incrDeletedFileCount(ret);\n             removePathAndBlocks(src, null, toRemoveINodes, true);\n           }\n         } else {\n           // If lease soft limit time is expired, recover the lease\n           recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n           throw new FileAlreadyExistsException(src + \" for client \" +\n               clientMachine + \" already exists\");\n         }\n       }\n \n       checkFsObjectLimit();\n       INodeFile newNode \u003d null;\n \n       // Always do an implicit mkdirs for parent directory tree.\n       Path parent \u003d new Path(src).getParent();\n-      if (parent !\u003d null \u0026\u0026 mkdirsRecursively(parent.toString(),\n-              permissions, true, now())) {\n+      if (parent !\u003d null \u0026\u0026 FSDirMkdirOp.mkdirsRecursively(dir,\n+          parent.toString(), permissions, true, now())) {\n         newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                               holder, clientMachine);\n       }\n \n       if (newNode \u003d\u003d null) {\n         throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n       }\n       leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n           .getClientName(), src);\n \n       // Set encryption attributes if necessary\n       if (feInfo !\u003d null) {\n         dir.setFileEncryptionInfo(src, feInfo);\n         newNode \u003d dir.getInode(newNode.getId()).asFile();\n       }\n \n       setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n \n       // record file record in log, record new generation stamp\n       getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n       if (NameNode.stateChangeLog.isDebugEnabled()) {\n         NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n             src + \" inode \" + newNode.getId() + \" \" + holder);\n       }\n       return toRemoveBlocks;\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n           ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n      String src, PermissionStatus permissions, String holder, \n      String clientMachine, boolean create, boolean overwrite, \n      boolean createParent, short replication, long blockSize, \n      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n      EncryptedKeyVersion edek, boolean logRetryEntry)\n      throws FileAlreadyExistsException, AccessControlException,\n      UnresolvedLinkException, FileNotFoundException,\n      ParentNotDirectoryException, RetryStartFileException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (isPermissionEnabled) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        checkPathAccess(pc, src, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission \n       * of parent (equals to ancestor in this case)\n       */\n      checkAncestorAccess(pc, src, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      dir.verifyParentDir(src);\n    }\n\n    try {\n      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n      if (myFile \u003d\u003d null) {\n        if (!create) {\n          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n              src + \" for client \" + clientMachine);\n        }\n      } else {\n        if (overwrite) {\n          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n          if (ret \u003e\u003d 0) {\n            incrDeletedFileCount(ret);\n            removePathAndBlocks(src, null, toRemoveINodes, true);\n          }\n        } else {\n          // If lease soft limit time is expired, recover the lease\n          recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n          throw new FileAlreadyExistsException(src + \" for client \" +\n              clientMachine + \" already exists\");\n        }\n      }\n\n      checkFsObjectLimit();\n      INodeFile newNode \u003d null;\n\n      // Always do an implicit mkdirs for parent directory tree.\n      Path parent \u003d new Path(src).getParent();\n      if (parent !\u003d null \u0026\u0026 FSDirMkdirOp.mkdirsRecursively(dir,\n          parent.toString(), permissions, true, now())) {\n        newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                              holder, clientMachine);\n      }\n\n      if (newNode \u003d\u003d null) {\n        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n      }\n      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n          .getClientName(), src);\n\n      // Set encryption attributes if necessary\n      if (feInfo !\u003d null) {\n        dir.setFileEncryptionInfo(src, feInfo);\n        newNode \u003d dir.getInode(newNode.getId()).asFile();\n      }\n\n      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n\n      // record file record in log, record new generation stamp\n      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n      if (NameNode.stateChangeLog.isDebugEnabled()) {\n        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n            src + \" inode \" + newNode.getId() + \" \" + holder);\n      }\n      return toRemoveBlocks;\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n          ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "368743140dd076ecd5af309c1ed83c5ae2d59fc8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7252. small refinement to the use of isInAnEZ in FSNamesystem. (Yi Liu via vinayakumarb)\n",
      "commitDate": "17/10/14 5:33 AM",
      "commitName": "368743140dd076ecd5af309c1ed83c5ae2d59fc8",
      "commitAuthor": "Vinayakumar B",
      "commitDateOld": "17/10/14 5:18 AM",
      "commitNameOld": "1c3ff0b7c892b9d70737c375fb6f4a6fc6dd6d81",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,116 @@\n   private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n       String src, PermissionStatus permissions, String holder, \n       String clientMachine, boolean create, boolean overwrite, \n       boolean createParent, short replication, long blockSize, \n       boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n       EncryptedKeyVersion edek, boolean logRetryEntry)\n       throws FileAlreadyExistsException, AccessControlException,\n       UnresolvedLinkException, FileNotFoundException,\n       ParentNotDirectoryException, RetryStartFileException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n-    if (dir.isInAnEZ(iip)) {\n+\n+    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n+    if (zone !\u003d null) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n-      String ezKeyName \u003d dir.getKeyName(iip);\n+      final String ezKeyName \u003d zone.getKeyName();\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (isPermissionEnabled) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         checkPathAccess(pc, src, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission \n        * of parent (equals to ancestor in this case)\n        */\n       checkAncestorAccess(pc, src, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       verifyParentDir(src);\n     }\n \n     try {\n       BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n       if (myFile \u003d\u003d null) {\n         if (!create) {\n           throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n               src + \" for client \" + clientMachine);\n         }\n       } else {\n         if (overwrite) {\n           toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n           if (ret \u003e\u003d 0) {\n             incrDeletedFileCount(ret);\n             removePathAndBlocks(src, null, toRemoveINodes, true);\n           }\n         } else {\n           // If lease soft limit time is expired, recover the lease\n           recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n           throw new FileAlreadyExistsException(src + \" for client \" +\n               clientMachine + \" already exists\");\n         }\n       }\n \n       checkFsObjectLimit();\n       INodeFile newNode \u003d null;\n \n       // Always do an implicit mkdirs for parent directory tree.\n       Path parent \u003d new Path(src).getParent();\n       if (parent !\u003d null \u0026\u0026 mkdirsRecursively(parent.toString(),\n               permissions, true, now())) {\n         newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                               holder, clientMachine);\n       }\n \n       if (newNode \u003d\u003d null) {\n         throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n       }\n       leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n           .getClientName(), src);\n \n       // Set encryption attributes if necessary\n       if (feInfo !\u003d null) {\n         dir.setFileEncryptionInfo(src, feInfo);\n         newNode \u003d dir.getInode(newNode.getId()).asFile();\n       }\n \n       setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n \n       // record file record in log, record new generation stamp\n       getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n       if (NameNode.stateChangeLog.isDebugEnabled()) {\n         NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n             src + \" inode \" + newNode.getId() + \" \" + holder);\n       }\n       return toRemoveBlocks;\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n           ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n      String src, PermissionStatus permissions, String holder, \n      String clientMachine, boolean create, boolean overwrite, \n      boolean createParent, short replication, long blockSize, \n      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n      EncryptedKeyVersion edek, boolean logRetryEntry)\n      throws FileAlreadyExistsException, AccessControlException,\n      UnresolvedLinkException, FileNotFoundException,\n      ParentNotDirectoryException, RetryStartFileException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n\n    final EncryptionZone zone \u003d dir.getEZForPath(iip);\n    if (zone !\u003d null) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      final String ezKeyName \u003d zone.getKeyName();\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (isPermissionEnabled) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        checkPathAccess(pc, src, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission \n       * of parent (equals to ancestor in this case)\n       */\n      checkAncestorAccess(pc, src, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      verifyParentDir(src);\n    }\n\n    try {\n      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n      if (myFile \u003d\u003d null) {\n        if (!create) {\n          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n              src + \" for client \" + clientMachine);\n        }\n      } else {\n        if (overwrite) {\n          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n          if (ret \u003e\u003d 0) {\n            incrDeletedFileCount(ret);\n            removePathAndBlocks(src, null, toRemoveINodes, true);\n          }\n        } else {\n          // If lease soft limit time is expired, recover the lease\n          recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n          throw new FileAlreadyExistsException(src + \" for client \" +\n              clientMachine + \" already exists\");\n        }\n      }\n\n      checkFsObjectLimit();\n      INodeFile newNode \u003d null;\n\n      // Always do an implicit mkdirs for parent directory tree.\n      Path parent \u003d new Path(src).getParent();\n      if (parent !\u003d null \u0026\u0026 mkdirsRecursively(parent.toString(),\n              permissions, true, now())) {\n        newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                              holder, clientMachine);\n      }\n\n      if (newNode \u003d\u003d null) {\n        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n      }\n      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n          .getClientName(), src);\n\n      // Set encryption attributes if necessary\n      if (feInfo !\u003d null) {\n        dir.setFileEncryptionInfo(src, feInfo);\n        newNode \u003d dir.getInode(newNode.getId()).asFile();\n      }\n\n      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n\n      // record file record in log, record new generation stamp\n      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n      if (NameNode.stateChangeLog.isDebugEnabled()) {\n        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n            src + \" inode \" + newNode.getId() + \" \" + holder);\n      }\n      return toRemoveBlocks;\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n          ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "128ace10cdde4e966e30ac429c9a65ab8ace2d6c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7190. Bad use of Preconditions in startFileInternal(). Contributed by Dawson Choong.\n",
      "commitDate": "14/10/14 11:42 PM",
      "commitName": "128ace10cdde4e966e30ac429c9a65ab8ace2d6c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "10/10/14 1:40 PM",
      "commitNameOld": "d3d3d47202a18749eeebec22db759c19dd3e232c",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.42,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,115 +1,114 @@\n   private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n       String src, PermissionStatus permissions, String holder, \n       String clientMachine, boolean create, boolean overwrite, \n       boolean createParent, short replication, long blockSize, \n       boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n       EncryptedKeyVersion edek, boolean logRetryEntry)\n       throws FileAlreadyExistsException, AccessControlException,\n       UnresolvedLinkException, FileNotFoundException,\n       ParentNotDirectoryException, RetryStartFileException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n     if (dir.isInAnEZ(iip)) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       String ezKeyName \u003d dir.getKeyName(iip);\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n-      Preconditions.checkNotNull(feInfo);\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (isPermissionEnabled) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         checkPathAccess(pc, src, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission \n        * of parent (equals to ancestor in this case)\n        */\n       checkAncestorAccess(pc, src, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       verifyParentDir(src);\n     }\n \n     try {\n       BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n       if (myFile \u003d\u003d null) {\n         if (!create) {\n           throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n               src + \" for client \" + clientMachine);\n         }\n       } else {\n         if (overwrite) {\n           toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n           if (ret \u003e\u003d 0) {\n             incrDeletedFileCount(ret);\n             removePathAndBlocks(src, null, toRemoveINodes, true);\n           }\n         } else {\n           // If lease soft limit time is expired, recover the lease\n           recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n           throw new FileAlreadyExistsException(src + \" for client \" +\n               clientMachine + \" already exists\");\n         }\n       }\n \n       checkFsObjectLimit();\n       INodeFile newNode \u003d null;\n \n       // Always do an implicit mkdirs for parent directory tree.\n       Path parent \u003d new Path(src).getParent();\n       if (parent !\u003d null \u0026\u0026 mkdirsRecursively(parent.toString(),\n               permissions, true, now())) {\n         newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                               holder, clientMachine);\n       }\n \n       if (newNode \u003d\u003d null) {\n         throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n       }\n       leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n           .getClientName(), src);\n \n       // Set encryption attributes if necessary\n       if (feInfo !\u003d null) {\n         dir.setFileEncryptionInfo(src, feInfo);\n         newNode \u003d dir.getInode(newNode.getId()).asFile();\n       }\n \n       setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n \n       // record file record in log, record new generation stamp\n       getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n       if (NameNode.stateChangeLog.isDebugEnabled()) {\n         NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n             src + \" inode \" + newNode.getId() + \" \" + holder);\n       }\n       return toRemoveBlocks;\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n           ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n      String src, PermissionStatus permissions, String holder, \n      String clientMachine, boolean create, boolean overwrite, \n      boolean createParent, short replication, long blockSize, \n      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n      EncryptedKeyVersion edek, boolean logRetryEntry)\n      throws FileAlreadyExistsException, AccessControlException,\n      UnresolvedLinkException, FileNotFoundException,\n      ParentNotDirectoryException, RetryStartFileException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n    if (dir.isInAnEZ(iip)) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      String ezKeyName \u003d dir.getKeyName(iip);\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (isPermissionEnabled) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        checkPathAccess(pc, src, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission \n       * of parent (equals to ancestor in this case)\n       */\n      checkAncestorAccess(pc, src, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      verifyParentDir(src);\n    }\n\n    try {\n      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n      if (myFile \u003d\u003d null) {\n        if (!create) {\n          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n              src + \" for client \" + clientMachine);\n        }\n      } else {\n        if (overwrite) {\n          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n          if (ret \u003e\u003d 0) {\n            incrDeletedFileCount(ret);\n            removePathAndBlocks(src, null, toRemoveINodes, true);\n          }\n        } else {\n          // If lease soft limit time is expired, recover the lease\n          recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n          throw new FileAlreadyExistsException(src + \" for client \" +\n              clientMachine + \" already exists\");\n        }\n      }\n\n      checkFsObjectLimit();\n      INodeFile newNode \u003d null;\n\n      // Always do an implicit mkdirs for parent directory tree.\n      Path parent \u003d new Path(src).getParent();\n      if (parent !\u003d null \u0026\u0026 mkdirsRecursively(parent.toString(),\n              permissions, true, now())) {\n        newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                              holder, clientMachine);\n      }\n\n      if (newNode \u003d\u003d null) {\n        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n      }\n      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n          .getClientName(), src);\n\n      // Set encryption attributes if necessary\n      if (feInfo !\u003d null) {\n        dir.setFileEncryptionInfo(src, feInfo);\n        newNode \u003d dir.getInode(newNode.getId()).asFile();\n      }\n\n      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n\n      // record file record in log, record new generation stamp\n      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n      if (NameNode.stateChangeLog.isDebugEnabled()) {\n        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n            src + \" inode \" + newNode.getId() + \" \" + holder);\n      }\n      return toRemoveBlocks;\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n          ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "bb84f1fccb18c6c7373851e05d2451d55e908242": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7159. Use block storage policy to set lazy persist preference. (Arpit Agarwal)\n",
      "commitDate": "29/09/14 10:27 PM",
      "commitName": "bb84f1fccb18c6c7373851e05d2451d55e908242",
      "commitAuthor": "arp",
      "commitDateOld": "29/09/14 12:36 PM",
      "commitNameOld": "d45e7c7e856c7103752888c0395fa94985cd7670",
      "commitAuthorOld": "arp",
      "daysBetweenCommits": 0.41,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,113 +1,115 @@\n   private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n       String src, PermissionStatus permissions, String holder, \n       String clientMachine, boolean create, boolean overwrite, \n       boolean createParent, short replication, long blockSize, \n       boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n       EncryptedKeyVersion edek, boolean logRetryEntry)\n       throws FileAlreadyExistsException, AccessControlException,\n       UnresolvedLinkException, FileNotFoundException,\n       ParentNotDirectoryException, RetryStartFileException, IOException {\n     assert hasWriteLock();\n     // Verify that the destination does not exist as a directory already.\n     final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n     final INode inode \u003d iip.getLastINode();\n     if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n       throw new FileAlreadyExistsException(src +\n           \" already exists as a directory\");\n     }\n \n     FileEncryptionInfo feInfo \u003d null;\n     if (dir.isInAnEZ(iip)) {\n       // The path is now within an EZ, but we\u0027re missing encryption parameters\n       if (suite \u003d\u003d null || edek \u003d\u003d null) {\n         throw new RetryStartFileException();\n       }\n       // Path is within an EZ and we have provided encryption parameters.\n       // Make sure that the generated EDEK matches the settings of the EZ.\n       String ezKeyName \u003d dir.getKeyName(iip);\n       if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n         throw new RetryStartFileException();\n       }\n       feInfo \u003d new FileEncryptionInfo(suite, version,\n           edek.getEncryptedKeyVersion().getMaterial(),\n           edek.getEncryptedKeyIv(),\n           ezKeyName, edek.getEncryptionKeyVersionName());\n       Preconditions.checkNotNull(feInfo);\n     }\n \n     final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n     if (isPermissionEnabled) {\n       if (overwrite \u0026\u0026 myFile !\u003d null) {\n         checkPathAccess(pc, src, FsAction.WRITE);\n       }\n       /*\n        * To overwrite existing file, need to check \u0027w\u0027 permission \n        * of parent (equals to ancestor in this case)\n        */\n       checkAncestorAccess(pc, src, FsAction.WRITE);\n     }\n \n     if (!createParent) {\n       verifyParentDir(src);\n     }\n \n     try {\n       BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n       if (myFile \u003d\u003d null) {\n         if (!create) {\n           throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n               src + \" for client \" + clientMachine);\n         }\n       } else {\n         if (overwrite) {\n           toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n           List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n           long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n           if (ret \u003e\u003d 0) {\n             incrDeletedFileCount(ret);\n             removePathAndBlocks(src, null, toRemoveINodes, true);\n           }\n         } else {\n           // If lease soft limit time is expired, recover the lease\n           recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n           throw new FileAlreadyExistsException(src + \" for client \" +\n               clientMachine + \" already exists\");\n         }\n       }\n \n       checkFsObjectLimit();\n       INodeFile newNode \u003d null;\n \n       // Always do an implicit mkdirs for parent directory tree.\n       Path parent \u003d new Path(src).getParent();\n       if (parent !\u003d null \u0026\u0026 mkdirsRecursively(parent.toString(),\n               permissions, true, now())) {\n         newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n-                              isLazyPersist, holder, clientMachine);\n+                              holder, clientMachine);\n       }\n \n       if (newNode \u003d\u003d null) {\n         throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n       }\n       leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n           .getClientName(), src);\n \n       // Set encryption attributes if necessary\n       if (feInfo !\u003d null) {\n         dir.setFileEncryptionInfo(src, feInfo);\n         newNode \u003d dir.getInode(newNode.getId()).asFile();\n       }\n \n+      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n+\n       // record file record in log, record new generation stamp\n       getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n       if (NameNode.stateChangeLog.isDebugEnabled()) {\n         NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n             src + \" inode \" + newNode.getId() + \" \" + holder);\n       }\n       return toRemoveBlocks;\n     } catch (IOException ie) {\n       NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n           ie.getMessage());\n       throw ie;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private BlocksMapUpdateInfo startFileInternal(FSPermissionChecker pc, \n      String src, PermissionStatus permissions, String holder, \n      String clientMachine, boolean create, boolean overwrite, \n      boolean createParent, short replication, long blockSize, \n      boolean isLazyPersist, CipherSuite suite, CryptoProtocolVersion version,\n      EncryptedKeyVersion edek, boolean logRetryEntry)\n      throws FileAlreadyExistsException, AccessControlException,\n      UnresolvedLinkException, FileNotFoundException,\n      ParentNotDirectoryException, RetryStartFileException, IOException {\n    assert hasWriteLock();\n    // Verify that the destination does not exist as a directory already.\n    final INodesInPath iip \u003d dir.getINodesInPath4Write(src);\n    final INode inode \u003d iip.getLastINode();\n    if (inode !\u003d null \u0026\u0026 inode.isDirectory()) {\n      throw new FileAlreadyExistsException(src +\n          \" already exists as a directory\");\n    }\n\n    FileEncryptionInfo feInfo \u003d null;\n    if (dir.isInAnEZ(iip)) {\n      // The path is now within an EZ, but we\u0027re missing encryption parameters\n      if (suite \u003d\u003d null || edek \u003d\u003d null) {\n        throw new RetryStartFileException();\n      }\n      // Path is within an EZ and we have provided encryption parameters.\n      // Make sure that the generated EDEK matches the settings of the EZ.\n      String ezKeyName \u003d dir.getKeyName(iip);\n      if (!ezKeyName.equals(edek.getEncryptionKeyName())) {\n        throw new RetryStartFileException();\n      }\n      feInfo \u003d new FileEncryptionInfo(suite, version,\n          edek.getEncryptedKeyVersion().getMaterial(),\n          edek.getEncryptedKeyIv(),\n          ezKeyName, edek.getEncryptionKeyVersionName());\n      Preconditions.checkNotNull(feInfo);\n    }\n\n    final INodeFile myFile \u003d INodeFile.valueOf(inode, src, true);\n    if (isPermissionEnabled) {\n      if (overwrite \u0026\u0026 myFile !\u003d null) {\n        checkPathAccess(pc, src, FsAction.WRITE);\n      }\n      /*\n       * To overwrite existing file, need to check \u0027w\u0027 permission \n       * of parent (equals to ancestor in this case)\n       */\n      checkAncestorAccess(pc, src, FsAction.WRITE);\n    }\n\n    if (!createParent) {\n      verifyParentDir(src);\n    }\n\n    try {\n      BlocksMapUpdateInfo toRemoveBlocks \u003d null;\n      if (myFile \u003d\u003d null) {\n        if (!create) {\n          throw new FileNotFoundException(\"Can\u0027t overwrite non-existent \" +\n              src + \" for client \" + clientMachine);\n        }\n      } else {\n        if (overwrite) {\n          toRemoveBlocks \u003d new BlocksMapUpdateInfo();\n          List\u003cINode\u003e toRemoveINodes \u003d new ChunkedArrayList\u003cINode\u003e();\n          long ret \u003d dir.delete(src, toRemoveBlocks, toRemoveINodes, now());\n          if (ret \u003e\u003d 0) {\n            incrDeletedFileCount(ret);\n            removePathAndBlocks(src, null, toRemoveINodes, true);\n          }\n        } else {\n          // If lease soft limit time is expired, recover the lease\n          recoverLeaseInternal(myFile, src, holder, clientMachine, false);\n          throw new FileAlreadyExistsException(src + \" for client \" +\n              clientMachine + \" already exists\");\n        }\n      }\n\n      checkFsObjectLimit();\n      INodeFile newNode \u003d null;\n\n      // Always do an implicit mkdirs for parent directory tree.\n      Path parent \u003d new Path(src).getParent();\n      if (parent !\u003d null \u0026\u0026 mkdirsRecursively(parent.toString(),\n              permissions, true, now())) {\n        newNode \u003d dir.addFile(src, permissions, replication, blockSize,\n                              holder, clientMachine);\n      }\n\n      if (newNode \u003d\u003d null) {\n        throw new IOException(\"Unable to add \" + src +  \" to namespace\");\n      }\n      leaseManager.addLease(newNode.getFileUnderConstructionFeature()\n          .getClientName(), src);\n\n      // Set encryption attributes if necessary\n      if (feInfo !\u003d null) {\n        dir.setFileEncryptionInfo(src, feInfo);\n        newNode \u003d dir.getInode(newNode.getId()).asFile();\n      }\n\n      setNewINodeStoragePolicy(newNode, iip, isLazyPersist);\n\n      // record file record in log, record new generation stamp\n      getEditLog().logOpenFile(src, newNode, overwrite, logRetryEntry);\n      if (NameNode.stateChangeLog.isDebugEnabled()) {\n        NameNode.stateChangeLog.debug(\"DIR* NameSystem.startFile: added \" +\n            src + \" inode \" + newNode.getId() + \" \" + holder);\n      }\n      return toRemoveBlocks;\n    } catch (IOException ie) {\n      NameNode.stateChangeLog.warn(\"DIR* NameSystem.startFile: \" + src + \" \" +\n          ie.getMessage());\n      throw ie;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    }
  }
}