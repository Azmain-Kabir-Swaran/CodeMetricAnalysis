{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacityScheduler.java",
  "functionName": "removeNode",
  "functionId": "removeNode___nodeInfo-RMNode",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
  "functionStartLine": 2070,
  "functionEndLine": 2121,
  "numCommitsSeen": 260,
  "timeTaken": 16641,
  "changeHistory": [
    "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff",
    "adf260a728df427eb729abe8fb9ad7248991ea54",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
    "d36b6e045f317c94e97cb41a163aa974d161a404",
    "14dd647c556016d351f425ee956ccf800ccb9ce2",
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
    "9571db19ebe39a2e654f754fd82c73c8fc865c15",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
    "57cdf8626a32b8595a645b7551f46ab950db4789",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "c0572656ced07a885f848c1134edd7b1c291d246",
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
    "6b608aad7d52b524fa94955a538e8b3524d42d93",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": "Ybodychange",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Ybodychange",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ymultichange(Ymodifierchange,Ybodychange)",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": "Ybodychange",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": "Ybodychange",
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": "Ybodychange",
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": "Ybodychange",
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": "Ybodychange",
    "adf260a728df427eb729abe8fb9ad7248991ea54": "Ybodychange",
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": "Ybodychange",
    "d36b6e045f317c94e97cb41a163aa974d161a404": "Ybodychange",
    "14dd647c556016d351f425ee956ccf800ccb9ce2": "Ybodychange",
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": "Ybodychange",
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": "Ybodychange",
    "9571db19ebe39a2e654f754fd82c73c8fc865c15": "Ybodychange",
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": "Ybodychange",
    "57cdf8626a32b8595a645b7551f46ab950db4789": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Ybodychange",
    "c0572656ced07a885f848c1134edd7b1c291d246": "Ybodychange",
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0": "Ybodychange",
    "6b608aad7d52b524fa94955a538e8b3524d42d93": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10034. Remove Allocation Tags from released container from Decommission node\n\nContributed by Kyungwan Nam. Reviewed by Adam Antal.\n",
      "commitDate": "19/03/20 12:25 AM",
      "commitName": "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911",
      "commitAuthor": "Prabhu Joseph",
      "commitDateOld": "28/01/20 9:46 AM",
      "commitNameOld": "1ab9c692fa9107f10c0d8fbfbb9e74f54bddc960",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 50.57,
      "commitsBetweenForRepo": 166,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,52 @@\n   private void removeNode(RMNode nodeInfo) {\n     writeLock.lock();\n     try {\n       // update this node to node label manager\n       if (labelManager !\u003d null) {\n         labelManager.deactivateNode(nodeInfo.getNodeID());\n       }\n \n       NodeId nodeId \u003d nodeInfo.getNodeID();\n       FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n       if (node \u003d\u003d null) {\n         LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n         return;\n       }\n \n       // Remove running containers\n       List\u003cRMContainer\u003e runningContainers \u003d\n           node.getCopiedListOfRunningContainers();\n       for (RMContainer container : runningContainers) {\n         super.completedContainer(container, SchedulerUtils\n             .createAbnormalContainerStatus(container.getContainerId(),\n                 SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n+        node.releaseContainer(container.getContainerId(), true);\n       }\n \n       // Remove reservations, if any\n       RMContainer reservedContainer \u003d node.getReservedContainer();\n       if (reservedContainer !\u003d null) {\n         super.completedContainer(reservedContainer, SchedulerUtils\n             .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                 SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n       }\n \n       nodeTracker.removeNode(nodeId);\n       Resource clusterResource \u003d getClusterResource();\n       getRootQueue().updateClusterResource(clusterResource,\n           new ResourceLimits(clusterResource));\n       int numNodes \u003d nodeTracker.nodeCount();\n \n       if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n         for (AsyncScheduleThread t : asyncSchedulerThreads) {\n           t.suspendSchedule();\n         }\n       }\n \n       LOG.info(\n           \"Removed node \" + nodeInfo.getNodeAddress() + \" clusterResource: \"\n               + getClusterResource());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void removeNode(RMNode nodeInfo) {\n    writeLock.lock();\n    try {\n      // update this node to node label manager\n      if (labelManager !\u003d null) {\n        labelManager.deactivateNode(nodeInfo.getNodeID());\n      }\n\n      NodeId nodeId \u003d nodeInfo.getNodeID();\n      FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n      if (node \u003d\u003d null) {\n        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n        return;\n      }\n\n      // Remove running containers\n      List\u003cRMContainer\u003e runningContainers \u003d\n          node.getCopiedListOfRunningContainers();\n      for (RMContainer container : runningContainers) {\n        super.completedContainer(container, SchedulerUtils\n            .createAbnormalContainerStatus(container.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n        node.releaseContainer(container.getContainerId(), true);\n      }\n\n      // Remove reservations, if any\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (reservedContainer !\u003d null) {\n        super.completedContainer(reservedContainer, SchedulerUtils\n            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      nodeTracker.removeNode(nodeId);\n      Resource clusterResource \u003d getClusterResource();\n      getRootQueue().updateClusterResource(clusterResource,\n          new ResourceLimits(clusterResource));\n      int numNodes \u003d nodeTracker.nodeCount();\n\n      if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n        for (AsyncScheduleThread t : asyncSchedulerThreads) {\n          t.suspendSchedule();\n        }\n      }\n\n      LOG.info(\n          \"Removed node \" + nodeInfo.getNodeAddress() + \" clusterResource: \"\n              + getClusterResource());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   private void removeNode(RMNode nodeInfo) {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       // update this node to node label manager\n       if (labelManager !\u003d null) {\n         labelManager.deactivateNode(nodeInfo.getNodeID());\n       }\n \n       NodeId nodeId \u003d nodeInfo.getNodeID();\n       FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n       if (node \u003d\u003d null) {\n         LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n         return;\n       }\n \n       // Remove running containers\n       List\u003cRMContainer\u003e runningContainers \u003d\n           node.getCopiedListOfRunningContainers();\n       for (RMContainer container : runningContainers) {\n         super.completedContainer(container, SchedulerUtils\n             .createAbnormalContainerStatus(container.getContainerId(),\n                 SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n       }\n \n       // Remove reservations, if any\n       RMContainer reservedContainer \u003d node.getReservedContainer();\n       if (reservedContainer !\u003d null) {\n         super.completedContainer(reservedContainer, SchedulerUtils\n             .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                 SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n       }\n \n       nodeTracker.removeNode(nodeId);\n       Resource clusterResource \u003d getClusterResource();\n       getRootQueue().updateClusterResource(clusterResource,\n           new ResourceLimits(clusterResource));\n       int numNodes \u003d nodeTracker.nodeCount();\n \n       if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n         for (AsyncScheduleThread t : asyncSchedulerThreads) {\n           t.suspendSchedule();\n         }\n       }\n \n       LOG.info(\n           \"Removed node \" + nodeInfo.getNodeAddress() + \" clusterResource: \"\n               + getClusterResource());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void removeNode(RMNode nodeInfo) {\n    writeLock.lock();\n    try {\n      // update this node to node label manager\n      if (labelManager !\u003d null) {\n        labelManager.deactivateNode(nodeInfo.getNodeID());\n      }\n\n      NodeId nodeId \u003d nodeInfo.getNodeID();\n      FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n      if (node \u003d\u003d null) {\n        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n        return;\n      }\n\n      // Remove running containers\n      List\u003cRMContainer\u003e runningContainers \u003d\n          node.getCopiedListOfRunningContainers();\n      for (RMContainer container : runningContainers) {\n        super.completedContainer(container, SchedulerUtils\n            .createAbnormalContainerStatus(container.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      // Remove reservations, if any\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (reservedContainer !\u003d null) {\n        super.completedContainer(reservedContainer, SchedulerUtils\n            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      nodeTracker.removeNode(nodeId);\n      Resource clusterResource \u003d getClusterResource();\n      getRootQueue().updateClusterResource(clusterResource,\n          new ResourceLimits(clusterResource));\n      int numNodes \u003d nodeTracker.nodeCount();\n\n      if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n        for (AsyncScheduleThread t : asyncSchedulerThreads) {\n          t.suspendSchedule();\n        }\n      }\n\n      LOG.info(\n          \"Removed node \" + nodeInfo.getNodeAddress() + \" clusterResource: \"\n              + getClusterResource());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5761. Separate QueueManager from Scheduler. (Xuan Gong via gtcarrera9)\n",
      "commitDate": "30/11/16 1:38 PM",
      "commitName": "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
      "commitAuthor": "Li Lu",
      "commitDateOld": "29/11/16 9:40 AM",
      "commitNameOld": "25f9872be63423ada6a18481eaad2888e731fdac",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   private void removeNode(RMNode nodeInfo) {\n     try {\n       writeLock.lock();\n       // update this node to node label manager\n       if (labelManager !\u003d null) {\n         labelManager.deactivateNode(nodeInfo.getNodeID());\n       }\n \n       NodeId nodeId \u003d nodeInfo.getNodeID();\n       FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n       if (node \u003d\u003d null) {\n         LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n         return;\n       }\n \n       // Remove running containers\n       List\u003cRMContainer\u003e runningContainers \u003d\n           node.getCopiedListOfRunningContainers();\n       for (RMContainer container : runningContainers) {\n         super.completedContainer(container, SchedulerUtils\n             .createAbnormalContainerStatus(container.getContainerId(),\n                 SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n       }\n \n       // Remove reservations, if any\n       RMContainer reservedContainer \u003d node.getReservedContainer();\n       if (reservedContainer !\u003d null) {\n         super.completedContainer(reservedContainer, SchedulerUtils\n             .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                 SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n       }\n \n       nodeTracker.removeNode(nodeId);\n       Resource clusterResource \u003d getClusterResource();\n-      root.updateClusterResource(clusterResource,\n+      getRootQueue().updateClusterResource(clusterResource,\n           new ResourceLimits(clusterResource));\n       int numNodes \u003d nodeTracker.nodeCount();\n \n       if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n         for (AsyncScheduleThread t : asyncSchedulerThreads) {\n           t.suspendSchedule();\n         }\n       }\n \n       LOG.info(\n           \"Removed node \" + nodeInfo.getNodeAddress() + \" clusterResource: \"\n               + getClusterResource());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void removeNode(RMNode nodeInfo) {\n    try {\n      writeLock.lock();\n      // update this node to node label manager\n      if (labelManager !\u003d null) {\n        labelManager.deactivateNode(nodeInfo.getNodeID());\n      }\n\n      NodeId nodeId \u003d nodeInfo.getNodeID();\n      FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n      if (node \u003d\u003d null) {\n        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n        return;\n      }\n\n      // Remove running containers\n      List\u003cRMContainer\u003e runningContainers \u003d\n          node.getCopiedListOfRunningContainers();\n      for (RMContainer container : runningContainers) {\n        super.completedContainer(container, SchedulerUtils\n            .createAbnormalContainerStatus(container.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      // Remove reservations, if any\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (reservedContainer !\u003d null) {\n        super.completedContainer(reservedContainer, SchedulerUtils\n            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      nodeTracker.removeNode(nodeId);\n      Resource clusterResource \u003d getClusterResource();\n      getRootQueue().updateClusterResource(clusterResource,\n          new ResourceLimits(clusterResource));\n      int numNodes \u003d nodeTracker.nodeCount();\n\n      if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n        for (AsyncScheduleThread t : asyncSchedulerThreads) {\n          t.suspendSchedule();\n        }\n      }\n\n      LOG.info(\n          \"Removed node \" + nodeInfo.getNodeAddress() + \" clusterResource: \"\n              + getClusterResource());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "07/11/16 10:14 AM",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "commitDateOld": "01/11/16 3:02 AM",
      "commitNameOld": "7d2d8d25ba0cb10a3c6192d4123f27ede5ef2ba6",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 6.34,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,51 @@\n   private void removeNode(RMNode nodeInfo) {\n     try {\n       writeLock.lock();\n       // update this node to node label manager\n       if (labelManager !\u003d null) {\n         labelManager.deactivateNode(nodeInfo.getNodeID());\n       }\n \n       NodeId nodeId \u003d nodeInfo.getNodeID();\n       FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n       if (node \u003d\u003d null) {\n         LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n         return;\n       }\n \n       // Remove running containers\n       List\u003cRMContainer\u003e runningContainers \u003d\n           node.getCopiedListOfRunningContainers();\n       for (RMContainer container : runningContainers) {\n         super.completedContainer(container, SchedulerUtils\n             .createAbnormalContainerStatus(container.getContainerId(),\n                 SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n       }\n \n       // Remove reservations, if any\n       RMContainer reservedContainer \u003d node.getReservedContainer();\n       if (reservedContainer !\u003d null) {\n         super.completedContainer(reservedContainer, SchedulerUtils\n             .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                 SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n       }\n \n       nodeTracker.removeNode(nodeId);\n       Resource clusterResource \u003d getClusterResource();\n       root.updateClusterResource(clusterResource,\n           new ResourceLimits(clusterResource));\n       int numNodes \u003d nodeTracker.nodeCount();\n \n       if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n-        asyncSchedulerThread.suspendSchedule();\n+        for (AsyncScheduleThread t : asyncSchedulerThreads) {\n+          t.suspendSchedule();\n+        }\n       }\n \n       LOG.info(\n           \"Removed node \" + nodeInfo.getNodeAddress() + \" clusterResource: \"\n               + getClusterResource());\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void removeNode(RMNode nodeInfo) {\n    try {\n      writeLock.lock();\n      // update this node to node label manager\n      if (labelManager !\u003d null) {\n        labelManager.deactivateNode(nodeInfo.getNodeID());\n      }\n\n      NodeId nodeId \u003d nodeInfo.getNodeID();\n      FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n      if (node \u003d\u003d null) {\n        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n        return;\n      }\n\n      // Remove running containers\n      List\u003cRMContainer\u003e runningContainers \u003d\n          node.getCopiedListOfRunningContainers();\n      for (RMContainer container : runningContainers) {\n        super.completedContainer(container, SchedulerUtils\n            .createAbnormalContainerStatus(container.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      // Remove reservations, if any\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (reservedContainer !\u003d null) {\n        super.completedContainer(reservedContainer, SchedulerUtils\n            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      nodeTracker.removeNode(nodeId);\n      Resource clusterResource \u003d getClusterResource();\n      root.updateClusterResource(clusterResource,\n          new ResourceLimits(clusterResource));\n      int numNodes \u003d nodeTracker.nodeCount();\n\n      if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n        for (AsyncScheduleThread t : asyncSchedulerThreads) {\n          t.suspendSchedule();\n        }\n      }\n\n      LOG.info(\n          \"Removed node \" + nodeInfo.getNodeAddress() + \" clusterResource: \"\n              + getClusterResource());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,49 @@\n-  private synchronized void removeNode(RMNode nodeInfo) {\n-    // update this node to node label manager\n-    if (labelManager !\u003d null) {\n-      labelManager.deactivateNode(nodeInfo.getNodeID());\n-    }\n+  private void removeNode(RMNode nodeInfo) {\n+    try {\n+      writeLock.lock();\n+      // update this node to node label manager\n+      if (labelManager !\u003d null) {\n+        labelManager.deactivateNode(nodeInfo.getNodeID());\n+      }\n \n-    NodeId nodeId \u003d nodeInfo.getNodeID();\n-    FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n-    if (node \u003d\u003d null) {\n-      LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n-      return;\n-    }\n+      NodeId nodeId \u003d nodeInfo.getNodeID();\n+      FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n+      if (node \u003d\u003d null) {\n+        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n+        return;\n+      }\n \n-    // Remove running containers\n-    List\u003cRMContainer\u003e runningContainers \u003d node.getCopiedListOfRunningContainers();\n-    for (RMContainer container : runningContainers) {\n-      super.completedContainer(container,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              container.getContainerId(), \n-              SchedulerUtils.LOST_CONTAINER), \n-          RMContainerEventType.KILL);\n-    }\n-    \n-    // Remove reservations, if any\n-    RMContainer reservedContainer \u003d node.getReservedContainer();\n-    if (reservedContainer !\u003d null) {\n-      super.completedContainer(reservedContainer,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              reservedContainer.getContainerId(), \n-              SchedulerUtils.LOST_CONTAINER), \n-          RMContainerEventType.KILL);\n-    }\n+      // Remove running containers\n+      List\u003cRMContainer\u003e runningContainers \u003d\n+          node.getCopiedListOfRunningContainers();\n+      for (RMContainer container : runningContainers) {\n+        super.completedContainer(container, SchedulerUtils\n+            .createAbnormalContainerStatus(container.getContainerId(),\n+                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n+      }\n \n-    nodeTracker.removeNode(nodeId);\n-    Resource clusterResource \u003d getClusterResource();\n-    root.updateClusterResource(clusterResource, new ResourceLimits(\n-        clusterResource));\n-    int numNodes \u003d nodeTracker.nodeCount();\n+      // Remove reservations, if any\n+      RMContainer reservedContainer \u003d node.getReservedContainer();\n+      if (reservedContainer !\u003d null) {\n+        super.completedContainer(reservedContainer, SchedulerUtils\n+            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n+                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n+      }\n \n-    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n-      asyncSchedulerThread.suspendSchedule();\n+      nodeTracker.removeNode(nodeId);\n+      Resource clusterResource \u003d getClusterResource();\n+      root.updateClusterResource(clusterResource,\n+          new ResourceLimits(clusterResource));\n+      int numNodes \u003d nodeTracker.nodeCount();\n+\n+      if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n+        asyncSchedulerThread.suspendSchedule();\n+      }\n+\n+      LOG.info(\n+          \"Removed node \" + nodeInfo.getNodeAddress() + \" clusterResource: \"\n+              + getClusterResource());\n+    } finally {\n+      writeLock.unlock();\n     }\n-\n-    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n-        \" clusterResource: \" + getClusterResource());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void removeNode(RMNode nodeInfo) {\n    try {\n      writeLock.lock();\n      // update this node to node label manager\n      if (labelManager !\u003d null) {\n        labelManager.deactivateNode(nodeInfo.getNodeID());\n      }\n\n      NodeId nodeId \u003d nodeInfo.getNodeID();\n      FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n      if (node \u003d\u003d null) {\n        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n        return;\n      }\n\n      // Remove running containers\n      List\u003cRMContainer\u003e runningContainers \u003d\n          node.getCopiedListOfRunningContainers();\n      for (RMContainer container : runningContainers) {\n        super.completedContainer(container, SchedulerUtils\n            .createAbnormalContainerStatus(container.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      // Remove reservations, if any\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (reservedContainer !\u003d null) {\n        super.completedContainer(reservedContainer, SchedulerUtils\n            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      nodeTracker.removeNode(nodeId);\n      Resource clusterResource \u003d getClusterResource();\n      root.updateClusterResource(clusterResource,\n          new ResourceLimits(clusterResource));\n      int numNodes \u003d nodeTracker.nodeCount();\n\n      if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n        asyncSchedulerThread.suspendSchedule();\n      }\n\n      LOG.info(\n          \"Removed node \" + nodeInfo.getNodeAddress() + \" clusterResource: \"\n              + getClusterResource());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[private, synchronized]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,49 @@\n-  private synchronized void removeNode(RMNode nodeInfo) {\n-    // update this node to node label manager\n-    if (labelManager !\u003d null) {\n-      labelManager.deactivateNode(nodeInfo.getNodeID());\n-    }\n+  private void removeNode(RMNode nodeInfo) {\n+    try {\n+      writeLock.lock();\n+      // update this node to node label manager\n+      if (labelManager !\u003d null) {\n+        labelManager.deactivateNode(nodeInfo.getNodeID());\n+      }\n \n-    NodeId nodeId \u003d nodeInfo.getNodeID();\n-    FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n-    if (node \u003d\u003d null) {\n-      LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n-      return;\n-    }\n+      NodeId nodeId \u003d nodeInfo.getNodeID();\n+      FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n+      if (node \u003d\u003d null) {\n+        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n+        return;\n+      }\n \n-    // Remove running containers\n-    List\u003cRMContainer\u003e runningContainers \u003d node.getCopiedListOfRunningContainers();\n-    for (RMContainer container : runningContainers) {\n-      super.completedContainer(container,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              container.getContainerId(), \n-              SchedulerUtils.LOST_CONTAINER), \n-          RMContainerEventType.KILL);\n-    }\n-    \n-    // Remove reservations, if any\n-    RMContainer reservedContainer \u003d node.getReservedContainer();\n-    if (reservedContainer !\u003d null) {\n-      super.completedContainer(reservedContainer,\n-          SchedulerUtils.createAbnormalContainerStatus(\n-              reservedContainer.getContainerId(), \n-              SchedulerUtils.LOST_CONTAINER), \n-          RMContainerEventType.KILL);\n-    }\n+      // Remove running containers\n+      List\u003cRMContainer\u003e runningContainers \u003d\n+          node.getCopiedListOfRunningContainers();\n+      for (RMContainer container : runningContainers) {\n+        super.completedContainer(container, SchedulerUtils\n+            .createAbnormalContainerStatus(container.getContainerId(),\n+                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n+      }\n \n-    nodeTracker.removeNode(nodeId);\n-    Resource clusterResource \u003d getClusterResource();\n-    root.updateClusterResource(clusterResource, new ResourceLimits(\n-        clusterResource));\n-    int numNodes \u003d nodeTracker.nodeCount();\n+      // Remove reservations, if any\n+      RMContainer reservedContainer \u003d node.getReservedContainer();\n+      if (reservedContainer !\u003d null) {\n+        super.completedContainer(reservedContainer, SchedulerUtils\n+            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n+                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n+      }\n \n-    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n-      asyncSchedulerThread.suspendSchedule();\n+      nodeTracker.removeNode(nodeId);\n+      Resource clusterResource \u003d getClusterResource();\n+      root.updateClusterResource(clusterResource,\n+          new ResourceLimits(clusterResource));\n+      int numNodes \u003d nodeTracker.nodeCount();\n+\n+      if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n+        asyncSchedulerThread.suspendSchedule();\n+      }\n+\n+      LOG.info(\n+          \"Removed node \" + nodeInfo.getNodeAddress() + \" clusterResource: \"\n+              + getClusterResource());\n+    } finally {\n+      writeLock.unlock();\n     }\n-\n-    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n-        \" clusterResource: \" + getClusterResource());\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void removeNode(RMNode nodeInfo) {\n    try {\n      writeLock.lock();\n      // update this node to node label manager\n      if (labelManager !\u003d null) {\n        labelManager.deactivateNode(nodeInfo.getNodeID());\n      }\n\n      NodeId nodeId \u003d nodeInfo.getNodeID();\n      FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n      if (node \u003d\u003d null) {\n        LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n        return;\n      }\n\n      // Remove running containers\n      List\u003cRMContainer\u003e runningContainers \u003d\n          node.getCopiedListOfRunningContainers();\n      for (RMContainer container : runningContainers) {\n        super.completedContainer(container, SchedulerUtils\n            .createAbnormalContainerStatus(container.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      // Remove reservations, if any\n      RMContainer reservedContainer \u003d node.getReservedContainer();\n      if (reservedContainer !\u003d null) {\n        super.completedContainer(reservedContainer, SchedulerUtils\n            .createAbnormalContainerStatus(reservedContainer.getContainerId(),\n                SchedulerUtils.LOST_CONTAINER), RMContainerEventType.KILL);\n      }\n\n      nodeTracker.removeNode(nodeId);\n      Resource clusterResource \u003d getClusterResource();\n      root.updateClusterResource(clusterResource,\n          new ResourceLimits(clusterResource));\n      int numNodes \u003d nodeTracker.nodeCount();\n\n      if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n        asyncSchedulerThread.suspendSchedule();\n      }\n\n      LOG.info(\n          \"Removed node \" + nodeInfo.getNodeAddress() + \" clusterResource: \"\n              + getClusterResource());\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
      "commitDate": "05/05/16 12:56 PM",
      "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthor": "Jian He",
      "commitDateOld": "08/04/16 3:33 PM",
      "commitNameOld": "ec06957941367930c855b5e05e6a84ba676fd46a",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 26.89,
      "commitsBetweenForRepo": 160,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     // update this node to node label manager\n     if (labelManager !\u003d null) {\n       labelManager.deactivateNode(nodeInfo.getNodeID());\n     }\n \n     NodeId nodeId \u003d nodeInfo.getNodeID();\n     FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n     if (node \u003d\u003d null) {\n       LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n       return;\n     }\n \n     // Remove running containers\n-    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n+    List\u003cRMContainer\u003e runningContainers \u003d node.getCopiedListOfRunningContainers();\n     for (RMContainer container : runningContainers) {\n       super.completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       super.completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     nodeTracker.removeNode(nodeId);\n     Resource clusterResource \u003d getClusterResource();\n     root.updateClusterResource(clusterResource, new ResourceLimits(\n         clusterResource));\n     int numNodes \u003d nodeTracker.nodeCount();\n \n     if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n       asyncSchedulerThread.suspendSchedule();\n     }\n \n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + getClusterResource());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    // update this node to node label manager\n    if (labelManager !\u003d null) {\n      labelManager.deactivateNode(nodeInfo.getNodeID());\n    }\n\n    NodeId nodeId \u003d nodeInfo.getNodeID();\n    FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n    if (node \u003d\u003d null) {\n      LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n      return;\n    }\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getCopiedListOfRunningContainers();\n    for (RMContainer container : runningContainers) {\n      super.completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      super.completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    nodeTracker.removeNode(nodeId);\n    Resource clusterResource \u003d getClusterResource();\n    root.updateClusterResource(clusterResource, new ResourceLimits(\n        clusterResource));\n    int numNodes \u003d nodeTracker.nodeCount();\n\n    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + getClusterResource());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4719. Add a helper library to maintain node state and allows common queries. (kasha)\n",
      "commitDate": "14/03/16 2:19 PM",
      "commitName": "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "01/03/16 1:14 PM",
      "commitNameOld": "5c465df90414d43250d09084748ab2d41af44eea",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 13.0,
      "commitsBetweenForRepo": 69,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,46 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     // update this node to node label manager\n     if (labelManager !\u003d null) {\n       labelManager.deactivateNode(nodeInfo.getNodeID());\n     }\n-    \n-    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n+\n+    NodeId nodeId \u003d nodeInfo.getNodeID();\n+    FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n     if (node \u003d\u003d null) {\n+      LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n       return;\n     }\n-    Resources.subtractFrom(clusterResource, node.getTotalResource());\n-    root.updateClusterResource(clusterResource, new ResourceLimits(\n-        clusterResource));\n-    int numNodes \u003d numNodeManagers.decrementAndGet();\n \n-    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n-      asyncSchedulerThread.suspendSchedule();\n-    }\n-    \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       super.completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       super.completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n-    this.nodes.remove(nodeInfo.getNodeID());\n-    updateMaximumAllocation(node, false);\n+    nodeTracker.removeNode(nodeId);\n+    Resource clusterResource \u003d getClusterResource();\n+    root.updateClusterResource(clusterResource, new ResourceLimits(\n+        clusterResource));\n+    int numNodes \u003d nodeTracker.nodeCount();\n+\n+    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n+      asyncSchedulerThread.suspendSchedule();\n+    }\n \n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n-        \" clusterResource: \" + clusterResource);\n+        \" clusterResource: \" + getClusterResource());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    // update this node to node label manager\n    if (labelManager !\u003d null) {\n      labelManager.deactivateNode(nodeInfo.getNodeID());\n    }\n\n    NodeId nodeId \u003d nodeInfo.getNodeID();\n    FiCaSchedulerNode node \u003d nodeTracker.getNode(nodeId);\n    if (node \u003d\u003d null) {\n      LOG.error(\"Attempting to remove non-existent node \" + nodeId);\n      return;\n    }\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      super.completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      super.completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    nodeTracker.removeNode(nodeId);\n    Resource clusterResource \u003d getClusterResource();\n    root.updateClusterResource(clusterResource, new ResourceLimits(\n        clusterResource));\n    int numNodes \u003d nodeTracker.nodeCount();\n\n    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + getClusterResource());\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "18/01/16 5:30 PM",
      "commitName": "a44ce3f14fd940601f984fbf7980aa6fdc8f23b7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 5:27 PM",
      "commitNameOld": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     // update this node to node label manager\n     if (labelManager !\u003d null) {\n       labelManager.deactivateNode(nodeInfo.getNodeID());\n     }\n     \n     FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, node.getTotalResource());\n     root.updateClusterResource(clusterResource, new ResourceLimits(\n         clusterResource));\n     int numNodes \u003d numNodeManagers.decrementAndGet();\n \n     if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n       asyncSchedulerThread.suspendSchedule();\n     }\n     \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n-      completedContainer(container, \n+      super.completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      completedContainer(reservedContainer, \n+      super.completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     updateMaximumAllocation(node, false);\n \n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    // update this node to node label manager\n    if (labelManager !\u003d null) {\n      labelManager.deactivateNode(nodeInfo.getNodeID());\n    }\n    \n    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getTotalResource());\n    root.updateClusterResource(clusterResource, new ResourceLimits(\n        clusterResource));\n    int numNodes \u003d numNodeManagers.decrementAndGet();\n\n    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n    \n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      super.completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      super.completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    updateMaximumAllocation(node, false);\n\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "150f5ae0343e872ee8bef39c57008c1389f0ba9e": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 3fe57285635e8058c34aa40a103845b49ca7d6ff.\n\nConflicts:\n\thadoop-yarn-project/CHANGES.txt\n",
      "commitDate": "18/01/16 5:27 PM",
      "commitName": "150f5ae0343e872ee8bef39c57008c1389f0ba9e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 1:06 AM",
      "commitNameOld": "3fe57285635e8058c34aa40a103845b49ca7d6ff",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.68,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     // update this node to node label manager\n     if (labelManager !\u003d null) {\n       labelManager.deactivateNode(nodeInfo.getNodeID());\n     }\n     \n     FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, node.getTotalResource());\n     root.updateClusterResource(clusterResource, new ResourceLimits(\n         clusterResource));\n     int numNodes \u003d numNodeManagers.decrementAndGet();\n \n     if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n       asyncSchedulerThread.suspendSchedule();\n     }\n     \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n-      super.completedContainer(container,\n+      completedContainer(container, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      super.completedContainer(reservedContainer,\n+      completedContainer(reservedContainer, \n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     updateMaximumAllocation(node, false);\n \n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    // update this node to node label manager\n    if (labelManager !\u003d null) {\n      labelManager.deactivateNode(nodeInfo.getNodeID());\n    }\n    \n    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getTotalResource());\n    root.updateClusterResource(clusterResource, new ResourceLimits(\n        clusterResource));\n    int numNodes \u003d numNodeManagers.decrementAndGet();\n\n    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n    \n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    updateMaximumAllocation(node, false);\n\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "3fe57285635e8058c34aa40a103845b49ca7d6ff": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n\n(cherry picked from commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579)\n",
      "commitDate": "18/01/16 1:06 AM",
      "commitName": "3fe57285635e8058c34aa40a103845b49ca7d6ff",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "18/01/16 12:50 AM",
      "commitNameOld": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     // update this node to node label manager\n     if (labelManager !\u003d null) {\n       labelManager.deactivateNode(nodeInfo.getNodeID());\n     }\n     \n     FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, node.getTotalResource());\n     root.updateClusterResource(clusterResource, new ResourceLimits(\n         clusterResource));\n     int numNodes \u003d numNodeManagers.decrementAndGet();\n \n     if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n       asyncSchedulerThread.suspendSchedule();\n     }\n     \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n-      completedContainer(container, \n+      super.completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      completedContainer(reservedContainer, \n+      super.completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     updateMaximumAllocation(node, false);\n \n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    // update this node to node label manager\n    if (labelManager !\u003d null) {\n      labelManager.deactivateNode(nodeInfo.getNodeID());\n    }\n    \n    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getTotalResource());\n    root.updateClusterResource(clusterResource, new ResourceLimits(\n        clusterResource));\n    int numNodes \u003d numNodeManagers.decrementAndGet();\n\n    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n    \n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      super.completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      super.completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    updateMaximumAllocation(node, false);\n\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "adf260a728df427eb729abe8fb9ad7248991ea54": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\"\n\nThis reverts commit 805a9ed85eb34c8125cfb7d26d07cdfac12b3579.\n",
      "commitDate": "18/01/16 12:50 AM",
      "commitName": "adf260a728df427eb729abe8fb9ad7248991ea54",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/01/16 7:04 PM",
      "commitNameOld": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.24,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     // update this node to node label manager\n     if (labelManager !\u003d null) {\n       labelManager.deactivateNode(nodeInfo.getNodeID());\n     }\n     \n     FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, node.getTotalResource());\n     root.updateClusterResource(clusterResource, new ResourceLimits(\n         clusterResource));\n     int numNodes \u003d numNodeManagers.decrementAndGet();\n \n     if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n       asyncSchedulerThread.suspendSchedule();\n     }\n     \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n-      super.completedContainer(container,\n+      completedContainer(container, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      super.completedContainer(reservedContainer,\n+      completedContainer(reservedContainer, \n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     updateMaximumAllocation(node, false);\n \n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    // update this node to node label manager\n    if (labelManager !\u003d null) {\n      labelManager.deactivateNode(nodeInfo.getNodeID());\n    }\n    \n    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getTotalResource());\n    root.updateClusterResource(clusterResource, new ResourceLimits(\n        clusterResource));\n    int numNodes \u003d numNodeManagers.decrementAndGet();\n\n    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n    \n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    updateMaximumAllocation(node, false);\n\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "805a9ed85eb34c8125cfb7d26d07cdfac12b3579": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4502. Fix two AM containers get allocated when AM restart. (Vinod Kumar Vavilapalli via wangda)\n",
      "commitDate": "17/01/16 7:04 PM",
      "commitName": "805a9ed85eb34c8125cfb7d26d07cdfac12b3579",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "12/01/16 9:18 PM",
      "commitNameOld": "c0537bcd2c2dcdb4812fcab7badf42e4f55a54d9",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 4.91,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     // update this node to node label manager\n     if (labelManager !\u003d null) {\n       labelManager.deactivateNode(nodeInfo.getNodeID());\n     }\n     \n     FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, node.getTotalResource());\n     root.updateClusterResource(clusterResource, new ResourceLimits(\n         clusterResource));\n     int numNodes \u003d numNodeManagers.decrementAndGet();\n \n     if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n       asyncSchedulerThread.suspendSchedule();\n     }\n     \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n-      completedContainer(container, \n+      super.completedContainer(container,\n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      completedContainer(reservedContainer, \n+      super.completedContainer(reservedContainer,\n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     updateMaximumAllocation(node, false);\n \n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    // update this node to node label manager\n    if (labelManager !\u003d null) {\n      labelManager.deactivateNode(nodeInfo.getNodeID());\n    }\n    \n    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getTotalResource());\n    root.updateClusterResource(clusterResource, new ResourceLimits(\n        clusterResource));\n    int numNodes \u003d numNodeManagers.decrementAndGet();\n\n    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n    \n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      super.completedContainer(container,\n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      super.completedContainer(reservedContainer,\n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    updateMaximumAllocation(node, false);\n\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "d36b6e045f317c94e97cb41a163aa974d161a404": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4344. NMs reconnecting with changed capabilities can lead to wrong cluster resource calculations. Contributed by Varun Vasudev\n",
      "commitDate": "23/11/15 12:30 PM",
      "commitName": "d36b6e045f317c94e97cb41a163aa974d161a404",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "24/10/15 10:53 PM",
      "commitNameOld": "ab8eb8770c8b8bff41dacb1a399d75906abb1ac4",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 29.61,
      "commitsBetweenForRepo": 230,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,45 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     // update this node to node label manager\n     if (labelManager !\u003d null) {\n       labelManager.deactivateNode(nodeInfo.getNodeID());\n     }\n     \n     FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n-    Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n+    Resources.subtractFrom(clusterResource, node.getTotalResource());\n     root.updateClusterResource(clusterResource, new ResourceLimits(\n         clusterResource));\n     int numNodes \u003d numNodeManagers.decrementAndGet();\n \n     if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n       asyncSchedulerThread.suspendSchedule();\n     }\n     \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer, \n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     updateMaximumAllocation(node, false);\n \n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    // update this node to node label manager\n    if (labelManager !\u003d null) {\n      labelManager.deactivateNode(nodeInfo.getNodeID());\n    }\n    \n    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getTotalResource());\n    root.updateClusterResource(clusterResource, new ResourceLimits(\n        clusterResource));\n    int numNodes \u003d numNodeManagers.decrementAndGet();\n\n    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n    \n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    updateMaximumAllocation(node, false);\n\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "14dd647c556016d351f425ee956ccf800ccb9ce2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3265. Fixed a deadlock in CapacityScheduler by always passing a queue\u0027s available resource-limit from the parent queue. Contributed by Wangda Tan.\n",
      "commitDate": "02/03/15 5:52 PM",
      "commitName": "14dd647c556016d351f425ee956ccf800ccb9ce2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "09/02/15 8:34 PM",
      "commitNameOld": "23bf6c72071782e3fd5a628e21495d6b974c7a9e",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 20.89,
      "commitsBetweenForRepo": 211,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,45 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     // update this node to node label manager\n     if (labelManager !\u003d null) {\n       labelManager.deactivateNode(nodeInfo.getNodeID());\n     }\n     \n     FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n-    root.updateClusterResource(clusterResource);\n+    root.updateClusterResource(clusterResource, new ResourceLimits(\n+        clusterResource));\n     int numNodes \u003d numNodeManagers.decrementAndGet();\n \n     if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n       asyncSchedulerThread.suspendSchedule();\n     }\n     \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer, \n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     updateMaximumAllocation(node, false);\n \n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    // update this node to node label manager\n    if (labelManager !\u003d null) {\n      labelManager.deactivateNode(nodeInfo.getNodeID());\n    }\n    \n    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n    root.updateClusterResource(clusterResource, new ResourceLimits(\n        clusterResource));\n    int numNodes \u003d numNodeManagers.decrementAndGet();\n\n    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n    \n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    updateMaximumAllocation(node, false);\n\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2604. Scheduler should consider max-allocation-* in conjunction with the largest node. (Robert Kanter via kasha)\n",
      "commitDate": "21/11/14 10:32 AM",
      "commitName": "3114d4731dcca7cb6c16aaa7c7a6550b7dd7dccb",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "04/11/14 5:45 PM",
      "commitNameOld": "b2cd2698028118b6384904732dbf94942f644732",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 16.7,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,44 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     // update this node to node label manager\n     if (labelManager !\u003d null) {\n       labelManager.deactivateNode(nodeInfo.getNodeID());\n     }\n     \n     FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n     root.updateClusterResource(clusterResource);\n     int numNodes \u003d numNodeManagers.decrementAndGet();\n \n     if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n       asyncSchedulerThread.suspendSchedule();\n     }\n     \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer, \n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n+    updateMaximumAllocation(node, false);\n \n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    // update this node to node label manager\n    if (labelManager !\u003d null) {\n      labelManager.deactivateNode(nodeInfo.getNodeID());\n    }\n    \n    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n    root.updateClusterResource(clusterResource);\n    int numNodes \u003d numNodeManagers.decrementAndGet();\n\n    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n    \n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    updateMaximumAllocation(node, false);\n\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "f2ea555ac6c06a3f2f6559731f48711fff05d3f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2496. Enhanced Capacity Scheduler to have basic support for allocating resources based on node-labels. Contributed by Wangda Tan.\nYARN-2500. Ehnaced ResourceManager to support schedulers allocating resources based on node-labels. Contributed by Wangda Tan.\n",
      "commitDate": "15/10/14 6:33 PM",
      "commitName": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/10/14 2:09 PM",
      "commitNameOld": "f9680d9a160ee527c8f2c1494584abf1a1f70f82",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 2.18,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,43 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n+    // update this node to node label manager\n+    if (labelManager !\u003d null) {\n+      labelManager.deactivateNode(nodeInfo.getNodeID());\n+    }\n+    \n     FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n     root.updateClusterResource(clusterResource);\n     int numNodes \u003d numNodeManagers.decrementAndGet();\n \n     if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n       asyncSchedulerThread.suspendSchedule();\n     }\n     \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer, \n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n+\n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    // update this node to node label manager\n    if (labelManager !\u003d null) {\n      labelManager.deactivateNode(nodeInfo.getNodeID());\n    }\n    \n    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n    root.updateClusterResource(clusterResource);\n    int numNodes \u003d numNodeManagers.decrementAndGet();\n\n    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n    \n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "9571db19ebe39a2e654f754fd82c73c8fc865c15": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2171. Improved CapacityScheduling to not lock on nodemanager-count when AMs heartbeat in. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605616 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/06/14 2:56 PM",
      "commitName": "9571db19ebe39a2e654f754fd82c73c8fc865c15",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/06/14 9:42 PM",
      "commitNameOld": "c3f1c30e65cc6a10928299f50801782ecbb4ccb6",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.72,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n     root.updateClusterResource(clusterResource);\n-    --numNodeManagers;\n+    int numNodes \u003d numNodeManagers.decrementAndGet();\n \n-    if (scheduleAsynchronously \u0026\u0026 numNodeManagers \u003d\u003d 0) {\n+    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n       asyncSchedulerThread.suspendSchedule();\n     }\n     \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer, \n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n    root.updateClusterResource(clusterResource);\n    int numNodes \u003d numNodeManagers.decrementAndGet();\n\n    if (scheduleAsynchronously \u0026\u0026 numNodes \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n    \n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2017. Merged some of the common scheduler code. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1596753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/05/14 10:32 PM",
      "commitName": "82f3454f5ac1f1c457e668e2cee12b4dcc800ee1",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/03/14 7:53 PM",
      "commitNameOld": "57cdf8626a32b8595a645b7551f46ab950db4789",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 65.11,
      "commitsBetweenForRepo": 406,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,37 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n-    FiCaSchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n+    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n     root.updateClusterResource(clusterResource);\n     --numNodeManagers;\n \n     if (scheduleAsynchronously \u0026\u0026 numNodeManagers \u003d\u003d 0) {\n       asyncSchedulerThread.suspendSchedule();\n     }\n     \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer, \n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    FiCaSchedulerNode node \u003d nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n    root.updateClusterResource(clusterResource);\n    --numNodeManagers;\n\n    if (scheduleAsynchronously \u0026\u0026 numNodeManagers \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n    \n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "57cdf8626a32b8595a645b7551f46ab950db4789": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1512. Enhanced CapacityScheduler to be able to decouple scheduling from node-heartbeats. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1578722 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/03/14 7:53 PM",
      "commitName": "57cdf8626a32b8595a645b7551f46ab950db4789",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/03/14 3:22 PM",
      "commitNameOld": "92317e3459b502f33a3575c247f05d64e5d39a00",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.19,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,37 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     FiCaSchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n     root.updateClusterResource(clusterResource);\n     --numNodeManagers;\n \n+    if (scheduleAsynchronously \u0026\u0026 numNodeManagers \u003d\u003d 0) {\n+      asyncSchedulerThread.suspendSchedule();\n+    }\n+    \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer, \n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    FiCaSchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n    root.updateClusterResource(clusterResource);\n    --numNodeManagers;\n\n    if (scheduleAsynchronously \u0026\u0026 numNodeManagers \u003d\u003d 0) {\n      asyncSchedulerThread.suspendSchedule();\n    }\n    \n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    FiCaSchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n    root.updateClusterResource(clusterResource);\n    --numNodeManagers;\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "09/03/12 3:34 PM",
      "commitNameOld": "ed4c222d5c0aeb4a46a2dd8a6342c85e88f31d3b",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 129.09,
      "commitsBetweenForRepo": 802,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n-    SchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n+    FiCaSchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n     if (node \u003d\u003d null) {\n       return;\n     }\n     Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n     root.updateClusterResource(clusterResource);\n     --numNodeManagers;\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer, \n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    FiCaSchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n    root.updateClusterResource(clusterResource);\n    --numNodeManagers;\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "c0572656ced07a885f848c1134edd7b1c291d246": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3730. Modified RM to allow restarted NMs to be able to join the cluster without waiting for expiry. Contributed by Jason Lowe.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1293436 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/02/12 1:39 PM",
      "commitName": "c0572656ced07a885f848c1134edd7b1c291d246",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "30/01/12 10:22 PM",
      "commitNameOld": "7ed0f74997ad8af0aaea7a2e54d6c1e3abbee33d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 24.64,
      "commitsBetweenForRepo": 176,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,33 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     SchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n-    Resources.subtractFrom(clusterResource, nodeInfo.getTotalCapability());\n+    if (node \u003d\u003d null) {\n+      return;\n+    }\n+    Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n     root.updateClusterResource(clusterResource);\n     --numNodeManagers;\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container, \n           SchedulerUtils.createAbnormalContainerStatus(\n               container.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer, \n           SchedulerUtils.createAbnormalContainerStatus(\n               reservedContainer.getContainerId(), \n               SchedulerUtils.LOST_CONTAINER), \n           RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    SchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n    if (node \u003d\u003d null) {\n      return;\n    }\n    Resources.subtractFrom(clusterResource, node.getRMNode().getTotalCapability());\n    root.updateClusterResource(clusterResource);\n    --numNodeManagers;\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "817ead65b99f465fc2dfa18072cf23cadf5f05d0": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2933. Change allocate call to return ContainerStatus for completed containers rather than Container.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169484 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/09/11 10:26 AM",
      "commitName": "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "08/09/11 11:26 AM",
      "commitNameOld": "1f46b991da9b91585608a0babd3eda39485dce09",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 2.96,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,30 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     SchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n     Resources.subtractFrom(clusterResource, nodeInfo.getTotalCapability());\n     root.updateClusterResource(clusterResource);\n     --numNodeManagers;\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n-      completedContainer(container, RMContainerEventType.KILL);\n+      completedContainer(container, \n+          SchedulerUtils.createAbnormalContainerStatus(\n+              container.getContainerId(), \n+              SchedulerUtils.LOST_CONTAINER), \n+          RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n-      completedContainer(reservedContainer, RMContainerEventType.KILL);\n+      completedContainer(reservedContainer, \n+          SchedulerUtils.createAbnormalContainerStatus(\n+              reservedContainer.getContainerId(), \n+              SchedulerUtils.LOST_CONTAINER), \n+          RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    SchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n    Resources.subtractFrom(clusterResource, nodeInfo.getTotalCapability());\n    root.updateClusterResource(clusterResource);\n    --numNodeManagers;\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, \n          SchedulerUtils.createAbnormalContainerStatus(\n              container.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, \n          SchedulerUtils.createAbnormalContainerStatus(\n              reservedContainer.getContainerId(), \n              SchedulerUtils.LOST_CONTAINER), \n          RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "6b608aad7d52b524fa94955a538e8b3524d42d93": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2697. Enhance CapacityScheduler to cap concurrently running applications per-queue \u0026 per-user.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165403 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/09/11 12:49 PM",
      "commitName": "6b608aad7d52b524fa94955a538e8b3524d42d93",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 11.82,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,22 @@\n   private synchronized void removeNode(RMNode nodeInfo) {\n     SchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n     Resources.subtractFrom(clusterResource, nodeInfo.getTotalCapability());\n+    root.updateClusterResource(clusterResource);\n     --numNodeManagers;\n \n     // Remove running containers\n     List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n     for (RMContainer container : runningContainers) {\n       completedContainer(container, RMContainerEventType.KILL);\n     }\n     \n     // Remove reservations, if any\n     RMContainer reservedContainer \u003d node.getReservedContainer();\n     if (reservedContainer !\u003d null) {\n       completedContainer(reservedContainer, RMContainerEventType.KILL);\n     }\n \n     this.nodes.remove(nodeInfo.getNodeID());\n     LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n         \" clusterResource: \" + clusterResource);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    SchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n    Resources.subtractFrom(clusterResource, nodeInfo.getTotalCapability());\n    root.updateClusterResource(clusterResource);\n    --numNodeManagers;\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    SchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n    Resources.subtractFrom(clusterResource, nodeInfo.getTotalCapability());\n    --numNodeManagers;\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,21 @@\n+  private synchronized void removeNode(RMNode nodeInfo) {\n+    SchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n+    Resources.subtractFrom(clusterResource, nodeInfo.getTotalCapability());\n+    --numNodeManagers;\n+\n+    // Remove running containers\n+    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n+    for (RMContainer container : runningContainers) {\n+      completedContainer(container, RMContainerEventType.KILL);\n+    }\n+    \n+    // Remove reservations, if any\n+    RMContainer reservedContainer \u003d node.getReservedContainer();\n+    if (reservedContainer !\u003d null) {\n+      completedContainer(reservedContainer, RMContainerEventType.KILL);\n+    }\n+\n+    this.nodes.remove(nodeInfo.getNodeID());\n+    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n+        \" clusterResource: \" + clusterResource);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private synchronized void removeNode(RMNode nodeInfo) {\n    SchedulerNode node \u003d this.nodes.get(nodeInfo.getNodeID());\n    Resources.subtractFrom(clusterResource, nodeInfo.getTotalCapability());\n    --numNodeManagers;\n\n    // Remove running containers\n    List\u003cRMContainer\u003e runningContainers \u003d node.getRunningContainers();\n    for (RMContainer container : runningContainers) {\n      completedContainer(container, RMContainerEventType.KILL);\n    }\n    \n    // Remove reservations, if any\n    RMContainer reservedContainer \u003d node.getReservedContainer();\n    if (reservedContainer !\u003d null) {\n      completedContainer(reservedContainer, RMContainerEventType.KILL);\n    }\n\n    this.nodes.remove(nodeInfo.getNodeID());\n    LOG.info(\"Removed node \" + nodeInfo.getNodeAddress() + \n        \" clusterResource: \" + clusterResource);\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}