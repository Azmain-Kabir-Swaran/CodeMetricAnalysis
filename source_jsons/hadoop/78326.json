{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "HCFSMountTableConfigLoader.java",
  "functionName": "load",
  "functionId": "load___mountTableConfigPath-String__conf-Configuration",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/HCFSMountTableConfigLoader.java",
  "functionStartLine": 58,
  "functionEndLine": 113,
  "numCommitsSeen": 2,
  "timeTaken": 1196,
  "changeHistory": [
    "4734c77b4b64b7c6432da4cc32881aba85f94ea1",
    "ac4a2e11d98827c7926a34cda27aa7bcfd3f36c1"
  ],
  "changeHistoryShort": {
    "4734c77b4b64b7c6432da4cc32881aba85f94ea1": "Ybodychange",
    "ac4a2e11d98827c7926a34cda27aa7bcfd3f36c1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4734c77b4b64b7c6432da4cc32881aba85f94ea1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15322. Make NflyFS to work when ViewFsOverloadScheme\u0027s scheme and target uris schemes are same. Contributed by Uma Maheswara Rao G.\n\n",
      "commitDate": "21/05/20 9:34 PM",
      "commitName": "4734c77b4b64b7c6432da4cc32881aba85f94ea1",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "14/05/20 5:29 PM",
      "commitNameOld": "ac4a2e11d98827c7926a34cda27aa7bcfd3f36c1",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 7.17,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,56 @@\n   public void load(String mountTableConfigPath, Configuration conf)\n       throws IOException {\n     this.mountTable \u003d new Path(mountTableConfigPath);\n     String scheme \u003d mountTable.toUri().getScheme();\n-    ViewFileSystem.FsGetter fsGetter \u003d\n-        new ViewFileSystemOverloadScheme.ChildFsGetter(scheme);\n+    FsGetter fsGetter \u003d new ViewFileSystemOverloadScheme.ChildFsGetter(scheme);\n     try (FileSystem fs \u003d fsGetter.getNewInstance(mountTable.toUri(), conf)) {\n       RemoteIterator\u003cLocatedFileStatus\u003e listFiles \u003d\n           fs.listFiles(mountTable, false);\n       LocatedFileStatus lfs \u003d null;\n       int higherVersion \u003d -1;\n       while (listFiles.hasNext()) {\n         LocatedFileStatus curLfs \u003d listFiles.next();\n         String cur \u003d curLfs.getPath().getName();\n         String[] nameParts \u003d cur.split(REGEX_DOT);\n         if (nameParts.length \u003c 2) {\n           logInvalidFileNameFormat(cur);\n           continue; // invalid file name\n         }\n         int curVersion \u003d higherVersion;\n         try {\n           curVersion \u003d Integer.parseInt(nameParts[nameParts.length - 2]);\n         } catch (NumberFormatException nfe) {\n           logInvalidFileNameFormat(cur);\n           continue;\n         }\n \n         if (curVersion \u003e higherVersion) {\n           higherVersion \u003d curVersion;\n           lfs \u003d curLfs;\n         }\n       }\n \n       if (lfs \u003d\u003d null) {\n         // No valid mount table file found.\n         // TODO: Should we fail? Currently viewfs init will fail if no mount\n         // links anyway.\n         LOGGER.warn(\"No valid mount-table file exist at: {}. At least one \"\n             + \"mount-table file should present with the name format: \"\n             + \"mount-table.\u003cversionNumber\u003e.xml\", mountTableConfigPath);\n         return;\n       }\n       // Latest version file.\n       Path latestVersionMountTable \u003d lfs.getPath();\n       if (LOGGER.isDebugEnabled()) {\n         LOGGER.debug(\"Loading the mount-table {} into configuration.\",\n             latestVersionMountTable);\n       }\n       try (FSDataInputStream open \u003d fs.open(latestVersionMountTable)) {\n         Configuration newConf \u003d new Configuration(false);\n         newConf.addResource(open);\n         // This will add configuration props as resource, instead of stream\n         // itself. So, that stream can be closed now.\n         conf.addResource(newConf);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void load(String mountTableConfigPath, Configuration conf)\n      throws IOException {\n    this.mountTable \u003d new Path(mountTableConfigPath);\n    String scheme \u003d mountTable.toUri().getScheme();\n    FsGetter fsGetter \u003d new ViewFileSystemOverloadScheme.ChildFsGetter(scheme);\n    try (FileSystem fs \u003d fsGetter.getNewInstance(mountTable.toUri(), conf)) {\n      RemoteIterator\u003cLocatedFileStatus\u003e listFiles \u003d\n          fs.listFiles(mountTable, false);\n      LocatedFileStatus lfs \u003d null;\n      int higherVersion \u003d -1;\n      while (listFiles.hasNext()) {\n        LocatedFileStatus curLfs \u003d listFiles.next();\n        String cur \u003d curLfs.getPath().getName();\n        String[] nameParts \u003d cur.split(REGEX_DOT);\n        if (nameParts.length \u003c 2) {\n          logInvalidFileNameFormat(cur);\n          continue; // invalid file name\n        }\n        int curVersion \u003d higherVersion;\n        try {\n          curVersion \u003d Integer.parseInt(nameParts[nameParts.length - 2]);\n        } catch (NumberFormatException nfe) {\n          logInvalidFileNameFormat(cur);\n          continue;\n        }\n\n        if (curVersion \u003e higherVersion) {\n          higherVersion \u003d curVersion;\n          lfs \u003d curLfs;\n        }\n      }\n\n      if (lfs \u003d\u003d null) {\n        // No valid mount table file found.\n        // TODO: Should we fail? Currently viewfs init will fail if no mount\n        // links anyway.\n        LOGGER.warn(\"No valid mount-table file exist at: {}. At least one \"\n            + \"mount-table file should present with the name format: \"\n            + \"mount-table.\u003cversionNumber\u003e.xml\", mountTableConfigPath);\n        return;\n      }\n      // Latest version file.\n      Path latestVersionMountTable \u003d lfs.getPath();\n      if (LOGGER.isDebugEnabled()) {\n        LOGGER.debug(\"Loading the mount-table {} into configuration.\",\n            latestVersionMountTable);\n      }\n      try (FSDataInputStream open \u003d fs.open(latestVersionMountTable)) {\n        Configuration newConf \u003d new Configuration(false);\n        newConf.addResource(open);\n        // This will add configuration props as resource, instead of stream\n        // itself. So, that stream can be closed now.\n        conf.addResource(newConf);\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/HCFSMountTableConfigLoader.java",
      "extendedDetails": {}
    },
    "ac4a2e11d98827c7926a34cda27aa7bcfd3f36c1": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-15306. Make mount-table to read from central place ( Let\u0027s say from HDFS). Contributed by Uma Maheswara Rao G.\n\n",
      "commitDate": "14/05/20 5:29 PM",
      "commitName": "ac4a2e11d98827c7926a34cda27aa7bcfd3f36c1",
      "commitAuthor": "Uma Maheswara Rao G",
      "diff": "@@ -0,0 +1,57 @@\n+  public void load(String mountTableConfigPath, Configuration conf)\n+      throws IOException {\n+    this.mountTable \u003d new Path(mountTableConfigPath);\n+    String scheme \u003d mountTable.toUri().getScheme();\n+    ViewFileSystem.FsGetter fsGetter \u003d\n+        new ViewFileSystemOverloadScheme.ChildFsGetter(scheme);\n+    try (FileSystem fs \u003d fsGetter.getNewInstance(mountTable.toUri(), conf)) {\n+      RemoteIterator\u003cLocatedFileStatus\u003e listFiles \u003d\n+          fs.listFiles(mountTable, false);\n+      LocatedFileStatus lfs \u003d null;\n+      int higherVersion \u003d -1;\n+      while (listFiles.hasNext()) {\n+        LocatedFileStatus curLfs \u003d listFiles.next();\n+        String cur \u003d curLfs.getPath().getName();\n+        String[] nameParts \u003d cur.split(REGEX_DOT);\n+        if (nameParts.length \u003c 2) {\n+          logInvalidFileNameFormat(cur);\n+          continue; // invalid file name\n+        }\n+        int curVersion \u003d higherVersion;\n+        try {\n+          curVersion \u003d Integer.parseInt(nameParts[nameParts.length - 2]);\n+        } catch (NumberFormatException nfe) {\n+          logInvalidFileNameFormat(cur);\n+          continue;\n+        }\n+\n+        if (curVersion \u003e higherVersion) {\n+          higherVersion \u003d curVersion;\n+          lfs \u003d curLfs;\n+        }\n+      }\n+\n+      if (lfs \u003d\u003d null) {\n+        // No valid mount table file found.\n+        // TODO: Should we fail? Currently viewfs init will fail if no mount\n+        // links anyway.\n+        LOGGER.warn(\"No valid mount-table file exist at: {}. At least one \"\n+            + \"mount-table file should present with the name format: \"\n+            + \"mount-table.\u003cversionNumber\u003e.xml\", mountTableConfigPath);\n+        return;\n+      }\n+      // Latest version file.\n+      Path latestVersionMountTable \u003d lfs.getPath();\n+      if (LOGGER.isDebugEnabled()) {\n+        LOGGER.debug(\"Loading the mount-table {} into configuration.\",\n+            latestVersionMountTable);\n+      }\n+      try (FSDataInputStream open \u003d fs.open(latestVersionMountTable)) {\n+        Configuration newConf \u003d new Configuration(false);\n+        newConf.addResource(open);\n+        // This will add configuration props as resource, instead of stream\n+        // itself. So, that stream can be closed now.\n+        conf.addResource(newConf);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void load(String mountTableConfigPath, Configuration conf)\n      throws IOException {\n    this.mountTable \u003d new Path(mountTableConfigPath);\n    String scheme \u003d mountTable.toUri().getScheme();\n    ViewFileSystem.FsGetter fsGetter \u003d\n        new ViewFileSystemOverloadScheme.ChildFsGetter(scheme);\n    try (FileSystem fs \u003d fsGetter.getNewInstance(mountTable.toUri(), conf)) {\n      RemoteIterator\u003cLocatedFileStatus\u003e listFiles \u003d\n          fs.listFiles(mountTable, false);\n      LocatedFileStatus lfs \u003d null;\n      int higherVersion \u003d -1;\n      while (listFiles.hasNext()) {\n        LocatedFileStatus curLfs \u003d listFiles.next();\n        String cur \u003d curLfs.getPath().getName();\n        String[] nameParts \u003d cur.split(REGEX_DOT);\n        if (nameParts.length \u003c 2) {\n          logInvalidFileNameFormat(cur);\n          continue; // invalid file name\n        }\n        int curVersion \u003d higherVersion;\n        try {\n          curVersion \u003d Integer.parseInt(nameParts[nameParts.length - 2]);\n        } catch (NumberFormatException nfe) {\n          logInvalidFileNameFormat(cur);\n          continue;\n        }\n\n        if (curVersion \u003e higherVersion) {\n          higherVersion \u003d curVersion;\n          lfs \u003d curLfs;\n        }\n      }\n\n      if (lfs \u003d\u003d null) {\n        // No valid mount table file found.\n        // TODO: Should we fail? Currently viewfs init will fail if no mount\n        // links anyway.\n        LOGGER.warn(\"No valid mount-table file exist at: {}. At least one \"\n            + \"mount-table file should present with the name format: \"\n            + \"mount-table.\u003cversionNumber\u003e.xml\", mountTableConfigPath);\n        return;\n      }\n      // Latest version file.\n      Path latestVersionMountTable \u003d lfs.getPath();\n      if (LOGGER.isDebugEnabled()) {\n        LOGGER.debug(\"Loading the mount-table {} into configuration.\",\n            latestVersionMountTable);\n      }\n      try (FSDataInputStream open \u003d fs.open(latestVersionMountTable)) {\n        Configuration newConf \u003d new Configuration(false);\n        newConf.addResource(open);\n        // This will add configuration props as resource, instead of stream\n        // itself. So, that stream can be closed now.\n        conf.addResource(newConf);\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/HCFSMountTableConfigLoader.java"
    }
  }
}