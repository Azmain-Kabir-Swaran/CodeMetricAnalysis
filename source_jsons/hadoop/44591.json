{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LogsCLI.java",
  "functionName": "fetchContainerLogs",
  "functionId": "fetchContainerLogs___request-ContainerLogsRequest__logCliHelper-LogCLIHelpers__useRegex-boolean__ignoreSizeLimit-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
  "functionStartLine": 1061,
  "functionEndLine": 1152,
  "numCommitsSeen": 140,
  "timeTaken": 7570,
  "changeHistory": [
    "ec2ae3060a807c8754826af2135a68c08b2e4f13",
    "64f68cb0b8c0b93d37699893b812b37c4b05c939",
    "871dc420f8a4f151189c0925e062c64859a8f275",
    "e605d47df05619c6b1c18aca59f709899498da75",
    "3818393297c7b337e380e8111a55f2ac4745cb83",
    "7e5355c14e55fd6540f7f070df4b78fa94a81618",
    "429347289c7787364e654334cd84115ae40bb22d",
    "eb471632349deac4b62f8dec853c8ceb64c9617a",
    "6ab5aa1c1f82f81726c6daa38b3db90d8c3ad856",
    "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1",
    "ef1757790d89cc72f88f5330761b1c8901c59e94",
    "87f5e351337a905af5215af76c72b9312616cd4f",
    "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835"
  ],
  "changeHistoryShort": {
    "ec2ae3060a807c8754826af2135a68c08b2e4f13": "Ymultichange(Yparameterchange,Ybodychange)",
    "64f68cb0b8c0b93d37699893b812b37c4b05c939": "Ybodychange",
    "871dc420f8a4f151189c0925e062c64859a8f275": "Ymultichange(Yexceptionschange,Ybodychange)",
    "e605d47df05619c6b1c18aca59f709899498da75": "Ymultichange(Yparameterchange,Ybodychange)",
    "3818393297c7b337e380e8111a55f2ac4745cb83": "Ybodychange",
    "7e5355c14e55fd6540f7f070df4b78fa94a81618": "Ybodychange",
    "429347289c7787364e654334cd84115ae40bb22d": "Ybodychange",
    "eb471632349deac4b62f8dec853c8ceb64c9617a": "Ybodychange",
    "6ab5aa1c1f82f81726c6daa38b3db90d8c3ad856": "Ybodychange",
    "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1": "Ymultichange(Yparameterchange,Ybodychange)",
    "ef1757790d89cc72f88f5330761b1c8901c59e94": "Ymultichange(Yparameterchange,Ybodychange)",
    "87f5e351337a905af5215af76c72b9312616cd4f": "Ybodychange",
    "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ec2ae3060a807c8754826af2135a68c08b2e4f13": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6509. Add a size threshold beyond which yarn logs will require a force option. (Xuan Gong via wangda)\n\nChange-Id: I755fe903337d4ff9ec35dae5b9cce638794e1d0f\n",
      "commitDate": "29/09/17 4:42 PM",
      "commitName": "ec2ae3060a807c8754826af2135a68c08b2e4f13",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6509. Add a size threshold beyond which yarn logs will require a force option. (Xuan Gong via wangda)\n\nChange-Id: I755fe903337d4ff9ec35dae5b9cce638794e1d0f\n",
          "commitDate": "29/09/17 4:42 PM",
          "commitName": "ec2ae3060a807c8754826af2135a68c08b2e4f13",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "15/09/17 3:33 PM",
          "commitNameOld": "1a84c24b0cf6674fa755403971fa57d8e412b320",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 14.05,
          "commitsBetweenForRepo": 103,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,92 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n-      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException,\n-      ClientHandlerException, UniformInterfaceException, JSONException {\n-    int resultCode \u003d 0;\n+      LogCLIHelpers logCliHelper, boolean useRegex, boolean ignoreSizeLimit)\n+      throws IOException, ClientHandlerException, UniformInterfaceException,\n+      JSONException {\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n     // if the application is in the final state,\n     // we could directly get logs from HDFS.\n     if (isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n+      ContainerLogsRequest newOptions \u003d getMatchedLogOptions(\n+          request, logCliHelper, useRegex, ignoreSizeLimit);\n+      if (newOptions \u003d\u003d null) {\n+        System.err.println(\"Can not find any log file matching the pattern: \"\n+            + request.getLogTypes() + \" for the container: \"\n+            + request.getContainerId() + \" within the application: \"\n+            + request.getAppId());\n+        return -1;\n+      }\n       if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n-        return printContainerLogsForFinishedApplication(\n-            request, logCliHelper, useRegex);\n+        return logCliHelper.dumpAContainerLogsForLogType(newOptions);\n       } else {\n-        return printContainerLogsForFinishedApplicationWithoutNodeId(\n-            request, logCliHelper, useRegex);\n+        return logCliHelper.dumpAContainerLogsForLogTypeWithoutNodeId(\n+            newOptions);\n       }\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d report.getNodeHttpAddress();\n       if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n         nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                 WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n         request.setNodeHttpAddress(nodeHttpAddress);\n       }\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n       request.setContainerState(report.getContainerState());\n     } catch (IOException | YarnException ex) {\n       nodeHttpAddress \u003d getNodeHttpAddressFromRMWebString(request);\n       if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n         request.setNodeHttpAddress(nodeHttpAddress);\n       } else {\n         // for the case, we have already uploaded partial logs in HDFS\n         int result \u003d -1;\n-        if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n-          result \u003d printAggregatedContainerLogs(request,\n-              logCliHelper, useRegex);\n+        ContainerLogsRequest newOptions \u003d getMatchedLogOptions(\n+                request, logCliHelper, useRegex, ignoreSizeLimit);\n+        if (newOptions \u003d\u003d null) {\n+          System.err.println(\"Can not find any log file matching the pattern: \"\n+              + request.getLogTypes() + \" for the container: \"\n+              + request.getContainerId() + \" within the application: \"\n+              + request.getAppId());\n         } else {\n-          result \u003d printAggregatedContainerLogsWithoutNodeId(request,\n-              logCliHelper,\n-                  useRegex);\n+          if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n+            result \u003d logCliHelper.dumpAContainerLogsForLogType(newOptions);\n+          } else {\n+            result \u003d logCliHelper.dumpAContainerLogsForLogTypeWithoutNodeId(\n+                newOptions);\n+          }\n         }\n         if (result \u003d\u003d -1) {\n           System.err.println(\n               \"Unable to get logs for this container:\"\n                   + containerIdStr + \" for the application:\"\n                   + appIdStr + \" with the appOwner: \" + appOwner);\n           System.err.println(\"The application: \" + appIdStr\n               + \" is still running, and we can not get Container report \"\n               + \"for the container: \" + containerIdStr + \". Please try later \"\n               + \"or after the application finishes.\");\n         }\n         return result;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n-    resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n-        logCliHelper, useRegex);\n-    return resultCode;\n+    ContainerLogsRequest newRequest \u003d getMatchedOptionForRunningApp(\n+        request, useRegex, ignoreSizeLimit);\n+    if (newRequest \u003d\u003d null) {\n+      return -1;\n+    }\n+    return printContainerLogsFromRunningApplication(getConf(), request,\n+          logCliHelper, useRegex, ignoreSizeLimit);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper, boolean useRegex, boolean ignoreSizeLimit)\n      throws IOException, ClientHandlerException, UniformInterfaceException,\n      JSONException {\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    // if the application is in the final state,\n    // we could directly get logs from HDFS.\n    if (isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      ContainerLogsRequest newOptions \u003d getMatchedLogOptions(\n          request, logCliHelper, useRegex, ignoreSizeLimit);\n      if (newOptions \u003d\u003d null) {\n        System.err.println(\"Can not find any log file matching the pattern: \"\n            + request.getLogTypes() + \" for the container: \"\n            + request.getContainerId() + \" within the application: \"\n            + request.getAppId());\n        return -1;\n      }\n      if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n        return logCliHelper.dumpAContainerLogsForLogType(newOptions);\n      } else {\n        return logCliHelper.dumpAContainerLogsForLogTypeWithoutNodeId(\n            newOptions);\n      }\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d report.getNodeHttpAddress();\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        request.setNodeHttpAddress(nodeHttpAddress);\n      }\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setContainerState(report.getContainerState());\n    } catch (IOException | YarnException ex) {\n      nodeHttpAddress \u003d getNodeHttpAddressFromRMWebString(request);\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        request.setNodeHttpAddress(nodeHttpAddress);\n      } else {\n        // for the case, we have already uploaded partial logs in HDFS\n        int result \u003d -1;\n        ContainerLogsRequest newOptions \u003d getMatchedLogOptions(\n                request, logCliHelper, useRegex, ignoreSizeLimit);\n        if (newOptions \u003d\u003d null) {\n          System.err.println(\"Can not find any log file matching the pattern: \"\n              + request.getLogTypes() + \" for the container: \"\n              + request.getContainerId() + \" within the application: \"\n              + request.getAppId());\n        } else {\n          if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n            result \u003d logCliHelper.dumpAContainerLogsForLogType(newOptions);\n          } else {\n            result \u003d logCliHelper.dumpAContainerLogsForLogTypeWithoutNodeId(\n                newOptions);\n          }\n        }\n        if (result \u003d\u003d -1) {\n          System.err.println(\n              \"Unable to get logs for this container:\"\n                  + containerIdStr + \" for the application:\"\n                  + appIdStr + \" with the appOwner: \" + appOwner);\n          System.err.println(\"The application: \" + appIdStr\n              + \" is still running, and we can not get Container report \"\n              + \"for the container: \" + containerIdStr + \". Please try later \"\n              + \"or after the application finishes.\");\n        }\n        return result;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    ContainerLogsRequest newRequest \u003d getMatchedOptionForRunningApp(\n        request, useRegex, ignoreSizeLimit);\n    if (newRequest \u003d\u003d null) {\n      return -1;\n    }\n    return printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper, useRegex, ignoreSizeLimit);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
          "extendedDetails": {
            "oldValue": "[request-ContainerLogsRequest, logCliHelper-LogCLIHelpers, useRegex-boolean]",
            "newValue": "[request-ContainerLogsRequest, logCliHelper-LogCLIHelpers, useRegex-boolean, ignoreSizeLimit-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6509. Add a size threshold beyond which yarn logs will require a force option. (Xuan Gong via wangda)\n\nChange-Id: I755fe903337d4ff9ec35dae5b9cce638794e1d0f\n",
          "commitDate": "29/09/17 4:42 PM",
          "commitName": "ec2ae3060a807c8754826af2135a68c08b2e4f13",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "15/09/17 3:33 PM",
          "commitNameOld": "1a84c24b0cf6674fa755403971fa57d8e412b320",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 14.05,
          "commitsBetweenForRepo": 103,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,92 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n-      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException,\n-      ClientHandlerException, UniformInterfaceException, JSONException {\n-    int resultCode \u003d 0;\n+      LogCLIHelpers logCliHelper, boolean useRegex, boolean ignoreSizeLimit)\n+      throws IOException, ClientHandlerException, UniformInterfaceException,\n+      JSONException {\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n     // if the application is in the final state,\n     // we could directly get logs from HDFS.\n     if (isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n+      ContainerLogsRequest newOptions \u003d getMatchedLogOptions(\n+          request, logCliHelper, useRegex, ignoreSizeLimit);\n+      if (newOptions \u003d\u003d null) {\n+        System.err.println(\"Can not find any log file matching the pattern: \"\n+            + request.getLogTypes() + \" for the container: \"\n+            + request.getContainerId() + \" within the application: \"\n+            + request.getAppId());\n+        return -1;\n+      }\n       if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n-        return printContainerLogsForFinishedApplication(\n-            request, logCliHelper, useRegex);\n+        return logCliHelper.dumpAContainerLogsForLogType(newOptions);\n       } else {\n-        return printContainerLogsForFinishedApplicationWithoutNodeId(\n-            request, logCliHelper, useRegex);\n+        return logCliHelper.dumpAContainerLogsForLogTypeWithoutNodeId(\n+            newOptions);\n       }\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d report.getNodeHttpAddress();\n       if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n         nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                 WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n         request.setNodeHttpAddress(nodeHttpAddress);\n       }\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n       request.setContainerState(report.getContainerState());\n     } catch (IOException | YarnException ex) {\n       nodeHttpAddress \u003d getNodeHttpAddressFromRMWebString(request);\n       if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n         request.setNodeHttpAddress(nodeHttpAddress);\n       } else {\n         // for the case, we have already uploaded partial logs in HDFS\n         int result \u003d -1;\n-        if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n-          result \u003d printAggregatedContainerLogs(request,\n-              logCliHelper, useRegex);\n+        ContainerLogsRequest newOptions \u003d getMatchedLogOptions(\n+                request, logCliHelper, useRegex, ignoreSizeLimit);\n+        if (newOptions \u003d\u003d null) {\n+          System.err.println(\"Can not find any log file matching the pattern: \"\n+              + request.getLogTypes() + \" for the container: \"\n+              + request.getContainerId() + \" within the application: \"\n+              + request.getAppId());\n         } else {\n-          result \u003d printAggregatedContainerLogsWithoutNodeId(request,\n-              logCliHelper,\n-                  useRegex);\n+          if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n+            result \u003d logCliHelper.dumpAContainerLogsForLogType(newOptions);\n+          } else {\n+            result \u003d logCliHelper.dumpAContainerLogsForLogTypeWithoutNodeId(\n+                newOptions);\n+          }\n         }\n         if (result \u003d\u003d -1) {\n           System.err.println(\n               \"Unable to get logs for this container:\"\n                   + containerIdStr + \" for the application:\"\n                   + appIdStr + \" with the appOwner: \" + appOwner);\n           System.err.println(\"The application: \" + appIdStr\n               + \" is still running, and we can not get Container report \"\n               + \"for the container: \" + containerIdStr + \". Please try later \"\n               + \"or after the application finishes.\");\n         }\n         return result;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n-    resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n-        logCliHelper, useRegex);\n-    return resultCode;\n+    ContainerLogsRequest newRequest \u003d getMatchedOptionForRunningApp(\n+        request, useRegex, ignoreSizeLimit);\n+    if (newRequest \u003d\u003d null) {\n+      return -1;\n+    }\n+    return printContainerLogsFromRunningApplication(getConf(), request,\n+          logCliHelper, useRegex, ignoreSizeLimit);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper, boolean useRegex, boolean ignoreSizeLimit)\n      throws IOException, ClientHandlerException, UniformInterfaceException,\n      JSONException {\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    // if the application is in the final state,\n    // we could directly get logs from HDFS.\n    if (isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      ContainerLogsRequest newOptions \u003d getMatchedLogOptions(\n          request, logCliHelper, useRegex, ignoreSizeLimit);\n      if (newOptions \u003d\u003d null) {\n        System.err.println(\"Can not find any log file matching the pattern: \"\n            + request.getLogTypes() + \" for the container: \"\n            + request.getContainerId() + \" within the application: \"\n            + request.getAppId());\n        return -1;\n      }\n      if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n        return logCliHelper.dumpAContainerLogsForLogType(newOptions);\n      } else {\n        return logCliHelper.dumpAContainerLogsForLogTypeWithoutNodeId(\n            newOptions);\n      }\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d report.getNodeHttpAddress();\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        request.setNodeHttpAddress(nodeHttpAddress);\n      }\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setContainerState(report.getContainerState());\n    } catch (IOException | YarnException ex) {\n      nodeHttpAddress \u003d getNodeHttpAddressFromRMWebString(request);\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        request.setNodeHttpAddress(nodeHttpAddress);\n      } else {\n        // for the case, we have already uploaded partial logs in HDFS\n        int result \u003d -1;\n        ContainerLogsRequest newOptions \u003d getMatchedLogOptions(\n                request, logCliHelper, useRegex, ignoreSizeLimit);\n        if (newOptions \u003d\u003d null) {\n          System.err.println(\"Can not find any log file matching the pattern: \"\n              + request.getLogTypes() + \" for the container: \"\n              + request.getContainerId() + \" within the application: \"\n              + request.getAppId());\n        } else {\n          if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n            result \u003d logCliHelper.dumpAContainerLogsForLogType(newOptions);\n          } else {\n            result \u003d logCliHelper.dumpAContainerLogsForLogTypeWithoutNodeId(\n                newOptions);\n          }\n        }\n        if (result \u003d\u003d -1) {\n          System.err.println(\n              \"Unable to get logs for this container:\"\n                  + containerIdStr + \" for the application:\"\n                  + appIdStr + \" with the appOwner: \" + appOwner);\n          System.err.println(\"The application: \" + appIdStr\n              + \" is still running, and we can not get Container report \"\n              + \"for the container: \" + containerIdStr + \". Please try later \"\n              + \"or after the application finishes.\");\n        }\n        return result;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    ContainerLogsRequest newRequest \u003d getMatchedOptionForRunningApp(\n        request, useRegex, ignoreSizeLimit);\n    if (newRequest \u003d\u003d null) {\n      return -1;\n    }\n    return printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper, useRegex, ignoreSizeLimit);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
          "extendedDetails": {}
        }
      ]
    },
    "64f68cb0b8c0b93d37699893b812b37c4b05c939": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6520. Fix warnings from Spotbugs in hadoop-yarn-client. Contributed by Weiwei Yang.\n",
      "commitDate": "01/05/17 6:08 AM",
      "commitName": "64f68cb0b8c0b93d37699893b812b37c4b05c939",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "21/03/17 10:53 AM",
      "commitNameOld": "c01d15ab2731b6710c94ff3bfa37d496a87b0c9f",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 40.8,
      "commitsBetweenForRepo": 231,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,73 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n       LogCLIHelpers logCliHelper, boolean useRegex) throws IOException,\n       ClientHandlerException, UniformInterfaceException, JSONException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n     // if the application is in the final state,\n     // we could directly get logs from HDFS.\n     if (isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n       if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n         return printContainerLogsForFinishedApplication(\n             request, logCliHelper, useRegex);\n       } else {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             request, logCliHelper, useRegex);\n       }\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d report.getNodeHttpAddress();\n       if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n         nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                 WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n         request.setNodeHttpAddress(nodeHttpAddress);\n       }\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n       request.setContainerState(report.getContainerState());\n     } catch (IOException | YarnException ex) {\n-      if (isAppFinished) {\n-        return printContainerLogsForFinishedApplicationWithoutNodeId(\n-            request, logCliHelper, useRegex);\n+      nodeHttpAddress \u003d getNodeHttpAddressFromRMWebString(request);\n+      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n+        request.setNodeHttpAddress(nodeHttpAddress);\n       } else {\n-        nodeHttpAddress \u003d getNodeHttpAddressFromRMWebString(request);\n-        if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n-          request.setNodeHttpAddress(nodeHttpAddress);\n+        // for the case, we have already uploaded partial logs in HDFS\n+        int result \u003d -1;\n+        if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n+          result \u003d printAggregatedContainerLogs(request,\n+              logCliHelper, useRegex);\n         } else {\n-          // for the case, we have already uploaded partial logs in HDFS\n-          int result \u003d -1;\n-          if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n-            result \u003d  printAggregatedContainerLogs(\n-                request, logCliHelper, useRegex);\n-          } else {\n-            result \u003d printAggregatedContainerLogsWithoutNodeId(\n-                request, logCliHelper, useRegex);\n-          }\n-          if (result \u003d\u003d -1) {\n-            System.err.println(\"Unable to get logs for this container:\"\n-                + containerIdStr + \" for the application:\" + appIdStr\n-                + \" with the appOwner: \" + appOwner);\n-            System.err.println(\"The application: \" + appIdStr\n-                + \" is still running, and we can not get Container report \"\n-                + \"for the container: \" + containerIdStr +\". Please try later \"\n-                + \"or after the application finishes.\");\n-          }\n-          return result;\n+          result \u003d printAggregatedContainerLogsWithoutNodeId(request,\n+              logCliHelper,\n+                  useRegex);\n         }\n+        if (result \u003d\u003d -1) {\n+          System.err.println(\n+              \"Unable to get logs for this container:\"\n+                  + containerIdStr + \" for the application:\"\n+                  + appIdStr + \" with the appOwner: \" + appOwner);\n+          System.err.println(\"The application: \" + appIdStr\n+              + \" is still running, and we can not get Container report \"\n+              + \"for the container: \" + containerIdStr + \". Please try later \"\n+              + \"or after the application finishes.\");\n+        }\n+        return result;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n-    if (!isAppFinished) {\n-      resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n-          logCliHelper, useRegex);\n-    } else {\n-      // If the application is in the final state, we will directly\n-      // get the container logs from HDFS.\n-      resultCode \u003d printContainerLogsForFinishedApplication(\n-          request, logCliHelper, useRegex);\n-    }\n+    resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n+        logCliHelper, useRegex);\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException,\n      ClientHandlerException, UniformInterfaceException, JSONException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    // if the application is in the final state,\n    // we could directly get logs from HDFS.\n    if (isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n        return printContainerLogsForFinishedApplication(\n            request, logCliHelper, useRegex);\n      } else {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper, useRegex);\n      }\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d report.getNodeHttpAddress();\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        request.setNodeHttpAddress(nodeHttpAddress);\n      }\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setContainerState(report.getContainerState());\n    } catch (IOException | YarnException ex) {\n      nodeHttpAddress \u003d getNodeHttpAddressFromRMWebString(request);\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        request.setNodeHttpAddress(nodeHttpAddress);\n      } else {\n        // for the case, we have already uploaded partial logs in HDFS\n        int result \u003d -1;\n        if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n          result \u003d printAggregatedContainerLogs(request,\n              logCliHelper, useRegex);\n        } else {\n          result \u003d printAggregatedContainerLogsWithoutNodeId(request,\n              logCliHelper,\n                  useRegex);\n        }\n        if (result \u003d\u003d -1) {\n          System.err.println(\n              \"Unable to get logs for this container:\"\n                  + containerIdStr + \" for the application:\"\n                  + appIdStr + \" with the appOwner: \" + appOwner);\n          System.err.println(\"The application: \" + appIdStr\n              + \" is still running, and we can not get Container report \"\n              + \"for the container: \" + containerIdStr + \". Please try later \"\n              + \"or after the application finishes.\");\n        }\n        return result;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n        logCliHelper, useRegex);\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "871dc420f8a4f151189c0925e062c64859a8f275": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-6313. YARN logs cli should provide logs for a completed container even when application is still running. Contributed by Xuan Gong.\n\n(cherry picked from commit b88f5e0f7858d1d89b79dfd325b767c34416052d)\n",
      "commitDate": "14/03/17 12:58 PM",
      "commitName": "871dc420f8a4f151189c0925e062c64859a8f275",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-6313. YARN logs cli should provide logs for a completed container even when application is still running. Contributed by Xuan Gong.\n\n(cherry picked from commit b88f5e0f7858d1d89b79dfd325b767c34416052d)\n",
          "commitDate": "14/03/17 12:58 PM",
          "commitName": "871dc420f8a4f151189c0925e062c64859a8f275",
          "commitAuthor": "Junping Du",
          "commitDateOld": "02/02/17 12:41 AM",
          "commitNameOld": "327c9980aafce52cc02d2b8885fc4e9f628ab23c",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 40.47,
          "commitsBetweenForRepo": 227,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,83 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n-      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException {\n+      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException,\n+      ClientHandlerException, UniformInterfaceException, JSONException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n     // if the application is in the final state,\n     // we could directly get logs from HDFS.\n     if (isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n       if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n         return printContainerLogsForFinishedApplication(\n             request, logCliHelper, useRegex);\n       } else {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             request, logCliHelper, useRegex);\n       }\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d report.getNodeHttpAddress();\n       if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n         nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                 WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n         request.setNodeHttpAddress(nodeHttpAddress);\n       }\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n       request.setContainerState(report.getContainerState());\n     } catch (IOException | YarnException ex) {\n       if (isAppFinished) {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             request, logCliHelper, useRegex);\n       } else {\n-        System.err.println(\"Unable to get logs for this container:\"\n-            + containerIdStr + \"for the application:\" + appIdStr\n-            + \" with the appOwner: \" + appOwner);\n-        System.err.println(\"The application: \" + appIdStr\n-            + \" is still running, and we can not get Container report \"\n-            + \"for the container: \" + containerIdStr +\". Please try later \"\n-            + \"or after the application finishes.\");\n-        return -1;\n+        nodeHttpAddress \u003d getNodeHttpAddressFromRMWebString(request);\n+        if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n+          request.setNodeHttpAddress(nodeHttpAddress);\n+        } else {\n+          // for the case, we have already uploaded partial logs in HDFS\n+          int result \u003d -1;\n+          if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n+            result \u003d  printAggregatedContainerLogs(\n+                request, logCliHelper, useRegex);\n+          } else {\n+            result \u003d printAggregatedContainerLogsWithoutNodeId(\n+                request, logCliHelper, useRegex);\n+          }\n+          if (result \u003d\u003d -1) {\n+            System.err.println(\"Unable to get logs for this container:\"\n+                + containerIdStr + \" for the application:\" + appIdStr\n+                + \" with the appOwner: \" + appOwner);\n+            System.err.println(\"The application: \" + appIdStr\n+                + \" is still running, and we can not get Container report \"\n+                + \"for the container: \" + containerIdStr +\". Please try later \"\n+                + \"or after the application finishes.\");\n+          }\n+          return result;\n+        }\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n     if (!isAppFinished) {\n       resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n           logCliHelper, useRegex);\n     } else {\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n       resultCode \u003d printContainerLogsForFinishedApplication(\n           request, logCliHelper, useRegex);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException,\n      ClientHandlerException, UniformInterfaceException, JSONException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    // if the application is in the final state,\n    // we could directly get logs from HDFS.\n    if (isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n        return printContainerLogsForFinishedApplication(\n            request, logCliHelper, useRegex);\n      } else {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper, useRegex);\n      }\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d report.getNodeHttpAddress();\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        request.setNodeHttpAddress(nodeHttpAddress);\n      }\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setContainerState(report.getContainerState());\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper, useRegex);\n      } else {\n        nodeHttpAddress \u003d getNodeHttpAddressFromRMWebString(request);\n        if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n          request.setNodeHttpAddress(nodeHttpAddress);\n        } else {\n          // for the case, we have already uploaded partial logs in HDFS\n          int result \u003d -1;\n          if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n            result \u003d  printAggregatedContainerLogs(\n                request, logCliHelper, useRegex);\n          } else {\n            result \u003d printAggregatedContainerLogsWithoutNodeId(\n                request, logCliHelper, useRegex);\n          }\n          if (result \u003d\u003d -1) {\n            System.err.println(\"Unable to get logs for this container:\"\n                + containerIdStr + \" for the application:\" + appIdStr\n                + \" with the appOwner: \" + appOwner);\n            System.err.println(\"The application: \" + appIdStr\n                + \" is still running, and we can not get Container report \"\n                + \"for the container: \" + containerIdStr +\". Please try later \"\n                + \"or after the application finishes.\");\n          }\n          return result;\n        }\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper, useRegex);\n    } else {\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      resultCode \u003d printContainerLogsForFinishedApplication(\n          request, logCliHelper, useRegex);\n    }\n    return resultCode;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
          "extendedDetails": {
            "oldValue": "[IOException]",
            "newValue": "[IOException, ClientHandlerException, UniformInterfaceException, JSONException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6313. YARN logs cli should provide logs for a completed container even when application is still running. Contributed by Xuan Gong.\n\n(cherry picked from commit b88f5e0f7858d1d89b79dfd325b767c34416052d)\n",
          "commitDate": "14/03/17 12:58 PM",
          "commitName": "871dc420f8a4f151189c0925e062c64859a8f275",
          "commitAuthor": "Junping Du",
          "commitDateOld": "02/02/17 12:41 AM",
          "commitNameOld": "327c9980aafce52cc02d2b8885fc4e9f628ab23c",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 40.47,
          "commitsBetweenForRepo": 227,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,83 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n-      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException {\n+      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException,\n+      ClientHandlerException, UniformInterfaceException, JSONException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n     // if the application is in the final state,\n     // we could directly get logs from HDFS.\n     if (isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n       if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n         return printContainerLogsForFinishedApplication(\n             request, logCliHelper, useRegex);\n       } else {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             request, logCliHelper, useRegex);\n       }\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d report.getNodeHttpAddress();\n       if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n         nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                 WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n         request.setNodeHttpAddress(nodeHttpAddress);\n       }\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n       request.setContainerState(report.getContainerState());\n     } catch (IOException | YarnException ex) {\n       if (isAppFinished) {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             request, logCliHelper, useRegex);\n       } else {\n-        System.err.println(\"Unable to get logs for this container:\"\n-            + containerIdStr + \"for the application:\" + appIdStr\n-            + \" with the appOwner: \" + appOwner);\n-        System.err.println(\"The application: \" + appIdStr\n-            + \" is still running, and we can not get Container report \"\n-            + \"for the container: \" + containerIdStr +\". Please try later \"\n-            + \"or after the application finishes.\");\n-        return -1;\n+        nodeHttpAddress \u003d getNodeHttpAddressFromRMWebString(request);\n+        if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n+          request.setNodeHttpAddress(nodeHttpAddress);\n+        } else {\n+          // for the case, we have already uploaded partial logs in HDFS\n+          int result \u003d -1;\n+          if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n+            result \u003d  printAggregatedContainerLogs(\n+                request, logCliHelper, useRegex);\n+          } else {\n+            result \u003d printAggregatedContainerLogsWithoutNodeId(\n+                request, logCliHelper, useRegex);\n+          }\n+          if (result \u003d\u003d -1) {\n+            System.err.println(\"Unable to get logs for this container:\"\n+                + containerIdStr + \" for the application:\" + appIdStr\n+                + \" with the appOwner: \" + appOwner);\n+            System.err.println(\"The application: \" + appIdStr\n+                + \" is still running, and we can not get Container report \"\n+                + \"for the container: \" + containerIdStr +\". Please try later \"\n+                + \"or after the application finishes.\");\n+          }\n+          return result;\n+        }\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n     if (!isAppFinished) {\n       resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n           logCliHelper, useRegex);\n     } else {\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n       resultCode \u003d printContainerLogsForFinishedApplication(\n           request, logCliHelper, useRegex);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException,\n      ClientHandlerException, UniformInterfaceException, JSONException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    // if the application is in the final state,\n    // we could directly get logs from HDFS.\n    if (isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n        return printContainerLogsForFinishedApplication(\n            request, logCliHelper, useRegex);\n      } else {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper, useRegex);\n      }\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d report.getNodeHttpAddress();\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        request.setNodeHttpAddress(nodeHttpAddress);\n      }\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setContainerState(report.getContainerState());\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper, useRegex);\n      } else {\n        nodeHttpAddress \u003d getNodeHttpAddressFromRMWebString(request);\n        if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n          request.setNodeHttpAddress(nodeHttpAddress);\n        } else {\n          // for the case, we have already uploaded partial logs in HDFS\n          int result \u003d -1;\n          if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n            result \u003d  printAggregatedContainerLogs(\n                request, logCliHelper, useRegex);\n          } else {\n            result \u003d printAggregatedContainerLogsWithoutNodeId(\n                request, logCliHelper, useRegex);\n          }\n          if (result \u003d\u003d -1) {\n            System.err.println(\"Unable to get logs for this container:\"\n                + containerIdStr + \" for the application:\" + appIdStr\n                + \" with the appOwner: \" + appOwner);\n            System.err.println(\"The application: \" + appIdStr\n                + \" is still running, and we can not get Container report \"\n                + \"for the container: \" + containerIdStr +\". Please try later \"\n                + \"or after the application finishes.\");\n          }\n          return result;\n        }\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper, useRegex);\n    } else {\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      resultCode \u003d printContainerLogsForFinishedApplication(\n          request, logCliHelper, useRegex);\n    }\n    return resultCode;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
          "extendedDetails": {}
        }
      ]
    },
    "e605d47df05619c6b1c18aca59f709899498da75": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5470. Differentiate exactly match with regex in yarn log CLI. Contributed by Xuan Gong.\n",
      "commitDate": "05/08/16 10:55 AM",
      "commitName": "e605d47df05619c6b1c18aca59f709899498da75",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5470. Differentiate exactly match with regex in yarn log CLI. Contributed by Xuan Gong.\n",
          "commitDate": "05/08/16 10:55 AM",
          "commitName": "e605d47df05619c6b1c18aca59f709899498da75",
          "commitAuthor": "Junping Du",
          "commitDateOld": "02/08/16 10:41 AM",
          "commitNameOld": "3818393297c7b337e380e8111a55f2ac4745cb83",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 3.01,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,66 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n-      LogCLIHelpers logCliHelper) throws IOException {\n+      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n     // if the application is in the final state,\n     // we could directly get logs from HDFS.\n     if (isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n       if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n         return printContainerLogsForFinishedApplication(\n-            request, logCliHelper);\n+            request, logCliHelper, useRegex);\n       } else {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n-            request, logCliHelper);\n+            request, logCliHelper, useRegex);\n       }\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d report.getNodeHttpAddress();\n       if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n         nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                 WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n         request.setNodeHttpAddress(nodeHttpAddress);\n       }\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n       request.setContainerState(report.getContainerState());\n     } catch (IOException | YarnException ex) {\n       if (isAppFinished) {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n-            request, logCliHelper);\n+            request, logCliHelper, useRegex);\n       } else {\n         System.err.println(\"Unable to get logs for this container:\"\n             + containerIdStr + \"for the application:\" + appIdStr\n             + \" with the appOwner: \" + appOwner);\n         System.err.println(\"The application: \" + appIdStr\n             + \" is still running, and we can not get Container report \"\n             + \"for the container: \" + containerIdStr +\". Please try later \"\n             + \"or after the application finishes.\");\n         return -1;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n     if (!isAppFinished) {\n       resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n-          logCliHelper);\n+          logCliHelper, useRegex);\n     } else {\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n       resultCode \u003d printContainerLogsForFinishedApplication(\n-          request, logCliHelper);\n+          request, logCliHelper, useRegex);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    // if the application is in the final state,\n    // we could directly get logs from HDFS.\n    if (isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n        return printContainerLogsForFinishedApplication(\n            request, logCliHelper, useRegex);\n      } else {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper, useRegex);\n      }\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d report.getNodeHttpAddress();\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        request.setNodeHttpAddress(nodeHttpAddress);\n      }\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setContainerState(report.getContainerState());\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper, useRegex);\n      } else {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr\n            + \" with the appOwner: \" + appOwner);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper, useRegex);\n    } else {\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      resultCode \u003d printContainerLogsForFinishedApplication(\n          request, logCliHelper, useRegex);\n    }\n    return resultCode;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
          "extendedDetails": {
            "oldValue": "[request-ContainerLogsRequest, logCliHelper-LogCLIHelpers]",
            "newValue": "[request-ContainerLogsRequest, logCliHelper-LogCLIHelpers, useRegex-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5470. Differentiate exactly match with regex in yarn log CLI. Contributed by Xuan Gong.\n",
          "commitDate": "05/08/16 10:55 AM",
          "commitName": "e605d47df05619c6b1c18aca59f709899498da75",
          "commitAuthor": "Junping Du",
          "commitDateOld": "02/08/16 10:41 AM",
          "commitNameOld": "3818393297c7b337e380e8111a55f2ac4745cb83",
          "commitAuthorOld": "Junping Du",
          "daysBetweenCommits": 3.01,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,66 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n-      LogCLIHelpers logCliHelper) throws IOException {\n+      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n     // if the application is in the final state,\n     // we could directly get logs from HDFS.\n     if (isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n       if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n         return printContainerLogsForFinishedApplication(\n-            request, logCliHelper);\n+            request, logCliHelper, useRegex);\n       } else {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n-            request, logCliHelper);\n+            request, logCliHelper, useRegex);\n       }\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d report.getNodeHttpAddress();\n       if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n         nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                 WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n         request.setNodeHttpAddress(nodeHttpAddress);\n       }\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n       request.setContainerState(report.getContainerState());\n     } catch (IOException | YarnException ex) {\n       if (isAppFinished) {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n-            request, logCliHelper);\n+            request, logCliHelper, useRegex);\n       } else {\n         System.err.println(\"Unable to get logs for this container:\"\n             + containerIdStr + \"for the application:\" + appIdStr\n             + \" with the appOwner: \" + appOwner);\n         System.err.println(\"The application: \" + appIdStr\n             + \" is still running, and we can not get Container report \"\n             + \"for the container: \" + containerIdStr +\". Please try later \"\n             + \"or after the application finishes.\");\n         return -1;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n     if (!isAppFinished) {\n       resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n-          logCliHelper);\n+          logCliHelper, useRegex);\n     } else {\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n       resultCode \u003d printContainerLogsForFinishedApplication(\n-          request, logCliHelper);\n+          request, logCliHelper, useRegex);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper, boolean useRegex) throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    // if the application is in the final state,\n    // we could directly get logs from HDFS.\n    if (isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n        return printContainerLogsForFinishedApplication(\n            request, logCliHelper, useRegex);\n      } else {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper, useRegex);\n      }\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d report.getNodeHttpAddress();\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        request.setNodeHttpAddress(nodeHttpAddress);\n      }\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setContainerState(report.getContainerState());\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper, useRegex);\n      } else {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr\n            + \" with the appOwner: \" + appOwner);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper, useRegex);\n    } else {\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      resultCode \u003d printContainerLogsForFinishedApplication(\n          request, logCliHelper, useRegex);\n    }\n    return resultCode;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
          "extendedDetails": {}
        }
      ]
    },
    "3818393297c7b337e380e8111a55f2ac4745cb83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5226. Remove AHS enable check from LogsCLI#fetchAMContainerLogs. Contributed by Xuan Gong.\n",
      "commitDate": "02/08/16 10:41 AM",
      "commitName": "3818393297c7b337e380e8111a55f2ac4745cb83",
      "commitAuthor": "Junping Du",
      "commitDateOld": "15/07/16 9:23 AM",
      "commitNameOld": "7e5355c14e55fd6540f7f070df4b78fa94a81618",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 18.05,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,66 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n       LogCLIHelpers logCliHelper) throws IOException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n-    // if we provide the node address and the application is in the final\n-    // state, we could directly get logs from HDFS.\n-    if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n+    // if the application is in the final state,\n+    // we could directly get logs from HDFS.\n+    if (isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n-      return printContainerLogsForFinishedApplication(\n-          request, logCliHelper);\n+      if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n+        return printContainerLogsForFinishedApplication(\n+            request, logCliHelper);\n+      } else {\n+        return printContainerLogsForFinishedApplicationWithoutNodeId(\n+            request, logCliHelper);\n+      }\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d report.getNodeHttpAddress();\n       if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n         nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                 WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n         request.setNodeHttpAddress(nodeHttpAddress);\n       }\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n       request.setContainerState(report.getContainerState());\n     } catch (IOException | YarnException ex) {\n       if (isAppFinished) {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             request, logCliHelper);\n       } else {\n         System.err.println(\"Unable to get logs for this container:\"\n             + containerIdStr + \"for the application:\" + appIdStr\n             + \" with the appOwner: \" + appOwner);\n         System.err.println(\"The application: \" + appIdStr\n             + \" is still running, and we can not get Container report \"\n             + \"for the container: \" + containerIdStr +\". Please try later \"\n             + \"or after the application finishes.\");\n         return -1;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n     if (!isAppFinished) {\n       resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n           logCliHelper);\n     } else {\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n       resultCode \u003d printContainerLogsForFinishedApplication(\n           request, logCliHelper);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper) throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    // if the application is in the final state,\n    // we could directly get logs from HDFS.\n    if (isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      if (nodeAddress !\u003d null \u0026\u0026 !nodeAddress.isEmpty()) {\n        return printContainerLogsForFinishedApplication(\n            request, logCliHelper);\n      } else {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper);\n      }\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d report.getNodeHttpAddress();\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        request.setNodeHttpAddress(nodeHttpAddress);\n      }\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setContainerState(report.getContainerState());\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper);\n      } else {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr\n            + \" with the appOwner: \" + appOwner);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper);\n    } else {\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      resultCode \u003d printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "7e5355c14e55fd6540f7f070df4b78fa94a81618": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5339. Passing file to -out for YARN log CLI doesnt give warning or error code. Contributed by Xuan Gong.\n",
      "commitDate": "15/07/16 9:23 AM",
      "commitName": "7e5355c14e55fd6540f7f070df4b78fa94a81618",
      "commitAuthor": "Junping Du",
      "commitDateOld": "14/07/16 10:20 AM",
      "commitNameOld": "429347289c7787364e654334cd84115ae40bb22d",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,61 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n       LogCLIHelpers logCliHelper) throws IOException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n     // if we provide the node address and the application is in the final\n     // state, we could directly get logs from HDFS.\n     if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n       return printContainerLogsForFinishedApplication(\n           request, logCliHelper);\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d report.getNodeHttpAddress();\n       if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n         nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                 WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n         request.setNodeHttpAddress(nodeHttpAddress);\n       }\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n+      request.setContainerState(report.getContainerState());\n     } catch (IOException | YarnException ex) {\n       if (isAppFinished) {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             request, logCliHelper);\n       } else {\n         System.err.println(\"Unable to get logs for this container:\"\n             + containerIdStr + \"for the application:\" + appIdStr\n             + \" with the appOwner: \" + appOwner);\n         System.err.println(\"The application: \" + appIdStr\n             + \" is still running, and we can not get Container report \"\n             + \"for the container: \" + containerIdStr +\". Please try later \"\n             + \"or after the application finishes.\");\n         return -1;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n     if (!isAppFinished) {\n       resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n           logCliHelper);\n     } else {\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n       resultCode \u003d printContainerLogsForFinishedApplication(\n           request, logCliHelper);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper) throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    // if we provide the node address and the application is in the final\n    // state, we could directly get logs from HDFS.\n    if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      return printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d report.getNodeHttpAddress();\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        request.setNodeHttpAddress(nodeHttpAddress);\n      }\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setContainerState(report.getContainerState());\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper);\n      } else {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr\n            + \" with the appOwner: \" + appOwner);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper);\n    } else {\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      resultCode \u003d printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "429347289c7787364e654334cd84115ae40bb22d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5363. For AM containers, or for containers of running-apps, \"yarn logs\" incorrectly only (tries to) shows syslog file-type by default. (Contributed by Vinod Kumar Vavilapalli)\n",
      "commitDate": "14/07/16 10:20 AM",
      "commitName": "429347289c7787364e654334cd84115ae40bb22d",
      "commitAuthor": "Xuan",
      "commitDateOld": "13/07/16 2:52 PM",
      "commitNameOld": "d18050522c5c6bd9e32eb9a1be4ffe2288624c40",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.81,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,60 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n       LogCLIHelpers logCliHelper) throws IOException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n-    List\u003cString\u003e logFiles \u003d request.getLogTypes();\n     // if we provide the node address and the application is in the final\n     // state, we could directly get logs from HDFS.\n     if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n       return printContainerLogsForFinishedApplication(\n           request, logCliHelper);\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d report.getNodeHttpAddress();\n       if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n         nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                 WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n         request.setNodeHttpAddress(nodeHttpAddress);\n       }\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n     } catch (IOException | YarnException ex) {\n       if (isAppFinished) {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             request, logCliHelper);\n       } else {\n         System.err.println(\"Unable to get logs for this container:\"\n             + containerIdStr + \"for the application:\" + appIdStr\n             + \" with the appOwner: \" + appOwner);\n         System.err.println(\"The application: \" + appIdStr\n             + \" is still running, and we can not get Container report \"\n             + \"for the container: \" + containerIdStr +\". Please try later \"\n             + \"or after the application finishes.\");\n         return -1;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n     if (!isAppFinished) {\n-      // if we do not specify the value for CONTAINER_LOG_FILES option,\n-      // we will only output syslog\n-      if (logFiles \u003d\u003d null || logFiles.isEmpty()) {\n-        logFiles \u003d Arrays.asList(\"syslog\");\n-      }\n-      request.setLogTypes(logFiles);\n       resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n           logCliHelper);\n     } else {\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n       resultCode \u003d printContainerLogsForFinishedApplication(\n           request, logCliHelper);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper) throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    // if we provide the node address and the application is in the final\n    // state, we could directly get logs from HDFS.\n    if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      return printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d report.getNodeHttpAddress();\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        request.setNodeHttpAddress(nodeHttpAddress);\n      }\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper);\n      } else {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr\n            + \" with the appOwner: \" + appOwner);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper);\n    } else {\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      resultCode \u003d printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "eb471632349deac4b62f8dec853c8ceb64c9617a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5200. Enhanced \"yarn logs\" to be able to get a list of containers whose logs are aggregated via a \"show_container_log_info\" option. Contributed by Xuan Gong.\n",
      "commitDate": "13/07/16 10:54 AM",
      "commitName": "eb471632349deac4b62f8dec853c8ceb64c9617a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/07/16 8:29 AM",
      "commitNameOld": "7705812c7e3a9f3f774130e25443fda249c08c9c",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 1.1,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,67 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n       LogCLIHelpers logCliHelper) throws IOException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n     List\u003cString\u003e logFiles \u003d request.getLogTypes();\n     // if we provide the node address and the application is in the final\n     // state, we could directly get logs from HDFS.\n     if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n       return printContainerLogsForFinishedApplication(\n           request, logCliHelper);\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n-      nodeHttpAddress \u003d\n-          report.getNodeHttpAddress().replaceFirst(\n-            WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n+      nodeHttpAddress \u003d report.getNodeHttpAddress();\n+      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n+        nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n+                WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n+        request.setNodeHttpAddress(nodeHttpAddress);\n+      }\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n-      request.setNodeHttpAddress(nodeHttpAddress);\n     } catch (IOException | YarnException ex) {\n       if (isAppFinished) {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             request, logCliHelper);\n       } else {\n         System.err.println(\"Unable to get logs for this container:\"\n             + containerIdStr + \"for the application:\" + appIdStr\n             + \" with the appOwner: \" + appOwner);\n         System.err.println(\"The application: \" + appIdStr\n             + \" is still running, and we can not get Container report \"\n             + \"for the container: \" + containerIdStr +\". Please try later \"\n             + \"or after the application finishes.\");\n         return -1;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n     if (!isAppFinished) {\n       // if we do not specify the value for CONTAINER_LOG_FILES option,\n       // we will only output syslog\n       if (logFiles \u003d\u003d null || logFiles.isEmpty()) {\n         logFiles \u003d Arrays.asList(\"syslog\");\n       }\n       request.setLogTypes(logFiles);\n       resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n           logCliHelper);\n     } else {\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n       resultCode \u003d printContainerLogsForFinishedApplication(\n           request, logCliHelper);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper) throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    List\u003cString\u003e logFiles \u003d request.getLogTypes();\n    // if we provide the node address and the application is in the final\n    // state, we could directly get logs from HDFS.\n    if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      return printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d report.getNodeHttpAddress();\n      if (nodeHttpAddress !\u003d null \u0026\u0026 !nodeHttpAddress.isEmpty()) {\n        nodeHttpAddress \u003d nodeHttpAddress.replaceFirst(\n                WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n        request.setNodeHttpAddress(nodeHttpAddress);\n      }\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper);\n      } else {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr\n            + \" with the appOwner: \" + appOwner);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      // if we do not specify the value for CONTAINER_LOG_FILES option,\n      // we will only output syslog\n      if (logFiles \u003d\u003d null || logFiles.isEmpty()) {\n        logFiles \u003d Arrays.asList(\"syslog\");\n      }\n      request.setLogTypes(logFiles);\n      resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper);\n    } else {\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      resultCode \u003d printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "6ab5aa1c1f82f81726c6daa38b3db90d8c3ad856": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5266. Wrong exit code while trying to get app logs using regex via CLI. Contributed by Xuan Gong\n",
      "commitDate": "22/06/16 9:48 PM",
      "commitName": "6ab5aa1c1f82f81726c6daa38b3db90d8c3ad856",
      "commitAuthor": "Xuan",
      "commitDateOld": "20/06/16 4:05 PM",
      "commitNameOld": "5d58858bb6dfc07272ef099d60ca7cfb3b04423c",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 2.24,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n       LogCLIHelpers logCliHelper) throws IOException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n     List\u003cString\u003e logFiles \u003d request.getLogTypes();\n     // if we provide the node address and the application is in the final\n     // state, we could directly get logs from HDFS.\n     if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n       return printContainerLogsForFinishedApplication(\n           request, logCliHelper);\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d\n           report.getNodeHttpAddress().replaceFirst(\n             WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n       request.setNodeHttpAddress(nodeHttpAddress);\n     } catch (IOException | YarnException ex) {\n       if (isAppFinished) {\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             request, logCliHelper);\n       } else {\n         System.err.println(\"Unable to get logs for this container:\"\n             + containerIdStr + \"for the application:\" + appIdStr\n             + \" with the appOwner: \" + appOwner);\n         System.err.println(\"The application: \" + appIdStr\n             + \" is still running, and we can not get Container report \"\n             + \"for the container: \" + containerIdStr +\". Please try later \"\n             + \"or after the application finishes.\");\n         return -1;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n     if (!isAppFinished) {\n       // if we do not specify the value for CONTAINER_LOG_FILES option,\n       // we will only output syslog\n       if (logFiles \u003d\u003d null || logFiles.isEmpty()) {\n         logFiles \u003d Arrays.asList(\"syslog\");\n       }\n       request.setLogTypes(logFiles);\n-      printContainerLogsFromRunningApplication(getConf(), request,\n+      resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n           logCliHelper);\n     } else {\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n       resultCode \u003d printContainerLogsForFinishedApplication(\n           request, logCliHelper);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper) throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    List\u003cString\u003e logFiles \u003d request.getLogTypes();\n    // if we provide the node address and the application is in the final\n    // state, we could directly get logs from HDFS.\n    if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      return printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d\n          report.getNodeHttpAddress().replaceFirst(\n            WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setNodeHttpAddress(nodeHttpAddress);\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper);\n      } else {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr\n            + \" with the appOwner: \" + appOwner);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      // if we do not specify the value for CONTAINER_LOG_FILES option,\n      // we will only output syslog\n      if (logFiles \u003d\u003d null || logFiles.isEmpty()) {\n        logFiles \u003d Arrays.asList(\"syslog\");\n      }\n      request.setLogTypes(logFiles);\n      resultCode \u003d printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper);\n    } else {\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      resultCode \u003d printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5089. Improve \"yarn log\" command-line \"logFiles\" option to support\nregex. Contributed by Xuan Gong\n",
      "commitDate": "26/05/16 11:49 PM",
      "commitName": "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1",
      "commitAuthor": "Xuan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5089. Improve \"yarn log\" command-line \"logFiles\" option to support\nregex. Contributed by Xuan Gong\n",
          "commitDate": "26/05/16 11:49 PM",
          "commitName": "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1",
          "commitAuthor": "Xuan",
          "commitDateOld": "18/05/16 10:14 AM",
          "commitNameOld": "ef1757790d89cc72f88f5330761b1c8901c59e94",
          "commitAuthorOld": "Varun Vasudev",
          "daysBetweenCommits": 8.57,
          "commitsBetweenForRepo": 66,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,65 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n-      String[] logFiles, LogCLIHelpers logCliHelper, String localDir)\n-      throws IOException {\n+      LogCLIHelpers logCliHelper) throws IOException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n+    List\u003cString\u003e logFiles \u003d request.getLogTypes();\n     // if we provide the node address and the application is in the final\n     // state, we could directly get logs from HDFS.\n     if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n-      // if user specified \"ALL\" as the logFiles param, pass null\n+      // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n-      List\u003cString\u003e logs;\n-      if (logFiles \u003d\u003d null) {\n-        logs \u003d null;\n-      } else if (fetchAllLogFiles(logFiles)) {\n-        logs \u003d null;\n-      } else {\n-        logs \u003d Arrays.asList(logFiles);\n-      }\n-      return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n-          containerIdStr, nodeAddress, appOwner, logs, localDir);\n+      return printContainerLogsForFinishedApplication(\n+          request, logCliHelper);\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d\n           report.getNodeHttpAddress().replaceFirst(\n             WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n       request.setNodeHttpAddress(nodeHttpAddress);\n     } catch (IOException | YarnException ex) {\n       if (isAppFinished) {\n-        String[] requestedLogFiles \u003d logFiles;\n-        if(fetchAllLogFiles(logFiles)) {\n-          requestedLogFiles \u003d null;\n-        }\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n-            appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n-            appOwner, localDir);\n+            request, logCliHelper);\n       } else {\n         System.err.println(\"Unable to get logs for this container:\"\n             + containerIdStr + \"for the application:\" + appIdStr\n             + \" with the appOwner: \" + appOwner);\n         System.err.println(\"The application: \" + appIdStr\n             + \" is still running, and we can not get Container report \"\n             + \"for the container: \" + containerIdStr +\". Please try later \"\n             + \"or after the application finishes.\");\n         return -1;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n     if (!isAppFinished) {\n-      if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n-        logFiles \u003d new String[] {\"syslog\"};\n+      // if we do not specify the value for CONTAINER_LOG_FILES option,\n+      // we will only output syslog\n+      if (logFiles \u003d\u003d null || logFiles.isEmpty()) {\n+        logFiles \u003d Arrays.asList(\"syslog\");\n       }\n+      request.setLogTypes(logFiles);\n       printContainerLogsFromRunningApplication(getConf(), request,\n-          logFiles, logCliHelper, localDir);\n+          logCliHelper);\n     } else {\n-      String[] requestedLogFiles \u003d logFiles;\n-      if(fetchAllLogFiles(logFiles)) {\n-        requestedLogFiles \u003d null;\n-      }\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n-      printContainerLogsForFinishedApplication(request,\n-          requestedLogFiles, logCliHelper, localDir);\n+      resultCode \u003d printContainerLogsForFinishedApplication(\n+          request, logCliHelper);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper) throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    List\u003cString\u003e logFiles \u003d request.getLogTypes();\n    // if we provide the node address and the application is in the final\n    // state, we could directly get logs from HDFS.\n    if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      return printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d\n          report.getNodeHttpAddress().replaceFirst(\n            WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setNodeHttpAddress(nodeHttpAddress);\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper);\n      } else {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr\n            + \" with the appOwner: \" + appOwner);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      // if we do not specify the value for CONTAINER_LOG_FILES option,\n      // we will only output syslog\n      if (logFiles \u003d\u003d null || logFiles.isEmpty()) {\n        logFiles \u003d Arrays.asList(\"syslog\");\n      }\n      request.setLogTypes(logFiles);\n      printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper);\n    } else {\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      resultCode \u003d printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    return resultCode;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
          "extendedDetails": {
            "oldValue": "[request-ContainerLogsRequest, logFiles-String[], logCliHelper-LogCLIHelpers, localDir-String]",
            "newValue": "[request-ContainerLogsRequest, logCliHelper-LogCLIHelpers]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5089. Improve \"yarn log\" command-line \"logFiles\" option to support\nregex. Contributed by Xuan Gong\n",
          "commitDate": "26/05/16 11:49 PM",
          "commitName": "bde819abbbcea940cfa6426a9e4920e6c8dc9cf1",
          "commitAuthor": "Xuan",
          "commitDateOld": "18/05/16 10:14 AM",
          "commitNameOld": "ef1757790d89cc72f88f5330761b1c8901c59e94",
          "commitAuthorOld": "Varun Vasudev",
          "daysBetweenCommits": 8.57,
          "commitsBetweenForRepo": 66,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,65 @@\n   private int fetchContainerLogs(ContainerLogsRequest request,\n-      String[] logFiles, LogCLIHelpers logCliHelper, String localDir)\n-      throws IOException {\n+      LogCLIHelpers logCliHelper) throws IOException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d request.getAppId().toString();\n     String containerIdStr \u003d request.getContainerId();\n     String nodeAddress \u003d request.getNodeId();\n     String appOwner \u003d request.getAppOwner();\n     boolean isAppFinished \u003d request.isAppFinished();\n+    List\u003cString\u003e logFiles \u003d request.getLogTypes();\n     // if we provide the node address and the application is in the final\n     // state, we could directly get logs from HDFS.\n     if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n-      // if user specified \"ALL\" as the logFiles param, pass null\n+      // if user specified \"ALL\" as the logFiles param, pass empty list\n       // to logCliHelper so that it fetches all the logs\n-      List\u003cString\u003e logs;\n-      if (logFiles \u003d\u003d null) {\n-        logs \u003d null;\n-      } else if (fetchAllLogFiles(logFiles)) {\n-        logs \u003d null;\n-      } else {\n-        logs \u003d Arrays.asList(logFiles);\n-      }\n-      return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n-          containerIdStr, nodeAddress, appOwner, logs, localDir);\n+      return printContainerLogsForFinishedApplication(\n+          request, logCliHelper);\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d\n           report.getNodeHttpAddress().replaceFirst(\n             WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n       nodeId \u003d report.getAssignedNode().toString();\n       request.setNodeId(nodeId);\n       request.setNodeHttpAddress(nodeHttpAddress);\n     } catch (IOException | YarnException ex) {\n       if (isAppFinished) {\n-        String[] requestedLogFiles \u003d logFiles;\n-        if(fetchAllLogFiles(logFiles)) {\n-          requestedLogFiles \u003d null;\n-        }\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n-            appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n-            appOwner, localDir);\n+            request, logCliHelper);\n       } else {\n         System.err.println(\"Unable to get logs for this container:\"\n             + containerIdStr + \"for the application:\" + appIdStr\n             + \" with the appOwner: \" + appOwner);\n         System.err.println(\"The application: \" + appIdStr\n             + \" is still running, and we can not get Container report \"\n             + \"for the container: \" + containerIdStr +\". Please try later \"\n             + \"or after the application finishes.\");\n         return -1;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n     if (!isAppFinished) {\n-      if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n-        logFiles \u003d new String[] {\"syslog\"};\n+      // if we do not specify the value for CONTAINER_LOG_FILES option,\n+      // we will only output syslog\n+      if (logFiles \u003d\u003d null || logFiles.isEmpty()) {\n+        logFiles \u003d Arrays.asList(\"syslog\");\n       }\n+      request.setLogTypes(logFiles);\n       printContainerLogsFromRunningApplication(getConf(), request,\n-          logFiles, logCliHelper, localDir);\n+          logCliHelper);\n     } else {\n-      String[] requestedLogFiles \u003d logFiles;\n-      if(fetchAllLogFiles(logFiles)) {\n-        requestedLogFiles \u003d null;\n-      }\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n-      printContainerLogsForFinishedApplication(request,\n-          requestedLogFiles, logCliHelper, localDir);\n+      resultCode \u003d printContainerLogsForFinishedApplication(\n+          request, logCliHelper);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      LogCLIHelpers logCliHelper) throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    List\u003cString\u003e logFiles \u003d request.getLogTypes();\n    // if we provide the node address and the application is in the final\n    // state, we could directly get logs from HDFS.\n    if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass empty list\n      // to logCliHelper so that it fetches all the logs\n      return printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d\n          report.getNodeHttpAddress().replaceFirst(\n            WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setNodeHttpAddress(nodeHttpAddress);\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            request, logCliHelper);\n      } else {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr\n            + \" with the appOwner: \" + appOwner);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      // if we do not specify the value for CONTAINER_LOG_FILES option,\n      // we will only output syslog\n      if (logFiles \u003d\u003d null || logFiles.isEmpty()) {\n        logFiles \u003d Arrays.asList(\"syslog\");\n      }\n      request.setLogTypes(logFiles);\n      printContainerLogsFromRunningApplication(getConf(), request,\n          logCliHelper);\n    } else {\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      resultCode \u003d printContainerLogsForFinishedApplication(\n          request, logCliHelper);\n    }\n    return resultCode;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
          "extendedDetails": {}
        }
      ]
    },
    "ef1757790d89cc72f88f5330761b1c8901c59e94": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4913. Yarn logs should take a -out option to write to a directory. Contributed by Xuan Gong.\n",
      "commitDate": "18/05/16 10:14 AM",
      "commitName": "ef1757790d89cc72f88f5330761b1c8901c59e94",
      "commitAuthor": "Varun Vasudev",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4913. Yarn logs should take a -out option to write to a directory. Contributed by Xuan Gong.\n",
          "commitDate": "18/05/16 10:14 AM",
          "commitName": "ef1757790d89cc72f88f5330761b1c8901c59e94",
          "commitAuthor": "Varun Vasudev",
          "commitDateOld": "14/05/16 12:19 PM",
          "commitNameOld": "7be53b65f95dae89c760cde354b42f15f5ee3b5f",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 3.91,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,77 +1,79 @@\n-  private int fetchContainerLogs(YarnApplicationState appState,\n-      boolean appStateObtainedSuccessfully, String[] logFiles,\n-      String appOwner, String nodeAddress,\n-      ContainerId containerId, LogCLIHelpers logCliHelper) throws IOException {\n+  private int fetchContainerLogs(ContainerLogsRequest request,\n+      String[] logFiles, LogCLIHelpers logCliHelper, String localDir)\n+      throws IOException {\n     int resultCode \u003d 0;\n-    String appIdStr \u003d containerId.getApplicationAttemptId()\n-        .getApplicationId().toString();\n-    String containerIdStr \u003d containerId.toString();\n+    String appIdStr \u003d request.getAppId().toString();\n+    String containerIdStr \u003d request.getContainerId();\n+    String nodeAddress \u003d request.getNodeId();\n+    String appOwner \u003d request.getAppOwner();\n+    boolean isAppFinished \u003d request.isAppFinished();\n     // if we provide the node address and the application is in the final\n     // state, we could directly get logs from HDFS.\n-    if (nodeAddress !\u003d null \u0026\u0026 (!appStateObtainedSuccessfully ||\n-        isApplicationFinished(appState))) {\n+    if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass null\n       // to logCliHelper so that it fetches all the logs\n       List\u003cString\u003e logs;\n       if (logFiles \u003d\u003d null) {\n         logs \u003d null;\n       } else if (fetchAllLogFiles(logFiles)) {\n         logs \u003d null;\n       } else {\n         logs \u003d Arrays.asList(logFiles);\n       }\n       return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n-          containerIdStr, nodeAddress, appOwner, logs);\n+          containerIdStr, nodeAddress, appOwner, logs, localDir);\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d\n           report.getNodeHttpAddress().replaceFirst(\n             WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n       nodeId \u003d report.getAssignedNode().toString();\n+      request.setNodeId(nodeId);\n+      request.setNodeHttpAddress(nodeHttpAddress);\n     } catch (IOException | YarnException ex) {\n-      if (!appStateObtainedSuccessfully || isApplicationFinished(appState)) {\n+      if (isAppFinished) {\n         String[] requestedLogFiles \u003d logFiles;\n         if(fetchAllLogFiles(logFiles)) {\n           requestedLogFiles \u003d null;\n         }\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n-            appOwner);\n-      } else if (!isApplicationFinished(appState)) {\n+            appOwner, localDir);\n+      } else {\n         System.err.println(\"Unable to get logs for this container:\"\n             + containerIdStr + \"for the application:\" + appIdStr\n             + \" with the appOwner: \" + appOwner);\n         System.err.println(\"The application: \" + appIdStr\n             + \" is still running, and we can not get Container report \"\n             + \"for the container: \" + containerIdStr +\". Please try later \"\n             + \"or after the application finishes.\");\n         return -1;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n-    if (!isApplicationFinished(appState)) {\n+    if (!isAppFinished) {\n       if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n         logFiles \u003d new String[] {\"syslog\"};\n       }\n-      printContainerLogsFromRunningApplication(getConf(), containerId,\n-          nodeHttpAddress, nodeId, logFiles, logCliHelper, appOwner);\n+      printContainerLogsFromRunningApplication(getConf(), request,\n+          logFiles, logCliHelper, localDir);\n     } else {\n       String[] requestedLogFiles \u003d logFiles;\n       if(fetchAllLogFiles(logFiles)) {\n         requestedLogFiles \u003d null;\n       }\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n-      printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n-          nodeId, requestedLogFiles, logCliHelper, appOwner);\n+      printContainerLogsForFinishedApplication(request,\n+          requestedLogFiles, logCliHelper, localDir);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      String[] logFiles, LogCLIHelpers logCliHelper, String localDir)\n      throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    // if we provide the node address and the application is in the final\n    // state, we could directly get logs from HDFS.\n    if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass null\n      // to logCliHelper so that it fetches all the logs\n      List\u003cString\u003e logs;\n      if (logFiles \u003d\u003d null) {\n        logs \u003d null;\n      } else if (fetchAllLogFiles(logFiles)) {\n        logs \u003d null;\n      } else {\n        logs \u003d Arrays.asList(logFiles);\n      }\n      return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n          containerIdStr, nodeAddress, appOwner, logs, localDir);\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d\n          report.getNodeHttpAddress().replaceFirst(\n            WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setNodeHttpAddress(nodeHttpAddress);\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        String[] requestedLogFiles \u003d logFiles;\n        if(fetchAllLogFiles(logFiles)) {\n          requestedLogFiles \u003d null;\n        }\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n            appOwner, localDir);\n      } else {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr\n            + \" with the appOwner: \" + appOwner);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n        logFiles \u003d new String[] {\"syslog\"};\n      }\n      printContainerLogsFromRunningApplication(getConf(), request,\n          logFiles, logCliHelper, localDir);\n    } else {\n      String[] requestedLogFiles \u003d logFiles;\n      if(fetchAllLogFiles(logFiles)) {\n        requestedLogFiles \u003d null;\n      }\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      printContainerLogsForFinishedApplication(request,\n          requestedLogFiles, logCliHelper, localDir);\n    }\n    return resultCode;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
          "extendedDetails": {
            "oldValue": "[appState-YarnApplicationState, appStateObtainedSuccessfully-boolean, logFiles-String[], appOwner-String, nodeAddress-String, containerId-ContainerId, logCliHelper-LogCLIHelpers]",
            "newValue": "[request-ContainerLogsRequest, logFiles-String[], logCliHelper-LogCLIHelpers, localDir-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4913. Yarn logs should take a -out option to write to a directory. Contributed by Xuan Gong.\n",
          "commitDate": "18/05/16 10:14 AM",
          "commitName": "ef1757790d89cc72f88f5330761b1c8901c59e94",
          "commitAuthor": "Varun Vasudev",
          "commitDateOld": "14/05/16 12:19 PM",
          "commitNameOld": "7be53b65f95dae89c760cde354b42f15f5ee3b5f",
          "commitAuthorOld": "Xuan",
          "daysBetweenCommits": 3.91,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,77 +1,79 @@\n-  private int fetchContainerLogs(YarnApplicationState appState,\n-      boolean appStateObtainedSuccessfully, String[] logFiles,\n-      String appOwner, String nodeAddress,\n-      ContainerId containerId, LogCLIHelpers logCliHelper) throws IOException {\n+  private int fetchContainerLogs(ContainerLogsRequest request,\n+      String[] logFiles, LogCLIHelpers logCliHelper, String localDir)\n+      throws IOException {\n     int resultCode \u003d 0;\n-    String appIdStr \u003d containerId.getApplicationAttemptId()\n-        .getApplicationId().toString();\n-    String containerIdStr \u003d containerId.toString();\n+    String appIdStr \u003d request.getAppId().toString();\n+    String containerIdStr \u003d request.getContainerId();\n+    String nodeAddress \u003d request.getNodeId();\n+    String appOwner \u003d request.getAppOwner();\n+    boolean isAppFinished \u003d request.isAppFinished();\n     // if we provide the node address and the application is in the final\n     // state, we could directly get logs from HDFS.\n-    if (nodeAddress !\u003d null \u0026\u0026 (!appStateObtainedSuccessfully ||\n-        isApplicationFinished(appState))) {\n+    if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n       // if user specified \"ALL\" as the logFiles param, pass null\n       // to logCliHelper so that it fetches all the logs\n       List\u003cString\u003e logs;\n       if (logFiles \u003d\u003d null) {\n         logs \u003d null;\n       } else if (fetchAllLogFiles(logFiles)) {\n         logs \u003d null;\n       } else {\n         logs \u003d Arrays.asList(logFiles);\n       }\n       return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n-          containerIdStr, nodeAddress, appOwner, logs);\n+          containerIdStr, nodeAddress, appOwner, logs, localDir);\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d\n           report.getNodeHttpAddress().replaceFirst(\n             WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n       nodeId \u003d report.getAssignedNode().toString();\n+      request.setNodeId(nodeId);\n+      request.setNodeHttpAddress(nodeHttpAddress);\n     } catch (IOException | YarnException ex) {\n-      if (!appStateObtainedSuccessfully || isApplicationFinished(appState)) {\n+      if (isAppFinished) {\n         String[] requestedLogFiles \u003d logFiles;\n         if(fetchAllLogFiles(logFiles)) {\n           requestedLogFiles \u003d null;\n         }\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n-            appOwner);\n-      } else if (!isApplicationFinished(appState)) {\n+            appOwner, localDir);\n+      } else {\n         System.err.println(\"Unable to get logs for this container:\"\n             + containerIdStr + \"for the application:\" + appIdStr\n             + \" with the appOwner: \" + appOwner);\n         System.err.println(\"The application: \" + appIdStr\n             + \" is still running, and we can not get Container report \"\n             + \"for the container: \" + containerIdStr +\". Please try later \"\n             + \"or after the application finishes.\");\n         return -1;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n-    if (!isApplicationFinished(appState)) {\n+    if (!isAppFinished) {\n       if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n         logFiles \u003d new String[] {\"syslog\"};\n       }\n-      printContainerLogsFromRunningApplication(getConf(), containerId,\n-          nodeHttpAddress, nodeId, logFiles, logCliHelper, appOwner);\n+      printContainerLogsFromRunningApplication(getConf(), request,\n+          logFiles, logCliHelper, localDir);\n     } else {\n       String[] requestedLogFiles \u003d logFiles;\n       if(fetchAllLogFiles(logFiles)) {\n         requestedLogFiles \u003d null;\n       }\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n-      printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n-          nodeId, requestedLogFiles, logCliHelper, appOwner);\n+      printContainerLogsForFinishedApplication(request,\n+          requestedLogFiles, logCliHelper, localDir);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private int fetchContainerLogs(ContainerLogsRequest request,\n      String[] logFiles, LogCLIHelpers logCliHelper, String localDir)\n      throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d request.getAppId().toString();\n    String containerIdStr \u003d request.getContainerId();\n    String nodeAddress \u003d request.getNodeId();\n    String appOwner \u003d request.getAppOwner();\n    boolean isAppFinished \u003d request.isAppFinished();\n    // if we provide the node address and the application is in the final\n    // state, we could directly get logs from HDFS.\n    if (nodeAddress !\u003d null \u0026\u0026 isAppFinished) {\n      // if user specified \"ALL\" as the logFiles param, pass null\n      // to logCliHelper so that it fetches all the logs\n      List\u003cString\u003e logs;\n      if (logFiles \u003d\u003d null) {\n        logs \u003d null;\n      } else if (fetchAllLogFiles(logFiles)) {\n        logs \u003d null;\n      } else {\n        logs \u003d Arrays.asList(logFiles);\n      }\n      return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n          containerIdStr, nodeAddress, appOwner, logs, localDir);\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d\n          report.getNodeHttpAddress().replaceFirst(\n            WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n      nodeId \u003d report.getAssignedNode().toString();\n      request.setNodeId(nodeId);\n      request.setNodeHttpAddress(nodeHttpAddress);\n    } catch (IOException | YarnException ex) {\n      if (isAppFinished) {\n        String[] requestedLogFiles \u003d logFiles;\n        if(fetchAllLogFiles(logFiles)) {\n          requestedLogFiles \u003d null;\n        }\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n            appOwner, localDir);\n      } else {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr\n            + \" with the appOwner: \" + appOwner);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isAppFinished) {\n      if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n        logFiles \u003d new String[] {\"syslog\"};\n      }\n      printContainerLogsFromRunningApplication(getConf(), request,\n          logFiles, logCliHelper, localDir);\n    } else {\n      String[] requestedLogFiles \u003d logFiles;\n      if(fetchAllLogFiles(logFiles)) {\n        requestedLogFiles \u003d null;\n      }\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      printContainerLogsForFinishedApplication(request,\n          requestedLogFiles, logCliHelper, localDir);\n    }\n    return resultCode;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
          "extendedDetails": {}
        }
      ]
    },
    "87f5e351337a905af5215af76c72b9312616cd4f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4842. Fixed \"yarn logs\" command to guess (and thus not require) the appOwner argument when viewing another user\u0027s logs. Contributed by Ram Venkatesh and Xuan Gong.\n",
      "commitDate": "09/05/16 10:41 PM",
      "commitName": "87f5e351337a905af5215af76c72b9312616cd4f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "04/05/16 2:16 PM",
      "commitNameOld": "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.35,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,77 @@\n   private int fetchContainerLogs(YarnApplicationState appState,\n       boolean appStateObtainedSuccessfully, String[] logFiles,\n       String appOwner, String nodeAddress,\n       ContainerId containerId, LogCLIHelpers logCliHelper) throws IOException {\n     int resultCode \u003d 0;\n     String appIdStr \u003d containerId.getApplicationAttemptId()\n         .getApplicationId().toString();\n     String containerIdStr \u003d containerId.toString();\n     // if we provide the node address and the application is in the final\n     // state, we could directly get logs from HDFS.\n     if (nodeAddress !\u003d null \u0026\u0026 (!appStateObtainedSuccessfully ||\n         isApplicationFinished(appState))) {\n       // if user specified \"ALL\" as the logFiles param, pass null\n       // to logCliHelper so that it fetches all the logs\n       List\u003cString\u003e logs;\n       if (logFiles \u003d\u003d null) {\n         logs \u003d null;\n       } else if (fetchAllLogFiles(logFiles)) {\n         logs \u003d null;\n       } else {\n         logs \u003d Arrays.asList(logFiles);\n       }\n       return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n           containerIdStr, nodeAddress, appOwner, logs);\n     }\n     String nodeHttpAddress \u003d null;\n     String nodeId \u003d null;\n     try {\n       // If the nodeAddress is not provided, we will try to get\n       // the ContainerReport. In the containerReport, we could get\n       // nodeAddress and nodeHttpAddress\n       ContainerReport report \u003d getContainerReport(containerIdStr);\n       nodeHttpAddress \u003d\n           report.getNodeHttpAddress().replaceFirst(\n             WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n       nodeId \u003d report.getAssignedNode().toString();\n     } catch (IOException | YarnException ex) {\n       if (!appStateObtainedSuccessfully || isApplicationFinished(appState)) {\n         String[] requestedLogFiles \u003d logFiles;\n         if(fetchAllLogFiles(logFiles)) {\n           requestedLogFiles \u003d null;\n         }\n         return printContainerLogsForFinishedApplicationWithoutNodeId(\n             appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n             appOwner);\n       } else if (!isApplicationFinished(appState)) {\n         System.err.println(\"Unable to get logs for this container:\"\n-            + containerIdStr + \"for the application:\" + appIdStr);\n+            + containerIdStr + \"for the application:\" + appIdStr\n+            + \" with the appOwner: \" + appOwner);\n         System.err.println(\"The application: \" + appIdStr\n             + \" is still running, and we can not get Container report \"\n             + \"for the container: \" + containerIdStr +\". Please try later \"\n             + \"or after the application finishes.\");\n         return -1;\n       }\n     }\n     // If the application is not in the final state,\n     // we will provide the NodeHttpAddress and get the container logs\n     // by calling NodeManager webservice.\n     if (!isApplicationFinished(appState)) {\n       if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n         logFiles \u003d new String[] {\"syslog\"};\n       }\n       printContainerLogsFromRunningApplication(getConf(), containerId,\n           nodeHttpAddress, nodeId, logFiles, logCliHelper, appOwner);\n     } else {\n       String[] requestedLogFiles \u003d logFiles;\n       if(fetchAllLogFiles(logFiles)) {\n         requestedLogFiles \u003d null;\n       }\n       // If the application is in the final state, we will directly\n       // get the container logs from HDFS.\n       printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n           nodeId, requestedLogFiles, logCliHelper, appOwner);\n     }\n     return resultCode;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private int fetchContainerLogs(YarnApplicationState appState,\n      boolean appStateObtainedSuccessfully, String[] logFiles,\n      String appOwner, String nodeAddress,\n      ContainerId containerId, LogCLIHelpers logCliHelper) throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d containerId.getApplicationAttemptId()\n        .getApplicationId().toString();\n    String containerIdStr \u003d containerId.toString();\n    // if we provide the node address and the application is in the final\n    // state, we could directly get logs from HDFS.\n    if (nodeAddress !\u003d null \u0026\u0026 (!appStateObtainedSuccessfully ||\n        isApplicationFinished(appState))) {\n      // if user specified \"ALL\" as the logFiles param, pass null\n      // to logCliHelper so that it fetches all the logs\n      List\u003cString\u003e logs;\n      if (logFiles \u003d\u003d null) {\n        logs \u003d null;\n      } else if (fetchAllLogFiles(logFiles)) {\n        logs \u003d null;\n      } else {\n        logs \u003d Arrays.asList(logFiles);\n      }\n      return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n          containerIdStr, nodeAddress, appOwner, logs);\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d\n          report.getNodeHttpAddress().replaceFirst(\n            WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n      nodeId \u003d report.getAssignedNode().toString();\n    } catch (IOException | YarnException ex) {\n      if (!appStateObtainedSuccessfully || isApplicationFinished(appState)) {\n        String[] requestedLogFiles \u003d logFiles;\n        if(fetchAllLogFiles(logFiles)) {\n          requestedLogFiles \u003d null;\n        }\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n            appOwner);\n      } else if (!isApplicationFinished(appState)) {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr\n            + \" with the appOwner: \" + appOwner);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isApplicationFinished(appState)) {\n      if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n        logFiles \u003d new String[] {\"syslog\"};\n      }\n      printContainerLogsFromRunningApplication(getConf(), containerId,\n          nodeHttpAddress, nodeId, logFiles, logCliHelper, appOwner);\n    } else {\n      String[] requestedLogFiles \u003d logFiles;\n      if(fetchAllLogFiles(logFiles)) {\n        requestedLogFiles \u003d null;\n      }\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n          nodeId, requestedLogFiles, logCliHelper, appOwner);\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java",
      "extendedDetails": {}
    },
    "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4905. Improved \"yarn logs\" command-line to optionally show log metadata also. Contributed by Xuan Gong.\n",
      "commitDate": "04/05/16 2:16 PM",
      "commitName": "9e37fe3b7a3b5f0a193d228bb5e065f41acd2835",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,76 @@\n+  private int fetchContainerLogs(YarnApplicationState appState,\n+      boolean appStateObtainedSuccessfully, String[] logFiles,\n+      String appOwner, String nodeAddress,\n+      ContainerId containerId, LogCLIHelpers logCliHelper) throws IOException {\n+    int resultCode \u003d 0;\n+    String appIdStr \u003d containerId.getApplicationAttemptId()\n+        .getApplicationId().toString();\n+    String containerIdStr \u003d containerId.toString();\n+    // if we provide the node address and the application is in the final\n+    // state, we could directly get logs from HDFS.\n+    if (nodeAddress !\u003d null \u0026\u0026 (!appStateObtainedSuccessfully ||\n+        isApplicationFinished(appState))) {\n+      // if user specified \"ALL\" as the logFiles param, pass null\n+      // to logCliHelper so that it fetches all the logs\n+      List\u003cString\u003e logs;\n+      if (logFiles \u003d\u003d null) {\n+        logs \u003d null;\n+      } else if (fetchAllLogFiles(logFiles)) {\n+        logs \u003d null;\n+      } else {\n+        logs \u003d Arrays.asList(logFiles);\n+      }\n+      return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n+          containerIdStr, nodeAddress, appOwner, logs);\n+    }\n+    String nodeHttpAddress \u003d null;\n+    String nodeId \u003d null;\n+    try {\n+      // If the nodeAddress is not provided, we will try to get\n+      // the ContainerReport. In the containerReport, we could get\n+      // nodeAddress and nodeHttpAddress\n+      ContainerReport report \u003d getContainerReport(containerIdStr);\n+      nodeHttpAddress \u003d\n+          report.getNodeHttpAddress().replaceFirst(\n+            WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n+      nodeId \u003d report.getAssignedNode().toString();\n+    } catch (IOException | YarnException ex) {\n+      if (!appStateObtainedSuccessfully || isApplicationFinished(appState)) {\n+        String[] requestedLogFiles \u003d logFiles;\n+        if(fetchAllLogFiles(logFiles)) {\n+          requestedLogFiles \u003d null;\n+        }\n+        return printContainerLogsForFinishedApplicationWithoutNodeId(\n+            appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n+            appOwner);\n+      } else if (!isApplicationFinished(appState)) {\n+        System.err.println(\"Unable to get logs for this container:\"\n+            + containerIdStr + \"for the application:\" + appIdStr);\n+        System.err.println(\"The application: \" + appIdStr\n+            + \" is still running, and we can not get Container report \"\n+            + \"for the container: \" + containerIdStr +\". Please try later \"\n+            + \"or after the application finishes.\");\n+        return -1;\n+      }\n+    }\n+    // If the application is not in the final state,\n+    // we will provide the NodeHttpAddress and get the container logs\n+    // by calling NodeManager webservice.\n+    if (!isApplicationFinished(appState)) {\n+      if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n+        logFiles \u003d new String[] {\"syslog\"};\n+      }\n+      printContainerLogsFromRunningApplication(getConf(), containerId,\n+          nodeHttpAddress, nodeId, logFiles, logCliHelper, appOwner);\n+    } else {\n+      String[] requestedLogFiles \u003d logFiles;\n+      if(fetchAllLogFiles(logFiles)) {\n+        requestedLogFiles \u003d null;\n+      }\n+      // If the application is in the final state, we will directly\n+      // get the container logs from HDFS.\n+      printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n+          nodeId, requestedLogFiles, logCliHelper, appOwner);\n+    }\n+    return resultCode;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private int fetchContainerLogs(YarnApplicationState appState,\n      boolean appStateObtainedSuccessfully, String[] logFiles,\n      String appOwner, String nodeAddress,\n      ContainerId containerId, LogCLIHelpers logCliHelper) throws IOException {\n    int resultCode \u003d 0;\n    String appIdStr \u003d containerId.getApplicationAttemptId()\n        .getApplicationId().toString();\n    String containerIdStr \u003d containerId.toString();\n    // if we provide the node address and the application is in the final\n    // state, we could directly get logs from HDFS.\n    if (nodeAddress !\u003d null \u0026\u0026 (!appStateObtainedSuccessfully ||\n        isApplicationFinished(appState))) {\n      // if user specified \"ALL\" as the logFiles param, pass null\n      // to logCliHelper so that it fetches all the logs\n      List\u003cString\u003e logs;\n      if (logFiles \u003d\u003d null) {\n        logs \u003d null;\n      } else if (fetchAllLogFiles(logFiles)) {\n        logs \u003d null;\n      } else {\n        logs \u003d Arrays.asList(logFiles);\n      }\n      return logCliHelper.dumpAContainersLogsForALogType(appIdStr,\n          containerIdStr, nodeAddress, appOwner, logs);\n    }\n    String nodeHttpAddress \u003d null;\n    String nodeId \u003d null;\n    try {\n      // If the nodeAddress is not provided, we will try to get\n      // the ContainerReport. In the containerReport, we could get\n      // nodeAddress and nodeHttpAddress\n      ContainerReport report \u003d getContainerReport(containerIdStr);\n      nodeHttpAddress \u003d\n          report.getNodeHttpAddress().replaceFirst(\n            WebAppUtils.getHttpSchemePrefix(getConf()), \"\");\n      nodeId \u003d report.getAssignedNode().toString();\n    } catch (IOException | YarnException ex) {\n      if (!appStateObtainedSuccessfully || isApplicationFinished(appState)) {\n        String[] requestedLogFiles \u003d logFiles;\n        if(fetchAllLogFiles(logFiles)) {\n          requestedLogFiles \u003d null;\n        }\n        return printContainerLogsForFinishedApplicationWithoutNodeId(\n            appIdStr, containerIdStr, requestedLogFiles, logCliHelper,\n            appOwner);\n      } else if (!isApplicationFinished(appState)) {\n        System.err.println(\"Unable to get logs for this container:\"\n            + containerIdStr + \"for the application:\" + appIdStr);\n        System.err.println(\"The application: \" + appIdStr\n            + \" is still running, and we can not get Container report \"\n            + \"for the container: \" + containerIdStr +\". Please try later \"\n            + \"or after the application finishes.\");\n        return -1;\n      }\n    }\n    // If the application is not in the final state,\n    // we will provide the NodeHttpAddress and get the container logs\n    // by calling NodeManager webservice.\n    if (!isApplicationFinished(appState)) {\n      if (logFiles \u003d\u003d null || logFiles.length \u003d\u003d 0) {\n        logFiles \u003d new String[] {\"syslog\"};\n      }\n      printContainerLogsFromRunningApplication(getConf(), containerId,\n          nodeHttpAddress, nodeId, logFiles, logCliHelper, appOwner);\n    } else {\n      String[] requestedLogFiles \u003d logFiles;\n      if(fetchAllLogFiles(logFiles)) {\n        requestedLogFiles \u003d null;\n      }\n      // If the application is in the final state, we will directly\n      // get the container logs from HDFS.\n      printContainerLogsForFinishedApplication(appIdStr, containerIdStr,\n          nodeId, requestedLogFiles, logCliHelper, appOwner);\n    }\n    return resultCode;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/cli/LogsCLI.java"
    }
  }
}