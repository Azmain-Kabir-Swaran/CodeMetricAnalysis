{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NameNodeUtils.java",
  "functionName": "getClientNamenodeAddress",
  "functionId": "getClientNamenodeAddress___conf-Configuration__nsId-String(annotations-@Nullable)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeUtils.java",
  "functionStartLine": 68,
  "functionEndLine": 120,
  "numCommitsSeen": 190,
  "timeTaken": 7145,
  "changeHistory": [
    "263c76b678275dfff867415c71ba9dc00a9235ef",
    "c533c770476254c27309daeb2b41c73dc70bf3f4",
    "6f8003dc7bc9e8be7b0512c514d370c303faf003",
    "3ae38ec7dfa1aaf451cf889cec6cf862379af32a",
    "eac832f92da084f1fa2b281331db32e01ab05604"
  ],
  "changeHistoryShort": {
    "263c76b678275dfff867415c71ba9dc00a9235ef": "Ybodychange",
    "c533c770476254c27309daeb2b41c73dc70bf3f4": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yrename,Yparameterchange)",
    "6f8003dc7bc9e8be7b0512c514d370c303faf003": "Ybodychange",
    "3ae38ec7dfa1aaf451cf889cec6cf862379af32a": "Ybodychange",
    "eac832f92da084f1fa2b281331db32e01ab05604": "Yintroduced"
  },
  "changeHistoryDetails": {
    "263c76b678275dfff867415c71ba9dc00a9235ef": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-17011. Tolerate leading and trailing spaces in fs.defaultFS. Contributed by Ctest\n\nSigned-off-by: Ayush Saxena \u003cayushsaxena@apache.org\u003e\n",
      "commitDate": "30/04/20 2:15 PM",
      "commitName": "263c76b678275dfff867415c71ba9dc00a9235ef",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "11/05/18 2:24 PM",
      "commitNameOld": "4b4f24ad5f2b457ad215d469bf28cf9a799812bc",
      "commitAuthorOld": "Anu Engineer",
      "daysBetweenCommits": 719.99,
      "commitsBetweenForRepo": 4730,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   static String getClientNamenodeAddress(\n       Configuration conf, @Nullable String nsId) {\n     final Collection\u003cString\u003e nameservices \u003d\n         DFSUtilClient.getNameServiceIds(conf);\n \n-    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n+    final String nnAddr \u003d conf.getTrimmed(FS_DEFAULT_NAME_KEY);\n     if (nnAddr \u003d\u003d null) {\n       // default fs is not set.\n       return null;\n     }\n \n     LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n     final URI nnUri \u003d URI.create(nnAddr);\n \n     String defaultNnHost \u003d nnUri.getHost();\n     if (defaultNnHost \u003d\u003d null) {\n       return null;\n     }\n \n     // Current Nameservice is HA.\n     if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n       final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n           DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n       if (namenodes.size() \u003e 1) {\n         return nsId;\n       }\n     }\n \n     // Federation without HA. We must handle the case when the current NN\n     // is not in the default nameservice.\n     String currentNnAddress \u003d null;\n     if (nsId !\u003d null) {\n       String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n       currentNnAddress \u003d conf.get(hostNameKey);\n     }\n \n     // Fallback to the address in fs.defaultFS.\n     if (currentNnAddress \u003d\u003d null) {\n       currentNnAddress \u003d nnUri.getAuthority();\n     }\n \n     int port \u003d 0;\n     if (currentNnAddress.contains(\":\")) {\n       port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n     }\n \n     if (port \u003e 0) {\n        return currentNnAddress;\n     } else {\n       // the port is missing or 0. Figure out real bind address later.\n       return null;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static String getClientNamenodeAddress(\n      Configuration conf, @Nullable String nsId) {\n    final Collection\u003cString\u003e nameservices \u003d\n        DFSUtilClient.getNameServiceIds(conf);\n\n    final String nnAddr \u003d conf.getTrimmed(FS_DEFAULT_NAME_KEY);\n    if (nnAddr \u003d\u003d null) {\n      // default fs is not set.\n      return null;\n    }\n\n    LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n    final URI nnUri \u003d URI.create(nnAddr);\n\n    String defaultNnHost \u003d nnUri.getHost();\n    if (defaultNnHost \u003d\u003d null) {\n      return null;\n    }\n\n    // Current Nameservice is HA.\n    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n      if (namenodes.size() \u003e 1) {\n        return nsId;\n      }\n    }\n\n    // Federation without HA. We must handle the case when the current NN\n    // is not in the default nameservice.\n    String currentNnAddress \u003d null;\n    if (nsId !\u003d null) {\n      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n      currentNnAddress \u003d conf.get(hostNameKey);\n    }\n\n    // Fallback to the address in fs.defaultFS.\n    if (currentNnAddress \u003d\u003d null) {\n      currentNnAddress \u003d nnUri.getAuthority();\n    }\n\n    int port \u003d 0;\n    if (currentNnAddress.contains(\":\")) {\n      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n    }\n\n    if (port \u003e 0) {\n       return currentNnAddress;\n    } else {\n      // the port is missing or 0. Figure out real bind address later.\n      return null;\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeUtils.java",
      "extendedDetails": {}
    },
    "c533c770476254c27309daeb2b41c73dc70bf3f4": {
      "type": "Ymultichange(Ymovefromfile,Yreturntypechange,Ymodifierchange,Ybodychange,Yrename,Yparameterchange)",
      "commitMessage": "HDFS-13433. webhdfs requests can be routed incorrectly in federated cluster. Contributed by Arpit Agarwal.\n",
      "commitDate": "23/04/18 10:08 AM",
      "commitName": "c533c770476254c27309daeb2b41c73dc70bf3f4",
      "commitAuthor": "Arpit Agarwal",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-13433. webhdfs requests can be routed incorrectly in federated cluster. Contributed by Arpit Agarwal.\n",
          "commitDate": "23/04/18 10:08 AM",
          "commitName": "c533c770476254c27309daeb2b41c73dc70bf3f4",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "23/04/18 1:06 AM",
          "commitNameOld": "83e5f25d5e28a6975464953dc756a3f464d4be60",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 0.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,53 @@\n-  public void setClientNamenodeAddress(Configuration conf) {\n-    String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n+  static String getClientNamenodeAddress(\n+      Configuration conf, @Nullable String nsId) {\n+    final Collection\u003cString\u003e nameservices \u003d\n+        DFSUtilClient.getNameServiceIds(conf);\n+\n+    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n     if (nnAddr \u003d\u003d null) {\n       // default fs is not set.\n-      clientNamenodeAddress \u003d null;\n-      return;\n+      return null;\n     }\n \n     LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n-    URI nnUri \u003d URI.create(nnAddr);\n+    final URI nnUri \u003d URI.create(nnAddr);\n \n-    String nnHost \u003d nnUri.getHost();\n-    if (nnHost \u003d\u003d null) {\n-      clientNamenodeAddress \u003d null;\n-      return;\n+    String defaultNnHost \u003d nnUri.getHost();\n+    if (defaultNnHost \u003d\u003d null) {\n+      return null;\n     }\n \n-    if (DFSUtilClient.getNameServiceIds(conf).contains(nnHost)) {\n-      // host name is logical\n-      clientNamenodeAddress \u003d nnHost;\n-    } else if (nnUri.getPort() \u003e 0) {\n-      // physical address with a valid port\n-      clientNamenodeAddress \u003d nnUri.getAuthority();\n+    // Current Nameservice is HA.\n+    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n+      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n+          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n+      if (namenodes.size() \u003e 1) {\n+        return nsId;\n+      }\n+    }\n+\n+    // Federation without HA. We must handle the case when the current NN\n+    // is not in the default nameservice.\n+    String currentNnAddress \u003d null;\n+    if (nsId !\u003d null) {\n+      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n+      currentNnAddress \u003d conf.get(hostNameKey);\n+    }\n+\n+    // Fallback to the address in fs.defaultFS.\n+    if (currentNnAddress \u003d\u003d null) {\n+      currentNnAddress \u003d nnUri.getAuthority();\n+    }\n+\n+    int port \u003d 0;\n+    if (currentNnAddress.contains(\":\")) {\n+      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n+    }\n+\n+    if (port \u003e 0) {\n+      return currentNnAddress;\n     } else {\n       // the port is missing or 0. Figure out real bind address later.\n-      clientNamenodeAddress \u003d null;\n-      return;\n+      return null;\n     }\n-    LOG.info(\"Clients are to use {} to access\"\n-        + \" this namenode/service.\", clientNamenodeAddress );\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static String getClientNamenodeAddress(\n      Configuration conf, @Nullable String nsId) {\n    final Collection\u003cString\u003e nameservices \u003d\n        DFSUtilClient.getNameServiceIds(conf);\n\n    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n    if (nnAddr \u003d\u003d null) {\n      // default fs is not set.\n      return null;\n    }\n\n    LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n    final URI nnUri \u003d URI.create(nnAddr);\n\n    String defaultNnHost \u003d nnUri.getHost();\n    if (defaultNnHost \u003d\u003d null) {\n      return null;\n    }\n\n    // Current Nameservice is HA.\n    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n      if (namenodes.size() \u003e 1) {\n        return nsId;\n      }\n    }\n\n    // Federation without HA. We must handle the case when the current NN\n    // is not in the default nameservice.\n    String currentNnAddress \u003d null;\n    if (nsId !\u003d null) {\n      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n      currentNnAddress \u003d conf.get(hostNameKey);\n    }\n\n    // Fallback to the address in fs.defaultFS.\n    if (currentNnAddress \u003d\u003d null) {\n      currentNnAddress \u003d nnUri.getAuthority();\n    }\n\n    int port \u003d 0;\n    if (currentNnAddress.contains(\":\")) {\n      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n    }\n\n    if (port \u003e 0) {\n      return currentNnAddress;\n    } else {\n      // the port is missing or 0. Figure out real bind address later.\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeUtils.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeUtils.java",
            "oldMethodName": "setClientNamenodeAddress",
            "newMethodName": "getClientNamenodeAddress"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-13433. webhdfs requests can be routed incorrectly in federated cluster. Contributed by Arpit Agarwal.\n",
          "commitDate": "23/04/18 10:08 AM",
          "commitName": "c533c770476254c27309daeb2b41c73dc70bf3f4",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "23/04/18 1:06 AM",
          "commitNameOld": "83e5f25d5e28a6975464953dc756a3f464d4be60",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 0.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,53 @@\n-  public void setClientNamenodeAddress(Configuration conf) {\n-    String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n+  static String getClientNamenodeAddress(\n+      Configuration conf, @Nullable String nsId) {\n+    final Collection\u003cString\u003e nameservices \u003d\n+        DFSUtilClient.getNameServiceIds(conf);\n+\n+    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n     if (nnAddr \u003d\u003d null) {\n       // default fs is not set.\n-      clientNamenodeAddress \u003d null;\n-      return;\n+      return null;\n     }\n \n     LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n-    URI nnUri \u003d URI.create(nnAddr);\n+    final URI nnUri \u003d URI.create(nnAddr);\n \n-    String nnHost \u003d nnUri.getHost();\n-    if (nnHost \u003d\u003d null) {\n-      clientNamenodeAddress \u003d null;\n-      return;\n+    String defaultNnHost \u003d nnUri.getHost();\n+    if (defaultNnHost \u003d\u003d null) {\n+      return null;\n     }\n \n-    if (DFSUtilClient.getNameServiceIds(conf).contains(nnHost)) {\n-      // host name is logical\n-      clientNamenodeAddress \u003d nnHost;\n-    } else if (nnUri.getPort() \u003e 0) {\n-      // physical address with a valid port\n-      clientNamenodeAddress \u003d nnUri.getAuthority();\n+    // Current Nameservice is HA.\n+    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n+      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n+          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n+      if (namenodes.size() \u003e 1) {\n+        return nsId;\n+      }\n+    }\n+\n+    // Federation without HA. We must handle the case when the current NN\n+    // is not in the default nameservice.\n+    String currentNnAddress \u003d null;\n+    if (nsId !\u003d null) {\n+      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n+      currentNnAddress \u003d conf.get(hostNameKey);\n+    }\n+\n+    // Fallback to the address in fs.defaultFS.\n+    if (currentNnAddress \u003d\u003d null) {\n+      currentNnAddress \u003d nnUri.getAuthority();\n+    }\n+\n+    int port \u003d 0;\n+    if (currentNnAddress.contains(\":\")) {\n+      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n+    }\n+\n+    if (port \u003e 0) {\n+      return currentNnAddress;\n     } else {\n       // the port is missing or 0. Figure out real bind address later.\n-      clientNamenodeAddress \u003d null;\n-      return;\n+      return null;\n     }\n-    LOG.info(\"Clients are to use {} to access\"\n-        + \" this namenode/service.\", clientNamenodeAddress );\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static String getClientNamenodeAddress(\n      Configuration conf, @Nullable String nsId) {\n    final Collection\u003cString\u003e nameservices \u003d\n        DFSUtilClient.getNameServiceIds(conf);\n\n    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n    if (nnAddr \u003d\u003d null) {\n      // default fs is not set.\n      return null;\n    }\n\n    LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n    final URI nnUri \u003d URI.create(nnAddr);\n\n    String defaultNnHost \u003d nnUri.getHost();\n    if (defaultNnHost \u003d\u003d null) {\n      return null;\n    }\n\n    // Current Nameservice is HA.\n    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n      if (namenodes.size() \u003e 1) {\n        return nsId;\n      }\n    }\n\n    // Federation without HA. We must handle the case when the current NN\n    // is not in the default nameservice.\n    String currentNnAddress \u003d null;\n    if (nsId !\u003d null) {\n      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n      currentNnAddress \u003d conf.get(hostNameKey);\n    }\n\n    // Fallback to the address in fs.defaultFS.\n    if (currentNnAddress \u003d\u003d null) {\n      currentNnAddress \u003d nnUri.getAuthority();\n    }\n\n    int port \u003d 0;\n    if (currentNnAddress.contains(\":\")) {\n      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n    }\n\n    if (port \u003e 0) {\n      return currentNnAddress;\n    } else {\n      // the port is missing or 0. Figure out real bind address later.\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeUtils.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "String"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-13433. webhdfs requests can be routed incorrectly in federated cluster. Contributed by Arpit Agarwal.\n",
          "commitDate": "23/04/18 10:08 AM",
          "commitName": "c533c770476254c27309daeb2b41c73dc70bf3f4",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "23/04/18 1:06 AM",
          "commitNameOld": "83e5f25d5e28a6975464953dc756a3f464d4be60",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 0.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,53 @@\n-  public void setClientNamenodeAddress(Configuration conf) {\n-    String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n+  static String getClientNamenodeAddress(\n+      Configuration conf, @Nullable String nsId) {\n+    final Collection\u003cString\u003e nameservices \u003d\n+        DFSUtilClient.getNameServiceIds(conf);\n+\n+    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n     if (nnAddr \u003d\u003d null) {\n       // default fs is not set.\n-      clientNamenodeAddress \u003d null;\n-      return;\n+      return null;\n     }\n \n     LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n-    URI nnUri \u003d URI.create(nnAddr);\n+    final URI nnUri \u003d URI.create(nnAddr);\n \n-    String nnHost \u003d nnUri.getHost();\n-    if (nnHost \u003d\u003d null) {\n-      clientNamenodeAddress \u003d null;\n-      return;\n+    String defaultNnHost \u003d nnUri.getHost();\n+    if (defaultNnHost \u003d\u003d null) {\n+      return null;\n     }\n \n-    if (DFSUtilClient.getNameServiceIds(conf).contains(nnHost)) {\n-      // host name is logical\n-      clientNamenodeAddress \u003d nnHost;\n-    } else if (nnUri.getPort() \u003e 0) {\n-      // physical address with a valid port\n-      clientNamenodeAddress \u003d nnUri.getAuthority();\n+    // Current Nameservice is HA.\n+    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n+      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n+          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n+      if (namenodes.size() \u003e 1) {\n+        return nsId;\n+      }\n+    }\n+\n+    // Federation without HA. We must handle the case when the current NN\n+    // is not in the default nameservice.\n+    String currentNnAddress \u003d null;\n+    if (nsId !\u003d null) {\n+      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n+      currentNnAddress \u003d conf.get(hostNameKey);\n+    }\n+\n+    // Fallback to the address in fs.defaultFS.\n+    if (currentNnAddress \u003d\u003d null) {\n+      currentNnAddress \u003d nnUri.getAuthority();\n+    }\n+\n+    int port \u003d 0;\n+    if (currentNnAddress.contains(\":\")) {\n+      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n+    }\n+\n+    if (port \u003e 0) {\n+      return currentNnAddress;\n     } else {\n       // the port is missing or 0. Figure out real bind address later.\n-      clientNamenodeAddress \u003d null;\n-      return;\n+      return null;\n     }\n-    LOG.info(\"Clients are to use {} to access\"\n-        + \" this namenode/service.\", clientNamenodeAddress );\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static String getClientNamenodeAddress(\n      Configuration conf, @Nullable String nsId) {\n    final Collection\u003cString\u003e nameservices \u003d\n        DFSUtilClient.getNameServiceIds(conf);\n\n    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n    if (nnAddr \u003d\u003d null) {\n      // default fs is not set.\n      return null;\n    }\n\n    LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n    final URI nnUri \u003d URI.create(nnAddr);\n\n    String defaultNnHost \u003d nnUri.getHost();\n    if (defaultNnHost \u003d\u003d null) {\n      return null;\n    }\n\n    // Current Nameservice is HA.\n    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n      if (namenodes.size() \u003e 1) {\n        return nsId;\n      }\n    }\n\n    // Federation without HA. We must handle the case when the current NN\n    // is not in the default nameservice.\n    String currentNnAddress \u003d null;\n    if (nsId !\u003d null) {\n      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n      currentNnAddress \u003d conf.get(hostNameKey);\n    }\n\n    // Fallback to the address in fs.defaultFS.\n    if (currentNnAddress \u003d\u003d null) {\n      currentNnAddress \u003d nnUri.getAuthority();\n    }\n\n    int port \u003d 0;\n    if (currentNnAddress.contains(\":\")) {\n      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n    }\n\n    if (port \u003e 0) {\n      return currentNnAddress;\n    } else {\n      // the port is missing or 0. Figure out real bind address later.\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeUtils.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[static]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-13433. webhdfs requests can be routed incorrectly in federated cluster. Contributed by Arpit Agarwal.\n",
          "commitDate": "23/04/18 10:08 AM",
          "commitName": "c533c770476254c27309daeb2b41c73dc70bf3f4",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "23/04/18 1:06 AM",
          "commitNameOld": "83e5f25d5e28a6975464953dc756a3f464d4be60",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 0.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,53 @@\n-  public void setClientNamenodeAddress(Configuration conf) {\n-    String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n+  static String getClientNamenodeAddress(\n+      Configuration conf, @Nullable String nsId) {\n+    final Collection\u003cString\u003e nameservices \u003d\n+        DFSUtilClient.getNameServiceIds(conf);\n+\n+    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n     if (nnAddr \u003d\u003d null) {\n       // default fs is not set.\n-      clientNamenodeAddress \u003d null;\n-      return;\n+      return null;\n     }\n \n     LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n-    URI nnUri \u003d URI.create(nnAddr);\n+    final URI nnUri \u003d URI.create(nnAddr);\n \n-    String nnHost \u003d nnUri.getHost();\n-    if (nnHost \u003d\u003d null) {\n-      clientNamenodeAddress \u003d null;\n-      return;\n+    String defaultNnHost \u003d nnUri.getHost();\n+    if (defaultNnHost \u003d\u003d null) {\n+      return null;\n     }\n \n-    if (DFSUtilClient.getNameServiceIds(conf).contains(nnHost)) {\n-      // host name is logical\n-      clientNamenodeAddress \u003d nnHost;\n-    } else if (nnUri.getPort() \u003e 0) {\n-      // physical address with a valid port\n-      clientNamenodeAddress \u003d nnUri.getAuthority();\n+    // Current Nameservice is HA.\n+    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n+      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n+          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n+      if (namenodes.size() \u003e 1) {\n+        return nsId;\n+      }\n+    }\n+\n+    // Federation without HA. We must handle the case when the current NN\n+    // is not in the default nameservice.\n+    String currentNnAddress \u003d null;\n+    if (nsId !\u003d null) {\n+      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n+      currentNnAddress \u003d conf.get(hostNameKey);\n+    }\n+\n+    // Fallback to the address in fs.defaultFS.\n+    if (currentNnAddress \u003d\u003d null) {\n+      currentNnAddress \u003d nnUri.getAuthority();\n+    }\n+\n+    int port \u003d 0;\n+    if (currentNnAddress.contains(\":\")) {\n+      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n+    }\n+\n+    if (port \u003e 0) {\n+      return currentNnAddress;\n     } else {\n       // the port is missing or 0. Figure out real bind address later.\n-      clientNamenodeAddress \u003d null;\n-      return;\n+      return null;\n     }\n-    LOG.info(\"Clients are to use {} to access\"\n-        + \" this namenode/service.\", clientNamenodeAddress );\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static String getClientNamenodeAddress(\n      Configuration conf, @Nullable String nsId) {\n    final Collection\u003cString\u003e nameservices \u003d\n        DFSUtilClient.getNameServiceIds(conf);\n\n    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n    if (nnAddr \u003d\u003d null) {\n      // default fs is not set.\n      return null;\n    }\n\n    LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n    final URI nnUri \u003d URI.create(nnAddr);\n\n    String defaultNnHost \u003d nnUri.getHost();\n    if (defaultNnHost \u003d\u003d null) {\n      return null;\n    }\n\n    // Current Nameservice is HA.\n    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n      if (namenodes.size() \u003e 1) {\n        return nsId;\n      }\n    }\n\n    // Federation without HA. We must handle the case when the current NN\n    // is not in the default nameservice.\n    String currentNnAddress \u003d null;\n    if (nsId !\u003d null) {\n      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n      currentNnAddress \u003d conf.get(hostNameKey);\n    }\n\n    // Fallback to the address in fs.defaultFS.\n    if (currentNnAddress \u003d\u003d null) {\n      currentNnAddress \u003d nnUri.getAuthority();\n    }\n\n    int port \u003d 0;\n    if (currentNnAddress.contains(\":\")) {\n      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n    }\n\n    if (port \u003e 0) {\n      return currentNnAddress;\n    } else {\n      // the port is missing or 0. Figure out real bind address later.\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeUtils.java",
          "extendedDetails": {}
        },
        {
          "type": "Yrename",
          "commitMessage": "HDFS-13433. webhdfs requests can be routed incorrectly in federated cluster. Contributed by Arpit Agarwal.\n",
          "commitDate": "23/04/18 10:08 AM",
          "commitName": "c533c770476254c27309daeb2b41c73dc70bf3f4",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "23/04/18 1:06 AM",
          "commitNameOld": "83e5f25d5e28a6975464953dc756a3f464d4be60",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 0.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,53 @@\n-  public void setClientNamenodeAddress(Configuration conf) {\n-    String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n+  static String getClientNamenodeAddress(\n+      Configuration conf, @Nullable String nsId) {\n+    final Collection\u003cString\u003e nameservices \u003d\n+        DFSUtilClient.getNameServiceIds(conf);\n+\n+    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n     if (nnAddr \u003d\u003d null) {\n       // default fs is not set.\n-      clientNamenodeAddress \u003d null;\n-      return;\n+      return null;\n     }\n \n     LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n-    URI nnUri \u003d URI.create(nnAddr);\n+    final URI nnUri \u003d URI.create(nnAddr);\n \n-    String nnHost \u003d nnUri.getHost();\n-    if (nnHost \u003d\u003d null) {\n-      clientNamenodeAddress \u003d null;\n-      return;\n+    String defaultNnHost \u003d nnUri.getHost();\n+    if (defaultNnHost \u003d\u003d null) {\n+      return null;\n     }\n \n-    if (DFSUtilClient.getNameServiceIds(conf).contains(nnHost)) {\n-      // host name is logical\n-      clientNamenodeAddress \u003d nnHost;\n-    } else if (nnUri.getPort() \u003e 0) {\n-      // physical address with a valid port\n-      clientNamenodeAddress \u003d nnUri.getAuthority();\n+    // Current Nameservice is HA.\n+    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n+      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n+          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n+      if (namenodes.size() \u003e 1) {\n+        return nsId;\n+      }\n+    }\n+\n+    // Federation without HA. We must handle the case when the current NN\n+    // is not in the default nameservice.\n+    String currentNnAddress \u003d null;\n+    if (nsId !\u003d null) {\n+      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n+      currentNnAddress \u003d conf.get(hostNameKey);\n+    }\n+\n+    // Fallback to the address in fs.defaultFS.\n+    if (currentNnAddress \u003d\u003d null) {\n+      currentNnAddress \u003d nnUri.getAuthority();\n+    }\n+\n+    int port \u003d 0;\n+    if (currentNnAddress.contains(\":\")) {\n+      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n+    }\n+\n+    if (port \u003e 0) {\n+      return currentNnAddress;\n     } else {\n       // the port is missing or 0. Figure out real bind address later.\n-      clientNamenodeAddress \u003d null;\n-      return;\n+      return null;\n     }\n-    LOG.info(\"Clients are to use {} to access\"\n-        + \" this namenode/service.\", clientNamenodeAddress );\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static String getClientNamenodeAddress(\n      Configuration conf, @Nullable String nsId) {\n    final Collection\u003cString\u003e nameservices \u003d\n        DFSUtilClient.getNameServiceIds(conf);\n\n    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n    if (nnAddr \u003d\u003d null) {\n      // default fs is not set.\n      return null;\n    }\n\n    LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n    final URI nnUri \u003d URI.create(nnAddr);\n\n    String defaultNnHost \u003d nnUri.getHost();\n    if (defaultNnHost \u003d\u003d null) {\n      return null;\n    }\n\n    // Current Nameservice is HA.\n    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n      if (namenodes.size() \u003e 1) {\n        return nsId;\n      }\n    }\n\n    // Federation without HA. We must handle the case when the current NN\n    // is not in the default nameservice.\n    String currentNnAddress \u003d null;\n    if (nsId !\u003d null) {\n      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n      currentNnAddress \u003d conf.get(hostNameKey);\n    }\n\n    // Fallback to the address in fs.defaultFS.\n    if (currentNnAddress \u003d\u003d null) {\n      currentNnAddress \u003d nnUri.getAuthority();\n    }\n\n    int port \u003d 0;\n    if (currentNnAddress.contains(\":\")) {\n      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n    }\n\n    if (port \u003e 0) {\n      return currentNnAddress;\n    } else {\n      // the port is missing or 0. Figure out real bind address later.\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeUtils.java",
          "extendedDetails": {
            "oldValue": "setClientNamenodeAddress",
            "newValue": "getClientNamenodeAddress"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-13433. webhdfs requests can be routed incorrectly in federated cluster. Contributed by Arpit Agarwal.\n",
          "commitDate": "23/04/18 10:08 AM",
          "commitName": "c533c770476254c27309daeb2b41c73dc70bf3f4",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "23/04/18 1:06 AM",
          "commitNameOld": "83e5f25d5e28a6975464953dc756a3f464d4be60",
          "commitAuthorOld": "Sunil G",
          "daysBetweenCommits": 0.38,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,53 @@\n-  public void setClientNamenodeAddress(Configuration conf) {\n-    String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n+  static String getClientNamenodeAddress(\n+      Configuration conf, @Nullable String nsId) {\n+    final Collection\u003cString\u003e nameservices \u003d\n+        DFSUtilClient.getNameServiceIds(conf);\n+\n+    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n     if (nnAddr \u003d\u003d null) {\n       // default fs is not set.\n-      clientNamenodeAddress \u003d null;\n-      return;\n+      return null;\n     }\n \n     LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n-    URI nnUri \u003d URI.create(nnAddr);\n+    final URI nnUri \u003d URI.create(nnAddr);\n \n-    String nnHost \u003d nnUri.getHost();\n-    if (nnHost \u003d\u003d null) {\n-      clientNamenodeAddress \u003d null;\n-      return;\n+    String defaultNnHost \u003d nnUri.getHost();\n+    if (defaultNnHost \u003d\u003d null) {\n+      return null;\n     }\n \n-    if (DFSUtilClient.getNameServiceIds(conf).contains(nnHost)) {\n-      // host name is logical\n-      clientNamenodeAddress \u003d nnHost;\n-    } else if (nnUri.getPort() \u003e 0) {\n-      // physical address with a valid port\n-      clientNamenodeAddress \u003d nnUri.getAuthority();\n+    // Current Nameservice is HA.\n+    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n+      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n+          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n+      if (namenodes.size() \u003e 1) {\n+        return nsId;\n+      }\n+    }\n+\n+    // Federation without HA. We must handle the case when the current NN\n+    // is not in the default nameservice.\n+    String currentNnAddress \u003d null;\n+    if (nsId !\u003d null) {\n+      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n+      currentNnAddress \u003d conf.get(hostNameKey);\n+    }\n+\n+    // Fallback to the address in fs.defaultFS.\n+    if (currentNnAddress \u003d\u003d null) {\n+      currentNnAddress \u003d nnUri.getAuthority();\n+    }\n+\n+    int port \u003d 0;\n+    if (currentNnAddress.contains(\":\")) {\n+      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n+    }\n+\n+    if (port \u003e 0) {\n+      return currentNnAddress;\n     } else {\n       // the port is missing or 0. Figure out real bind address later.\n-      clientNamenodeAddress \u003d null;\n-      return;\n+      return null;\n     }\n-    LOG.info(\"Clients are to use {} to access\"\n-        + \" this namenode/service.\", clientNamenodeAddress );\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static String getClientNamenodeAddress(\n      Configuration conf, @Nullable String nsId) {\n    final Collection\u003cString\u003e nameservices \u003d\n        DFSUtilClient.getNameServiceIds(conf);\n\n    final String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n    if (nnAddr \u003d\u003d null) {\n      // default fs is not set.\n      return null;\n    }\n\n    LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n    final URI nnUri \u003d URI.create(nnAddr);\n\n    String defaultNnHost \u003d nnUri.getHost();\n    if (defaultNnHost \u003d\u003d null) {\n      return null;\n    }\n\n    // Current Nameservice is HA.\n    if (nsId !\u003d null \u0026\u0026 nameservices.contains(nsId)) {\n      final Collection\u003cString\u003e namenodes \u003d conf.getTrimmedStringCollection(\n          DFS_HA_NAMENODES_KEY_PREFIX + \".\" + nsId);\n      if (namenodes.size() \u003e 1) {\n        return nsId;\n      }\n    }\n\n    // Federation without HA. We must handle the case when the current NN\n    // is not in the default nameservice.\n    String currentNnAddress \u003d null;\n    if (nsId !\u003d null) {\n      String hostNameKey \u003d DFS_NAMENODE_RPC_ADDRESS_KEY + \".\" + nsId;\n      currentNnAddress \u003d conf.get(hostNameKey);\n    }\n\n    // Fallback to the address in fs.defaultFS.\n    if (currentNnAddress \u003d\u003d null) {\n      currentNnAddress \u003d nnUri.getAuthority();\n    }\n\n    int port \u003d 0;\n    if (currentNnAddress.contains(\":\")) {\n      port \u003d Integer.parseInt(currentNnAddress.split(\":\")[1]);\n    }\n\n    if (port \u003e 0) {\n      return currentNnAddress;\n    } else {\n      // the port is missing or 0. Figure out real bind address later.\n      return null;\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeUtils.java",
          "extendedDetails": {
            "oldValue": "[conf-Configuration]",
            "newValue": "[conf-Configuration, nsId-String(annotations-@Nullable)]"
          }
        }
      ]
    },
    "6f8003dc7bc9e8be7b0512c514d370c303faf003": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8185. Separate client related routines in HAUtil into a new class. Contributed by Haohui Mai.\n",
      "commitDate": "21/04/15 9:59 PM",
      "commitName": "6f8003dc7bc9e8be7b0512c514d370c303faf003",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "01/04/15 12:54 PM",
      "commitNameOld": "ed72daa5df97669906234e8ac9a406d78136b206",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 20.38,
      "commitsBetweenForRepo": 162,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n   public void setClientNamenodeAddress(Configuration conf) {\n     String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n     if (nnAddr \u003d\u003d null) {\n       // default fs is not set.\n       clientNamenodeAddress \u003d null;\n       return;\n     }\n \n     LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n     URI nnUri \u003d URI.create(nnAddr);\n \n     String nnHost \u003d nnUri.getHost();\n     if (nnHost \u003d\u003d null) {\n       clientNamenodeAddress \u003d null;\n       return;\n     }\n \n-    if (DFSUtil.getNameServiceIds(conf).contains(nnHost)) {\n+    if (DFSUtilClient.getNameServiceIds(conf).contains(nnHost)) {\n       // host name is logical\n       clientNamenodeAddress \u003d nnHost;\n     } else if (nnUri.getPort() \u003e 0) {\n       // physical address with a valid port\n       clientNamenodeAddress \u003d nnUri.getAuthority();\n     } else {\n       // the port is missing or 0. Figure out real bind address later.\n       clientNamenodeAddress \u003d null;\n       return;\n     }\n     LOG.info(\"Clients are to use {} to access\"\n         + \" this namenode/service.\", clientNamenodeAddress );\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setClientNamenodeAddress(Configuration conf) {\n    String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n    if (nnAddr \u003d\u003d null) {\n      // default fs is not set.\n      clientNamenodeAddress \u003d null;\n      return;\n    }\n\n    LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n    URI nnUri \u003d URI.create(nnAddr);\n\n    String nnHost \u003d nnUri.getHost();\n    if (nnHost \u003d\u003d null) {\n      clientNamenodeAddress \u003d null;\n      return;\n    }\n\n    if (DFSUtilClient.getNameServiceIds(conf).contains(nnHost)) {\n      // host name is logical\n      clientNamenodeAddress \u003d nnHost;\n    } else if (nnUri.getPort() \u003e 0) {\n      // physical address with a valid port\n      clientNamenodeAddress \u003d nnUri.getAuthority();\n    } else {\n      // the port is missing or 0. Figure out real bind address later.\n      clientNamenodeAddress \u003d null;\n      return;\n    }\n    LOG.info(\"Clients are to use {} to access\"\n        + \" this namenode/service.\", clientNamenodeAddress );\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "3ae38ec7dfa1aaf451cf889cec6cf862379af32a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7712. Switch blockStateChangeLog to use slf4j.\n",
      "commitDate": "03/02/15 3:01 PM",
      "commitName": "3ae38ec7dfa1aaf451cf889cec6cf862379af32a",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/01/15 11:33 AM",
      "commitNameOld": "db334bb8625da97c7e518cbcf477530c7ba7001e",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 13.14,
      "commitsBetweenForRepo": 102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n   public void setClientNamenodeAddress(Configuration conf) {\n     String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n     if (nnAddr \u003d\u003d null) {\n       // default fs is not set.\n       clientNamenodeAddress \u003d null;\n       return;\n     }\n \n-    LOG.info(FS_DEFAULT_NAME_KEY + \" is \" + nnAddr);\n+    LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n     URI nnUri \u003d URI.create(nnAddr);\n \n     String nnHost \u003d nnUri.getHost();\n     if (nnHost \u003d\u003d null) {\n       clientNamenodeAddress \u003d null;\n       return;\n     }\n \n     if (DFSUtil.getNameServiceIds(conf).contains(nnHost)) {\n       // host name is logical\n       clientNamenodeAddress \u003d nnHost;\n     } else if (nnUri.getPort() \u003e 0) {\n       // physical address with a valid port\n       clientNamenodeAddress \u003d nnUri.getAuthority();\n     } else {\n       // the port is missing or 0. Figure out real bind address later.\n       clientNamenodeAddress \u003d null;\n       return;\n     }\n-    LOG.info(\"Clients are to use \" + clientNamenodeAddress + \" to access\"\n-        + \" this namenode/service.\");\n+    LOG.info(\"Clients are to use {} to access\"\n+        + \" this namenode/service.\", clientNamenodeAddress );\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setClientNamenodeAddress(Configuration conf) {\n    String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n    if (nnAddr \u003d\u003d null) {\n      // default fs is not set.\n      clientNamenodeAddress \u003d null;\n      return;\n    }\n\n    LOG.info(\"{} is {}\", FS_DEFAULT_NAME_KEY, nnAddr);\n    URI nnUri \u003d URI.create(nnAddr);\n\n    String nnHost \u003d nnUri.getHost();\n    if (nnHost \u003d\u003d null) {\n      clientNamenodeAddress \u003d null;\n      return;\n    }\n\n    if (DFSUtil.getNameServiceIds(conf).contains(nnHost)) {\n      // host name is logical\n      clientNamenodeAddress \u003d nnHost;\n    } else if (nnUri.getPort() \u003e 0) {\n      // physical address with a valid port\n      clientNamenodeAddress \u003d nnUri.getAuthority();\n    } else {\n      // the port is missing or 0. Figure out real bind address later.\n      clientNamenodeAddress \u003d null;\n      return;\n    }\n    LOG.info(\"Clients are to use {} to access\"\n        + \" this namenode/service.\", clientNamenodeAddress );\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java",
      "extendedDetails": {}
    },
    "eac832f92da084f1fa2b281331db32e01ab05604": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-6329. WebHdfs does not work if HA is enabled on NN but logical URI is not configured. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593470 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/14 6:46 PM",
      "commitName": "eac832f92da084f1fa2b281331db32e01ab05604",
      "commitAuthor": "Kihwal Lee",
      "diff": "@@ -0,0 +1,31 @@\n+  public void setClientNamenodeAddress(Configuration conf) {\n+    String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n+    if (nnAddr \u003d\u003d null) {\n+      // default fs is not set.\n+      clientNamenodeAddress \u003d null;\n+      return;\n+    }\n+\n+    LOG.info(FS_DEFAULT_NAME_KEY + \" is \" + nnAddr);\n+    URI nnUri \u003d URI.create(nnAddr);\n+\n+    String nnHost \u003d nnUri.getHost();\n+    if (nnHost \u003d\u003d null) {\n+      clientNamenodeAddress \u003d null;\n+      return;\n+    }\n+\n+    if (DFSUtil.getNameServiceIds(conf).contains(nnHost)) {\n+      // host name is logical\n+      clientNamenodeAddress \u003d nnHost;\n+    } else if (nnUri.getPort() \u003e 0) {\n+      // physical address with a valid port\n+      clientNamenodeAddress \u003d nnUri.getAuthority();\n+    } else {\n+      // the port is missing or 0. Figure out real bind address later.\n+      clientNamenodeAddress \u003d null;\n+      return;\n+    }\n+    LOG.info(\"Clients are to use \" + clientNamenodeAddress + \" to access\"\n+        + \" this namenode/service.\");\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void setClientNamenodeAddress(Configuration conf) {\n    String nnAddr \u003d conf.get(FS_DEFAULT_NAME_KEY);\n    if (nnAddr \u003d\u003d null) {\n      // default fs is not set.\n      clientNamenodeAddress \u003d null;\n      return;\n    }\n\n    LOG.info(FS_DEFAULT_NAME_KEY + \" is \" + nnAddr);\n    URI nnUri \u003d URI.create(nnAddr);\n\n    String nnHost \u003d nnUri.getHost();\n    if (nnHost \u003d\u003d null) {\n      clientNamenodeAddress \u003d null;\n      return;\n    }\n\n    if (DFSUtil.getNameServiceIds(conf).contains(nnHost)) {\n      // host name is logical\n      clientNamenodeAddress \u003d nnHost;\n    } else if (nnUri.getPort() \u003e 0) {\n      // physical address with a valid port\n      clientNamenodeAddress \u003d nnUri.getAuthority();\n    } else {\n      // the port is missing or 0. Figure out real bind address later.\n      clientNamenodeAddress \u003d null;\n      return;\n    }\n    LOG.info(\"Clients are to use \" + clientNamenodeAddress + \" to access\"\n        + \" this namenode/service.\");\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNode.java"
    }
  }
}