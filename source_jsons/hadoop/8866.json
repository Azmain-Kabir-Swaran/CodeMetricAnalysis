{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NameNodeHttpServer.java",
  "functionName": "start",
  "functionId": "start",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
  "functionStartLine": 117,
  "functionEndLine": 184,
  "numCommitsSeen": 65,
  "timeTaken": 5695,
  "changeHistory": [
    "f0ce072934515d39e9bf61744058ecad3393291e",
    "6e31a090842f8aeedb331b653b075499f8df6c60",
    "c447efebdb92dcdf3d95e983036f53bfbed2c0b4",
    "46b6d23e8fbed4c2ba537dd752116c173805bca7",
    "cf4bc7fdd49974324b177c99b820587cc5854adb",
    "a5b37c6ed14e92f5a7f7dd76a9a82b3f859fb6dd",
    "33a47743a5f4263bc21b345587370c5ecf43f5b4",
    "87a6db45b70a1a07165e0773c4452d1327258bfa",
    "d02baff9a0d8cec92bde751777f3e575da2339c8",
    "2214871d916fdcae62aa51afbb5fd571f2808745",
    "fef8f49c5885ba05dcd73e8a02de7c2be5ec3f0e",
    "09998741ac3b425d95a6ba47865414b629ef1252",
    "b2e174c9a502197180584c01db7029a3606efe56",
    "782191f1ba27e0ff0acf3c6cf8a88df00274d308",
    "7e2aba0ab594f6939b47704f1087405c3d1c089b",
    "da8e962e39bd41b73b53966826c82e741b08010b",
    "301079b4bfa1853f48ec0d118f2dd48f96d5d41b",
    "a82e67af6c748a1c33528338c560f130e5b28c28",
    "6582da034b9dff252e5b458890b0f0c7d2f81746",
    "7dee7f11f6709990a7a18bbbabdeb929ffde6b76",
    "c76a7893f9215d25fca18f4444157db2addf720e",
    "5770a453f304d83463879db6101da1f1e81e5563",
    "5ef725eb5369215fbca5d8067da6ec4255cc98db",
    "5dbbe0e0a5d31689d3425e490865f95057dc051c",
    "e505b7e704ff83893a40190695977ce1393f6248",
    "0398a9e88dacf81068f2786f28a9127e02b203d7",
    "52937609733fb25bc19c9bd6df2e1ca544973860",
    "8534e70044ebd35c80a2bdff509adef85cb8d61c",
    "8335995630e2c4288795fa0dfa9b670090a6790b",
    "6f1d18bd478c4963543f8b8d80aefcb5adb38774",
    "78e3821b819b441d1faf4bc66c659cdeddc6006c",
    "cde0e484e7ee99583e6c0b4dd016724f910bd9a7",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "01cd616d170d5d26a539e51e731e8e73b789b360"
  ],
  "changeHistoryShort": {
    "f0ce072934515d39e9bf61744058ecad3393291e": "Ybodychange",
    "6e31a090842f8aeedb331b653b075499f8df6c60": "Ybodychange",
    "c447efebdb92dcdf3d95e983036f53bfbed2c0b4": "Ybodychange",
    "46b6d23e8fbed4c2ba537dd752116c173805bca7": "Ybodychange",
    "cf4bc7fdd49974324b177c99b820587cc5854adb": "Ybodychange",
    "a5b37c6ed14e92f5a7f7dd76a9a82b3f859fb6dd": "Ybodychange",
    "33a47743a5f4263bc21b345587370c5ecf43f5b4": "Ybodychange",
    "87a6db45b70a1a07165e0773c4452d1327258bfa": "Ybodychange",
    "d02baff9a0d8cec92bde751777f3e575da2339c8": "Ybodychange",
    "2214871d916fdcae62aa51afbb5fd571f2808745": "Ymultichange(Ymodifierchange,Ybodychange)",
    "fef8f49c5885ba05dcd73e8a02de7c2be5ec3f0e": "Ybodychange",
    "09998741ac3b425d95a6ba47865414b629ef1252": "Ybodychange",
    "b2e174c9a502197180584c01db7029a3606efe56": "Ybodychange",
    "782191f1ba27e0ff0acf3c6cf8a88df00274d308": "Ybodychange",
    "7e2aba0ab594f6939b47704f1087405c3d1c089b": "Ybodychange",
    "da8e962e39bd41b73b53966826c82e741b08010b": "Ybodychange",
    "301079b4bfa1853f48ec0d118f2dd48f96d5d41b": "Ybodychange",
    "a82e67af6c748a1c33528338c560f130e5b28c28": "Ybodychange",
    "6582da034b9dff252e5b458890b0f0c7d2f81746": "Ybodychange",
    "7dee7f11f6709990a7a18bbbabdeb929ffde6b76": "Ybodychange",
    "c76a7893f9215d25fca18f4444157db2addf720e": "Ybodychange",
    "5770a453f304d83463879db6101da1f1e81e5563": "Ybodychange",
    "5ef725eb5369215fbca5d8067da6ec4255cc98db": "Ybodychange",
    "5dbbe0e0a5d31689d3425e490865f95057dc051c": "Ybodychange",
    "e505b7e704ff83893a40190695977ce1393f6248": "Ybodychange",
    "0398a9e88dacf81068f2786f28a9127e02b203d7": "Ybodychange",
    "52937609733fb25bc19c9bd6df2e1ca544973860": "Ybodychange",
    "8534e70044ebd35c80a2bdff509adef85cb8d61c": "Ybodychange",
    "8335995630e2c4288795fa0dfa9b670090a6790b": "Ybodychange",
    "6f1d18bd478c4963543f8b8d80aefcb5adb38774": "Ybodychange",
    "78e3821b819b441d1faf4bc66c659cdeddc6006c": "Ybodychange",
    "cde0e484e7ee99583e6c0b4dd016724f910bd9a7": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "01cd616d170d5d26a539e51e731e8e73b789b360": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f0ce072934515d39e9bf61744058ecad3393291e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14051. Refactor NameNodeHttpServer#initWebHdfs to specify local keytab. Contributed by CR Hota.\n",
      "commitDate": "06/11/18 10:05 AM",
      "commitName": "f0ce072934515d39e9bf61744058ecad3393291e",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "05/09/18 10:50 AM",
      "commitNameOld": "9af96d4ed4b6f80d3ca53a2b003d2ef768650dd4",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 62.01,
      "commitsBetweenForRepo": 624,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,68 @@\n   void start() throws IOException {\n     HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n     final String infoHost \u003d bindAddress.getHostName();\n \n     final InetSocketAddress httpAddr \u003d bindAddress;\n     final String httpsAddrString \u003d conf.getTrimmed(\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n     InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n \n     if (httpsAddr !\u003d null) {\n       // If DFS_NAMENODE_HTTPS_BIND_HOST_KEY exists then it overrides the\n       // host name portion of DFS_NAMENODE_HTTPS_ADDRESS_KEY.\n       final String bindHost \u003d\n           conf.getTrimmed(DFSConfigKeys.DFS_NAMENODE_HTTPS_BIND_HOST_KEY);\n       if (bindHost !\u003d null \u0026\u0026 !bindHost.isEmpty()) {\n         httpsAddr \u003d new InetSocketAddress(bindHost, httpsAddr.getPort());\n       }\n     }\n \n     HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n         httpAddr, httpsAddr, \"hdfs\",\n         DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,\n         DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n \n     final boolean xFrameEnabled \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_XFRAME_OPTION_ENABLED,\n         DFSConfigKeys.DFS_XFRAME_OPTION_ENABLED_DEFAULT);\n \n     final String xFrameOptionValue \u003d conf.getTrimmed(\n         DFSConfigKeys.DFS_XFRAME_OPTION_VALUE,\n         DFSConfigKeys.DFS_XFRAME_OPTION_VALUE_DEFAULT);\n \n     builder.configureXFrame(xFrameEnabled).setXFrameOption(xFrameOptionValue);\n \n     httpServer \u003d builder.build();\n \n     if (policy.isHttpsEnabled()) {\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.getTrimmed(\n           DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n               + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n           datanodeSslPort.getPort());\n     }\n-\n-    initWebHdfs(conf, bindAddress.getHostName(), httpServer,\n+    String httpKeytab \u003d conf.get(DFSUtil.getSpnegoKeytabKey(conf,\n+        DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n+    initWebHdfs(conf, bindAddress.getHostName(), httpKeytab, httpServer,\n         NamenodeWebHdfsMethods.class.getPackage().getName());\n \n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n \n     int connIdx \u003d 0;\n     if (policy.isHttpEnabled()) {\n       httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpAddress));\n     }\n \n     if (policy.isHttpsEnabled()) {\n       httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpsAddress));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void start() throws IOException {\n    HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n    final String infoHost \u003d bindAddress.getHostName();\n\n    final InetSocketAddress httpAddr \u003d bindAddress;\n    final String httpsAddrString \u003d conf.getTrimmed(\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n    InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n\n    if (httpsAddr !\u003d null) {\n      // If DFS_NAMENODE_HTTPS_BIND_HOST_KEY exists then it overrides the\n      // host name portion of DFS_NAMENODE_HTTPS_ADDRESS_KEY.\n      final String bindHost \u003d\n          conf.getTrimmed(DFSConfigKeys.DFS_NAMENODE_HTTPS_BIND_HOST_KEY);\n      if (bindHost !\u003d null \u0026\u0026 !bindHost.isEmpty()) {\n        httpsAddr \u003d new InetSocketAddress(bindHost, httpsAddr.getPort());\n      }\n    }\n\n    HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n        httpAddr, httpsAddr, \"hdfs\",\n        DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,\n        DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n\n    final boolean xFrameEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_XFRAME_OPTION_ENABLED,\n        DFSConfigKeys.DFS_XFRAME_OPTION_ENABLED_DEFAULT);\n\n    final String xFrameOptionValue \u003d conf.getTrimmed(\n        DFSConfigKeys.DFS_XFRAME_OPTION_VALUE,\n        DFSConfigKeys.DFS_XFRAME_OPTION_VALUE_DEFAULT);\n\n    builder.configureXFrame(xFrameEnabled).setXFrameOption(xFrameOptionValue);\n\n    httpServer \u003d builder.build();\n\n    if (policy.isHttpsEnabled()) {\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.getTrimmed(\n          DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n              + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n          datanodeSslPort.getPort());\n    }\n    String httpKeytab \u003d conf.get(DFSUtil.getSpnegoKeytabKey(conf,\n        DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n    initWebHdfs(conf, bindAddress.getHostName(), httpKeytab, httpServer,\n        NamenodeWebHdfsMethods.class.getPackage().getName());\n\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n\n    int connIdx \u003d 0;\n    if (policy.isHttpEnabled()) {\n      httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpAddress));\n    }\n\n    if (policy.isHttpsEnabled()) {\n      httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpsAddress));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "6e31a090842f8aeedb331b653b075499f8df6c60": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12512. RBF: Add WebHDFS.\n",
      "commitDate": "23/03/18 8:32 AM",
      "commitName": "6e31a090842f8aeedb331b653b075499f8df6c60",
      "commitAuthor": "weiy",
      "commitDateOld": "24/02/17 4:49 PM",
      "commitNameOld": "e24ed47d9a19f34a4dd8d4bad9b5c78ca3dd1c2e",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 391.61,
      "commitsBetweenForRepo": 2732,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,67 @@\n   void start() throws IOException {\n     HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n     final String infoHost \u003d bindAddress.getHostName();\n \n     final InetSocketAddress httpAddr \u003d bindAddress;\n     final String httpsAddrString \u003d conf.getTrimmed(\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n     InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n \n     if (httpsAddr !\u003d null) {\n       // If DFS_NAMENODE_HTTPS_BIND_HOST_KEY exists then it overrides the\n       // host name portion of DFS_NAMENODE_HTTPS_ADDRESS_KEY.\n       final String bindHost \u003d\n           conf.getTrimmed(DFSConfigKeys.DFS_NAMENODE_HTTPS_BIND_HOST_KEY);\n       if (bindHost !\u003d null \u0026\u0026 !bindHost.isEmpty()) {\n         httpsAddr \u003d new InetSocketAddress(bindHost, httpsAddr.getPort());\n       }\n     }\n \n     HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n         httpAddr, httpsAddr, \"hdfs\",\n         DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,\n         DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n \n     final boolean xFrameEnabled \u003d conf.getBoolean(\n         DFSConfigKeys.DFS_XFRAME_OPTION_ENABLED,\n         DFSConfigKeys.DFS_XFRAME_OPTION_ENABLED_DEFAULT);\n \n     final String xFrameOptionValue \u003d conf.getTrimmed(\n         DFSConfigKeys.DFS_XFRAME_OPTION_VALUE,\n         DFSConfigKeys.DFS_XFRAME_OPTION_VALUE_DEFAULT);\n \n     builder.configureXFrame(xFrameEnabled).setXFrameOption(xFrameOptionValue);\n \n     httpServer \u003d builder.build();\n \n     if (policy.isHttpsEnabled()) {\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.getTrimmed(\n           DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n               + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n           datanodeSslPort.getPort());\n     }\n \n-    initWebHdfs(conf);\n+    initWebHdfs(conf, bindAddress.getHostName(), httpServer,\n+        NamenodeWebHdfsMethods.class.getPackage().getName());\n \n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n \n     int connIdx \u003d 0;\n     if (policy.isHttpEnabled()) {\n       httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpAddress));\n     }\n \n     if (policy.isHttpsEnabled()) {\n       httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpsAddress));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void start() throws IOException {\n    HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n    final String infoHost \u003d bindAddress.getHostName();\n\n    final InetSocketAddress httpAddr \u003d bindAddress;\n    final String httpsAddrString \u003d conf.getTrimmed(\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n    InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n\n    if (httpsAddr !\u003d null) {\n      // If DFS_NAMENODE_HTTPS_BIND_HOST_KEY exists then it overrides the\n      // host name portion of DFS_NAMENODE_HTTPS_ADDRESS_KEY.\n      final String bindHost \u003d\n          conf.getTrimmed(DFSConfigKeys.DFS_NAMENODE_HTTPS_BIND_HOST_KEY);\n      if (bindHost !\u003d null \u0026\u0026 !bindHost.isEmpty()) {\n        httpsAddr \u003d new InetSocketAddress(bindHost, httpsAddr.getPort());\n      }\n    }\n\n    HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n        httpAddr, httpsAddr, \"hdfs\",\n        DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,\n        DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n\n    final boolean xFrameEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_XFRAME_OPTION_ENABLED,\n        DFSConfigKeys.DFS_XFRAME_OPTION_ENABLED_DEFAULT);\n\n    final String xFrameOptionValue \u003d conf.getTrimmed(\n        DFSConfigKeys.DFS_XFRAME_OPTION_VALUE,\n        DFSConfigKeys.DFS_XFRAME_OPTION_VALUE_DEFAULT);\n\n    builder.configureXFrame(xFrameEnabled).setXFrameOption(xFrameOptionValue);\n\n    httpServer \u003d builder.build();\n\n    if (policy.isHttpsEnabled()) {\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.getTrimmed(\n          DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n              + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n          datanodeSslPort.getPort());\n    }\n\n    initWebHdfs(conf, bindAddress.getHostName(), httpServer,\n        NamenodeWebHdfsMethods.class.getPackage().getName());\n\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n\n    int connIdx \u003d 0;\n    if (policy.isHttpEnabled()) {\n      httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpAddress));\n    }\n\n    if (policy.isHttpsEnabled()) {\n      httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpsAddress));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "c447efebdb92dcdf3d95e983036f53bfbed2c0b4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10579. HDFS web interfaces lack configs for X-FRAME-OPTIONS protection. Contributed by Anu Engineer.\n",
      "commitDate": "11/07/16 2:55 PM",
      "commitName": "c447efebdb92dcdf3d95e983036f53bfbed2c0b4",
      "commitAuthor": "Jitendra Pandey",
      "commitDateOld": "18/02/16 10:07 AM",
      "commitNameOld": "5d1889a66d91608d34ca9411fb6e9161e637e9d3",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 144.16,
      "commitsBetweenForRepo": 1041,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,66 @@\n   void start() throws IOException {\n     HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n     final String infoHost \u003d bindAddress.getHostName();\n \n     final InetSocketAddress httpAddr \u003d bindAddress;\n     final String httpsAddrString \u003d conf.getTrimmed(\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n     InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n \n     if (httpsAddr !\u003d null) {\n       // If DFS_NAMENODE_HTTPS_BIND_HOST_KEY exists then it overrides the\n       // host name portion of DFS_NAMENODE_HTTPS_ADDRESS_KEY.\n       final String bindHost \u003d\n           conf.getTrimmed(DFSConfigKeys.DFS_NAMENODE_HTTPS_BIND_HOST_KEY);\n       if (bindHost !\u003d null \u0026\u0026 !bindHost.isEmpty()) {\n         httpsAddr \u003d new InetSocketAddress(bindHost, httpsAddr.getPort());\n       }\n     }\n \n     HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n         httpAddr, httpsAddr, \"hdfs\",\n         DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,\n         DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n \n+    final boolean xFrameEnabled \u003d conf.getBoolean(\n+        DFSConfigKeys.DFS_XFRAME_OPTION_ENABLED,\n+        DFSConfigKeys.DFS_XFRAME_OPTION_ENABLED_DEFAULT);\n+\n+    final String xFrameOptionValue \u003d conf.getTrimmed(\n+        DFSConfigKeys.DFS_XFRAME_OPTION_VALUE,\n+        DFSConfigKeys.DFS_XFRAME_OPTION_VALUE_DEFAULT);\n+\n+    builder.configureXFrame(xFrameEnabled).setXFrameOption(xFrameOptionValue);\n+\n     httpServer \u003d builder.build();\n \n     if (policy.isHttpsEnabled()) {\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.getTrimmed(\n           DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n               + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n           datanodeSslPort.getPort());\n     }\n \n     initWebHdfs(conf);\n \n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n \n     int connIdx \u003d 0;\n     if (policy.isHttpEnabled()) {\n       httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpAddress));\n     }\n \n     if (policy.isHttpsEnabled()) {\n       httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpsAddress));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void start() throws IOException {\n    HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n    final String infoHost \u003d bindAddress.getHostName();\n\n    final InetSocketAddress httpAddr \u003d bindAddress;\n    final String httpsAddrString \u003d conf.getTrimmed(\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n    InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n\n    if (httpsAddr !\u003d null) {\n      // If DFS_NAMENODE_HTTPS_BIND_HOST_KEY exists then it overrides the\n      // host name portion of DFS_NAMENODE_HTTPS_ADDRESS_KEY.\n      final String bindHost \u003d\n          conf.getTrimmed(DFSConfigKeys.DFS_NAMENODE_HTTPS_BIND_HOST_KEY);\n      if (bindHost !\u003d null \u0026\u0026 !bindHost.isEmpty()) {\n        httpsAddr \u003d new InetSocketAddress(bindHost, httpsAddr.getPort());\n      }\n    }\n\n    HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n        httpAddr, httpsAddr, \"hdfs\",\n        DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,\n        DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n\n    final boolean xFrameEnabled \u003d conf.getBoolean(\n        DFSConfigKeys.DFS_XFRAME_OPTION_ENABLED,\n        DFSConfigKeys.DFS_XFRAME_OPTION_ENABLED_DEFAULT);\n\n    final String xFrameOptionValue \u003d conf.getTrimmed(\n        DFSConfigKeys.DFS_XFRAME_OPTION_VALUE,\n        DFSConfigKeys.DFS_XFRAME_OPTION_VALUE_DEFAULT);\n\n    builder.configureXFrame(xFrameEnabled).setXFrameOption(xFrameOptionValue);\n\n    httpServer \u003d builder.build();\n\n    if (policy.isHttpsEnabled()) {\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.getTrimmed(\n          DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n              + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n          datanodeSslPort.getPort());\n    }\n\n    initWebHdfs(conf);\n\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n\n    int connIdx \u003d 0;\n    if (policy.isHttpEnabled()) {\n      httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpAddress));\n    }\n\n    if (policy.isHttpsEnabled()) {\n      httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpsAddress));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "46b6d23e8fbed4c2ba537dd752116c173805bca7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7684. The host:port settings of the deamons should be trimmed before use. Contributed by Anu Engineer.\n",
      "commitDate": "12/02/15 5:40 PM",
      "commitName": "46b6d23e8fbed4c2ba537dd752116c173805bca7",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "24/04/14 10:40 AM",
      "commitNameOld": "cf4bc7fdd49974324b177c99b820587cc5854adb",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 294.33,
      "commitsBetweenForRepo": 2375,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,56 @@\n   void start() throws IOException {\n     HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n     final String infoHost \u003d bindAddress.getHostName();\n \n     final InetSocketAddress httpAddr \u003d bindAddress;\n-    final String httpsAddrString \u003d conf.get(\n+    final String httpsAddrString \u003d conf.getTrimmed(\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n     InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n \n     if (httpsAddr !\u003d null) {\n       // If DFS_NAMENODE_HTTPS_BIND_HOST_KEY exists then it overrides the\n       // host name portion of DFS_NAMENODE_HTTPS_ADDRESS_KEY.\n       final String bindHost \u003d\n           conf.getTrimmed(DFSConfigKeys.DFS_NAMENODE_HTTPS_BIND_HOST_KEY);\n       if (bindHost !\u003d null \u0026\u0026 !bindHost.isEmpty()) {\n         httpsAddr \u003d new InetSocketAddress(bindHost, httpsAddr.getPort());\n       }\n     }\n \n     HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n         httpAddr, httpsAddr, \"hdfs\",\n         DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,\n         DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n \n     httpServer \u003d builder.build();\n \n     if (policy.isHttpsEnabled()) {\n       // assume same ssl port for all datanodes\n-      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n+      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.getTrimmed(\n           DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n               + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n           datanodeSslPort.getPort());\n     }\n \n     initWebHdfs(conf);\n \n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n \n     int connIdx \u003d 0;\n     if (policy.isHttpEnabled()) {\n       httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpAddress));\n     }\n \n     if (policy.isHttpsEnabled()) {\n       httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpsAddress));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void start() throws IOException {\n    HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n    final String infoHost \u003d bindAddress.getHostName();\n\n    final InetSocketAddress httpAddr \u003d bindAddress;\n    final String httpsAddrString \u003d conf.getTrimmed(\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n    InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n\n    if (httpsAddr !\u003d null) {\n      // If DFS_NAMENODE_HTTPS_BIND_HOST_KEY exists then it overrides the\n      // host name portion of DFS_NAMENODE_HTTPS_ADDRESS_KEY.\n      final String bindHost \u003d\n          conf.getTrimmed(DFSConfigKeys.DFS_NAMENODE_HTTPS_BIND_HOST_KEY);\n      if (bindHost !\u003d null \u0026\u0026 !bindHost.isEmpty()) {\n        httpsAddr \u003d new InetSocketAddress(bindHost, httpsAddr.getPort());\n      }\n    }\n\n    HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n        httpAddr, httpsAddr, \"hdfs\",\n        DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,\n        DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n\n    httpServer \u003d builder.build();\n\n    if (policy.isHttpsEnabled()) {\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.getTrimmed(\n          DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n              + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n          datanodeSslPort.getPort());\n    }\n\n    initWebHdfs(conf);\n\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n\n    int connIdx \u003d 0;\n    if (policy.isHttpEnabled()) {\n      httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpAddress));\n    }\n\n    if (policy.isHttpsEnabled()) {\n      httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpsAddress));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "cf4bc7fdd49974324b177c99b820587cc5854adb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6273. Config options to allow wildcard endpoints for namenode HTTP and HTTPS servers. (Contributed by Arpit Agarwal)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1589803 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/04/14 10:40 AM",
      "commitName": "cf4bc7fdd49974324b177c99b820587cc5854adb",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "07/04/14 11:55 AM",
      "commitNameOld": "a5b37c6ed14e92f5a7f7dd76a9a82b3f859fb6dd",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 16.95,
      "commitsBetweenForRepo": 122,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,56 @@\n   void start() throws IOException {\n     HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n     final String infoHost \u003d bindAddress.getHostName();\n \n     final InetSocketAddress httpAddr \u003d bindAddress;\n     final String httpsAddrString \u003d conf.get(\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n     InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n \n+    if (httpsAddr !\u003d null) {\n+      // If DFS_NAMENODE_HTTPS_BIND_HOST_KEY exists then it overrides the\n+      // host name portion of DFS_NAMENODE_HTTPS_ADDRESS_KEY.\n+      final String bindHost \u003d\n+          conf.getTrimmed(DFSConfigKeys.DFS_NAMENODE_HTTPS_BIND_HOST_KEY);\n+      if (bindHost !\u003d null \u0026\u0026 !bindHost.isEmpty()) {\n+        httpsAddr \u003d new InetSocketAddress(bindHost, httpsAddr.getPort());\n+      }\n+    }\n+\n     HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n         httpAddr, httpsAddr, \"hdfs\",\n         DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,\n         DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n \n     httpServer \u003d builder.build();\n \n     if (policy.isHttpsEnabled()) {\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n           DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n               + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n           datanodeSslPort.getPort());\n     }\n \n     initWebHdfs(conf);\n \n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n \n     int connIdx \u003d 0;\n     if (policy.isHttpEnabled()) {\n       httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpAddress));\n     }\n \n     if (policy.isHttpsEnabled()) {\n       httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpsAddress));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void start() throws IOException {\n    HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n    final String infoHost \u003d bindAddress.getHostName();\n\n    final InetSocketAddress httpAddr \u003d bindAddress;\n    final String httpsAddrString \u003d conf.get(\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n    InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n\n    if (httpsAddr !\u003d null) {\n      // If DFS_NAMENODE_HTTPS_BIND_HOST_KEY exists then it overrides the\n      // host name portion of DFS_NAMENODE_HTTPS_ADDRESS_KEY.\n      final String bindHost \u003d\n          conf.getTrimmed(DFSConfigKeys.DFS_NAMENODE_HTTPS_BIND_HOST_KEY);\n      if (bindHost !\u003d null \u0026\u0026 !bindHost.isEmpty()) {\n        httpsAddr \u003d new InetSocketAddress(bindHost, httpsAddr.getPort());\n      }\n    }\n\n    HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n        httpAddr, httpsAddr, \"hdfs\",\n        DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,\n        DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n\n    httpServer \u003d builder.build();\n\n    if (policy.isHttpsEnabled()) {\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n          DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n              + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n          datanodeSslPort.getPort());\n    }\n\n    initWebHdfs(conf);\n\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n\n    int connIdx \u003d 0;\n    if (policy.isHttpEnabled()) {\n      httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpAddress));\n    }\n\n    if (policy.isHttpsEnabled()) {\n      httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpsAddress));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "a5b37c6ed14e92f5a7f7dd76a9a82b3f859fb6dd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6181. Fix the wrong property names in NFS user guide. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1585563 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/04/14 11:55 AM",
      "commitName": "a5b37c6ed14e92f5a7f7dd76a9a82b3f859fb6dd",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "02/04/14 10:28 AM",
      "commitNameOld": "fb1d7fb596b8e8bb9a5f141c89acb1949bade87a",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 5.06,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   void start() throws IOException {\n     HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n     final String infoHost \u003d bindAddress.getHostName();\n \n     final InetSocketAddress httpAddr \u003d bindAddress;\n     final String httpsAddrString \u003d conf.get(\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n     InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n \n     HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n         httpAddr, httpsAddr, \"hdfs\",\n-        DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n+        DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,\n         DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n \n     httpServer \u003d builder.build();\n \n     if (policy.isHttpsEnabled()) {\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n           DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n               + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n           datanodeSslPort.getPort());\n     }\n \n     initWebHdfs(conf);\n \n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n \n     int connIdx \u003d 0;\n     if (policy.isHttpEnabled()) {\n       httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpAddress));\n     }\n \n     if (policy.isHttpsEnabled()) {\n       httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpsAddress));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void start() throws IOException {\n    HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n    final String infoHost \u003d bindAddress.getHostName();\n\n    final InetSocketAddress httpAddr \u003d bindAddress;\n    final String httpsAddrString \u003d conf.get(\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n    InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n\n    HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n        httpAddr, httpsAddr, \"hdfs\",\n        DFSConfigKeys.DFS_NAMENODE_KERBEROS_INTERNAL_SPNEGO_PRINCIPAL_KEY,\n        DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n\n    httpServer \u003d builder.build();\n\n    if (policy.isHttpsEnabled()) {\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n          DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n              + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n          datanodeSslPort.getPort());\n    }\n\n    initWebHdfs(conf);\n\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n\n    int connIdx \u003d 0;\n    if (policy.isHttpEnabled()) {\n      httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpAddress));\n    }\n\n    if (policy.isHttpsEnabled()) {\n      httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpsAddress));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "33a47743a5f4263bc21b345587370c5ecf43f5b4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10255. Rename HttpServer to HttpServer2 to retain older HttpServer in branch-2 for compatibility. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561959 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/01/14 11:32 PM",
      "commitName": "33a47743a5f4263bc21b345587370c5ecf43f5b4",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "09/12/13 1:58 PM",
      "commitNameOld": "87a6db45b70a1a07165e0773c4452d1327258bfa",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 49.4,
      "commitsBetweenForRepo": 238,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,46 @@\n   void start() throws IOException {\n     HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n     final String infoHost \u003d bindAddress.getHostName();\n \n     final InetSocketAddress httpAddr \u003d bindAddress;\n     final String httpsAddrString \u003d conf.get(\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n     InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n \n-    HttpServer.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n+    HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n         httpAddr, httpsAddr, \"hdfs\",\n         DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n         DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n \n     httpServer \u003d builder.build();\n \n     if (policy.isHttpsEnabled()) {\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n           DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n               + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n           datanodeSslPort.getPort());\n     }\n \n     initWebHdfs(conf);\n \n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n \n     int connIdx \u003d 0;\n     if (policy.isHttpEnabled()) {\n       httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpAddress));\n     }\n \n     if (policy.isHttpsEnabled()) {\n       httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpsAddress));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void start() throws IOException {\n    HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n    final String infoHost \u003d bindAddress.getHostName();\n\n    final InetSocketAddress httpAddr \u003d bindAddress;\n    final String httpsAddrString \u003d conf.get(\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n    InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n\n    HttpServer2.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n        httpAddr, httpsAddr, \"hdfs\",\n        DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n        DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n\n    httpServer \u003d builder.build();\n\n    if (policy.isHttpsEnabled()) {\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n          DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n              + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n          datanodeSslPort.getPort());\n    }\n\n    initWebHdfs(conf);\n\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n\n    int connIdx \u003d 0;\n    if (policy.isHttpEnabled()) {\n      httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpAddress));\n    }\n\n    if (policy.isHttpsEnabled()) {\n      httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpsAddress));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "87a6db45b70a1a07165e0773c4452d1327258bfa": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5629. Support HTTPS in JournalNode and SecondaryNameNode. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1549692 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/12/13 1:58 PM",
      "commitName": "87a6db45b70a1a07165e0773c4452d1327258bfa",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "07/12/13 1:10 PM",
      "commitNameOld": "91d0b4727066241c900037f9a10e28b143489172",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 2.03,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,46 @@\n   void start() throws IOException {\n     HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n     final String infoHost \u003d bindAddress.getHostName();\n \n-    HttpServer.Builder builder \u003d new HttpServer.Builder()\n-        .setName(\"hdfs\")\n-        .setConf(conf)\n-        .setACL(new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n-        .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n-        .setUsernameConfKey(\n-            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n-        .setKeytabConfKey(\n-            DFSUtil.getSpnegoKeytabKey(conf,\n-                DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n+    final InetSocketAddress httpAddr \u003d bindAddress;\n+    final String httpsAddrString \u003d conf.get(\n+        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n+        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n+    InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n \n-    if (policy.isHttpEnabled()) {\n-      int port \u003d bindAddress.getPort();\n-      if (port \u003d\u003d 0) {\n-        builder.setFindPort(true);\n-      }\n-      builder.addEndpoint(URI.create(\"http://\" + infoHost + \":\" + port));\n-    }\n-\n-    if (policy.isHttpsEnabled()) {\n-      final String httpsAddrString \u003d conf.get(\n-          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n-          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n-      InetSocketAddress addr \u003d NetUtils.createSocketAddr(httpsAddrString);\n-\n-      Configuration sslConf \u003d new Configuration(false);\n-\n-      sslConf.addResource(conf.get(\n-          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n-          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n-\n-      sslConf.addResource(conf.get(\n-          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n-          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n-      sslConf.setBoolean(DFS_CLIENT_HTTPS_NEED_AUTH_KEY, conf.getBoolean(\n-          DFS_CLIENT_HTTPS_NEED_AUTH_KEY, DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT));\n-      DFSUtil.loadSslConfToHttpServerBuilder(builder, sslConf);\n-\n-      if (addr.getPort() \u003d\u003d 0) {\n-        builder.setFindPort(true);\n-      }\n-\n-      builder.addEndpoint(URI.create(\"https://\"\n-          + NetUtils.getHostPortString(addr)));\n-    }\n+    HttpServer.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n+        httpAddr, httpsAddr, \"hdfs\",\n+        DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n+        DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n \n     httpServer \u003d builder.build();\n \n     if (policy.isHttpsEnabled()) {\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n           DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n               + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n           datanodeSslPort.getPort());\n     }\n \n     initWebHdfs(conf);\n \n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n \n     int connIdx \u003d 0;\n     if (policy.isHttpEnabled()) {\n       httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpAddress));\n     }\n \n     if (policy.isHttpsEnabled()) {\n       httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n       conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n           NetUtils.getHostPortString(httpsAddress));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void start() throws IOException {\n    HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n    final String infoHost \u003d bindAddress.getHostName();\n\n    final InetSocketAddress httpAddr \u003d bindAddress;\n    final String httpsAddrString \u003d conf.get(\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n    InetSocketAddress httpsAddr \u003d NetUtils.createSocketAddr(httpsAddrString);\n\n    HttpServer.Builder builder \u003d DFSUtil.httpServerTemplateForNNAndJN(conf,\n        httpAddr, httpsAddr, \"hdfs\",\n        DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n        DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n\n    httpServer \u003d builder.build();\n\n    if (policy.isHttpsEnabled()) {\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n          DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n              + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n          datanodeSslPort.getPort());\n    }\n\n    initWebHdfs(conf);\n\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n\n    int connIdx \u003d 0;\n    if (policy.isHttpEnabled()) {\n      httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpAddress));\n    }\n\n    if (policy.isHttpsEnabled()) {\n      httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpsAddress));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "d02baff9a0d8cec92bde751777f3e575da2339c8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5536. Implement HTTP policy for Namenode and DataNode. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1547925 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/13 1:40 PM",
      "commitName": "d02baff9a0d8cec92bde751777f3e575da2339c8",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "27/11/13 10:20 AM",
      "commitNameOld": "2214871d916fdcae62aa51afbb5fd571f2808745",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 7.14,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,81 @@\n   void start() throws IOException {\n+    HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n     final String infoHost \u003d bindAddress.getHostName();\n-    int infoPort \u003d bindAddress.getPort();\n-    HttpServer.Builder builder \u003d new HttpServer.Builder().setName(\"hdfs\")\n-        .addEndpoint(URI.create((\"http://\" + NetUtils.getHostPortString(bindAddress))))\n-        .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n-            new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n+\n+    HttpServer.Builder builder \u003d new HttpServer.Builder()\n+        .setName(\"hdfs\")\n+        .setConf(conf)\n+        .setACL(new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n         .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n         .setUsernameConfKey(\n             DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n-        .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n-            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n+        .setKeytabConfKey(\n+            DFSUtil.getSpnegoKeytabKey(conf,\n+                DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n \n-    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n-    if (certSSL) {\n-      httpsAddress \u003d NetUtils.createSocketAddr(conf.get(\n+    if (policy.isHttpEnabled()) {\n+      int port \u003d bindAddress.getPort();\n+      if (port \u003d\u003d 0) {\n+        builder.setFindPort(true);\n+      }\n+      builder.addEndpoint(URI.create(\"http://\" + infoHost + \":\" + port));\n+    }\n+\n+    if (policy.isHttpsEnabled()) {\n+      final String httpsAddrString \u003d conf.get(\n           DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n-          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n+          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n+      InetSocketAddress addr \u003d NetUtils.createSocketAddr(httpsAddrString);\n \n-      builder.addEndpoint(URI.create(\"https://\"\n-          + NetUtils.getHostPortString(httpsAddress)));\n       Configuration sslConf \u003d new Configuration(false);\n-      sslConf.setBoolean(DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY, conf\n-          .getBoolean(DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n-              DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT));\n+\n       sslConf.addResource(conf.get(\n           DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n           DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n+\n+      sslConf.addResource(conf.get(\n+          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n+          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n+      sslConf.setBoolean(DFS_CLIENT_HTTPS_NEED_AUTH_KEY, conf.getBoolean(\n+          DFS_CLIENT_HTTPS_NEED_AUTH_KEY, DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT));\n       DFSUtil.loadSslConfToHttpServerBuilder(builder, sslConf);\n+\n+      if (addr.getPort() \u003d\u003d 0) {\n+        builder.setFindPort(true);\n+      }\n+\n+      builder.addEndpoint(URI.create(\"https://\"\n+          + NetUtils.getHostPortString(addr)));\n     }\n \n     httpServer \u003d builder.build();\n-    if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n-      //add SPNEGO authentication filter for webhdfs\n-      final String name \u003d \"SPNEGO\";\n-      final String classname \u003d AuthFilter.class.getName();\n-      final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n-      Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n-      HttpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n-          new String[]{pathSpec});\n-      HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n-      // add webhdfs packages\n-      httpServer.addJerseyResourcePackage(\n-          NamenodeWebHdfsMethods.class.getPackage().getName()\n-          + \";\" + Param.class.getPackage().getName(), pathSpec);\n-      }\n+    if (policy.isHttpsEnabled()) {\n+      // assume same ssl port for all datanodes\n+      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n+          DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n+              + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n+      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n+          datanodeSslPort.getPort());\n+    }\n+\n+    initWebHdfs(conf);\n \n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n-    httpAddress \u003d httpServer.getConnectorAddress(0);\n-    if (certSSL) {\n-      httpsAddress \u003d httpServer.getConnectorAddress(1);\n-      // assume same ssl port for all datanodes\n-      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n-        DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n-      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n-        .getPort());\n+\n+    int connIdx \u003d 0;\n+    if (policy.isHttpEnabled()) {\n+      httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n+      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n+          NetUtils.getHostPortString(httpAddress));\n+    }\n+\n+    if (policy.isHttpsEnabled()) {\n+      httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n+      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n+          NetUtils.getHostPortString(httpsAddress));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void start() throws IOException {\n    HttpConfig.Policy policy \u003d DFSUtil.getHttpPolicy(conf);\n    final String infoHost \u003d bindAddress.getHostName();\n\n    HttpServer.Builder builder \u003d new HttpServer.Builder()\n        .setName(\"hdfs\")\n        .setConf(conf)\n        .setACL(new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n        .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n        .setUsernameConfKey(\n            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n        .setKeytabConfKey(\n            DFSUtil.getSpnegoKeytabKey(conf,\n                DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n\n    if (policy.isHttpEnabled()) {\n      int port \u003d bindAddress.getPort();\n      if (port \u003d\u003d 0) {\n        builder.setFindPort(true);\n      }\n      builder.addEndpoint(URI.create(\"http://\" + infoHost + \":\" + port));\n    }\n\n    if (policy.isHttpsEnabled()) {\n      final String httpsAddrString \u003d conf.get(\n          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT);\n      InetSocketAddress addr \u003d NetUtils.createSocketAddr(httpsAddrString);\n\n      Configuration sslConf \u003d new Configuration(false);\n\n      sslConf.addResource(conf.get(\n          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n\n      sslConf.addResource(conf.get(\n          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n      sslConf.setBoolean(DFS_CLIENT_HTTPS_NEED_AUTH_KEY, conf.getBoolean(\n          DFS_CLIENT_HTTPS_NEED_AUTH_KEY, DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT));\n      DFSUtil.loadSslConfToHttpServerBuilder(builder, sslConf);\n\n      if (addr.getPort() \u003d\u003d 0) {\n        builder.setFindPort(true);\n      }\n\n      builder.addEndpoint(URI.create(\"https://\"\n          + NetUtils.getHostPortString(addr)));\n    }\n\n    httpServer \u003d builder.build();\n\n    if (policy.isHttpsEnabled()) {\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n          DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\"\n              + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n          datanodeSslPort.getPort());\n    }\n\n    initWebHdfs(conf);\n\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n\n    int connIdx \u003d 0;\n    if (policy.isHttpEnabled()) {\n      httpAddress \u003d httpServer.getConnectorAddress(connIdx++);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTP_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpAddress));\n    }\n\n    if (policy.isHttpsEnabled()) {\n      httpsAddress \u003d httpServer.getConnectorAddress(connIdx);\n      conf.set(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          NetUtils.getHostPortString(httpsAddress));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "2214871d916fdcae62aa51afbb5fd571f2808745": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-5545. Allow specifying endpoints for listeners in HttpServer. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546151 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/13 10:20 AM",
      "commitName": "2214871d916fdcae62aa51afbb5fd571f2808745",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-5545. Allow specifying endpoints for listeners in HttpServer. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546151 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/11/13 10:20 AM",
          "commitName": "2214871d916fdcae62aa51afbb5fd571f2808745",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "15/11/13 5:00 PM",
          "commitNameOld": "fef8f49c5885ba05dcd73e8a02de7c2be5ec3f0e",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 11.72,
          "commitsBetweenForRepo": 63,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,57 +1,62 @@\n-  public void start() throws IOException {\n+  void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n-    httpServer \u003d new HttpServer.Builder().setName(\"hdfs\")\n-        .setBindAddress(infoHost).setPort(infoPort)\n+    HttpServer.Builder builder \u003d new HttpServer.Builder().setName(\"hdfs\")\n+        .addEndpoint(URI.create((\"http://\" + NetUtils.getHostPortString(bindAddress))))\n         .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n             new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n         .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n         .setUsernameConfKey(\n             DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n         .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n-            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY)).build();\n+            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n+\n+    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n+    if (certSSL) {\n+      httpsAddress \u003d NetUtils.createSocketAddr(conf.get(\n+          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n+          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n+\n+      builder.addEndpoint(URI.create(\"https://\"\n+          + NetUtils.getHostPortString(httpsAddress)));\n+      Configuration sslConf \u003d new Configuration(false);\n+      sslConf.setBoolean(DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY, conf\n+          .getBoolean(DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n+              DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT));\n+      sslConf.addResource(conf.get(\n+          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n+          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n+      DFSUtil.loadSslConfToHttpServerBuilder(builder, sslConf);\n+    }\n+\n+    httpServer \u003d builder.build();\n     if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n       //add SPNEGO authentication filter for webhdfs\n       final String name \u003d \"SPNEGO\";\n       final String classname \u003d AuthFilter.class.getName();\n       final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n       Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n-      httpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n+      HttpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n           new String[]{pathSpec});\n       HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n       // add webhdfs packages\n       httpServer.addJerseyResourcePackage(\n           NamenodeWebHdfsMethods.class.getPackage().getName()\n           + \";\" + Param.class.getPackage().getName(), pathSpec);\n       }\n \n-    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n+    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n+    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n+    setupServlets(httpServer, conf);\n+    httpServer.start();\n+    httpAddress \u003d httpServer.getConnectorAddress(0);\n     if (certSSL) {\n-      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n-      httpsAddress \u003d NetUtils.createSocketAddr(conf.get(\n-          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n-          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n-\n-      Configuration sslConf \u003d new Configuration(false);\n-      sslConf.addResource(conf.get(\n-          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n-          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n-      httpServer.addSslListener(httpsAddress, sslConf, needClientAuth);\n+      httpsAddress \u003d httpServer.getConnectorAddress(1);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n         .getPort());\n     }\n-    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n-    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n-    setupServlets(httpServer, conf);\n-    httpServer.start();\n-    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(),\n-        httpServer.getPort());\n-    if (certSSL) {\n-      httpsAddress \u003d new InetSocketAddress(bindAddress.getAddress(),\n-          httpServer.getConnectorPort(1));\n-    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n    HttpServer.Builder builder \u003d new HttpServer.Builder().setName(\"hdfs\")\n        .addEndpoint(URI.create((\"http://\" + NetUtils.getHostPortString(bindAddress))))\n        .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n            new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n        .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n        .setUsernameConfKey(\n            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n        .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n\n    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n    if (certSSL) {\n      httpsAddress \u003d NetUtils.createSocketAddr(conf.get(\n          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n\n      builder.addEndpoint(URI.create(\"https://\"\n          + NetUtils.getHostPortString(httpsAddress)));\n      Configuration sslConf \u003d new Configuration(false);\n      sslConf.setBoolean(DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY, conf\n          .getBoolean(DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n              DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT));\n      sslConf.addResource(conf.get(\n          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n      DFSUtil.loadSslConfToHttpServerBuilder(builder, sslConf);\n    }\n\n    httpServer \u003d builder.build();\n    if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n      //add SPNEGO authentication filter for webhdfs\n      final String name \u003d \"SPNEGO\";\n      final String classname \u003d AuthFilter.class.getName();\n      final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n      Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n      HttpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n          new String[]{pathSpec});\n      HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n      // add webhdfs packages\n      httpServer.addJerseyResourcePackage(\n          NamenodeWebHdfsMethods.class.getPackage().getName()\n          + \";\" + Param.class.getPackage().getName(), pathSpec);\n      }\n\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d httpServer.getConnectorAddress(0);\n    if (certSSL) {\n      httpsAddress \u003d httpServer.getConnectorAddress(1);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n        .getPort());\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5545. Allow specifying endpoints for listeners in HttpServer. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546151 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/11/13 10:20 AM",
          "commitName": "2214871d916fdcae62aa51afbb5fd571f2808745",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "15/11/13 5:00 PM",
          "commitNameOld": "fef8f49c5885ba05dcd73e8a02de7c2be5ec3f0e",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 11.72,
          "commitsBetweenForRepo": 63,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,57 +1,62 @@\n-  public void start() throws IOException {\n+  void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n-    httpServer \u003d new HttpServer.Builder().setName(\"hdfs\")\n-        .setBindAddress(infoHost).setPort(infoPort)\n+    HttpServer.Builder builder \u003d new HttpServer.Builder().setName(\"hdfs\")\n+        .addEndpoint(URI.create((\"http://\" + NetUtils.getHostPortString(bindAddress))))\n         .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n             new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n         .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n         .setUsernameConfKey(\n             DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n         .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n-            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY)).build();\n+            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n+\n+    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n+    if (certSSL) {\n+      httpsAddress \u003d NetUtils.createSocketAddr(conf.get(\n+          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n+          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n+\n+      builder.addEndpoint(URI.create(\"https://\"\n+          + NetUtils.getHostPortString(httpsAddress)));\n+      Configuration sslConf \u003d new Configuration(false);\n+      sslConf.setBoolean(DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY, conf\n+          .getBoolean(DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n+              DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT));\n+      sslConf.addResource(conf.get(\n+          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n+          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n+      DFSUtil.loadSslConfToHttpServerBuilder(builder, sslConf);\n+    }\n+\n+    httpServer \u003d builder.build();\n     if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n       //add SPNEGO authentication filter for webhdfs\n       final String name \u003d \"SPNEGO\";\n       final String classname \u003d AuthFilter.class.getName();\n       final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n       Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n-      httpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n+      HttpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n           new String[]{pathSpec});\n       HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n       // add webhdfs packages\n       httpServer.addJerseyResourcePackage(\n           NamenodeWebHdfsMethods.class.getPackage().getName()\n           + \";\" + Param.class.getPackage().getName(), pathSpec);\n       }\n \n-    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n+    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n+    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n+    setupServlets(httpServer, conf);\n+    httpServer.start();\n+    httpAddress \u003d httpServer.getConnectorAddress(0);\n     if (certSSL) {\n-      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n-      httpsAddress \u003d NetUtils.createSocketAddr(conf.get(\n-          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n-          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n-\n-      Configuration sslConf \u003d new Configuration(false);\n-      sslConf.addResource(conf.get(\n-          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n-          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n-      httpServer.addSslListener(httpsAddress, sslConf, needClientAuth);\n+      httpsAddress \u003d httpServer.getConnectorAddress(1);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n         .getPort());\n     }\n-    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n-    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n-    setupServlets(httpServer, conf);\n-    httpServer.start();\n-    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(),\n-        httpServer.getPort());\n-    if (certSSL) {\n-      httpsAddress \u003d new InetSocketAddress(bindAddress.getAddress(),\n-          httpServer.getConnectorPort(1));\n-    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n    HttpServer.Builder builder \u003d new HttpServer.Builder().setName(\"hdfs\")\n        .addEndpoint(URI.create((\"http://\" + NetUtils.getHostPortString(bindAddress))))\n        .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n            new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n        .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n        .setUsernameConfKey(\n            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n        .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n\n    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n    if (certSSL) {\n      httpsAddress \u003d NetUtils.createSocketAddr(conf.get(\n          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n\n      builder.addEndpoint(URI.create(\"https://\"\n          + NetUtils.getHostPortString(httpsAddress)));\n      Configuration sslConf \u003d new Configuration(false);\n      sslConf.setBoolean(DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY, conf\n          .getBoolean(DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n              DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT));\n      sslConf.addResource(conf.get(\n          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n      DFSUtil.loadSslConfToHttpServerBuilder(builder, sslConf);\n    }\n\n    httpServer \u003d builder.build();\n    if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n      //add SPNEGO authentication filter for webhdfs\n      final String name \u003d \"SPNEGO\";\n      final String classname \u003d AuthFilter.class.getName();\n      final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n      Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n      HttpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n          new String[]{pathSpec});\n      HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n      // add webhdfs packages\n      httpServer.addJerseyResourcePackage(\n          NamenodeWebHdfsMethods.class.getPackage().getName()\n          + \";\" + Param.class.getPackage().getName(), pathSpec);\n      }\n\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d httpServer.getConnectorAddress(0);\n    if (certSSL) {\n      httpsAddress \u003d httpServer.getConnectorAddress(1);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n        .getPort());\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
          "extendedDetails": {}
        }
      ]
    },
    "fef8f49c5885ba05dcd73e8a02de7c2be5ec3f0e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5502. Fix HTTPS support in HsftpFileSystem. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1542438 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/11/13 5:00 PM",
      "commitName": "fef8f49c5885ba05dcd73e8a02de7c2be5ec3f0e",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "07/10/13 9:26 PM",
      "commitNameOld": "09998741ac3b425d95a6ba47865414b629ef1252",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 38.86,
      "commitsBetweenForRepo": 233,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,57 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n     httpServer \u003d new HttpServer.Builder().setName(\"hdfs\")\n         .setBindAddress(infoHost).setPort(infoPort)\n         .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n             new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n         .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n         .setUsernameConfKey(\n             DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n         .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n             DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY)).build();\n     if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n       //add SPNEGO authentication filter for webhdfs\n       final String name \u003d \"SPNEGO\";\n       final String classname \u003d AuthFilter.class.getName();\n       final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n       Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n       httpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n           new String[]{pathSpec});\n       HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n       // add webhdfs packages\n       httpServer.addJerseyResourcePackage(\n           NamenodeWebHdfsMethods.class.getPackage().getName()\n           + \";\" + Param.class.getPackage().getName(), pathSpec);\n       }\n \n     boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n       httpsAddress \u003d NetUtils.createSocketAddr(conf.get(\n           DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n           DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n \n       Configuration sslConf \u003d new Configuration(false);\n       sslConf.addResource(conf.get(\n           DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n           DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n       httpServer.addSslListener(httpsAddress, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n         .getPort());\n     }\n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n-    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n+    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(),\n+        httpServer.getPort());\n+    if (certSSL) {\n+      httpsAddress \u003d new InetSocketAddress(bindAddress.getAddress(),\n+          httpServer.getConnectorPort(1));\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n    httpServer \u003d new HttpServer.Builder().setName(\"hdfs\")\n        .setBindAddress(infoHost).setPort(infoPort)\n        .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n            new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n        .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n        .setUsernameConfKey(\n            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n        .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY)).build();\n    if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n      //add SPNEGO authentication filter for webhdfs\n      final String name \u003d \"SPNEGO\";\n      final String classname \u003d AuthFilter.class.getName();\n      final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n      Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n      httpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n          new String[]{pathSpec});\n      HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n      // add webhdfs packages\n      httpServer.addJerseyResourcePackage(\n          NamenodeWebHdfsMethods.class.getPackage().getName()\n          + \";\" + Param.class.getPackage().getName(), pathSpec);\n      }\n\n    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      httpsAddress \u003d NetUtils.createSocketAddr(conf.get(\n          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n\n      Configuration sslConf \u003d new Configuration(false);\n      sslConf.addResource(conf.get(\n          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n      httpServer.addSslListener(httpsAddress, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(),\n        httpServer.getPort());\n    if (certSSL) {\n      httpsAddress \u003d new InetSocketAddress(bindAddress.getAddress(),\n          httpServer.getConnectorPort(1));\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "09998741ac3b425d95a6ba47865414b629ef1252": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5316. Namenode ignores the default https port. Contributed by Haohui Mai\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1530150 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/10/13 9:26 PM",
      "commitName": "09998741ac3b425d95a6ba47865414b629ef1252",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "27/09/13 2:45 PM",
      "commitNameOld": "b2e174c9a502197180584c01db7029a3606efe56",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 10.28,
      "commitsBetweenForRepo": 86,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,52 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n     httpServer \u003d new HttpServer.Builder().setName(\"hdfs\")\n         .setBindAddress(infoHost).setPort(infoPort)\n         .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n             new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n         .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n         .setUsernameConfKey(\n             DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n         .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n             DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY)).build();\n     if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n       //add SPNEGO authentication filter for webhdfs\n       final String name \u003d \"SPNEGO\";\n       final String classname \u003d AuthFilter.class.getName();\n       final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n       Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n       httpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n           new String[]{pathSpec});\n       HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n       // add webhdfs packages\n       httpServer.addJerseyResourcePackage(\n           NamenodeWebHdfsMethods.class.getPackage().getName()\n           + \";\" + Param.class.getPackage().getName(), pathSpec);\n       }\n \n     boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n-      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n-        DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_KEY, \"0\"));\n+      httpsAddress \u003d NetUtils.createSocketAddr(conf.get(\n+          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n+          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n+\n       Configuration sslConf \u003d new Configuration(false);\n-      if (certSSL) {\n-        sslConf.addResource(conf.get(DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n-                                     \"ssl-server.xml\"));\n-      }\n-      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n+      sslConf.addResource(conf.get(\n+          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n+          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n+      httpServer.addSslListener(httpsAddress, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n         .getPort());\n     }\n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n     httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n    httpServer \u003d new HttpServer.Builder().setName(\"hdfs\")\n        .setBindAddress(infoHost).setPort(infoPort)\n        .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n            new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n        .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n        .setUsernameConfKey(\n            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n        .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY)).build();\n    if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n      //add SPNEGO authentication filter for webhdfs\n      final String name \u003d \"SPNEGO\";\n      final String classname \u003d AuthFilter.class.getName();\n      final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n      Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n      httpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n          new String[]{pathSpec});\n      HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n      // add webhdfs packages\n      httpServer.addJerseyResourcePackage(\n          NamenodeWebHdfsMethods.class.getPackage().getName()\n          + \";\" + Param.class.getPackage().getName(), pathSpec);\n      }\n\n    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      httpsAddress \u003d NetUtils.createSocketAddr(conf.get(\n          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n          DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n\n      Configuration sslConf \u003d new Configuration(false);\n      sslConf.addResource(conf.get(\n          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n          DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n      httpServer.addSslListener(httpsAddress, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "b2e174c9a502197180584c01db7029a3606efe56": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5265. Namenode fails to start when dfs.https.port is unspecified. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527093 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/09/13 2:45 PM",
      "commitName": "b2e174c9a502197180584c01db7029a3606efe56",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "21/08/13 3:12 AM",
      "commitNameOld": "782191f1ba27e0ff0acf3c6cf8a88df00274d308",
      "commitAuthorOld": "Luke Lu",
      "daysBetweenCommits": 37.48,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n     httpServer \u003d new HttpServer.Builder().setName(\"hdfs\")\n         .setBindAddress(infoHost).setPort(infoPort)\n         .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n             new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n         .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n         .setUsernameConfKey(\n             DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n         .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n             DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY)).build();\n     if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n       //add SPNEGO authentication filter for webhdfs\n       final String name \u003d \"SPNEGO\";\n       final String classname \u003d AuthFilter.class.getName();\n       final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n       Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n       httpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n           new String[]{pathSpec});\n       HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n       // add webhdfs packages\n       httpServer.addJerseyResourcePackage(\n           NamenodeWebHdfsMethods.class.getPackage().getName()\n           + \";\" + Param.class.getPackage().getName(), pathSpec);\n       }\n \n     boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n       InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n-        DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_KEY, infoHost + \":\" + 0));\n+        DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_KEY, \"0\"));\n       Configuration sslConf \u003d new Configuration(false);\n       if (certSSL) {\n         sslConf.addResource(conf.get(DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n                                      \"ssl-server.xml\"));\n       }\n       httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n         .getPort());\n     }\n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n     httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n    httpServer \u003d new HttpServer.Builder().setName(\"hdfs\")\n        .setBindAddress(infoHost).setPort(infoPort)\n        .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n            new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n        .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n        .setUsernameConfKey(\n            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n        .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY)).build();\n    if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n      //add SPNEGO authentication filter for webhdfs\n      final String name \u003d \"SPNEGO\";\n      final String classname \u003d AuthFilter.class.getName();\n      final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n      Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n      httpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n          new String[]{pathSpec});\n      HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n      // add webhdfs packages\n      httpServer.addJerseyResourcePackage(\n          NamenodeWebHdfsMethods.class.getPackage().getName()\n          + \";\" + Param.class.getPackage().getName(), pathSpec);\n      }\n\n    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_KEY, \"0\"));\n      Configuration sslConf \u003d new Configuration(false);\n      if (certSSL) {\n        sslConf.addResource(conf.get(DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n                                     \"ssl-server.xml\"));\n      }\n      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "782191f1ba27e0ff0acf3c6cf8a88df00274d308": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9784. Add a builder for HttpServer. (Junping Du via llu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1516128 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/08/13 3:12 AM",
      "commitName": "782191f1ba27e0ff0acf3c6cf8a88df00274d308",
      "commitAuthor": "Luke Lu",
      "commitDateOld": "18/07/13 10:41 PM",
      "commitNameOld": "7e2aba0ab594f6939b47704f1087405c3d1c089b",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 33.19,
      "commitsBetweenForRepo": 205,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,51 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n+    httpServer \u003d new HttpServer.Builder().setName(\"hdfs\")\n+        .setBindAddress(infoHost).setPort(infoPort)\n+        .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n+            new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n+        .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n+        .setUsernameConfKey(\n+            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n+        .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n+            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY)).build();\n+    if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n+      //add SPNEGO authentication filter for webhdfs\n+      final String name \u003d \"SPNEGO\";\n+      final String classname \u003d AuthFilter.class.getName();\n+      final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n+      Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n+      httpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n+          new String[]{pathSpec});\n+      HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n-    httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n-                                infoPort \u003d\u003d 0, conf,\n-                                new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n-      {\n-        // Add SPNEGO support to NameNode\n-        if (UserGroupInformation.isSecurityEnabled()) {\n-          initSpnego(conf,\n-              DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n-              DFSUtil.getSpnegoKeytabKey(conf,\n-                  DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n-        }\n-        if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n-          //add SPNEGO authentication filter for webhdfs\n-          final String name \u003d \"SPNEGO\";\n-          final String classname \u003d AuthFilter.class.getName();\n-          final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n-          Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n-          defineFilter(webAppContext, name, classname, params,\n-                       new String[]{pathSpec});\n-          LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n-\n-          // add webhdfs packages\n-          addJerseyResourcePackage(\n-            NamenodeWebHdfsMethods.class.getPackage().getName()\n-            + \";\" + Param.class.getPackage().getName(), pathSpec);\n-        }\n+      // add webhdfs packages\n+      httpServer.addJerseyResourcePackage(\n+          NamenodeWebHdfsMethods.class.getPackage().getName()\n+          + \";\" + Param.class.getPackage().getName(), pathSpec);\n       }\n \n-      private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n-        throws IOException {\n-        Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n-        String principalInConf \u003d conf\n-          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n-        if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n-          params\n-            .put(\n-              DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n-              SecurityUtil.getServerPrincipal(principalInConf,\n-                                              bindAddress.getHostName()));\n-        } else if (UserGroupInformation.isSecurityEnabled()) {\n-          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n-                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY +\n-                    \"\u0027 is not set.\");\n-        }\n-        String httpKeytab \u003d conf.get(DFSUtil.getSpnegoKeytabKey(conf,\n-            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n-        if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n-          params.put(\n-            DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n-            httpKeytab);\n-        } else if (UserGroupInformation.isSecurityEnabled()) {\n-          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n-                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY +\n-                    \"\u0027 is not set.\");\n-        }\n-        return params;\n-      }\n-    };\n-\n     boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n       InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n         DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_KEY, infoHost + \":\" + 0));\n       Configuration sslConf \u003d new Configuration(false);\n       if (certSSL) {\n         sslConf.addResource(conf.get(DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n                                      \"ssl-server.xml\"));\n       }\n       httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n       httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n         .getPort());\n     }\n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n     httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n    httpServer \u003d new HttpServer.Builder().setName(\"hdfs\")\n        .setBindAddress(infoHost).setPort(infoPort)\n        .setFindPort(infoPort \u003d\u003d 0).setConf(conf).setACL(\n            new AccessControlList(conf.get(DFS_ADMIN, \" \")))\n        .setSecurityEnabled(UserGroupInformation.isSecurityEnabled())\n        .setUsernameConfKey(\n            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY)\n        .setKeytabConfKey(DFSUtil.getSpnegoKeytabKey(conf,\n            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY)).build();\n    if (WebHdfsFileSystem.isEnabled(conf, HttpServer.LOG)) {\n      //add SPNEGO authentication filter for webhdfs\n      final String name \u003d \"SPNEGO\";\n      final String classname \u003d AuthFilter.class.getName();\n      final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n      Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n      httpServer.defineFilter(httpServer.getWebAppContext(), name, classname, params,\n          new String[]{pathSpec});\n      HttpServer.LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n      // add webhdfs packages\n      httpServer.addJerseyResourcePackage(\n          NamenodeWebHdfsMethods.class.getPackage().getName()\n          + \";\" + Param.class.getPackage().getName(), pathSpec);\n      }\n\n    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_KEY, infoHost + \":\" + 0));\n      Configuration sslConf \u003d new Configuration(false);\n      if (certSSL) {\n        sslConf.addResource(conf.get(DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n                                     \"ssl-server.xml\"));\n      }\n      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "7e2aba0ab594f6939b47704f1087405c3d1c089b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5007. Replace hard-coded property keys with DFSConfigKeys fields. Contributed by Kousuke Saruta.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1504764 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/07/13 10:41 PM",
      "commitName": "7e2aba0ab594f6939b47704f1087405c3d1c089b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "11/07/13 12:04 PM",
      "commitNameOld": "19346d8ca6458840d1e2a78786c872bf9d1f038e",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 7.44,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,86 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n \n     httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                 infoPort \u003d\u003d 0, conf,\n                                 new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n       {\n         // Add SPNEGO support to NameNode\n         if (UserGroupInformation.isSecurityEnabled()) {\n           initSpnego(conf,\n               DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n               DFSUtil.getSpnegoKeytabKey(conf,\n                   DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n         }\n         if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n           //add SPNEGO authentication filter for webhdfs\n           final String name \u003d \"SPNEGO\";\n           final String classname \u003d AuthFilter.class.getName();\n           final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n           Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n           defineFilter(webAppContext, name, classname, params,\n                        new String[]{pathSpec});\n           LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n           // add webhdfs packages\n           addJerseyResourcePackage(\n             NamenodeWebHdfsMethods.class.getPackage().getName()\n             + \";\" + Param.class.getPackage().getName(), pathSpec);\n         }\n       }\n \n       private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n         throws IOException {\n         Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n         String principalInConf \u003d conf\n           .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n         if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n           params\n             .put(\n               DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n               SecurityUtil.getServerPrincipal(principalInConf,\n                                               bindAddress.getHostName()));\n         } else if (UserGroupInformation.isSecurityEnabled()) {\n           LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY +\n                     \"\u0027 is not set.\");\n         }\n         String httpKeytab \u003d conf.get(DFSUtil.getSpnegoKeytabKey(conf,\n             DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n         if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n           params.put(\n             DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n             httpKeytab);\n         } else if (UserGroupInformation.isSecurityEnabled()) {\n           LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY +\n                     \"\u0027 is not set.\");\n         }\n         return params;\n       }\n     };\n \n-    boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n+    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n       InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n-        \"dfs.https.port\", infoHost + \":\" + 0));\n+        DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_KEY, infoHost + \":\" + 0));\n       Configuration sslConf \u003d new Configuration(false);\n       if (certSSL) {\n-        sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n+        sslConf.addResource(conf.get(DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n                                      \"ssl-server.xml\"));\n       }\n       httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n-        \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n-      httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n+        DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n+      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n         .getPort());\n     }\n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n     httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n\n    httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                infoPort \u003d\u003d 0, conf,\n                                new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n      {\n        // Add SPNEGO support to NameNode\n        if (UserGroupInformation.isSecurityEnabled()) {\n          initSpnego(conf,\n              DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n              DFSUtil.getSpnegoKeytabKey(conf,\n                  DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n        }\n        if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n          //add SPNEGO authentication filter for webhdfs\n          final String name \u003d \"SPNEGO\";\n          final String classname \u003d AuthFilter.class.getName();\n          final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n          Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n          defineFilter(webAppContext, name, classname, params,\n                       new String[]{pathSpec});\n          LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n          // add webhdfs packages\n          addJerseyResourcePackage(\n            NamenodeWebHdfsMethods.class.getPackage().getName()\n            + \";\" + Param.class.getPackage().getName(), pathSpec);\n        }\n      }\n\n      private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n        throws IOException {\n        Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n        String principalInConf \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n        if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n          params\n            .put(\n              DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n              SecurityUtil.getServerPrincipal(principalInConf,\n                                              bindAddress.getHostName()));\n        } else if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY +\n                    \"\u0027 is not set.\");\n        }\n        String httpKeytab \u003d conf.get(DFSUtil.getSpnegoKeytabKey(conf,\n            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n        if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n          params.put(\n            DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n            httpKeytab);\n        } else if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY +\n                    \"\u0027 is not set.\");\n        }\n        return params;\n      }\n    };\n\n    boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n        DFSConfigKeys.DFS_NAMENODE_HTTPS_PORT_KEY, infoHost + \":\" + 0));\n      Configuration sslConf \u003d new Configuration(false);\n      if (certSSL) {\n        sslConf.addResource(conf.get(DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n                                     \"ssl-server.xml\"));\n      }\n      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        DFSConfigKeys.DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n      httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY, datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "da8e962e39bd41b73b53966826c82e741b08010b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4372. Track NameNode startup progress. Contributed by Chris Nauroth.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1502120 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/13 10:35 PM",
      "commitName": "da8e962e39bd41b73b53966826c82e741b08010b",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "07/03/13 11:23 AM",
      "commitNameOld": "301079b4bfa1853f48ec0d118f2dd48f96d5d41b",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 125.43,
      "commitsBetweenForRepo": 775,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,89 +1,86 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n \n     httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                 infoPort \u003d\u003d 0, conf,\n                                 new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n       {\n         // Add SPNEGO support to NameNode\n         if (UserGroupInformation.isSecurityEnabled()) {\n           initSpnego(conf,\n               DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n               DFSUtil.getSpnegoKeytabKey(conf,\n                   DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n         }\n         if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n           //add SPNEGO authentication filter for webhdfs\n           final String name \u003d \"SPNEGO\";\n           final String classname \u003d AuthFilter.class.getName();\n           final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n           Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n           defineFilter(webAppContext, name, classname, params,\n                        new String[]{pathSpec});\n           LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n           // add webhdfs packages\n           addJerseyResourcePackage(\n             NamenodeWebHdfsMethods.class.getPackage().getName()\n             + \";\" + Param.class.getPackage().getName(), pathSpec);\n         }\n       }\n \n       private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n         throws IOException {\n         Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n         String principalInConf \u003d conf\n           .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n         if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n           params\n             .put(\n               DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n               SecurityUtil.getServerPrincipal(principalInConf,\n                                               bindAddress.getHostName()));\n         } else if (UserGroupInformation.isSecurityEnabled()) {\n           LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY +\n                     \"\u0027 is not set.\");\n         }\n         String httpKeytab \u003d conf.get(DFSUtil.getSpnegoKeytabKey(conf,\n             DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n         if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n           params.put(\n             DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n             httpKeytab);\n         } else if (UserGroupInformation.isSecurityEnabled()) {\n           LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY +\n                     \"\u0027 is not set.\");\n         }\n         return params;\n       }\n     };\n \n     boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n       InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n         \"dfs.https.port\", infoHost + \":\" + 0));\n       Configuration sslConf \u003d new Configuration(false);\n       if (certSSL) {\n         sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                      \"ssl-server.xml\"));\n       }\n       httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n       httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n         .getPort());\n     }\n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n-    httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n-        NetUtils.getConnectAddress(nn.getNameNodeAddress()));\n-    httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n     httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n\n    httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                infoPort \u003d\u003d 0, conf,\n                                new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n      {\n        // Add SPNEGO support to NameNode\n        if (UserGroupInformation.isSecurityEnabled()) {\n          initSpnego(conf,\n              DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n              DFSUtil.getSpnegoKeytabKey(conf,\n                  DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n        }\n        if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n          //add SPNEGO authentication filter for webhdfs\n          final String name \u003d \"SPNEGO\";\n          final String classname \u003d AuthFilter.class.getName();\n          final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n          Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n          defineFilter(webAppContext, name, classname, params,\n                       new String[]{pathSpec});\n          LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n          // add webhdfs packages\n          addJerseyResourcePackage(\n            NamenodeWebHdfsMethods.class.getPackage().getName()\n            + \";\" + Param.class.getPackage().getName(), pathSpec);\n        }\n      }\n\n      private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n        throws IOException {\n        Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n        String principalInConf \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n        if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n          params\n            .put(\n              DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n              SecurityUtil.getServerPrincipal(principalInConf,\n                                              bindAddress.getHostName()));\n        } else if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY +\n                    \"\u0027 is not set.\");\n        }\n        String httpKeytab \u003d conf.get(DFSUtil.getSpnegoKeytabKey(conf,\n            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n        if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n          params.put(\n            DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n            httpKeytab);\n        } else if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY +\n                    \"\u0027 is not set.\");\n        }\n        return params;\n      }\n    };\n\n    boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n        \"dfs.https.port\", infoHost + \":\" + 0));\n      Configuration sslConf \u003d new Configuration(false);\n      if (certSSL) {\n        sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                     \"ssl-server.xml\"));\n      }\n      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n      httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "301079b4bfa1853f48ec0d118f2dd48f96d5d41b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4546. Use DFSUtil.getSpnegoKeytabKey() to get the spnego keytab key in secondary namenode and namenode http server. Contributed by Arpit Agarwal.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1454021 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/03/13 11:23 AM",
      "commitName": "301079b4bfa1853f48ec0d118f2dd48f96d5d41b",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "05/03/13 1:47 PM",
      "commitNameOld": "a82e67af6c748a1c33528338c560f130e5b28c28",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 1.9,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,89 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n \n     httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                 infoPort \u003d\u003d 0, conf,\n                                 new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n       {\n         // Add SPNEGO support to NameNode\n         if (UserGroupInformation.isSecurityEnabled()) {\n           initSpnego(conf,\n               DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n               DFSUtil.getSpnegoKeytabKey(conf,\n                   DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n         }\n         if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n           //add SPNEGO authentication filter for webhdfs\n           final String name \u003d \"SPNEGO\";\n           final String classname \u003d AuthFilter.class.getName();\n           final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n           Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n           defineFilter(webAppContext, name, classname, params,\n                        new String[]{pathSpec});\n           LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n           // add webhdfs packages\n           addJerseyResourcePackage(\n             NamenodeWebHdfsMethods.class.getPackage().getName()\n             + \";\" + Param.class.getPackage().getName(), pathSpec);\n         }\n       }\n \n       private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n         throws IOException {\n         Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n         String principalInConf \u003d conf\n           .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n         if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n           params\n             .put(\n               DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n               SecurityUtil.getServerPrincipal(principalInConf,\n                                               bindAddress.getHostName()));\n         } else if (UserGroupInformation.isSecurityEnabled()) {\n           LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY +\n                     \"\u0027 is not set.\");\n         }\n-        String httpKeytab \u003d conf.get(\n-          DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n-        if (httpKeytab \u003d\u003d null) {\n-          httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n-        }\n+        String httpKeytab \u003d conf.get(DFSUtil.getSpnegoKeytabKey(conf,\n+            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n         if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n           params.put(\n             DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n             httpKeytab);\n         } else if (UserGroupInformation.isSecurityEnabled()) {\n           LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY +\n                     \"\u0027 is not set.\");\n         }\n         return params;\n       }\n     };\n \n     boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n       InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n         \"dfs.https.port\", infoHost + \":\" + 0));\n       Configuration sslConf \u003d new Configuration(false);\n       if (certSSL) {\n         sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                      \"ssl-server.xml\"));\n       }\n       httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n       httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n         .getPort());\n     }\n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n         NetUtils.getConnectAddress(nn.getNameNodeAddress()));\n     httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n     httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n\n    httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                infoPort \u003d\u003d 0, conf,\n                                new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n      {\n        // Add SPNEGO support to NameNode\n        if (UserGroupInformation.isSecurityEnabled()) {\n          initSpnego(conf,\n              DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n              DFSUtil.getSpnegoKeytabKey(conf,\n                  DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n        }\n        if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n          //add SPNEGO authentication filter for webhdfs\n          final String name \u003d \"SPNEGO\";\n          final String classname \u003d AuthFilter.class.getName();\n          final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n          Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n          defineFilter(webAppContext, name, classname, params,\n                       new String[]{pathSpec});\n          LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n          // add webhdfs packages\n          addJerseyResourcePackage(\n            NamenodeWebHdfsMethods.class.getPackage().getName()\n            + \";\" + Param.class.getPackage().getName(), pathSpec);\n        }\n      }\n\n      private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n        throws IOException {\n        Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n        String principalInConf \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n        if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n          params\n            .put(\n              DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n              SecurityUtil.getServerPrincipal(principalInConf,\n                                              bindAddress.getHostName()));\n        } else if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY +\n                    \"\u0027 is not set.\");\n        }\n        String httpKeytab \u003d conf.get(DFSUtil.getSpnegoKeytabKey(conf,\n            DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n        if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n          params.put(\n            DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n            httpKeytab);\n        } else if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY +\n                    \"\u0027 is not set.\");\n        }\n        return params;\n      }\n    };\n\n    boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n        \"dfs.https.port\", infoHost + \":\" + 0));\n      Configuration sslConf \u003d new Configuration(false);\n      if (certSSL) {\n        sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                     \"ssl-server.xml\"));\n      }\n      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n      httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n        NetUtils.getConnectAddress(nn.getNameNodeAddress()));\n    httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "a82e67af6c748a1c33528338c560f130e5b28c28": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4540. Namenode http server should use the web authentication keytab for spnego principal. Contributed by Arpit Gupta.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1453025 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/03/13 1:47 PM",
      "commitName": "a82e67af6c748a1c33528338c560f130e5b28c28",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "04/10/12 5:54 PM",
      "commitNameOld": "6582da034b9dff252e5b458890b0f0c7d2f81746",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 151.87,
      "commitsBetweenForRepo": 690,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,92 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n \n     httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                 infoPort \u003d\u003d 0, conf,\n                                 new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n       {\n         // Add SPNEGO support to NameNode\n         if (UserGroupInformation.isSecurityEnabled()) {\n           initSpnego(conf,\n               DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n-              DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n+              DFSUtil.getSpnegoKeytabKey(conf,\n+                  DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n         }\n         if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n           //add SPNEGO authentication filter for webhdfs\n           final String name \u003d \"SPNEGO\";\n           final String classname \u003d AuthFilter.class.getName();\n           final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n           Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n           defineFilter(webAppContext, name, classname, params,\n                        new String[]{pathSpec});\n           LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n           // add webhdfs packages\n           addJerseyResourcePackage(\n             NamenodeWebHdfsMethods.class.getPackage().getName()\n             + \";\" + Param.class.getPackage().getName(), pathSpec);\n         }\n       }\n \n       private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n         throws IOException {\n         Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n         String principalInConf \u003d conf\n           .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n         if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n           params\n             .put(\n               DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n               SecurityUtil.getServerPrincipal(principalInConf,\n                                               bindAddress.getHostName()));\n         } else if (UserGroupInformation.isSecurityEnabled()) {\n           LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY +\n                     \"\u0027 is not set.\");\n         }\n         String httpKeytab \u003d conf.get(\n           DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n         if (httpKeytab \u003d\u003d null) {\n           httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n         }\n         if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n           params.put(\n             DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n             httpKeytab);\n         } else if (UserGroupInformation.isSecurityEnabled()) {\n           LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY +\n                     \"\u0027 is not set.\");\n         }\n         return params;\n       }\n     };\n \n     boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n       InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n         \"dfs.https.port\", infoHost + \":\" + 0));\n       Configuration sslConf \u003d new Configuration(false);\n       if (certSSL) {\n         sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                      \"ssl-server.xml\"));\n       }\n       httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n       httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n         .getPort());\n     }\n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n         NetUtils.getConnectAddress(nn.getNameNodeAddress()));\n     httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n     httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n\n    httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                infoPort \u003d\u003d 0, conf,\n                                new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n      {\n        // Add SPNEGO support to NameNode\n        if (UserGroupInformation.isSecurityEnabled()) {\n          initSpnego(conf,\n              DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n              DFSUtil.getSpnegoKeytabKey(conf,\n                  DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY));\n        }\n        if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n          //add SPNEGO authentication filter for webhdfs\n          final String name \u003d \"SPNEGO\";\n          final String classname \u003d AuthFilter.class.getName();\n          final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n          Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n          defineFilter(webAppContext, name, classname, params,\n                       new String[]{pathSpec});\n          LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n          // add webhdfs packages\n          addJerseyResourcePackage(\n            NamenodeWebHdfsMethods.class.getPackage().getName()\n            + \";\" + Param.class.getPackage().getName(), pathSpec);\n        }\n      }\n\n      private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n        throws IOException {\n        Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n        String principalInConf \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n        if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n          params\n            .put(\n              DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n              SecurityUtil.getServerPrincipal(principalInConf,\n                                              bindAddress.getHostName()));\n        } else if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY +\n                    \"\u0027 is not set.\");\n        }\n        String httpKeytab \u003d conf.get(\n          DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n        if (httpKeytab \u003d\u003d null) {\n          httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n        }\n        if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n          params.put(\n            DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n            httpKeytab);\n        } else if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY +\n                    \"\u0027 is not set.\");\n        }\n        return params;\n      }\n    };\n\n    boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n        \"dfs.https.port\", infoHost + \":\" + 0));\n      Configuration sslConf \u003d new Configuration(false);\n      if (certSSL) {\n        sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                     \"ssl-server.xml\"));\n      }\n      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n      httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n        NetUtils.getConnectAddress(nn.getNameNodeAddress()));\n    httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "6582da034b9dff252e5b458890b0f0c7d2f81746": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3813. Log error message if security and WebHDFS are enabled but principal/keytab are not configured. Contributed by Stephen Chu.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1394340 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/10/12 5:54 PM",
      "commitName": "6582da034b9dff252e5b458890b0f0c7d2f81746",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "20/09/12 9:51 PM",
      "commitNameOld": "7dee7f11f6709990a7a18bbbabdeb929ffde6b76",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 13.83,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,91 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n \n     httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                 infoPort \u003d\u003d 0, conf,\n                                 new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n       {\n         // Add SPNEGO support to NameNode\n         if (UserGroupInformation.isSecurityEnabled()) {\n           initSpnego(conf,\n               DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n               DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n         }\n         if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n           //add SPNEGO authentication filter for webhdfs\n           final String name \u003d \"SPNEGO\";\n           final String classname \u003d AuthFilter.class.getName();\n           final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n           Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n           defineFilter(webAppContext, name, classname, params,\n                        new String[]{pathSpec});\n           LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n           // add webhdfs packages\n           addJerseyResourcePackage(\n             NamenodeWebHdfsMethods.class.getPackage().getName()\n             + \";\" + Param.class.getPackage().getName(), pathSpec);\n         }\n       }\n \n       private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n         throws IOException {\n         Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n         String principalInConf \u003d conf\n           .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n         if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n           params\n             .put(\n               DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n               SecurityUtil.getServerPrincipal(principalInConf,\n                                               bindAddress.getHostName()));\n+        } else if (UserGroupInformation.isSecurityEnabled()) {\n+          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n+                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY +\n+                    \"\u0027 is not set.\");\n         }\n         String httpKeytab \u003d conf.get(\n           DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n         if (httpKeytab \u003d\u003d null) {\n           httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n         }\n         if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n           params.put(\n             DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n             httpKeytab);\n+        } else if (UserGroupInformation.isSecurityEnabled()) {\n+          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n+                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY +\n+                    \"\u0027 is not set.\");\n         }\n         return params;\n       }\n     };\n \n     boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n       InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n         \"dfs.https.port\", infoHost + \":\" + 0));\n       Configuration sslConf \u003d new Configuration(false);\n       if (certSSL) {\n         sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                      \"ssl-server.xml\"));\n       }\n       httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n       httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n         .getPort());\n     }\n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n         NetUtils.getConnectAddress(nn.getNameNodeAddress()));\n     httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n     httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n\n    httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                infoPort \u003d\u003d 0, conf,\n                                new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n      {\n        // Add SPNEGO support to NameNode\n        if (UserGroupInformation.isSecurityEnabled()) {\n          initSpnego(conf,\n              DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n              DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n        }\n        if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n          //add SPNEGO authentication filter for webhdfs\n          final String name \u003d \"SPNEGO\";\n          final String classname \u003d AuthFilter.class.getName();\n          final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n          Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n          defineFilter(webAppContext, name, classname, params,\n                       new String[]{pathSpec});\n          LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n          // add webhdfs packages\n          addJerseyResourcePackage(\n            NamenodeWebHdfsMethods.class.getPackage().getName()\n            + \";\" + Param.class.getPackage().getName(), pathSpec);\n        }\n      }\n\n      private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n        throws IOException {\n        Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n        String principalInConf \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n        if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n          params\n            .put(\n              DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n              SecurityUtil.getServerPrincipal(principalInConf,\n                                              bindAddress.getHostName()));\n        } else if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY +\n                    \"\u0027 is not set.\");\n        }\n        String httpKeytab \u003d conf.get(\n          DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n        if (httpKeytab \u003d\u003d null) {\n          httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n        }\n        if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n          params.put(\n            DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n            httpKeytab);\n        } else if (UserGroupInformation.isSecurityEnabled()) {\n          LOG.error(\"WebHDFS and security are enabled, but configuration property \u0027\" +\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY +\n                    \"\u0027 is not set.\");\n        }\n        return params;\n      }\n    };\n\n    boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n        \"dfs.https.port\", infoHost + \":\" + 0));\n      Configuration sslConf \u003d new Configuration(false);\n      if (certSSL) {\n        sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                     \"ssl-server.xml\"));\n      }\n      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n      httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n        NetUtils.getConnectAddress(nn.getNameNodeAddress()));\n    httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "7dee7f11f6709990a7a18bbbabdeb929ffde6b76": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3932. NameNode Web UI broken if the rpc-address is set to the wildcard. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1388321 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/09/12 9:51 PM",
      "commitName": "7dee7f11f6709990a7a18bbbabdeb929ffde6b76",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "18/09/12 10:42 AM",
      "commitNameOld": "a8e4bb81b2e7c5c79273ef3ceb1af86ae8e4cd68",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 2.46,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,83 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n \n     httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                 infoPort \u003d\u003d 0, conf,\n                                 new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n       {\n         // Add SPNEGO support to NameNode\n         if (UserGroupInformation.isSecurityEnabled()) {\n           initSpnego(conf,\n               DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n               DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n         }\n         if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n           //add SPNEGO authentication filter for webhdfs\n           final String name \u003d \"SPNEGO\";\n           final String classname \u003d AuthFilter.class.getName();\n           final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n           Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n           defineFilter(webAppContext, name, classname, params,\n                        new String[]{pathSpec});\n           LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n           // add webhdfs packages\n           addJerseyResourcePackage(\n             NamenodeWebHdfsMethods.class.getPackage().getName()\n             + \";\" + Param.class.getPackage().getName(), pathSpec);\n         }\n       }\n \n       private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n         throws IOException {\n         Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n         String principalInConf \u003d conf\n           .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n         if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n           params\n             .put(\n               DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n               SecurityUtil.getServerPrincipal(principalInConf,\n                                               bindAddress.getHostName()));\n         }\n         String httpKeytab \u003d conf.get(\n           DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n         if (httpKeytab \u003d\u003d null) {\n           httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n         }\n         if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n           params.put(\n             DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n             httpKeytab);\n         }\n         return params;\n       }\n     };\n \n     boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n       InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n         \"dfs.https.port\", infoHost + \":\" + 0));\n       Configuration sslConf \u003d new Configuration(false);\n       if (certSSL) {\n         sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                      \"ssl-server.xml\"));\n       }\n       httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n       httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n         .getPort());\n     }\n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n-    httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY, nn.getNameNodeAddress());\n+    httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n+        NetUtils.getConnectAddress(nn.getNameNodeAddress()));\n     httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n     httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n\n    httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                infoPort \u003d\u003d 0, conf,\n                                new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n      {\n        // Add SPNEGO support to NameNode\n        if (UserGroupInformation.isSecurityEnabled()) {\n          initSpnego(conf,\n              DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n              DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n        }\n        if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n          //add SPNEGO authentication filter for webhdfs\n          final String name \u003d \"SPNEGO\";\n          final String classname \u003d AuthFilter.class.getName();\n          final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n          Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n          defineFilter(webAppContext, name, classname, params,\n                       new String[]{pathSpec});\n          LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n          // add webhdfs packages\n          addJerseyResourcePackage(\n            NamenodeWebHdfsMethods.class.getPackage().getName()\n            + \";\" + Param.class.getPackage().getName(), pathSpec);\n        }\n      }\n\n      private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n        throws IOException {\n        Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n        String principalInConf \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n        if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n          params\n            .put(\n              DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n              SecurityUtil.getServerPrincipal(principalInConf,\n                                              bindAddress.getHostName()));\n        }\n        String httpKeytab \u003d conf.get(\n          DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n        if (httpKeytab \u003d\u003d null) {\n          httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n        }\n        if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n          params.put(\n            DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n            httpKeytab);\n        }\n        return params;\n      }\n    };\n\n    boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n        \"dfs.https.port\", infoHost + \":\" + 0));\n      Configuration sslConf \u003d new Configuration(false);\n      if (certSSL) {\n        sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                     \"ssl-server.xml\"));\n      }\n      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n      httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n        NetUtils.getConnectAddress(nn.getNameNodeAddress()));\n    httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "c76a7893f9215d25fca18f4444157db2addf720e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3466. Get HTTP kerberos principal from the web authentication keytab.\n(omalley)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1379646 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/08/12 3:31 PM",
      "commitName": "c76a7893f9215d25fca18f4444157db2addf720e",
      "commitAuthor": "Owen O\u0027Malley",
      "commitDateOld": "24/08/12 6:03 PM",
      "commitNameOld": "deead78e35b0cb81af875b5a8032cbd06c9a2dae",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 6.89,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,82 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n \n     httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                 infoPort \u003d\u003d 0, conf,\n                                 new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n       {\n         // Add SPNEGO support to NameNode\n         if (UserGroupInformation.isSecurityEnabled()) {\n           initSpnego(conf,\n               DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n               DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n         }\n         if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n           //add SPNEGO authentication filter for webhdfs\n           final String name \u003d \"SPNEGO\";\n           final String classname \u003d AuthFilter.class.getName();\n           final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n           Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n           defineFilter(webAppContext, name, classname, params,\n                        new String[]{pathSpec});\n           LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n           // add webhdfs packages\n           addJerseyResourcePackage(\n             NamenodeWebHdfsMethods.class.getPackage().getName()\n             + \";\" + Param.class.getPackage().getName(), pathSpec);\n         }\n       }\n \n       private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n         throws IOException {\n         Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n         String principalInConf \u003d conf\n           .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n         if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n           params\n             .put(\n               DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n               SecurityUtil.getServerPrincipal(principalInConf,\n                                               bindAddress.getHostName()));\n         }\n-        String httpKeytab \u003d conf\n-          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n+        String httpKeytab \u003d conf.get(\n+          DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n+        if (httpKeytab \u003d\u003d null) {\n+          httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n+        }\n         if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n           params.put(\n             DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n             httpKeytab);\n         }\n         return params;\n       }\n     };\n \n     boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n       InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n         \"dfs.https.port\", infoHost + \":\" + 0));\n       Configuration sslConf \u003d new Configuration(false);\n       if (certSSL) {\n         sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                      \"ssl-server.xml\"));\n       }\n       httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n       httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n         .getPort());\n     }\n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY, nn.getNameNodeAddress());\n     httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n     httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n\n    httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                infoPort \u003d\u003d 0, conf,\n                                new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n      {\n        // Add SPNEGO support to NameNode\n        if (UserGroupInformation.isSecurityEnabled()) {\n          initSpnego(conf,\n              DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n              DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n        }\n        if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n          //add SPNEGO authentication filter for webhdfs\n          final String name \u003d \"SPNEGO\";\n          final String classname \u003d AuthFilter.class.getName();\n          final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n          Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n          defineFilter(webAppContext, name, classname, params,\n                       new String[]{pathSpec});\n          LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n          // add webhdfs packages\n          addJerseyResourcePackage(\n            NamenodeWebHdfsMethods.class.getPackage().getName()\n            + \";\" + Param.class.getPackage().getName(), pathSpec);\n        }\n      }\n\n      private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n        throws IOException {\n        Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n        String principalInConf \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n        if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n          params\n            .put(\n              DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n              SecurityUtil.getServerPrincipal(principalInConf,\n                                              bindAddress.getHostName()));\n        }\n        String httpKeytab \u003d conf.get(\n          DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n        if (httpKeytab \u003d\u003d null) {\n          httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n        }\n        if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n          params.put(\n            DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n            httpKeytab);\n        }\n        return params;\n      }\n    };\n\n    boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n        \"dfs.https.port\", infoHost + \":\" + 0));\n      Configuration sslConf \u003d new Configuration(false);\n      if (certSSL) {\n        sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                     \"ssl-server.xml\"));\n      }\n      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n      httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY, nn.getNameNodeAddress());\n    httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "5770a453f304d83463879db6101da1f1e81e5563": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3572. Cleanup code which inits SPNEGO in HttpServer. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1354767 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/06/12 3:41 PM",
      "commitName": "5770a453f304d83463879db6101da1f1e81e5563",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "17/05/12 10:01 AM",
      "commitNameOld": "5ef725eb5369215fbca5d8067da6ec4255cc98db",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 41.24,
      "commitsBetweenForRepo": 169,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,79 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n \n     httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                 infoPort \u003d\u003d 0, conf,\n                                 new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n       {\n         // Add SPNEGO support to NameNode\n         if (UserGroupInformation.isSecurityEnabled()) {\n-          Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n-          String principalInConf \u003d conf.get(\n-            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPENGO_USER_NAME_KEY);\n-          if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n-            params.put(\"kerberos.principal\",\n-                       SecurityUtil.getServerPrincipal(principalInConf, infoHost));\n-            String httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n-            if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n-              params.put(\"kerberos.keytab\", httpKeytab);\n-            }\n-\n-            params.put(AuthenticationFilter.AUTH_TYPE, \"kerberos\");\n-\n-            defineFilter(webAppContext, SPNEGO_FILTER,\n-                         AuthenticationFilter.class.getName(), params, null);\n-          }\n+          initSpnego(conf,\n+              DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n+              DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n         }\n         if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n           //add SPNEGO authentication filter for webhdfs\n           final String name \u003d \"SPNEGO\";\n           final String classname \u003d AuthFilter.class.getName();\n           final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n           Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n           defineFilter(webAppContext, name, classname, params,\n                        new String[]{pathSpec});\n           LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n           // add webhdfs packages\n           addJerseyResourcePackage(\n             NamenodeWebHdfsMethods.class.getPackage().getName()\n             + \";\" + Param.class.getPackage().getName(), pathSpec);\n         }\n       }\n \n       private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n         throws IOException {\n         Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n         String principalInConf \u003d conf\n           .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n         if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n           params\n             .put(\n               DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n               SecurityUtil.getServerPrincipal(principalInConf,\n                                               bindAddress.getHostName()));\n         }\n         String httpKeytab \u003d conf\n           .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n         if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n           params.put(\n             DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n             httpKeytab);\n         }\n         return params;\n       }\n     };\n \n     boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n       InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n         \"dfs.https.port\", infoHost + \":\" + 0));\n       Configuration sslConf \u003d new Configuration(false);\n       if (certSSL) {\n         sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                      \"ssl-server.xml\"));\n       }\n       httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n       httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n         .getPort());\n     }\n     httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n     httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY, nn.getNameNodeAddress());\n     httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n     httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n\n    httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                infoPort \u003d\u003d 0, conf,\n                                new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n      {\n        // Add SPNEGO support to NameNode\n        if (UserGroupInformation.isSecurityEnabled()) {\n          initSpnego(conf,\n              DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPNEGO_USER_NAME_KEY,\n              DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n        }\n        if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n          //add SPNEGO authentication filter for webhdfs\n          final String name \u003d \"SPNEGO\";\n          final String classname \u003d AuthFilter.class.getName();\n          final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n          Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n          defineFilter(webAppContext, name, classname, params,\n                       new String[]{pathSpec});\n          LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n          // add webhdfs packages\n          addJerseyResourcePackage(\n            NamenodeWebHdfsMethods.class.getPackage().getName()\n            + \";\" + Param.class.getPackage().getName(), pathSpec);\n        }\n      }\n\n      private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n        throws IOException {\n        Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n        String principalInConf \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n        if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n          params\n            .put(\n              DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n              SecurityUtil.getServerPrincipal(principalInConf,\n                                              bindAddress.getHostName()));\n        }\n        String httpKeytab \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n        if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n          params.put(\n            DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n            httpKeytab);\n        }\n        return params;\n      }\n    };\n\n    boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n        \"dfs.https.port\", infoHost + \":\" + 0));\n      Configuration sslConf \u003d new Configuration(false);\n      if (certSSL) {\n        sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                     \"ssl-server.xml\"));\n      }\n      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n      httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY, nn.getNameNodeAddress());\n    httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "5ef725eb5369215fbca5d8067da6ec4255cc98db": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3434. InvalidProtocolBufferException when visiting DN browseDirectory.jsp. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1339712 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/05/12 10:01 AM",
      "commitName": "5ef725eb5369215fbca5d8067da6ec4255cc98db",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "04/05/12 2:58 PM",
      "commitNameOld": "5dbbe0e0a5d31689d3425e490865f95057dc051c",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 12.79,
      "commitsBetweenForRepo": 81,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     int infoPort \u003d bindAddress.getPort();\n \n     httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                 infoPort \u003d\u003d 0, conf,\n                                 new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n       {\n         // Add SPNEGO support to NameNode\n         if (UserGroupInformation.isSecurityEnabled()) {\n           Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n           String principalInConf \u003d conf.get(\n             DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPENGO_USER_NAME_KEY);\n           if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n             params.put(\"kerberos.principal\",\n                        SecurityUtil.getServerPrincipal(principalInConf, infoHost));\n             String httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n             if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n               params.put(\"kerberos.keytab\", httpKeytab);\n             }\n \n             params.put(AuthenticationFilter.AUTH_TYPE, \"kerberos\");\n \n             defineFilter(webAppContext, SPNEGO_FILTER,\n                          AuthenticationFilter.class.getName(), params, null);\n           }\n         }\n         if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n           //add SPNEGO authentication filter for webhdfs\n           final String name \u003d \"SPNEGO\";\n           final String classname \u003d AuthFilter.class.getName();\n           final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n           Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n           defineFilter(webAppContext, name, classname, params,\n                        new String[]{pathSpec});\n           LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n           // add webhdfs packages\n           addJerseyResourcePackage(\n             NamenodeWebHdfsMethods.class.getPackage().getName()\n             + \";\" + Param.class.getPackage().getName(), pathSpec);\n         }\n       }\n \n       private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n         throws IOException {\n         Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n         String principalInConf \u003d conf\n           .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n         if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n           params\n             .put(\n               DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n               SecurityUtil.getServerPrincipal(principalInConf,\n                                               bindAddress.getHostName()));\n         }\n         String httpKeytab \u003d conf\n           .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n         if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n           params.put(\n             DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n             httpKeytab);\n         }\n         return params;\n       }\n     };\n \n     boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n     if (certSSL) {\n       boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n       InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n         \"dfs.https.port\", infoHost + \":\" + 0));\n       Configuration sslConf \u003d new Configuration(false);\n       if (certSSL) {\n         sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                      \"ssl-server.xml\"));\n       }\n       httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n       // assume same ssl port for all datanodes\n       InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n         \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n       httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n         .getPort());\n     }\n-    httpServer.setAttribute(\"name.node\", nn);\n-    httpServer.setAttribute(\"name.node.address\", bindAddress);\n-    httpServer.setAttribute(\"name.system.image\", nn.getFSImage());\n+    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n+    httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY, nn.getNameNodeAddress());\n+    httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n     httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n     setupServlets(httpServer, conf);\n     httpServer.start();\n     httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n\n    httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                infoPort \u003d\u003d 0, conf,\n                                new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n      {\n        // Add SPNEGO support to NameNode\n        if (UserGroupInformation.isSecurityEnabled()) {\n          Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n          String principalInConf \u003d conf.get(\n            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPENGO_USER_NAME_KEY);\n          if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n            params.put(\"kerberos.principal\",\n                       SecurityUtil.getServerPrincipal(principalInConf, infoHost));\n            String httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n            if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n              params.put(\"kerberos.keytab\", httpKeytab);\n            }\n\n            params.put(AuthenticationFilter.AUTH_TYPE, \"kerberos\");\n\n            defineFilter(webAppContext, SPNEGO_FILTER,\n                         AuthenticationFilter.class.getName(), params, null);\n          }\n        }\n        if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n          //add SPNEGO authentication filter for webhdfs\n          final String name \u003d \"SPNEGO\";\n          final String classname \u003d AuthFilter.class.getName();\n          final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n          Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n          defineFilter(webAppContext, name, classname, params,\n                       new String[]{pathSpec});\n          LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n          // add webhdfs packages\n          addJerseyResourcePackage(\n            NamenodeWebHdfsMethods.class.getPackage().getName()\n            + \";\" + Param.class.getPackage().getName(), pathSpec);\n        }\n      }\n\n      private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n        throws IOException {\n        Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n        String principalInConf \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n        if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n          params\n            .put(\n              DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n              SecurityUtil.getServerPrincipal(principalInConf,\n                                              bindAddress.getHostName()));\n        }\n        String httpKeytab \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n        if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n          params.put(\n            DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n            httpKeytab);\n        }\n        return params;\n      }\n    };\n\n    boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n        \"dfs.https.port\", infoHost + \":\" + 0));\n      Configuration sslConf \u003d new Configuration(false);\n      if (certSSL) {\n        sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                     \"ssl-server.xml\"));\n      }\n      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n      httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n    httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY, nn.getNameNodeAddress());\n    httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "5dbbe0e0a5d31689d3425e490865f95057dc051c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2617. Replaced Kerberized SSL for image transfer and fsck with SPNEGO-based solution. Contributed by Jakob Homan, Alejandro Abdelnur, and Aaron T. Myers\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1334216 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/05/12 2:58 PM",
      "commitName": "5dbbe0e0a5d31689d3425e490865f95057dc051c",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "05/04/12 5:20 PM",
      "commitNameOld": "e505b7e704ff83893a40190695977ce1393f6248",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 28.9,
      "commitsBetweenForRepo": 209,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,92 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n-    \n-    if(UserGroupInformation.isSecurityEnabled()) {\n-      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n-          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n-      if (httpsUser \u003d\u003d null) {\n-        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n-            + \" not defined in config. Starting http server as \"\n-            + getDefaultServerPrincipal()\n-            + \": Kerberized SSL may be not function correctly.\");\n-      } else {\n-        // Kerberized SSL servers must be run from the host principal...\n-        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n-        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n-            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n-      }\n-    }\n+    int infoPort \u003d bindAddress.getPort();\n \n-    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n-    try {\n-      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n-        @Override\n-        public HttpServer run() throws IOException, InterruptedException {\n-          int infoPort \u003d bindAddress.getPort();\n-          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n-              infoPort \u003d\u003d 0, conf, \n-              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n-            {\n-              if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n-                //add SPNEGO authentication filter for webhdfs\n-                final String name \u003d \"SPNEGO\";\n-                final String classname \u003d  AuthFilter.class.getName();\n-                final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n-                Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n-                defineFilter(webAppContext, name, classname, params,\n-                    new String[]{pathSpec});\n-                LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n-\n-                // add webhdfs packages\n-                addJerseyResourcePackage(\n-                    NamenodeWebHdfsMethods.class.getPackage().getName()\n-                    + \";\" + Param.class.getPackage().getName(), pathSpec);\n-              }\n+    httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n+                                infoPort \u003d\u003d 0, conf,\n+                                new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n+      {\n+        // Add SPNEGO support to NameNode\n+        if (UserGroupInformation.isSecurityEnabled()) {\n+          Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n+          String principalInConf \u003d conf.get(\n+            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPENGO_USER_NAME_KEY);\n+          if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n+            params.put(\"kerberos.principal\",\n+                       SecurityUtil.getServerPrincipal(principalInConf, infoHost));\n+            String httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n+            if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n+              params.put(\"kerberos.keytab\", httpKeytab);\n             }\n \n-            private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n-                throws IOException {\n-              Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n-              String principalInConf \u003d conf\n-                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n-              if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n-                params\n-                    .put(\n-                        DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n-                        SecurityUtil.getServerPrincipal(principalInConf,\n-                            infoHost));\n-              }\n-              String httpKeytab \u003d conf\n-                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n-              if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n-                params.put(\n-                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n-                    httpKeytab);\n-              }\n-              return params;\n-            }\n-          };\n+            params.put(AuthenticationFilter.AUTH_TYPE, \"kerberos\");\n \n-          boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n-          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n-          if (certSSL || useKrb) {\n-            boolean needClientAuth \u003d conf.getBoolean(\n-                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n-                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n-            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n-                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n-                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n-            Configuration sslConf \u003d new HdfsConfiguration(false);\n-            if (certSSL) {\n-              sslConf.addResource(conf.get(DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n-                  DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n-            }\n-            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n-                useKrb);\n-            // assume same ssl port for all datanodes\n-            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(\n-                conf.get(DFS_DATANODE_HTTPS_ADDRESS_KEY,\n-                    infoHost + \":\" + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n-            httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n-                datanodeSslPort.getPort());\n+            defineFilter(webAppContext, SPNEGO_FILTER,\n+                         AuthenticationFilter.class.getName(), params, null);\n           }\n-          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n-          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n-              nn.getNameNodeAddress());\n-          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n-          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n-          setupServlets(httpServer, conf);\n-          httpServer.start();\n-\n-          // The web-server port can be ephemeral... ensure we have the correct\n-          // info\n-          infoPort \u003d httpServer.getPort();\n-          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n-          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n-          return httpServer;\n         }\n-      });\n-    } catch (InterruptedException e) {\n-      throw new IOException(e);\n-    } finally {\n-      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n-          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n-        // Go back to being the correct Namenode principal\n-        LOG.info(\"Logging back in as NameNode user following http server start\");\n-        nn.loginAsNameNodeUser(conf);\n+        if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n+          //add SPNEGO authentication filter for webhdfs\n+          final String name \u003d \"SPNEGO\";\n+          final String classname \u003d AuthFilter.class.getName();\n+          final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n+          Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n+          defineFilter(webAppContext, name, classname, params,\n+                       new String[]{pathSpec});\n+          LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n+\n+          // add webhdfs packages\n+          addJerseyResourcePackage(\n+            NamenodeWebHdfsMethods.class.getPackage().getName()\n+            + \";\" + Param.class.getPackage().getName(), pathSpec);\n+        }\n       }\n+\n+      private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n+        throws IOException {\n+        Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n+        String principalInConf \u003d conf\n+          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n+        if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n+          params\n+            .put(\n+              DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n+              SecurityUtil.getServerPrincipal(principalInConf,\n+                                              bindAddress.getHostName()));\n+        }\n+        String httpKeytab \u003d conf\n+          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n+        if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n+          params.put(\n+            DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n+            httpKeytab);\n+        }\n+        return params;\n+      }\n+    };\n+\n+    boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n+    if (certSSL) {\n+      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n+      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n+        \"dfs.https.port\", infoHost + \":\" + 0));\n+      Configuration sslConf \u003d new Configuration(false);\n+      if (certSSL) {\n+        sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n+                                     \"ssl-server.xml\"));\n+      }\n+      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n+      // assume same ssl port for all datanodes\n+      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n+        \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n+      httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n+        .getPort());\n     }\n+    httpServer.setAttribute(\"name.node\", nn);\n+    httpServer.setAttribute(\"name.node.address\", bindAddress);\n+    httpServer.setAttribute(\"name.system.image\", nn.getFSImage());\n+    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n+    setupServlets(httpServer, conf);\n+    httpServer.start();\n+    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    int infoPort \u003d bindAddress.getPort();\n\n    httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n                                infoPort \u003d\u003d 0, conf,\n                                new AccessControlList(conf.get(DFS_ADMIN, \" \"))) {\n      {\n        // Add SPNEGO support to NameNode\n        if (UserGroupInformation.isSecurityEnabled()) {\n          Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n          String principalInConf \u003d conf.get(\n            DFSConfigKeys.DFS_NAMENODE_INTERNAL_SPENGO_USER_NAME_KEY);\n          if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n            params.put(\"kerberos.principal\",\n                       SecurityUtil.getServerPrincipal(principalInConf, infoHost));\n            String httpKeytab \u003d conf.get(DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY);\n            if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n              params.put(\"kerberos.keytab\", httpKeytab);\n            }\n\n            params.put(AuthenticationFilter.AUTH_TYPE, \"kerberos\");\n\n            defineFilter(webAppContext, SPNEGO_FILTER,\n                         AuthenticationFilter.class.getName(), params, null);\n          }\n        }\n        if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n          //add SPNEGO authentication filter for webhdfs\n          final String name \u003d \"SPNEGO\";\n          final String classname \u003d AuthFilter.class.getName();\n          final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n          Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n          defineFilter(webAppContext, name, classname, params,\n                       new String[]{pathSpec});\n          LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n          // add webhdfs packages\n          addJerseyResourcePackage(\n            NamenodeWebHdfsMethods.class.getPackage().getName()\n            + \";\" + Param.class.getPackage().getName(), pathSpec);\n        }\n      }\n\n      private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n        throws IOException {\n        Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n        String principalInConf \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n        if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n          params\n            .put(\n              DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n              SecurityUtil.getServerPrincipal(principalInConf,\n                                              bindAddress.getHostName()));\n        }\n        String httpKeytab \u003d conf\n          .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n        if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n          params.put(\n            DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n            httpKeytab);\n        }\n        return params;\n      }\n    };\n\n    boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n    if (certSSL) {\n      boolean needClientAuth \u003d conf.getBoolean(\"dfs.https.need.client.auth\", false);\n      InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(infoHost + \":\" + conf.get(\n        \"dfs.https.port\", infoHost + \":\" + 0));\n      Configuration sslConf \u003d new Configuration(false);\n      if (certSSL) {\n        sslConf.addResource(conf.get(\"dfs.https.server.keystore.resource\",\n                                     \"ssl-server.xml\"));\n      }\n      httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth);\n      // assume same ssl port for all datanodes\n      InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf.get(\n        \"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n      httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n        .getPort());\n    }\n    httpServer.setAttribute(\"name.node\", nn);\n    httpServer.setAttribute(\"name.node.address\", bindAddress);\n    httpServer.setAttribute(\"name.system.image\", nn.getFSImage());\n    httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n    setupServlets(httpServer, conf);\n    httpServer.start();\n    httpAddress \u003d new InetSocketAddress(bindAddress.getAddress(), httpServer.getPort());\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "e505b7e704ff83893a40190695977ce1393f6248": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3208. Bogus entries in hosts files are incorrectly displayed in the report. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1310138 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/04/12 5:20 PM",
      "commitName": "e505b7e704ff83893a40190695977ce1393f6248",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "11/12/11 10:53 AM",
      "commitNameOld": "2740112bb64e1cc8132a1dc450d9e461c2e4729e",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 116.23,
      "commitsBetweenForRepo": 855,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,119 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     \n     if(UserGroupInformation.isSecurityEnabled()) {\n       String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n           .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n       if (httpsUser \u003d\u003d null) {\n         LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n             + \" not defined in config. Starting http server as \"\n             + getDefaultServerPrincipal()\n             + \": Kerberized SSL may be not function correctly.\");\n       } else {\n         // Kerberized SSL servers must be run from the host principal...\n         LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n         SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n             DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n       }\n     }\n \n     UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n     try {\n       this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n         @Override\n         public HttpServer run() throws IOException, InterruptedException {\n           int infoPort \u003d bindAddress.getPort();\n           httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n               infoPort \u003d\u003d 0, conf, \n               new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n             {\n               if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n                 //add SPNEGO authentication filter for webhdfs\n                 final String name \u003d \"SPNEGO\";\n                 final String classname \u003d  AuthFilter.class.getName();\n                 final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n                 Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n                 defineFilter(webAppContext, name, classname, params,\n                     new String[]{pathSpec});\n                 LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n                 // add webhdfs packages\n                 addJerseyResourcePackage(\n                     NamenodeWebHdfsMethods.class.getPackage().getName()\n                     + \";\" + Param.class.getPackage().getName(), pathSpec);\n               }\n             }\n \n             private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n                 throws IOException {\n               Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n               String principalInConf \u003d conf\n                   .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n               if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n                 params\n                     .put(\n                         DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n                         SecurityUtil.getServerPrincipal(principalInConf,\n                             infoHost));\n               }\n               String httpKeytab \u003d conf\n                   .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n               if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n                 params.put(\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n                     httpKeytab);\n               }\n               return params;\n             }\n           };\n \n           boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n           boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n           if (certSSL || useKrb) {\n             boolean needClientAuth \u003d conf.getBoolean(\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n             InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                 .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                     DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n             Configuration sslConf \u003d new HdfsConfiguration(false);\n             if (certSSL) {\n               sslConf.addResource(conf.get(DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n                   DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n             }\n             httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                 useKrb);\n             // assume same ssl port for all datanodes\n-            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n-                .get(DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n-            httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n-                .getPort());\n+            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(\n+                conf.get(DFS_DATANODE_HTTPS_ADDRESS_KEY,\n+                    infoHost + \":\" + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n+            httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n+                datanodeSslPort.getPort());\n           }\n           httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n           httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n               nn.getNameNodeAddress());\n           httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n           httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n           setupServlets(httpServer, conf);\n           httpServer.start();\n \n           // The web-server port can be ephemeral... ensure we have the correct\n           // info\n           infoPort \u003d httpServer.getPort();\n           httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n           LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n           return httpServer;\n         }\n       });\n     } catch (InterruptedException e) {\n       throw new IOException(e);\n     } finally {\n       if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n           conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n         // Go back to being the correct Namenode principal\n         LOG.info(\"Logging back in as NameNode user following http server start\");\n         nn.loginAsNameNodeUser(conf);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    \n    if(UserGroupInformation.isSecurityEnabled()) {\n      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n      if (httpsUser \u003d\u003d null) {\n        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n            + \" not defined in config. Starting http server as \"\n            + getDefaultServerPrincipal()\n            + \": Kerberized SSL may be not function correctly.\");\n      } else {\n        // Kerberized SSL servers must be run from the host principal...\n        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n      }\n    }\n\n    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n    try {\n      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n        @Override\n        public HttpServer run() throws IOException, InterruptedException {\n          int infoPort \u003d bindAddress.getPort();\n          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n              infoPort \u003d\u003d 0, conf, \n              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n            {\n              if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n                //add SPNEGO authentication filter for webhdfs\n                final String name \u003d \"SPNEGO\";\n                final String classname \u003d  AuthFilter.class.getName();\n                final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n                Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n                defineFilter(webAppContext, name, classname, params,\n                    new String[]{pathSpec});\n                LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n                // add webhdfs packages\n                addJerseyResourcePackage(\n                    NamenodeWebHdfsMethods.class.getPackage().getName()\n                    + \";\" + Param.class.getPackage().getName(), pathSpec);\n              }\n            }\n\n            private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n                throws IOException {\n              Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n              String principalInConf \u003d conf\n                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n              if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n                params\n                    .put(\n                        DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n                        SecurityUtil.getServerPrincipal(principalInConf,\n                            infoHost));\n              }\n              String httpKeytab \u003d conf\n                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n              if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n                params.put(\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n                    httpKeytab);\n              }\n              return params;\n            }\n          };\n\n          boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n          if (certSSL || useKrb) {\n            boolean needClientAuth \u003d conf.getBoolean(\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n            Configuration sslConf \u003d new HdfsConfiguration(false);\n            if (certSSL) {\n              sslConf.addResource(conf.get(DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n                  DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n            }\n            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                useKrb);\n            // assume same ssl port for all datanodes\n            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(\n                conf.get(DFS_DATANODE_HTTPS_ADDRESS_KEY,\n                    infoHost + \":\" + DFSConfigKeys.DFS_DATANODE_HTTPS_DEFAULT_PORT));\n            httpServer.setAttribute(DFSConfigKeys.DFS_DATANODE_HTTPS_PORT_KEY,\n                datanodeSslPort.getPort());\n          }\n          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n              nn.getNameNodeAddress());\n          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n          setupServlets(httpServer, conf);\n          httpServer.start();\n\n          // The web-server port can be ephemeral... ensure we have the correct\n          // info\n          infoPort \u003d httpServer.getPort();\n          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n          return httpServer;\n        }\n      });\n    } catch (InterruptedException e) {\n      throw new IOException(e);\n    } finally {\n      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n        // Go back to being the correct Namenode principal\n        LOG.info(\"Logging back in as NameNode user following http server start\");\n        nn.loginAsNameNodeUser(conf);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "0398a9e88dacf81068f2786f28a9127e02b203d7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2604. Add a log message to show if WebHDFS is enabled and a configuration section in the forrest doc. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208140 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/11/11 3:38 PM",
      "commitName": "0398a9e88dacf81068f2786f28a9127e02b203d7",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "21/11/11 3:49 PM",
      "commitNameOld": "52937609733fb25bc19c9bd6df2e1ca544973860",
      "commitAuthorOld": "Suresh Srinivas",
      "daysBetweenCommits": 7.99,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,118 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     \n     if(UserGroupInformation.isSecurityEnabled()) {\n       String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n           .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n       if (httpsUser \u003d\u003d null) {\n         LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n             + \" not defined in config. Starting http server as \"\n             + getDefaultServerPrincipal()\n             + \": Kerberized SSL may be not function correctly.\");\n       } else {\n         // Kerberized SSL servers must be run from the host principal...\n         LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n         SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n             DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n       }\n     }\n \n     UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n     try {\n       this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n         @Override\n         public HttpServer run() throws IOException, InterruptedException {\n           int infoPort \u003d bindAddress.getPort();\n           httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n               infoPort \u003d\u003d 0, conf, \n               new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n             {\n-              if (conf.getBoolean(DFSConfigKeys.DFS_WEBHDFS_ENABLED_KEY,\n-                  DFSConfigKeys.DFS_WEBHDFS_ENABLED_DEFAULT)) {\n+              if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n                 //add SPNEGO authentication filter for webhdfs\n                 final String name \u003d \"SPNEGO\";\n                 final String classname \u003d  AuthFilter.class.getName();\n                 final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n                 Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n                 defineFilter(webAppContext, name, classname, params,\n                     new String[]{pathSpec});\n                 LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n                 // add webhdfs packages\n                 addJerseyResourcePackage(\n                     NamenodeWebHdfsMethods.class.getPackage().getName()\n                     + \";\" + Param.class.getPackage().getName(), pathSpec);\n               }\n             }\n \n             private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n                 throws IOException {\n               Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n               String principalInConf \u003d conf\n                   .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n               if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n                 params\n                     .put(\n                         DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n                         SecurityUtil.getServerPrincipal(principalInConf,\n                             infoHost));\n               }\n               String httpKeytab \u003d conf\n                   .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n               if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n                 params.put(\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n                     httpKeytab);\n               }\n               return params;\n             }\n           };\n \n           boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n           boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n           if (certSSL || useKrb) {\n             boolean needClientAuth \u003d conf.getBoolean(\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n             InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                 .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                     DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n             Configuration sslConf \u003d new HdfsConfiguration(false);\n             if (certSSL) {\n               sslConf.addResource(conf.get(DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n                   DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n             }\n             httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                 useKrb);\n             // assume same ssl port for all datanodes\n             InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                 .get(DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n             httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                 .getPort());\n           }\n           httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n           httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n               nn.getNameNodeAddress());\n           httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n           httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n           setupServlets(httpServer, conf);\n           httpServer.start();\n \n           // The web-server port can be ephemeral... ensure we have the correct\n           // info\n           infoPort \u003d httpServer.getPort();\n           httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n           LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n           return httpServer;\n         }\n       });\n     } catch (InterruptedException e) {\n       throw new IOException(e);\n     } finally {\n       if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n           conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n         // Go back to being the correct Namenode principal\n         LOG.info(\"Logging back in as NameNode user following http server start\");\n         nn.loginAsNameNodeUser(conf);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    \n    if(UserGroupInformation.isSecurityEnabled()) {\n      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n      if (httpsUser \u003d\u003d null) {\n        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n            + \" not defined in config. Starting http server as \"\n            + getDefaultServerPrincipal()\n            + \": Kerberized SSL may be not function correctly.\");\n      } else {\n        // Kerberized SSL servers must be run from the host principal...\n        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n      }\n    }\n\n    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n    try {\n      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n        @Override\n        public HttpServer run() throws IOException, InterruptedException {\n          int infoPort \u003d bindAddress.getPort();\n          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n              infoPort \u003d\u003d 0, conf, \n              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n            {\n              if (WebHdfsFileSystem.isEnabled(conf, LOG)) {\n                //add SPNEGO authentication filter for webhdfs\n                final String name \u003d \"SPNEGO\";\n                final String classname \u003d  AuthFilter.class.getName();\n                final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n                Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n                defineFilter(webAppContext, name, classname, params,\n                    new String[]{pathSpec});\n                LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n                // add webhdfs packages\n                addJerseyResourcePackage(\n                    NamenodeWebHdfsMethods.class.getPackage().getName()\n                    + \";\" + Param.class.getPackage().getName(), pathSpec);\n              }\n            }\n\n            private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n                throws IOException {\n              Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n              String principalInConf \u003d conf\n                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n              if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n                params\n                    .put(\n                        DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n                        SecurityUtil.getServerPrincipal(principalInConf,\n                            infoHost));\n              }\n              String httpKeytab \u003d conf\n                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n              if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n                params.put(\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n                    httpKeytab);\n              }\n              return params;\n            }\n          };\n\n          boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n          if (certSSL || useKrb) {\n            boolean needClientAuth \u003d conf.getBoolean(\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n            Configuration sslConf \u003d new HdfsConfiguration(false);\n            if (certSSL) {\n              sslConf.addResource(conf.get(DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n                  DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n            }\n            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                useKrb);\n            // assume same ssl port for all datanodes\n            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                .get(DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n            httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                .getPort());\n          }\n          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n              nn.getNameNodeAddress());\n          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n          setupServlets(httpServer, conf);\n          httpServer.start();\n\n          // The web-server port can be ephemeral... ensure we have the correct\n          // info\n          infoPort \u003d httpServer.getPort();\n          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n          return httpServer;\n        }\n      });\n    } catch (InterruptedException e) {\n      throw new IOException(e);\n    } finally {\n      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n        // Go back to being the correct Namenode principal\n        LOG.info(\"Logging back in as NameNode user following http server start\");\n        nn.loginAsNameNodeUser(conf);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "52937609733fb25bc19c9bd6df2e1ca544973860": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2410. Further cleanup of hardcoded configuration keys and values. Contributed by Suresh Srinivas.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1204753 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/11/11 3:49 PM",
      "commitName": "52937609733fb25bc19c9bd6df2e1ca544973860",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "26/10/11 11:15 AM",
      "commitNameOld": "8534e70044ebd35c80a2bdff509adef85cb8d61c",
      "commitAuthorOld": "Jitendra Nath Pandey",
      "daysBetweenCommits": 26.23,
      "commitsBetweenForRepo": 193,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,119 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     \n     if(UserGroupInformation.isSecurityEnabled()) {\n       String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n           .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n       if (httpsUser \u003d\u003d null) {\n         LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n             + \" not defined in config. Starting http server as \"\n             + getDefaultServerPrincipal()\n             + \": Kerberized SSL may be not function correctly.\");\n       } else {\n         // Kerberized SSL servers must be run from the host principal...\n         LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n         SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n             DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n       }\n     }\n \n     UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n     try {\n       this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n         @Override\n         public HttpServer run() throws IOException, InterruptedException {\n           int infoPort \u003d bindAddress.getPort();\n           httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n               infoPort \u003d\u003d 0, conf, \n               new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n             {\n               if (conf.getBoolean(DFSConfigKeys.DFS_WEBHDFS_ENABLED_KEY,\n                   DFSConfigKeys.DFS_WEBHDFS_ENABLED_DEFAULT)) {\n                 //add SPNEGO authentication filter for webhdfs\n                 final String name \u003d \"SPNEGO\";\n                 final String classname \u003d  AuthFilter.class.getName();\n                 final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n                 Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n                 defineFilter(webAppContext, name, classname, params,\n                     new String[]{pathSpec});\n                 LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n                 // add webhdfs packages\n                 addJerseyResourcePackage(\n                     NamenodeWebHdfsMethods.class.getPackage().getName()\n                     + \";\" + Param.class.getPackage().getName(), pathSpec);\n               }\n             }\n \n             private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n                 throws IOException {\n               Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n               String principalInConf \u003d conf\n                   .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n               if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n                 params\n                     .put(\n                         DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n                         SecurityUtil.getServerPrincipal(principalInConf,\n                             infoHost));\n               }\n               String httpKeytab \u003d conf\n                   .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n               if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n                 params.put(\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n                     httpKeytab);\n               }\n               return params;\n             }\n           };\n \n-          boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n+          boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n           boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n           if (certSSL || useKrb) {\n             boolean needClientAuth \u003d conf.getBoolean(\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n             InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                 .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                     DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n             Configuration sslConf \u003d new HdfsConfiguration(false);\n             if (certSSL) {\n-              sslConf.addResource(conf.get(\n-                  \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n+              sslConf.addResource(conf.get(DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n+                  DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n             }\n             httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                 useKrb);\n             // assume same ssl port for all datanodes\n             InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n-                .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n+                .get(DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n             httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                 .getPort());\n           }\n           httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n           httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n               nn.getNameNodeAddress());\n           httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n           httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n           setupServlets(httpServer, conf);\n           httpServer.start();\n \n           // The web-server port can be ephemeral... ensure we have the correct\n           // info\n           infoPort \u003d httpServer.getPort();\n           httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n           LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n           return httpServer;\n         }\n       });\n     } catch (InterruptedException e) {\n       throw new IOException(e);\n     } finally {\n       if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n           conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n         // Go back to being the correct Namenode principal\n         LOG.info(\"Logging back in as NameNode user following http server start\");\n         nn.loginAsNameNodeUser(conf);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    \n    if(UserGroupInformation.isSecurityEnabled()) {\n      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n      if (httpsUser \u003d\u003d null) {\n        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n            + \" not defined in config. Starting http server as \"\n            + getDefaultServerPrincipal()\n            + \": Kerberized SSL may be not function correctly.\");\n      } else {\n        // Kerberized SSL servers must be run from the host principal...\n        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n      }\n    }\n\n    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n    try {\n      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n        @Override\n        public HttpServer run() throws IOException, InterruptedException {\n          int infoPort \u003d bindAddress.getPort();\n          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n              infoPort \u003d\u003d 0, conf, \n              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n            {\n              if (conf.getBoolean(DFSConfigKeys.DFS_WEBHDFS_ENABLED_KEY,\n                  DFSConfigKeys.DFS_WEBHDFS_ENABLED_DEFAULT)) {\n                //add SPNEGO authentication filter for webhdfs\n                final String name \u003d \"SPNEGO\";\n                final String classname \u003d  AuthFilter.class.getName();\n                final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n                Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n                defineFilter(webAppContext, name, classname, params,\n                    new String[]{pathSpec});\n                LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n                // add webhdfs packages\n                addJerseyResourcePackage(\n                    NamenodeWebHdfsMethods.class.getPackage().getName()\n                    + \";\" + Param.class.getPackage().getName(), pathSpec);\n              }\n            }\n\n            private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n                throws IOException {\n              Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n              String principalInConf \u003d conf\n                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n              if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n                params\n                    .put(\n                        DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n                        SecurityUtil.getServerPrincipal(principalInConf,\n                            infoHost));\n              }\n              String httpKeytab \u003d conf\n                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n              if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n                params.put(\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n                    httpKeytab);\n              }\n              return params;\n            }\n          };\n\n          boolean certSSL \u003d conf.getBoolean(DFSConfigKeys.DFS_HTTPS_ENABLE_KEY, false);\n          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n          if (certSSL || useKrb) {\n            boolean needClientAuth \u003d conf.getBoolean(\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n            Configuration sslConf \u003d new HdfsConfiguration(false);\n            if (certSSL) {\n              sslConf.addResource(conf.get(DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY,\n                  DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_DEFAULT));\n            }\n            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                useKrb);\n            // assume same ssl port for all datanodes\n            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                .get(DFS_DATANODE_HTTPS_ADDRESS_KEY, infoHost + \":\" + 50475));\n            httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                .getPort());\n          }\n          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n              nn.getNameNodeAddress());\n          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n          setupServlets(httpServer, conf);\n          httpServer.start();\n\n          // The web-server port can be ephemeral... ensure we have the correct\n          // info\n          infoPort \u003d httpServer.getPort();\n          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n          return httpServer;\n        }\n      });\n    } catch (InterruptedException e) {\n      throw new IOException(e);\n    } finally {\n      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n        // Go back to being the correct Namenode principal\n        LOG.info(\"Logging back in as NameNode user following http server start\");\n        nn.loginAsNameNodeUser(conf);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "8534e70044ebd35c80a2bdff509adef85cb8d61c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2411. The auth to local mappings are not respected with webhdfs and security enabled.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189355 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/10/11 11:15 AM",
      "commitName": "8534e70044ebd35c80a2bdff509adef85cb8d61c",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "25/10/11 10:16 PM",
      "commitNameOld": "8335995630e2c4288795fa0dfa9b670090a6790b",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.54,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,119 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     \n     if(UserGroupInformation.isSecurityEnabled()) {\n       String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n           .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n       if (httpsUser \u003d\u003d null) {\n         LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n             + \" not defined in config. Starting http server as \"\n             + getDefaultServerPrincipal()\n             + \": Kerberized SSL may be not function correctly.\");\n       } else {\n         // Kerberized SSL servers must be run from the host principal...\n         LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n         SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n             DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n       }\n     }\n \n     UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n     try {\n       this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n         @Override\n         public HttpServer run() throws IOException, InterruptedException {\n           int infoPort \u003d bindAddress.getPort();\n           httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n               infoPort \u003d\u003d 0, conf, \n               new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n             {\n               if (conf.getBoolean(DFSConfigKeys.DFS_WEBHDFS_ENABLED_KEY,\n                   DFSConfigKeys.DFS_WEBHDFS_ENABLED_DEFAULT)) {\n                 //add SPNEGO authentication filter for webhdfs\n                 final String name \u003d \"SPNEGO\";\n                 final String classname \u003d  AuthFilter.class.getName();\n                 final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n                 Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n                 defineFilter(webAppContext, name, classname, params,\n                     new String[]{pathSpec});\n                 LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n                 // add webhdfs packages\n                 addJerseyResourcePackage(\n                     NamenodeWebHdfsMethods.class.getPackage().getName()\n                     + \";\" + Param.class.getPackage().getName(), pathSpec);\n               }\n             }\n \n             private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n                 throws IOException {\n               Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n               String principalInConf \u003d conf\n                   .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n               if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n                 params\n                     .put(\n                         DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n                         SecurityUtil.getServerPrincipal(principalInConf,\n                             infoHost));\n               }\n               String httpKeytab \u003d conf\n                   .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n               if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n                 params.put(\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n                     httpKeytab);\n               }\n-              params.put(\"kerberos.name.rules\",\n-                  conf.get(\"hadoop.security.auth_to_local\", \"DEFAULT\"));\n               return params;\n             }\n           };\n \n           boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n           boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n           if (certSSL || useKrb) {\n             boolean needClientAuth \u003d conf.getBoolean(\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n             InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                 .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                     DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n             Configuration sslConf \u003d new HdfsConfiguration(false);\n             if (certSSL) {\n               sslConf.addResource(conf.get(\n                   \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n             }\n             httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                 useKrb);\n             // assume same ssl port for all datanodes\n             InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                 .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n             httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                 .getPort());\n           }\n           httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n           httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n               nn.getNameNodeAddress());\n           httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n           httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n           setupServlets(httpServer, conf);\n           httpServer.start();\n \n           // The web-server port can be ephemeral... ensure we have the correct\n           // info\n           infoPort \u003d httpServer.getPort();\n           httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n           LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n           return httpServer;\n         }\n       });\n     } catch (InterruptedException e) {\n       throw new IOException(e);\n     } finally {\n       if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n           conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n         // Go back to being the correct Namenode principal\n         LOG.info(\"Logging back in as NameNode user following http server start\");\n         nn.loginAsNameNodeUser(conf);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    \n    if(UserGroupInformation.isSecurityEnabled()) {\n      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n      if (httpsUser \u003d\u003d null) {\n        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n            + \" not defined in config. Starting http server as \"\n            + getDefaultServerPrincipal()\n            + \": Kerberized SSL may be not function correctly.\");\n      } else {\n        // Kerberized SSL servers must be run from the host principal...\n        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n      }\n    }\n\n    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n    try {\n      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n        @Override\n        public HttpServer run() throws IOException, InterruptedException {\n          int infoPort \u003d bindAddress.getPort();\n          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n              infoPort \u003d\u003d 0, conf, \n              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n            {\n              if (conf.getBoolean(DFSConfigKeys.DFS_WEBHDFS_ENABLED_KEY,\n                  DFSConfigKeys.DFS_WEBHDFS_ENABLED_DEFAULT)) {\n                //add SPNEGO authentication filter for webhdfs\n                final String name \u003d \"SPNEGO\";\n                final String classname \u003d  AuthFilter.class.getName();\n                final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n                Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n                defineFilter(webAppContext, name, classname, params,\n                    new String[]{pathSpec});\n                LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n                // add webhdfs packages\n                addJerseyResourcePackage(\n                    NamenodeWebHdfsMethods.class.getPackage().getName()\n                    + \";\" + Param.class.getPackage().getName(), pathSpec);\n              }\n            }\n\n            private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n                throws IOException {\n              Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n              String principalInConf \u003d conf\n                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n              if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n                params\n                    .put(\n                        DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n                        SecurityUtil.getServerPrincipal(principalInConf,\n                            infoHost));\n              }\n              String httpKeytab \u003d conf\n                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n              if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n                params.put(\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n                    httpKeytab);\n              }\n              return params;\n            }\n          };\n\n          boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n          if (certSSL || useKrb) {\n            boolean needClientAuth \u003d conf.getBoolean(\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n            Configuration sslConf \u003d new HdfsConfiguration(false);\n            if (certSSL) {\n              sslConf.addResource(conf.get(\n                  \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n            }\n            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                useKrb);\n            // assume same ssl port for all datanodes\n            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n            httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                .getPort());\n          }\n          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n              nn.getNameNodeAddress());\n          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n          setupServlets(httpServer, conf);\n          httpServer.start();\n\n          // The web-server port can be ephemeral... ensure we have the correct\n          // info\n          infoPort \u003d httpServer.getPort();\n          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n          return httpServer;\n        }\n      });\n    } catch (InterruptedException e) {\n      throw new IOException(e);\n    } finally {\n      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n        // Go back to being the correct Namenode principal\n        LOG.info(\"Logging back in as NameNode user following http server start\");\n        nn.loginAsNameNodeUser(conf);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "8335995630e2c4288795fa0dfa9b670090a6790b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2501. Add version prefix and root methods to webhdfs.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189028 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/10/11 10:16 PM",
      "commitName": "8335995630e2c4288795fa0dfa9b670090a6790b",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "06/10/11 2:30 PM",
      "commitNameOld": "6f1d18bd478c4963543f8b8d80aefcb5adb38774",
      "commitAuthorOld": "Jitendra Nath Pandey",
      "daysBetweenCommits": 19.32,
      "commitsBetweenForRepo": 156,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,121 +1,121 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     \n     if(UserGroupInformation.isSecurityEnabled()) {\n       String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n           .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n       if (httpsUser \u003d\u003d null) {\n         LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n             + \" not defined in config. Starting http server as \"\n             + getDefaultServerPrincipal()\n             + \": Kerberized SSL may be not function correctly.\");\n       } else {\n         // Kerberized SSL servers must be run from the host principal...\n         LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n         SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n             DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n       }\n     }\n \n     UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n     try {\n       this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n         @Override\n         public HttpServer run() throws IOException, InterruptedException {\n           int infoPort \u003d bindAddress.getPort();\n           httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n               infoPort \u003d\u003d 0, conf, \n               new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n             {\n               if (conf.getBoolean(DFSConfigKeys.DFS_WEBHDFS_ENABLED_KEY,\n                   DFSConfigKeys.DFS_WEBHDFS_ENABLED_DEFAULT)) {\n                 //add SPNEGO authentication filter for webhdfs\n                 final String name \u003d \"SPNEGO\";\n                 final String classname \u003d  AuthFilter.class.getName();\n-                final String pathSpec \u003d \"/\" + WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n+                final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n                 Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n                 defineFilter(webAppContext, name, classname, params,\n                     new String[]{pathSpec});\n                 LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n                 // add webhdfs packages\n                 addJerseyResourcePackage(\n                     NamenodeWebHdfsMethods.class.getPackage().getName()\n                     + \";\" + Param.class.getPackage().getName(), pathSpec);\n               }\n             }\n \n             private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n                 throws IOException {\n               Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n               String principalInConf \u003d conf\n                   .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n               if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n                 params\n                     .put(\n                         DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n                         SecurityUtil.getServerPrincipal(principalInConf,\n                             infoHost));\n               }\n               String httpKeytab \u003d conf\n                   .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n               if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n                 params.put(\n                     DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n                     httpKeytab);\n               }\n               params.put(\"kerberos.name.rules\",\n                   conf.get(\"hadoop.security.auth_to_local\", \"DEFAULT\"));\n               return params;\n             }\n           };\n \n           boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n           boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n           if (certSSL || useKrb) {\n             boolean needClientAuth \u003d conf.getBoolean(\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n             InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                 .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                     DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n             Configuration sslConf \u003d new HdfsConfiguration(false);\n             if (certSSL) {\n               sslConf.addResource(conf.get(\n                   \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n             }\n             httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                 useKrb);\n             // assume same ssl port for all datanodes\n             InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                 .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n             httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                 .getPort());\n           }\n           httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n           httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n               nn.getNameNodeAddress());\n           httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n           httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n           setupServlets(httpServer, conf);\n           httpServer.start();\n \n           // The web-server port can be ephemeral... ensure we have the correct\n           // info\n           infoPort \u003d httpServer.getPort();\n           httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n           LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n           return httpServer;\n         }\n       });\n     } catch (InterruptedException e) {\n       throw new IOException(e);\n     } finally {\n       if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n           conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n         // Go back to being the correct Namenode principal\n         LOG.info(\"Logging back in as NameNode user following http server start\");\n         nn.loginAsNameNodeUser(conf);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    \n    if(UserGroupInformation.isSecurityEnabled()) {\n      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n      if (httpsUser \u003d\u003d null) {\n        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n            + \" not defined in config. Starting http server as \"\n            + getDefaultServerPrincipal()\n            + \": Kerberized SSL may be not function correctly.\");\n      } else {\n        // Kerberized SSL servers must be run from the host principal...\n        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n      }\n    }\n\n    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n    try {\n      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n        @Override\n        public HttpServer run() throws IOException, InterruptedException {\n          int infoPort \u003d bindAddress.getPort();\n          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n              infoPort \u003d\u003d 0, conf, \n              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n            {\n              if (conf.getBoolean(DFSConfigKeys.DFS_WEBHDFS_ENABLED_KEY,\n                  DFSConfigKeys.DFS_WEBHDFS_ENABLED_DEFAULT)) {\n                //add SPNEGO authentication filter for webhdfs\n                final String name \u003d \"SPNEGO\";\n                final String classname \u003d  AuthFilter.class.getName();\n                final String pathSpec \u003d WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n                Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n                defineFilter(webAppContext, name, classname, params,\n                    new String[]{pathSpec});\n                LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n                // add webhdfs packages\n                addJerseyResourcePackage(\n                    NamenodeWebHdfsMethods.class.getPackage().getName()\n                    + \";\" + Param.class.getPackage().getName(), pathSpec);\n              }\n            }\n\n            private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n                throws IOException {\n              Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n              String principalInConf \u003d conf\n                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n              if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n                params\n                    .put(\n                        DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n                        SecurityUtil.getServerPrincipal(principalInConf,\n                            infoHost));\n              }\n              String httpKeytab \u003d conf\n                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n              if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n                params.put(\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n                    httpKeytab);\n              }\n              params.put(\"kerberos.name.rules\",\n                  conf.get(\"hadoop.security.auth_to_local\", \"DEFAULT\"));\n              return params;\n            }\n          };\n\n          boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n          if (certSSL || useKrb) {\n            boolean needClientAuth \u003d conf.getBoolean(\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n            Configuration sslConf \u003d new HdfsConfiguration(false);\n            if (certSSL) {\n              sslConf.addResource(conf.get(\n                  \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n            }\n            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                useKrb);\n            // assume same ssl port for all datanodes\n            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n            httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                .getPort());\n          }\n          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n              nn.getNameNodeAddress());\n          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n          setupServlets(httpServer, conf);\n          httpServer.start();\n\n          // The web-server port can be ephemeral... ensure we have the correct\n          // info\n          infoPort \u003d httpServer.getPort();\n          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n          return httpServer;\n        }\n      });\n    } catch (InterruptedException e) {\n      throw new IOException(e);\n    } finally {\n      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n        // Go back to being the correct Namenode principal\n        LOG.info(\"Logging back in as NameNode user following http server start\");\n        nn.loginAsNameNodeUser(conf);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "6f1d18bd478c4963543f8b8d80aefcb5adb38774": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2409. _HOST in dfs.web.authentication.kerberos.principal. Incorporates HDFS-2405 as well.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1179861 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/10/11 2:30 PM",
      "commitName": "6f1d18bd478c4963543f8b8d80aefcb5adb38774",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "16/09/11 8:02 AM",
      "commitNameOld": "78e3821b819b441d1faf4bc66c659cdeddc6006c",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 20.27,
      "commitsBetweenForRepo": 144,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,121 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     \n     if(UserGroupInformation.isSecurityEnabled()) {\n       String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n           .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n       if (httpsUser \u003d\u003d null) {\n         LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n             + \" not defined in config. Starting http server as \"\n             + getDefaultServerPrincipal()\n             + \": Kerberized SSL may be not function correctly.\");\n       } else {\n         // Kerberized SSL servers must be run from the host principal...\n         LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n         SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n             DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n       }\n     }\n \n     UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n     try {\n       this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n         @Override\n         public HttpServer run() throws IOException, InterruptedException {\n           int infoPort \u003d bindAddress.getPort();\n           httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n               infoPort \u003d\u003d 0, conf, \n               new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n             {\n               if (conf.getBoolean(DFSConfigKeys.DFS_WEBHDFS_ENABLED_KEY,\n                   DFSConfigKeys.DFS_WEBHDFS_ENABLED_DEFAULT)) {\n                 //add SPNEGO authentication filter for webhdfs\n                 final String name \u003d \"SPNEGO\";\n                 final String classname \u003d  AuthFilter.class.getName();\n                 final String pathSpec \u003d \"/\" + WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n-                defineFilter(webAppContext, name, classname, null,\n+                Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n+                defineFilter(webAppContext, name, classname, params,\n                     new String[]{pathSpec});\n                 LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n \n                 // add webhdfs packages\n                 addJerseyResourcePackage(\n                     NamenodeWebHdfsMethods.class.getPackage().getName()\n                     + \";\" + Param.class.getPackage().getName(), pathSpec);\n               }\n             }\n+\n+            private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n+                throws IOException {\n+              Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n+              String principalInConf \u003d conf\n+                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n+              if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n+                params\n+                    .put(\n+                        DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n+                        SecurityUtil.getServerPrincipal(principalInConf,\n+                            infoHost));\n+              }\n+              String httpKeytab \u003d conf\n+                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n+              if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n+                params.put(\n+                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n+                    httpKeytab);\n+              }\n+              params.put(\"kerberos.name.rules\",\n+                  conf.get(\"hadoop.security.auth_to_local\", \"DEFAULT\"));\n+              return params;\n+            }\n           };\n \n           boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n           boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n           if (certSSL || useKrb) {\n             boolean needClientAuth \u003d conf.getBoolean(\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n             InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                 .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                     DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n             Configuration sslConf \u003d new HdfsConfiguration(false);\n             if (certSSL) {\n               sslConf.addResource(conf.get(\n                   \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n             }\n             httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                 useKrb);\n             // assume same ssl port for all datanodes\n             InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                 .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n             httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                 .getPort());\n           }\n           httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n           httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n               nn.getNameNodeAddress());\n           httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n           httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n           setupServlets(httpServer, conf);\n           httpServer.start();\n \n           // The web-server port can be ephemeral... ensure we have the correct\n           // info\n           infoPort \u003d httpServer.getPort();\n           httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n           LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n           return httpServer;\n         }\n       });\n     } catch (InterruptedException e) {\n       throw new IOException(e);\n     } finally {\n       if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n           conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n         // Go back to being the correct Namenode principal\n         LOG.info(\"Logging back in as NameNode user following http server start\");\n         nn.loginAsNameNodeUser(conf);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    \n    if(UserGroupInformation.isSecurityEnabled()) {\n      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n      if (httpsUser \u003d\u003d null) {\n        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n            + \" not defined in config. Starting http server as \"\n            + getDefaultServerPrincipal()\n            + \": Kerberized SSL may be not function correctly.\");\n      } else {\n        // Kerberized SSL servers must be run from the host principal...\n        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n      }\n    }\n\n    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n    try {\n      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n        @Override\n        public HttpServer run() throws IOException, InterruptedException {\n          int infoPort \u003d bindAddress.getPort();\n          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n              infoPort \u003d\u003d 0, conf, \n              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n            {\n              if (conf.getBoolean(DFSConfigKeys.DFS_WEBHDFS_ENABLED_KEY,\n                  DFSConfigKeys.DFS_WEBHDFS_ENABLED_DEFAULT)) {\n                //add SPNEGO authentication filter for webhdfs\n                final String name \u003d \"SPNEGO\";\n                final String classname \u003d  AuthFilter.class.getName();\n                final String pathSpec \u003d \"/\" + WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n                Map\u003cString, String\u003e params \u003d getAuthFilterParams(conf);\n                defineFilter(webAppContext, name, classname, params,\n                    new String[]{pathSpec});\n                LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n                // add webhdfs packages\n                addJerseyResourcePackage(\n                    NamenodeWebHdfsMethods.class.getPackage().getName()\n                    + \";\" + Param.class.getPackage().getName(), pathSpec);\n              }\n            }\n\n            private Map\u003cString, String\u003e getAuthFilterParams(Configuration conf)\n                throws IOException {\n              Map\u003cString, String\u003e params \u003d new HashMap\u003cString, String\u003e();\n              String principalInConf \u003d conf\n                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY);\n              if (principalInConf !\u003d null \u0026\u0026 !principalInConf.isEmpty()) {\n                params\n                    .put(\n                        DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY,\n                        SecurityUtil.getServerPrincipal(principalInConf,\n                            infoHost));\n              }\n              String httpKeytab \u003d conf\n                  .get(DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY);\n              if (httpKeytab !\u003d null \u0026\u0026 !httpKeytab.isEmpty()) {\n                params.put(\n                    DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY,\n                    httpKeytab);\n              }\n              params.put(\"kerberos.name.rules\",\n                  conf.get(\"hadoop.security.auth_to_local\", \"DEFAULT\"));\n              return params;\n            }\n          };\n\n          boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n          if (certSSL || useKrb) {\n            boolean needClientAuth \u003d conf.getBoolean(\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n            Configuration sslConf \u003d new HdfsConfiguration(false);\n            if (certSSL) {\n              sslConf.addResource(conf.get(\n                  \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n            }\n            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                useKrb);\n            // assume same ssl port for all datanodes\n            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n            httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                .getPort());\n          }\n          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n              nn.getNameNodeAddress());\n          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n          setupServlets(httpServer, conf);\n          httpServer.start();\n\n          // The web-server port can be ephemeral... ensure we have the correct\n          // info\n          infoPort \u003d httpServer.getPort();\n          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n          return httpServer;\n        }\n      });\n    } catch (InterruptedException e) {\n      throw new IOException(e);\n    } finally {\n      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n        // Go back to being the correct Namenode principal\n        LOG.info(\"Logging back in as NameNode user following http server start\");\n        nn.loginAsNameNodeUser(conf);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "78e3821b819b441d1faf4bc66c659cdeddc6006c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2318. Provide authentication to webhdfs using SPNEGO and delegation tokens.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1171611 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/09/11 8:02 AM",
      "commitName": "78e3821b819b441d1faf4bc66c659cdeddc6006c",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "15/09/11 9:01 PM",
      "commitNameOld": "cde0e484e7ee99583e6c0b4dd016724f910bd9a7",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.46,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,96 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     \n     if(UserGroupInformation.isSecurityEnabled()) {\n       String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n           .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n       if (httpsUser \u003d\u003d null) {\n         LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n             + \" not defined in config. Starting http server as \"\n             + getDefaultServerPrincipal()\n             + \": Kerberized SSL may be not function correctly.\");\n       } else {\n         // Kerberized SSL servers must be run from the host principal...\n         LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n         SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n             DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n       }\n     }\n \n     UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n     try {\n       this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n         @Override\n         public HttpServer run() throws IOException, InterruptedException {\n           int infoPort \u003d bindAddress.getPort();\n           httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n               infoPort \u003d\u003d 0, conf, \n-              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \")));\n+              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n+            {\n+              if (conf.getBoolean(DFSConfigKeys.DFS_WEBHDFS_ENABLED_KEY,\n+                  DFSConfigKeys.DFS_WEBHDFS_ENABLED_DEFAULT)) {\n+                //add SPNEGO authentication filter for webhdfs\n+                final String name \u003d \"SPNEGO\";\n+                final String classname \u003d  AuthFilter.class.getName();\n+                final String pathSpec \u003d \"/\" + WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n+                defineFilter(webAppContext, name, classname, null,\n+                    new String[]{pathSpec});\n+                LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n+\n+                // add webhdfs packages\n+                addJerseyResourcePackage(\n+                    NamenodeWebHdfsMethods.class.getPackage().getName()\n+                    + \";\" + Param.class.getPackage().getName(), pathSpec);\n+              }\n+            }\n+          };\n \n           boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n           boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n           if (certSSL || useKrb) {\n             boolean needClientAuth \u003d conf.getBoolean(\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n             InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                 .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                     DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n             Configuration sslConf \u003d new HdfsConfiguration(false);\n             if (certSSL) {\n               sslConf.addResource(conf.get(\n                   \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n             }\n             httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                 useKrb);\n             // assume same ssl port for all datanodes\n             InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                 .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n             httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                 .getPort());\n           }\n           httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n           httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n               nn.getNameNodeAddress());\n           httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n           httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n           setupServlets(httpServer, conf);\n           httpServer.start();\n \n           // The web-server port can be ephemeral... ensure we have the correct\n           // info\n           infoPort \u003d httpServer.getPort();\n           httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n           LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n           return httpServer;\n         }\n       });\n     } catch (InterruptedException e) {\n       throw new IOException(e);\n     } finally {\n       if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n           conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n         // Go back to being the correct Namenode principal\n         LOG.info(\"Logging back in as NameNode user following http server start\");\n         nn.loginAsNameNodeUser(conf);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    \n    if(UserGroupInformation.isSecurityEnabled()) {\n      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n      if (httpsUser \u003d\u003d null) {\n        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n            + \" not defined in config. Starting http server as \"\n            + getDefaultServerPrincipal()\n            + \": Kerberized SSL may be not function correctly.\");\n      } else {\n        // Kerberized SSL servers must be run from the host principal...\n        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n      }\n    }\n\n    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n    try {\n      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n        @Override\n        public HttpServer run() throws IOException, InterruptedException {\n          int infoPort \u003d bindAddress.getPort();\n          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n              infoPort \u003d\u003d 0, conf, \n              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \"))) {\n            {\n              if (conf.getBoolean(DFSConfigKeys.DFS_WEBHDFS_ENABLED_KEY,\n                  DFSConfigKeys.DFS_WEBHDFS_ENABLED_DEFAULT)) {\n                //add SPNEGO authentication filter for webhdfs\n                final String name \u003d \"SPNEGO\";\n                final String classname \u003d  AuthFilter.class.getName();\n                final String pathSpec \u003d \"/\" + WebHdfsFileSystem.PATH_PREFIX + \"/*\";\n                defineFilter(webAppContext, name, classname, null,\n                    new String[]{pathSpec});\n                LOG.info(\"Added filter \u0027\" + name + \"\u0027 (class\u003d\" + classname + \")\");\n\n                // add webhdfs packages\n                addJerseyResourcePackage(\n                    NamenodeWebHdfsMethods.class.getPackage().getName()\n                    + \";\" + Param.class.getPackage().getName(), pathSpec);\n              }\n            }\n          };\n\n          boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n          if (certSSL || useKrb) {\n            boolean needClientAuth \u003d conf.getBoolean(\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n            Configuration sslConf \u003d new HdfsConfiguration(false);\n            if (certSSL) {\n              sslConf.addResource(conf.get(\n                  \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n            }\n            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                useKrb);\n            // assume same ssl port for all datanodes\n            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n            httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                .getPort());\n          }\n          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n              nn.getNameNodeAddress());\n          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n          setupServlets(httpServer, conf);\n          httpServer.start();\n\n          // The web-server port can be ephemeral... ensure we have the correct\n          // info\n          infoPort \u003d httpServer.getPort();\n          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n          return httpServer;\n        }\n      });\n    } catch (InterruptedException e) {\n      throw new IOException(e);\n    } finally {\n      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n        // Go back to being the correct Namenode principal\n        LOG.info(\"Logging back in as NameNode user following http server start\");\n        nn.loginAsNameNodeUser(conf);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "cde0e484e7ee99583e6c0b4dd016724f910bd9a7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2338. Add configuration option to enable/disable webhdfs.  Contributed by jitendra \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1171379 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/09/11 9:01 PM",
      "commitName": "cde0e484e7ee99583e6c0b4dd016724f910bd9a7",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "10/09/11 6:41 PM",
      "commitNameOld": "61d0b7530c8978c095ab6f62d9d38e168bd829c6",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 5.1,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,78 @@\n   public void start() throws IOException {\n     final String infoHost \u003d bindAddress.getHostName();\n     \n     if(UserGroupInformation.isSecurityEnabled()) {\n       String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n           .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n       if (httpsUser \u003d\u003d null) {\n         LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n             + \" not defined in config. Starting http server as \"\n             + getDefaultServerPrincipal()\n             + \": Kerberized SSL may be not function correctly.\");\n       } else {\n         // Kerberized SSL servers must be run from the host principal...\n         LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n         SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n             DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n       }\n     }\n \n     UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n     try {\n       this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n         @Override\n         public HttpServer run() throws IOException, InterruptedException {\n           int infoPort \u003d bindAddress.getPort();\n           httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n               infoPort \u003d\u003d 0, conf, \n               new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \")));\n \n           boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n           boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n           if (certSSL || useKrb) {\n             boolean needClientAuth \u003d conf.getBoolean(\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                 DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n             InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                 .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                     DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n             Configuration sslConf \u003d new HdfsConfiguration(false);\n             if (certSSL) {\n               sslConf.addResource(conf.get(\n                   \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n             }\n             httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                 useKrb);\n             // assume same ssl port for all datanodes\n             InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                 .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n             httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                 .getPort());\n           }\n           httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n           httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n               nn.getNameNodeAddress());\n           httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n           httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n-          setupServlets(httpServer);\n+          setupServlets(httpServer, conf);\n           httpServer.start();\n \n           // The web-server port can be ephemeral... ensure we have the correct\n           // info\n           infoPort \u003d httpServer.getPort();\n           httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n           LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n           return httpServer;\n         }\n       });\n     } catch (InterruptedException e) {\n       throw new IOException(e);\n     } finally {\n       if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n           conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n         // Go back to being the correct Namenode principal\n         LOG.info(\"Logging back in as NameNode user following http server start\");\n         nn.loginAsNameNodeUser(conf);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    \n    if(UserGroupInformation.isSecurityEnabled()) {\n      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n      if (httpsUser \u003d\u003d null) {\n        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n            + \" not defined in config. Starting http server as \"\n            + getDefaultServerPrincipal()\n            + \": Kerberized SSL may be not function correctly.\");\n      } else {\n        // Kerberized SSL servers must be run from the host principal...\n        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n      }\n    }\n\n    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n    try {\n      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n        @Override\n        public HttpServer run() throws IOException, InterruptedException {\n          int infoPort \u003d bindAddress.getPort();\n          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n              infoPort \u003d\u003d 0, conf, \n              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \")));\n\n          boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n          if (certSSL || useKrb) {\n            boolean needClientAuth \u003d conf.getBoolean(\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n            Configuration sslConf \u003d new HdfsConfiguration(false);\n            if (certSSL) {\n              sslConf.addResource(conf.get(\n                  \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n            }\n            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                useKrb);\n            // assume same ssl port for all datanodes\n            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n            httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                .getPort());\n          }\n          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n              nn.getNameNodeAddress());\n          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n          setupServlets(httpServer, conf);\n          httpServer.start();\n\n          // The web-server port can be ephemeral... ensure we have the correct\n          // info\n          infoPort \u003d httpServer.getPort();\n          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n          return httpServer;\n        }\n      });\n    } catch (InterruptedException e) {\n      throw new IOException(e);\n    } finally {\n      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n        // Go back to being the correct Namenode principal\n        LOG.info(\"Logging back in as NameNode user following http server start\");\n        nn.loginAsNameNodeUser(conf);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    \n    if(UserGroupInformation.isSecurityEnabled()) {\n      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n      if (httpsUser \u003d\u003d null) {\n        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n            + \" not defined in config. Starting http server as \"\n            + getDefaultServerPrincipal()\n            + \": Kerberized SSL may be not function correctly.\");\n      } else {\n        // Kerberized SSL servers must be run from the host principal...\n        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n      }\n    }\n\n    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n    try {\n      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n        @Override\n        public HttpServer run() throws IOException, InterruptedException {\n          int infoPort \u003d bindAddress.getPort();\n          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n              infoPort \u003d\u003d 0, conf, \n              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \")));\n\n          boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n          if (certSSL || useKrb) {\n            boolean needClientAuth \u003d conf.getBoolean(\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n            Configuration sslConf \u003d new HdfsConfiguration(false);\n            if (certSSL) {\n              sslConf.addResource(conf.get(\n                  \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n            }\n            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                useKrb);\n            // assume same ssl port for all datanodes\n            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n            httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                .getPort());\n          }\n          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n              nn.getNameNodeAddress());\n          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n          setupServlets(httpServer);\n          httpServer.start();\n\n          // The web-server port can be ephemeral... ensure we have the correct\n          // info\n          infoPort \u003d httpServer.getPort();\n          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n          return httpServer;\n        }\n      });\n    } catch (InterruptedException e) {\n      throw new IOException(e);\n    } finally {\n      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n        // Go back to being the correct Namenode principal\n        LOG.info(\"Logging back in as NameNode user following http server start\");\n        nn.loginAsNameNodeUser(conf);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    \n    if(UserGroupInformation.isSecurityEnabled()) {\n      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n      if (httpsUser \u003d\u003d null) {\n        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n            + \" not defined in config. Starting http server as \"\n            + getDefaultServerPrincipal()\n            + \": Kerberized SSL may be not function correctly.\");\n      } else {\n        // Kerberized SSL servers must be run from the host principal...\n        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n      }\n    }\n\n    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n    try {\n      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n        @Override\n        public HttpServer run() throws IOException, InterruptedException {\n          int infoPort \u003d bindAddress.getPort();\n          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n              infoPort \u003d\u003d 0, conf, \n              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \")));\n\n          boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n          if (certSSL || useKrb) {\n            boolean needClientAuth \u003d conf.getBoolean(\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n            Configuration sslConf \u003d new HdfsConfiguration(false);\n            if (certSSL) {\n              sslConf.addResource(conf.get(\n                  \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n            }\n            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                useKrb);\n            // assume same ssl port for all datanodes\n            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n            httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                .getPort());\n          }\n          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n              nn.getNameNodeAddress());\n          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n          setupServlets(httpServer);\n          httpServer.start();\n\n          // The web-server port can be ephemeral... ensure we have the correct\n          // info\n          infoPort \u003d httpServer.getPort();\n          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n          return httpServer;\n        }\n      });\n    } catch (InterruptedException e) {\n      throw new IOException(e);\n    } finally {\n      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n        // Go back to being the correct Namenode principal\n        LOG.info(\"Logging back in as NameNode user following http server start\");\n        nn.loginAsNameNodeUser(conf);\n      }\n    }\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java"
      }
    },
    "01cd616d170d5d26a539e51e731e8e73b789b360": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-2180. Refactor NameNode HTTP server into new class. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1150960 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/07/11 5:04 PM",
      "commitName": "01cd616d170d5d26a539e51e731e8e73b789b360",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,78 @@\n+  public void start() throws IOException {\n+    final String infoHost \u003d bindAddress.getHostName();\n+    \n+    if(UserGroupInformation.isSecurityEnabled()) {\n+      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n+          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n+      if (httpsUser \u003d\u003d null) {\n+        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n+            + \" not defined in config. Starting http server as \"\n+            + getDefaultServerPrincipal()\n+            + \": Kerberized SSL may be not function correctly.\");\n+      } else {\n+        // Kerberized SSL servers must be run from the host principal...\n+        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n+        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n+            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n+      }\n+    }\n+\n+    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n+    try {\n+      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n+        @Override\n+        public HttpServer run() throws IOException, InterruptedException {\n+          int infoPort \u003d bindAddress.getPort();\n+          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n+              infoPort \u003d\u003d 0, conf, \n+              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \")));\n+\n+          boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n+          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n+          if (certSSL || useKrb) {\n+            boolean needClientAuth \u003d conf.getBoolean(\n+                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n+                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n+            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n+                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n+                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n+            Configuration sslConf \u003d new HdfsConfiguration(false);\n+            if (certSSL) {\n+              sslConf.addResource(conf.get(\n+                  \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n+            }\n+            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n+                useKrb);\n+            // assume same ssl port for all datanodes\n+            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n+                .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n+            httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n+                .getPort());\n+          }\n+          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n+          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n+              nn.getNameNodeAddress());\n+          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n+          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n+          setupServlets(httpServer);\n+          httpServer.start();\n+\n+          // The web-server port can be ephemeral... ensure we have the correct\n+          // info\n+          infoPort \u003d httpServer.getPort();\n+          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n+          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n+          return httpServer;\n+        }\n+      });\n+    } catch (InterruptedException e) {\n+      throw new IOException(e);\n+    } finally {\n+      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n+          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n+        // Go back to being the correct Namenode principal\n+        LOG.info(\"Logging back in as NameNode user following http server start\");\n+        nn.loginAsNameNodeUser(conf);\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void start() throws IOException {\n    final String infoHost \u003d bindAddress.getHostName();\n    \n    if(UserGroupInformation.isSecurityEnabled()) {\n      String httpsUser \u003d SecurityUtil.getServerPrincipal(conf\n          .get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY), infoHost);\n      if (httpsUser \u003d\u003d null) {\n        LOG.warn(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY\n            + \" not defined in config. Starting http server as \"\n            + getDefaultServerPrincipal()\n            + \": Kerberized SSL may be not function correctly.\");\n      } else {\n        // Kerberized SSL servers must be run from the host principal...\n        LOG.info(\"Logging in as \" + httpsUser + \" to start http server.\");\n        SecurityUtil.login(conf, DFSConfigKeys.DFS_NAMENODE_KEYTAB_FILE_KEY,\n            DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY, infoHost);\n      }\n    }\n\n    UserGroupInformation ugi \u003d UserGroupInformation.getLoginUser();\n    try {\n      this.httpServer \u003d ugi.doAs(new PrivilegedExceptionAction\u003cHttpServer\u003e() {\n        @Override\n        public HttpServer run() throws IOException, InterruptedException {\n          int infoPort \u003d bindAddress.getPort();\n          httpServer \u003d new HttpServer(\"hdfs\", infoHost, infoPort,\n              infoPort \u003d\u003d 0, conf, \n              new AccessControlList(conf.get(DFSConfigKeys.DFS_ADMIN, \" \")));\n\n          boolean certSSL \u003d conf.getBoolean(\"dfs.https.enable\", false);\n          boolean useKrb \u003d UserGroupInformation.isSecurityEnabled();\n          if (certSSL || useKrb) {\n            boolean needClientAuth \u003d conf.getBoolean(\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_KEY,\n                DFSConfigKeys.DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT);\n            InetSocketAddress secInfoSocAddr \u003d NetUtils.createSocketAddr(conf\n                .get(DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_KEY,\n                    DFSConfigKeys.DFS_NAMENODE_HTTPS_ADDRESS_DEFAULT));\n            Configuration sslConf \u003d new HdfsConfiguration(false);\n            if (certSSL) {\n              sslConf.addResource(conf.get(\n                  \"dfs.https.server.keystore.resource\", \"ssl-server.xml\"));\n            }\n            httpServer.addSslListener(secInfoSocAddr, sslConf, needClientAuth,\n                useKrb);\n            // assume same ssl port for all datanodes\n            InetSocketAddress datanodeSslPort \u003d NetUtils.createSocketAddr(conf\n                .get(\"dfs.datanode.https.address\", infoHost + \":\" + 50475));\n            httpServer.setAttribute(\"datanode.https.port\", datanodeSslPort\n                .getPort());\n          }\n          httpServer.setAttribute(NAMENODE_ATTRIBUTE_KEY, nn);\n          httpServer.setAttribute(NAMENODE_ADDRESS_ATTRIBUTE_KEY,\n              nn.getNameNodeAddress());\n          httpServer.setAttribute(FSIMAGE_ATTRIBUTE_KEY, nn.getFSImage());\n          httpServer.setAttribute(JspHelper.CURRENT_CONF, conf);\n          setupServlets(httpServer);\n          httpServer.start();\n\n          // The web-server port can be ephemeral... ensure we have the correct\n          // info\n          infoPort \u003d httpServer.getPort();\n          httpAddress \u003d new InetSocketAddress(infoHost, infoPort);\n          LOG.info(nn.getRole() + \" Web-server up at: \" + httpAddress);\n          return httpServer;\n        }\n      });\n    } catch (InterruptedException e) {\n      throw new IOException(e);\n    } finally {\n      if(UserGroupInformation.isSecurityEnabled() \u0026\u0026 \n          conf.get(DFSConfigKeys.DFS_NAMENODE_KRB_HTTPS_USER_NAME_KEY) !\u003d null) {\n        // Go back to being the correct Namenode principal\n        LOG.info(\"Logging back in as NameNode user following http server start\");\n        nn.loginAsNameNodeUser(conf);\n      }\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/NameNodeHttpServer.java"
    }
  }
}