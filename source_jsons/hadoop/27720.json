{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LocalityMulticastAMRMProxyPolicy.java",
  "functionName": "splitResourceRequests",
  "functionId": "splitResourceRequests___resourceRequests-List__ResourceRequest____timedOutSubClusters-Set__SubClusterId__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
  "functionStartLine": 204,
  "functionEndLine": 281,
  "numCommitsSeen": 19,
  "timeTaken": 4747,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
    "7ed458b255e492fd5bc2ca36f216ff1b16054db7",
    "e0f6ffdbad6f43fd43ec57fb68ebf5275b8b9ba0",
    "1c64e1709b627846f29dc2fe6d637f074de8b403",
    "8623644f4599f51d34ba79c4c1453b3997205d8f",
    "1dadd0b45a6a605da72eb304808edb49fc66da45"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa": "Ymultichange(Yparameterchange,Ybodychange)",
    "7ed458b255e492fd5bc2ca36f216ff1b16054db7": "Ybodychange",
    "e0f6ffdbad6f43fd43ec57fb68ebf5275b8b9ba0": "Ybodychange",
    "1c64e1709b627846f29dc2fe6d637f074de8b403": "Ybodychange",
    "8623644f4599f51d34ba79c4c1453b3997205d8f": "Ybodychange",
    "1dadd0b45a6a605da72eb304808edb49fc66da45": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "11/11/18 11:12 AM",
      "commitNameOld": "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
      "commitAuthorOld": "Botong Huang",
      "daysBetweenCommits": 124.17,
      "commitsBetweenForRepo": 915,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,81 +1,78 @@\n   public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n       List\u003cResourceRequest\u003e resourceRequests,\n       Set\u003cSubClusterId\u003e timedOutSubClusters) throws YarnException {\n \n     // object used to accumulate statistics about the answer, initialize with\n     // active subclusters. Create a new instance per call because this method\n     // can be called concurrently.\n     AllocationBookkeeper bookkeeper \u003d new AllocationBookkeeper();\n     bookkeeper.reinitialize(getActiveSubclusters(), timedOutSubClusters);\n \n     List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n         new ArrayList\u003cResourceRequest\u003e();\n \n     SubClusterId targetId \u003d null;\n     Set\u003cSubClusterId\u003e targetIds \u003d null;\n \n     // if the RR is resolved to a local subcluster add it directly (node and\n     // resolvable racks)\n     for (ResourceRequest rr : resourceRequests) {\n       targetId \u003d null;\n       targetIds \u003d null;\n \n       // Handle: ANY (accumulated for later)\n       if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n         nonLocalizedRequests.add(rr);\n         continue;\n       }\n \n       // Handle \"node\" requests\n       try {\n         targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (bookkeeper.isActiveAndEnabled(targetId)) {\n         bookkeeper.addLocalizedNodeRR(targetId, rr);\n         continue;\n       }\n \n       // Handle \"rack\" requests\n       try {\n         targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n         boolean hasActive \u003d false;\n         for (SubClusterId tid : targetIds) {\n           if (bookkeeper.isActiveAndEnabled(tid)) {\n             bookkeeper.addRackRR(tid, rr);\n             hasActive \u003d true;\n           }\n         }\n         if (hasActive) {\n           continue;\n         }\n       }\n \n       // Handle node/rack requests that the SubClusterResolver cannot map to\n       // any cluster. Pick a random sub-cluster from active and enabled ones.\n       targetId \u003d getSubClusterForUnResolvedRequest(bookkeeper,\n           rr.getAllocationRequestId());\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n-            + rr.getResourceName() + \", picked a random subcluster to forward:\"\n-            + targetId);\n-      }\n+      LOG.debug(\"ERROR resolving sub-cluster for resourceName: {}, picked a \"\n+          + \"random subcluster to forward:{}\", rr.getResourceName(), targetId);\n       if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n         bookkeeper.addRackRR(targetId, rr);\n       } else {\n         bookkeeper.addLocalizedNodeRR(targetId, rr);\n       }\n     }\n \n     // handle all non-localized requests (ANY)\n     splitAnyRequests(nonLocalizedRequests, bookkeeper);\n \n     return bookkeeper.getAnswer();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n      List\u003cResourceRequest\u003e resourceRequests,\n      Set\u003cSubClusterId\u003e timedOutSubClusters) throws YarnException {\n\n    // object used to accumulate statistics about the answer, initialize with\n    // active subclusters. Create a new instance per call because this method\n    // can be called concurrently.\n    AllocationBookkeeper bookkeeper \u003d new AllocationBookkeeper();\n    bookkeeper.reinitialize(getActiveSubclusters(), timedOutSubClusters);\n\n    List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n        new ArrayList\u003cResourceRequest\u003e();\n\n    SubClusterId targetId \u003d null;\n    Set\u003cSubClusterId\u003e targetIds \u003d null;\n\n    // if the RR is resolved to a local subcluster add it directly (node and\n    // resolvable racks)\n    for (ResourceRequest rr : resourceRequests) {\n      targetId \u003d null;\n      targetIds \u003d null;\n\n      // Handle: ANY (accumulated for later)\n      if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n        nonLocalizedRequests.add(rr);\n        continue;\n      }\n\n      // Handle \"node\" requests\n      try {\n        targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (bookkeeper.isActiveAndEnabled(targetId)) {\n        bookkeeper.addLocalizedNodeRR(targetId, rr);\n        continue;\n      }\n\n      // Handle \"rack\" requests\n      try {\n        targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n        boolean hasActive \u003d false;\n        for (SubClusterId tid : targetIds) {\n          if (bookkeeper.isActiveAndEnabled(tid)) {\n            bookkeeper.addRackRR(tid, rr);\n            hasActive \u003d true;\n          }\n        }\n        if (hasActive) {\n          continue;\n        }\n      }\n\n      // Handle node/rack requests that the SubClusterResolver cannot map to\n      // any cluster. Pick a random sub-cluster from active and enabled ones.\n      targetId \u003d getSubClusterForUnResolvedRequest(bookkeeper,\n          rr.getAllocationRequestId());\n      LOG.debug(\"ERROR resolving sub-cluster for resourceName: {}, picked a \"\n          + \"random subcluster to forward:{}\", rr.getResourceName(), targetId);\n      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n        bookkeeper.addRackRR(targetId, rr);\n      } else {\n        bookkeeper.addLocalizedNodeRR(targetId, rr);\n      }\n    }\n\n    // handle all non-localized requests (ANY)\n    splitAnyRequests(nonLocalizedRequests, bookkeeper);\n\n    return bookkeeper.getAnswer();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
      "extendedDetails": {}
    },
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-8933. [AMRMProxy] Fix potential empty fields in allocation response, move SubClusterTimeout to FederationInterceptor. Contributed by Botong Huang.\n",
      "commitDate": "11/11/18 11:12 AM",
      "commitName": "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
      "commitAuthor": "Botong Huang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8933. [AMRMProxy] Fix potential empty fields in allocation response, move SubClusterTimeout to FederationInterceptor. Contributed by Botong Huang.\n",
          "commitDate": "11/11/18 11:12 AM",
          "commitName": "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
          "commitAuthor": "Botong Huang",
          "commitDateOld": "28/08/18 4:01 PM",
          "commitNameOld": "7ed458b255e492fd5bc2ca36f216ff1b16054db7",
          "commitAuthorOld": "Giovanni Matteo Fumarola",
          "daysBetweenCommits": 74.84,
          "commitsBetweenForRepo": 697,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,89 +1,81 @@\n   public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n-      List\u003cResourceRequest\u003e resourceRequests) throws YarnException {\n+      List\u003cResourceRequest\u003e resourceRequests,\n+      Set\u003cSubClusterId\u003e timedOutSubClusters) throws YarnException {\n \n     // object used to accumulate statistics about the answer, initialize with\n     // active subclusters. Create a new instance per call because this method\n     // can be called concurrently.\n-    bookkeeper \u003d new AllocationBookkeeper();\n-    bookkeeper.reinitialize(federationFacade.getSubClusters(true));\n+    AllocationBookkeeper bookkeeper \u003d new AllocationBookkeeper();\n+    bookkeeper.reinitialize(getActiveSubclusters(), timedOutSubClusters);\n \n     List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n         new ArrayList\u003cResourceRequest\u003e();\n \n     SubClusterId targetId \u003d null;\n     Set\u003cSubClusterId\u003e targetIds \u003d null;\n \n     // if the RR is resolved to a local subcluster add it directly (node and\n     // resolvable racks)\n     for (ResourceRequest rr : resourceRequests) {\n       targetId \u003d null;\n       targetIds \u003d null;\n \n       // Handle: ANY (accumulated for later)\n       if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n         nonLocalizedRequests.add(rr);\n         continue;\n       }\n \n       // Handle \"node\" requests\n       try {\n         targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (bookkeeper.isActiveAndEnabled(targetId)) {\n         bookkeeper.addLocalizedNodeRR(targetId, rr);\n         continue;\n       }\n \n       // Handle \"rack\" requests\n       try {\n         targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n         boolean hasActive \u003d false;\n         for (SubClusterId tid : targetIds) {\n           if (bookkeeper.isActiveAndEnabled(tid)) {\n             bookkeeper.addRackRR(tid, rr);\n             hasActive \u003d true;\n           }\n         }\n         if (hasActive) {\n           continue;\n         }\n       }\n \n       // Handle node/rack requests that the SubClusterResolver cannot map to\n       // any cluster. Pick a random sub-cluster from active and enabled ones.\n       targetId \u003d getSubClusterForUnResolvedRequest(bookkeeper,\n           rr.getAllocationRequestId());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n             + rr.getResourceName() + \", picked a random subcluster to forward:\"\n             + targetId);\n       }\n       if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n         bookkeeper.addRackRR(targetId, rr);\n       } else {\n         bookkeeper.addLocalizedNodeRR(targetId, rr);\n       }\n     }\n \n     // handle all non-localized requests (ANY)\n     splitAnyRequests(nonLocalizedRequests, bookkeeper);\n \n-    for (Map.Entry\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e entry : bookkeeper\n-        .getAnswer().entrySet()) {\n-      // A new-cluster here will trigger new UAM luanch, which might take a long\n-      // time. We don\u0027t want too many requests stuck in this UAM before it is\n-      // ready and starts heartbeating\n-      if (!lastHeartbeatTimeStamp.containsKey(entry.getKey())) {\n-        lastHeartbeatTimeStamp.put(entry.getKey(), System.currentTimeMillis());\n-      }\n-    }\n     return bookkeeper.getAnswer();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n      List\u003cResourceRequest\u003e resourceRequests,\n      Set\u003cSubClusterId\u003e timedOutSubClusters) throws YarnException {\n\n    // object used to accumulate statistics about the answer, initialize with\n    // active subclusters. Create a new instance per call because this method\n    // can be called concurrently.\n    AllocationBookkeeper bookkeeper \u003d new AllocationBookkeeper();\n    bookkeeper.reinitialize(getActiveSubclusters(), timedOutSubClusters);\n\n    List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n        new ArrayList\u003cResourceRequest\u003e();\n\n    SubClusterId targetId \u003d null;\n    Set\u003cSubClusterId\u003e targetIds \u003d null;\n\n    // if the RR is resolved to a local subcluster add it directly (node and\n    // resolvable racks)\n    for (ResourceRequest rr : resourceRequests) {\n      targetId \u003d null;\n      targetIds \u003d null;\n\n      // Handle: ANY (accumulated for later)\n      if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n        nonLocalizedRequests.add(rr);\n        continue;\n      }\n\n      // Handle \"node\" requests\n      try {\n        targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (bookkeeper.isActiveAndEnabled(targetId)) {\n        bookkeeper.addLocalizedNodeRR(targetId, rr);\n        continue;\n      }\n\n      // Handle \"rack\" requests\n      try {\n        targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n        boolean hasActive \u003d false;\n        for (SubClusterId tid : targetIds) {\n          if (bookkeeper.isActiveAndEnabled(tid)) {\n            bookkeeper.addRackRR(tid, rr);\n            hasActive \u003d true;\n          }\n        }\n        if (hasActive) {\n          continue;\n        }\n      }\n\n      // Handle node/rack requests that the SubClusterResolver cannot map to\n      // any cluster. Pick a random sub-cluster from active and enabled ones.\n      targetId \u003d getSubClusterForUnResolvedRequest(bookkeeper,\n          rr.getAllocationRequestId());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n            + rr.getResourceName() + \", picked a random subcluster to forward:\"\n            + targetId);\n      }\n      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n        bookkeeper.addRackRR(targetId, rr);\n      } else {\n        bookkeeper.addLocalizedNodeRR(targetId, rr);\n      }\n    }\n\n    // handle all non-localized requests (ANY)\n    splitAnyRequests(nonLocalizedRequests, bookkeeper);\n\n    return bookkeeper.getAnswer();\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
          "extendedDetails": {
            "oldValue": "[resourceRequests-List\u003cResourceRequest\u003e]",
            "newValue": "[resourceRequests-List\u003cResourceRequest\u003e, timedOutSubClusters-Set\u003cSubClusterId\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8933. [AMRMProxy] Fix potential empty fields in allocation response, move SubClusterTimeout to FederationInterceptor. Contributed by Botong Huang.\n",
          "commitDate": "11/11/18 11:12 AM",
          "commitName": "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
          "commitAuthor": "Botong Huang",
          "commitDateOld": "28/08/18 4:01 PM",
          "commitNameOld": "7ed458b255e492fd5bc2ca36f216ff1b16054db7",
          "commitAuthorOld": "Giovanni Matteo Fumarola",
          "daysBetweenCommits": 74.84,
          "commitsBetweenForRepo": 697,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,89 +1,81 @@\n   public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n-      List\u003cResourceRequest\u003e resourceRequests) throws YarnException {\n+      List\u003cResourceRequest\u003e resourceRequests,\n+      Set\u003cSubClusterId\u003e timedOutSubClusters) throws YarnException {\n \n     // object used to accumulate statistics about the answer, initialize with\n     // active subclusters. Create a new instance per call because this method\n     // can be called concurrently.\n-    bookkeeper \u003d new AllocationBookkeeper();\n-    bookkeeper.reinitialize(federationFacade.getSubClusters(true));\n+    AllocationBookkeeper bookkeeper \u003d new AllocationBookkeeper();\n+    bookkeeper.reinitialize(getActiveSubclusters(), timedOutSubClusters);\n \n     List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n         new ArrayList\u003cResourceRequest\u003e();\n \n     SubClusterId targetId \u003d null;\n     Set\u003cSubClusterId\u003e targetIds \u003d null;\n \n     // if the RR is resolved to a local subcluster add it directly (node and\n     // resolvable racks)\n     for (ResourceRequest rr : resourceRequests) {\n       targetId \u003d null;\n       targetIds \u003d null;\n \n       // Handle: ANY (accumulated for later)\n       if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n         nonLocalizedRequests.add(rr);\n         continue;\n       }\n \n       // Handle \"node\" requests\n       try {\n         targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (bookkeeper.isActiveAndEnabled(targetId)) {\n         bookkeeper.addLocalizedNodeRR(targetId, rr);\n         continue;\n       }\n \n       // Handle \"rack\" requests\n       try {\n         targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n         boolean hasActive \u003d false;\n         for (SubClusterId tid : targetIds) {\n           if (bookkeeper.isActiveAndEnabled(tid)) {\n             bookkeeper.addRackRR(tid, rr);\n             hasActive \u003d true;\n           }\n         }\n         if (hasActive) {\n           continue;\n         }\n       }\n \n       // Handle node/rack requests that the SubClusterResolver cannot map to\n       // any cluster. Pick a random sub-cluster from active and enabled ones.\n       targetId \u003d getSubClusterForUnResolvedRequest(bookkeeper,\n           rr.getAllocationRequestId());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n             + rr.getResourceName() + \", picked a random subcluster to forward:\"\n             + targetId);\n       }\n       if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n         bookkeeper.addRackRR(targetId, rr);\n       } else {\n         bookkeeper.addLocalizedNodeRR(targetId, rr);\n       }\n     }\n \n     // handle all non-localized requests (ANY)\n     splitAnyRequests(nonLocalizedRequests, bookkeeper);\n \n-    for (Map.Entry\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e entry : bookkeeper\n-        .getAnswer().entrySet()) {\n-      // A new-cluster here will trigger new UAM luanch, which might take a long\n-      // time. We don\u0027t want too many requests stuck in this UAM before it is\n-      // ready and starts heartbeating\n-      if (!lastHeartbeatTimeStamp.containsKey(entry.getKey())) {\n-        lastHeartbeatTimeStamp.put(entry.getKey(), System.currentTimeMillis());\n-      }\n-    }\n     return bookkeeper.getAnswer();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n      List\u003cResourceRequest\u003e resourceRequests,\n      Set\u003cSubClusterId\u003e timedOutSubClusters) throws YarnException {\n\n    // object used to accumulate statistics about the answer, initialize with\n    // active subclusters. Create a new instance per call because this method\n    // can be called concurrently.\n    AllocationBookkeeper bookkeeper \u003d new AllocationBookkeeper();\n    bookkeeper.reinitialize(getActiveSubclusters(), timedOutSubClusters);\n\n    List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n        new ArrayList\u003cResourceRequest\u003e();\n\n    SubClusterId targetId \u003d null;\n    Set\u003cSubClusterId\u003e targetIds \u003d null;\n\n    // if the RR is resolved to a local subcluster add it directly (node and\n    // resolvable racks)\n    for (ResourceRequest rr : resourceRequests) {\n      targetId \u003d null;\n      targetIds \u003d null;\n\n      // Handle: ANY (accumulated for later)\n      if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n        nonLocalizedRequests.add(rr);\n        continue;\n      }\n\n      // Handle \"node\" requests\n      try {\n        targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (bookkeeper.isActiveAndEnabled(targetId)) {\n        bookkeeper.addLocalizedNodeRR(targetId, rr);\n        continue;\n      }\n\n      // Handle \"rack\" requests\n      try {\n        targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n        boolean hasActive \u003d false;\n        for (SubClusterId tid : targetIds) {\n          if (bookkeeper.isActiveAndEnabled(tid)) {\n            bookkeeper.addRackRR(tid, rr);\n            hasActive \u003d true;\n          }\n        }\n        if (hasActive) {\n          continue;\n        }\n      }\n\n      // Handle node/rack requests that the SubClusterResolver cannot map to\n      // any cluster. Pick a random sub-cluster from active and enabled ones.\n      targetId \u003d getSubClusterForUnResolvedRequest(bookkeeper,\n          rr.getAllocationRequestId());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n            + rr.getResourceName() + \", picked a random subcluster to forward:\"\n            + targetId);\n      }\n      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n        bookkeeper.addRackRR(targetId, rr);\n      } else {\n        bookkeeper.addLocalizedNodeRR(targetId, rr);\n      }\n    }\n\n    // handle all non-localized requests (ANY)\n    splitAnyRequests(nonLocalizedRequests, bookkeeper);\n\n    return bookkeeper.getAnswer();\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "7ed458b255e492fd5bc2ca36f216ff1b16054db7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8697. LocalityMulticastAMRMProxyPolicy should fallback to random sub-cluster when cannot resolve resource. Contributed by Botong Huang.\n",
      "commitDate": "28/08/18 4:01 PM",
      "commitName": "7ed458b255e492fd5bc2ca36f216ff1b16054db7",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "20/08/18 2:33 PM",
      "commitNameOld": "e0f6ffdbad6f43fd43ec57fb68ebf5275b8b9ba0",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 8.06,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,89 @@\n   public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n       List\u003cResourceRequest\u003e resourceRequests) throws YarnException {\n \n     // object used to accumulate statistics about the answer, initialize with\n     // active subclusters. Create a new instance per call because this method\n     // can be called concurrently.\n     bookkeeper \u003d new AllocationBookkeeper();\n     bookkeeper.reinitialize(federationFacade.getSubClusters(true));\n \n     List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n         new ArrayList\u003cResourceRequest\u003e();\n \n     SubClusterId targetId \u003d null;\n     Set\u003cSubClusterId\u003e targetIds \u003d null;\n \n     // if the RR is resolved to a local subcluster add it directly (node and\n     // resolvable racks)\n     for (ResourceRequest rr : resourceRequests) {\n       targetId \u003d null;\n       targetIds \u003d null;\n \n       // Handle: ANY (accumulated for later)\n       if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n         nonLocalizedRequests.add(rr);\n         continue;\n       }\n \n       // Handle \"node\" requests\n       try {\n         targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (bookkeeper.isActiveAndEnabled(targetId)) {\n         bookkeeper.addLocalizedNodeRR(targetId, rr);\n         continue;\n       }\n \n       // Handle \"rack\" requests\n       try {\n         targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n         boolean hasActive \u003d false;\n         for (SubClusterId tid : targetIds) {\n           if (bookkeeper.isActiveAndEnabled(tid)) {\n             bookkeeper.addRackRR(tid, rr);\n             hasActive \u003d true;\n           }\n         }\n         if (hasActive) {\n           continue;\n         }\n       }\n \n       // Handle node/rack requests that the SubClusterResolver cannot map to\n-      // any cluster. Defaulting to home subcluster.\n+      // any cluster. Pick a random sub-cluster from active and enabled ones.\n+      targetId \u003d getSubClusterForUnResolvedRequest(bookkeeper,\n+          rr.getAllocationRequestId());\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n-            + rr.getResourceName() + \" we are falling back to homeSubCluster:\"\n-            + homeSubcluster);\n+            + rr.getResourceName() + \", picked a random subcluster to forward:\"\n+            + targetId);\n       }\n-\n-      // If home-subcluster is not active, ignore node/rack request\n-      if (bookkeeper.isActiveAndEnabled(homeSubcluster)) {\n-        if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n-          bookkeeper.addRackRR(homeSubcluster, rr);\n-        } else {\n-          bookkeeper.addLocalizedNodeRR(homeSubcluster, rr);\n-        }\n+      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n+        bookkeeper.addRackRR(targetId, rr);\n       } else {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"The homeSubCluster (\" + homeSubcluster + \") we are \"\n-              + \"defaulting to is not active, the ResourceRequest \"\n-              + \"will be ignored.\");\n-        }\n+        bookkeeper.addLocalizedNodeRR(targetId, rr);\n       }\n     }\n \n     // handle all non-localized requests (ANY)\n     splitAnyRequests(nonLocalizedRequests, bookkeeper);\n \n     for (Map.Entry\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e entry : bookkeeper\n         .getAnswer().entrySet()) {\n       // A new-cluster here will trigger new UAM luanch, which might take a long\n       // time. We don\u0027t want too many requests stuck in this UAM before it is\n       // ready and starts heartbeating\n       if (!lastHeartbeatTimeStamp.containsKey(entry.getKey())) {\n         lastHeartbeatTimeStamp.put(entry.getKey(), System.currentTimeMillis());\n       }\n     }\n     return bookkeeper.getAnswer();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n      List\u003cResourceRequest\u003e resourceRequests) throws YarnException {\n\n    // object used to accumulate statistics about the answer, initialize with\n    // active subclusters. Create a new instance per call because this method\n    // can be called concurrently.\n    bookkeeper \u003d new AllocationBookkeeper();\n    bookkeeper.reinitialize(federationFacade.getSubClusters(true));\n\n    List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n        new ArrayList\u003cResourceRequest\u003e();\n\n    SubClusterId targetId \u003d null;\n    Set\u003cSubClusterId\u003e targetIds \u003d null;\n\n    // if the RR is resolved to a local subcluster add it directly (node and\n    // resolvable racks)\n    for (ResourceRequest rr : resourceRequests) {\n      targetId \u003d null;\n      targetIds \u003d null;\n\n      // Handle: ANY (accumulated for later)\n      if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n        nonLocalizedRequests.add(rr);\n        continue;\n      }\n\n      // Handle \"node\" requests\n      try {\n        targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (bookkeeper.isActiveAndEnabled(targetId)) {\n        bookkeeper.addLocalizedNodeRR(targetId, rr);\n        continue;\n      }\n\n      // Handle \"rack\" requests\n      try {\n        targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n        boolean hasActive \u003d false;\n        for (SubClusterId tid : targetIds) {\n          if (bookkeeper.isActiveAndEnabled(tid)) {\n            bookkeeper.addRackRR(tid, rr);\n            hasActive \u003d true;\n          }\n        }\n        if (hasActive) {\n          continue;\n        }\n      }\n\n      // Handle node/rack requests that the SubClusterResolver cannot map to\n      // any cluster. Pick a random sub-cluster from active and enabled ones.\n      targetId \u003d getSubClusterForUnResolvedRequest(bookkeeper,\n          rr.getAllocationRequestId());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n            + rr.getResourceName() + \", picked a random subcluster to forward:\"\n            + targetId);\n      }\n      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n        bookkeeper.addRackRR(targetId, rr);\n      } else {\n        bookkeeper.addLocalizedNodeRR(targetId, rr);\n      }\n    }\n\n    // handle all non-localized requests (ANY)\n    splitAnyRequests(nonLocalizedRequests, bookkeeper);\n\n    for (Map.Entry\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e entry : bookkeeper\n        .getAnswer().entrySet()) {\n      // A new-cluster here will trigger new UAM luanch, which might take a long\n      // time. We don\u0027t want too many requests stuck in this UAM before it is\n      // ready and starts heartbeating\n      if (!lastHeartbeatTimeStamp.containsKey(entry.getKey())) {\n        lastHeartbeatTimeStamp.put(entry.getKey(), System.currentTimeMillis());\n      }\n    }\n    return bookkeeper.getAnswer();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
      "extendedDetails": {}
    },
    "e0f6ffdbad6f43fd43ec57fb68ebf5275b8b9ba0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8581. [AMRMProxy] Add sub-cluster timeout in LocalityMulticastAMRMProxyPolicy. Contributed by Botong Huang.\n",
      "commitDate": "20/08/18 2:33 PM",
      "commitName": "e0f6ffdbad6f43fd43ec57fb68ebf5275b8b9ba0",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "21/06/18 6:24 PM",
      "commitNameOld": "99948565cb5d5706241d7a8fc591e1617c499e03",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 59.84,
      "commitsBetweenForRepo": 435,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,88 +1,97 @@\n   public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n       List\u003cResourceRequest\u003e resourceRequests) throws YarnException {\n \n     // object used to accumulate statistics about the answer, initialize with\n     // active subclusters. Create a new instance per call because this method\n     // can be called concurrently.\n     bookkeeper \u003d new AllocationBookkeeper();\n     bookkeeper.reinitialize(federationFacade.getSubClusters(true));\n \n     List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n         new ArrayList\u003cResourceRequest\u003e();\n \n     SubClusterId targetId \u003d null;\n     Set\u003cSubClusterId\u003e targetIds \u003d null;\n \n     // if the RR is resolved to a local subcluster add it directly (node and\n     // resolvable racks)\n     for (ResourceRequest rr : resourceRequests) {\n       targetId \u003d null;\n       targetIds \u003d null;\n \n       // Handle: ANY (accumulated for later)\n       if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n         nonLocalizedRequests.add(rr);\n         continue;\n       }\n \n       // Handle \"node\" requests\n       try {\n         targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (bookkeeper.isActiveAndEnabled(targetId)) {\n         bookkeeper.addLocalizedNodeRR(targetId, rr);\n         continue;\n       }\n \n       // Handle \"rack\" requests\n       try {\n         targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n         boolean hasActive \u003d false;\n         for (SubClusterId tid : targetIds) {\n           if (bookkeeper.isActiveAndEnabled(tid)) {\n             bookkeeper.addRackRR(tid, rr);\n             hasActive \u003d true;\n           }\n         }\n         if (hasActive) {\n           continue;\n         }\n       }\n \n       // Handle node/rack requests that the SubClusterResolver cannot map to\n       // any cluster. Defaulting to home subcluster.\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n             + rr.getResourceName() + \" we are falling back to homeSubCluster:\"\n             + homeSubcluster);\n       }\n \n       // If home-subcluster is not active, ignore node/rack request\n       if (bookkeeper.isActiveAndEnabled(homeSubcluster)) {\n         if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n           bookkeeper.addRackRR(homeSubcluster, rr);\n         } else {\n           bookkeeper.addLocalizedNodeRR(homeSubcluster, rr);\n         }\n       } else {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"The homeSubCluster (\" + homeSubcluster + \") we are \"\n               + \"defaulting to is not active, the ResourceRequest \"\n               + \"will be ignored.\");\n         }\n       }\n     }\n \n     // handle all non-localized requests (ANY)\n     splitAnyRequests(nonLocalizedRequests, bookkeeper);\n \n+    for (Map.Entry\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e entry : bookkeeper\n+        .getAnswer().entrySet()) {\n+      // A new-cluster here will trigger new UAM luanch, which might take a long\n+      // time. We don\u0027t want too many requests stuck in this UAM before it is\n+      // ready and starts heartbeating\n+      if (!lastHeartbeatTimeStamp.containsKey(entry.getKey())) {\n+        lastHeartbeatTimeStamp.put(entry.getKey(), System.currentTimeMillis());\n+      }\n+    }\n     return bookkeeper.getAnswer();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n      List\u003cResourceRequest\u003e resourceRequests) throws YarnException {\n\n    // object used to accumulate statistics about the answer, initialize with\n    // active subclusters. Create a new instance per call because this method\n    // can be called concurrently.\n    bookkeeper \u003d new AllocationBookkeeper();\n    bookkeeper.reinitialize(federationFacade.getSubClusters(true));\n\n    List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n        new ArrayList\u003cResourceRequest\u003e();\n\n    SubClusterId targetId \u003d null;\n    Set\u003cSubClusterId\u003e targetIds \u003d null;\n\n    // if the RR is resolved to a local subcluster add it directly (node and\n    // resolvable racks)\n    for (ResourceRequest rr : resourceRequests) {\n      targetId \u003d null;\n      targetIds \u003d null;\n\n      // Handle: ANY (accumulated for later)\n      if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n        nonLocalizedRequests.add(rr);\n        continue;\n      }\n\n      // Handle \"node\" requests\n      try {\n        targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (bookkeeper.isActiveAndEnabled(targetId)) {\n        bookkeeper.addLocalizedNodeRR(targetId, rr);\n        continue;\n      }\n\n      // Handle \"rack\" requests\n      try {\n        targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n        boolean hasActive \u003d false;\n        for (SubClusterId tid : targetIds) {\n          if (bookkeeper.isActiveAndEnabled(tid)) {\n            bookkeeper.addRackRR(tid, rr);\n            hasActive \u003d true;\n          }\n        }\n        if (hasActive) {\n          continue;\n        }\n      }\n\n      // Handle node/rack requests that the SubClusterResolver cannot map to\n      // any cluster. Defaulting to home subcluster.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n            + rr.getResourceName() + \" we are falling back to homeSubCluster:\"\n            + homeSubcluster);\n      }\n\n      // If home-subcluster is not active, ignore node/rack request\n      if (bookkeeper.isActiveAndEnabled(homeSubcluster)) {\n        if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n          bookkeeper.addRackRR(homeSubcluster, rr);\n        } else {\n          bookkeeper.addLocalizedNodeRR(homeSubcluster, rr);\n        }\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"The homeSubCluster (\" + homeSubcluster + \") we are \"\n              + \"defaulting to is not active, the ResourceRequest \"\n              + \"will be ignored.\");\n        }\n      }\n    }\n\n    // handle all non-localized requests (ANY)\n    splitAnyRequests(nonLocalizedRequests, bookkeeper);\n\n    for (Map.Entry\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e entry : bookkeeper\n        .getAnswer().entrySet()) {\n      // A new-cluster here will trigger new UAM luanch, which might take a long\n      // time. We don\u0027t want too many requests stuck in this UAM before it is\n      // ready and starts heartbeating\n      if (!lastHeartbeatTimeStamp.containsKey(entry.getKey())) {\n        lastHeartbeatTimeStamp.put(entry.getKey(), System.currentTimeMillis());\n      }\n    }\n    return bookkeeper.getAnswer();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
      "extendedDetails": {}
    },
    "1c64e1709b627846f29dc2fe6d637f074de8b403": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6370. Properly handle rack requests for non-active subclusters in LocalityMulticastAMRMProxyPolicy. (Contributed by Botong Huang via curino).\n\n(cherry picked from commit ce419881c32b178c48c3a01b5a15e4e3a3e750f5)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "1c64e1709b627846f29dc2fe6d637f074de8b403",
      "commitAuthor": "Carlo Curino",
      "commitDateOld": "01/08/17 5:28 PM",
      "commitNameOld": "8623644f4599f51d34ba79c4c1453b3997205d8f",
      "commitAuthorOld": "Carlo Curino",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,88 @@\n   public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n       List\u003cResourceRequest\u003e resourceRequests) throws YarnException {\n \n     // object used to accumulate statistics about the answer, initialize with\n     // active subclusters. Create a new instance per call because this method\n     // can be called concurrently.\n     bookkeeper \u003d new AllocationBookkeeper();\n     bookkeeper.reinitialize(federationFacade.getSubClusters(true));\n \n     List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n         new ArrayList\u003cResourceRequest\u003e();\n \n     SubClusterId targetId \u003d null;\n     Set\u003cSubClusterId\u003e targetIds \u003d null;\n \n     // if the RR is resolved to a local subcluster add it directly (node and\n     // resolvable racks)\n     for (ResourceRequest rr : resourceRequests) {\n       targetId \u003d null;\n       targetIds \u003d null;\n \n       // Handle: ANY (accumulated for later)\n       if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n         nonLocalizedRequests.add(rr);\n         continue;\n       }\n \n       // Handle \"node\" requests\n       try {\n         targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (bookkeeper.isActiveAndEnabled(targetId)) {\n         bookkeeper.addLocalizedNodeRR(targetId, rr);\n         continue;\n       }\n \n       // Handle \"rack\" requests\n       try {\n         targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n         boolean hasActive \u003d false;\n         for (SubClusterId tid : targetIds) {\n           if (bookkeeper.isActiveAndEnabled(tid)) {\n             bookkeeper.addRackRR(tid, rr);\n             hasActive \u003d true;\n           }\n         }\n         if (hasActive) {\n           continue;\n         }\n       }\n \n       // Handle node/rack requests that the SubClusterResolver cannot map to\n       // any cluster. Defaulting to home subcluster.\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n             + rr.getResourceName() + \" we are falling back to homeSubCluster:\"\n             + homeSubcluster);\n       }\n \n       // If home-subcluster is not active, ignore node/rack request\n       if (bookkeeper.isActiveAndEnabled(homeSubcluster)) {\n-        bookkeeper.addLocalizedNodeRR(homeSubcluster, rr);\n+        if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n+          bookkeeper.addRackRR(homeSubcluster, rr);\n+        } else {\n+          bookkeeper.addLocalizedNodeRR(homeSubcluster, rr);\n+        }\n       } else {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"The homeSubCluster (\" + homeSubcluster + \") we are \"\n               + \"defaulting to is not active, the ResourceRequest \"\n               + \"will be ignored.\");\n         }\n       }\n     }\n \n     // handle all non-localized requests (ANY)\n     splitAnyRequests(nonLocalizedRequests, bookkeeper);\n \n     return bookkeeper.getAnswer();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n      List\u003cResourceRequest\u003e resourceRequests) throws YarnException {\n\n    // object used to accumulate statistics about the answer, initialize with\n    // active subclusters. Create a new instance per call because this method\n    // can be called concurrently.\n    bookkeeper \u003d new AllocationBookkeeper();\n    bookkeeper.reinitialize(federationFacade.getSubClusters(true));\n\n    List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n        new ArrayList\u003cResourceRequest\u003e();\n\n    SubClusterId targetId \u003d null;\n    Set\u003cSubClusterId\u003e targetIds \u003d null;\n\n    // if the RR is resolved to a local subcluster add it directly (node and\n    // resolvable racks)\n    for (ResourceRequest rr : resourceRequests) {\n      targetId \u003d null;\n      targetIds \u003d null;\n\n      // Handle: ANY (accumulated for later)\n      if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n        nonLocalizedRequests.add(rr);\n        continue;\n      }\n\n      // Handle \"node\" requests\n      try {\n        targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (bookkeeper.isActiveAndEnabled(targetId)) {\n        bookkeeper.addLocalizedNodeRR(targetId, rr);\n        continue;\n      }\n\n      // Handle \"rack\" requests\n      try {\n        targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n        boolean hasActive \u003d false;\n        for (SubClusterId tid : targetIds) {\n          if (bookkeeper.isActiveAndEnabled(tid)) {\n            bookkeeper.addRackRR(tid, rr);\n            hasActive \u003d true;\n          }\n        }\n        if (hasActive) {\n          continue;\n        }\n      }\n\n      // Handle node/rack requests that the SubClusterResolver cannot map to\n      // any cluster. Defaulting to home subcluster.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n            + rr.getResourceName() + \" we are falling back to homeSubCluster:\"\n            + homeSubcluster);\n      }\n\n      // If home-subcluster is not active, ignore node/rack request\n      if (bookkeeper.isActiveAndEnabled(homeSubcluster)) {\n        if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n          bookkeeper.addRackRR(homeSubcluster, rr);\n        } else {\n          bookkeeper.addLocalizedNodeRR(homeSubcluster, rr);\n        }\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"The homeSubCluster (\" + homeSubcluster + \") we are \"\n              + \"defaulting to is not active, the ResourceRequest \"\n              + \"will be ignored.\");\n        }\n      }\n    }\n\n    // handle all non-localized requests (ANY)\n    splitAnyRequests(nonLocalizedRequests, bookkeeper);\n\n    return bookkeeper.getAnswer();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
      "extendedDetails": {}
    },
    "8623644f4599f51d34ba79c4c1453b3997205d8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6190. Validation and synchronization fixes in LocalityMulticastAMRMProxyPolicy. (Botong Huang via curino)\n\n(cherry picked from commit 5c486961cd3a175b122ef86275c99b72964f2c50)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "8623644f4599f51d34ba79c4c1453b3997205d8f",
      "commitAuthor": "Carlo Curino",
      "commitDateOld": "01/08/17 5:28 PM",
      "commitNameOld": "1dadd0b45a6a605da72eb304808edb49fc66da45",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,84 @@\n   public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n       List\u003cResourceRequest\u003e resourceRequests) throws YarnException {\n \n     // object used to accumulate statistics about the answer, initialize with\n-    // active subclusters.\n+    // active subclusters. Create a new instance per call because this method\n+    // can be called concurrently.\n+    bookkeeper \u003d new AllocationBookkeeper();\n     bookkeeper.reinitialize(federationFacade.getSubClusters(true));\n \n     List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n         new ArrayList\u003cResourceRequest\u003e();\n \n     SubClusterId targetId \u003d null;\n     Set\u003cSubClusterId\u003e targetIds \u003d null;\n \n     // if the RR is resolved to a local subcluster add it directly (node and\n     // resolvable racks)\n     for (ResourceRequest rr : resourceRequests) {\n       targetId \u003d null;\n       targetIds \u003d null;\n \n       // Handle: ANY (accumulated for later)\n       if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n         nonLocalizedRequests.add(rr);\n         continue;\n       }\n \n       // Handle \"node\" requests\n       try {\n         targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (bookkeeper.isActiveAndEnabled(targetId)) {\n         bookkeeper.addLocalizedNodeRR(targetId, rr);\n         continue;\n       }\n \n       // Handle \"rack\" requests\n       try {\n         targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n       } catch (YarnException e) {\n         // this might happen as we can\u0027t differentiate node from rack names\n         // we log altogether later\n       }\n       if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n+        boolean hasActive \u003d false;\n         for (SubClusterId tid : targetIds) {\n           if (bookkeeper.isActiveAndEnabled(tid)) {\n             bookkeeper.addRackRR(tid, rr);\n+            hasActive \u003d true;\n           }\n         }\n-        continue;\n+        if (hasActive) {\n+          continue;\n+        }\n       }\n \n       // Handle node/rack requests that the SubClusterResolver cannot map to\n       // any cluster. Defaulting to home subcluster.\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n             + rr.getResourceName() + \" we are falling back to homeSubCluster:\"\n             + homeSubcluster);\n       }\n \n       // If home-subcluster is not active, ignore node/rack request\n       if (bookkeeper.isActiveAndEnabled(homeSubcluster)) {\n         bookkeeper.addLocalizedNodeRR(homeSubcluster, rr);\n       } else {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"The homeSubCluster (\" + homeSubcluster + \") we are \"\n               + \"defaulting to is not active, the ResourceRequest \"\n               + \"will be ignored.\");\n         }\n       }\n     }\n \n     // handle all non-localized requests (ANY)\n     splitAnyRequests(nonLocalizedRequests, bookkeeper);\n \n     return bookkeeper.getAnswer();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n      List\u003cResourceRequest\u003e resourceRequests) throws YarnException {\n\n    // object used to accumulate statistics about the answer, initialize with\n    // active subclusters. Create a new instance per call because this method\n    // can be called concurrently.\n    bookkeeper \u003d new AllocationBookkeeper();\n    bookkeeper.reinitialize(federationFacade.getSubClusters(true));\n\n    List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n        new ArrayList\u003cResourceRequest\u003e();\n\n    SubClusterId targetId \u003d null;\n    Set\u003cSubClusterId\u003e targetIds \u003d null;\n\n    // if the RR is resolved to a local subcluster add it directly (node and\n    // resolvable racks)\n    for (ResourceRequest rr : resourceRequests) {\n      targetId \u003d null;\n      targetIds \u003d null;\n\n      // Handle: ANY (accumulated for later)\n      if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n        nonLocalizedRequests.add(rr);\n        continue;\n      }\n\n      // Handle \"node\" requests\n      try {\n        targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (bookkeeper.isActiveAndEnabled(targetId)) {\n        bookkeeper.addLocalizedNodeRR(targetId, rr);\n        continue;\n      }\n\n      // Handle \"rack\" requests\n      try {\n        targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n        boolean hasActive \u003d false;\n        for (SubClusterId tid : targetIds) {\n          if (bookkeeper.isActiveAndEnabled(tid)) {\n            bookkeeper.addRackRR(tid, rr);\n            hasActive \u003d true;\n          }\n        }\n        if (hasActive) {\n          continue;\n        }\n      }\n\n      // Handle node/rack requests that the SubClusterResolver cannot map to\n      // any cluster. Defaulting to home subcluster.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n            + rr.getResourceName() + \" we are falling back to homeSubCluster:\"\n            + homeSubcluster);\n      }\n\n      // If home-subcluster is not active, ignore node/rack request\n      if (bookkeeper.isActiveAndEnabled(homeSubcluster)) {\n        bookkeeper.addLocalizedNodeRR(homeSubcluster, rr);\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"The homeSubCluster (\" + homeSubcluster + \") we are \"\n              + \"defaulting to is not active, the ResourceRequest \"\n              + \"will be ignored.\");\n        }\n      }\n    }\n\n    // handle all non-localized requests (ANY)\n    splitAnyRequests(nonLocalizedRequests, bookkeeper);\n\n    return bookkeeper.getAnswer();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
      "extendedDetails": {}
    },
    "1dadd0b45a6a605da72eb304808edb49fc66da45": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5325. Stateless ARMRMProxy policies implementation. (Carlo Curino via Subru).\n\n(cherry picked from commit 11c5336522d3504598fb94eee288d54df73418c6)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "1dadd0b45a6a605da72eb304808edb49fc66da45",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,78 @@\n+  public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n+      List\u003cResourceRequest\u003e resourceRequests) throws YarnException {\n+\n+    // object used to accumulate statistics about the answer, initialize with\n+    // active subclusters.\n+    bookkeeper.reinitialize(federationFacade.getSubClusters(true));\n+\n+    List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n+        new ArrayList\u003cResourceRequest\u003e();\n+\n+    SubClusterId targetId \u003d null;\n+    Set\u003cSubClusterId\u003e targetIds \u003d null;\n+\n+    // if the RR is resolved to a local subcluster add it directly (node and\n+    // resolvable racks)\n+    for (ResourceRequest rr : resourceRequests) {\n+      targetId \u003d null;\n+      targetIds \u003d null;\n+\n+      // Handle: ANY (accumulated for later)\n+      if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n+        nonLocalizedRequests.add(rr);\n+        continue;\n+      }\n+\n+      // Handle \"node\" requests\n+      try {\n+        targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n+      } catch (YarnException e) {\n+        // this might happen as we can\u0027t differentiate node from rack names\n+        // we log altogether later\n+      }\n+      if (bookkeeper.isActiveAndEnabled(targetId)) {\n+        bookkeeper.addLocalizedNodeRR(targetId, rr);\n+        continue;\n+      }\n+\n+      // Handle \"rack\" requests\n+      try {\n+        targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n+      } catch (YarnException e) {\n+        // this might happen as we can\u0027t differentiate node from rack names\n+        // we log altogether later\n+      }\n+      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n+        for (SubClusterId tid : targetIds) {\n+          if (bookkeeper.isActiveAndEnabled(tid)) {\n+            bookkeeper.addRackRR(tid, rr);\n+          }\n+        }\n+        continue;\n+      }\n+\n+      // Handle node/rack requests that the SubClusterResolver cannot map to\n+      // any cluster. Defaulting to home subcluster.\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n+            + rr.getResourceName() + \" we are falling back to homeSubCluster:\"\n+            + homeSubcluster);\n+      }\n+\n+      // If home-subcluster is not active, ignore node/rack request\n+      if (bookkeeper.isActiveAndEnabled(homeSubcluster)) {\n+        bookkeeper.addLocalizedNodeRR(homeSubcluster, rr);\n+      } else {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"The homeSubCluster (\" + homeSubcluster + \") we are \"\n+              + \"defaulting to is not active, the ResourceRequest \"\n+              + \"will be ignored.\");\n+        }\n+      }\n+    }\n+\n+    // handle all non-localized requests (ANY)\n+    splitAnyRequests(nonLocalizedRequests, bookkeeper);\n+\n+    return bookkeeper.getAnswer();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cSubClusterId, List\u003cResourceRequest\u003e\u003e splitResourceRequests(\n      List\u003cResourceRequest\u003e resourceRequests) throws YarnException {\n\n    // object used to accumulate statistics about the answer, initialize with\n    // active subclusters.\n    bookkeeper.reinitialize(federationFacade.getSubClusters(true));\n\n    List\u003cResourceRequest\u003e nonLocalizedRequests \u003d\n        new ArrayList\u003cResourceRequest\u003e();\n\n    SubClusterId targetId \u003d null;\n    Set\u003cSubClusterId\u003e targetIds \u003d null;\n\n    // if the RR is resolved to a local subcluster add it directly (node and\n    // resolvable racks)\n    for (ResourceRequest rr : resourceRequests) {\n      targetId \u003d null;\n      targetIds \u003d null;\n\n      // Handle: ANY (accumulated for later)\n      if (ResourceRequest.isAnyLocation(rr.getResourceName())) {\n        nonLocalizedRequests.add(rr);\n        continue;\n      }\n\n      // Handle \"node\" requests\n      try {\n        targetId \u003d resolver.getSubClusterForNode(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (bookkeeper.isActiveAndEnabled(targetId)) {\n        bookkeeper.addLocalizedNodeRR(targetId, rr);\n        continue;\n      }\n\n      // Handle \"rack\" requests\n      try {\n        targetIds \u003d resolver.getSubClustersForRack(rr.getResourceName());\n      } catch (YarnException e) {\n        // this might happen as we can\u0027t differentiate node from rack names\n        // we log altogether later\n      }\n      if (targetIds !\u003d null \u0026\u0026 targetIds.size() \u003e 0) {\n        for (SubClusterId tid : targetIds) {\n          if (bookkeeper.isActiveAndEnabled(tid)) {\n            bookkeeper.addRackRR(tid, rr);\n          }\n        }\n        continue;\n      }\n\n      // Handle node/rack requests that the SubClusterResolver cannot map to\n      // any cluster. Defaulting to home subcluster.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"ERROR resolving sub-cluster for resourceName: \"\n            + rr.getResourceName() + \" we are falling back to homeSubCluster:\"\n            + homeSubcluster);\n      }\n\n      // If home-subcluster is not active, ignore node/rack request\n      if (bookkeeper.isActiveAndEnabled(homeSubcluster)) {\n        bookkeeper.addLocalizedNodeRR(homeSubcluster, rr);\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"The homeSubCluster (\" + homeSubcluster + \") we are \"\n              + \"defaulting to is not active, the ResourceRequest \"\n              + \"will be ignored.\");\n        }\n      }\n    }\n\n    // handle all non-localized requests (ANY)\n    splitAnyRequests(nonLocalizedRequests, bookkeeper);\n\n    return bookkeeper.getAnswer();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java"
    }
  }
}