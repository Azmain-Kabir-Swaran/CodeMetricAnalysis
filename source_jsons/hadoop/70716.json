{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AzureNativeFileSystemStore.java",
  "functionName": "retrieveMetadata",
  "functionId": "retrieveMetadata___key-String",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java",
  "functionStartLine": 2124,
  "functionEndLine": 2225,
  "numCommitsSeen": 53,
  "timeTaken": 3153,
  "changeHistory": [
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
    "9374f3882044b552b7dbde788ce569452072c6dc",
    "5f6edb30c2bb648d5564c951edc25645e17e6636",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82"
  ],
  "changeHistoryShort": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": "Ybodychange",
    "9374f3882044b552b7dbde788ce569452072c6dc": "Ybodychange",
    "5f6edb30c2bb648d5564c951edc25645e17e6636": "Ybodychange",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": "Ybodychange",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": "Yintroduced"
  },
  "changeHistoryDetails": {
    "45d9568aaaf532a6da11bd7c1844ff81bf66bab1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15547/ WASB: improve listStatus performance.\nContributed by Thomas Marquardt.\n\n(cherry picked from commit 749fff577ed9afb4ef8a54b8948f74be083cc620)\n",
      "commitDate": "19/07/18 12:31 PM",
      "commitName": "45d9568aaaf532a6da11bd7c1844ff81bf66bab1",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "27/06/18 10:37 PM",
      "commitNameOld": "2b2399d623539ab68e71a38fa9fbfc9a405bddb8",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 21.58,
      "commitsBetweenForRepo": 124,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   public FileMetadata retrieveMetadata(String key) throws IOException {\n \n     // Attempts to check status may occur before opening any streams so first,\n     // check if a session exists, if not create a session with the Azure storage\n     // server.\n     if (null \u003d\u003d storageInteractionLayer) {\n       final String errMsg \u003d String.format(\n           \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n           sessionUri);\n       throw new AssertionError(errMsg);\n     }\n \n     LOG.debug(\"Retrieving metadata for {}\", key);\n \n     try {\n       if (checkContainer(ContainerAccessType.PureRead) \u003d\u003d ContainerState.DoesntExist) {\n         // The container doesn\u0027t exist, so spare some service calls and just\n         // return null now.\n         return null;\n       }\n \n       // Handle the degenerate cases where the key does not exist or the\n       // key is a container.\n       if (key.equals(\"/\")) {\n         // The key refers to root directory of container.\n         // Set the modification time for root to zero.\n         return new FileMetadata(key, 0, defaultPermissionNoBlobMetadata(),\n-            BlobMaterialization.Implicit);\n+            BlobMaterialization.Implicit, hadoopBlockSize);\n       }\n \n       CloudBlobWrapper blob \u003d getBlobReference(key);\n \n       // Download attributes and return file metadata only if the blob\n       // exists.\n       if (null !\u003d blob \u0026\u0026 blob.exists(getInstrumentedContext())) {\n \n         LOG.debug(\"Found {} as an explicit blob. Checking if it\u0027s a file or folder.\", key);\n \n         try {\n           // The blob exists, so capture the metadata from the blob\n           // properties.\n           blob.downloadAttributes(getInstrumentedContext());\n           BlobProperties properties \u003d blob.getProperties();\n \n           if (retrieveFolderAttribute(blob)) {\n             LOG.debug(\"{} is a folder blob.\", key);\n             return new FileMetadata(key, properties.getLastModified().getTime(),\n-                getPermissionStatus(blob), BlobMaterialization.Explicit);\n+                getPermissionStatus(blob), BlobMaterialization.Explicit, hadoopBlockSize);\n           } else {\n \n             LOG.debug(\"{} is a normal blob.\", key);\n \n             return new FileMetadata(\n                 key, // Always return denormalized key with metadata.\n                 getDataLength(blob, properties),\n                 properties.getLastModified().getTime(),\n-                getPermissionStatus(blob));\n+                getPermissionStatus(blob), hadoopBlockSize);\n           }\n         } catch(StorageException e){\n           if (!NativeAzureFileSystemHelper.isFileNotFoundException(e)) {\n             throw e;\n           }\n         }\n       }\n \n       // There is no file with that key name, but maybe it is a folder.\n       // Query the underlying folder/container to list the blobs stored\n       // there under that key.\n       //\n       Iterable\u003cListBlobItem\u003e objects \u003d\n           listRootBlobs(\n               key,\n               true,\n               EnumSet.of(BlobListingDetails.METADATA),\n               null,\n           getInstrumentedContext());\n \n       // Check if the directory/container has the blob items.\n       for (ListBlobItem blobItem : objects) {\n         if (blobItem instanceof CloudBlockBlobWrapper\n             || blobItem instanceof CloudPageBlobWrapper) {\n           LOG.debug(\"Found blob as a directory-using this file under it to infer its properties {}\",\n               blobItem.getUri());\n \n           blob \u003d (CloudBlobWrapper) blobItem;\n           // The key specifies a directory. Create a FileMetadata object which\n           // specifies as such.\n           BlobProperties properties \u003d blob.getProperties();\n \n           return new FileMetadata(key, properties.getLastModified().getTime(),\n-              getPermissionStatus(blob), BlobMaterialization.Implicit);\n+              getPermissionStatus(blob), BlobMaterialization.Implicit, hadoopBlockSize);\n         }\n       }\n \n       // Return to caller with a null metadata object.\n       return null;\n \n     } catch (Exception e) {\n       // Re-throw the exception as an Azure storage exception.\n       throw new AzureException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileMetadata retrieveMetadata(String key) throws IOException {\n\n    // Attempts to check status may occur before opening any streams so first,\n    // check if a session exists, if not create a session with the Azure storage\n    // server.\n    if (null \u003d\u003d storageInteractionLayer) {\n      final String errMsg \u003d String.format(\n          \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n          sessionUri);\n      throw new AssertionError(errMsg);\n    }\n\n    LOG.debug(\"Retrieving metadata for {}\", key);\n\n    try {\n      if (checkContainer(ContainerAccessType.PureRead) \u003d\u003d ContainerState.DoesntExist) {\n        // The container doesn\u0027t exist, so spare some service calls and just\n        // return null now.\n        return null;\n      }\n\n      // Handle the degenerate cases where the key does not exist or the\n      // key is a container.\n      if (key.equals(\"/\")) {\n        // The key refers to root directory of container.\n        // Set the modification time for root to zero.\n        return new FileMetadata(key, 0, defaultPermissionNoBlobMetadata(),\n            BlobMaterialization.Implicit, hadoopBlockSize);\n      }\n\n      CloudBlobWrapper blob \u003d getBlobReference(key);\n\n      // Download attributes and return file metadata only if the blob\n      // exists.\n      if (null !\u003d blob \u0026\u0026 blob.exists(getInstrumentedContext())) {\n\n        LOG.debug(\"Found {} as an explicit blob. Checking if it\u0027s a file or folder.\", key);\n\n        try {\n          // The blob exists, so capture the metadata from the blob\n          // properties.\n          blob.downloadAttributes(getInstrumentedContext());\n          BlobProperties properties \u003d blob.getProperties();\n\n          if (retrieveFolderAttribute(blob)) {\n            LOG.debug(\"{} is a folder blob.\", key);\n            return new FileMetadata(key, properties.getLastModified().getTime(),\n                getPermissionStatus(blob), BlobMaterialization.Explicit, hadoopBlockSize);\n          } else {\n\n            LOG.debug(\"{} is a normal blob.\", key);\n\n            return new FileMetadata(\n                key, // Always return denormalized key with metadata.\n                getDataLength(blob, properties),\n                properties.getLastModified().getTime(),\n                getPermissionStatus(blob), hadoopBlockSize);\n          }\n        } catch(StorageException e){\n          if (!NativeAzureFileSystemHelper.isFileNotFoundException(e)) {\n            throw e;\n          }\n        }\n      }\n\n      // There is no file with that key name, but maybe it is a folder.\n      // Query the underlying folder/container to list the blobs stored\n      // there under that key.\n      //\n      Iterable\u003cListBlobItem\u003e objects \u003d\n          listRootBlobs(\n              key,\n              true,\n              EnumSet.of(BlobListingDetails.METADATA),\n              null,\n          getInstrumentedContext());\n\n      // Check if the directory/container has the blob items.\n      for (ListBlobItem blobItem : objects) {\n        if (blobItem instanceof CloudBlockBlobWrapper\n            || blobItem instanceof CloudPageBlobWrapper) {\n          LOG.debug(\"Found blob as a directory-using this file under it to infer its properties {}\",\n              blobItem.getUri());\n\n          blob \u003d (CloudBlobWrapper) blobItem;\n          // The key specifies a directory. Create a FileMetadata object which\n          // specifies as such.\n          BlobProperties properties \u003d blob.getProperties();\n\n          return new FileMetadata(key, properties.getLastModified().getTime(),\n              getPermissionStatus(blob), BlobMaterialization.Implicit, hadoopBlockSize);\n        }\n      }\n\n      // Return to caller with a null metadata object.\n      return null;\n\n    } catch (Exception e) {\n      // Re-throw the exception as an Azure storage exception.\n      throw new AzureException(e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java",
      "extendedDetails": {}
    },
    "9374f3882044b552b7dbde788ce569452072c6dc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14583. wasb throws an exception if you try to create a file and there\u0027s no parent directory\nContributed by Esfandiar Manii and Thomas Marquardt.\n",
      "commitDate": "29/08/17 11:03 AM",
      "commitName": "9374f3882044b552b7dbde788ce569452072c6dc",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/08/17 6:13 AM",
      "commitNameOld": "c6b4e656b76b68cc1d0dbcc15a5aa5ea23335b7b",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 11.2,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,102 @@\n   public FileMetadata retrieveMetadata(String key) throws IOException {\n \n     // Attempts to check status may occur before opening any streams so first,\n     // check if a session exists, if not create a session with the Azure storage\n     // server.\n     if (null \u003d\u003d storageInteractionLayer) {\n       final String errMsg \u003d String.format(\n           \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n           sessionUri);\n       throw new AssertionError(errMsg);\n     }\n \n     LOG.debug(\"Retrieving metadata for {}\", key);\n \n     try {\n       if (checkContainer(ContainerAccessType.PureRead) \u003d\u003d ContainerState.DoesntExist) {\n         // The container doesn\u0027t exist, so spare some service calls and just\n         // return null now.\n         return null;\n       }\n \n       // Handle the degenerate cases where the key does not exist or the\n       // key is a container.\n       if (key.equals(\"/\")) {\n         // The key refers to root directory of container.\n         // Set the modification time for root to zero.\n         return new FileMetadata(key, 0, defaultPermissionNoBlobMetadata(),\n             BlobMaterialization.Implicit);\n       }\n \n       CloudBlobWrapper blob \u003d getBlobReference(key);\n \n       // Download attributes and return file metadata only if the blob\n       // exists.\n       if (null !\u003d blob \u0026\u0026 blob.exists(getInstrumentedContext())) {\n \n         LOG.debug(\"Found {} as an explicit blob. Checking if it\u0027s a file or folder.\", key);\n \n-        // The blob exists, so capture the metadata from the blob\n-        // properties.\n-        blob.downloadAttributes(getInstrumentedContext());\n-        BlobProperties properties \u003d blob.getProperties();\n+        try {\n+          // The blob exists, so capture the metadata from the blob\n+          // properties.\n+          blob.downloadAttributes(getInstrumentedContext());\n+          BlobProperties properties \u003d blob.getProperties();\n \n-        if (retrieveFolderAttribute(blob)) {\n-          LOG.debug(\"{} is a folder blob.\", key);\n-          return new FileMetadata(key, properties.getLastModified().getTime(),\n-              getPermissionStatus(blob), BlobMaterialization.Explicit);\n-        } else {\n+          if (retrieveFolderAttribute(blob)) {\n+            LOG.debug(\"{} is a folder blob.\", key);\n+            return new FileMetadata(key, properties.getLastModified().getTime(),\n+                getPermissionStatus(blob), BlobMaterialization.Explicit);\n+          } else {\n \n-          LOG.debug(\"{} is a normal blob.\", key);\n+            LOG.debug(\"{} is a normal blob.\", key);\n \n-          return new FileMetadata(\n-              key, // Always return denormalized key with metadata.\n-              getDataLength(blob, properties),\n-              properties.getLastModified().getTime(),\n-              getPermissionStatus(blob));\n+            return new FileMetadata(\n+                key, // Always return denormalized key with metadata.\n+                getDataLength(blob, properties),\n+                properties.getLastModified().getTime(),\n+                getPermissionStatus(blob));\n+          }\n+        } catch(StorageException e){\n+          if (!NativeAzureFileSystemHelper.isFileNotFoundException(e)) {\n+            throw e;\n+          }\n         }\n       }\n \n       // There is no file with that key name, but maybe it is a folder.\n       // Query the underlying folder/container to list the blobs stored\n       // there under that key.\n       //\n       Iterable\u003cListBlobItem\u003e objects \u003d\n           listRootBlobs(\n               key,\n               true,\n               EnumSet.of(BlobListingDetails.METADATA),\n               null,\n           getInstrumentedContext());\n \n       // Check if the directory/container has the blob items.\n       for (ListBlobItem blobItem : objects) {\n         if (blobItem instanceof CloudBlockBlobWrapper\n             || blobItem instanceof CloudPageBlobWrapper) {\n           LOG.debug(\"Found blob as a directory-using this file under it to infer its properties {}\",\n               blobItem.getUri());\n \n           blob \u003d (CloudBlobWrapper) blobItem;\n           // The key specifies a directory. Create a FileMetadata object which\n           // specifies as such.\n           BlobProperties properties \u003d blob.getProperties();\n \n           return new FileMetadata(key, properties.getLastModified().getTime(),\n               getPermissionStatus(blob), BlobMaterialization.Implicit);\n         }\n       }\n \n       // Return to caller with a null metadata object.\n       return null;\n \n     } catch (Exception e) {\n       // Re-throw the exception as an Azure storage exception.\n       throw new AzureException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileMetadata retrieveMetadata(String key) throws IOException {\n\n    // Attempts to check status may occur before opening any streams so first,\n    // check if a session exists, if not create a session with the Azure storage\n    // server.\n    if (null \u003d\u003d storageInteractionLayer) {\n      final String errMsg \u003d String.format(\n          \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n          sessionUri);\n      throw new AssertionError(errMsg);\n    }\n\n    LOG.debug(\"Retrieving metadata for {}\", key);\n\n    try {\n      if (checkContainer(ContainerAccessType.PureRead) \u003d\u003d ContainerState.DoesntExist) {\n        // The container doesn\u0027t exist, so spare some service calls and just\n        // return null now.\n        return null;\n      }\n\n      // Handle the degenerate cases where the key does not exist or the\n      // key is a container.\n      if (key.equals(\"/\")) {\n        // The key refers to root directory of container.\n        // Set the modification time for root to zero.\n        return new FileMetadata(key, 0, defaultPermissionNoBlobMetadata(),\n            BlobMaterialization.Implicit);\n      }\n\n      CloudBlobWrapper blob \u003d getBlobReference(key);\n\n      // Download attributes and return file metadata only if the blob\n      // exists.\n      if (null !\u003d blob \u0026\u0026 blob.exists(getInstrumentedContext())) {\n\n        LOG.debug(\"Found {} as an explicit blob. Checking if it\u0027s a file or folder.\", key);\n\n        try {\n          // The blob exists, so capture the metadata from the blob\n          // properties.\n          blob.downloadAttributes(getInstrumentedContext());\n          BlobProperties properties \u003d blob.getProperties();\n\n          if (retrieveFolderAttribute(blob)) {\n            LOG.debug(\"{} is a folder blob.\", key);\n            return new FileMetadata(key, properties.getLastModified().getTime(),\n                getPermissionStatus(blob), BlobMaterialization.Explicit);\n          } else {\n\n            LOG.debug(\"{} is a normal blob.\", key);\n\n            return new FileMetadata(\n                key, // Always return denormalized key with metadata.\n                getDataLength(blob, properties),\n                properties.getLastModified().getTime(),\n                getPermissionStatus(blob));\n          }\n        } catch(StorageException e){\n          if (!NativeAzureFileSystemHelper.isFileNotFoundException(e)) {\n            throw e;\n          }\n        }\n      }\n\n      // There is no file with that key name, but maybe it is a folder.\n      // Query the underlying folder/container to list the blobs stored\n      // there under that key.\n      //\n      Iterable\u003cListBlobItem\u003e objects \u003d\n          listRootBlobs(\n              key,\n              true,\n              EnumSet.of(BlobListingDetails.METADATA),\n              null,\n          getInstrumentedContext());\n\n      // Check if the directory/container has the blob items.\n      for (ListBlobItem blobItem : objects) {\n        if (blobItem instanceof CloudBlockBlobWrapper\n            || blobItem instanceof CloudPageBlobWrapper) {\n          LOG.debug(\"Found blob as a directory-using this file under it to infer its properties {}\",\n              blobItem.getUri());\n\n          blob \u003d (CloudBlobWrapper) blobItem;\n          // The key specifies a directory. Create a FileMetadata object which\n          // specifies as such.\n          BlobProperties properties \u003d blob.getProperties();\n\n          return new FileMetadata(key, properties.getLastModified().getTime(),\n              getPermissionStatus(blob), BlobMaterialization.Implicit);\n        }\n      }\n\n      // Return to caller with a null metadata object.\n      return null;\n\n    } catch (Exception e) {\n      // Re-throw the exception as an Azure storage exception.\n      throw new AzureException(e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java",
      "extendedDetails": {}
    },
    "5f6edb30c2bb648d5564c951edc25645e17e6636": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12350. WASB Logging: Improve WASB Logging around deletes, reads and writes. Contributed by Dushyanth.\n",
      "commitDate": "05/10/15 8:11 PM",
      "commitName": "5f6edb30c2bb648d5564c951edc25645e17e6636",
      "commitAuthor": "cnauroth",
      "commitDateOld": "08/06/15 10:42 PM",
      "commitNameOld": "c45784bc9031353b938f4756473937cca759b3dc",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 118.9,
      "commitsBetweenForRepo": 778,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,104 +1,96 @@\n   public FileMetadata retrieveMetadata(String key) throws IOException {\n \n     // Attempts to check status may occur before opening any streams so first,\n     // check if a session exists, if not create a session with the Azure storage\n     // server.\n     if (null \u003d\u003d storageInteractionLayer) {\n       final String errMsg \u003d String.format(\n           \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n           sessionUri);\n       throw new AssertionError(errMsg);\n     }\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Retrieving metadata for \" + key);\n-    }\n+    LOG.debug(\"Retrieving metadata for {}\", key);\n \n     try {\n       if (checkContainer(ContainerAccessType.PureRead) \u003d\u003d ContainerState.DoesntExist) {\n         // The container doesn\u0027t exist, so spare some service calls and just\n         // return null now.\n         return null;\n       }\n \n       // Handle the degenerate cases where the key does not exist or the\n       // key is a container.\n       if (key.equals(\"/\")) {\n         // The key refers to root directory of container.\n         // Set the modification time for root to zero.\n         return new FileMetadata(key, 0, defaultPermissionNoBlobMetadata(),\n             BlobMaterialization.Implicit);\n       }\n \n       CloudBlobWrapper blob \u003d getBlobReference(key);\n \n       // Download attributes and return file metadata only if the blob\n       // exists.\n       if (null !\u003d blob \u0026\u0026 blob.exists(getInstrumentedContext())) {\n \n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Found \" + key\n-              + \" as an explicit blob. Checking if it\u0027s a file or folder.\");\n-        }\n+        LOG.debug(\"Found {} as an explicit blob. Checking if it\u0027s a file or folder.\", key);\n \n         // The blob exists, so capture the metadata from the blob\n         // properties.\n         blob.downloadAttributes(getInstrumentedContext());\n         BlobProperties properties \u003d blob.getProperties();\n \n         if (retrieveFolderAttribute(blob)) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(key + \" is a folder blob.\");\n-          }\n+          LOG.debug(\"{} is a folder blob.\", key);\n           return new FileMetadata(key, properties.getLastModified().getTime(),\n               getPermissionStatus(blob), BlobMaterialization.Explicit);\n         } else {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(key + \" is a normal blob.\");\n-          }\n+\n+          LOG.debug(\"{} is a normal blob.\", key);\n \n           return new FileMetadata(\n               key, // Always return denormalized key with metadata.\n               getDataLength(blob, properties),\n               properties.getLastModified().getTime(),\n               getPermissionStatus(blob));\n         }\n       }\n \n       // There is no file with that key name, but maybe it is a folder.\n       // Query the underlying folder/container to list the blobs stored\n       // there under that key.\n       //\n       Iterable\u003cListBlobItem\u003e objects \u003d\n           listRootBlobs(\n               key,\n               true,\n               EnumSet.of(BlobListingDetails.METADATA),\n               null,\n           getInstrumentedContext());\n \n       // Check if the directory/container has the blob items.\n       for (ListBlobItem blobItem : objects) {\n         if (blobItem instanceof CloudBlockBlobWrapper\n             || blobItem instanceof CloudPageBlobWrapper) {\n-          LOG.debug(\"Found blob as a directory-using this file under it to infer its properties \"\n-              + blobItem.getUri());\n+          LOG.debug(\"Found blob as a directory-using this file under it to infer its properties {}\",\n+              blobItem.getUri());\n \n           blob \u003d (CloudBlobWrapper) blobItem;\n           // The key specifies a directory. Create a FileMetadata object which\n           // specifies as such.\n           BlobProperties properties \u003d blob.getProperties();\n \n           return new FileMetadata(key, properties.getLastModified().getTime(),\n               getPermissionStatus(blob), BlobMaterialization.Implicit);\n         }\n       }\n \n       // Return to caller with a null metadata object.\n       return null;\n \n     } catch (Exception e) {\n       // Re-throw the exception as an Azure storage exception.\n       throw new AzureException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileMetadata retrieveMetadata(String key) throws IOException {\n\n    // Attempts to check status may occur before opening any streams so first,\n    // check if a session exists, if not create a session with the Azure storage\n    // server.\n    if (null \u003d\u003d storageInteractionLayer) {\n      final String errMsg \u003d String.format(\n          \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n          sessionUri);\n      throw new AssertionError(errMsg);\n    }\n\n    LOG.debug(\"Retrieving metadata for {}\", key);\n\n    try {\n      if (checkContainer(ContainerAccessType.PureRead) \u003d\u003d ContainerState.DoesntExist) {\n        // The container doesn\u0027t exist, so spare some service calls and just\n        // return null now.\n        return null;\n      }\n\n      // Handle the degenerate cases where the key does not exist or the\n      // key is a container.\n      if (key.equals(\"/\")) {\n        // The key refers to root directory of container.\n        // Set the modification time for root to zero.\n        return new FileMetadata(key, 0, defaultPermissionNoBlobMetadata(),\n            BlobMaterialization.Implicit);\n      }\n\n      CloudBlobWrapper blob \u003d getBlobReference(key);\n\n      // Download attributes and return file metadata only if the blob\n      // exists.\n      if (null !\u003d blob \u0026\u0026 blob.exists(getInstrumentedContext())) {\n\n        LOG.debug(\"Found {} as an explicit blob. Checking if it\u0027s a file or folder.\", key);\n\n        // The blob exists, so capture the metadata from the blob\n        // properties.\n        blob.downloadAttributes(getInstrumentedContext());\n        BlobProperties properties \u003d blob.getProperties();\n\n        if (retrieveFolderAttribute(blob)) {\n          LOG.debug(\"{} is a folder blob.\", key);\n          return new FileMetadata(key, properties.getLastModified().getTime(),\n              getPermissionStatus(blob), BlobMaterialization.Explicit);\n        } else {\n\n          LOG.debug(\"{} is a normal blob.\", key);\n\n          return new FileMetadata(\n              key, // Always return denormalized key with metadata.\n              getDataLength(blob, properties),\n              properties.getLastModified().getTime(),\n              getPermissionStatus(blob));\n        }\n      }\n\n      // There is no file with that key name, but maybe it is a folder.\n      // Query the underlying folder/container to list the blobs stored\n      // there under that key.\n      //\n      Iterable\u003cListBlobItem\u003e objects \u003d\n          listRootBlobs(\n              key,\n              true,\n              EnumSet.of(BlobListingDetails.METADATA),\n              null,\n          getInstrumentedContext());\n\n      // Check if the directory/container has the blob items.\n      for (ListBlobItem blobItem : objects) {\n        if (blobItem instanceof CloudBlockBlobWrapper\n            || blobItem instanceof CloudPageBlobWrapper) {\n          LOG.debug(\"Found blob as a directory-using this file under it to infer its properties {}\",\n              blobItem.getUri());\n\n          blob \u003d (CloudBlobWrapper) blobItem;\n          // The key specifies a directory. Create a FileMetadata object which\n          // specifies as such.\n          BlobProperties properties \u003d blob.getProperties();\n\n          return new FileMetadata(key, properties.getLastModified().getTime(),\n              getPermissionStatus(blob), BlobMaterialization.Implicit);\n        }\n      }\n\n      // Return to caller with a null metadata object.\n      return null;\n\n    } catch (Exception e) {\n      // Re-throw the exception as an Azure storage exception.\n      throw new AzureException(e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java",
      "extendedDetails": {}
    },
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
      "commitDate": "08/10/14 2:20 PM",
      "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
      "commitAuthor": "cnauroth",
      "commitDateOld": "24/06/14 1:52 PM",
      "commitNameOld": "0d91576ec31f63402f2db6107a04155368e2632d",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 106.02,
      "commitsBetweenForRepo": 1005,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,104 @@\n   public FileMetadata retrieveMetadata(String key) throws IOException {\n \n     // Attempts to check status may occur before opening any streams so first,\n     // check if a session exists, if not create a session with the Azure storage\n     // server.\n     if (null \u003d\u003d storageInteractionLayer) {\n       final String errMsg \u003d String.format(\n           \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n           sessionUri);\n       throw new AssertionError(errMsg);\n     }\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Retrieving metadata for \" + key);\n     }\n \n     try {\n       if (checkContainer(ContainerAccessType.PureRead) \u003d\u003d ContainerState.DoesntExist) {\n         // The container doesn\u0027t exist, so spare some service calls and just\n         // return null now.\n         return null;\n       }\n \n       // Handle the degenerate cases where the key does not exist or the\n       // key is a container.\n       if (key.equals(\"/\")) {\n         // The key refers to root directory of container.\n         // Set the modification time for root to zero.\n         return new FileMetadata(key, 0, defaultPermissionNoBlobMetadata(),\n             BlobMaterialization.Implicit);\n       }\n \n-      CloudBlockBlobWrapper blob \u003d getBlobReference(key);\n+      CloudBlobWrapper blob \u003d getBlobReference(key);\n \n       // Download attributes and return file metadata only if the blob\n       // exists.\n       if (null !\u003d blob \u0026\u0026 blob.exists(getInstrumentedContext())) {\n \n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Found \" + key\n               + \" as an explicit blob. Checking if it\u0027s a file or folder.\");\n         }\n \n         // The blob exists, so capture the metadata from the blob\n         // properties.\n         blob.downloadAttributes(getInstrumentedContext());\n         BlobProperties properties \u003d blob.getProperties();\n \n         if (retrieveFolderAttribute(blob)) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(key + \" is a folder blob.\");\n           }\n           return new FileMetadata(key, properties.getLastModified().getTime(),\n               getPermissionStatus(blob), BlobMaterialization.Explicit);\n         } else {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(key + \" is a normal blob.\");\n           }\n \n           return new FileMetadata(\n               key, // Always return denormalized key with metadata.\n-              properties.getLength(), properties.getLastModified().getTime(),\n+              getDataLength(blob, properties),\n+              properties.getLastModified().getTime(),\n               getPermissionStatus(blob));\n         }\n       }\n \n       // There is no file with that key name, but maybe it is a folder.\n       // Query the underlying folder/container to list the blobs stored\n       // there under that key.\n-      Iterable\u003cListBlobItem\u003e objects \u003d listRootBlobs(key, true,\n-          EnumSet.of(BlobListingDetails.METADATA), null,\n+      //\n+      Iterable\u003cListBlobItem\u003e objects \u003d\n+          listRootBlobs(\n+              key,\n+              true,\n+              EnumSet.of(BlobListingDetails.METADATA),\n+              null,\n           getInstrumentedContext());\n \n       // Check if the directory/container has the blob items.\n       for (ListBlobItem blobItem : objects) {\n-        if (blobItem instanceof CloudBlockBlobWrapper) {\n+        if (blobItem instanceof CloudBlockBlobWrapper\n+            || blobItem instanceof CloudPageBlobWrapper) {\n           LOG.debug(\"Found blob as a directory-using this file under it to infer its properties \"\n               + blobItem.getUri());\n \n-          blob \u003d (CloudBlockBlobWrapper) blobItem;\n+          blob \u003d (CloudBlobWrapper) blobItem;\n           // The key specifies a directory. Create a FileMetadata object which\n           // specifies as such.\n           BlobProperties properties \u003d blob.getProperties();\n \n           return new FileMetadata(key, properties.getLastModified().getTime(),\n               getPermissionStatus(blob), BlobMaterialization.Implicit);\n         }\n       }\n \n       // Return to caller with a null metadata object.\n       return null;\n \n     } catch (Exception e) {\n       // Re-throw the exception as an Azure storage exception.\n       throw new AzureException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FileMetadata retrieveMetadata(String key) throws IOException {\n\n    // Attempts to check status may occur before opening any streams so first,\n    // check if a session exists, if not create a session with the Azure storage\n    // server.\n    if (null \u003d\u003d storageInteractionLayer) {\n      final String errMsg \u003d String.format(\n          \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n          sessionUri);\n      throw new AssertionError(errMsg);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Retrieving metadata for \" + key);\n    }\n\n    try {\n      if (checkContainer(ContainerAccessType.PureRead) \u003d\u003d ContainerState.DoesntExist) {\n        // The container doesn\u0027t exist, so spare some service calls and just\n        // return null now.\n        return null;\n      }\n\n      // Handle the degenerate cases where the key does not exist or the\n      // key is a container.\n      if (key.equals(\"/\")) {\n        // The key refers to root directory of container.\n        // Set the modification time for root to zero.\n        return new FileMetadata(key, 0, defaultPermissionNoBlobMetadata(),\n            BlobMaterialization.Implicit);\n      }\n\n      CloudBlobWrapper blob \u003d getBlobReference(key);\n\n      // Download attributes and return file metadata only if the blob\n      // exists.\n      if (null !\u003d blob \u0026\u0026 blob.exists(getInstrumentedContext())) {\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found \" + key\n              + \" as an explicit blob. Checking if it\u0027s a file or folder.\");\n        }\n\n        // The blob exists, so capture the metadata from the blob\n        // properties.\n        blob.downloadAttributes(getInstrumentedContext());\n        BlobProperties properties \u003d blob.getProperties();\n\n        if (retrieveFolderAttribute(blob)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(key + \" is a folder blob.\");\n          }\n          return new FileMetadata(key, properties.getLastModified().getTime(),\n              getPermissionStatus(blob), BlobMaterialization.Explicit);\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(key + \" is a normal blob.\");\n          }\n\n          return new FileMetadata(\n              key, // Always return denormalized key with metadata.\n              getDataLength(blob, properties),\n              properties.getLastModified().getTime(),\n              getPermissionStatus(blob));\n        }\n      }\n\n      // There is no file with that key name, but maybe it is a folder.\n      // Query the underlying folder/container to list the blobs stored\n      // there under that key.\n      //\n      Iterable\u003cListBlobItem\u003e objects \u003d\n          listRootBlobs(\n              key,\n              true,\n              EnumSet.of(BlobListingDetails.METADATA),\n              null,\n          getInstrumentedContext());\n\n      // Check if the directory/container has the blob items.\n      for (ListBlobItem blobItem : objects) {\n        if (blobItem instanceof CloudBlockBlobWrapper\n            || blobItem instanceof CloudPageBlobWrapper) {\n          LOG.debug(\"Found blob as a directory-using this file under it to infer its properties \"\n              + blobItem.getUri());\n\n          blob \u003d (CloudBlobWrapper) blobItem;\n          // The key specifies a directory. Create a FileMetadata object which\n          // specifies as such.\n          BlobProperties properties \u003d blob.getProperties();\n\n          return new FileMetadata(key, properties.getLastModified().getTime(),\n              getPermissionStatus(blob), BlobMaterialization.Implicit);\n        }\n      }\n\n      // Return to caller with a null metadata object.\n      return null;\n\n    } catch (Exception e) {\n      // Re-throw the exception as an Azure storage exception.\n      throw new AzureException(e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java",
      "extendedDetails": {}
    },
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9629. Support Windows Azure Storage - Blob as a file system in Hadoop. Contributed by Dexter Bradshaw, Mostafa Elhemali, Xi Fang, Johannes Klein, David Lao, Mike Liddell, Chuan Liu, Lengning Liu, Ivan Mitic, Michael Rys, Alexander Stojanovic, Brian Swan, and Min Wei.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601781 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/06/14 3:26 PM",
      "commitName": "81bc395deb3ba00567dc067d6ca71bacf9e3bc82",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,97 @@\n+  public FileMetadata retrieveMetadata(String key) throws IOException {\n+\n+    // Attempts to check status may occur before opening any streams so first,\n+    // check if a session exists, if not create a session with the Azure storage\n+    // server.\n+    if (null \u003d\u003d storageInteractionLayer) {\n+      final String errMsg \u003d String.format(\n+          \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n+          sessionUri);\n+      throw new AssertionError(errMsg);\n+    }\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Retrieving metadata for \" + key);\n+    }\n+\n+    try {\n+      if (checkContainer(ContainerAccessType.PureRead) \u003d\u003d ContainerState.DoesntExist) {\n+        // The container doesn\u0027t exist, so spare some service calls and just\n+        // return null now.\n+        return null;\n+      }\n+\n+      // Handle the degenerate cases where the key does not exist or the\n+      // key is a container.\n+      if (key.equals(\"/\")) {\n+        // The key refers to root directory of container.\n+        // Set the modification time for root to zero.\n+        return new FileMetadata(key, 0, defaultPermissionNoBlobMetadata(),\n+            BlobMaterialization.Implicit);\n+      }\n+\n+      CloudBlockBlobWrapper blob \u003d getBlobReference(key);\n+\n+      // Download attributes and return file metadata only if the blob\n+      // exists.\n+      if (null !\u003d blob \u0026\u0026 blob.exists(getInstrumentedContext())) {\n+\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Found \" + key\n+              + \" as an explicit blob. Checking if it\u0027s a file or folder.\");\n+        }\n+\n+        // The blob exists, so capture the metadata from the blob\n+        // properties.\n+        blob.downloadAttributes(getInstrumentedContext());\n+        BlobProperties properties \u003d blob.getProperties();\n+\n+        if (retrieveFolderAttribute(blob)) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(key + \" is a folder blob.\");\n+          }\n+          return new FileMetadata(key, properties.getLastModified().getTime(),\n+              getPermissionStatus(blob), BlobMaterialization.Explicit);\n+        } else {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(key + \" is a normal blob.\");\n+          }\n+\n+          return new FileMetadata(\n+              key, // Always return denormalized key with metadata.\n+              properties.getLength(), properties.getLastModified().getTime(),\n+              getPermissionStatus(blob));\n+        }\n+      }\n+\n+      // There is no file with that key name, but maybe it is a folder.\n+      // Query the underlying folder/container to list the blobs stored\n+      // there under that key.\n+      Iterable\u003cListBlobItem\u003e objects \u003d listRootBlobs(key, true,\n+          EnumSet.of(BlobListingDetails.METADATA), null,\n+          getInstrumentedContext());\n+\n+      // Check if the directory/container has the blob items.\n+      for (ListBlobItem blobItem : objects) {\n+        if (blobItem instanceof CloudBlockBlobWrapper) {\n+          LOG.debug(\"Found blob as a directory-using this file under it to infer its properties \"\n+              + blobItem.getUri());\n+\n+          blob \u003d (CloudBlockBlobWrapper) blobItem;\n+          // The key specifies a directory. Create a FileMetadata object which\n+          // specifies as such.\n+          BlobProperties properties \u003d blob.getProperties();\n+\n+          return new FileMetadata(key, properties.getLastModified().getTime(),\n+              getPermissionStatus(blob), BlobMaterialization.Implicit);\n+        }\n+      }\n+\n+      // Return to caller with a null metadata object.\n+      return null;\n+\n+    } catch (Exception e) {\n+      // Re-throw the exception as an Azure storage exception.\n+      throw new AzureException(e);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public FileMetadata retrieveMetadata(String key) throws IOException {\n\n    // Attempts to check status may occur before opening any streams so first,\n    // check if a session exists, if not create a session with the Azure storage\n    // server.\n    if (null \u003d\u003d storageInteractionLayer) {\n      final String errMsg \u003d String.format(\n          \"Storage session expected for URI \u0027%s\u0027 but does not exist.\",\n          sessionUri);\n      throw new AssertionError(errMsg);\n    }\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Retrieving metadata for \" + key);\n    }\n\n    try {\n      if (checkContainer(ContainerAccessType.PureRead) \u003d\u003d ContainerState.DoesntExist) {\n        // The container doesn\u0027t exist, so spare some service calls and just\n        // return null now.\n        return null;\n      }\n\n      // Handle the degenerate cases where the key does not exist or the\n      // key is a container.\n      if (key.equals(\"/\")) {\n        // The key refers to root directory of container.\n        // Set the modification time for root to zero.\n        return new FileMetadata(key, 0, defaultPermissionNoBlobMetadata(),\n            BlobMaterialization.Implicit);\n      }\n\n      CloudBlockBlobWrapper blob \u003d getBlobReference(key);\n\n      // Download attributes and return file metadata only if the blob\n      // exists.\n      if (null !\u003d blob \u0026\u0026 blob.exists(getInstrumentedContext())) {\n\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Found \" + key\n              + \" as an explicit blob. Checking if it\u0027s a file or folder.\");\n        }\n\n        // The blob exists, so capture the metadata from the blob\n        // properties.\n        blob.downloadAttributes(getInstrumentedContext());\n        BlobProperties properties \u003d blob.getProperties();\n\n        if (retrieveFolderAttribute(blob)) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(key + \" is a folder blob.\");\n          }\n          return new FileMetadata(key, properties.getLastModified().getTime(),\n              getPermissionStatus(blob), BlobMaterialization.Explicit);\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(key + \" is a normal blob.\");\n          }\n\n          return new FileMetadata(\n              key, // Always return denormalized key with metadata.\n              properties.getLength(), properties.getLastModified().getTime(),\n              getPermissionStatus(blob));\n        }\n      }\n\n      // There is no file with that key name, but maybe it is a folder.\n      // Query the underlying folder/container to list the blobs stored\n      // there under that key.\n      Iterable\u003cListBlobItem\u003e objects \u003d listRootBlobs(key, true,\n          EnumSet.of(BlobListingDetails.METADATA), null,\n          getInstrumentedContext());\n\n      // Check if the directory/container has the blob items.\n      for (ListBlobItem blobItem : objects) {\n        if (blobItem instanceof CloudBlockBlobWrapper) {\n          LOG.debug(\"Found blob as a directory-using this file under it to infer its properties \"\n              + blobItem.getUri());\n\n          blob \u003d (CloudBlockBlobWrapper) blobItem;\n          // The key specifies a directory. Create a FileMetadata object which\n          // specifies as such.\n          BlobProperties properties \u003d blob.getProperties();\n\n          return new FileMetadata(key, properties.getLastModified().getTime(),\n              getPermissionStatus(blob), BlobMaterialization.Implicit);\n        }\n      }\n\n      // Return to caller with a null metadata object.\n      return null;\n\n    } catch (Exception e) {\n      // Re-throw the exception as an Azure storage exception.\n      throw new AzureException(e);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/AzureNativeFileSystemStore.java"
    }
  }
}