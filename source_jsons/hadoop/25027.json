{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LocalResourceBuilder.java",
  "functionName": "createLocalResources",
  "functionId": "createLocalResources___localResources-Map__String,LocalResource__",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapreduce/v2/util/LocalResourceBuilder.java",
  "functionStartLine": 89,
  "functionEndLine": 159,
  "numCommitsSeen": 3,
  "timeTaken": 1423,
  "changeHistory": [
    "b3b4d4ccb53fdf8dacc66e912822b34f8b3bf215",
    "e46d5bb962b0c942f993afc505b165b1cd96e51b"
  ],
  "changeHistoryShort": {
    "b3b4d4ccb53fdf8dacc66e912822b34f8b3bf215": "Ybodychange",
    "e46d5bb962b0c942f993afc505b165b1cd96e51b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b3b4d4ccb53fdf8dacc66e912822b34f8b3bf215": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7118. Distributed cache conflicts breaks backwards compatability. (Jason Lowe via wangda)\n\nChange-Id: I89ab4852b4ad305fec19812e8931c59d96581376\n",
      "commitDate": "19/07/18 2:26 PM",
      "commitName": "b3b4d4ccb53fdf8dacc66e912822b34f8b3bf215",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/01/18 10:38 PM",
      "commitNameOld": "1a9c5d479e2259ac024da392b020967112c5af55",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 185.62,
      "commitsBetweenForRepo": 1901,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,71 @@\n   void createLocalResources(Map\u003cString, LocalResource\u003e localResources)\n       throws IOException {\n \n     if (uris !\u003d null) {\n       // Sanity check\n       if ((uris.length !\u003d timestamps.length) || (uris.length !\u003d sizes.length) ||\n           (uris.length !\u003d visibilities.length)) {\n         throw new IllegalArgumentException(\"Invalid specification for \" +\n             \"distributed-cache artifacts of type \" + type + \" :\" +\n             \" #uris\u003d\" + uris.length +\n             \" #timestamps\u003d\" + timestamps.length +\n             \" #visibilities\u003d\" + visibilities.length\n             );\n       }\n \n       for (int i \u003d 0; i \u003c uris.length; ++i) {\n         URI u \u003d uris[i];\n         Path p \u003d new Path(u);\n         FileSystem remoteFS \u003d p.getFileSystem(conf);\n         String linkName \u003d null;\n \n         if (p.getName().equals(DistributedCache.WILDCARD)) {\n           p \u003d p.getParent();\n           linkName \u003d p.getName() + Path.SEPARATOR + DistributedCache.WILDCARD;\n         }\n \n         p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n             remoteFS.getWorkingDirectory()));\n \n         // If there\u0027s no wildcard, try using the fragment for the link\n         if (linkName \u003d\u003d null) {\n           linkName \u003d u.getFragment();\n \n           // Because we don\u0027t know what\u0027s in the fragment, we have to handle\n           // it with care.\n           if (linkName !\u003d null) {\n             Path linkPath \u003d new Path(linkName);\n \n             if (linkPath.isAbsolute()) {\n               throw new IllegalArgumentException(\"Resource name must be \"\n                   + \"relative\");\n             }\n \n             linkName \u003d linkPath.toUri().getPath();\n           }\n         } else if (u.getFragment() !\u003d null) {\n           throw new IllegalArgumentException(\"Invalid path URI: \" + p +\n               \" - cannot contain both a URI fragment and a wildcard\");\n         }\n \n         // If there\u0027s no wildcard or fragment, just link to the file name\n         if (linkName \u003d\u003d null) {\n           linkName \u003d p.getName();\n         }\n \n         LocalResource orig \u003d localResources.get(linkName);\n         if(orig !\u003d null \u0026\u0026 !orig.getResource().equals(URL.fromURI(p.toUri()))) {\n-          throw new InvalidJobConfException(\n-              getResourceDescription(orig.getType()) + orig.getResource()\n-                  +\n-              \" conflicts with \" + getResourceDescription(type) + u);\n+          LOG.warn(getResourceDescription(orig.getType()) + orig.getResource()\n+              + \" conflicts with \" + getResourceDescription(type) + u);\n+          continue;\n         }\n         Boolean sharedCachePolicy \u003d sharedCacheUploadPolicies.get(u.toString());\n         sharedCachePolicy \u003d\n             sharedCachePolicy \u003d\u003d null ? Boolean.FALSE : sharedCachePolicy;\n         localResources.put(linkName, LocalResource.newInstance(URL.fromURI(p\n             .toUri()), type, visibilities[i] ? LocalResourceVisibility.PUBLIC\n                 : LocalResourceVisibility.PRIVATE,\n             sizes[i], timestamps[i], sharedCachePolicy));\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void createLocalResources(Map\u003cString, LocalResource\u003e localResources)\n      throws IOException {\n\n    if (uris !\u003d null) {\n      // Sanity check\n      if ((uris.length !\u003d timestamps.length) || (uris.length !\u003d sizes.length) ||\n          (uris.length !\u003d visibilities.length)) {\n        throw new IllegalArgumentException(\"Invalid specification for \" +\n            \"distributed-cache artifacts of type \" + type + \" :\" +\n            \" #uris\u003d\" + uris.length +\n            \" #timestamps\u003d\" + timestamps.length +\n            \" #visibilities\u003d\" + visibilities.length\n            );\n      }\n\n      for (int i \u003d 0; i \u003c uris.length; ++i) {\n        URI u \u003d uris[i];\n        Path p \u003d new Path(u);\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        String linkName \u003d null;\n\n        if (p.getName().equals(DistributedCache.WILDCARD)) {\n          p \u003d p.getParent();\n          linkName \u003d p.getName() + Path.SEPARATOR + DistributedCache.WILDCARD;\n        }\n\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n\n        // If there\u0027s no wildcard, try using the fragment for the link\n        if (linkName \u003d\u003d null) {\n          linkName \u003d u.getFragment();\n\n          // Because we don\u0027t know what\u0027s in the fragment, we have to handle\n          // it with care.\n          if (linkName !\u003d null) {\n            Path linkPath \u003d new Path(linkName);\n\n            if (linkPath.isAbsolute()) {\n              throw new IllegalArgumentException(\"Resource name must be \"\n                  + \"relative\");\n            }\n\n            linkName \u003d linkPath.toUri().getPath();\n          }\n        } else if (u.getFragment() !\u003d null) {\n          throw new IllegalArgumentException(\"Invalid path URI: \" + p +\n              \" - cannot contain both a URI fragment and a wildcard\");\n        }\n\n        // If there\u0027s no wildcard or fragment, just link to the file name\n        if (linkName \u003d\u003d null) {\n          linkName \u003d p.getName();\n        }\n\n        LocalResource orig \u003d localResources.get(linkName);\n        if(orig !\u003d null \u0026\u0026 !orig.getResource().equals(URL.fromURI(p.toUri()))) {\n          LOG.warn(getResourceDescription(orig.getType()) + orig.getResource()\n              + \" conflicts with \" + getResourceDescription(type) + u);\n          continue;\n        }\n        Boolean sharedCachePolicy \u003d sharedCacheUploadPolicies.get(u.toString());\n        sharedCachePolicy \u003d\n            sharedCachePolicy \u003d\u003d null ? Boolean.FALSE : sharedCachePolicy;\n        localResources.put(linkName, LocalResource.newInstance(URL.fromURI(p\n            .toUri()), type, visibilities[i] ? LocalResourceVisibility.PUBLIC\n                : LocalResourceVisibility.PRIVATE,\n            sizes[i], timestamps[i], sharedCachePolicy));\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapreduce/v2/util/LocalResourceBuilder.java",
      "extendedDetails": {}
    },
    "e46d5bb962b0c942f993afc505b165b1cd96e51b": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-5951. Add support for the YARN Shared Cache.\n",
      "commitDate": "12/10/17 10:59 AM",
      "commitName": "e46d5bb962b0c942f993afc505b165b1cd96e51b",
      "commitAuthor": "Chris Trezzo",
      "diff": "@@ -0,0 +1,72 @@\n+  void createLocalResources(Map\u003cString, LocalResource\u003e localResources)\n+      throws IOException {\n+\n+    if (uris !\u003d null) {\n+      // Sanity check\n+      if ((uris.length !\u003d timestamps.length) || (uris.length !\u003d sizes.length) ||\n+          (uris.length !\u003d visibilities.length)) {\n+        throw new IllegalArgumentException(\"Invalid specification for \" +\n+            \"distributed-cache artifacts of type \" + type + \" :\" +\n+            \" #uris\u003d\" + uris.length +\n+            \" #timestamps\u003d\" + timestamps.length +\n+            \" #visibilities\u003d\" + visibilities.length\n+            );\n+      }\n+\n+      for (int i \u003d 0; i \u003c uris.length; ++i) {\n+        URI u \u003d uris[i];\n+        Path p \u003d new Path(u);\n+        FileSystem remoteFS \u003d p.getFileSystem(conf);\n+        String linkName \u003d null;\n+\n+        if (p.getName().equals(DistributedCache.WILDCARD)) {\n+          p \u003d p.getParent();\n+          linkName \u003d p.getName() + Path.SEPARATOR + DistributedCache.WILDCARD;\n+        }\n+\n+        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n+            remoteFS.getWorkingDirectory()));\n+\n+        // If there\u0027s no wildcard, try using the fragment for the link\n+        if (linkName \u003d\u003d null) {\n+          linkName \u003d u.getFragment();\n+\n+          // Because we don\u0027t know what\u0027s in the fragment, we have to handle\n+          // it with care.\n+          if (linkName !\u003d null) {\n+            Path linkPath \u003d new Path(linkName);\n+\n+            if (linkPath.isAbsolute()) {\n+              throw new IllegalArgumentException(\"Resource name must be \"\n+                  + \"relative\");\n+            }\n+\n+            linkName \u003d linkPath.toUri().getPath();\n+          }\n+        } else if (u.getFragment() !\u003d null) {\n+          throw new IllegalArgumentException(\"Invalid path URI: \" + p +\n+              \" - cannot contain both a URI fragment and a wildcard\");\n+        }\n+\n+        // If there\u0027s no wildcard or fragment, just link to the file name\n+        if (linkName \u003d\u003d null) {\n+          linkName \u003d p.getName();\n+        }\n+\n+        LocalResource orig \u003d localResources.get(linkName);\n+        if(orig !\u003d null \u0026\u0026 !orig.getResource().equals(URL.fromURI(p.toUri()))) {\n+          throw new InvalidJobConfException(\n+              getResourceDescription(orig.getType()) + orig.getResource()\n+                  +\n+              \" conflicts with \" + getResourceDescription(type) + u);\n+        }\n+        Boolean sharedCachePolicy \u003d sharedCacheUploadPolicies.get(u.toString());\n+        sharedCachePolicy \u003d\n+            sharedCachePolicy \u003d\u003d null ? Boolean.FALSE : sharedCachePolicy;\n+        localResources.put(linkName, LocalResource.newInstance(URL.fromURI(p\n+            .toUri()), type, visibilities[i] ? LocalResourceVisibility.PUBLIC\n+                : LocalResourceVisibility.PRIVATE,\n+            sizes[i], timestamps[i], sharedCachePolicy));\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void createLocalResources(Map\u003cString, LocalResource\u003e localResources)\n      throws IOException {\n\n    if (uris !\u003d null) {\n      // Sanity check\n      if ((uris.length !\u003d timestamps.length) || (uris.length !\u003d sizes.length) ||\n          (uris.length !\u003d visibilities.length)) {\n        throw new IllegalArgumentException(\"Invalid specification for \" +\n            \"distributed-cache artifacts of type \" + type + \" :\" +\n            \" #uris\u003d\" + uris.length +\n            \" #timestamps\u003d\" + timestamps.length +\n            \" #visibilities\u003d\" + visibilities.length\n            );\n      }\n\n      for (int i \u003d 0; i \u003c uris.length; ++i) {\n        URI u \u003d uris[i];\n        Path p \u003d new Path(u);\n        FileSystem remoteFS \u003d p.getFileSystem(conf);\n        String linkName \u003d null;\n\n        if (p.getName().equals(DistributedCache.WILDCARD)) {\n          p \u003d p.getParent();\n          linkName \u003d p.getName() + Path.SEPARATOR + DistributedCache.WILDCARD;\n        }\n\n        p \u003d remoteFS.resolvePath(p.makeQualified(remoteFS.getUri(),\n            remoteFS.getWorkingDirectory()));\n\n        // If there\u0027s no wildcard, try using the fragment for the link\n        if (linkName \u003d\u003d null) {\n          linkName \u003d u.getFragment();\n\n          // Because we don\u0027t know what\u0027s in the fragment, we have to handle\n          // it with care.\n          if (linkName !\u003d null) {\n            Path linkPath \u003d new Path(linkName);\n\n            if (linkPath.isAbsolute()) {\n              throw new IllegalArgumentException(\"Resource name must be \"\n                  + \"relative\");\n            }\n\n            linkName \u003d linkPath.toUri().getPath();\n          }\n        } else if (u.getFragment() !\u003d null) {\n          throw new IllegalArgumentException(\"Invalid path URI: \" + p +\n              \" - cannot contain both a URI fragment and a wildcard\");\n        }\n\n        // If there\u0027s no wildcard or fragment, just link to the file name\n        if (linkName \u003d\u003d null) {\n          linkName \u003d p.getName();\n        }\n\n        LocalResource orig \u003d localResources.get(linkName);\n        if(orig !\u003d null \u0026\u0026 !orig.getResource().equals(URL.fromURI(p.toUri()))) {\n          throw new InvalidJobConfException(\n              getResourceDescription(orig.getType()) + orig.getResource()\n                  +\n              \" conflicts with \" + getResourceDescription(type) + u);\n        }\n        Boolean sharedCachePolicy \u003d sharedCacheUploadPolicies.get(u.toString());\n        sharedCachePolicy \u003d\n            sharedCachePolicy \u003d\u003d null ? Boolean.FALSE : sharedCachePolicy;\n        localResources.put(linkName, LocalResource.newInstance(URL.fromURI(p\n            .toUri()), type, visibilities[i] ? LocalResourceVisibility.PUBLIC\n                : LocalResourceVisibility.PRIVATE,\n            sizes[i], timestamps[i], sharedCachePolicy));\n      }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-common/src/main/java/org/apache/hadoop/mapreduce/v2/util/LocalResourceBuilder.java"
    }
  }
}