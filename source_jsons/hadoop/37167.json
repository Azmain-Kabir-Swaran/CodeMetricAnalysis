{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StageAllocatorGreedyRLE.java",
  "functionName": "computeStageAllocation",
  "functionId": "computeStageAllocation___plan-Plan__planLoads-RLESparseResourceAllocation__planModifications-RLESparseResourceAllocation__rr-ReservationRequest__stageEarliestStart-long__stageDeadline-long__period-long__user-String__oldId-ReservationId",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedyRLE.java",
  "functionStartLine": 54,
  "functionEndLine": 204,
  "numCommitsSeen": 15,
  "timeTaken": 5264,
  "changeHistory": [
    "e6e614e380ed1d746973b50f666a9c40d272073e",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
    "e3345e985bff93c6c74a76747e45376c6027f42c",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
    "a3a615eeab8c14ccdc548311097e62a916963dc5",
    "7a9b7372a1a917c7b5e1beca7e13c0419e3dbfef",
    "5cf5c41a895f5ab8bf6270089f8cfdea50573a97"
  ],
  "changeHistoryShort": {
    "e6e614e380ed1d746973b50f666a9c40d272073e": "Ymultichange(Yparameterchange,Ybodychange)",
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": "Ybodychange",
    "e3345e985bff93c6c74a76747e45376c6027f42c": "Ybodychange",
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": "Ybodychange",
    "a3a615eeab8c14ccdc548311097e62a916963dc5": "Yparameterchange",
    "7a9b7372a1a917c7b5e1beca7e13c0419e3dbfef": "Ybodychange",
    "5cf5c41a895f5ab8bf6270089f8cfdea50573a97": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e6e614e380ed1d746973b50f666a9c40d272073e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
      "commitDate": "04/10/17 7:28 PM",
      "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
      "commitAuthor": "Subru Krishnan",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
          "commitDate": "04/10/17 7:28 PM",
          "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "06/09/17 4:46 PM",
          "commitNameOld": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 28.11,
          "commitsBetweenForRepo": 262,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,150 +1,151 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageEarliestStart, long stageDeadline, String user,\n+      long stageEarliestStart, long stageDeadline, long period, String user,\n       ReservationId oldId) throws PlanningException {\n \n     // abort early if the interval is not satisfiable\n     if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n       return null;\n     }\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     // compute the gang as a resource and get the duration\n     Resource sizeOfGang \u003d\n         Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     // get available resources from plan\n-    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n-        user, oldId, stageEarliestStart, stageDeadline, 0);\n+    RLESparseResourceAllocation netRLERes \u003d\n+        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n+            stageDeadline, period);\n \n     // remove plan modifications\n     netRLERes \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n             stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       int maxGang \u003d gangsToPlace;\n       long minPoint \u003d -1;\n \n       // focus our attention to a time-range under consideration\n       NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n           netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n               .getCumulative();\n \n       // revert the map for right-to-left allocation\n       if (!allocateLeft) {\n         partialMap \u003d partialMap.descendingMap();\n       }\n \n       Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n \n       long oldT \u003d stageDeadline;\n \n       // internal loop, tries to allocate as many gang as possible starting\n       // at a given point in time, if it fails we move to the next time\n       // interval (with outside loop)\n       while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n \n         long t;\n         Resource curAvailRes;\n \n         Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n         if (allocateLeft) {\n           t \u003d Math.max(e.getKey(), stageEarliestStart);\n           curAvailRes \u003d e.getValue();\n         } else {\n           t \u003d oldT;\n           oldT \u003d e.getKey();\n           //attention: higher means lower, because we reversed the map direction\n           curAvailRes \u003d partialMap.higherEntry(t).getValue();\n         }\n \n         // check exit/skip conditions/\n         if (curAvailRes \u003d\u003d null) {\n           //skip undefined regions (should not happen beside borders)\n           continue;\n         }\n         if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n           break;\n         }\n \n         // compute maximum number of gangs we could fit\n         int curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, curAvailRes, sizeOfGang));\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // update data structures that retain the progress made so far\n       gangsToPlace \u003d\n           trackProgress(planModifications, rr, stageEarliestStart,\n               stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n \n       // reset the next range of time-intervals to deal with\n       if (allocateLeft) {\n         // set earliest start to the min of the constraining \"range\" or my the\n         // end of this allocation\n         if(partialMap.higherKey(minPoint) \u003d\u003d null){\n           stageEarliestStart \u003d stageEarliestStart + dur;\n         } else {\n           stageEarliestStart \u003d\n              Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n         }\n       } else {\n         // same as above moving right-to-left\n         if(partialMap.higherKey(minPoint) \u003d\u003d null){\n           stageDeadline \u003d stageDeadline - dur;\n         } else {\n           stageDeadline \u003d\n               Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n         }\n       }\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is because we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n           allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, long period, String user,\n      ReservationId oldId) throws PlanningException {\n\n    // abort early if the interval is not satisfiable\n    if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n      return null;\n    }\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // compute the gang as a resource and get the duration\n    Resource sizeOfGang \u003d\n        Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    // get available resources from plan\n    RLESparseResourceAllocation netRLERes \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline, period);\n\n    // remove plan modifications\n    netRLERes \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n            stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      int maxGang \u003d gangsToPlace;\n      long minPoint \u003d -1;\n\n      // focus our attention to a time-range under consideration\n      NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n          netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n              .getCumulative();\n\n      // revert the map for right-to-left allocation\n      if (!allocateLeft) {\n        partialMap \u003d partialMap.descendingMap();\n      }\n\n      Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n\n      long oldT \u003d stageDeadline;\n\n      // internal loop, tries to allocate as many gang as possible starting\n      // at a given point in time, if it fails we move to the next time\n      // interval (with outside loop)\n      while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n\n        long t;\n        Resource curAvailRes;\n\n        Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n        if (allocateLeft) {\n          t \u003d Math.max(e.getKey(), stageEarliestStart);\n          curAvailRes \u003d e.getValue();\n        } else {\n          t \u003d oldT;\n          oldT \u003d e.getKey();\n          //attention: higher means lower, because we reversed the map direction\n          curAvailRes \u003d partialMap.higherEntry(t).getValue();\n        }\n\n        // check exit/skip conditions/\n        if (curAvailRes \u003d\u003d null) {\n          //skip undefined regions (should not happen beside borders)\n          continue;\n        }\n        if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n          break;\n        }\n\n        // compute maximum number of gangs we could fit\n        int curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, curAvailRes, sizeOfGang));\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // update data structures that retain the progress made so far\n      gangsToPlace \u003d\n          trackProgress(planModifications, rr, stageEarliestStart,\n              stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n\n      // reset the next range of time-intervals to deal with\n      if (allocateLeft) {\n        // set earliest start to the min of the constraining \"range\" or my the\n        // end of this allocation\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageEarliestStart \u003d stageEarliestStart + dur;\n        } else {\n          stageEarliestStart \u003d\n             Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n        }\n      } else {\n        // same as above moving right-to-left\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageDeadline \u003d stageDeadline - dur;\n        } else {\n          stageDeadline \u003d\n              Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n        }\n      }\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is because we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n          allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedyRLE.java",
          "extendedDetails": {
            "oldValue": "[plan-Plan, planLoads-RLESparseResourceAllocation, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long, user-String, oldId-ReservationId]",
            "newValue": "[plan-Plan, planLoads-RLESparseResourceAllocation, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long, period-long, user-String, oldId-ReservationId]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5329. Placement Agent enhancements required to support recurring reservations in ReservationSystem. (Carlo Curino via Subru).\n",
          "commitDate": "04/10/17 7:28 PM",
          "commitName": "e6e614e380ed1d746973b50f666a9c40d272073e",
          "commitAuthor": "Subru Krishnan",
          "commitDateOld": "06/09/17 4:46 PM",
          "commitNameOld": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
          "commitAuthorOld": "Subru Krishnan",
          "daysBetweenCommits": 28.11,
          "commitsBetweenForRepo": 262,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,150 +1,151 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n-      long stageEarliestStart, long stageDeadline, String user,\n+      long stageEarliestStart, long stageDeadline, long period, String user,\n       ReservationId oldId) throws PlanningException {\n \n     // abort early if the interval is not satisfiable\n     if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n       return null;\n     }\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     // compute the gang as a resource and get the duration\n     Resource sizeOfGang \u003d\n         Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     // get available resources from plan\n-    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n-        user, oldId, stageEarliestStart, stageDeadline, 0);\n+    RLESparseResourceAllocation netRLERes \u003d\n+        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n+            stageDeadline, period);\n \n     // remove plan modifications\n     netRLERes \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n             stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       int maxGang \u003d gangsToPlace;\n       long minPoint \u003d -1;\n \n       // focus our attention to a time-range under consideration\n       NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n           netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n               .getCumulative();\n \n       // revert the map for right-to-left allocation\n       if (!allocateLeft) {\n         partialMap \u003d partialMap.descendingMap();\n       }\n \n       Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n \n       long oldT \u003d stageDeadline;\n \n       // internal loop, tries to allocate as many gang as possible starting\n       // at a given point in time, if it fails we move to the next time\n       // interval (with outside loop)\n       while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n \n         long t;\n         Resource curAvailRes;\n \n         Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n         if (allocateLeft) {\n           t \u003d Math.max(e.getKey(), stageEarliestStart);\n           curAvailRes \u003d e.getValue();\n         } else {\n           t \u003d oldT;\n           oldT \u003d e.getKey();\n           //attention: higher means lower, because we reversed the map direction\n           curAvailRes \u003d partialMap.higherEntry(t).getValue();\n         }\n \n         // check exit/skip conditions/\n         if (curAvailRes \u003d\u003d null) {\n           //skip undefined regions (should not happen beside borders)\n           continue;\n         }\n         if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n           break;\n         }\n \n         // compute maximum number of gangs we could fit\n         int curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, curAvailRes, sizeOfGang));\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // update data structures that retain the progress made so far\n       gangsToPlace \u003d\n           trackProgress(planModifications, rr, stageEarliestStart,\n               stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n \n       // reset the next range of time-intervals to deal with\n       if (allocateLeft) {\n         // set earliest start to the min of the constraining \"range\" or my the\n         // end of this allocation\n         if(partialMap.higherKey(minPoint) \u003d\u003d null){\n           stageEarliestStart \u003d stageEarliestStart + dur;\n         } else {\n           stageEarliestStart \u003d\n              Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n         }\n       } else {\n         // same as above moving right-to-left\n         if(partialMap.higherKey(minPoint) \u003d\u003d null){\n           stageDeadline \u003d stageDeadline - dur;\n         } else {\n           stageDeadline \u003d\n               Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n         }\n       }\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is because we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n           allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, long period, String user,\n      ReservationId oldId) throws PlanningException {\n\n    // abort early if the interval is not satisfiable\n    if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n      return null;\n    }\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // compute the gang as a resource and get the duration\n    Resource sizeOfGang \u003d\n        Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    // get available resources from plan\n    RLESparseResourceAllocation netRLERes \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline, period);\n\n    // remove plan modifications\n    netRLERes \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n            stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      int maxGang \u003d gangsToPlace;\n      long minPoint \u003d -1;\n\n      // focus our attention to a time-range under consideration\n      NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n          netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n              .getCumulative();\n\n      // revert the map for right-to-left allocation\n      if (!allocateLeft) {\n        partialMap \u003d partialMap.descendingMap();\n      }\n\n      Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n\n      long oldT \u003d stageDeadline;\n\n      // internal loop, tries to allocate as many gang as possible starting\n      // at a given point in time, if it fails we move to the next time\n      // interval (with outside loop)\n      while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n\n        long t;\n        Resource curAvailRes;\n\n        Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n        if (allocateLeft) {\n          t \u003d Math.max(e.getKey(), stageEarliestStart);\n          curAvailRes \u003d e.getValue();\n        } else {\n          t \u003d oldT;\n          oldT \u003d e.getKey();\n          //attention: higher means lower, because we reversed the map direction\n          curAvailRes \u003d partialMap.higherEntry(t).getValue();\n        }\n\n        // check exit/skip conditions/\n        if (curAvailRes \u003d\u003d null) {\n          //skip undefined regions (should not happen beside borders)\n          continue;\n        }\n        if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n          break;\n        }\n\n        // compute maximum number of gangs we could fit\n        int curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, curAvailRes, sizeOfGang));\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // update data structures that retain the progress made so far\n      gangsToPlace \u003d\n          trackProgress(planModifications, rr, stageEarliestStart,\n              stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n\n      // reset the next range of time-intervals to deal with\n      if (allocateLeft) {\n        // set earliest start to the min of the constraining \"range\" or my the\n        // end of this allocation\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageEarliestStart \u003d stageEarliestStart + dur;\n        } else {\n          stageEarliestStart \u003d\n             Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n        }\n      } else {\n        // same as above moving right-to-left\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageDeadline \u003d stageDeadline - dur;\n        } else {\n          stageDeadline \u003d\n              Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n        }\n      }\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is because we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n          allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedyRLE.java",
          "extendedDetails": {}
        }
      ]
    },
    "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5328. Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "06/09/17 4:46 PM",
      "commitName": "b6e7d1369690eaf50ce9ea7968f91a72ecb74de0",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "06/09/17 4:39 PM",
      "commitNameOld": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,150 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageEarliestStart, long stageDeadline, String user,\n       ReservationId oldId) throws PlanningException {\n \n     // abort early if the interval is not satisfiable\n     if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n       return null;\n     }\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     // compute the gang as a resource and get the duration\n     Resource sizeOfGang \u003d\n         Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     // get available resources from plan\n-    RLESparseResourceAllocation netRLERes \u003d\n-        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n-            stageDeadline);\n+    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n+        user, oldId, stageEarliestStart, stageDeadline, 0);\n \n     // remove plan modifications\n     netRLERes \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n             stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       int maxGang \u003d gangsToPlace;\n       long minPoint \u003d -1;\n \n       // focus our attention to a time-range under consideration\n       NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n           netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n               .getCumulative();\n \n       // revert the map for right-to-left allocation\n       if (!allocateLeft) {\n         partialMap \u003d partialMap.descendingMap();\n       }\n \n       Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n \n       long oldT \u003d stageDeadline;\n \n       // internal loop, tries to allocate as many gang as possible starting\n       // at a given point in time, if it fails we move to the next time\n       // interval (with outside loop)\n       while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n \n         long t;\n         Resource curAvailRes;\n \n         Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n         if (allocateLeft) {\n           t \u003d Math.max(e.getKey(), stageEarliestStart);\n           curAvailRes \u003d e.getValue();\n         } else {\n           t \u003d oldT;\n           oldT \u003d e.getKey();\n           //attention: higher means lower, because we reversed the map direction\n           curAvailRes \u003d partialMap.higherEntry(t).getValue();\n         }\n \n         // check exit/skip conditions/\n         if (curAvailRes \u003d\u003d null) {\n           //skip undefined regions (should not happen beside borders)\n           continue;\n         }\n         if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n           break;\n         }\n \n         // compute maximum number of gangs we could fit\n         int curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, curAvailRes, sizeOfGang));\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // update data structures that retain the progress made so far\n       gangsToPlace \u003d\n           trackProgress(planModifications, rr, stageEarliestStart,\n               stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n \n       // reset the next range of time-intervals to deal with\n       if (allocateLeft) {\n         // set earliest start to the min of the constraining \"range\" or my the\n         // end of this allocation\n         if(partialMap.higherKey(minPoint) \u003d\u003d null){\n           stageEarliestStart \u003d stageEarliestStart + dur;\n         } else {\n           stageEarliestStart \u003d\n              Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n         }\n       } else {\n         // same as above moving right-to-left\n         if(partialMap.higherKey(minPoint) \u003d\u003d null){\n           stageDeadline \u003d stageDeadline - dur;\n         } else {\n           stageDeadline \u003d\n               Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n         }\n       }\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is because we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n           allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    // abort early if the interval is not satisfiable\n    if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n      return null;\n    }\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // compute the gang as a resource and get the duration\n    Resource sizeOfGang \u003d\n        Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    // get available resources from plan\n    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n        user, oldId, stageEarliestStart, stageDeadline, 0);\n\n    // remove plan modifications\n    netRLERes \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n            stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      int maxGang \u003d gangsToPlace;\n      long minPoint \u003d -1;\n\n      // focus our attention to a time-range under consideration\n      NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n          netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n              .getCumulative();\n\n      // revert the map for right-to-left allocation\n      if (!allocateLeft) {\n        partialMap \u003d partialMap.descendingMap();\n      }\n\n      Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n\n      long oldT \u003d stageDeadline;\n\n      // internal loop, tries to allocate as many gang as possible starting\n      // at a given point in time, if it fails we move to the next time\n      // interval (with outside loop)\n      while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n\n        long t;\n        Resource curAvailRes;\n\n        Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n        if (allocateLeft) {\n          t \u003d Math.max(e.getKey(), stageEarliestStart);\n          curAvailRes \u003d e.getValue();\n        } else {\n          t \u003d oldT;\n          oldT \u003d e.getKey();\n          //attention: higher means lower, because we reversed the map direction\n          curAvailRes \u003d partialMap.higherEntry(t).getValue();\n        }\n\n        // check exit/skip conditions/\n        if (curAvailRes \u003d\u003d null) {\n          //skip undefined regions (should not happen beside borders)\n          continue;\n        }\n        if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n          break;\n        }\n\n        // compute maximum number of gangs we could fit\n        int curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, curAvailRes, sizeOfGang));\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // update data structures that retain the progress made so far\n      gangsToPlace \u003d\n          trackProgress(planModifications, rr, stageEarliestStart,\n              stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n\n      // reset the next range of time-intervals to deal with\n      if (allocateLeft) {\n        // set earliest start to the min of the constraining \"range\" or my the\n        // end of this allocation\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageEarliestStart \u003d stageEarliestStart + dur;\n        } else {\n          stageEarliestStart \u003d\n             Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n        }\n      } else {\n        // same as above moving right-to-left\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageDeadline \u003d stageDeadline - dur;\n        } else {\n          stageDeadline \u003d\n              Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n        }\n      }\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is because we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n          allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedyRLE.java",
      "extendedDetails": {}
    },
    "e3345e985bff93c6c74a76747e45376c6027f42c": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\"\n\nThis reverts commit 7996eca7dcfaa1bdf970e32022274f2699bef8a1.\n",
      "commitDate": "06/09/17 4:39 PM",
      "commitName": "e3345e985bff93c6c74a76747e45376c6027f42c",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/09/17 3:16 PM",
      "commitNameOld": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 5.06,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,150 +1,151 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageEarliestStart, long stageDeadline, String user,\n       ReservationId oldId) throws PlanningException {\n \n     // abort early if the interval is not satisfiable\n     if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n       return null;\n     }\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     // compute the gang as a resource and get the duration\n     Resource sizeOfGang \u003d\n         Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     // get available resources from plan\n-    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n-        user, oldId, stageEarliestStart, stageDeadline, 0);\n+    RLESparseResourceAllocation netRLERes \u003d\n+        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n+            stageDeadline);\n \n     // remove plan modifications\n     netRLERes \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n             stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       int maxGang \u003d gangsToPlace;\n       long minPoint \u003d -1;\n \n       // focus our attention to a time-range under consideration\n       NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n           netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n               .getCumulative();\n \n       // revert the map for right-to-left allocation\n       if (!allocateLeft) {\n         partialMap \u003d partialMap.descendingMap();\n       }\n \n       Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n \n       long oldT \u003d stageDeadline;\n \n       // internal loop, tries to allocate as many gang as possible starting\n       // at a given point in time, if it fails we move to the next time\n       // interval (with outside loop)\n       while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n \n         long t;\n         Resource curAvailRes;\n \n         Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n         if (allocateLeft) {\n           t \u003d Math.max(e.getKey(), stageEarliestStart);\n           curAvailRes \u003d e.getValue();\n         } else {\n           t \u003d oldT;\n           oldT \u003d e.getKey();\n           //attention: higher means lower, because we reversed the map direction\n           curAvailRes \u003d partialMap.higherEntry(t).getValue();\n         }\n \n         // check exit/skip conditions/\n         if (curAvailRes \u003d\u003d null) {\n           //skip undefined regions (should not happen beside borders)\n           continue;\n         }\n         if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n           break;\n         }\n \n         // compute maximum number of gangs we could fit\n         int curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, curAvailRes, sizeOfGang));\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // update data structures that retain the progress made so far\n       gangsToPlace \u003d\n           trackProgress(planModifications, rr, stageEarliestStart,\n               stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n \n       // reset the next range of time-intervals to deal with\n       if (allocateLeft) {\n         // set earliest start to the min of the constraining \"range\" or my the\n         // end of this allocation\n         if(partialMap.higherKey(minPoint) \u003d\u003d null){\n           stageEarliestStart \u003d stageEarliestStart + dur;\n         } else {\n           stageEarliestStart \u003d\n              Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n         }\n       } else {\n         // same as above moving right-to-left\n         if(partialMap.higherKey(minPoint) \u003d\u003d null){\n           stageDeadline \u003d stageDeadline - dur;\n         } else {\n           stageDeadline \u003d\n               Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n         }\n       }\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is because we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n           allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    // abort early if the interval is not satisfiable\n    if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n      return null;\n    }\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // compute the gang as a resource and get the duration\n    Resource sizeOfGang \u003d\n        Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    // get available resources from plan\n    RLESparseResourceAllocation netRLERes \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline);\n\n    // remove plan modifications\n    netRLERes \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n            stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      int maxGang \u003d gangsToPlace;\n      long minPoint \u003d -1;\n\n      // focus our attention to a time-range under consideration\n      NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n          netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n              .getCumulative();\n\n      // revert the map for right-to-left allocation\n      if (!allocateLeft) {\n        partialMap \u003d partialMap.descendingMap();\n      }\n\n      Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n\n      long oldT \u003d stageDeadline;\n\n      // internal loop, tries to allocate as many gang as possible starting\n      // at a given point in time, if it fails we move to the next time\n      // interval (with outside loop)\n      while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n\n        long t;\n        Resource curAvailRes;\n\n        Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n        if (allocateLeft) {\n          t \u003d Math.max(e.getKey(), stageEarliestStart);\n          curAvailRes \u003d e.getValue();\n        } else {\n          t \u003d oldT;\n          oldT \u003d e.getKey();\n          //attention: higher means lower, because we reversed the map direction\n          curAvailRes \u003d partialMap.higherEntry(t).getValue();\n        }\n\n        // check exit/skip conditions/\n        if (curAvailRes \u003d\u003d null) {\n          //skip undefined regions (should not happen beside borders)\n          continue;\n        }\n        if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n          break;\n        }\n\n        // compute maximum number of gangs we could fit\n        int curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, curAvailRes, sizeOfGang));\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // update data structures that retain the progress made so far\n      gangsToPlace \u003d\n          trackProgress(planModifications, rr, stageEarliestStart,\n              stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n\n      // reset the next range of time-intervals to deal with\n      if (allocateLeft) {\n        // set earliest start to the min of the constraining \"range\" or my the\n        // end of this allocation\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageEarliestStart \u003d stageEarliestStart + dur;\n        } else {\n          stageEarliestStart \u003d\n             Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n        }\n      } else {\n        // same as above moving right-to-left\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageDeadline \u003d stageDeadline - dur;\n        } else {\n          stageDeadline \u003d\n              Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n        }\n      }\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is because we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n          allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedyRLE.java",
      "extendedDetails": {}
    },
    "7996eca7dcfaa1bdf970e32022274f2699bef8a1": {
      "type": "Ybodychange",
      "commitMessage": "Plan/ResourceAllocation data structure enhancements required to support recurring reservations in ReservationSystem.\n",
      "commitDate": "01/09/17 3:16 PM",
      "commitName": "7996eca7dcfaa1bdf970e32022274f2699bef8a1",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "01/05/17 4:01 PM",
      "commitNameOld": "a3a615eeab8c14ccdc548311097e62a916963dc5",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 122.97,
      "commitsBetweenForRepo": 775,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,150 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageEarliestStart, long stageDeadline, String user,\n       ReservationId oldId) throws PlanningException {\n \n     // abort early if the interval is not satisfiable\n     if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n       return null;\n     }\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     // compute the gang as a resource and get the duration\n     Resource sizeOfGang \u003d\n         Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     // get available resources from plan\n-    RLESparseResourceAllocation netRLERes \u003d\n-        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n-            stageDeadline);\n+    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n+        user, oldId, stageEarliestStart, stageDeadline, 0);\n \n     // remove plan modifications\n     netRLERes \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n             stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       int maxGang \u003d gangsToPlace;\n       long minPoint \u003d -1;\n \n       // focus our attention to a time-range under consideration\n       NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n           netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n               .getCumulative();\n \n       // revert the map for right-to-left allocation\n       if (!allocateLeft) {\n         partialMap \u003d partialMap.descendingMap();\n       }\n \n       Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n \n       long oldT \u003d stageDeadline;\n \n       // internal loop, tries to allocate as many gang as possible starting\n       // at a given point in time, if it fails we move to the next time\n       // interval (with outside loop)\n       while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n \n         long t;\n         Resource curAvailRes;\n \n         Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n         if (allocateLeft) {\n           t \u003d Math.max(e.getKey(), stageEarliestStart);\n           curAvailRes \u003d e.getValue();\n         } else {\n           t \u003d oldT;\n           oldT \u003d e.getKey();\n           //attention: higher means lower, because we reversed the map direction\n           curAvailRes \u003d partialMap.higherEntry(t).getValue();\n         }\n \n         // check exit/skip conditions/\n         if (curAvailRes \u003d\u003d null) {\n           //skip undefined regions (should not happen beside borders)\n           continue;\n         }\n         if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n           break;\n         }\n \n         // compute maximum number of gangs we could fit\n         int curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, curAvailRes, sizeOfGang));\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // update data structures that retain the progress made so far\n       gangsToPlace \u003d\n           trackProgress(planModifications, rr, stageEarliestStart,\n               stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n \n       // reset the next range of time-intervals to deal with\n       if (allocateLeft) {\n         // set earliest start to the min of the constraining \"range\" or my the\n         // end of this allocation\n         if(partialMap.higherKey(minPoint) \u003d\u003d null){\n           stageEarliestStart \u003d stageEarliestStart + dur;\n         } else {\n           stageEarliestStart \u003d\n              Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n         }\n       } else {\n         // same as above moving right-to-left\n         if(partialMap.higherKey(minPoint) \u003d\u003d null){\n           stageDeadline \u003d stageDeadline - dur;\n         } else {\n           stageDeadline \u003d\n               Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n         }\n       }\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is because we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n           allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    // abort early if the interval is not satisfiable\n    if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n      return null;\n    }\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // compute the gang as a resource and get the duration\n    Resource sizeOfGang \u003d\n        Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    // get available resources from plan\n    RLESparseResourceAllocation netRLERes \u003d plan.getAvailableResourceOverTime(\n        user, oldId, stageEarliestStart, stageDeadline, 0);\n\n    // remove plan modifications\n    netRLERes \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n            stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      int maxGang \u003d gangsToPlace;\n      long minPoint \u003d -1;\n\n      // focus our attention to a time-range under consideration\n      NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n          netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n              .getCumulative();\n\n      // revert the map for right-to-left allocation\n      if (!allocateLeft) {\n        partialMap \u003d partialMap.descendingMap();\n      }\n\n      Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n\n      long oldT \u003d stageDeadline;\n\n      // internal loop, tries to allocate as many gang as possible starting\n      // at a given point in time, if it fails we move to the next time\n      // interval (with outside loop)\n      while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n\n        long t;\n        Resource curAvailRes;\n\n        Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n        if (allocateLeft) {\n          t \u003d Math.max(e.getKey(), stageEarliestStart);\n          curAvailRes \u003d e.getValue();\n        } else {\n          t \u003d oldT;\n          oldT \u003d e.getKey();\n          //attention: higher means lower, because we reversed the map direction\n          curAvailRes \u003d partialMap.higherEntry(t).getValue();\n        }\n\n        // check exit/skip conditions/\n        if (curAvailRes \u003d\u003d null) {\n          //skip undefined regions (should not happen beside borders)\n          continue;\n        }\n        if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n          break;\n        }\n\n        // compute maximum number of gangs we could fit\n        int curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, curAvailRes, sizeOfGang));\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // update data structures that retain the progress made so far\n      gangsToPlace \u003d\n          trackProgress(planModifications, rr, stageEarliestStart,\n              stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n\n      // reset the next range of time-intervals to deal with\n      if (allocateLeft) {\n        // set earliest start to the min of the constraining \"range\" or my the\n        // end of this allocation\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageEarliestStart \u003d stageEarliestStart + dur;\n        } else {\n          stageEarliestStart \u003d\n             Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n        }\n      } else {\n        // same as above moving right-to-left\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageDeadline \u003d stageDeadline - dur;\n        } else {\n          stageDeadline \u003d\n              Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n        }\n      }\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is because we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n          allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedyRLE.java",
      "extendedDetails": {}
    },
    "a3a615eeab8c14ccdc548311097e62a916963dc5": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-4359. Update LowCost agents logic to take advantage of YARN-4358. (Jonathan Yaniv and Ishai Menache via Subru).\n",
      "commitDate": "01/05/17 4:01 PM",
      "commitName": "a3a615eeab8c14ccdc548311097e62a916963dc5",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "06/06/16 9:06 PM",
      "commitNameOld": "7a9b7372a1a917c7b5e1beca7e13c0419e3dbfef",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 328.79,
      "commitsBetweenForRepo": 2189,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,151 +1,151 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n-      Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageEarliestStart, long stageDeadline, String user,\n       ReservationId oldId) throws PlanningException {\n \n     // abort early if the interval is not satisfiable\n     if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n       return null;\n     }\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     // compute the gang as a resource and get the duration\n     Resource sizeOfGang \u003d\n         Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     // get available resources from plan\n     RLESparseResourceAllocation netRLERes \u003d\n         plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n             stageDeadline);\n \n     // remove plan modifications\n     netRLERes \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n             stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       int maxGang \u003d gangsToPlace;\n       long minPoint \u003d -1;\n \n       // focus our attention to a time-range under consideration\n       NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n           netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n               .getCumulative();\n \n       // revert the map for right-to-left allocation\n       if (!allocateLeft) {\n         partialMap \u003d partialMap.descendingMap();\n       }\n \n       Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n \n       long oldT \u003d stageDeadline;\n \n       // internal loop, tries to allocate as many gang as possible starting\n       // at a given point in time, if it fails we move to the next time\n       // interval (with outside loop)\n       while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n \n         long t;\n         Resource curAvailRes;\n \n         Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n         if (allocateLeft) {\n           t \u003d Math.max(e.getKey(), stageEarliestStart);\n           curAvailRes \u003d e.getValue();\n         } else {\n           t \u003d oldT;\n           oldT \u003d e.getKey();\n           //attention: higher means lower, because we reversed the map direction\n           curAvailRes \u003d partialMap.higherEntry(t).getValue();\n         }\n \n         // check exit/skip conditions/\n         if (curAvailRes \u003d\u003d null) {\n           //skip undefined regions (should not happen beside borders)\n           continue;\n         }\n         if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n           break;\n         }\n \n         // compute maximum number of gangs we could fit\n         int curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, curAvailRes, sizeOfGang));\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // update data structures that retain the progress made so far\n       gangsToPlace \u003d\n           trackProgress(planModifications, rr, stageEarliestStart,\n               stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n \n       // reset the next range of time-intervals to deal with\n       if (allocateLeft) {\n         // set earliest start to the min of the constraining \"range\" or my the\n         // end of this allocation\n         if(partialMap.higherKey(minPoint) \u003d\u003d null){\n           stageEarliestStart \u003d stageEarliestStart + dur;\n         } else {\n           stageEarliestStart \u003d\n              Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n         }\n       } else {\n         // same as above moving right-to-left\n         if(partialMap.higherKey(minPoint) \u003d\u003d null){\n           stageDeadline \u003d stageDeadline - dur;\n         } else {\n           stageDeadline \u003d\n               Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n         }\n       }\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is because we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n           allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      RLESparseResourceAllocation planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    // abort early if the interval is not satisfiable\n    if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n      return null;\n    }\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // compute the gang as a resource and get the duration\n    Resource sizeOfGang \u003d\n        Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    // get available resources from plan\n    RLESparseResourceAllocation netRLERes \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline);\n\n    // remove plan modifications\n    netRLERes \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n            stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      int maxGang \u003d gangsToPlace;\n      long minPoint \u003d -1;\n\n      // focus our attention to a time-range under consideration\n      NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n          netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n              .getCumulative();\n\n      // revert the map for right-to-left allocation\n      if (!allocateLeft) {\n        partialMap \u003d partialMap.descendingMap();\n      }\n\n      Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n\n      long oldT \u003d stageDeadline;\n\n      // internal loop, tries to allocate as many gang as possible starting\n      // at a given point in time, if it fails we move to the next time\n      // interval (with outside loop)\n      while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n\n        long t;\n        Resource curAvailRes;\n\n        Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n        if (allocateLeft) {\n          t \u003d Math.max(e.getKey(), stageEarliestStart);\n          curAvailRes \u003d e.getValue();\n        } else {\n          t \u003d oldT;\n          oldT \u003d e.getKey();\n          //attention: higher means lower, because we reversed the map direction\n          curAvailRes \u003d partialMap.higherEntry(t).getValue();\n        }\n\n        // check exit/skip conditions/\n        if (curAvailRes \u003d\u003d null) {\n          //skip undefined regions (should not happen beside borders)\n          continue;\n        }\n        if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n          break;\n        }\n\n        // compute maximum number of gangs we could fit\n        int curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, curAvailRes, sizeOfGang));\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // update data structures that retain the progress made so far\n      gangsToPlace \u003d\n          trackProgress(planModifications, rr, stageEarliestStart,\n              stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n\n      // reset the next range of time-intervals to deal with\n      if (allocateLeft) {\n        // set earliest start to the min of the constraining \"range\" or my the\n        // end of this allocation\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageEarliestStart \u003d stageEarliestStart + dur;\n        } else {\n          stageEarliestStart \u003d\n             Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n        }\n      } else {\n        // same as above moving right-to-left\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageDeadline \u003d stageDeadline - dur;\n        } else {\n          stageDeadline \u003d\n              Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n        }\n      }\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is because we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n          allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedyRLE.java",
      "extendedDetails": {
        "oldValue": "[plan-Plan, planLoads-Map\u003cLong,Resource\u003e, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long, user-String, oldId-ReservationId]",
        "newValue": "[plan-Plan, planLoads-RLESparseResourceAllocation, planModifications-RLESparseResourceAllocation, rr-ReservationRequest, stageEarliestStart-long, stageDeadline-long, user-String, oldId-ReservationId]"
      }
    },
    "7a9b7372a1a917c7b5e1beca7e13c0419e3dbfef": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5185. StageAllocaterGreedyRLE: Fix NPE in corner case. (Carlo Curino via asuresh)\n",
      "commitDate": "06/06/16 9:06 PM",
      "commitName": "7a9b7372a1a917c7b5e1beca7e13c0419e3dbfef",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "10/02/16 9:11 AM",
      "commitNameOld": "5cf5c41a895f5ab8bf6270089f8cfdea50573a97",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 117.46,
      "commitsBetweenForRepo": 751,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,151 @@\n   public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n       Map\u003cLong, Resource\u003e planLoads,\n       RLESparseResourceAllocation planModifications, ReservationRequest rr,\n       long stageEarliestStart, long stageDeadline, String user,\n       ReservationId oldId) throws PlanningException {\n \n     // abort early if the interval is not satisfiable\n     if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n       return null;\n     }\n \n     Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n         new HashMap\u003cReservationInterval, Resource\u003e();\n \n     Resource totalCapacity \u003d plan.getTotalCapacity();\n \n     // compute the gang as a resource and get the duration\n     Resource sizeOfGang \u003d\n         Resources.multiply(rr.getCapability(), rr.getConcurrency());\n     long dur \u003d rr.getDuration();\n     long step \u003d plan.getStep();\n \n     // ceil the duration to the next multiple of the plan step\n     if (dur % step !\u003d 0) {\n       dur +\u003d (step - (dur % step));\n     }\n \n     // we know for sure that this division has no remainder (part of contract\n     // with user, validate before\n     int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n \n     // get available resources from plan\n     RLESparseResourceAllocation netRLERes \u003d\n         plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n             stageDeadline);\n \n     // remove plan modifications\n     netRLERes \u003d\n         RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n             totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n             stageEarliestStart, stageDeadline);\n \n     // loop trying to place until we are done, or we are considering\n     // an invalid range of times\n     while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n \n       // as we run along we remember how many gangs we can fit, and what\n       // was the most constraining moment in time (we will restart just\n       // after that to place the next batch)\n       int maxGang \u003d gangsToPlace;\n       long minPoint \u003d -1;\n \n       // focus our attention to a time-range under consideration\n       NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n           netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n               .getCumulative();\n \n       // revert the map for right-to-left allocation\n       if (!allocateLeft) {\n         partialMap \u003d partialMap.descendingMap();\n       }\n \n       Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n \n       long oldT \u003d stageDeadline;\n \n       // internal loop, tries to allocate as many gang as possible starting\n       // at a given point in time, if it fails we move to the next time\n       // interval (with outside loop)\n       while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n \n         long t;\n         Resource curAvailRes;\n \n         Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n         if (allocateLeft) {\n           t \u003d Math.max(e.getKey(), stageEarliestStart);\n           curAvailRes \u003d e.getValue();\n         } else {\n           t \u003d oldT;\n           oldT \u003d e.getKey();\n           //attention: higher means lower, because we reversed the map direction\n           curAvailRes \u003d partialMap.higherEntry(t).getValue();\n         }\n \n         // check exit/skip conditions/\n         if (curAvailRes \u003d\u003d null) {\n           //skip undefined regions (should not happen beside borders)\n           continue;\n         }\n         if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n           break;\n         }\n \n         // compute maximum number of gangs we could fit\n         int curMaxGang \u003d\n             (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                 totalCapacity, curAvailRes, sizeOfGang));\n         curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n \n         // compare with previous max, and set it. also remember *where* we found\n         // the minimum (useful for next attempts)\n         if (curMaxGang \u003c\u003d maxGang) {\n           maxGang \u003d curMaxGang;\n           minPoint \u003d t;\n         }\n       }\n \n       // update data structures that retain the progress made so far\n       gangsToPlace \u003d\n           trackProgress(planModifications, rr, stageEarliestStart,\n               stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n \n       // reset the next range of time-intervals to deal with\n       if (allocateLeft) {\n         // set earliest start to the min of the constraining \"range\" or my the\n         // end of this allocation\n-        stageEarliestStart \u003d\n-            Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n+        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n+          stageEarliestStart \u003d stageEarliestStart + dur;\n+        } else {\n+          stageEarliestStart \u003d\n+             Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n+        }\n       } else {\n         // same as above moving right-to-left\n-        stageDeadline \u003d\n-            Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n+        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n+          stageDeadline \u003d stageDeadline - dur;\n+        } else {\n+          stageDeadline \u003d\n+              Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n+        }\n       }\n     }\n \n     // if no gangs are left to place we succeed and return the allocation\n     if (gangsToPlace \u003d\u003d 0) {\n       return allocationRequests;\n     } else {\n       // If we are here is because we did not manage to satisfy this request.\n       // So we need to remove unwanted side-effect from tempAssigned (needed\n       // for ANY).\n       for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n           allocationRequests.entrySet()) {\n         planModifications.removeInterval(tempAllocation.getKey(),\n             tempAllocation.getValue());\n       }\n       // and return null to signal failure in this allocation\n       return null;\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    // abort early if the interval is not satisfiable\n    if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n      return null;\n    }\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // compute the gang as a resource and get the duration\n    Resource sizeOfGang \u003d\n        Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    // get available resources from plan\n    RLESparseResourceAllocation netRLERes \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline);\n\n    // remove plan modifications\n    netRLERes \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n            stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      int maxGang \u003d gangsToPlace;\n      long minPoint \u003d -1;\n\n      // focus our attention to a time-range under consideration\n      NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n          netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n              .getCumulative();\n\n      // revert the map for right-to-left allocation\n      if (!allocateLeft) {\n        partialMap \u003d partialMap.descendingMap();\n      }\n\n      Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n\n      long oldT \u003d stageDeadline;\n\n      // internal loop, tries to allocate as many gang as possible starting\n      // at a given point in time, if it fails we move to the next time\n      // interval (with outside loop)\n      while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n\n        long t;\n        Resource curAvailRes;\n\n        Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n        if (allocateLeft) {\n          t \u003d Math.max(e.getKey(), stageEarliestStart);\n          curAvailRes \u003d e.getValue();\n        } else {\n          t \u003d oldT;\n          oldT \u003d e.getKey();\n          //attention: higher means lower, because we reversed the map direction\n          curAvailRes \u003d partialMap.higherEntry(t).getValue();\n        }\n\n        // check exit/skip conditions/\n        if (curAvailRes \u003d\u003d null) {\n          //skip undefined regions (should not happen beside borders)\n          continue;\n        }\n        if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n          break;\n        }\n\n        // compute maximum number of gangs we could fit\n        int curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, curAvailRes, sizeOfGang));\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // update data structures that retain the progress made so far\n      gangsToPlace \u003d\n          trackProgress(planModifications, rr, stageEarliestStart,\n              stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n\n      // reset the next range of time-intervals to deal with\n      if (allocateLeft) {\n        // set earliest start to the min of the constraining \"range\" or my the\n        // end of this allocation\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageEarliestStart \u003d stageEarliestStart + dur;\n        } else {\n          stageEarliestStart \u003d\n             Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n        }\n      } else {\n        // same as above moving right-to-left\n        if(partialMap.higherKey(minPoint) \u003d\u003d null){\n          stageDeadline \u003d stageDeadline - dur;\n        } else {\n          stageDeadline \u003d\n              Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n        }\n      }\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is because we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n          allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedyRLE.java",
      "extendedDetails": {}
    },
    "5cf5c41a895f5ab8bf6270089f8cfdea50573a97": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4360. Improve GreedyReservationAgent to support \"early\" allocations, and performance improvements (curino via asuresh)\n",
      "commitDate": "10/02/16 9:11 AM",
      "commitName": "5cf5c41a895f5ab8bf6270089f8cfdea50573a97",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,143 @@\n+  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n+      Map\u003cLong, Resource\u003e planLoads,\n+      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n+      long stageEarliestStart, long stageDeadline, String user,\n+      ReservationId oldId) throws PlanningException {\n+\n+    // abort early if the interval is not satisfiable\n+    if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n+      return null;\n+    }\n+\n+    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n+        new HashMap\u003cReservationInterval, Resource\u003e();\n+\n+    Resource totalCapacity \u003d plan.getTotalCapacity();\n+\n+    // compute the gang as a resource and get the duration\n+    Resource sizeOfGang \u003d\n+        Resources.multiply(rr.getCapability(), rr.getConcurrency());\n+    long dur \u003d rr.getDuration();\n+    long step \u003d plan.getStep();\n+\n+    // ceil the duration to the next multiple of the plan step\n+    if (dur % step !\u003d 0) {\n+      dur +\u003d (step - (dur % step));\n+    }\n+\n+    // we know for sure that this division has no remainder (part of contract\n+    // with user, validate before\n+    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n+\n+    // get available resources from plan\n+    RLESparseResourceAllocation netRLERes \u003d\n+        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n+            stageDeadline);\n+\n+    // remove plan modifications\n+    netRLERes \u003d\n+        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n+            totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n+            stageEarliestStart, stageDeadline);\n+\n+    // loop trying to place until we are done, or we are considering\n+    // an invalid range of times\n+    while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n+\n+      // as we run along we remember how many gangs we can fit, and what\n+      // was the most constraining moment in time (we will restart just\n+      // after that to place the next batch)\n+      int maxGang \u003d gangsToPlace;\n+      long minPoint \u003d -1;\n+\n+      // focus our attention to a time-range under consideration\n+      NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n+          netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n+              .getCumulative();\n+\n+      // revert the map for right-to-left allocation\n+      if (!allocateLeft) {\n+        partialMap \u003d partialMap.descendingMap();\n+      }\n+\n+      Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n+\n+      long oldT \u003d stageDeadline;\n+\n+      // internal loop, tries to allocate as many gang as possible starting\n+      // at a given point in time, if it fails we move to the next time\n+      // interval (with outside loop)\n+      while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n+\n+        long t;\n+        Resource curAvailRes;\n+\n+        Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n+        if (allocateLeft) {\n+          t \u003d Math.max(e.getKey(), stageEarliestStart);\n+          curAvailRes \u003d e.getValue();\n+        } else {\n+          t \u003d oldT;\n+          oldT \u003d e.getKey();\n+          //attention: higher means lower, because we reversed the map direction\n+          curAvailRes \u003d partialMap.higherEntry(t).getValue();\n+        }\n+\n+        // check exit/skip conditions/\n+        if (curAvailRes \u003d\u003d null) {\n+          //skip undefined regions (should not happen beside borders)\n+          continue;\n+        }\n+        if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n+          break;\n+        }\n+\n+        // compute maximum number of gangs we could fit\n+        int curMaxGang \u003d\n+            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n+                totalCapacity, curAvailRes, sizeOfGang));\n+        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n+\n+        // compare with previous max, and set it. also remember *where* we found\n+        // the minimum (useful for next attempts)\n+        if (curMaxGang \u003c\u003d maxGang) {\n+          maxGang \u003d curMaxGang;\n+          minPoint \u003d t;\n+        }\n+      }\n+\n+      // update data structures that retain the progress made so far\n+      gangsToPlace \u003d\n+          trackProgress(planModifications, rr, stageEarliestStart,\n+              stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n+\n+      // reset the next range of time-intervals to deal with\n+      if (allocateLeft) {\n+        // set earliest start to the min of the constraining \"range\" or my the\n+        // end of this allocation\n+        stageEarliestStart \u003d\n+            Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n+      } else {\n+        // same as above moving right-to-left\n+        stageDeadline \u003d\n+            Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n+      }\n+    }\n+\n+    // if no gangs are left to place we succeed and return the allocation\n+    if (gangsToPlace \u003d\u003d 0) {\n+      return allocationRequests;\n+    } else {\n+      // If we are here is because we did not manage to satisfy this request.\n+      // So we need to remove unwanted side-effect from tempAssigned (needed\n+      // for ANY).\n+      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n+          allocationRequests.entrySet()) {\n+        planModifications.removeInterval(tempAllocation.getKey(),\n+            tempAllocation.getValue());\n+      }\n+      // and return null to signal failure in this allocation\n+      return null;\n+    }\n+\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cReservationInterval, Resource\u003e computeStageAllocation(Plan plan,\n      Map\u003cLong, Resource\u003e planLoads,\n      RLESparseResourceAllocation planModifications, ReservationRequest rr,\n      long stageEarliestStart, long stageDeadline, String user,\n      ReservationId oldId) throws PlanningException {\n\n    // abort early if the interval is not satisfiable\n    if (stageEarliestStart + rr.getDuration() \u003e stageDeadline) {\n      return null;\n    }\n\n    Map\u003cReservationInterval, Resource\u003e allocationRequests \u003d\n        new HashMap\u003cReservationInterval, Resource\u003e();\n\n    Resource totalCapacity \u003d plan.getTotalCapacity();\n\n    // compute the gang as a resource and get the duration\n    Resource sizeOfGang \u003d\n        Resources.multiply(rr.getCapability(), rr.getConcurrency());\n    long dur \u003d rr.getDuration();\n    long step \u003d plan.getStep();\n\n    // ceil the duration to the next multiple of the plan step\n    if (dur % step !\u003d 0) {\n      dur +\u003d (step - (dur % step));\n    }\n\n    // we know for sure that this division has no remainder (part of contract\n    // with user, validate before\n    int gangsToPlace \u003d rr.getNumContainers() / rr.getConcurrency();\n\n    // get available resources from plan\n    RLESparseResourceAllocation netRLERes \u003d\n        plan.getAvailableResourceOverTime(user, oldId, stageEarliestStart,\n            stageDeadline);\n\n    // remove plan modifications\n    netRLERes \u003d\n        RLESparseResourceAllocation.merge(plan.getResourceCalculator(),\n            totalCapacity, netRLERes, planModifications, RLEOperator.subtract,\n            stageEarliestStart, stageDeadline);\n\n    // loop trying to place until we are done, or we are considering\n    // an invalid range of times\n    while (gangsToPlace \u003e 0 \u0026\u0026 stageEarliestStart + dur \u003c\u003d stageDeadline) {\n\n      // as we run along we remember how many gangs we can fit, and what\n      // was the most constraining moment in time (we will restart just\n      // after that to place the next batch)\n      int maxGang \u003d gangsToPlace;\n      long minPoint \u003d -1;\n\n      // focus our attention to a time-range under consideration\n      NavigableMap\u003cLong, Resource\u003e partialMap \u003d\n          netRLERes.getRangeOverlapping(stageEarliestStart, stageDeadline)\n              .getCumulative();\n\n      // revert the map for right-to-left allocation\n      if (!allocateLeft) {\n        partialMap \u003d partialMap.descendingMap();\n      }\n\n      Iterator\u003cEntry\u003cLong, Resource\u003e\u003e netIt \u003d partialMap.entrySet().iterator();\n\n      long oldT \u003d stageDeadline;\n\n      // internal loop, tries to allocate as many gang as possible starting\n      // at a given point in time, if it fails we move to the next time\n      // interval (with outside loop)\n      while (maxGang \u003e 0 \u0026\u0026 netIt.hasNext()) {\n\n        long t;\n        Resource curAvailRes;\n\n        Entry\u003cLong, Resource\u003e e \u003d netIt.next();\n        if (allocateLeft) {\n          t \u003d Math.max(e.getKey(), stageEarliestStart);\n          curAvailRes \u003d e.getValue();\n        } else {\n          t \u003d oldT;\n          oldT \u003d e.getKey();\n          //attention: higher means lower, because we reversed the map direction\n          curAvailRes \u003d partialMap.higherEntry(t).getValue();\n        }\n\n        // check exit/skip conditions/\n        if (curAvailRes \u003d\u003d null) {\n          //skip undefined regions (should not happen beside borders)\n          continue;\n        }\n        if (exitCondition(t, stageEarliestStart, stageDeadline, dur)) {\n          break;\n        }\n\n        // compute maximum number of gangs we could fit\n        int curMaxGang \u003d\n            (int) Math.floor(Resources.divide(plan.getResourceCalculator(),\n                totalCapacity, curAvailRes, sizeOfGang));\n        curMaxGang \u003d Math.min(gangsToPlace, curMaxGang);\n\n        // compare with previous max, and set it. also remember *where* we found\n        // the minimum (useful for next attempts)\n        if (curMaxGang \u003c\u003d maxGang) {\n          maxGang \u003d curMaxGang;\n          minPoint \u003d t;\n        }\n      }\n\n      // update data structures that retain the progress made so far\n      gangsToPlace \u003d\n          trackProgress(planModifications, rr, stageEarliestStart,\n              stageDeadline, allocationRequests, dur, gangsToPlace, maxGang);\n\n      // reset the next range of time-intervals to deal with\n      if (allocateLeft) {\n        // set earliest start to the min of the constraining \"range\" or my the\n        // end of this allocation\n        stageEarliestStart \u003d\n            Math.min(partialMap.higherKey(minPoint), stageEarliestStart + dur);\n      } else {\n        // same as above moving right-to-left\n        stageDeadline \u003d\n            Math.max(partialMap.higherKey(minPoint), stageDeadline - dur);\n      }\n    }\n\n    // if no gangs are left to place we succeed and return the allocation\n    if (gangsToPlace \u003d\u003d 0) {\n      return allocationRequests;\n    } else {\n      // If we are here is because we did not manage to satisfy this request.\n      // So we need to remove unwanted side-effect from tempAssigned (needed\n      // for ANY).\n      for (Map.Entry\u003cReservationInterval, Resource\u003e tempAllocation :\n          allocationRequests.entrySet()) {\n        planModifications.removeInterval(tempAllocation.getKey(),\n            tempAllocation.getValue());\n      }\n      // and return null to signal failure in this allocation\n      return null;\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/planning/StageAllocatorGreedyRLE.java"
    }
  }
}