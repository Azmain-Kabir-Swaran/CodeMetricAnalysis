{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerLauncherImpl.java",
  "functionName": "kill",
  "functionId": "kill",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
  "functionStartLine": 198,
  "functionEndLine": 200,
  "numCommitsSeen": 63,
  "timeTaken": 2124,
  "changeHistory": [
    "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5",
    "3ca3137179ef093e42cde06587c9ea785b10f32c",
    "243bcd367ff3130d74676280233041f88aca62a5",
    "77e134d13fb87cd098f2e9c23212affe0a7be1be",
    "92692c863cae56485de45e0aae3921018cf67b01",
    "0a80f82a304fc8bb3d9cf5ec016e12e6415270fc",
    "2b5c36b6952e16232f352b47c62d9e28ee2b30c9",
    "849c68c7b5f80064de3692d766444c2f8864f47a"
  ],
  "changeHistoryShort": {
    "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5": "Ymultichange(Ymodifierchange,Ybodychange)",
    "3ca3137179ef093e42cde06587c9ea785b10f32c": "Ybodychange",
    "243bcd367ff3130d74676280233041f88aca62a5": "Ybodychange",
    "77e134d13fb87cd098f2e9c23212affe0a7be1be": "Ybodychange",
    "92692c863cae56485de45e0aae3921018cf67b01": "Ybodychange",
    "0a80f82a304fc8bb3d9cf5ec016e12e6415270fc": "Ymultichange(Yparameterchange,Ybodychange)",
    "2b5c36b6952e16232f352b47c62d9e28ee2b30c9": "Ybodychange",
    "849c68c7b5f80064de3692d766444c2f8864f47a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-5044. Have AM trigger jstack on task attempts that timeout before killing them. (Eric Payne and Gera Shegalov via mingma)\n",
      "commitDate": "06/06/16 2:30 PM",
      "commitName": "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5",
      "commitAuthor": "Ming Ma",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "MAPREDUCE-5044. Have AM trigger jstack on task attempts that timeout before killing them. (Eric Payne and Gera Shegalov via mingma)\n",
          "commitDate": "06/06/16 2:30 PM",
          "commitName": "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "18/02/16 12:48 AM",
          "commitNameOld": "2440671a117f165dcda5056404bc898df3c50803",
          "commitAuthorOld": "Varun Vasudev",
          "daysBetweenCommits": 109.53,
          "commitsBetweenForRepo": 694,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,3 @@\n-    public synchronized void kill() {\n-\n-      if(this.state \u003d\u003d ContainerState.PREP) {\n-        this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n-      } else if (!isCompletelyDone()) {\n-        LOG.info(\"KILLING \" + taskAttemptID);\n-\n-        ContainerManagementProtocolProxyData proxy \u003d null;\n-        try {\n-          proxy \u003d getCMProxy(this.containerMgrAddress, this.containerID);\n-\n-          // kill the remote container if already launched\n-          List\u003cContainerId\u003e ids \u003d new ArrayList\u003cContainerId\u003e();\n-          ids.add(this.containerID);\n-          StopContainersRequest request \u003d StopContainersRequest.newInstance(ids);\n-          StopContainersResponse response \u003d\n-              proxy.getContainerManagementProtocol().stopContainers(request);\n-          if (response.getFailedRequests() !\u003d null\n-              \u0026\u0026 response.getFailedRequests().containsKey(this.containerID)) {\n-            throw response.getFailedRequests().get(this.containerID)\n-              .deSerialize();\n-          }\n-        } catch (Throwable t) {\n-          // ignore the cleanup failure\n-          String message \u003d \"cleanup failed for container \"\n-              + this.containerID + \" : \"\n-              + StringUtils.stringifyException(t);\n-          context.getEventHandler()\n-              .handle(\n-                  new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID,\n-                      message));\n-          LOG.warn(message);\n-        } finally {\n-          if (proxy !\u003d null) {\n-            cmProxy.mayBeCloseProxy(proxy);\n-          }\n-        }\n-        this.state \u003d ContainerState.DONE;\n-      }\n-      // after killing, send killed event to task attempt\n-      context.getEventHandler().handle(\n-          new TaskAttemptEvent(this.taskAttemptID,\n-              TaskAttemptEventType.TA_CONTAINER_CLEANED));\n+    public void kill() {\n+      kill(false);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void kill() {\n      kill(false);\n    }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-5044. Have AM trigger jstack on task attempts that timeout before killing them. (Eric Payne and Gera Shegalov via mingma)\n",
          "commitDate": "06/06/16 2:30 PM",
          "commitName": "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "18/02/16 12:48 AM",
          "commitNameOld": "2440671a117f165dcda5056404bc898df3c50803",
          "commitAuthorOld": "Varun Vasudev",
          "daysBetweenCommits": 109.53,
          "commitsBetweenForRepo": 694,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,3 @@\n-    public synchronized void kill() {\n-\n-      if(this.state \u003d\u003d ContainerState.PREP) {\n-        this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n-      } else if (!isCompletelyDone()) {\n-        LOG.info(\"KILLING \" + taskAttemptID);\n-\n-        ContainerManagementProtocolProxyData proxy \u003d null;\n-        try {\n-          proxy \u003d getCMProxy(this.containerMgrAddress, this.containerID);\n-\n-          // kill the remote container if already launched\n-          List\u003cContainerId\u003e ids \u003d new ArrayList\u003cContainerId\u003e();\n-          ids.add(this.containerID);\n-          StopContainersRequest request \u003d StopContainersRequest.newInstance(ids);\n-          StopContainersResponse response \u003d\n-              proxy.getContainerManagementProtocol().stopContainers(request);\n-          if (response.getFailedRequests() !\u003d null\n-              \u0026\u0026 response.getFailedRequests().containsKey(this.containerID)) {\n-            throw response.getFailedRequests().get(this.containerID)\n-              .deSerialize();\n-          }\n-        } catch (Throwable t) {\n-          // ignore the cleanup failure\n-          String message \u003d \"cleanup failed for container \"\n-              + this.containerID + \" : \"\n-              + StringUtils.stringifyException(t);\n-          context.getEventHandler()\n-              .handle(\n-                  new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID,\n-                      message));\n-          LOG.warn(message);\n-        } finally {\n-          if (proxy !\u003d null) {\n-            cmProxy.mayBeCloseProxy(proxy);\n-          }\n-        }\n-        this.state \u003d ContainerState.DONE;\n-      }\n-      // after killing, send killed event to task attempt\n-      context.getEventHandler().handle(\n-          new TaskAttemptEvent(this.taskAttemptID,\n-              TaskAttemptEventType.TA_CONTAINER_CLEANED));\n+    public void kill() {\n+      kill(false);\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void kill() {\n      kill(false);\n    }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "3ca3137179ef093e42cde06587c9ea785b10f32c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-926. Modified ContainerManagerProtcol APIs to take in requests for multiple containers. Contributed by Jian He.\nMAPREDUCE-5412. Update MR app to use multiple containers API of ContainerManager after YARN-926. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506391 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/07/13 8:41 PM",
      "commitName": "3ca3137179ef093e42cde06587c9ea785b10f32c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "20/06/13 5:08 PM",
      "commitNameOld": "1a06175440eec7994d6b63b0e5ac8b6532870fb3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 33.15,
      "commitsBetweenForRepo": 159,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,44 @@\n     public synchronized void kill() {\n \n       if(this.state \u003d\u003d ContainerState.PREP) {\n         this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n       } else if (!isCompletelyDone()) {\n         LOG.info(\"KILLING \" + taskAttemptID);\n \n         ContainerManagementProtocolProxyData proxy \u003d null;\n         try {\n           proxy \u003d getCMProxy(this.containerMgrAddress, this.containerID);\n \n           // kill the remote container if already launched\n-          StopContainerRequest stopRequest \u003d Records\n-              .newRecord(StopContainerRequest.class);\n-          stopRequest.setContainerId(this.containerID);\n-          proxy.getContainerManagementProtocol().stopContainer(stopRequest);\n-\n+          List\u003cContainerId\u003e ids \u003d new ArrayList\u003cContainerId\u003e();\n+          ids.add(this.containerID);\n+          StopContainersRequest request \u003d StopContainersRequest.newInstance(ids);\n+          StopContainersResponse response \u003d\n+              proxy.getContainerManagementProtocol().stopContainers(request);\n+          if (response.getFailedRequests() !\u003d null\n+              \u0026\u0026 response.getFailedRequests().containsKey(this.containerID)) {\n+            throw response.getFailedRequests().get(this.containerID)\n+              .deSerialize();\n+          }\n         } catch (Throwable t) {\n-\n           // ignore the cleanup failure\n           String message \u003d \"cleanup failed for container \"\n               + this.containerID + \" : \"\n               + StringUtils.stringifyException(t);\n           context.getEventHandler()\n               .handle(\n                   new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID,\n                       message));\n           LOG.warn(message);\n         } finally {\n           if (proxy !\u003d null) {\n             cmProxy.mayBeCloseProxy(proxy);\n           }\n         }\n         this.state \u003d ContainerState.DONE;\n       }\n       // after killing, send killed event to task attempt\n       context.getEventHandler().handle(\n           new TaskAttemptEvent(this.taskAttemptID,\n               TaskAttemptEventType.TA_CONTAINER_CLEANED));\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public synchronized void kill() {\n\n      if(this.state \u003d\u003d ContainerState.PREP) {\n        this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n      } else if (!isCompletelyDone()) {\n        LOG.info(\"KILLING \" + taskAttemptID);\n\n        ContainerManagementProtocolProxyData proxy \u003d null;\n        try {\n          proxy \u003d getCMProxy(this.containerMgrAddress, this.containerID);\n\n          // kill the remote container if already launched\n          List\u003cContainerId\u003e ids \u003d new ArrayList\u003cContainerId\u003e();\n          ids.add(this.containerID);\n          StopContainersRequest request \u003d StopContainersRequest.newInstance(ids);\n          StopContainersResponse response \u003d\n              proxy.getContainerManagementProtocol().stopContainers(request);\n          if (response.getFailedRequests() !\u003d null\n              \u0026\u0026 response.getFailedRequests().containsKey(this.containerID)) {\n            throw response.getFailedRequests().get(this.containerID)\n              .deSerialize();\n          }\n        } catch (Throwable t) {\n          // ignore the cleanup failure\n          String message \u003d \"cleanup failed for container \"\n              + this.containerID + \" : \"\n              + StringUtils.stringifyException(t);\n          context.getEventHandler()\n              .handle(\n                  new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID,\n                      message));\n          LOG.warn(message);\n        } finally {\n          if (proxy !\u003d null) {\n            cmProxy.mayBeCloseProxy(proxy);\n          }\n        }\n        this.state \u003d ContainerState.DONE;\n      }\n      // after killing, send killed event to task attempt\n      context.getEventHandler().handle(\n          new TaskAttemptEvent(this.taskAttemptID,\n              TaskAttemptEventType.TA_CONTAINER_CLEANED));\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "243bcd367ff3130d74676280233041f88aca62a5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-694. Starting to use NMTokens to authenticate all communication with NodeManagers. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494369 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/06/13 4:19 PM",
      "commitName": "243bcd367ff3130d74676280233041f88aca62a5",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/06/13 11:20 PM",
      "commitNameOld": "f4d80e91ae314d316100baa7770b9d73ea853d9c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,40 @@\n     public synchronized void kill() {\n \n       if(this.state \u003d\u003d ContainerState.PREP) {\n         this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n       } else if (!isCompletelyDone()) {\n         LOG.info(\"KILLING \" + taskAttemptID);\n \n-        ContainerManagementProtocol proxy \u003d null;\n+        ContainerManagementProtocolProxyData proxy \u003d null;\n         try {\n-          proxy \u003d getCMProxy(this.containerID, this.containerMgrAddress,\n-              this.containerToken);\n+          proxy \u003d getCMProxy(this.containerMgrAddress, this.containerID);\n \n-            // kill the remote container if already launched\n-            StopContainerRequest stopRequest \u003d Records\n+          // kill the remote container if already launched\n+          StopContainerRequest stopRequest \u003d Records\n               .newRecord(StopContainerRequest.class);\n-            stopRequest.setContainerId(this.containerID);\n-            proxy.stopContainer(stopRequest);\n+          stopRequest.setContainerId(this.containerID);\n+          proxy.getContainerManagementProtocol().stopContainer(stopRequest);\n \n         } catch (Throwable t) {\n \n           // ignore the cleanup failure\n           String message \u003d \"cleanup failed for container \"\n-            + this.containerID + \" : \"\n-            + StringUtils.stringifyException(t);\n-          context.getEventHandler().handle(\n-            new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID, message));\n+              + this.containerID + \" : \"\n+              + StringUtils.stringifyException(t);\n+          context.getEventHandler()\n+              .handle(\n+                  new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID,\n+                      message));\n           LOG.warn(message);\n         } finally {\n           if (proxy !\u003d null) {\n-            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n+            cmProxy.mayBeCloseProxy(proxy);\n           }\n         }\n         this.state \u003d ContainerState.DONE;\n       }\n       // after killing, send killed event to task attempt\n       context.getEventHandler().handle(\n           new TaskAttemptEvent(this.taskAttemptID,\n               TaskAttemptEventType.TA_CONTAINER_CLEANED));\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public synchronized void kill() {\n\n      if(this.state \u003d\u003d ContainerState.PREP) {\n        this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n      } else if (!isCompletelyDone()) {\n        LOG.info(\"KILLING \" + taskAttemptID);\n\n        ContainerManagementProtocolProxyData proxy \u003d null;\n        try {\n          proxy \u003d getCMProxy(this.containerMgrAddress, this.containerID);\n\n          // kill the remote container if already launched\n          StopContainerRequest stopRequest \u003d Records\n              .newRecord(StopContainerRequest.class);\n          stopRequest.setContainerId(this.containerID);\n          proxy.getContainerManagementProtocol().stopContainer(stopRequest);\n\n        } catch (Throwable t) {\n\n          // ignore the cleanup failure\n          String message \u003d \"cleanup failed for container \"\n              + this.containerID + \" : \"\n              + StringUtils.stringifyException(t);\n          context.getEventHandler()\n              .handle(\n                  new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID,\n                      message));\n          LOG.warn(message);\n        } finally {\n          if (proxy !\u003d null) {\n            cmProxy.mayBeCloseProxy(proxy);\n          }\n        }\n        this.state \u003d ContainerState.DONE;\n      }\n      // after killing, send killed event to task attempt\n      context.getEventHandler().handle(\n          new TaskAttemptEvent(this.taskAttemptID,\n              TaskAttemptEventType.TA_CONTAINER_CLEANED));\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "77e134d13fb87cd098f2e9c23212affe0a7be1be": {
      "type": "Ybodychange",
      "commitMessage": "YARN-387. Renamed YARN protocols for consistency. Contributed by Vinod K V.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493623 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/06/13 7:27 PM",
      "commitName": "77e134d13fb87cd098f2e9c23212affe0a7be1be",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "13/06/13 4:25 PM",
      "commitNameOld": "c0cd68d8fbf5c8cafa6d563c7d0401e7a87a2d9e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.13,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n     public synchronized void kill() {\n \n       if(this.state \u003d\u003d ContainerState.PREP) {\n         this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n       } else if (!isCompletelyDone()) {\n         LOG.info(\"KILLING \" + taskAttemptID);\n \n-        ContainerManager proxy \u003d null;\n+        ContainerManagementProtocol proxy \u003d null;\n         try {\n           proxy \u003d getCMProxy(this.containerID, this.containerMgrAddress,\n               this.containerToken);\n \n             // kill the remote container if already launched\n             StopContainerRequest stopRequest \u003d Records\n               .newRecord(StopContainerRequest.class);\n             stopRequest.setContainerId(this.containerID);\n             proxy.stopContainer(stopRequest);\n \n         } catch (Throwable t) {\n \n           // ignore the cleanup failure\n           String message \u003d \"cleanup failed for container \"\n             + this.containerID + \" : \"\n             + StringUtils.stringifyException(t);\n           context.getEventHandler().handle(\n             new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID, message));\n           LOG.warn(message);\n         } finally {\n           if (proxy !\u003d null) {\n             ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n           }\n         }\n         this.state \u003d ContainerState.DONE;\n       }\n       // after killing, send killed event to task attempt\n       context.getEventHandler().handle(\n           new TaskAttemptEvent(this.taskAttemptID,\n               TaskAttemptEventType.TA_CONTAINER_CLEANED));\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public synchronized void kill() {\n\n      if(this.state \u003d\u003d ContainerState.PREP) {\n        this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n      } else if (!isCompletelyDone()) {\n        LOG.info(\"KILLING \" + taskAttemptID);\n\n        ContainerManagementProtocol proxy \u003d null;\n        try {\n          proxy \u003d getCMProxy(this.containerID, this.containerMgrAddress,\n              this.containerToken);\n\n            // kill the remote container if already launched\n            StopContainerRequest stopRequest \u003d Records\n              .newRecord(StopContainerRequest.class);\n            stopRequest.setContainerId(this.containerID);\n            proxy.stopContainer(stopRequest);\n\n        } catch (Throwable t) {\n\n          // ignore the cleanup failure\n          String message \u003d \"cleanup failed for container \"\n            + this.containerID + \" : \"\n            + StringUtils.stringifyException(t);\n          context.getEventHandler().handle(\n            new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID, message));\n          LOG.warn(message);\n        } finally {\n          if (proxy !\u003d null) {\n            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n          }\n        }\n        this.state \u003d ContainerState.DONE;\n      }\n      // after killing, send killed event to task attempt\n      context.getEventHandler().handle(\n          new TaskAttemptEvent(this.taskAttemptID,\n              TaskAttemptEventType.TA_CONTAINER_CLEANED));\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "92692c863cae56485de45e0aae3921018cf67b01": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4833. Task can get stuck in FAIL_CONTAINER_CLEANUP. Contributed by Robert Parker\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1425167 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/12/12 2:27 PM",
      "commitName": "92692c863cae56485de45e0aae3921018cf67b01",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "24/10/12 8:45 AM",
      "commitNameOld": "1e45b1f1fd38543b0b1233f57fdee1ac4a365332",
      "commitAuthorOld": "Jason Darrell Lowe",
      "daysBetweenCommits": 58.28,
      "commitsBetweenForRepo": 263,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,39 @@\n     public synchronized void kill() {\n \n-      if(isCompletelyDone()) { \n-        return;\n-      }\n       if(this.state \u003d\u003d ContainerState.PREP) {\n         this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n-      } else {\n+      } else if (!isCompletelyDone()) {\n         LOG.info(\"KILLING \" + taskAttemptID);\n \n         ContainerManager proxy \u003d null;\n         try {\n           proxy \u003d getCMProxy(this.containerID, this.containerMgrAddress,\n               this.containerToken);\n \n             // kill the remote container if already launched\n             StopContainerRequest stopRequest \u003d Records\n               .newRecord(StopContainerRequest.class);\n             stopRequest.setContainerId(this.containerID);\n             proxy.stopContainer(stopRequest);\n \n         } catch (Throwable t) {\n \n           // ignore the cleanup failure\n           String message \u003d \"cleanup failed for container \"\n             + this.containerID + \" : \"\n             + StringUtils.stringifyException(t);\n           context.getEventHandler().handle(\n             new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID, message));\n           LOG.warn(message);\n         } finally {\n           if (proxy !\u003d null) {\n             ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n           }\n         }\n         this.state \u003d ContainerState.DONE;\n       }\n       // after killing, send killed event to task attempt\n       context.getEventHandler().handle(\n           new TaskAttemptEvent(this.taskAttemptID,\n               TaskAttemptEventType.TA_CONTAINER_CLEANED));\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public synchronized void kill() {\n\n      if(this.state \u003d\u003d ContainerState.PREP) {\n        this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n      } else if (!isCompletelyDone()) {\n        LOG.info(\"KILLING \" + taskAttemptID);\n\n        ContainerManager proxy \u003d null;\n        try {\n          proxy \u003d getCMProxy(this.containerID, this.containerMgrAddress,\n              this.containerToken);\n\n            // kill the remote container if already launched\n            StopContainerRequest stopRequest \u003d Records\n              .newRecord(StopContainerRequest.class);\n            stopRequest.setContainerId(this.containerID);\n            proxy.stopContainer(stopRequest);\n\n        } catch (Throwable t) {\n\n          // ignore the cleanup failure\n          String message \u003d \"cleanup failed for container \"\n            + this.containerID + \" : \"\n            + StringUtils.stringifyException(t);\n          context.getEventHandler().handle(\n            new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID, message));\n          LOG.warn(message);\n        } finally {\n          if (proxy !\u003d null) {\n            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n          }\n        }\n        this.state \u003d ContainerState.DONE;\n      }\n      // after killing, send killed event to task attempt\n      context.getEventHandler().handle(\n          new TaskAttemptEvent(this.taskAttemptID,\n              TaskAttemptEventType.TA_CONTAINER_CLEANED));\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "0a80f82a304fc8bb3d9cf5ec016e12e6415270fc": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-4152. map task left hanging after AM dies trying to connect to RM (Tom Graves via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1344283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/12 7:48 AM",
      "commitName": "0a80f82a304fc8bb3d9cf5ec016e12e6415270fc",
      "commitAuthor": "Robert Joseph Evans",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-4152. map task left hanging after AM dies trying to connect to RM (Tom Graves via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1344283 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/05/12 7:48 AM",
          "commitName": "0a80f82a304fc8bb3d9cf5ec016e12e6415270fc",
          "commitAuthor": "Robert Joseph Evans",
          "commitDateOld": "08/05/12 8:07 AM",
          "commitNameOld": "aa60da6c2ec049cc70897afee6c368cb70493773",
          "commitAuthorOld": "Robert Joseph Evans",
          "daysBetweenCommits": 21.99,
          "commitsBetweenForRepo": 120,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,42 @@\n-    public synchronized void kill(ContainerLauncherEvent event) {\n+    public synchronized void kill() {\n+\n+      if(isCompletelyDone()) { \n+        return;\n+      }\n       if(this.state \u003d\u003d ContainerState.PREP) {\n         this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n       } else {\n-        final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n-        ContainerId containerID \u003d event.getContainerID();\n-        ContainerToken containerToken \u003d event.getContainerToken();\n-        TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n         LOG.info(\"KILLING \" + taskAttemptID);\n \n         ContainerManager proxy \u003d null;\n         try {\n-          proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n-              containerToken);\n+          proxy \u003d getCMProxy(this.containerID, this.containerMgrAddress,\n+              this.containerToken);\n \n             // kill the remote container if already launched\n             StopContainerRequest stopRequest \u003d Records\n               .newRecord(StopContainerRequest.class);\n-            stopRequest.setContainerId(event.getContainerID());\n+            stopRequest.setContainerId(this.containerID);\n             proxy.stopContainer(stopRequest);\n \n         } catch (Throwable t) {\n \n           // ignore the cleanup failure\n           String message \u003d \"cleanup failed for container \"\n-            + event.getContainerID() + \" : \"\n+            + this.containerID + \" : \"\n             + StringUtils.stringifyException(t);\n           context.getEventHandler().handle(\n-            new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n+            new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID, message));\n           LOG.warn(message);\n         } finally {\n           if (proxy !\u003d null) {\n             ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n           }\n         }\n         this.state \u003d ContainerState.DONE;\n       }\n       // after killing, send killed event to task attempt\n       context.getEventHandler().handle(\n-          new TaskAttemptEvent(event.getTaskAttemptID(),\n+          new TaskAttemptEvent(this.taskAttemptID,\n               TaskAttemptEventType.TA_CONTAINER_CLEANED));\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public synchronized void kill() {\n\n      if(isCompletelyDone()) { \n        return;\n      }\n      if(this.state \u003d\u003d ContainerState.PREP) {\n        this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n      } else {\n        LOG.info(\"KILLING \" + taskAttemptID);\n\n        ContainerManager proxy \u003d null;\n        try {\n          proxy \u003d getCMProxy(this.containerID, this.containerMgrAddress,\n              this.containerToken);\n\n            // kill the remote container if already launched\n            StopContainerRequest stopRequest \u003d Records\n              .newRecord(StopContainerRequest.class);\n            stopRequest.setContainerId(this.containerID);\n            proxy.stopContainer(stopRequest);\n\n        } catch (Throwable t) {\n\n          // ignore the cleanup failure\n          String message \u003d \"cleanup failed for container \"\n            + this.containerID + \" : \"\n            + StringUtils.stringifyException(t);\n          context.getEventHandler().handle(\n            new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID, message));\n          LOG.warn(message);\n        } finally {\n          if (proxy !\u003d null) {\n            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n          }\n        }\n        this.state \u003d ContainerState.DONE;\n      }\n      // after killing, send killed event to task attempt\n      context.getEventHandler().handle(\n          new TaskAttemptEvent(this.taskAttemptID,\n              TaskAttemptEventType.TA_CONTAINER_CLEANED));\n    }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
          "extendedDetails": {
            "oldValue": "[event-ContainerLauncherEvent]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-4152. map task left hanging after AM dies trying to connect to RM (Tom Graves via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1344283 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/05/12 7:48 AM",
          "commitName": "0a80f82a304fc8bb3d9cf5ec016e12e6415270fc",
          "commitAuthor": "Robert Joseph Evans",
          "commitDateOld": "08/05/12 8:07 AM",
          "commitNameOld": "aa60da6c2ec049cc70897afee6c368cb70493773",
          "commitAuthorOld": "Robert Joseph Evans",
          "daysBetweenCommits": 21.99,
          "commitsBetweenForRepo": 120,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,42 @@\n-    public synchronized void kill(ContainerLauncherEvent event) {\n+    public synchronized void kill() {\n+\n+      if(isCompletelyDone()) { \n+        return;\n+      }\n       if(this.state \u003d\u003d ContainerState.PREP) {\n         this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n       } else {\n-        final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n-        ContainerId containerID \u003d event.getContainerID();\n-        ContainerToken containerToken \u003d event.getContainerToken();\n-        TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n         LOG.info(\"KILLING \" + taskAttemptID);\n \n         ContainerManager proxy \u003d null;\n         try {\n-          proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n-              containerToken);\n+          proxy \u003d getCMProxy(this.containerID, this.containerMgrAddress,\n+              this.containerToken);\n \n             // kill the remote container if already launched\n             StopContainerRequest stopRequest \u003d Records\n               .newRecord(StopContainerRequest.class);\n-            stopRequest.setContainerId(event.getContainerID());\n+            stopRequest.setContainerId(this.containerID);\n             proxy.stopContainer(stopRequest);\n \n         } catch (Throwable t) {\n \n           // ignore the cleanup failure\n           String message \u003d \"cleanup failed for container \"\n-            + event.getContainerID() + \" : \"\n+            + this.containerID + \" : \"\n             + StringUtils.stringifyException(t);\n           context.getEventHandler().handle(\n-            new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n+            new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID, message));\n           LOG.warn(message);\n         } finally {\n           if (proxy !\u003d null) {\n             ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n           }\n         }\n         this.state \u003d ContainerState.DONE;\n       }\n       // after killing, send killed event to task attempt\n       context.getEventHandler().handle(\n-          new TaskAttemptEvent(event.getTaskAttemptID(),\n+          new TaskAttemptEvent(this.taskAttemptID,\n               TaskAttemptEventType.TA_CONTAINER_CLEANED));\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public synchronized void kill() {\n\n      if(isCompletelyDone()) { \n        return;\n      }\n      if(this.state \u003d\u003d ContainerState.PREP) {\n        this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n      } else {\n        LOG.info(\"KILLING \" + taskAttemptID);\n\n        ContainerManager proxy \u003d null;\n        try {\n          proxy \u003d getCMProxy(this.containerID, this.containerMgrAddress,\n              this.containerToken);\n\n            // kill the remote container if already launched\n            StopContainerRequest stopRequest \u003d Records\n              .newRecord(StopContainerRequest.class);\n            stopRequest.setContainerId(this.containerID);\n            proxy.stopContainer(stopRequest);\n\n        } catch (Throwable t) {\n\n          // ignore the cleanup failure\n          String message \u003d \"cleanup failed for container \"\n            + this.containerID + \" : \"\n            + StringUtils.stringifyException(t);\n          context.getEventHandler().handle(\n            new TaskAttemptDiagnosticsUpdateEvent(this.taskAttemptID, message));\n          LOG.warn(message);\n        } finally {\n          if (proxy !\u003d null) {\n            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n          }\n        }\n        this.state \u003d ContainerState.DONE;\n      }\n      // after killing, send killed event to task attempt\n      context.getEventHandler().handle(\n          new TaskAttemptEvent(this.taskAttemptID,\n              TaskAttemptEventType.TA_CONTAINER_CLEANED));\n    }",
          "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "2b5c36b6952e16232f352b47c62d9e28ee2b30c9": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4062. AM Launcher thread can hang forever (tgraves via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1309037 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/04/12 9:59 AM",
      "commitName": "2b5c36b6952e16232f352b47c62d9e28ee2b30c9",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "20/02/12 9:08 PM",
      "commitNameOld": "5ee495e6f34faff231ad87ec890188eb63617393",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 42.49,
      "commitsBetweenForRepo": 291,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,42 @@\n     public synchronized void kill(ContainerLauncherEvent event) {\n       if(this.state \u003d\u003d ContainerState.PREP) {\n         this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n       } else {\n-        CommandTimerTask timerTask \u003d new CommandTimerTask(Thread\n-            .currentThread(), event);\n-\n         final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n         ContainerId containerID \u003d event.getContainerID();\n         ContainerToken containerToken \u003d event.getContainerToken();\n         TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n         LOG.info(\"KILLING \" + taskAttemptID);\n-        commandTimer.schedule(timerTask, nmTimeOut);\n \n         ContainerManager proxy \u003d null;\n         try {\n           proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n               containerToken);\n \n-          if (Thread.interrupted()) {\n-            // The timer canceled the command in the mean while. No need to\n-            // return, send cleaned up event anyways.\n-            LOG.info(\"Stop-container for \" + event.getContainerID()\n-                + \" got interrupted.\");\n-          } else {\n             // kill the remote container if already launched\n             StopContainerRequest stopRequest \u003d Records\n               .newRecord(StopContainerRequest.class);\n             stopRequest.setContainerId(event.getContainerID());\n             proxy.stopContainer(stopRequest);\n-          }\n-        } catch (Throwable t) {\n \n-          if (Thread.interrupted()) {\n-            // The timer canceled the command in the mean while, clear the\n-            // interrupt flag\n-            LOG.info(\"Stop-container for \" + event.getContainerID()\n-                + \" got interrupted.\");\n-          }\n+        } catch (Throwable t) {\n \n           // ignore the cleanup failure\n           String message \u003d \"cleanup failed for container \"\n             + event.getContainerID() + \" : \"\n             + StringUtils.stringifyException(t);\n           context.getEventHandler().handle(\n             new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n           LOG.warn(message);\n         } finally {\n-          timerTask.cancel();\n-          if (Thread.interrupted()) {\n-            LOG.info(\"Stop-container for \" + event.getContainerID()\n-                + \" got interrupted.\");\n-            // ignore the cleanup failure\n-            context.getEventHandler().handle(\n-              new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n-                \"cleanup failed for container \" + event.getContainerID()));\n-          }\n           if (proxy !\u003d null) {\n             ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n           }\n         }\n         this.state \u003d ContainerState.DONE;\n       }\n       // after killing, send killed event to task attempt\n       context.getEventHandler().handle(\n           new TaskAttemptEvent(event.getTaskAttemptID(),\n               TaskAttemptEventType.TA_CONTAINER_CLEANED));\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public synchronized void kill(ContainerLauncherEvent event) {\n      if(this.state \u003d\u003d ContainerState.PREP) {\n        this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n      } else {\n        final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n        ContainerId containerID \u003d event.getContainerID();\n        ContainerToken containerToken \u003d event.getContainerToken();\n        TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n        LOG.info(\"KILLING \" + taskAttemptID);\n\n        ContainerManager proxy \u003d null;\n        try {\n          proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n              containerToken);\n\n            // kill the remote container if already launched\n            StopContainerRequest stopRequest \u003d Records\n              .newRecord(StopContainerRequest.class);\n            stopRequest.setContainerId(event.getContainerID());\n            proxy.stopContainer(stopRequest);\n\n        } catch (Throwable t) {\n\n          // ignore the cleanup failure\n          String message \u003d \"cleanup failed for container \"\n            + event.getContainerID() + \" : \"\n            + StringUtils.stringifyException(t);\n          context.getEventHandler().handle(\n            new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n          LOG.warn(message);\n        } finally {\n          if (proxy !\u003d null) {\n            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n          }\n        }\n        this.state \u003d ContainerState.DONE;\n      }\n      // after killing, send killed event to task attempt\n      context.getEventHandler().handle(\n          new TaskAttemptEvent(event.getTaskAttemptID(),\n              TaskAttemptEventType.TA_CONTAINER_CLEANED));\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java",
      "extendedDetails": {}
    },
    "849c68c7b5f80064de3692d766444c2f8864f47a": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3312. Modified MR AM to not send a stop-container request for a container that isn\u0027t launched at all. Contributed by Robert Joseph Evans.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1229451 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/01/12 6:15 PM",
      "commitName": "849c68c7b5f80064de3692d766444c2f8864f47a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,68 @@\n+    public synchronized void kill(ContainerLauncherEvent event) {\n+      if(this.state \u003d\u003d ContainerState.PREP) {\n+        this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n+      } else {\n+        CommandTimerTask timerTask \u003d new CommandTimerTask(Thread\n+            .currentThread(), event);\n+\n+        final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n+        ContainerId containerID \u003d event.getContainerID();\n+        ContainerToken containerToken \u003d event.getContainerToken();\n+        TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n+        LOG.info(\"KILLING \" + taskAttemptID);\n+        commandTimer.schedule(timerTask, nmTimeOut);\n+\n+        ContainerManager proxy \u003d null;\n+        try {\n+          proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n+              containerToken);\n+\n+          if (Thread.interrupted()) {\n+            // The timer canceled the command in the mean while. No need to\n+            // return, send cleaned up event anyways.\n+            LOG.info(\"Stop-container for \" + event.getContainerID()\n+                + \" got interrupted.\");\n+          } else {\n+            // kill the remote container if already launched\n+            StopContainerRequest stopRequest \u003d Records\n+              .newRecord(StopContainerRequest.class);\n+            stopRequest.setContainerId(event.getContainerID());\n+            proxy.stopContainer(stopRequest);\n+          }\n+        } catch (Throwable t) {\n+\n+          if (Thread.interrupted()) {\n+            // The timer canceled the command in the mean while, clear the\n+            // interrupt flag\n+            LOG.info(\"Stop-container for \" + event.getContainerID()\n+                + \" got interrupted.\");\n+          }\n+\n+          // ignore the cleanup failure\n+          String message \u003d \"cleanup failed for container \"\n+            + event.getContainerID() + \" : \"\n+            + StringUtils.stringifyException(t);\n+          context.getEventHandler().handle(\n+            new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n+          LOG.warn(message);\n+        } finally {\n+          timerTask.cancel();\n+          if (Thread.interrupted()) {\n+            LOG.info(\"Stop-container for \" + event.getContainerID()\n+                + \" got interrupted.\");\n+            // ignore the cleanup failure\n+            context.getEventHandler().handle(\n+              new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n+                \"cleanup failed for container \" + event.getContainerID()));\n+          }\n+          if (proxy !\u003d null) {\n+            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n+          }\n+        }\n+        this.state \u003d ContainerState.DONE;\n+      }\n+      // after killing, send killed event to task attempt\n+      context.getEventHandler().handle(\n+          new TaskAttemptEvent(event.getTaskAttemptID(),\n+              TaskAttemptEventType.TA_CONTAINER_CLEANED));\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public synchronized void kill(ContainerLauncherEvent event) {\n      if(this.state \u003d\u003d ContainerState.PREP) {\n        this.state \u003d ContainerState.KILLED_BEFORE_LAUNCH;\n      } else {\n        CommandTimerTask timerTask \u003d new CommandTimerTask(Thread\n            .currentThread(), event);\n\n        final String containerManagerBindAddr \u003d event.getContainerMgrAddress();\n        ContainerId containerID \u003d event.getContainerID();\n        ContainerToken containerToken \u003d event.getContainerToken();\n        TaskAttemptId taskAttemptID \u003d event.getTaskAttemptID();\n        LOG.info(\"KILLING \" + taskAttemptID);\n        commandTimer.schedule(timerTask, nmTimeOut);\n\n        ContainerManager proxy \u003d null;\n        try {\n          proxy \u003d getCMProxy(containerID, containerManagerBindAddr,\n              containerToken);\n\n          if (Thread.interrupted()) {\n            // The timer canceled the command in the mean while. No need to\n            // return, send cleaned up event anyways.\n            LOG.info(\"Stop-container for \" + event.getContainerID()\n                + \" got interrupted.\");\n          } else {\n            // kill the remote container if already launched\n            StopContainerRequest stopRequest \u003d Records\n              .newRecord(StopContainerRequest.class);\n            stopRequest.setContainerId(event.getContainerID());\n            proxy.stopContainer(stopRequest);\n          }\n        } catch (Throwable t) {\n\n          if (Thread.interrupted()) {\n            // The timer canceled the command in the mean while, clear the\n            // interrupt flag\n            LOG.info(\"Stop-container for \" + event.getContainerID()\n                + \" got interrupted.\");\n          }\n\n          // ignore the cleanup failure\n          String message \u003d \"cleanup failed for container \"\n            + event.getContainerID() + \" : \"\n            + StringUtils.stringifyException(t);\n          context.getEventHandler().handle(\n            new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID, message));\n          LOG.warn(message);\n        } finally {\n          timerTask.cancel();\n          if (Thread.interrupted()) {\n            LOG.info(\"Stop-container for \" + event.getContainerID()\n                + \" got interrupted.\");\n            // ignore the cleanup failure\n            context.getEventHandler().handle(\n              new TaskAttemptDiagnosticsUpdateEvent(taskAttemptID,\n                \"cleanup failed for container \" + event.getContainerID()));\n          }\n          if (proxy !\u003d null) {\n            ContainerLauncherImpl.this.rpc.stopProxy(proxy, getConfig());\n          }\n        }\n        this.state \u003d ContainerState.DONE;\n      }\n      // after killing, send killed event to task attempt\n      context.getEventHandler().handle(\n          new TaskAttemptEvent(event.getTaskAttemptID(),\n              TaskAttemptEventType.TA_CONTAINER_CLEANED));\n    }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/launcher/ContainerLauncherImpl.java"
    }
  }
}