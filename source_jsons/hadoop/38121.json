{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ReservedContainerCandidatesSelector.java",
  "functionName": "selectCandidates",
  "functionId": "selectCandidates___selectedCandidates-Map__ApplicationAttemptId,Set__RMContainer______clusterResource-Resource__totalPreemptedResourceAllowed-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ReservedContainerCandidatesSelector.java",
  "functionStartLine": 69,
  "functionEndLine": 116,
  "numCommitsSeen": 5,
  "timeTaken": 3073,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
    "e81596d06d226f1cfa44b2390ce3095ed4dee621",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": "Ybodychange",
    "e81596d06d226f1cfa44b2390ce3095ed4dee621": "Ybodychange",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.76,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,48 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource,\n       Resource totalPreemptedResourceAllowed) {\n     Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n     // Calculate how much resources we need to preempt\n     preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n         totalPreemptedResourceAllowed);\n \n     // Get queue to preemptable resource by partition\n     Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition \u003d\n         new HashMap\u003c\u003e();\n     for (String leafQueue : preemptionContext.getLeafQueueNames()) {\n       queueToPreemptableResourceByPartition.put(leafQueue,\n           CapacitySchedulerPreemptionUtils\n               .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                   leafQueue, clusterResource));\n     }\n \n     // Get list of nodes for preemption, ordered by preemption cost\n     List\u003cNodeForPreemption\u003e nodesForPreemption \u003d getNodesForPreemption(\n         queueToPreemptableResourceByPartition, selectedCandidates,\n         totalPreemptedResourceAllowed);\n \n     for (NodeForPreemption nfp : nodesForPreemption) {\n       RMContainer reservedContainer \u003d nfp.schedulerNode.getReservedContainer();\n       if (null \u003d\u003d reservedContainer) {\n         continue;\n       }\n \n       NodeForPreemption preemptionResult \u003d getPreemptionCandidatesOnNode(\n           nfp.schedulerNode, queueToPreemptableResourceByPartition,\n           selectedCandidates, totalPreemptedResourceAllowed, false);\n       if (null !\u003d preemptionResult) {\n         for (RMContainer c : preemptionResult.selectedContainers) {\n           // Add to preemptMap\n           CapacitySchedulerPreemptionUtils.addToPreemptMap(selectedCandidates,\n               curCandidates, c.getApplicationAttemptId(), c);\n \n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + c\n-                .getContainerId() + \" from queue\u003d\" + c.getQueueName()\n-                + \" to be preemption candidates\");\n-          }\n+          LOG.debug(\"{} Marked container\u003d{} from queue\u003d{} to be preemption\"\n+              + \" candidates\", this.getClass().getName(), c.getContainerId(),\n+              c.getQueueName());\n         }\n       }\n     }\n \n     return curCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource,\n      Resource totalPreemptedResourceAllowed) {\n    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptedResourceAllowed);\n\n    // Get queue to preemptable resource by partition\n    Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition \u003d\n        new HashMap\u003c\u003e();\n    for (String leafQueue : preemptionContext.getLeafQueueNames()) {\n      queueToPreemptableResourceByPartition.put(leafQueue,\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  leafQueue, clusterResource));\n    }\n\n    // Get list of nodes for preemption, ordered by preemption cost\n    List\u003cNodeForPreemption\u003e nodesForPreemption \u003d getNodesForPreemption(\n        queueToPreemptableResourceByPartition, selectedCandidates,\n        totalPreemptedResourceAllowed);\n\n    for (NodeForPreemption nfp : nodesForPreemption) {\n      RMContainer reservedContainer \u003d nfp.schedulerNode.getReservedContainer();\n      if (null \u003d\u003d reservedContainer) {\n        continue;\n      }\n\n      NodeForPreemption preemptionResult \u003d getPreemptionCandidatesOnNode(\n          nfp.schedulerNode, queueToPreemptableResourceByPartition,\n          selectedCandidates, totalPreemptedResourceAllowed, false);\n      if (null !\u003d preemptionResult) {\n        for (RMContainer c : preemptionResult.selectedContainers) {\n          // Add to preemptMap\n          CapacitySchedulerPreemptionUtils.addToPreemptMap(selectedCandidates,\n              curCandidates, c.getApplicationAttemptId(), c);\n\n          LOG.debug(\"{} Marked container\u003d{} from queue\u003d{} to be preemption\"\n              + \" candidates\", this.getClass().getName(), c.getContainerId(),\n              c.getQueueName());\n        }\n      }\n    }\n\n    return curCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ReservedContainerCandidatesSelector.java",
      "extendedDetails": {}
    },
    "291194302cc1a875d6d94ea93cf1184a3f1fc2cc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8379. Improve balancing resources in already satisfied queues by using Capacity Scheduler preemption. Contributed by Zian Chen.\n",
      "commitDate": "28/06/18 10:23 AM",
      "commitName": "291194302cc1a875d6d94ea93cf1184a3f1fc2cc",
      "commitAuthor": "Sunil G",
      "commitDateOld": "17/09/17 9:20 PM",
      "commitNameOld": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 283.54,
      "commitsBetweenForRepo": 2597,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,50 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource,\n       Resource totalPreemptedResourceAllowed) {\n+    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n     // Calculate how much resources we need to preempt\n     preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n         totalPreemptedResourceAllowed);\n \n     // Get queue to preemptable resource by partition\n     Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition \u003d\n         new HashMap\u003c\u003e();\n     for (String leafQueue : preemptionContext.getLeafQueueNames()) {\n       queueToPreemptableResourceByPartition.put(leafQueue,\n           CapacitySchedulerPreemptionUtils\n               .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                   leafQueue, clusterResource));\n     }\n \n     // Get list of nodes for preemption, ordered by preemption cost\n     List\u003cNodeForPreemption\u003e nodesForPreemption \u003d getNodesForPreemption(\n         queueToPreemptableResourceByPartition, selectedCandidates,\n         totalPreemptedResourceAllowed);\n \n     for (NodeForPreemption nfp : nodesForPreemption) {\n       RMContainer reservedContainer \u003d nfp.schedulerNode.getReservedContainer();\n       if (null \u003d\u003d reservedContainer) {\n         continue;\n       }\n \n       NodeForPreemption preemptionResult \u003d getPreemptionCandidatesOnNode(\n           nfp.schedulerNode, queueToPreemptableResourceByPartition,\n           selectedCandidates, totalPreemptedResourceAllowed, false);\n       if (null !\u003d preemptionResult) {\n         for (RMContainer c : preemptionResult.selectedContainers) {\n-          ApplicationAttemptId appId \u003d c.getApplicationAttemptId();\n-          Set\u003cRMContainer\u003e containers \u003d selectedCandidates.get(appId);\n-          if (null \u003d\u003d containers) {\n-            containers \u003d new HashSet\u003c\u003e();\n-            selectedCandidates.put(appId, containers);\n-          }\n+          // Add to preemptMap\n+          CapacitySchedulerPreemptionUtils.addToPreemptMap(selectedCandidates,\n+              curCandidates, c.getApplicationAttemptId(), c);\n \n-          containers.add(c);\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + c\n                 .getContainerId() + \" from queue\u003d\" + c.getQueueName()\n                 + \" to be preemption candidates\");\n           }\n         }\n       }\n     }\n \n-    return selectedCandidates;\n+    return curCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource,\n      Resource totalPreemptedResourceAllowed) {\n    Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e curCandidates \u003d new HashMap\u003c\u003e();\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptedResourceAllowed);\n\n    // Get queue to preemptable resource by partition\n    Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition \u003d\n        new HashMap\u003c\u003e();\n    for (String leafQueue : preemptionContext.getLeafQueueNames()) {\n      queueToPreemptableResourceByPartition.put(leafQueue,\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  leafQueue, clusterResource));\n    }\n\n    // Get list of nodes for preemption, ordered by preemption cost\n    List\u003cNodeForPreemption\u003e nodesForPreemption \u003d getNodesForPreemption(\n        queueToPreemptableResourceByPartition, selectedCandidates,\n        totalPreemptedResourceAllowed);\n\n    for (NodeForPreemption nfp : nodesForPreemption) {\n      RMContainer reservedContainer \u003d nfp.schedulerNode.getReservedContainer();\n      if (null \u003d\u003d reservedContainer) {\n        continue;\n      }\n\n      NodeForPreemption preemptionResult \u003d getPreemptionCandidatesOnNode(\n          nfp.schedulerNode, queueToPreemptableResourceByPartition,\n          selectedCandidates, totalPreemptedResourceAllowed, false);\n      if (null !\u003d preemptionResult) {\n        for (RMContainer c : preemptionResult.selectedContainers) {\n          // Add to preemptMap\n          CapacitySchedulerPreemptionUtils.addToPreemptMap(selectedCandidates,\n              curCandidates, c.getApplicationAttemptId(), c);\n\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + c\n                .getContainerId() + \" from queue\u003d\" + c.getQueueName()\n                + \" to be preemption candidates\");\n          }\n        }\n      }\n    }\n\n    return curCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ReservedContainerCandidatesSelector.java",
      "extendedDetails": {}
    },
    "e81596d06d226f1cfa44b2390ce3095ed4dee621": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7172. ResourceCalculator.fitsIn() should not take a cluster resource parameter. (Sen Zhao via wangda)\n\nChange-Id: Icc3670c9381ce7591ca69ec12da5aa52d3612d34\n",
      "commitDate": "17/09/17 9:20 PM",
      "commitName": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "05/05/16 12:56 PM",
      "commitNameOld": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 500.35,
      "commitsBetweenForRepo": 3345,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,53 @@\n   public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n       Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n       Resource clusterResource,\n       Resource totalPreemptedResourceAllowed) {\n     // Calculate how much resources we need to preempt\n     preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n         totalPreemptedResourceAllowed);\n \n     // Get queue to preemptable resource by partition\n     Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition \u003d\n         new HashMap\u003c\u003e();\n     for (String leafQueue : preemptionContext.getLeafQueueNames()) {\n       queueToPreemptableResourceByPartition.put(leafQueue,\n           CapacitySchedulerPreemptionUtils\n               .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                   leafQueue, clusterResource));\n     }\n \n     // Get list of nodes for preemption, ordered by preemption cost\n     List\u003cNodeForPreemption\u003e nodesForPreemption \u003d getNodesForPreemption(\n-        clusterResource, queueToPreemptableResourceByPartition,\n-        selectedCandidates, totalPreemptedResourceAllowed);\n+        queueToPreemptableResourceByPartition, selectedCandidates,\n+        totalPreemptedResourceAllowed);\n \n     for (NodeForPreemption nfp : nodesForPreemption) {\n       RMContainer reservedContainer \u003d nfp.schedulerNode.getReservedContainer();\n       if (null \u003d\u003d reservedContainer) {\n         continue;\n       }\n \n       NodeForPreemption preemptionResult \u003d getPreemptionCandidatesOnNode(\n-          nfp.schedulerNode, clusterResource,\n-          queueToPreemptableResourceByPartition, selectedCandidates,\n-          totalPreemptedResourceAllowed, false);\n+          nfp.schedulerNode, queueToPreemptableResourceByPartition,\n+          selectedCandidates, totalPreemptedResourceAllowed, false);\n       if (null !\u003d preemptionResult) {\n         for (RMContainer c : preemptionResult.selectedContainers) {\n           ApplicationAttemptId appId \u003d c.getApplicationAttemptId();\n           Set\u003cRMContainer\u003e containers \u003d selectedCandidates.get(appId);\n           if (null \u003d\u003d containers) {\n             containers \u003d new HashSet\u003c\u003e();\n             selectedCandidates.put(appId, containers);\n           }\n \n           containers.add(c);\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + c\n                 .getContainerId() + \" from queue\u003d\" + c.getQueueName()\n                 + \" to be preemption candidates\");\n           }\n         }\n       }\n     }\n \n     return selectedCandidates;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource,\n      Resource totalPreemptedResourceAllowed) {\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptedResourceAllowed);\n\n    // Get queue to preemptable resource by partition\n    Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition \u003d\n        new HashMap\u003c\u003e();\n    for (String leafQueue : preemptionContext.getLeafQueueNames()) {\n      queueToPreemptableResourceByPartition.put(leafQueue,\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  leafQueue, clusterResource));\n    }\n\n    // Get list of nodes for preemption, ordered by preemption cost\n    List\u003cNodeForPreemption\u003e nodesForPreemption \u003d getNodesForPreemption(\n        queueToPreemptableResourceByPartition, selectedCandidates,\n        totalPreemptedResourceAllowed);\n\n    for (NodeForPreemption nfp : nodesForPreemption) {\n      RMContainer reservedContainer \u003d nfp.schedulerNode.getReservedContainer();\n      if (null \u003d\u003d reservedContainer) {\n        continue;\n      }\n\n      NodeForPreemption preemptionResult \u003d getPreemptionCandidatesOnNode(\n          nfp.schedulerNode, queueToPreemptableResourceByPartition,\n          selectedCandidates, totalPreemptedResourceAllowed, false);\n      if (null !\u003d preemptionResult) {\n        for (RMContainer c : preemptionResult.selectedContainers) {\n          ApplicationAttemptId appId \u003d c.getApplicationAttemptId();\n          Set\u003cRMContainer\u003e containers \u003d selectedCandidates.get(appId);\n          if (null \u003d\u003d containers) {\n            containers \u003d new HashSet\u003c\u003e();\n            selectedCandidates.put(appId, containers);\n          }\n\n          containers.add(c);\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + c\n                .getContainerId() + \" from queue\u003d\" + c.getQueueName()\n                + \" to be preemption candidates\");\n          }\n        }\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ReservedContainerCandidatesSelector.java",
      "extendedDetails": {}
    },
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
      "commitDate": "05/05/16 12:56 PM",
      "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,54 @@\n+  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n+      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n+      Resource clusterResource,\n+      Resource totalPreemptedResourceAllowed) {\n+    // Calculate how much resources we need to preempt\n+    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n+        totalPreemptedResourceAllowed);\n+\n+    // Get queue to preemptable resource by partition\n+    Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition \u003d\n+        new HashMap\u003c\u003e();\n+    for (String leafQueue : preemptionContext.getLeafQueueNames()) {\n+      queueToPreemptableResourceByPartition.put(leafQueue,\n+          CapacitySchedulerPreemptionUtils\n+              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n+                  leafQueue, clusterResource));\n+    }\n+\n+    // Get list of nodes for preemption, ordered by preemption cost\n+    List\u003cNodeForPreemption\u003e nodesForPreemption \u003d getNodesForPreemption(\n+        clusterResource, queueToPreemptableResourceByPartition,\n+        selectedCandidates, totalPreemptedResourceAllowed);\n+\n+    for (NodeForPreemption nfp : nodesForPreemption) {\n+      RMContainer reservedContainer \u003d nfp.schedulerNode.getReservedContainer();\n+      if (null \u003d\u003d reservedContainer) {\n+        continue;\n+      }\n+\n+      NodeForPreemption preemptionResult \u003d getPreemptionCandidatesOnNode(\n+          nfp.schedulerNode, clusterResource,\n+          queueToPreemptableResourceByPartition, selectedCandidates,\n+          totalPreemptedResourceAllowed, false);\n+      if (null !\u003d preemptionResult) {\n+        for (RMContainer c : preemptionResult.selectedContainers) {\n+          ApplicationAttemptId appId \u003d c.getApplicationAttemptId();\n+          Set\u003cRMContainer\u003e containers \u003d selectedCandidates.get(appId);\n+          if (null \u003d\u003d containers) {\n+            containers \u003d new HashSet\u003c\u003e();\n+            selectedCandidates.put(appId, containers);\n+          }\n+\n+          containers.add(c);\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + c\n+                .getContainerId() + \" from queue\u003d\" + c.getQueueName()\n+                + \" to be preemption candidates\");\n+          }\n+        }\n+      }\n+    }\n+\n+    return selectedCandidates;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectCandidates(\n      Map\u003cApplicationAttemptId, Set\u003cRMContainer\u003e\u003e selectedCandidates,\n      Resource clusterResource,\n      Resource totalPreemptedResourceAllowed) {\n    // Calculate how much resources we need to preempt\n    preemptableAmountCalculator.computeIdealAllocation(clusterResource,\n        totalPreemptedResourceAllowed);\n\n    // Get queue to preemptable resource by partition\n    Map\u003cString, Map\u003cString, Resource\u003e\u003e queueToPreemptableResourceByPartition \u003d\n        new HashMap\u003c\u003e();\n    for (String leafQueue : preemptionContext.getLeafQueueNames()) {\n      queueToPreemptableResourceByPartition.put(leafQueue,\n          CapacitySchedulerPreemptionUtils\n              .getResToObtainByPartitionForLeafQueue(preemptionContext,\n                  leafQueue, clusterResource));\n    }\n\n    // Get list of nodes for preemption, ordered by preemption cost\n    List\u003cNodeForPreemption\u003e nodesForPreemption \u003d getNodesForPreemption(\n        clusterResource, queueToPreemptableResourceByPartition,\n        selectedCandidates, totalPreemptedResourceAllowed);\n\n    for (NodeForPreemption nfp : nodesForPreemption) {\n      RMContainer reservedContainer \u003d nfp.schedulerNode.getReservedContainer();\n      if (null \u003d\u003d reservedContainer) {\n        continue;\n      }\n\n      NodeForPreemption preemptionResult \u003d getPreemptionCandidatesOnNode(\n          nfp.schedulerNode, clusterResource,\n          queueToPreemptableResourceByPartition, selectedCandidates,\n          totalPreemptedResourceAllowed, false);\n      if (null !\u003d preemptionResult) {\n        for (RMContainer c : preemptionResult.selectedContainers) {\n          ApplicationAttemptId appId \u003d c.getApplicationAttemptId();\n          Set\u003cRMContainer\u003e containers \u003d selectedCandidates.get(appId);\n          if (null \u003d\u003d containers) {\n            containers \u003d new HashSet\u003c\u003e();\n            selectedCandidates.put(appId, containers);\n          }\n\n          containers.add(c);\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(this.getClass().getName() + \" Marked container\u003d\" + c\n                .getContainerId() + \" from queue\u003d\" + c.getQueueName()\n                + \" to be preemption candidates\");\n          }\n        }\n      }\n    }\n\n    return selectedCandidates;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/monitor/capacity/ReservedContainerCandidatesSelector.java"
    }
  }
}