{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3Guard.java",
  "functionName": "authoritativeUnion",
  "functionId": "authoritativeUnion___ms-MetadataStore(modifiers-final)__path-Path(modifiers-final)__backingStatuses-List__S3AFileStatus__(modifiers-final)__dirMeta-DirListingMetadata(modifiers-final)__timeProvider-ITtlTimeProvider(modifiers-final)__operationState-BulkOperationState(modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
  "functionStartLine": 381,
  "functionEndLine": 433,
  "numCommitsSeen": 25,
  "timeTaken": 1345,
  "changeHistory": [
    "7f40e6688a5716fca53e1090d8347a43064d6d43"
  ],
  "changeHistoryShort": {
    "7f40e6688a5716fca53e1090d8347a43064d6d43": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7f40e6688a5716fca53e1090d8347a43064d6d43": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-16746. mkdirs and s3guard Authoritative mode.\n\nContributed by Steve Loughran.\n\nThis fixes two problems with S3Guard authoritative mode and\nthe auth directory flags which are stored in DynamoDB.\n\n1. mkdirs was creating dir markers without the auth bit,\n   forcing needless scans on newly created directories and\n   files subsequently added; it was only with the first listStatus call\n   on that directory that the dir would be marked as authoritative -even\n   though it would be complete already.\n\n2. listStatus(path) would reset the authoritative status bit of all\n   child directories even if they were already marked as authoritative.\n\nIssue #2 is possibly the most expensive, as any treewalk using listStatus\n(e.g globfiles) would clear the auth bit for all child directories before\nlisting them. And this would happen every single time...\nessentially you weren\u0027t getting authoritative directory listings.\n\nFor the curious, that the major bug was actually found during testing\n-we\u0027d all missed it during reviews.\n\nA lesson there: the better the tests the fewer the bugs.\n\nMaybe also: something obvious and significant can get by code reviews.\n\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/BulkOperationState.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/NullMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/ITestS3GuardWriteBack.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/auth/ITestRestrictedReadAccess.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/impl/TestPartialDeleteFailures.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreAuthoritativeMode.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreScale.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestS3GuardFsck.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStoreTestBase.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/TestS3Guard.java\n\nChange-Id: Ic3ffda13f2af2430afedd50fd657b595c83e90a7\n",
      "commitDate": "25/01/20 10:35 AM",
      "commitName": "7f40e6688a5716fca53e1090d8347a43064d6d43",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,53 @@\n+  private static void authoritativeUnion(\n+      final MetadataStore ms,\n+      final Path path,\n+      final List\u003cS3AFileStatus\u003e backingStatuses,\n+      final DirListingMetadata dirMeta,\n+      final ITtlTimeProvider timeProvider,\n+      final BulkOperationState operationState) throws IOException {\n+    // track all unchanged entries; used so the metastore can identify entries\n+    // it doesn\u0027t need to update\n+    List\u003cPath\u003e unchangedEntries \u003d new ArrayList\u003c\u003e(dirMeta.getListing().size());\n+    boolean changed \u003d !dirMeta.isAuthoritative();\n+    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n+    final Map\u003cPath, PathMetadata\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n+        .collect(Collectors.toMap(pm -\u003e pm.getFileStatus().getPath(), pm -\u003e pm));\n+    for (S3AFileStatus s : backingStatuses) {\n+      final Path statusPath \u003d s.getPath();\n+      if (deleted.contains(statusPath)) {\n+        continue;\n+      }\n+\n+      // this is built up to be whatever entry is to be added to the dirMeta\n+      // collection\n+      PathMetadata pathMetadata \u003d dirMetaMap.get(statusPath);\n+\n+      if (pathMetadata \u003d\u003d null) {\n+        // there\u0027s no entry in the listing, so create one.\n+        pathMetadata \u003d new PathMetadata(s);\n+      } else {\n+        // no change -add the path to the list of unchangedEntries\n+        unchangedEntries.add(statusPath);\n+      }\n+\n+      // Minor race condition here.  Multiple threads could add to this\n+      // mutable DirListingMetadata.  Since it is backed by a\n+      // ConcurrentHashMap, the last put() wins.\n+      // More concerning is two threads racing on listStatus() and delete().\n+      // Any FileSystem has similar race conditions, but we could persist\n+      // a stale entry longer.  We could expose an atomic\n+      // DirListingMetadata#putIfNotPresent()\n+      changed |\u003d dirMeta.put(pathMetadata);\n+    }\n+\n+    if (changed) {\n+      // in an authoritative update, we pass in the full list of entries,\n+      // but do declare which have not changed to avoid needless and potentially\n+      // destructive overwrites.\n+      LOG.debug(\"Marking the directory {} as authoritative\", path);\n+      ms.getInstrumentation().directoryMarkedAuthoritative();\n+      dirMeta.setAuthoritative(true); // This is the full directory contents\n+      // write the updated dir entry and any changed children.\n+      S3Guard.putWithTtl(ms, dirMeta, unchangedEntries, timeProvider, operationState);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static void authoritativeUnion(\n      final MetadataStore ms,\n      final Path path,\n      final List\u003cS3AFileStatus\u003e backingStatuses,\n      final DirListingMetadata dirMeta,\n      final ITtlTimeProvider timeProvider,\n      final BulkOperationState operationState) throws IOException {\n    // track all unchanged entries; used so the metastore can identify entries\n    // it doesn\u0027t need to update\n    List\u003cPath\u003e unchangedEntries \u003d new ArrayList\u003c\u003e(dirMeta.getListing().size());\n    boolean changed \u003d !dirMeta.isAuthoritative();\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n    final Map\u003cPath, PathMetadata\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n        .collect(Collectors.toMap(pm -\u003e pm.getFileStatus().getPath(), pm -\u003e pm));\n    for (S3AFileStatus s : backingStatuses) {\n      final Path statusPath \u003d s.getPath();\n      if (deleted.contains(statusPath)) {\n        continue;\n      }\n\n      // this is built up to be whatever entry is to be added to the dirMeta\n      // collection\n      PathMetadata pathMetadata \u003d dirMetaMap.get(statusPath);\n\n      if (pathMetadata \u003d\u003d null) {\n        // there\u0027s no entry in the listing, so create one.\n        pathMetadata \u003d new PathMetadata(s);\n      } else {\n        // no change -add the path to the list of unchangedEntries\n        unchangedEntries.add(statusPath);\n      }\n\n      // Minor race condition here.  Multiple threads could add to this\n      // mutable DirListingMetadata.  Since it is backed by a\n      // ConcurrentHashMap, the last put() wins.\n      // More concerning is two threads racing on listStatus() and delete().\n      // Any FileSystem has similar race conditions, but we could persist\n      // a stale entry longer.  We could expose an atomic\n      // DirListingMetadata#putIfNotPresent()\n      changed |\u003d dirMeta.put(pathMetadata);\n    }\n\n    if (changed) {\n      // in an authoritative update, we pass in the full list of entries,\n      // but do declare which have not changed to avoid needless and potentially\n      // destructive overwrites.\n      LOG.debug(\"Marking the directory {} as authoritative\", path);\n      ms.getInstrumentation().directoryMarkedAuthoritative();\n      dirMeta.setAuthoritative(true); // This is the full directory contents\n      // write the updated dir entry and any changed children.\n      S3Guard.putWithTtl(ms, dirMeta, unchangedEntries, timeProvider, operationState);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java"
    }
  }
}