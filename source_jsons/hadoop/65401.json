{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3Guard.java",
  "functionName": "dirListingUnion",
  "functionId": "dirListingUnion___ms-MetadataStore__path-Path__backingStatuses-List__S3AFileStatus____dirMeta-DirListingMetadata__isAuthoritative-boolean__timeProvider-ITtlTimeProvider",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
  "functionStartLine": 317,
  "functionEndLine": 366,
  "numCommitsSeen": 39,
  "timeTaken": 6615,
  "changeHistory": [
    "7f40e6688a5716fca53e1090d8347a43064d6d43",
    "49df83899543586bbcaf80f01399ade031cf68b0",
    "7b219778e05a50e33cca75d727e62783322b7f80",
    "e02eb24e0a9139418120027b694492e0738df20a",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
    "a36274d69947648dbe82721220cc5240ec5d396d",
    "b5db2383832881034d57d836a8135a07a2bd1cf4",
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
    "d7232857d8d1e10cdac171acdc931187e45fd6be",
    "621b43e254afaff708cd6fc4698b29628f6abc33"
  ],
  "changeHistoryShort": {
    "7f40e6688a5716fca53e1090d8347a43064d6d43": "Ybodychange",
    "49df83899543586bbcaf80f01399ade031cf68b0": "Ybodychange",
    "7b219778e05a50e33cca75d727e62783322b7f80": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Ybodychange",
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": "Ybodychange",
    "a36274d69947648dbe82721220cc5240ec5d396d": "Ymultichange(Yparameterchange,Ybodychange)",
    "b5db2383832881034d57d836a8135a07a2bd1cf4": "Ybodychange",
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3": "Ymultichange(Yparameterchange,Ybodychange)",
    "d7232857d8d1e10cdac171acdc931187e45fd6be": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7f40e6688a5716fca53e1090d8347a43064d6d43": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16746. mkdirs and s3guard Authoritative mode.\n\nContributed by Steve Loughran.\n\nThis fixes two problems with S3Guard authoritative mode and\nthe auth directory flags which are stored in DynamoDB.\n\n1. mkdirs was creating dir markers without the auth bit,\n   forcing needless scans on newly created directories and\n   files subsequently added; it was only with the first listStatus call\n   on that directory that the dir would be marked as authoritative -even\n   though it would be complete already.\n\n2. listStatus(path) would reset the authoritative status bit of all\n   child directories even if they were already marked as authoritative.\n\nIssue #2 is possibly the most expensive, as any treewalk using listStatus\n(e.g globfiles) would clear the auth bit for all child directories before\nlisting them. And this would happen every single time...\nessentially you weren\u0027t getting authoritative directory listings.\n\nFor the curious, that the major bug was actually found during testing\n-we\u0027d all missed it during reviews.\n\nA lesson there: the better the tests the fewer the bugs.\n\nMaybe also: something obvious and significant can get by code reviews.\n\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/BulkOperationState.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/LocalMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/NullMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/ITestS3GuardWriteBack.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/auth/ITestRestrictedReadAccess.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/impl/TestPartialDeleteFailures.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStore.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreAuthoritativeMode.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestDynamoDBMetadataStoreScale.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/ITestS3GuardFsck.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/MetadataStoreTestBase.java\n\tmodified:   hadoop-tools/hadoop-aws/src/test/java/org/apache/hadoop/fs/s3a/s3guard/TestS3Guard.java\n\nChange-Id: Ic3ffda13f2af2430afedd50fd657b595c83e90a7\n",
      "commitDate": "25/01/20 10:35 AM",
      "commitName": "7f40e6688a5716fca53e1090d8347a43064d6d43",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "10/01/20 3:11 AM",
      "commitNameOld": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 15.31,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,79 +1,50 @@\n   public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n       List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n       boolean isAuthoritative, ITtlTimeProvider timeProvider)\n       throws IOException {\n \n     // Fast-path for NullMetadataStore\n     if (isNullMetadataStore(ms)) {\n       return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n     }\n \n     assertQualified(path);\n \n     if (dirMeta \u003d\u003d null) {\n       // The metadataStore had zero state for this directory\n       dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n           false);\n     }\n \n-    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n-\n     // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n     // of metadata, we always use its metadata first.\n \n     // Since the authoritative case is already handled outside this function,\n     // we will basically start with the set of directory entries in the\n     // DirListingMetadata, and add any that only exist in the backingStatuses.\n-    boolean changed \u003d false;\n-    final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n-        .collect(Collectors.toMap(\n-            pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n-        );\n+    //\n+    // We try to avoid writing any more child entries than need be to :-\n+    //  (a) save time and money.\n+    //  (b) avoid overwriting the authoritative bit of children (HADOOP-16746).\n+    // For auth mode updates, we supply the full listing and a list of which\n+    // child entries have not been changed; the store gets to optimize its\n+    // update however it chooses.\n+    //\n+    // for non-auth-mode S3Guard, we just build a list of entries to add and\n+    // submit them in a batch; this is more efficient than trickling out the\n+    // updates one-by-one.\n+\n     BulkOperationState operationState \u003d ms.initiateBulkWrite(\n         BulkOperationState.OperationType.Listing,\n         path);\n-    for (S3AFileStatus s : backingStatuses) {\n-      if (deleted.contains(s.getPath())) {\n-        continue;\n-      }\n-\n-      final PathMetadata pathMetadata \u003d new PathMetadata(s);\n-\n-      if (!isAuthoritative){\n-        FileStatus status \u003d dirMetaMap.get(s.getPath());\n-        if (status !\u003d null\n-            \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n-          LOG.debug(\"Update ms with newer metadata of: {}\", status);\n-          S3Guard.putWithTtl(ms, pathMetadata, timeProvider, operationState);\n-        }\n-      }\n-\n-      // Minor race condition here.  Multiple threads could add to this\n-      // mutable DirListingMetadata.  Since it is backed by a\n-      // ConcurrentHashMap, the last put() wins.\n-      // More concerning is two threads racing on listStatus() and delete().\n-      // Any FileSystem has similar race conditions, but we could persist\n-      // a stale entry longer.  We could expose an atomic\n-      // DirListingMetadata#putIfNotPresent()\n-      boolean updated \u003d dirMeta.put(pathMetadata);\n-      changed \u003d changed || updated;\n-    }\n-\n-    // If dirMeta is not authoritative, but isAuthoritative is true the\n-    // directory metadata should be updated. Treat it as a change.\n-    changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n-\n-    if (changed \u0026\u0026 isAuthoritative) {\n-      LOG.debug(\"Marking the directory {} as authoritative\", path);\n-      final MetastoreInstrumentation instrumentation\n-          \u003d ms.getInstrumentation();\n-      if (instrumentation !\u003d null) {\n-        instrumentation.directoryMarkedAuthoritative();\n-      }\n-      dirMeta.setAuthoritative(true); // This is the full directory contents\n-      S3Guard.putWithTtl(ms, dirMeta, timeProvider, operationState);\n+    if (isAuthoritative) {\n+      authoritativeUnion(ms, path, backingStatuses, dirMeta,\n+          timeProvider, operationState);\n+    } else {\n+      nonAuthoritativeUnion(ms, path, backingStatuses, dirMeta,\n+          timeProvider, operationState);\n     }\n     IOUtils.cleanupWithLogger(LOG, operationState);\n \n     return dirMetaToStatuses(dirMeta);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n      List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n      boolean isAuthoritative, ITtlTimeProvider timeProvider)\n      throws IOException {\n\n    // Fast-path for NullMetadataStore\n    if (isNullMetadataStore(ms)) {\n      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n    }\n\n    assertQualified(path);\n\n    if (dirMeta \u003d\u003d null) {\n      // The metadataStore had zero state for this directory\n      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n          false);\n    }\n\n    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n    // of metadata, we always use its metadata first.\n\n    // Since the authoritative case is already handled outside this function,\n    // we will basically start with the set of directory entries in the\n    // DirListingMetadata, and add any that only exist in the backingStatuses.\n    //\n    // We try to avoid writing any more child entries than need be to :-\n    //  (a) save time and money.\n    //  (b) avoid overwriting the authoritative bit of children (HADOOP-16746).\n    // For auth mode updates, we supply the full listing and a list of which\n    // child entries have not been changed; the store gets to optimize its\n    // update however it chooses.\n    //\n    // for non-auth-mode S3Guard, we just build a list of entries to add and\n    // submit them in a batch; this is more efficient than trickling out the\n    // updates one-by-one.\n\n    BulkOperationState operationState \u003d ms.initiateBulkWrite(\n        BulkOperationState.OperationType.Listing,\n        path);\n    if (isAuthoritative) {\n      authoritativeUnion(ms, path, backingStatuses, dirMeta,\n          timeProvider, operationState);\n    } else {\n      nonAuthoritativeUnion(ms, path, backingStatuses, dirMeta,\n          timeProvider, operationState);\n    }\n    IOUtils.cleanupWithLogger(LOG, operationState);\n\n    return dirMetaToStatuses(dirMeta);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
      "extendedDetails": {}
    },
    "49df83899543586bbcaf80f01399ade031cf68b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
      "commitDate": "10/01/20 3:11 AM",
      "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "26/11/19 7:36 AM",
      "commitNameOld": "ea25f4de236611d388e14a710ebe5d6872c421b6",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 44.82,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,79 @@\n   public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n       List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n       boolean isAuthoritative, ITtlTimeProvider timeProvider)\n       throws IOException {\n \n     // Fast-path for NullMetadataStore\n     if (isNullMetadataStore(ms)) {\n       return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n     }\n \n     assertQualified(path);\n \n     if (dirMeta \u003d\u003d null) {\n       // The metadataStore had zero state for this directory\n       dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n           false);\n     }\n \n     Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n \n     // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n     // of metadata, we always use its metadata first.\n \n     // Since the authoritative case is already handled outside this function,\n     // we will basically start with the set of directory entries in the\n     // DirListingMetadata, and add any that only exist in the backingStatuses.\n     boolean changed \u003d false;\n     final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n         .collect(Collectors.toMap(\n             pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n         );\n-\n+    BulkOperationState operationState \u003d ms.initiateBulkWrite(\n+        BulkOperationState.OperationType.Listing,\n+        path);\n     for (S3AFileStatus s : backingStatuses) {\n       if (deleted.contains(s.getPath())) {\n         continue;\n       }\n \n       final PathMetadata pathMetadata \u003d new PathMetadata(s);\n \n       if (!isAuthoritative){\n         FileStatus status \u003d dirMetaMap.get(s.getPath());\n         if (status !\u003d null\n             \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n           LOG.debug(\"Update ms with newer metadata of: {}\", status);\n-          S3Guard.putWithTtl(ms, pathMetadata, timeProvider, null);\n+          S3Guard.putWithTtl(ms, pathMetadata, timeProvider, operationState);\n         }\n       }\n \n       // Minor race condition here.  Multiple threads could add to this\n       // mutable DirListingMetadata.  Since it is backed by a\n       // ConcurrentHashMap, the last put() wins.\n       // More concerning is two threads racing on listStatus() and delete().\n       // Any FileSystem has similar race conditions, but we could persist\n       // a stale entry longer.  We could expose an atomic\n       // DirListingMetadata#putIfNotPresent()\n       boolean updated \u003d dirMeta.put(pathMetadata);\n       changed \u003d changed || updated;\n     }\n \n     // If dirMeta is not authoritative, but isAuthoritative is true the\n     // directory metadata should be updated. Treat it as a change.\n     changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n \n     if (changed \u0026\u0026 isAuthoritative) {\n+      LOG.debug(\"Marking the directory {} as authoritative\", path);\n+      final MetastoreInstrumentation instrumentation\n+          \u003d ms.getInstrumentation();\n+      if (instrumentation !\u003d null) {\n+        instrumentation.directoryMarkedAuthoritative();\n+      }\n       dirMeta.setAuthoritative(true); // This is the full directory contents\n-      S3Guard.putWithTtl(ms, dirMeta, timeProvider, null);\n+      S3Guard.putWithTtl(ms, dirMeta, timeProvider, operationState);\n     }\n+    IOUtils.cleanupWithLogger(LOG, operationState);\n \n     return dirMetaToStatuses(dirMeta);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n      List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n      boolean isAuthoritative, ITtlTimeProvider timeProvider)\n      throws IOException {\n\n    // Fast-path for NullMetadataStore\n    if (isNullMetadataStore(ms)) {\n      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n    }\n\n    assertQualified(path);\n\n    if (dirMeta \u003d\u003d null) {\n      // The metadataStore had zero state for this directory\n      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n          false);\n    }\n\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n\n    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n    // of metadata, we always use its metadata first.\n\n    // Since the authoritative case is already handled outside this function,\n    // we will basically start with the set of directory entries in the\n    // DirListingMetadata, and add any that only exist in the backingStatuses.\n    boolean changed \u003d false;\n    final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n        .collect(Collectors.toMap(\n            pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n        );\n    BulkOperationState operationState \u003d ms.initiateBulkWrite(\n        BulkOperationState.OperationType.Listing,\n        path);\n    for (S3AFileStatus s : backingStatuses) {\n      if (deleted.contains(s.getPath())) {\n        continue;\n      }\n\n      final PathMetadata pathMetadata \u003d new PathMetadata(s);\n\n      if (!isAuthoritative){\n        FileStatus status \u003d dirMetaMap.get(s.getPath());\n        if (status !\u003d null\n            \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n          LOG.debug(\"Update ms with newer metadata of: {}\", status);\n          S3Guard.putWithTtl(ms, pathMetadata, timeProvider, operationState);\n        }\n      }\n\n      // Minor race condition here.  Multiple threads could add to this\n      // mutable DirListingMetadata.  Since it is backed by a\n      // ConcurrentHashMap, the last put() wins.\n      // More concerning is two threads racing on listStatus() and delete().\n      // Any FileSystem has similar race conditions, but we could persist\n      // a stale entry longer.  We could expose an atomic\n      // DirListingMetadata#putIfNotPresent()\n      boolean updated \u003d dirMeta.put(pathMetadata);\n      changed \u003d changed || updated;\n    }\n\n    // If dirMeta is not authoritative, but isAuthoritative is true the\n    // directory metadata should be updated. Treat it as a change.\n    changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n\n    if (changed \u0026\u0026 isAuthoritative) {\n      LOG.debug(\"Marking the directory {} as authoritative\", path);\n      final MetastoreInstrumentation instrumentation\n          \u003d ms.getInstrumentation();\n      if (instrumentation !\u003d null) {\n        instrumentation.directoryMarkedAuthoritative();\n      }\n      dirMeta.setAuthoritative(true); // This is the full directory contents\n      S3Guard.putWithTtl(ms, dirMeta, timeProvider, operationState);\n    }\n    IOUtils.cleanupWithLogger(LOG, operationState);\n\n    return dirMetaToStatuses(dirMeta);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
      "extendedDetails": {}
    },
    "7b219778e05a50e33cca75d727e62783322b7f80": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16433. S3Guard: Filter expired entries and tombstones when listing with MetadataStore.listChildren().\n\nContributed by Gabor Bota.\n\nThis pulls the tracking of the lastUpdated timestamp of metadata entries up from the DDB metastore into all s3guard stores, and then uses this to filter out expired tombstones from listings.\n\nChange-Id: I80f121236b49c75a024116f65a3ef29d3580b462\n",
      "commitDate": "24/07/19 10:11 AM",
      "commitName": "7b219778e05a50e33cca75d727e62783322b7f80",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "23/07/19 6:52 AM",
      "commitNameOld": "4317d332321778269a583e2223d433107fab82eb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 1.14,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,70 @@\n   public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n       List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n       boolean isAuthoritative, ITtlTimeProvider timeProvider)\n       throws IOException {\n \n     // Fast-path for NullMetadataStore\n     if (isNullMetadataStore(ms)) {\n       return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n     }\n \n     assertQualified(path);\n \n     if (dirMeta \u003d\u003d null) {\n       // The metadataStore had zero state for this directory\n       dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n           false);\n     }\n \n     Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n \n     // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n     // of metadata, we always use its metadata first.\n \n     // Since the authoritative case is already handled outside this function,\n     // we will basically start with the set of directory entries in the\n     // DirListingMetadata, and add any that only exist in the backingStatuses.\n     boolean changed \u003d false;\n     final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n         .collect(Collectors.toMap(\n             pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n         );\n \n     for (S3AFileStatus s : backingStatuses) {\n       if (deleted.contains(s.getPath())) {\n         continue;\n       }\n \n+      final PathMetadata pathMetadata \u003d new PathMetadata(s);\n+\n       if (!isAuthoritative){\n         FileStatus status \u003d dirMetaMap.get(s.getPath());\n         if (status !\u003d null\n             \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n           LOG.debug(\"Update ms with newer metadata of: {}\", status);\n-          S3Guard.putWithTtl(ms, new PathMetadata(s), timeProvider, null);\n+          S3Guard.putWithTtl(ms, pathMetadata, timeProvider, null);\n         }\n       }\n \n       // Minor race condition here.  Multiple threads could add to this\n       // mutable DirListingMetadata.  Since it is backed by a\n       // ConcurrentHashMap, the last put() wins.\n       // More concerning is two threads racing on listStatus() and delete().\n       // Any FileSystem has similar race conditions, but we could persist\n       // a stale entry longer.  We could expose an atomic\n       // DirListingMetadata#putIfNotPresent()\n-      boolean updated \u003d dirMeta.put(s);\n+      boolean updated \u003d dirMeta.put(pathMetadata);\n       changed \u003d changed || updated;\n     }\n \n     // If dirMeta is not authoritative, but isAuthoritative is true the\n     // directory metadata should be updated. Treat it as a change.\n     changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n \n     if (changed \u0026\u0026 isAuthoritative) {\n       dirMeta.setAuthoritative(true); // This is the full directory contents\n       S3Guard.putWithTtl(ms, dirMeta, timeProvider, null);\n     }\n \n     return dirMetaToStatuses(dirMeta);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n      List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n      boolean isAuthoritative, ITtlTimeProvider timeProvider)\n      throws IOException {\n\n    // Fast-path for NullMetadataStore\n    if (isNullMetadataStore(ms)) {\n      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n    }\n\n    assertQualified(path);\n\n    if (dirMeta \u003d\u003d null) {\n      // The metadataStore had zero state for this directory\n      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n          false);\n    }\n\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n\n    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n    // of metadata, we always use its metadata first.\n\n    // Since the authoritative case is already handled outside this function,\n    // we will basically start with the set of directory entries in the\n    // DirListingMetadata, and add any that only exist in the backingStatuses.\n    boolean changed \u003d false;\n    final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n        .collect(Collectors.toMap(\n            pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n        );\n\n    for (S3AFileStatus s : backingStatuses) {\n      if (deleted.contains(s.getPath())) {\n        continue;\n      }\n\n      final PathMetadata pathMetadata \u003d new PathMetadata(s);\n\n      if (!isAuthoritative){\n        FileStatus status \u003d dirMetaMap.get(s.getPath());\n        if (status !\u003d null\n            \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n          LOG.debug(\"Update ms with newer metadata of: {}\", status);\n          S3Guard.putWithTtl(ms, pathMetadata, timeProvider, null);\n        }\n      }\n\n      // Minor race condition here.  Multiple threads could add to this\n      // mutable DirListingMetadata.  Since it is backed by a\n      // ConcurrentHashMap, the last put() wins.\n      // More concerning is two threads racing on listStatus() and delete().\n      // Any FileSystem has similar race conditions, but we could persist\n      // a stale entry longer.  We could expose an atomic\n      // DirListingMetadata#putIfNotPresent()\n      boolean updated \u003d dirMeta.put(pathMetadata);\n      changed \u003d changed || updated;\n    }\n\n    // If dirMeta is not authoritative, but isAuthoritative is true the\n    // directory metadata should be updated. Treat it as a change.\n    changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n\n    if (changed \u0026\u0026 isAuthoritative) {\n      dirMeta.setAuthoritative(true); // This is the full directory contents\n      S3Guard.putWithTtl(ms, dirMeta, timeProvider, null);\n    }\n\n    return dirMetaToStatuses(dirMeta);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "16/06/19 9:05 AM",
      "commitNameOld": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 3.7,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n       List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n       boolean isAuthoritative, ITtlTimeProvider timeProvider)\n       throws IOException {\n \n     // Fast-path for NullMetadataStore\n     if (isNullMetadataStore(ms)) {\n       return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n     }\n \n     assertQualified(path);\n \n     if (dirMeta \u003d\u003d null) {\n       // The metadataStore had zero state for this directory\n       dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n           false);\n     }\n \n     Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n \n     // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n     // of metadata, we always use its metadata first.\n \n     // Since the authoritative case is already handled outside this function,\n     // we will basically start with the set of directory entries in the\n     // DirListingMetadata, and add any that only exist in the backingStatuses.\n     boolean changed \u003d false;\n     final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n         .collect(Collectors.toMap(\n             pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n         );\n \n     for (S3AFileStatus s : backingStatuses) {\n       if (deleted.contains(s.getPath())) {\n         continue;\n       }\n \n       if (!isAuthoritative){\n         FileStatus status \u003d dirMetaMap.get(s.getPath());\n         if (status !\u003d null\n             \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n           LOG.debug(\"Update ms with newer metadata of: {}\", status);\n-          S3Guard.putWithTtl(ms, new PathMetadata(s), timeProvider);\n+          S3Guard.putWithTtl(ms, new PathMetadata(s), timeProvider, null);\n         }\n       }\n \n       // Minor race condition here.  Multiple threads could add to this\n       // mutable DirListingMetadata.  Since it is backed by a\n       // ConcurrentHashMap, the last put() wins.\n       // More concerning is two threads racing on listStatus() and delete().\n       // Any FileSystem has similar race conditions, but we could persist\n       // a stale entry longer.  We could expose an atomic\n       // DirListingMetadata#putIfNotPresent()\n       boolean updated \u003d dirMeta.put(s);\n       changed \u003d changed || updated;\n     }\n \n     // If dirMeta is not authoritative, but isAuthoritative is true the\n     // directory metadata should be updated. Treat it as a change.\n     changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n \n     if (changed \u0026\u0026 isAuthoritative) {\n       dirMeta.setAuthoritative(true); // This is the full directory contents\n-      S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n+      S3Guard.putWithTtl(ms, dirMeta, timeProvider, null);\n     }\n \n     return dirMetaToStatuses(dirMeta);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n      List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n      boolean isAuthoritative, ITtlTimeProvider timeProvider)\n      throws IOException {\n\n    // Fast-path for NullMetadataStore\n    if (isNullMetadataStore(ms)) {\n      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n    }\n\n    assertQualified(path);\n\n    if (dirMeta \u003d\u003d null) {\n      // The metadataStore had zero state for this directory\n      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n          false);\n    }\n\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n\n    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n    // of metadata, we always use its metadata first.\n\n    // Since the authoritative case is already handled outside this function,\n    // we will basically start with the set of directory entries in the\n    // DirListingMetadata, and add any that only exist in the backingStatuses.\n    boolean changed \u003d false;\n    final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n        .collect(Collectors.toMap(\n            pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n        );\n\n    for (S3AFileStatus s : backingStatuses) {\n      if (deleted.contains(s.getPath())) {\n        continue;\n      }\n\n      if (!isAuthoritative){\n        FileStatus status \u003d dirMetaMap.get(s.getPath());\n        if (status !\u003d null\n            \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n          LOG.debug(\"Update ms with newer metadata of: {}\", status);\n          S3Guard.putWithTtl(ms, new PathMetadata(s), timeProvider, null);\n        }\n      }\n\n      // Minor race condition here.  Multiple threads could add to this\n      // mutable DirListingMetadata.  Since it is backed by a\n      // ConcurrentHashMap, the last put() wins.\n      // More concerning is two threads racing on listStatus() and delete().\n      // Any FileSystem has similar race conditions, but we could persist\n      // a stale entry longer.  We could expose an atomic\n      // DirListingMetadata#putIfNotPresent()\n      boolean updated \u003d dirMeta.put(s);\n      changed \u003d changed || updated;\n    }\n\n    // If dirMeta is not authoritative, but isAuthoritative is true the\n    // directory metadata should be updated. Treat it as a change.\n    changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n\n    if (changed \u0026\u0026 isAuthoritative) {\n      dirMeta.setAuthoritative(true); // This is the full directory contents\n      S3Guard.putWithTtl(ms, dirMeta, timeProvider, null);\n    }\n\n    return dirMetaToStatuses(dirMeta);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
      "extendedDetails": {}
    },
    "f9cc9e162175444efe9d5b07ecb9a795f750ca3c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16279. S3Guard: Implement time-based (TTL) expiry for entries (and tombstones).\n\nContributed by Gabor Bota.\n\nChange-Id: I73a2d2861901dedfe7a0e783b310fbb95e7c1af9\n",
      "commitDate": "16/06/19 9:05 AM",
      "commitName": "f9cc9e162175444efe9d5b07ecb9a795f750ca3c",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "19/05/19 2:29 PM",
      "commitNameOld": "a36274d69947648dbe82721220cc5240ec5d396d",
      "commitAuthorOld": "Ben Roling",
      "daysBetweenCommits": 27.77,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n       List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n       boolean isAuthoritative, ITtlTimeProvider timeProvider)\n       throws IOException {\n \n     // Fast-path for NullMetadataStore\n     if (isNullMetadataStore(ms)) {\n       return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n     }\n \n     assertQualified(path);\n \n     if (dirMeta \u003d\u003d null) {\n       // The metadataStore had zero state for this directory\n       dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n           false);\n     }\n \n     Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n \n     // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n     // of metadata, we always use its metadata first.\n \n     // Since the authoritative case is already handled outside this function,\n     // we will basically start with the set of directory entries in the\n     // DirListingMetadata, and add any that only exist in the backingStatuses.\n     boolean changed \u003d false;\n     final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n         .collect(Collectors.toMap(\n             pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n         );\n \n     for (S3AFileStatus s : backingStatuses) {\n       if (deleted.contains(s.getPath())) {\n         continue;\n       }\n \n       if (!isAuthoritative){\n         FileStatus status \u003d dirMetaMap.get(s.getPath());\n         if (status !\u003d null\n             \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n           LOG.debug(\"Update ms with newer metadata of: {}\", status);\n-          ms.put(new PathMetadata(s));\n+          S3Guard.putWithTtl(ms, new PathMetadata(s), timeProvider);\n         }\n       }\n \n       // Minor race condition here.  Multiple threads could add to this\n       // mutable DirListingMetadata.  Since it is backed by a\n       // ConcurrentHashMap, the last put() wins.\n       // More concerning is two threads racing on listStatus() and delete().\n       // Any FileSystem has similar race conditions, but we could persist\n       // a stale entry longer.  We could expose an atomic\n       // DirListingMetadata#putIfNotPresent()\n       boolean updated \u003d dirMeta.put(s);\n       changed \u003d changed || updated;\n     }\n \n     // If dirMeta is not authoritative, but isAuthoritative is true the\n     // directory metadata should be updated. Treat it as a change.\n     changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n \n     if (changed \u0026\u0026 isAuthoritative) {\n       dirMeta.setAuthoritative(true); // This is the full directory contents\n       S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n     }\n \n     return dirMetaToStatuses(dirMeta);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n      List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n      boolean isAuthoritative, ITtlTimeProvider timeProvider)\n      throws IOException {\n\n    // Fast-path for NullMetadataStore\n    if (isNullMetadataStore(ms)) {\n      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n    }\n\n    assertQualified(path);\n\n    if (dirMeta \u003d\u003d null) {\n      // The metadataStore had zero state for this directory\n      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n          false);\n    }\n\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n\n    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n    // of metadata, we always use its metadata first.\n\n    // Since the authoritative case is already handled outside this function,\n    // we will basically start with the set of directory entries in the\n    // DirListingMetadata, and add any that only exist in the backingStatuses.\n    boolean changed \u003d false;\n    final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n        .collect(Collectors.toMap(\n            pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n        );\n\n    for (S3AFileStatus s : backingStatuses) {\n      if (deleted.contains(s.getPath())) {\n        continue;\n      }\n\n      if (!isAuthoritative){\n        FileStatus status \u003d dirMetaMap.get(s.getPath());\n        if (status !\u003d null\n            \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n          LOG.debug(\"Update ms with newer metadata of: {}\", status);\n          S3Guard.putWithTtl(ms, new PathMetadata(s), timeProvider);\n        }\n      }\n\n      // Minor race condition here.  Multiple threads could add to this\n      // mutable DirListingMetadata.  Since it is backed by a\n      // ConcurrentHashMap, the last put() wins.\n      // More concerning is two threads racing on listStatus() and delete().\n      // Any FileSystem has similar race conditions, but we could persist\n      // a stale entry longer.  We could expose an atomic\n      // DirListingMetadata#putIfNotPresent()\n      boolean updated \u003d dirMeta.put(s);\n      changed \u003d changed || updated;\n    }\n\n    // If dirMeta is not authoritative, but isAuthoritative is true the\n    // directory metadata should be updated. Treat it as a change.\n    changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n\n    if (changed \u0026\u0026 isAuthoritative) {\n      dirMeta.setAuthoritative(true); // This is the full directory contents\n      S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n    }\n\n    return dirMetaToStatuses(dirMeta);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
      "extendedDetails": {}
    },
    "a36274d69947648dbe82721220cc5240ec5d396d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
      "commitDate": "19/05/19 2:29 PM",
      "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
      "commitAuthor": "Ben Roling",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
          "commitDate": "19/05/19 2:29 PM",
          "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
          "commitAuthor": "Ben Roling",
          "commitDateOld": "30/04/19 3:53 AM",
          "commitNameOld": "0af4011580878566213016af0c32633eabd15100",
          "commitAuthorOld": "Ben Roling",
          "daysBetweenCommits": 19.44,
          "commitsBetweenForRepo": 90,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,68 @@\n   public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n-      List\u003cFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n+      List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n       boolean isAuthoritative, ITtlTimeProvider timeProvider)\n       throws IOException {\n \n     // Fast-path for NullMetadataStore\n     if (isNullMetadataStore(ms)) {\n       return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n     }\n \n     assertQualified(path);\n \n     if (dirMeta \u003d\u003d null) {\n       // The metadataStore had zero state for this directory\n       dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n           false);\n     }\n \n     Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n \n     // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n     // of metadata, we always use its metadata first.\n \n     // Since the authoritative case is already handled outside this function,\n     // we will basically start with the set of directory entries in the\n     // DirListingMetadata, and add any that only exist in the backingStatuses.\n     boolean changed \u003d false;\n     final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n         .collect(Collectors.toMap(\n             pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n         );\n \n-    for (FileStatus s : backingStatuses) {\n+    for (S3AFileStatus s : backingStatuses) {\n       if (deleted.contains(s.getPath())) {\n         continue;\n       }\n \n       if (!isAuthoritative){\n         FileStatus status \u003d dirMetaMap.get(s.getPath());\n         if (status !\u003d null\n             \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n           LOG.debug(\"Update ms with newer metadata of: {}\", status);\n           ms.put(new PathMetadata(s));\n         }\n       }\n \n       // Minor race condition here.  Multiple threads could add to this\n       // mutable DirListingMetadata.  Since it is backed by a\n       // ConcurrentHashMap, the last put() wins.\n       // More concerning is two threads racing on listStatus() and delete().\n       // Any FileSystem has similar race conditions, but we could persist\n       // a stale entry longer.  We could expose an atomic\n       // DirListingMetadata#putIfNotPresent()\n       boolean updated \u003d dirMeta.put(s);\n       changed \u003d changed || updated;\n     }\n \n     // If dirMeta is not authoritative, but isAuthoritative is true the\n     // directory metadata should be updated. Treat it as a change.\n     changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n \n     if (changed \u0026\u0026 isAuthoritative) {\n       dirMeta.setAuthoritative(true); // This is the full directory contents\n       S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n     }\n \n     return dirMetaToStatuses(dirMeta);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n      List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n      boolean isAuthoritative, ITtlTimeProvider timeProvider)\n      throws IOException {\n\n    // Fast-path for NullMetadataStore\n    if (isNullMetadataStore(ms)) {\n      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n    }\n\n    assertQualified(path);\n\n    if (dirMeta \u003d\u003d null) {\n      // The metadataStore had zero state for this directory\n      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n          false);\n    }\n\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n\n    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n    // of metadata, we always use its metadata first.\n\n    // Since the authoritative case is already handled outside this function,\n    // we will basically start with the set of directory entries in the\n    // DirListingMetadata, and add any that only exist in the backingStatuses.\n    boolean changed \u003d false;\n    final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n        .collect(Collectors.toMap(\n            pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n        );\n\n    for (S3AFileStatus s : backingStatuses) {\n      if (deleted.contains(s.getPath())) {\n        continue;\n      }\n\n      if (!isAuthoritative){\n        FileStatus status \u003d dirMetaMap.get(s.getPath());\n        if (status !\u003d null\n            \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n          LOG.debug(\"Update ms with newer metadata of: {}\", status);\n          ms.put(new PathMetadata(s));\n        }\n      }\n\n      // Minor race condition here.  Multiple threads could add to this\n      // mutable DirListingMetadata.  Since it is backed by a\n      // ConcurrentHashMap, the last put() wins.\n      // More concerning is two threads racing on listStatus() and delete().\n      // Any FileSystem has similar race conditions, but we could persist\n      // a stale entry longer.  We could expose an atomic\n      // DirListingMetadata#putIfNotPresent()\n      boolean updated \u003d dirMeta.put(s);\n      changed \u003d changed || updated;\n    }\n\n    // If dirMeta is not authoritative, but isAuthoritative is true the\n    // directory metadata should be updated. Treat it as a change.\n    changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n\n    if (changed \u0026\u0026 isAuthoritative) {\n      dirMeta.setAuthoritative(true); // This is the full directory contents\n      S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n    }\n\n    return dirMetaToStatuses(dirMeta);\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
          "extendedDetails": {
            "oldValue": "[ms-MetadataStore, path-Path, backingStatuses-List\u003cFileStatus\u003e, dirMeta-DirListingMetadata, isAuthoritative-boolean, timeProvider-ITtlTimeProvider]",
            "newValue": "[ms-MetadataStore, path-Path, backingStatuses-List\u003cS3AFileStatus\u003e, dirMeta-DirListingMetadata, isAuthoritative-boolean, timeProvider-ITtlTimeProvider]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-16085. S3Guard: use object version or etags to protect against inconsistent read after replace/overwrite.\n\nContributed by Ben Roling.\n\nS3Guard will now track the etag of uploaded files and, if an S3\nbucket is versioned, the object version.\n\nYou can then control how to react to a mismatch between the data\nin the DynamoDB table and that in the store: warn, fail, or, when\nusing versions, return the original value.\n\nThis adds two new columns to the table: etag and version.\nThis is transparent to older S3A clients -but when such clients\nadd/update data to the S3Guard table, they will not add these values.\nAs a result, the etag/version checks will not work with files uploaded by older clients.\n\nFor a consistent experience, upgrade all clients to use the latest hadoop version.\n",
          "commitDate": "19/05/19 2:29 PM",
          "commitName": "a36274d69947648dbe82721220cc5240ec5d396d",
          "commitAuthor": "Ben Roling",
          "commitDateOld": "30/04/19 3:53 AM",
          "commitNameOld": "0af4011580878566213016af0c32633eabd15100",
          "commitAuthorOld": "Ben Roling",
          "daysBetweenCommits": 19.44,
          "commitsBetweenForRepo": 90,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,68 @@\n   public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n-      List\u003cFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n+      List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n       boolean isAuthoritative, ITtlTimeProvider timeProvider)\n       throws IOException {\n \n     // Fast-path for NullMetadataStore\n     if (isNullMetadataStore(ms)) {\n       return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n     }\n \n     assertQualified(path);\n \n     if (dirMeta \u003d\u003d null) {\n       // The metadataStore had zero state for this directory\n       dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n           false);\n     }\n \n     Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n \n     // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n     // of metadata, we always use its metadata first.\n \n     // Since the authoritative case is already handled outside this function,\n     // we will basically start with the set of directory entries in the\n     // DirListingMetadata, and add any that only exist in the backingStatuses.\n     boolean changed \u003d false;\n     final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n         .collect(Collectors.toMap(\n             pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n         );\n \n-    for (FileStatus s : backingStatuses) {\n+    for (S3AFileStatus s : backingStatuses) {\n       if (deleted.contains(s.getPath())) {\n         continue;\n       }\n \n       if (!isAuthoritative){\n         FileStatus status \u003d dirMetaMap.get(s.getPath());\n         if (status !\u003d null\n             \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n           LOG.debug(\"Update ms with newer metadata of: {}\", status);\n           ms.put(new PathMetadata(s));\n         }\n       }\n \n       // Minor race condition here.  Multiple threads could add to this\n       // mutable DirListingMetadata.  Since it is backed by a\n       // ConcurrentHashMap, the last put() wins.\n       // More concerning is two threads racing on listStatus() and delete().\n       // Any FileSystem has similar race conditions, but we could persist\n       // a stale entry longer.  We could expose an atomic\n       // DirListingMetadata#putIfNotPresent()\n       boolean updated \u003d dirMeta.put(s);\n       changed \u003d changed || updated;\n     }\n \n     // If dirMeta is not authoritative, but isAuthoritative is true the\n     // directory metadata should be updated. Treat it as a change.\n     changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n \n     if (changed \u0026\u0026 isAuthoritative) {\n       dirMeta.setAuthoritative(true); // This is the full directory contents\n       S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n     }\n \n     return dirMetaToStatuses(dirMeta);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n      List\u003cS3AFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n      boolean isAuthoritative, ITtlTimeProvider timeProvider)\n      throws IOException {\n\n    // Fast-path for NullMetadataStore\n    if (isNullMetadataStore(ms)) {\n      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n    }\n\n    assertQualified(path);\n\n    if (dirMeta \u003d\u003d null) {\n      // The metadataStore had zero state for this directory\n      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n          false);\n    }\n\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n\n    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n    // of metadata, we always use its metadata first.\n\n    // Since the authoritative case is already handled outside this function,\n    // we will basically start with the set of directory entries in the\n    // DirListingMetadata, and add any that only exist in the backingStatuses.\n    boolean changed \u003d false;\n    final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n        .collect(Collectors.toMap(\n            pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n        );\n\n    for (S3AFileStatus s : backingStatuses) {\n      if (deleted.contains(s.getPath())) {\n        continue;\n      }\n\n      if (!isAuthoritative){\n        FileStatus status \u003d dirMetaMap.get(s.getPath());\n        if (status !\u003d null\n            \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n          LOG.debug(\"Update ms with newer metadata of: {}\", status);\n          ms.put(new PathMetadata(s));\n        }\n      }\n\n      // Minor race condition here.  Multiple threads could add to this\n      // mutable DirListingMetadata.  Since it is backed by a\n      // ConcurrentHashMap, the last put() wins.\n      // More concerning is two threads racing on listStatus() and delete().\n      // Any FileSystem has similar race conditions, but we could persist\n      // a stale entry longer.  We could expose an atomic\n      // DirListingMetadata#putIfNotPresent()\n      boolean updated \u003d dirMeta.put(s);\n      changed \u003d changed || updated;\n    }\n\n    // If dirMeta is not authoritative, but isAuthoritative is true the\n    // directory metadata should be updated. Treat it as a change.\n    changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n\n    if (changed \u0026\u0026 isAuthoritative) {\n      dirMeta.setAuthoritative(true); // This is the full directory contents\n      S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n    }\n\n    return dirMetaToStatuses(dirMeta);\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
          "extendedDetails": {}
        }
      ]
    },
    "b5db2383832881034d57d836a8135a07a2bd1cf4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15999. S3Guard: Better support for out-of-band operations.\n\nAuthor:    Gabor Bota\n",
      "commitDate": "28/03/19 8:59 AM",
      "commitName": "b5db2383832881034d57d836a8135a07a2bd1cf4",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "11/02/19 1:07 PM",
      "commitNameOld": "6c999fe4b0181720c8e55be8388bd592196c8c87",
      "commitAuthorOld": "Masatake Iwasaki",
      "daysBetweenCommits": 44.79,
      "commitsBetweenForRepo": 382,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,68 @@\n   public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n       List\u003cFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n       boolean isAuthoritative, ITtlTimeProvider timeProvider)\n       throws IOException {\n \n     // Fast-path for NullMetadataStore\n     if (isNullMetadataStore(ms)) {\n       return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n     }\n \n     assertQualified(path);\n \n     if (dirMeta \u003d\u003d null) {\n       // The metadataStore had zero state for this directory\n       dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n           false);\n     }\n \n     Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n \n     // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n     // of metadata, we always use its metadata first.\n \n     // Since the authoritative case is already handled outside this function,\n     // we will basically start with the set of directory entries in the\n     // DirListingMetadata, and add any that only exist in the backingStatuses.\n-\n     boolean changed \u003d false;\n+    final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n+        .collect(Collectors.toMap(\n+            pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n+        );\n+\n     for (FileStatus s : backingStatuses) {\n       if (deleted.contains(s.getPath())) {\n         continue;\n       }\n \n+      if (!isAuthoritative){\n+        FileStatus status \u003d dirMetaMap.get(s.getPath());\n+        if (status !\u003d null\n+            \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n+          LOG.debug(\"Update ms with newer metadata of: {}\", status);\n+          ms.put(new PathMetadata(s));\n+        }\n+      }\n+\n       // Minor race condition here.  Multiple threads could add to this\n       // mutable DirListingMetadata.  Since it is backed by a\n       // ConcurrentHashMap, the last put() wins.\n       // More concerning is two threads racing on listStatus() and delete().\n       // Any FileSystem has similar race conditions, but we could persist\n       // a stale entry longer.  We could expose an atomic\n       // DirListingMetadata#putIfNotPresent()\n       boolean updated \u003d dirMeta.put(s);\n       changed \u003d changed || updated;\n     }\n \n     // If dirMeta is not authoritative, but isAuthoritative is true the\n     // directory metadata should be updated. Treat it as a change.\n     changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n \n     if (changed \u0026\u0026 isAuthoritative) {\n       dirMeta.setAuthoritative(true); // This is the full directory contents\n       S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n     }\n \n     return dirMetaToStatuses(dirMeta);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n      List\u003cFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n      boolean isAuthoritative, ITtlTimeProvider timeProvider)\n      throws IOException {\n\n    // Fast-path for NullMetadataStore\n    if (isNullMetadataStore(ms)) {\n      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n    }\n\n    assertQualified(path);\n\n    if (dirMeta \u003d\u003d null) {\n      // The metadataStore had zero state for this directory\n      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n          false);\n    }\n\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n\n    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n    // of metadata, we always use its metadata first.\n\n    // Since the authoritative case is already handled outside this function,\n    // we will basically start with the set of directory entries in the\n    // DirListingMetadata, and add any that only exist in the backingStatuses.\n    boolean changed \u003d false;\n    final Map\u003cPath, FileStatus\u003e dirMetaMap \u003d dirMeta.getListing().stream()\n        .collect(Collectors.toMap(\n            pm -\u003e pm.getFileStatus().getPath(), PathMetadata::getFileStatus)\n        );\n\n    for (FileStatus s : backingStatuses) {\n      if (deleted.contains(s.getPath())) {\n        continue;\n      }\n\n      if (!isAuthoritative){\n        FileStatus status \u003d dirMetaMap.get(s.getPath());\n        if (status !\u003d null\n            \u0026\u0026 s.getModificationTime() \u003e status.getModificationTime()) {\n          LOG.debug(\"Update ms with newer metadata of: {}\", status);\n          ms.put(new PathMetadata(s));\n        }\n      }\n\n      // Minor race condition here.  Multiple threads could add to this\n      // mutable DirListingMetadata.  Since it is backed by a\n      // ConcurrentHashMap, the last put() wins.\n      // More concerning is two threads racing on listStatus() and delete().\n      // Any FileSystem has similar race conditions, but we could persist\n      // a stale entry longer.  We could expose an atomic\n      // DirListingMetadata#putIfNotPresent()\n      boolean updated \u003d dirMeta.put(s);\n      changed \u003d changed || updated;\n    }\n\n    // If dirMeta is not authoritative, but isAuthoritative is true the\n    // directory metadata should be updated. Treat it as a change.\n    changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n\n    if (changed \u0026\u0026 isAuthoritative) {\n      dirMeta.setAuthoritative(true); // This is the full directory contents\n      S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n    }\n\n    return dirMetaToStatuses(dirMeta);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
      "extendedDetails": {}
    },
    "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-15621 S3Guard: Implement time-based (TTL) expiry for Authoritative Directory Listing. Contributed by Gabor Bota\n",
      "commitDate": "02/10/18 9:22 PM",
      "commitName": "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
      "commitAuthor": "Aaron Fabbri",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-15621 S3Guard: Implement time-based (TTL) expiry for Authoritative Directory Listing. Contributed by Gabor Bota\n",
          "commitDate": "02/10/18 9:22 PM",
          "commitName": "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
          "commitAuthor": "Aaron Fabbri",
          "commitDateOld": "17/08/18 10:15 AM",
          "commitNameOld": "d7232857d8d1e10cdac171acdc931187e45fd6be",
          "commitAuthorOld": "Aaron Fabbri",
          "daysBetweenCommits": 46.46,
          "commitsBetweenForRepo": 388,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n   public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n       List\u003cFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n-      boolean isAuthoritative) throws IOException {\n+      boolean isAuthoritative, ITtlTimeProvider timeProvider)\n+      throws IOException {\n \n     // Fast-path for NullMetadataStore\n     if (isNullMetadataStore(ms)) {\n       return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n     }\n \n     assertQualified(path);\n \n     if (dirMeta \u003d\u003d null) {\n       // The metadataStore had zero state for this directory\n       dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n           false);\n     }\n \n     Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n \n     // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n     // of metadata, we always use its metadata first.\n \n     // Since the authoritative case is already handled outside this function,\n     // we will basically start with the set of directory entries in the\n     // DirListingMetadata, and add any that only exist in the backingStatuses.\n \n     boolean changed \u003d false;\n     for (FileStatus s : backingStatuses) {\n       if (deleted.contains(s.getPath())) {\n         continue;\n       }\n \n       // Minor race condition here.  Multiple threads could add to this\n       // mutable DirListingMetadata.  Since it is backed by a\n       // ConcurrentHashMap, the last put() wins.\n       // More concerning is two threads racing on listStatus() and delete().\n       // Any FileSystem has similar race conditions, but we could persist\n       // a stale entry longer.  We could expose an atomic\n       // DirListingMetadata#putIfNotPresent()\n       boolean updated \u003d dirMeta.put(s);\n       changed \u003d changed || updated;\n     }\n \n     // If dirMeta is not authoritative, but isAuthoritative is true the\n     // directory metadata should be updated. Treat it as a change.\n     changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n \n     if (changed \u0026\u0026 isAuthoritative) {\n       dirMeta.setAuthoritative(true); // This is the full directory contents\n-      ms.put(dirMeta);\n+      S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n     }\n \n     return dirMetaToStatuses(dirMeta);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n      List\u003cFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n      boolean isAuthoritative, ITtlTimeProvider timeProvider)\n      throws IOException {\n\n    // Fast-path for NullMetadataStore\n    if (isNullMetadataStore(ms)) {\n      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n    }\n\n    assertQualified(path);\n\n    if (dirMeta \u003d\u003d null) {\n      // The metadataStore had zero state for this directory\n      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n          false);\n    }\n\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n\n    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n    // of metadata, we always use its metadata first.\n\n    // Since the authoritative case is already handled outside this function,\n    // we will basically start with the set of directory entries in the\n    // DirListingMetadata, and add any that only exist in the backingStatuses.\n\n    boolean changed \u003d false;\n    for (FileStatus s : backingStatuses) {\n      if (deleted.contains(s.getPath())) {\n        continue;\n      }\n\n      // Minor race condition here.  Multiple threads could add to this\n      // mutable DirListingMetadata.  Since it is backed by a\n      // ConcurrentHashMap, the last put() wins.\n      // More concerning is two threads racing on listStatus() and delete().\n      // Any FileSystem has similar race conditions, but we could persist\n      // a stale entry longer.  We could expose an atomic\n      // DirListingMetadata#putIfNotPresent()\n      boolean updated \u003d dirMeta.put(s);\n      changed \u003d changed || updated;\n    }\n\n    // If dirMeta is not authoritative, but isAuthoritative is true the\n    // directory metadata should be updated. Treat it as a change.\n    changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n\n    if (changed \u0026\u0026 isAuthoritative) {\n      dirMeta.setAuthoritative(true); // This is the full directory contents\n      S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n    }\n\n    return dirMetaToStatuses(dirMeta);\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
          "extendedDetails": {
            "oldValue": "[ms-MetadataStore, path-Path, backingStatuses-List\u003cFileStatus\u003e, dirMeta-DirListingMetadata, isAuthoritative-boolean]",
            "newValue": "[ms-MetadataStore, path-Path, backingStatuses-List\u003cFileStatus\u003e, dirMeta-DirListingMetadata, isAuthoritative-boolean, timeProvider-ITtlTimeProvider]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15621 S3Guard: Implement time-based (TTL) expiry for Authoritative Directory Listing. Contributed by Gabor Bota\n",
          "commitDate": "02/10/18 9:22 PM",
          "commitName": "046b8768af8a07a9e10ce43f538d6ac16e7fa5f3",
          "commitAuthor": "Aaron Fabbri",
          "commitDateOld": "17/08/18 10:15 AM",
          "commitNameOld": "d7232857d8d1e10cdac171acdc931187e45fd6be",
          "commitAuthorOld": "Aaron Fabbri",
          "daysBetweenCommits": 46.46,
          "commitsBetweenForRepo": 388,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,55 @@\n   public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n       List\u003cFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n-      boolean isAuthoritative) throws IOException {\n+      boolean isAuthoritative, ITtlTimeProvider timeProvider)\n+      throws IOException {\n \n     // Fast-path for NullMetadataStore\n     if (isNullMetadataStore(ms)) {\n       return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n     }\n \n     assertQualified(path);\n \n     if (dirMeta \u003d\u003d null) {\n       // The metadataStore had zero state for this directory\n       dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n           false);\n     }\n \n     Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n \n     // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n     // of metadata, we always use its metadata first.\n \n     // Since the authoritative case is already handled outside this function,\n     // we will basically start with the set of directory entries in the\n     // DirListingMetadata, and add any that only exist in the backingStatuses.\n \n     boolean changed \u003d false;\n     for (FileStatus s : backingStatuses) {\n       if (deleted.contains(s.getPath())) {\n         continue;\n       }\n \n       // Minor race condition here.  Multiple threads could add to this\n       // mutable DirListingMetadata.  Since it is backed by a\n       // ConcurrentHashMap, the last put() wins.\n       // More concerning is two threads racing on listStatus() and delete().\n       // Any FileSystem has similar race conditions, but we could persist\n       // a stale entry longer.  We could expose an atomic\n       // DirListingMetadata#putIfNotPresent()\n       boolean updated \u003d dirMeta.put(s);\n       changed \u003d changed || updated;\n     }\n \n     // If dirMeta is not authoritative, but isAuthoritative is true the\n     // directory metadata should be updated. Treat it as a change.\n     changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n \n     if (changed \u0026\u0026 isAuthoritative) {\n       dirMeta.setAuthoritative(true); // This is the full directory contents\n-      ms.put(dirMeta);\n+      S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n     }\n \n     return dirMetaToStatuses(dirMeta);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n      List\u003cFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n      boolean isAuthoritative, ITtlTimeProvider timeProvider)\n      throws IOException {\n\n    // Fast-path for NullMetadataStore\n    if (isNullMetadataStore(ms)) {\n      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n    }\n\n    assertQualified(path);\n\n    if (dirMeta \u003d\u003d null) {\n      // The metadataStore had zero state for this directory\n      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n          false);\n    }\n\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n\n    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n    // of metadata, we always use its metadata first.\n\n    // Since the authoritative case is already handled outside this function,\n    // we will basically start with the set of directory entries in the\n    // DirListingMetadata, and add any that only exist in the backingStatuses.\n\n    boolean changed \u003d false;\n    for (FileStatus s : backingStatuses) {\n      if (deleted.contains(s.getPath())) {\n        continue;\n      }\n\n      // Minor race condition here.  Multiple threads could add to this\n      // mutable DirListingMetadata.  Since it is backed by a\n      // ConcurrentHashMap, the last put() wins.\n      // More concerning is two threads racing on listStatus() and delete().\n      // Any FileSystem has similar race conditions, but we could persist\n      // a stale entry longer.  We could expose an atomic\n      // DirListingMetadata#putIfNotPresent()\n      boolean updated \u003d dirMeta.put(s);\n      changed \u003d changed || updated;\n    }\n\n    // If dirMeta is not authoritative, but isAuthoritative is true the\n    // directory metadata should be updated. Treat it as a change.\n    changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n\n    if (changed \u0026\u0026 isAuthoritative) {\n      dirMeta.setAuthoritative(true); // This is the full directory contents\n      S3Guard.putWithTtl(ms, dirMeta, timeProvider);\n    }\n\n    return dirMetaToStatuses(dirMeta);\n  }",
          "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
          "extendedDetails": {}
        }
      ]
    },
    "d7232857d8d1e10cdac171acdc931187e45fd6be": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14154 Persist isAuthoritative bit in DynamoDBMetaStore (Contributed by Gabor Bota)\n",
      "commitDate": "17/08/18 10:15 AM",
      "commitName": "d7232857d8d1e10cdac171acdc931187e45fd6be",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "15/01/18 3:33 AM",
      "commitNameOld": "a0c71dcc33ca7c5539d0ab61c4a276c4f39e5744",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 214.24,
      "commitsBetweenForRepo": 2166,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,54 @@\n   public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n       List\u003cFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n       boolean isAuthoritative) throws IOException {\n \n     // Fast-path for NullMetadataStore\n     if (isNullMetadataStore(ms)) {\n       return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n     }\n \n     assertQualified(path);\n \n     if (dirMeta \u003d\u003d null) {\n       // The metadataStore had zero state for this directory\n       dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n           false);\n     }\n \n     Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n \n     // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n     // of metadata, we always use its metadata first.\n \n     // Since the authoritative case is already handled outside this function,\n     // we will basically start with the set of directory entries in the\n     // DirListingMetadata, and add any that only exist in the backingStatuses.\n \n     boolean changed \u003d false;\n     for (FileStatus s : backingStatuses) {\n       if (deleted.contains(s.getPath())) {\n         continue;\n       }\n \n       // Minor race condition here.  Multiple threads could add to this\n       // mutable DirListingMetadata.  Since it is backed by a\n       // ConcurrentHashMap, the last put() wins.\n       // More concerning is two threads racing on listStatus() and delete().\n       // Any FileSystem has similar race conditions, but we could persist\n       // a stale entry longer.  We could expose an atomic\n       // DirListingMetadata#putIfNotPresent()\n       boolean updated \u003d dirMeta.put(s);\n       changed \u003d changed || updated;\n     }\n \n+    // If dirMeta is not authoritative, but isAuthoritative is true the\n+    // directory metadata should be updated. Treat it as a change.\n+    changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n+\n     if (changed \u0026\u0026 isAuthoritative) {\n       dirMeta.setAuthoritative(true); // This is the full directory contents\n       ms.put(dirMeta);\n     }\n \n     return dirMetaToStatuses(dirMeta);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n      List\u003cFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n      boolean isAuthoritative) throws IOException {\n\n    // Fast-path for NullMetadataStore\n    if (isNullMetadataStore(ms)) {\n      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n    }\n\n    assertQualified(path);\n\n    if (dirMeta \u003d\u003d null) {\n      // The metadataStore had zero state for this directory\n      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n          false);\n    }\n\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n\n    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n    // of metadata, we always use its metadata first.\n\n    // Since the authoritative case is already handled outside this function,\n    // we will basically start with the set of directory entries in the\n    // DirListingMetadata, and add any that only exist in the backingStatuses.\n\n    boolean changed \u003d false;\n    for (FileStatus s : backingStatuses) {\n      if (deleted.contains(s.getPath())) {\n        continue;\n      }\n\n      // Minor race condition here.  Multiple threads could add to this\n      // mutable DirListingMetadata.  Since it is backed by a\n      // ConcurrentHashMap, the last put() wins.\n      // More concerning is two threads racing on listStatus() and delete().\n      // Any FileSystem has similar race conditions, but we could persist\n      // a stale entry longer.  We could expose an atomic\n      // DirListingMetadata#putIfNotPresent()\n      boolean updated \u003d dirMeta.put(s);\n      changed \u003d changed || updated;\n    }\n\n    // If dirMeta is not authoritative, but isAuthoritative is true the\n    // directory metadata should be updated. Treat it as a change.\n    changed \u003d changed || (!dirMeta.isAuthoritative() \u0026\u0026 isAuthoritative);\n\n    if (changed \u0026\u0026 isAuthoritative) {\n      dirMeta.setAuthoritative(true); // This is the full directory contents\n      ms.put(dirMeta);\n    }\n\n    return dirMetaToStatuses(dirMeta);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,50 @@\n+  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n+      List\u003cFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n+      boolean isAuthoritative) throws IOException {\n+\n+    // Fast-path for NullMetadataStore\n+    if (isNullMetadataStore(ms)) {\n+      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n+    }\n+\n+    assertQualified(path);\n+\n+    if (dirMeta \u003d\u003d null) {\n+      // The metadataStore had zero state for this directory\n+      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n+          false);\n+    }\n+\n+    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n+\n+    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n+    // of metadata, we always use its metadata first.\n+\n+    // Since the authoritative case is already handled outside this function,\n+    // we will basically start with the set of directory entries in the\n+    // DirListingMetadata, and add any that only exist in the backingStatuses.\n+\n+    boolean changed \u003d false;\n+    for (FileStatus s : backingStatuses) {\n+      if (deleted.contains(s.getPath())) {\n+        continue;\n+      }\n+\n+      // Minor race condition here.  Multiple threads could add to this\n+      // mutable DirListingMetadata.  Since it is backed by a\n+      // ConcurrentHashMap, the last put() wins.\n+      // More concerning is two threads racing on listStatus() and delete().\n+      // Any FileSystem has similar race conditions, but we could persist\n+      // a stale entry longer.  We could expose an atomic\n+      // DirListingMetadata#putIfNotPresent()\n+      boolean updated \u003d dirMeta.put(s);\n+      changed \u003d changed || updated;\n+    }\n+\n+    if (changed \u0026\u0026 isAuthoritative) {\n+      dirMeta.setAuthoritative(true); // This is the full directory contents\n+      ms.put(dirMeta);\n+    }\n+\n+    return dirMetaToStatuses(dirMeta);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static FileStatus[] dirListingUnion(MetadataStore ms, Path path,\n      List\u003cFileStatus\u003e backingStatuses, DirListingMetadata dirMeta,\n      boolean isAuthoritative) throws IOException {\n\n    // Fast-path for NullMetadataStore\n    if (isNullMetadataStore(ms)) {\n      return backingStatuses.toArray(new FileStatus[backingStatuses.size()]);\n    }\n\n    assertQualified(path);\n\n    if (dirMeta \u003d\u003d null) {\n      // The metadataStore had zero state for this directory\n      dirMeta \u003d new DirListingMetadata(path, DirListingMetadata.EMPTY_DIR,\n          false);\n    }\n\n    Set\u003cPath\u003e deleted \u003d dirMeta.listTombstones();\n\n    // Since we treat the MetadataStore as a \"fresher\" or \"consistent\" view\n    // of metadata, we always use its metadata first.\n\n    // Since the authoritative case is already handled outside this function,\n    // we will basically start with the set of directory entries in the\n    // DirListingMetadata, and add any that only exist in the backingStatuses.\n\n    boolean changed \u003d false;\n    for (FileStatus s : backingStatuses) {\n      if (deleted.contains(s.getPath())) {\n        continue;\n      }\n\n      // Minor race condition here.  Multiple threads could add to this\n      // mutable DirListingMetadata.  Since it is backed by a\n      // ConcurrentHashMap, the last put() wins.\n      // More concerning is two threads racing on listStatus() and delete().\n      // Any FileSystem has similar race conditions, but we could persist\n      // a stale entry longer.  We could expose an atomic\n      // DirListingMetadata#putIfNotPresent()\n      boolean updated \u003d dirMeta.put(s);\n      changed \u003d changed || updated;\n    }\n\n    if (changed \u0026\u0026 isAuthoritative) {\n      dirMeta.setAuthoritative(true); // This is the full directory contents\n      ms.put(dirMeta);\n    }\n\n    return dirMetaToStatuses(dirMeta);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/S3Guard.java"
    }
  }
}