{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LocalityMulticastAMRMProxyPolicy.java",
  "functionName": "splitIndividualAny",
  "functionId": "splitIndividualAny___originalResourceRequest-ResourceRequest__targetSubclusters-Set__SubClusterId____allocationBookkeeper-AllocationBookkeeper",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
  "functionStartLine": 322,
  "functionEndLine": 378,
  "numCommitsSeen": 11,
  "timeTaken": 2499,
  "changeHistory": [
    "99948565cb5d5706241d7a8fc591e1617c499e03",
    "1c5c2b5dde6f2cffc587ca8f79a18828e1b1faf9",
    "13fcfb3d46ee7a0d606b4bb221d1cd66ef2a5a7c",
    "8623644f4599f51d34ba79c4c1453b3997205d8f",
    "1dadd0b45a6a605da72eb304808edb49fc66da45"
  ],
  "changeHistoryShort": {
    "99948565cb5d5706241d7a8fc591e1617c499e03": "Ybodychange",
    "1c5c2b5dde6f2cffc587ca8f79a18828e1b1faf9": "Ybodychange",
    "13fcfb3d46ee7a0d606b4bb221d1cd66ef2a5a7c": "Ymultichange(Yexceptionschange,Ybodychange)",
    "8623644f4599f51d34ba79c4c1453b3997205d8f": "Ybodychange",
    "1dadd0b45a6a605da72eb304808edb49fc66da45": "Yintroduced"
  },
  "changeHistoryDetails": {
    "99948565cb5d5706241d7a8fc591e1617c499e03": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8412. Move ResourceRequest.clone logic everywhere into a proper API. Contributed by Botong Huang.\n",
      "commitDate": "21/06/18 6:24 PM",
      "commitName": "99948565cb5d5706241d7a8fc591e1617c499e03",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "24/10/17 10:39 AM",
      "commitNameOld": "1c5c2b5dde6f2cffc587ca8f79a18828e1b1faf9",
      "commitAuthorOld": "Carlo Curino",
      "daysBetweenCommits": 240.32,
      "commitsBetweenForRepo": 2287,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,57 @@\n   private void splitIndividualAny(ResourceRequest originalResourceRequest,\n       Set\u003cSubClusterId\u003e targetSubclusters,\n       AllocationBookkeeper allocationBookkeeper) throws YarnException {\n \n     long allocationId \u003d originalResourceRequest.getAllocationRequestId();\n     int numContainer \u003d originalResourceRequest.getNumContainers();\n \n     // If the ANY request has 0 containers to begin with we must forward it to\n     // any RM we have previously contacted (this might be the user way\n     // to cancel a previous request).\n     if (numContainer \u003d\u003d 0) {\n       for (SubClusterId targetId : headroom.keySet()) {\n         allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n       }\n       return;\n     }\n \n     // List preserves iteration order\n     List\u003cSubClusterId\u003e targetSCs \u003d new ArrayList\u003c\u003e(targetSubclusters);\n \n     // Compute the distribution weights\n     ArrayList\u003cFloat\u003e weightsList \u003d new ArrayList\u003c\u003e();\n     for (SubClusterId targetId : targetSCs) {\n       // If ANY is associated with localized asks, split based on their ratio\n       if (allocationBookkeeper.getSubClustersForId(allocationId) !\u003d null) {\n         weightsList.add(getLocalityBasedWeighting(allocationId, targetId,\n             allocationBookkeeper));\n       } else {\n         // split ANY based on load and policy configuration\n         float headroomWeighting \u003d\n             getHeadroomWeighting(targetId, allocationBookkeeper);\n         float policyWeighting \u003d\n             getPolicyConfigWeighting(targetId, allocationBookkeeper);\n         // hrAlpha controls how much headroom influencing decision\n         weightsList\n             .add(hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n       }\n     }\n \n     // Compute the integer container counts for each sub-cluster\n     ArrayList\u003cInteger\u003e containerNums \u003d\n         computeIntegerAssignment(numContainer, weightsList);\n     int i \u003d 0;\n     for (SubClusterId targetId : targetSCs) {\n       // if the calculated request is non-empty add it to the answer\n       if (containerNums.get(i) \u003e 0) {\n-        ResourceRequest out \u003d\n-            ResourceRequest.newInstance(originalResourceRequest.getPriority(),\n-                originalResourceRequest.getResourceName(),\n-                originalResourceRequest.getCapability(),\n-                originalResourceRequest.getNumContainers(),\n-                originalResourceRequest.getRelaxLocality(),\n-                originalResourceRequest.getNodeLabelExpression(),\n-                originalResourceRequest.getExecutionTypeRequest());\n-        out.setAllocationRequestId(allocationId);\n+        ResourceRequest out \u003d ResourceRequest.clone(originalResourceRequest);\n         out.setNumContainers(containerNums.get(i));\n         if (ResourceRequest.isAnyLocation(out.getResourceName())) {\n           allocationBookkeeper.addAnyRR(targetId, out);\n         } else {\n           allocationBookkeeper.addRackRR(targetId, out);\n         }\n       }\n       i++;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void splitIndividualAny(ResourceRequest originalResourceRequest,\n      Set\u003cSubClusterId\u003e targetSubclusters,\n      AllocationBookkeeper allocationBookkeeper) throws YarnException {\n\n    long allocationId \u003d originalResourceRequest.getAllocationRequestId();\n    int numContainer \u003d originalResourceRequest.getNumContainers();\n\n    // If the ANY request has 0 containers to begin with we must forward it to\n    // any RM we have previously contacted (this might be the user way\n    // to cancel a previous request).\n    if (numContainer \u003d\u003d 0) {\n      for (SubClusterId targetId : headroom.keySet()) {\n        allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n      }\n      return;\n    }\n\n    // List preserves iteration order\n    List\u003cSubClusterId\u003e targetSCs \u003d new ArrayList\u003c\u003e(targetSubclusters);\n\n    // Compute the distribution weights\n    ArrayList\u003cFloat\u003e weightsList \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId targetId : targetSCs) {\n      // If ANY is associated with localized asks, split based on their ratio\n      if (allocationBookkeeper.getSubClustersForId(allocationId) !\u003d null) {\n        weightsList.add(getLocalityBasedWeighting(allocationId, targetId,\n            allocationBookkeeper));\n      } else {\n        // split ANY based on load and policy configuration\n        float headroomWeighting \u003d\n            getHeadroomWeighting(targetId, allocationBookkeeper);\n        float policyWeighting \u003d\n            getPolicyConfigWeighting(targetId, allocationBookkeeper);\n        // hrAlpha controls how much headroom influencing decision\n        weightsList\n            .add(hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n      }\n    }\n\n    // Compute the integer container counts for each sub-cluster\n    ArrayList\u003cInteger\u003e containerNums \u003d\n        computeIntegerAssignment(numContainer, weightsList);\n    int i \u003d 0;\n    for (SubClusterId targetId : targetSCs) {\n      // if the calculated request is non-empty add it to the answer\n      if (containerNums.get(i) \u003e 0) {\n        ResourceRequest out \u003d ResourceRequest.clone(originalResourceRequest);\n        out.setNumContainers(containerNums.get(i));\n        if (ResourceRequest.isAnyLocation(out.getResourceName())) {\n          allocationBookkeeper.addAnyRR(targetId, out);\n        } else {\n          allocationBookkeeper.addRackRR(targetId, out);\n        }\n      }\n      i++;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
      "extendedDetails": {}
    },
    "1c5c2b5dde6f2cffc587ca8f79a18828e1b1faf9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7339. LocalityMulticastAMRMProxyPolicy should handle cancel request properly. (Botong Huang via curino)\n",
      "commitDate": "24/10/17 10:39 AM",
      "commitName": "1c5c2b5dde6f2cffc587ca8f79a18828e1b1faf9",
      "commitAuthor": "Carlo Curino",
      "commitDateOld": "12/10/17 10:38 AM",
      "commitNameOld": "13fcfb3d46ee7a0d606b4bb221d1cd66ef2a5a7c",
      "commitAuthorOld": "Carlo Curino",
      "daysBetweenCommits": 12.0,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,65 @@\n   private void splitIndividualAny(ResourceRequest originalResourceRequest,\n       Set\u003cSubClusterId\u003e targetSubclusters,\n       AllocationBookkeeper allocationBookkeeper) throws YarnException {\n \n     long allocationId \u003d originalResourceRequest.getAllocationRequestId();\n     int numContainer \u003d originalResourceRequest.getNumContainers();\n \n     // If the ANY request has 0 containers to begin with we must forward it to\n     // any RM we have previously contacted (this might be the user way\n     // to cancel a previous request).\n     if (numContainer \u003d\u003d 0) {\n-      for (SubClusterId targetId : targetSubclusters) {\n-        if (headroom.containsKey(targetId)) {\n-          allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n-        }\n+      for (SubClusterId targetId : headroom.keySet()) {\n+        allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n       }\n       return;\n     }\n \n     // List preserves iteration order\n     List\u003cSubClusterId\u003e targetSCs \u003d new ArrayList\u003c\u003e(targetSubclusters);\n \n     // Compute the distribution weights\n     ArrayList\u003cFloat\u003e weightsList \u003d new ArrayList\u003c\u003e();\n     for (SubClusterId targetId : targetSCs) {\n       // If ANY is associated with localized asks, split based on their ratio\n       if (allocationBookkeeper.getSubClustersForId(allocationId) !\u003d null) {\n         weightsList.add(getLocalityBasedWeighting(allocationId, targetId,\n             allocationBookkeeper));\n       } else {\n         // split ANY based on load and policy configuration\n         float headroomWeighting \u003d\n             getHeadroomWeighting(targetId, allocationBookkeeper);\n         float policyWeighting \u003d\n             getPolicyConfigWeighting(targetId, allocationBookkeeper);\n         // hrAlpha controls how much headroom influencing decision\n         weightsList\n             .add(hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n       }\n     }\n \n     // Compute the integer container counts for each sub-cluster\n     ArrayList\u003cInteger\u003e containerNums \u003d\n         computeIntegerAssignment(numContainer, weightsList);\n     int i \u003d 0;\n     for (SubClusterId targetId : targetSCs) {\n       // if the calculated request is non-empty add it to the answer\n       if (containerNums.get(i) \u003e 0) {\n         ResourceRequest out \u003d\n             ResourceRequest.newInstance(originalResourceRequest.getPriority(),\n                 originalResourceRequest.getResourceName(),\n                 originalResourceRequest.getCapability(),\n                 originalResourceRequest.getNumContainers(),\n                 originalResourceRequest.getRelaxLocality(),\n                 originalResourceRequest.getNodeLabelExpression(),\n                 originalResourceRequest.getExecutionTypeRequest());\n         out.setAllocationRequestId(allocationId);\n         out.setNumContainers(containerNums.get(i));\n         if (ResourceRequest.isAnyLocation(out.getResourceName())) {\n           allocationBookkeeper.addAnyRR(targetId, out);\n         } else {\n           allocationBookkeeper.addRackRR(targetId, out);\n         }\n       }\n       i++;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void splitIndividualAny(ResourceRequest originalResourceRequest,\n      Set\u003cSubClusterId\u003e targetSubclusters,\n      AllocationBookkeeper allocationBookkeeper) throws YarnException {\n\n    long allocationId \u003d originalResourceRequest.getAllocationRequestId();\n    int numContainer \u003d originalResourceRequest.getNumContainers();\n\n    // If the ANY request has 0 containers to begin with we must forward it to\n    // any RM we have previously contacted (this might be the user way\n    // to cancel a previous request).\n    if (numContainer \u003d\u003d 0) {\n      for (SubClusterId targetId : headroom.keySet()) {\n        allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n      }\n      return;\n    }\n\n    // List preserves iteration order\n    List\u003cSubClusterId\u003e targetSCs \u003d new ArrayList\u003c\u003e(targetSubclusters);\n\n    // Compute the distribution weights\n    ArrayList\u003cFloat\u003e weightsList \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId targetId : targetSCs) {\n      // If ANY is associated with localized asks, split based on their ratio\n      if (allocationBookkeeper.getSubClustersForId(allocationId) !\u003d null) {\n        weightsList.add(getLocalityBasedWeighting(allocationId, targetId,\n            allocationBookkeeper));\n      } else {\n        // split ANY based on load and policy configuration\n        float headroomWeighting \u003d\n            getHeadroomWeighting(targetId, allocationBookkeeper);\n        float policyWeighting \u003d\n            getPolicyConfigWeighting(targetId, allocationBookkeeper);\n        // hrAlpha controls how much headroom influencing decision\n        weightsList\n            .add(hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n      }\n    }\n\n    // Compute the integer container counts for each sub-cluster\n    ArrayList\u003cInteger\u003e containerNums \u003d\n        computeIntegerAssignment(numContainer, weightsList);\n    int i \u003d 0;\n    for (SubClusterId targetId : targetSCs) {\n      // if the calculated request is non-empty add it to the answer\n      if (containerNums.get(i) \u003e 0) {\n        ResourceRequest out \u003d\n            ResourceRequest.newInstance(originalResourceRequest.getPriority(),\n                originalResourceRequest.getResourceName(),\n                originalResourceRequest.getCapability(),\n                originalResourceRequest.getNumContainers(),\n                originalResourceRequest.getRelaxLocality(),\n                originalResourceRequest.getNodeLabelExpression(),\n                originalResourceRequest.getExecutionTypeRequest());\n        out.setAllocationRequestId(allocationId);\n        out.setNumContainers(containerNums.get(i));\n        if (ResourceRequest.isAnyLocation(out.getResourceName())) {\n          allocationBookkeeper.addAnyRR(targetId, out);\n        } else {\n          allocationBookkeeper.addRackRR(targetId, out);\n        }\n      }\n      i++;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
      "extendedDetails": {}
    },
    "13fcfb3d46ee7a0d606b4bb221d1cd66ef2a5a7c": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-7317. Fix overallocation resulted from ceiling in LocalityMulticastAMRMProxyPolicy. (contributed by Botong Huang via curino)\n",
      "commitDate": "12/10/17 10:38 AM",
      "commitName": "13fcfb3d46ee7a0d606b4bb221d1cd66ef2a5a7c",
      "commitAuthor": "Carlo Curino",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-7317. Fix overallocation resulted from ceiling in LocalityMulticastAMRMProxyPolicy. (contributed by Botong Huang via curino)\n",
          "commitDate": "12/10/17 10:38 AM",
          "commitName": "13fcfb3d46ee7a0d606b4bb221d1cd66ef2a5a7c",
          "commitAuthor": "Carlo Curino",
          "commitDateOld": "01/08/17 5:28 PM",
          "commitNameOld": "1c64e1709b627846f29dc2fe6d637f074de8b403",
          "commitAuthorOld": "Carlo Curino",
          "daysBetweenCommits": 71.72,
          "commitsBetweenForRepo": 652,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,67 @@\n   private void splitIndividualAny(ResourceRequest originalResourceRequest,\n       Set\u003cSubClusterId\u003e targetSubclusters,\n-      AllocationBookkeeper allocationBookkeeper) {\n+      AllocationBookkeeper allocationBookkeeper) throws YarnException {\n \n     long allocationId \u003d originalResourceRequest.getAllocationRequestId();\n+    int numContainer \u003d originalResourceRequest.getNumContainers();\n \n-    for (SubClusterId targetId : targetSubclusters) {\n-      float numContainer \u003d originalResourceRequest.getNumContainers();\n-\n-      // If the ANY request has 0 containers to begin with we must forward it to\n-      // any RM we have previously contacted (this might be the user way\n-      // to cancel a previous request).\n-      if (numContainer \u003d\u003d 0 \u0026\u0026 headroom.containsKey(targetId)) {\n-        allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n+    // If the ANY request has 0 containers to begin with we must forward it to\n+    // any RM we have previously contacted (this might be the user way\n+    // to cancel a previous request).\n+    if (numContainer \u003d\u003d 0) {\n+      for (SubClusterId targetId : targetSubclusters) {\n+        if (headroom.containsKey(targetId)) {\n+          allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n+        }\n       }\n+      return;\n+    }\n \n+    // List preserves iteration order\n+    List\u003cSubClusterId\u003e targetSCs \u003d new ArrayList\u003c\u003e(targetSubclusters);\n+\n+    // Compute the distribution weights\n+    ArrayList\u003cFloat\u003e weightsList \u003d new ArrayList\u003c\u003e();\n+    for (SubClusterId targetId : targetSCs) {\n       // If ANY is associated with localized asks, split based on their ratio\n       if (allocationBookkeeper.getSubClustersForId(allocationId) !\u003d null) {\n-        float localityBasedWeight \u003d getLocalityBasedWeighting(allocationId,\n-            targetId, allocationBookkeeper);\n-        numContainer \u003d numContainer * localityBasedWeight;\n+        weightsList.add(getLocalityBasedWeighting(allocationId, targetId,\n+            allocationBookkeeper));\n       } else {\n         // split ANY based on load and policy configuration\n         float headroomWeighting \u003d\n             getHeadroomWeighting(targetId, allocationBookkeeper);\n         float policyWeighting \u003d\n             getPolicyConfigWeighting(targetId, allocationBookkeeper);\n         // hrAlpha controls how much headroom influencing decision\n-        numContainer \u003d numContainer\n-            * (hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n+        weightsList\n+            .add(hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n       }\n+    }\n \n+    // Compute the integer container counts for each sub-cluster\n+    ArrayList\u003cInteger\u003e containerNums \u003d\n+        computeIntegerAssignment(numContainer, weightsList);\n+    int i \u003d 0;\n+    for (SubClusterId targetId : targetSCs) {\n       // if the calculated request is non-empty add it to the answer\n-      if (numContainer \u003e 0) {\n+      if (containerNums.get(i) \u003e 0) {\n         ResourceRequest out \u003d\n             ResourceRequest.newInstance(originalResourceRequest.getPriority(),\n                 originalResourceRequest.getResourceName(),\n                 originalResourceRequest.getCapability(),\n                 originalResourceRequest.getNumContainers(),\n                 originalResourceRequest.getRelaxLocality(),\n                 originalResourceRequest.getNodeLabelExpression(),\n                 originalResourceRequest.getExecutionTypeRequest());\n         out.setAllocationRequestId(allocationId);\n-        out.setNumContainers((int) Math.ceil(numContainer));\n+        out.setNumContainers(containerNums.get(i));\n         if (ResourceRequest.isAnyLocation(out.getResourceName())) {\n           allocationBookkeeper.addAnyRR(targetId, out);\n         } else {\n           allocationBookkeeper.addRackRR(targetId, out);\n         }\n       }\n+      i++;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void splitIndividualAny(ResourceRequest originalResourceRequest,\n      Set\u003cSubClusterId\u003e targetSubclusters,\n      AllocationBookkeeper allocationBookkeeper) throws YarnException {\n\n    long allocationId \u003d originalResourceRequest.getAllocationRequestId();\n    int numContainer \u003d originalResourceRequest.getNumContainers();\n\n    // If the ANY request has 0 containers to begin with we must forward it to\n    // any RM we have previously contacted (this might be the user way\n    // to cancel a previous request).\n    if (numContainer \u003d\u003d 0) {\n      for (SubClusterId targetId : targetSubclusters) {\n        if (headroom.containsKey(targetId)) {\n          allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n        }\n      }\n      return;\n    }\n\n    // List preserves iteration order\n    List\u003cSubClusterId\u003e targetSCs \u003d new ArrayList\u003c\u003e(targetSubclusters);\n\n    // Compute the distribution weights\n    ArrayList\u003cFloat\u003e weightsList \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId targetId : targetSCs) {\n      // If ANY is associated with localized asks, split based on their ratio\n      if (allocationBookkeeper.getSubClustersForId(allocationId) !\u003d null) {\n        weightsList.add(getLocalityBasedWeighting(allocationId, targetId,\n            allocationBookkeeper));\n      } else {\n        // split ANY based on load and policy configuration\n        float headroomWeighting \u003d\n            getHeadroomWeighting(targetId, allocationBookkeeper);\n        float policyWeighting \u003d\n            getPolicyConfigWeighting(targetId, allocationBookkeeper);\n        // hrAlpha controls how much headroom influencing decision\n        weightsList\n            .add(hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n      }\n    }\n\n    // Compute the integer container counts for each sub-cluster\n    ArrayList\u003cInteger\u003e containerNums \u003d\n        computeIntegerAssignment(numContainer, weightsList);\n    int i \u003d 0;\n    for (SubClusterId targetId : targetSCs) {\n      // if the calculated request is non-empty add it to the answer\n      if (containerNums.get(i) \u003e 0) {\n        ResourceRequest out \u003d\n            ResourceRequest.newInstance(originalResourceRequest.getPriority(),\n                originalResourceRequest.getResourceName(),\n                originalResourceRequest.getCapability(),\n                originalResourceRequest.getNumContainers(),\n                originalResourceRequest.getRelaxLocality(),\n                originalResourceRequest.getNodeLabelExpression(),\n                originalResourceRequest.getExecutionTypeRequest());\n        out.setAllocationRequestId(allocationId);\n        out.setNumContainers(containerNums.get(i));\n        if (ResourceRequest.isAnyLocation(out.getResourceName())) {\n          allocationBookkeeper.addAnyRR(targetId, out);\n        } else {\n          allocationBookkeeper.addRackRR(targetId, out);\n        }\n      }\n      i++;\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[YarnException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7317. Fix overallocation resulted from ceiling in LocalityMulticastAMRMProxyPolicy. (contributed by Botong Huang via curino)\n",
          "commitDate": "12/10/17 10:38 AM",
          "commitName": "13fcfb3d46ee7a0d606b4bb221d1cd66ef2a5a7c",
          "commitAuthor": "Carlo Curino",
          "commitDateOld": "01/08/17 5:28 PM",
          "commitNameOld": "1c64e1709b627846f29dc2fe6d637f074de8b403",
          "commitAuthorOld": "Carlo Curino",
          "daysBetweenCommits": 71.72,
          "commitsBetweenForRepo": 652,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,52 +1,67 @@\n   private void splitIndividualAny(ResourceRequest originalResourceRequest,\n       Set\u003cSubClusterId\u003e targetSubclusters,\n-      AllocationBookkeeper allocationBookkeeper) {\n+      AllocationBookkeeper allocationBookkeeper) throws YarnException {\n \n     long allocationId \u003d originalResourceRequest.getAllocationRequestId();\n+    int numContainer \u003d originalResourceRequest.getNumContainers();\n \n-    for (SubClusterId targetId : targetSubclusters) {\n-      float numContainer \u003d originalResourceRequest.getNumContainers();\n-\n-      // If the ANY request has 0 containers to begin with we must forward it to\n-      // any RM we have previously contacted (this might be the user way\n-      // to cancel a previous request).\n-      if (numContainer \u003d\u003d 0 \u0026\u0026 headroom.containsKey(targetId)) {\n-        allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n+    // If the ANY request has 0 containers to begin with we must forward it to\n+    // any RM we have previously contacted (this might be the user way\n+    // to cancel a previous request).\n+    if (numContainer \u003d\u003d 0) {\n+      for (SubClusterId targetId : targetSubclusters) {\n+        if (headroom.containsKey(targetId)) {\n+          allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n+        }\n       }\n+      return;\n+    }\n \n+    // List preserves iteration order\n+    List\u003cSubClusterId\u003e targetSCs \u003d new ArrayList\u003c\u003e(targetSubclusters);\n+\n+    // Compute the distribution weights\n+    ArrayList\u003cFloat\u003e weightsList \u003d new ArrayList\u003c\u003e();\n+    for (SubClusterId targetId : targetSCs) {\n       // If ANY is associated with localized asks, split based on their ratio\n       if (allocationBookkeeper.getSubClustersForId(allocationId) !\u003d null) {\n-        float localityBasedWeight \u003d getLocalityBasedWeighting(allocationId,\n-            targetId, allocationBookkeeper);\n-        numContainer \u003d numContainer * localityBasedWeight;\n+        weightsList.add(getLocalityBasedWeighting(allocationId, targetId,\n+            allocationBookkeeper));\n       } else {\n         // split ANY based on load and policy configuration\n         float headroomWeighting \u003d\n             getHeadroomWeighting(targetId, allocationBookkeeper);\n         float policyWeighting \u003d\n             getPolicyConfigWeighting(targetId, allocationBookkeeper);\n         // hrAlpha controls how much headroom influencing decision\n-        numContainer \u003d numContainer\n-            * (hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n+        weightsList\n+            .add(hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n       }\n+    }\n \n+    // Compute the integer container counts for each sub-cluster\n+    ArrayList\u003cInteger\u003e containerNums \u003d\n+        computeIntegerAssignment(numContainer, weightsList);\n+    int i \u003d 0;\n+    for (SubClusterId targetId : targetSCs) {\n       // if the calculated request is non-empty add it to the answer\n-      if (numContainer \u003e 0) {\n+      if (containerNums.get(i) \u003e 0) {\n         ResourceRequest out \u003d\n             ResourceRequest.newInstance(originalResourceRequest.getPriority(),\n                 originalResourceRequest.getResourceName(),\n                 originalResourceRequest.getCapability(),\n                 originalResourceRequest.getNumContainers(),\n                 originalResourceRequest.getRelaxLocality(),\n                 originalResourceRequest.getNodeLabelExpression(),\n                 originalResourceRequest.getExecutionTypeRequest());\n         out.setAllocationRequestId(allocationId);\n-        out.setNumContainers((int) Math.ceil(numContainer));\n+        out.setNumContainers(containerNums.get(i));\n         if (ResourceRequest.isAnyLocation(out.getResourceName())) {\n           allocationBookkeeper.addAnyRR(targetId, out);\n         } else {\n           allocationBookkeeper.addRackRR(targetId, out);\n         }\n       }\n+      i++;\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void splitIndividualAny(ResourceRequest originalResourceRequest,\n      Set\u003cSubClusterId\u003e targetSubclusters,\n      AllocationBookkeeper allocationBookkeeper) throws YarnException {\n\n    long allocationId \u003d originalResourceRequest.getAllocationRequestId();\n    int numContainer \u003d originalResourceRequest.getNumContainers();\n\n    // If the ANY request has 0 containers to begin with we must forward it to\n    // any RM we have previously contacted (this might be the user way\n    // to cancel a previous request).\n    if (numContainer \u003d\u003d 0) {\n      for (SubClusterId targetId : targetSubclusters) {\n        if (headroom.containsKey(targetId)) {\n          allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n        }\n      }\n      return;\n    }\n\n    // List preserves iteration order\n    List\u003cSubClusterId\u003e targetSCs \u003d new ArrayList\u003c\u003e(targetSubclusters);\n\n    // Compute the distribution weights\n    ArrayList\u003cFloat\u003e weightsList \u003d new ArrayList\u003c\u003e();\n    for (SubClusterId targetId : targetSCs) {\n      // If ANY is associated with localized asks, split based on their ratio\n      if (allocationBookkeeper.getSubClustersForId(allocationId) !\u003d null) {\n        weightsList.add(getLocalityBasedWeighting(allocationId, targetId,\n            allocationBookkeeper));\n      } else {\n        // split ANY based on load and policy configuration\n        float headroomWeighting \u003d\n            getHeadroomWeighting(targetId, allocationBookkeeper);\n        float policyWeighting \u003d\n            getPolicyConfigWeighting(targetId, allocationBookkeeper);\n        // hrAlpha controls how much headroom influencing decision\n        weightsList\n            .add(hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n      }\n    }\n\n    // Compute the integer container counts for each sub-cluster\n    ArrayList\u003cInteger\u003e containerNums \u003d\n        computeIntegerAssignment(numContainer, weightsList);\n    int i \u003d 0;\n    for (SubClusterId targetId : targetSCs) {\n      // if the calculated request is non-empty add it to the answer\n      if (containerNums.get(i) \u003e 0) {\n        ResourceRequest out \u003d\n            ResourceRequest.newInstance(originalResourceRequest.getPriority(),\n                originalResourceRequest.getResourceName(),\n                originalResourceRequest.getCapability(),\n                originalResourceRequest.getNumContainers(),\n                originalResourceRequest.getRelaxLocality(),\n                originalResourceRequest.getNodeLabelExpression(),\n                originalResourceRequest.getExecutionTypeRequest());\n        out.setAllocationRequestId(allocationId);\n        out.setNumContainers(containerNums.get(i));\n        if (ResourceRequest.isAnyLocation(out.getResourceName())) {\n          allocationBookkeeper.addAnyRR(targetId, out);\n        } else {\n          allocationBookkeeper.addRackRR(targetId, out);\n        }\n      }\n      i++;\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
          "extendedDetails": {}
        }
      ]
    },
    "8623644f4599f51d34ba79c4c1453b3997205d8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6190. Validation and synchronization fixes in LocalityMulticastAMRMProxyPolicy. (Botong Huang via curino)\n\n(cherry picked from commit 5c486961cd3a175b122ef86275c99b72964f2c50)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "8623644f4599f51d34ba79c4c1453b3997205d8f",
      "commitAuthor": "Carlo Curino",
      "commitDateOld": "01/08/17 5:28 PM",
      "commitNameOld": "1dadd0b45a6a605da72eb304808edb49fc66da45",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   private void splitIndividualAny(ResourceRequest originalResourceRequest,\n       Set\u003cSubClusterId\u003e targetSubclusters,\n       AllocationBookkeeper allocationBookkeeper) {\n \n     long allocationId \u003d originalResourceRequest.getAllocationRequestId();\n \n     for (SubClusterId targetId : targetSubclusters) {\n       float numContainer \u003d originalResourceRequest.getNumContainers();\n \n       // If the ANY request has 0 containers to begin with we must forward it to\n       // any RM we have previously contacted (this might be the user way\n       // to cancel a previous request).\n       if (numContainer \u003d\u003d 0 \u0026\u0026 headroom.containsKey(targetId)) {\n         allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n       }\n \n       // If ANY is associated with localized asks, split based on their ratio\n       if (allocationBookkeeper.getSubClustersForId(allocationId) !\u003d null) {\n         float localityBasedWeight \u003d getLocalityBasedWeighting(allocationId,\n             targetId, allocationBookkeeper);\n         numContainer \u003d numContainer * localityBasedWeight;\n       } else {\n         // split ANY based on load and policy configuration\n         float headroomWeighting \u003d\n             getHeadroomWeighting(targetId, allocationBookkeeper);\n         float policyWeighting \u003d\n             getPolicyConfigWeighting(targetId, allocationBookkeeper);\n         // hrAlpha controls how much headroom influencing decision\n         numContainer \u003d numContainer\n             * (hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n       }\n \n       // if the calculated request is non-empty add it to the answer\n       if (numContainer \u003e 0) {\n         ResourceRequest out \u003d\n             ResourceRequest.newInstance(originalResourceRequest.getPriority(),\n                 originalResourceRequest.getResourceName(),\n                 originalResourceRequest.getCapability(),\n                 originalResourceRequest.getNumContainers(),\n                 originalResourceRequest.getRelaxLocality(),\n                 originalResourceRequest.getNodeLabelExpression(),\n                 originalResourceRequest.getExecutionTypeRequest());\n         out.setAllocationRequestId(allocationId);\n         out.setNumContainers((int) Math.ceil(numContainer));\n-        if (out.isAnyLocation(out.getResourceName())) {\n+        if (ResourceRequest.isAnyLocation(out.getResourceName())) {\n           allocationBookkeeper.addAnyRR(targetId, out);\n         } else {\n           allocationBookkeeper.addRackRR(targetId, out);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void splitIndividualAny(ResourceRequest originalResourceRequest,\n      Set\u003cSubClusterId\u003e targetSubclusters,\n      AllocationBookkeeper allocationBookkeeper) {\n\n    long allocationId \u003d originalResourceRequest.getAllocationRequestId();\n\n    for (SubClusterId targetId : targetSubclusters) {\n      float numContainer \u003d originalResourceRequest.getNumContainers();\n\n      // If the ANY request has 0 containers to begin with we must forward it to\n      // any RM we have previously contacted (this might be the user way\n      // to cancel a previous request).\n      if (numContainer \u003d\u003d 0 \u0026\u0026 headroom.containsKey(targetId)) {\n        allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n      }\n\n      // If ANY is associated with localized asks, split based on their ratio\n      if (allocationBookkeeper.getSubClustersForId(allocationId) !\u003d null) {\n        float localityBasedWeight \u003d getLocalityBasedWeighting(allocationId,\n            targetId, allocationBookkeeper);\n        numContainer \u003d numContainer * localityBasedWeight;\n      } else {\n        // split ANY based on load and policy configuration\n        float headroomWeighting \u003d\n            getHeadroomWeighting(targetId, allocationBookkeeper);\n        float policyWeighting \u003d\n            getPolicyConfigWeighting(targetId, allocationBookkeeper);\n        // hrAlpha controls how much headroom influencing decision\n        numContainer \u003d numContainer\n            * (hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n      }\n\n      // if the calculated request is non-empty add it to the answer\n      if (numContainer \u003e 0) {\n        ResourceRequest out \u003d\n            ResourceRequest.newInstance(originalResourceRequest.getPriority(),\n                originalResourceRequest.getResourceName(),\n                originalResourceRequest.getCapability(),\n                originalResourceRequest.getNumContainers(),\n                originalResourceRequest.getRelaxLocality(),\n                originalResourceRequest.getNodeLabelExpression(),\n                originalResourceRequest.getExecutionTypeRequest());\n        out.setAllocationRequestId(allocationId);\n        out.setNumContainers((int) Math.ceil(numContainer));\n        if (ResourceRequest.isAnyLocation(out.getResourceName())) {\n          allocationBookkeeper.addAnyRR(targetId, out);\n        } else {\n          allocationBookkeeper.addRackRR(targetId, out);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java",
      "extendedDetails": {}
    },
    "1dadd0b45a6a605da72eb304808edb49fc66da45": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5325. Stateless ARMRMProxy policies implementation. (Carlo Curino via Subru).\n\n(cherry picked from commit 11c5336522d3504598fb94eee288d54df73418c6)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "1dadd0b45a6a605da72eb304808edb49fc66da45",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,52 @@\n+  private void splitIndividualAny(ResourceRequest originalResourceRequest,\n+      Set\u003cSubClusterId\u003e targetSubclusters,\n+      AllocationBookkeeper allocationBookkeeper) {\n+\n+    long allocationId \u003d originalResourceRequest.getAllocationRequestId();\n+\n+    for (SubClusterId targetId : targetSubclusters) {\n+      float numContainer \u003d originalResourceRequest.getNumContainers();\n+\n+      // If the ANY request has 0 containers to begin with we must forward it to\n+      // any RM we have previously contacted (this might be the user way\n+      // to cancel a previous request).\n+      if (numContainer \u003d\u003d 0 \u0026\u0026 headroom.containsKey(targetId)) {\n+        allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n+      }\n+\n+      // If ANY is associated with localized asks, split based on their ratio\n+      if (allocationBookkeeper.getSubClustersForId(allocationId) !\u003d null) {\n+        float localityBasedWeight \u003d getLocalityBasedWeighting(allocationId,\n+            targetId, allocationBookkeeper);\n+        numContainer \u003d numContainer * localityBasedWeight;\n+      } else {\n+        // split ANY based on load and policy configuration\n+        float headroomWeighting \u003d\n+            getHeadroomWeighting(targetId, allocationBookkeeper);\n+        float policyWeighting \u003d\n+            getPolicyConfigWeighting(targetId, allocationBookkeeper);\n+        // hrAlpha controls how much headroom influencing decision\n+        numContainer \u003d numContainer\n+            * (hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n+      }\n+\n+      // if the calculated request is non-empty add it to the answer\n+      if (numContainer \u003e 0) {\n+        ResourceRequest out \u003d\n+            ResourceRequest.newInstance(originalResourceRequest.getPriority(),\n+                originalResourceRequest.getResourceName(),\n+                originalResourceRequest.getCapability(),\n+                originalResourceRequest.getNumContainers(),\n+                originalResourceRequest.getRelaxLocality(),\n+                originalResourceRequest.getNodeLabelExpression(),\n+                originalResourceRequest.getExecutionTypeRequest());\n+        out.setAllocationRequestId(allocationId);\n+        out.setNumContainers((int) Math.ceil(numContainer));\n+        if (out.isAnyLocation(out.getResourceName())) {\n+          allocationBookkeeper.addAnyRR(targetId, out);\n+        } else {\n+          allocationBookkeeper.addRackRR(targetId, out);\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void splitIndividualAny(ResourceRequest originalResourceRequest,\n      Set\u003cSubClusterId\u003e targetSubclusters,\n      AllocationBookkeeper allocationBookkeeper) {\n\n    long allocationId \u003d originalResourceRequest.getAllocationRequestId();\n\n    for (SubClusterId targetId : targetSubclusters) {\n      float numContainer \u003d originalResourceRequest.getNumContainers();\n\n      // If the ANY request has 0 containers to begin with we must forward it to\n      // any RM we have previously contacted (this might be the user way\n      // to cancel a previous request).\n      if (numContainer \u003d\u003d 0 \u0026\u0026 headroom.containsKey(targetId)) {\n        allocationBookkeeper.addAnyRR(targetId, originalResourceRequest);\n      }\n\n      // If ANY is associated with localized asks, split based on their ratio\n      if (allocationBookkeeper.getSubClustersForId(allocationId) !\u003d null) {\n        float localityBasedWeight \u003d getLocalityBasedWeighting(allocationId,\n            targetId, allocationBookkeeper);\n        numContainer \u003d numContainer * localityBasedWeight;\n      } else {\n        // split ANY based on load and policy configuration\n        float headroomWeighting \u003d\n            getHeadroomWeighting(targetId, allocationBookkeeper);\n        float policyWeighting \u003d\n            getPolicyConfigWeighting(targetId, allocationBookkeeper);\n        // hrAlpha controls how much headroom influencing decision\n        numContainer \u003d numContainer\n            * (hrAlpha * headroomWeighting + (1 - hrAlpha) * policyWeighting);\n      }\n\n      // if the calculated request is non-empty add it to the answer\n      if (numContainer \u003e 0) {\n        ResourceRequest out \u003d\n            ResourceRequest.newInstance(originalResourceRequest.getPriority(),\n                originalResourceRequest.getResourceName(),\n                originalResourceRequest.getCapability(),\n                originalResourceRequest.getNumContainers(),\n                originalResourceRequest.getRelaxLocality(),\n                originalResourceRequest.getNodeLabelExpression(),\n                originalResourceRequest.getExecutionTypeRequest());\n        out.setAllocationRequestId(allocationId);\n        out.setNumContainers((int) Math.ceil(numContainer));\n        if (out.isAnyLocation(out.getResourceName())) {\n          allocationBookkeeper.addAnyRR(targetId, out);\n        } else {\n          allocationBookkeeper.addRackRR(targetId, out);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/federation/policies/amrmproxy/LocalityMulticastAMRMProxyPolicy.java"
    }
  }
}