{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ManagedParentQueue.java",
  "functionName": "addChildQueue",
  "functionId": "addChildQueue___childQueue-CSQueue",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ManagedParentQueue.java",
  "functionStartLine": 255,
  "functionEndLine": 311,
  "numCommitsSeen": 8,
  "timeTaken": 3991,
  "changeHistory": [
    "450e5aa9dd49eae46a0e05151bbddc56083eafd5",
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df"
  ],
  "changeHistoryShort": {
    "450e5aa9dd49eae46a0e05151bbddc56083eafd5": "Ybodychange",
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Ymultichange(Yexceptionschange,Ybodychange)",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": "Yintroduced"
  },
  "changeHistoryDetails": {
    "450e5aa9dd49eae46a0e05151bbddc56083eafd5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10154. Addendum Patch which fixes below bugs\n\n1. RM fails to start when LeafQueueTemplate max capacity is not specified.\n2. Job stuck in ACCEPTED state with DominantResourceCalculator as Queue\n   Capacity is set to NaN during RM startup with clusterResource is zero.\n\nReviewed by Sunil G and Manikandan R.\n",
      "commitDate": "13/05/20 2:05 AM",
      "commitName": "450e5aa9dd49eae46a0e05151bbddc56083eafd5",
      "commitAuthor": "Prabhu Joseph",
      "commitDateOld": "17/04/20 6:21 AM",
      "commitNameOld": "2fe122e322afd35dfae6e45b3e7fdaddd20a411f",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 25.82,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,57 @@\n   public void addChildQueue(CSQueue childQueue)\n       throws SchedulerDynamicEditException, IOException {\n \n     writeLock.lock();\n     try {\n       if (childQueue \u003d\u003d null || !(childQueue instanceof AutoCreatedLeafQueue)) {\n         throw new SchedulerDynamicEditException(\n             \"Expected child queue to be an instance of AutoCreatedLeafQueue\");\n       }\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n       ManagedParentQueue parentQueue \u003d\n           (ManagedParentQueue) childQueue.getParent();\n \n       String leafQueuePath \u003d childQueue.getQueuePath();\n       int maxQueues \u003d conf.getAutoCreatedQueuesMaxChildQueuesLimit(\n           parentQueue.getQueuePath());\n \n       if (parentQueue.getChildQueues().size() \u003e\u003d maxQueues) {\n         throw new SchedulerDynamicEditException(\n             \"Cannot auto create leaf queue \" + leafQueuePath + \".Max Child \"\n                 + \"Queue limit exceeded which is configured as : \" + maxQueues\n                 + \" and number of child queues is : \" + parentQueue\n                 .getChildQueues().size());\n       }\n \n       if (shouldFailAutoCreationWhenGuaranteedCapacityExceeded) {\n         if (getLeafQueueTemplate().getQueueCapacities().getAbsoluteCapacity()\n             + parentQueue.sumOfChildAbsCapacities() \u003e parentQueue\n             .getAbsoluteCapacity()) {\n           throw new SchedulerDynamicEditException(\n               \"Cannot auto create leaf queue \" + leafQueuePath + \". Child \"\n                   + \"queues capacities have reached parent queue : \"\n                   + parentQueue.getQueuePath() + \"\u0027s guaranteed capacity\");\n         }\n       }\n \n       AutoCreatedLeafQueue leafQueue \u003d (AutoCreatedLeafQueue) childQueue;\n       super.addChildQueue(leafQueue);\n+\n+      /* Below is to avoid Setting Queue Capacity to NaN when ClusterResource\n+         is zero during RM Startup with DominantResourceCalculator */\n+      if (this.capacityConfigType.equals(\n+          CapacityConfigType.ABSOLUTE_RESOURCE)) {\n+        QueueCapacities queueCapacities \u003d\n+            getLeafQueueTemplate().getQueueCapacities();\n+        updateQueueCapacities(queueCapacities);\n+      }\n+\n       final AutoCreatedLeafQueueConfig initialLeafQueueTemplate \u003d\n           queueManagementPolicy.getInitialLeafQueueConfiguration(leafQueue);\n \n       leafQueue.reinitializeFromTemplate(initialLeafQueueTemplate);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void addChildQueue(CSQueue childQueue)\n      throws SchedulerDynamicEditException, IOException {\n\n    writeLock.lock();\n    try {\n      if (childQueue \u003d\u003d null || !(childQueue instanceof AutoCreatedLeafQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"Expected child queue to be an instance of AutoCreatedLeafQueue\");\n      }\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n      ManagedParentQueue parentQueue \u003d\n          (ManagedParentQueue) childQueue.getParent();\n\n      String leafQueuePath \u003d childQueue.getQueuePath();\n      int maxQueues \u003d conf.getAutoCreatedQueuesMaxChildQueuesLimit(\n          parentQueue.getQueuePath());\n\n      if (parentQueue.getChildQueues().size() \u003e\u003d maxQueues) {\n        throw new SchedulerDynamicEditException(\n            \"Cannot auto create leaf queue \" + leafQueuePath + \".Max Child \"\n                + \"Queue limit exceeded which is configured as : \" + maxQueues\n                + \" and number of child queues is : \" + parentQueue\n                .getChildQueues().size());\n      }\n\n      if (shouldFailAutoCreationWhenGuaranteedCapacityExceeded) {\n        if (getLeafQueueTemplate().getQueueCapacities().getAbsoluteCapacity()\n            + parentQueue.sumOfChildAbsCapacities() \u003e parentQueue\n            .getAbsoluteCapacity()) {\n          throw new SchedulerDynamicEditException(\n              \"Cannot auto create leaf queue \" + leafQueuePath + \". Child \"\n                  + \"queues capacities have reached parent queue : \"\n                  + parentQueue.getQueuePath() + \"\u0027s guaranteed capacity\");\n        }\n      }\n\n      AutoCreatedLeafQueue leafQueue \u003d (AutoCreatedLeafQueue) childQueue;\n      super.addChildQueue(leafQueue);\n\n      /* Below is to avoid Setting Queue Capacity to NaN when ClusterResource\n         is zero during RM Startup with DominantResourceCalculator */\n      if (this.capacityConfigType.equals(\n          CapacityConfigType.ABSOLUTE_RESOURCE)) {\n        QueueCapacities queueCapacities \u003d\n            getLeafQueueTemplate().getQueueCapacities();\n        updateQueueCapacities(queueCapacities);\n      }\n\n      final AutoCreatedLeafQueueConfig initialLeafQueueTemplate \u003d\n          queueManagementPolicy.getInitialLeafQueueConfiguration(leafQueue);\n\n      leafQueue.reinitializeFromTemplate(initialLeafQueueTemplate);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ManagedParentQueue.java",
      "extendedDetails": {}
    },
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "07/03/19 1:47 PM",
      "commitNameOld": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 383.56,
      "commitsBetweenForRepo": 2259,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   public void addChildQueue(CSQueue childQueue)\n       throws SchedulerDynamicEditException, IOException {\n \n     writeLock.lock();\n     try {\n       if (childQueue \u003d\u003d null || !(childQueue instanceof AutoCreatedLeafQueue)) {\n         throw new SchedulerDynamicEditException(\n             \"Expected child queue to be an instance of AutoCreatedLeafQueue\");\n       }\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n       ManagedParentQueue parentQueue \u003d\n           (ManagedParentQueue) childQueue.getParent();\n \n-      String leafQueueName \u003d childQueue.getQueueName();\n+      String leafQueuePath \u003d childQueue.getQueuePath();\n       int maxQueues \u003d conf.getAutoCreatedQueuesMaxChildQueuesLimit(\n           parentQueue.getQueuePath());\n \n       if (parentQueue.getChildQueues().size() \u003e\u003d maxQueues) {\n         throw new SchedulerDynamicEditException(\n-            \"Cannot auto create leaf queue \" + leafQueueName + \".Max Child \"\n+            \"Cannot auto create leaf queue \" + leafQueuePath + \".Max Child \"\n                 + \"Queue limit exceeded which is configured as : \" + maxQueues\n                 + \" and number of child queues is : \" + parentQueue\n                 .getChildQueues().size());\n       }\n \n       if (shouldFailAutoCreationWhenGuaranteedCapacityExceeded) {\n         if (getLeafQueueTemplate().getQueueCapacities().getAbsoluteCapacity()\n             + parentQueue.sumOfChildAbsCapacities() \u003e parentQueue\n             .getAbsoluteCapacity()) {\n           throw new SchedulerDynamicEditException(\n-              \"Cannot auto create leaf queue \" + leafQueueName + \". Child \"\n+              \"Cannot auto create leaf queue \" + leafQueuePath + \". Child \"\n                   + \"queues capacities have reached parent queue : \"\n                   + parentQueue.getQueuePath() + \"\u0027s guaranteed capacity\");\n         }\n       }\n \n       AutoCreatedLeafQueue leafQueue \u003d (AutoCreatedLeafQueue) childQueue;\n       super.addChildQueue(leafQueue);\n       final AutoCreatedLeafQueueConfig initialLeafQueueTemplate \u003d\n           queueManagementPolicy.getInitialLeafQueueConfiguration(leafQueue);\n \n       leafQueue.reinitializeFromTemplate(initialLeafQueueTemplate);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void addChildQueue(CSQueue childQueue)\n      throws SchedulerDynamicEditException, IOException {\n\n    writeLock.lock();\n    try {\n      if (childQueue \u003d\u003d null || !(childQueue instanceof AutoCreatedLeafQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"Expected child queue to be an instance of AutoCreatedLeafQueue\");\n      }\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n      ManagedParentQueue parentQueue \u003d\n          (ManagedParentQueue) childQueue.getParent();\n\n      String leafQueuePath \u003d childQueue.getQueuePath();\n      int maxQueues \u003d conf.getAutoCreatedQueuesMaxChildQueuesLimit(\n          parentQueue.getQueuePath());\n\n      if (parentQueue.getChildQueues().size() \u003e\u003d maxQueues) {\n        throw new SchedulerDynamicEditException(\n            \"Cannot auto create leaf queue \" + leafQueuePath + \".Max Child \"\n                + \"Queue limit exceeded which is configured as : \" + maxQueues\n                + \" and number of child queues is : \" + parentQueue\n                .getChildQueues().size());\n      }\n\n      if (shouldFailAutoCreationWhenGuaranteedCapacityExceeded) {\n        if (getLeafQueueTemplate().getQueueCapacities().getAbsoluteCapacity()\n            + parentQueue.sumOfChildAbsCapacities() \u003e parentQueue\n            .getAbsoluteCapacity()) {\n          throw new SchedulerDynamicEditException(\n              \"Cannot auto create leaf queue \" + leafQueuePath + \". Child \"\n                  + \"queues capacities have reached parent queue : \"\n                  + parentQueue.getQueuePath() + \"\u0027s guaranteed capacity\");\n        }\n      }\n\n      AutoCreatedLeafQueue leafQueue \u003d (AutoCreatedLeafQueue) childQueue;\n      super.addChildQueue(leafQueue);\n      final AutoCreatedLeafQueueConfig initialLeafQueueTemplate \u003d\n          queueManagementPolicy.getInitialLeafQueueConfiguration(leafQueue);\n\n      leafQueue.reinitializeFromTemplate(initialLeafQueueTemplate);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ManagedParentQueue.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "28/12/18 12:29 AM",
      "commitNameOld": "15fe1b34ddd134df1f413ca435a970fc34bae9f7",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 69.55,
      "commitsBetweenForRepo": 524,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   public void addChildQueue(CSQueue childQueue)\n       throws SchedulerDynamicEditException, IOException {\n-    try {\n-      writeLock.lock();\n \n+    writeLock.lock();\n+    try {\n       if (childQueue \u003d\u003d null || !(childQueue instanceof AutoCreatedLeafQueue)) {\n         throw new SchedulerDynamicEditException(\n             \"Expected child queue to be an instance of AutoCreatedLeafQueue\");\n       }\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n       ManagedParentQueue parentQueue \u003d\n           (ManagedParentQueue) childQueue.getParent();\n \n       String leafQueueName \u003d childQueue.getQueueName();\n       int maxQueues \u003d conf.getAutoCreatedQueuesMaxChildQueuesLimit(\n           parentQueue.getQueuePath());\n \n       if (parentQueue.getChildQueues().size() \u003e\u003d maxQueues) {\n         throw new SchedulerDynamicEditException(\n             \"Cannot auto create leaf queue \" + leafQueueName + \".Max Child \"\n                 + \"Queue limit exceeded which is configured as : \" + maxQueues\n                 + \" and number of child queues is : \" + parentQueue\n                 .getChildQueues().size());\n       }\n \n       if (shouldFailAutoCreationWhenGuaranteedCapacityExceeded) {\n         if (getLeafQueueTemplate().getQueueCapacities().getAbsoluteCapacity()\n             + parentQueue.sumOfChildAbsCapacities() \u003e parentQueue\n             .getAbsoluteCapacity()) {\n           throw new SchedulerDynamicEditException(\n               \"Cannot auto create leaf queue \" + leafQueueName + \". Child \"\n                   + \"queues capacities have reached parent queue : \"\n                   + parentQueue.getQueuePath() + \"\u0027s guaranteed capacity\");\n         }\n       }\n \n       AutoCreatedLeafQueue leafQueue \u003d (AutoCreatedLeafQueue) childQueue;\n       super.addChildQueue(leafQueue);\n       final AutoCreatedLeafQueueConfig initialLeafQueueTemplate \u003d\n           queueManagementPolicy.getInitialLeafQueueConfiguration(leafQueue);\n \n       leafQueue.reinitializeFromTemplate(initialLeafQueueTemplate);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void addChildQueue(CSQueue childQueue)\n      throws SchedulerDynamicEditException, IOException {\n\n    writeLock.lock();\n    try {\n      if (childQueue \u003d\u003d null || !(childQueue instanceof AutoCreatedLeafQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"Expected child queue to be an instance of AutoCreatedLeafQueue\");\n      }\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n      ManagedParentQueue parentQueue \u003d\n          (ManagedParentQueue) childQueue.getParent();\n\n      String leafQueueName \u003d childQueue.getQueueName();\n      int maxQueues \u003d conf.getAutoCreatedQueuesMaxChildQueuesLimit(\n          parentQueue.getQueuePath());\n\n      if (parentQueue.getChildQueues().size() \u003e\u003d maxQueues) {\n        throw new SchedulerDynamicEditException(\n            \"Cannot auto create leaf queue \" + leafQueueName + \".Max Child \"\n                + \"Queue limit exceeded which is configured as : \" + maxQueues\n                + \" and number of child queues is : \" + parentQueue\n                .getChildQueues().size());\n      }\n\n      if (shouldFailAutoCreationWhenGuaranteedCapacityExceeded) {\n        if (getLeafQueueTemplate().getQueueCapacities().getAbsoluteCapacity()\n            + parentQueue.sumOfChildAbsCapacities() \u003e parentQueue\n            .getAbsoluteCapacity()) {\n          throw new SchedulerDynamicEditException(\n              \"Cannot auto create leaf queue \" + leafQueueName + \". Child \"\n                  + \"queues capacities have reached parent queue : \"\n                  + parentQueue.getQueuePath() + \"\u0027s guaranteed capacity\");\n        }\n      }\n\n      AutoCreatedLeafQueue leafQueue \u003d (AutoCreatedLeafQueue) childQueue;\n      super.addChildQueue(leafQueue);\n      final AutoCreatedLeafQueueConfig initialLeafQueueTemplate \u003d\n          queueManagementPolicy.getInitialLeafQueueConfiguration(leafQueue);\n\n      leafQueue.reinitializeFromTemplate(initialLeafQueueTemplate);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ManagedParentQueue.java",
      "extendedDetails": {}
    },
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
          "commitDate": "08/12/17 3:10 PM",
          "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "16/11/17 11:25 AM",
          "commitNameOld": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 22.16,
          "commitsBetweenForRepo": 110,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,47 @@\n   public void addChildQueue(CSQueue childQueue)\n-      throws SchedulerDynamicEditException {\n+      throws SchedulerDynamicEditException, IOException {\n     try {\n       writeLock.lock();\n \n       if (childQueue \u003d\u003d null || !(childQueue instanceof AutoCreatedLeafQueue)) {\n         throw new SchedulerDynamicEditException(\n             \"Expected child queue to be an instance of AutoCreatedLeafQueue\");\n       }\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n       ManagedParentQueue parentQueue \u003d\n           (ManagedParentQueue) childQueue.getParent();\n \n       String leafQueueName \u003d childQueue.getQueueName();\n       int maxQueues \u003d conf.getAutoCreatedQueuesMaxChildQueuesLimit(\n           parentQueue.getQueuePath());\n \n       if (parentQueue.getChildQueues().size() \u003e\u003d maxQueues) {\n         throw new SchedulerDynamicEditException(\n             \"Cannot auto create leaf queue \" + leafQueueName + \".Max Child \"\n                 + \"Queue limit exceeded which is configured as : \" + maxQueues\n                 + \" and number of child queues is : \" + parentQueue\n                 .getChildQueues().size());\n       }\n \n       if (shouldFailAutoCreationWhenGuaranteedCapacityExceeded) {\n         if (getLeafQueueTemplate().getQueueCapacities().getAbsoluteCapacity()\n             + parentQueue.sumOfChildAbsCapacities() \u003e parentQueue\n             .getAbsoluteCapacity()) {\n           throw new SchedulerDynamicEditException(\n               \"Cannot auto create leaf queue \" + leafQueueName + \". Child \"\n                   + \"queues capacities have reached parent queue : \"\n-                  + parentQueue.getQueuePath() + \" guaranteed capacity\");\n+                  + parentQueue.getQueuePath() + \"\u0027s guaranteed capacity\");\n         }\n       }\n \n       AutoCreatedLeafQueue leafQueue \u003d (AutoCreatedLeafQueue) childQueue;\n       super.addChildQueue(leafQueue);\n-      //TODO - refresh policy queue after capacity management is added\n+      final AutoCreatedLeafQueueConfig initialLeafQueueTemplate \u003d\n+          queueManagementPolicy.getInitialLeafQueueConfiguration(leafQueue);\n \n+      leafQueue.reinitializeFromTemplate(initialLeafQueueTemplate);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void addChildQueue(CSQueue childQueue)\n      throws SchedulerDynamicEditException, IOException {\n    try {\n      writeLock.lock();\n\n      if (childQueue \u003d\u003d null || !(childQueue instanceof AutoCreatedLeafQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"Expected child queue to be an instance of AutoCreatedLeafQueue\");\n      }\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n      ManagedParentQueue parentQueue \u003d\n          (ManagedParentQueue) childQueue.getParent();\n\n      String leafQueueName \u003d childQueue.getQueueName();\n      int maxQueues \u003d conf.getAutoCreatedQueuesMaxChildQueuesLimit(\n          parentQueue.getQueuePath());\n\n      if (parentQueue.getChildQueues().size() \u003e\u003d maxQueues) {\n        throw new SchedulerDynamicEditException(\n            \"Cannot auto create leaf queue \" + leafQueueName + \".Max Child \"\n                + \"Queue limit exceeded which is configured as : \" + maxQueues\n                + \" and number of child queues is : \" + parentQueue\n                .getChildQueues().size());\n      }\n\n      if (shouldFailAutoCreationWhenGuaranteedCapacityExceeded) {\n        if (getLeafQueueTemplate().getQueueCapacities().getAbsoluteCapacity()\n            + parentQueue.sumOfChildAbsCapacities() \u003e parentQueue\n            .getAbsoluteCapacity()) {\n          throw new SchedulerDynamicEditException(\n              \"Cannot auto create leaf queue \" + leafQueueName + \". Child \"\n                  + \"queues capacities have reached parent queue : \"\n                  + parentQueue.getQueuePath() + \"\u0027s guaranteed capacity\");\n        }\n      }\n\n      AutoCreatedLeafQueue leafQueue \u003d (AutoCreatedLeafQueue) childQueue;\n      super.addChildQueue(leafQueue);\n      final AutoCreatedLeafQueueConfig initialLeafQueueTemplate \u003d\n          queueManagementPolicy.getInitialLeafQueueConfiguration(leafQueue);\n\n      leafQueue.reinitializeFromTemplate(initialLeafQueueTemplate);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ManagedParentQueue.java",
          "extendedDetails": {
            "oldValue": "[SchedulerDynamicEditException]",
            "newValue": "[SchedulerDynamicEditException, IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
          "commitDate": "08/12/17 3:10 PM",
          "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
          "commitAuthor": "Wangda Tan",
          "commitDateOld": "16/11/17 11:25 AM",
          "commitNameOld": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 22.16,
          "commitsBetweenForRepo": 110,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,47 @@\n   public void addChildQueue(CSQueue childQueue)\n-      throws SchedulerDynamicEditException {\n+      throws SchedulerDynamicEditException, IOException {\n     try {\n       writeLock.lock();\n \n       if (childQueue \u003d\u003d null || !(childQueue instanceof AutoCreatedLeafQueue)) {\n         throw new SchedulerDynamicEditException(\n             \"Expected child queue to be an instance of AutoCreatedLeafQueue\");\n       }\n \n       CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n       ManagedParentQueue parentQueue \u003d\n           (ManagedParentQueue) childQueue.getParent();\n \n       String leafQueueName \u003d childQueue.getQueueName();\n       int maxQueues \u003d conf.getAutoCreatedQueuesMaxChildQueuesLimit(\n           parentQueue.getQueuePath());\n \n       if (parentQueue.getChildQueues().size() \u003e\u003d maxQueues) {\n         throw new SchedulerDynamicEditException(\n             \"Cannot auto create leaf queue \" + leafQueueName + \".Max Child \"\n                 + \"Queue limit exceeded which is configured as : \" + maxQueues\n                 + \" and number of child queues is : \" + parentQueue\n                 .getChildQueues().size());\n       }\n \n       if (shouldFailAutoCreationWhenGuaranteedCapacityExceeded) {\n         if (getLeafQueueTemplate().getQueueCapacities().getAbsoluteCapacity()\n             + parentQueue.sumOfChildAbsCapacities() \u003e parentQueue\n             .getAbsoluteCapacity()) {\n           throw new SchedulerDynamicEditException(\n               \"Cannot auto create leaf queue \" + leafQueueName + \". Child \"\n                   + \"queues capacities have reached parent queue : \"\n-                  + parentQueue.getQueuePath() + \" guaranteed capacity\");\n+                  + parentQueue.getQueuePath() + \"\u0027s guaranteed capacity\");\n         }\n       }\n \n       AutoCreatedLeafQueue leafQueue \u003d (AutoCreatedLeafQueue) childQueue;\n       super.addChildQueue(leafQueue);\n-      //TODO - refresh policy queue after capacity management is added\n+      final AutoCreatedLeafQueueConfig initialLeafQueueTemplate \u003d\n+          queueManagementPolicy.getInitialLeafQueueConfiguration(leafQueue);\n \n+      leafQueue.reinitializeFromTemplate(initialLeafQueueTemplate);\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void addChildQueue(CSQueue childQueue)\n      throws SchedulerDynamicEditException, IOException {\n    try {\n      writeLock.lock();\n\n      if (childQueue \u003d\u003d null || !(childQueue instanceof AutoCreatedLeafQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"Expected child queue to be an instance of AutoCreatedLeafQueue\");\n      }\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n      ManagedParentQueue parentQueue \u003d\n          (ManagedParentQueue) childQueue.getParent();\n\n      String leafQueueName \u003d childQueue.getQueueName();\n      int maxQueues \u003d conf.getAutoCreatedQueuesMaxChildQueuesLimit(\n          parentQueue.getQueuePath());\n\n      if (parentQueue.getChildQueues().size() \u003e\u003d maxQueues) {\n        throw new SchedulerDynamicEditException(\n            \"Cannot auto create leaf queue \" + leafQueueName + \".Max Child \"\n                + \"Queue limit exceeded which is configured as : \" + maxQueues\n                + \" and number of child queues is : \" + parentQueue\n                .getChildQueues().size());\n      }\n\n      if (shouldFailAutoCreationWhenGuaranteedCapacityExceeded) {\n        if (getLeafQueueTemplate().getQueueCapacities().getAbsoluteCapacity()\n            + parentQueue.sumOfChildAbsCapacities() \u003e parentQueue\n            .getAbsoluteCapacity()) {\n          throw new SchedulerDynamicEditException(\n              \"Cannot auto create leaf queue \" + leafQueueName + \". Child \"\n                  + \"queues capacities have reached parent queue : \"\n                  + parentQueue.getQueuePath() + \"\u0027s guaranteed capacity\");\n        }\n      }\n\n      AutoCreatedLeafQueue leafQueue \u003d (AutoCreatedLeafQueue) childQueue;\n      super.addChildQueue(leafQueue);\n      final AutoCreatedLeafQueueConfig initialLeafQueueTemplate \u003d\n          queueManagementPolicy.getInitialLeafQueueConfiguration(leafQueue);\n\n      leafQueue.reinitializeFromTemplate(initialLeafQueueTemplate);\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ManagedParentQueue.java",
          "extendedDetails": {}
        }
      ]
    },
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7419. CapacityScheduler: Allow auto leaf queue creation after queue mapping. (Suma Shivaprasad via wangda)\n\nChange-Id: Ia1704bb8cb5070e5b180b5a85787d7b9ca57ebc6\n",
      "commitDate": "16/11/17 11:25 AM",
      "commitName": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,45 @@\n+  public void addChildQueue(CSQueue childQueue)\n+      throws SchedulerDynamicEditException {\n+    try {\n+      writeLock.lock();\n+\n+      if (childQueue \u003d\u003d null || !(childQueue instanceof AutoCreatedLeafQueue)) {\n+        throw new SchedulerDynamicEditException(\n+            \"Expected child queue to be an instance of AutoCreatedLeafQueue\");\n+      }\n+\n+      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n+      ManagedParentQueue parentQueue \u003d\n+          (ManagedParentQueue) childQueue.getParent();\n+\n+      String leafQueueName \u003d childQueue.getQueueName();\n+      int maxQueues \u003d conf.getAutoCreatedQueuesMaxChildQueuesLimit(\n+          parentQueue.getQueuePath());\n+\n+      if (parentQueue.getChildQueues().size() \u003e\u003d maxQueues) {\n+        throw new SchedulerDynamicEditException(\n+            \"Cannot auto create leaf queue \" + leafQueueName + \".Max Child \"\n+                + \"Queue limit exceeded which is configured as : \" + maxQueues\n+                + \" and number of child queues is : \" + parentQueue\n+                .getChildQueues().size());\n+      }\n+\n+      if (shouldFailAutoCreationWhenGuaranteedCapacityExceeded) {\n+        if (getLeafQueueTemplate().getQueueCapacities().getAbsoluteCapacity()\n+            + parentQueue.sumOfChildAbsCapacities() \u003e parentQueue\n+            .getAbsoluteCapacity()) {\n+          throw new SchedulerDynamicEditException(\n+              \"Cannot auto create leaf queue \" + leafQueueName + \". Child \"\n+                  + \"queues capacities have reached parent queue : \"\n+                  + parentQueue.getQueuePath() + \" guaranteed capacity\");\n+        }\n+      }\n+\n+      AutoCreatedLeafQueue leafQueue \u003d (AutoCreatedLeafQueue) childQueue;\n+      super.addChildQueue(leafQueue);\n+      //TODO - refresh policy queue after capacity management is added\n+\n+    } finally {\n+      writeLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void addChildQueue(CSQueue childQueue)\n      throws SchedulerDynamicEditException {\n    try {\n      writeLock.lock();\n\n      if (childQueue \u003d\u003d null || !(childQueue instanceof AutoCreatedLeafQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"Expected child queue to be an instance of AutoCreatedLeafQueue\");\n      }\n\n      CapacitySchedulerConfiguration conf \u003d csContext.getConfiguration();\n      ManagedParentQueue parentQueue \u003d\n          (ManagedParentQueue) childQueue.getParent();\n\n      String leafQueueName \u003d childQueue.getQueueName();\n      int maxQueues \u003d conf.getAutoCreatedQueuesMaxChildQueuesLimit(\n          parentQueue.getQueuePath());\n\n      if (parentQueue.getChildQueues().size() \u003e\u003d maxQueues) {\n        throw new SchedulerDynamicEditException(\n            \"Cannot auto create leaf queue \" + leafQueueName + \".Max Child \"\n                + \"Queue limit exceeded which is configured as : \" + maxQueues\n                + \" and number of child queues is : \" + parentQueue\n                .getChildQueues().size());\n      }\n\n      if (shouldFailAutoCreationWhenGuaranteedCapacityExceeded) {\n        if (getLeafQueueTemplate().getQueueCapacities().getAbsoluteCapacity()\n            + parentQueue.sumOfChildAbsCapacities() \u003e parentQueue\n            .getAbsoluteCapacity()) {\n          throw new SchedulerDynamicEditException(\n              \"Cannot auto create leaf queue \" + leafQueueName + \". Child \"\n                  + \"queues capacities have reached parent queue : \"\n                  + parentQueue.getQueuePath() + \" guaranteed capacity\");\n        }\n      }\n\n      AutoCreatedLeafQueue leafQueue \u003d (AutoCreatedLeafQueue) childQueue;\n      super.addChildQueue(leafQueue);\n      //TODO - refresh policy queue after capacity management is added\n\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/ManagedParentQueue.java"
    }
  }
}