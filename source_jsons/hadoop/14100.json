{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SegmentRecoveryComparator.java",
  "functionName": "compare",
  "functionId": "compare___a-Entry__AsyncLogger,PrepareRecoveryResponseProto____b-Entry__AsyncLogger,PrepareRecoveryResponseProto__",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/SegmentRecoveryComparator.java",
  "functionStartLine": 40,
  "functionEndLine": 90,
  "numCommitsSeen": 11,
  "timeTaken": 1753,
  "changeHistory": [
    "83c14fbd24353b5e882f065faec81e58449afed3",
    "1e68d4726b225fb4a62eb8d79a3160dd03059ccb",
    "74d4573a23db5586c6e47ff2277aa7c35237da34"
  ],
  "changeHistoryShort": {
    "83c14fbd24353b5e882f065faec81e58449afed3": "Ybodychange",
    "1e68d4726b225fb4a62eb8d79a3160dd03059ccb": "Ymultichange(Ymovefromfile,Ybodychange)",
    "74d4573a23db5586c6e47ff2277aa7c35237da34": "Yintroduced"
  },
  "changeHistoryDetails": {
    "83c14fbd24353b5e882f065faec81e58449afed3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3943. QJM: remove currently-unused md5sum field. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1386863 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/09/12 2:51 PM",
      "commitName": "83c14fbd24353b5e882f065faec81e58449afed3",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "27/08/12 12:55 PM",
      "commitNameOld": "1e68d4726b225fb4a62eb8d79a3160dd03059ccb",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 21.08,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,51 @@\n   public int compare(\n       Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e a,\n       Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e b) {\n     \n     PrepareRecoveryResponseProto r1 \u003d a.getValue();\n     PrepareRecoveryResponseProto r2 \u003d b.getValue();\n     \n     // A response that has data for a segment is always better than one\n     // that doesn\u0027t.\n     if (r1.hasSegmentState() !\u003d r2.hasSegmentState()) {\n       return Booleans.compare(r1.hasSegmentState(), r2.hasSegmentState());\n     }\n     \n     if (!r1.hasSegmentState()) {\n       // Neither has a segment, so neither can be used for recover.\n       // Call them equal.\n       return 0;\n     }\n     \n     // They both have a segment.\n     SegmentStateProto r1Seg \u003d r1.getSegmentState();\n     SegmentStateProto r2Seg \u003d r2.getSegmentState();\n     \n     Preconditions.checkArgument(r1Seg.getStartTxId() \u003d\u003d r2Seg.getStartTxId(),\n         \"Should only be called with responses for corresponding segments: \" +\n         \"%s and %s do not have the same start txid.\", r1, r2);\n \n     // If one is in-progress but the other is finalized,\n     // the finalized one is greater.\n     if (r1Seg.getIsInProgress() !\u003d r2Seg.getIsInProgress()) {\n       return Booleans.compare(!r1Seg.getIsInProgress(), !r2Seg.getIsInProgress());\n     }\n     \n     if (!r1Seg.getIsInProgress()) {\n-      // If both are finalized, they should match lengths, and be considered\n-      // equal\n-      if (r1Seg.getEndTxId() !\u003d r2Seg.getEndTxId()  ||\n-          !r1Seg.getMd5Sum().equals(r2Seg.getMd5Sum())) {\n+      // If both are finalized, they should match lengths\n+      if (r1Seg.getEndTxId() !\u003d r2Seg.getEndTxId()) {\n         throw new AssertionError(\"finalized segs with different lengths: \" + \n             r1 + \", \" + r2);\n       }\n       return 0;\n     }\n     \n     // Both are in-progress.\n     long r1SeenEpoch \u003d Math.max(r1.getAcceptedInEpoch(), r1.getLastWriterEpoch());\n     long r2SeenEpoch \u003d Math.max(r2.getAcceptedInEpoch(), r2.getLastWriterEpoch());\n     \n     return ComparisonChain.start()\n         .compare(r1SeenEpoch, r2SeenEpoch)\n         .compare(r1.getSegmentState().getEndTxId(), r2.getSegmentState().getEndTxId())\n         .result();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int compare(\n      Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e a,\n      Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e b) {\n    \n    PrepareRecoveryResponseProto r1 \u003d a.getValue();\n    PrepareRecoveryResponseProto r2 \u003d b.getValue();\n    \n    // A response that has data for a segment is always better than one\n    // that doesn\u0027t.\n    if (r1.hasSegmentState() !\u003d r2.hasSegmentState()) {\n      return Booleans.compare(r1.hasSegmentState(), r2.hasSegmentState());\n    }\n    \n    if (!r1.hasSegmentState()) {\n      // Neither has a segment, so neither can be used for recover.\n      // Call them equal.\n      return 0;\n    }\n    \n    // They both have a segment.\n    SegmentStateProto r1Seg \u003d r1.getSegmentState();\n    SegmentStateProto r2Seg \u003d r2.getSegmentState();\n    \n    Preconditions.checkArgument(r1Seg.getStartTxId() \u003d\u003d r2Seg.getStartTxId(),\n        \"Should only be called with responses for corresponding segments: \" +\n        \"%s and %s do not have the same start txid.\", r1, r2);\n\n    // If one is in-progress but the other is finalized,\n    // the finalized one is greater.\n    if (r1Seg.getIsInProgress() !\u003d r2Seg.getIsInProgress()) {\n      return Booleans.compare(!r1Seg.getIsInProgress(), !r2Seg.getIsInProgress());\n    }\n    \n    if (!r1Seg.getIsInProgress()) {\n      // If both are finalized, they should match lengths\n      if (r1Seg.getEndTxId() !\u003d r2Seg.getEndTxId()) {\n        throw new AssertionError(\"finalized segs with different lengths: \" + \n            r1 + \", \" + r2);\n      }\n      return 0;\n    }\n    \n    // Both are in-progress.\n    long r1SeenEpoch \u003d Math.max(r1.getAcceptedInEpoch(), r1.getLastWriterEpoch());\n    long r2SeenEpoch \u003d Math.max(r2.getAcceptedInEpoch(), r2.getLastWriterEpoch());\n    \n    return ComparisonChain.start()\n        .compare(r1SeenEpoch, r2SeenEpoch)\n        .compare(r1.getSegmentState().getEndTxId(), r2.getSegmentState().getEndTxId())\n        .result();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/SegmentRecoveryComparator.java",
      "extendedDetails": {}
    },
    "1e68d4726b225fb4a62eb8d79a3160dd03059ccb": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "HDFS-3845. Fixes for edge cases in QJM recovery protocol. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1377809 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/08/12 12:55 PM",
      "commitName": "1e68d4726b225fb4a62eb8d79a3160dd03059ccb",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-3845. Fixes for edge cases in QJM recovery protocol. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1377809 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/08/12 12:55 PM",
          "commitName": "1e68d4726b225fb4a62eb8d79a3160dd03059ccb",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "24/08/12 1:38 PM",
          "commitNameOld": "a8ff29266934d6d1455cc2f0af16856dbbf1796d",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 2.97,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,53 @@\n-      public int compare(\n-          Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e a,\n-          Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e b) {\n-        \n-        PrepareRecoveryResponseProto r1 \u003d a.getValue();\n-        PrepareRecoveryResponseProto r2 \u003d b.getValue();\n-        \n-        if (r1.hasSegmentState() \u0026\u0026 r2.hasSegmentState()) {\n-          assert r1.getSegmentState().getStartTxId() \u003d\u003d\n-              r2.getSegmentState().getStartTxId() : \"bad args: \" + r1 + \", \" + r2;\n-        }\n-        \n-        return ComparisonChain.start()\n-            // If one of them has accepted something and the other hasn\u0027t,\n-            // use the one with an accepted recovery\n-            .compare(r1.hasAcceptedInEpoch(), r2.hasAcceptedInEpoch())\n-            // If they both accepted, use the one that\u0027s more recent\n-            .compare(r1.getAcceptedInEpoch(),\n-                     r2.getAcceptedInEpoch())\n-            // Otherwise, choose based on which log is longer\n-            .compare(r1.hasSegmentState(), r2.hasSegmentState())\n-            .compare(r1.getSegmentState().getEndTxId(), r2.getSegmentState().getEndTxId())\n-            .result();\n-      }\n\\ No newline at end of file\n+  public int compare(\n+      Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e a,\n+      Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e b) {\n+    \n+    PrepareRecoveryResponseProto r1 \u003d a.getValue();\n+    PrepareRecoveryResponseProto r2 \u003d b.getValue();\n+    \n+    // A response that has data for a segment is always better than one\n+    // that doesn\u0027t.\n+    if (r1.hasSegmentState() !\u003d r2.hasSegmentState()) {\n+      return Booleans.compare(r1.hasSegmentState(), r2.hasSegmentState());\n+    }\n+    \n+    if (!r1.hasSegmentState()) {\n+      // Neither has a segment, so neither can be used for recover.\n+      // Call them equal.\n+      return 0;\n+    }\n+    \n+    // They both have a segment.\n+    SegmentStateProto r1Seg \u003d r1.getSegmentState();\n+    SegmentStateProto r2Seg \u003d r2.getSegmentState();\n+    \n+    Preconditions.checkArgument(r1Seg.getStartTxId() \u003d\u003d r2Seg.getStartTxId(),\n+        \"Should only be called with responses for corresponding segments: \" +\n+        \"%s and %s do not have the same start txid.\", r1, r2);\n+\n+    // If one is in-progress but the other is finalized,\n+    // the finalized one is greater.\n+    if (r1Seg.getIsInProgress() !\u003d r2Seg.getIsInProgress()) {\n+      return Booleans.compare(!r1Seg.getIsInProgress(), !r2Seg.getIsInProgress());\n+    }\n+    \n+    if (!r1Seg.getIsInProgress()) {\n+      // If both are finalized, they should match lengths, and be considered\n+      // equal\n+      if (r1Seg.getEndTxId() !\u003d r2Seg.getEndTxId()  ||\n+          !r1Seg.getMd5Sum().equals(r2Seg.getMd5Sum())) {\n+        throw new AssertionError(\"finalized segs with different lengths: \" + \n+            r1 + \", \" + r2);\n+      }\n+      return 0;\n+    }\n+    \n+    // Both are in-progress.\n+    long r1SeenEpoch \u003d Math.max(r1.getAcceptedInEpoch(), r1.getLastWriterEpoch());\n+    long r2SeenEpoch \u003d Math.max(r2.getAcceptedInEpoch(), r2.getLastWriterEpoch());\n+    \n+    return ComparisonChain.start()\n+        .compare(r1SeenEpoch, r2SeenEpoch)\n+        .compare(r1.getSegmentState().getEndTxId(), r2.getSegmentState().getEndTxId())\n+        .result();\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  public int compare(\n      Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e a,\n      Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e b) {\n    \n    PrepareRecoveryResponseProto r1 \u003d a.getValue();\n    PrepareRecoveryResponseProto r2 \u003d b.getValue();\n    \n    // A response that has data for a segment is always better than one\n    // that doesn\u0027t.\n    if (r1.hasSegmentState() !\u003d r2.hasSegmentState()) {\n      return Booleans.compare(r1.hasSegmentState(), r2.hasSegmentState());\n    }\n    \n    if (!r1.hasSegmentState()) {\n      // Neither has a segment, so neither can be used for recover.\n      // Call them equal.\n      return 0;\n    }\n    \n    // They both have a segment.\n    SegmentStateProto r1Seg \u003d r1.getSegmentState();\n    SegmentStateProto r2Seg \u003d r2.getSegmentState();\n    \n    Preconditions.checkArgument(r1Seg.getStartTxId() \u003d\u003d r2Seg.getStartTxId(),\n        \"Should only be called with responses for corresponding segments: \" +\n        \"%s and %s do not have the same start txid.\", r1, r2);\n\n    // If one is in-progress but the other is finalized,\n    // the finalized one is greater.\n    if (r1Seg.getIsInProgress() !\u003d r2Seg.getIsInProgress()) {\n      return Booleans.compare(!r1Seg.getIsInProgress(), !r2Seg.getIsInProgress());\n    }\n    \n    if (!r1Seg.getIsInProgress()) {\n      // If both are finalized, they should match lengths, and be considered\n      // equal\n      if (r1Seg.getEndTxId() !\u003d r2Seg.getEndTxId()  ||\n          !r1Seg.getMd5Sum().equals(r2Seg.getMd5Sum())) {\n        throw new AssertionError(\"finalized segs with different lengths: \" + \n            r1 + \", \" + r2);\n      }\n      return 0;\n    }\n    \n    // Both are in-progress.\n    long r1SeenEpoch \u003d Math.max(r1.getAcceptedInEpoch(), r1.getLastWriterEpoch());\n    long r2SeenEpoch \u003d Math.max(r2.getAcceptedInEpoch(), r2.getLastWriterEpoch());\n    \n    return ComparisonChain.start()\n        .compare(r1SeenEpoch, r2SeenEpoch)\n        .compare(r1.getSegmentState().getEndTxId(), r2.getSegmentState().getEndTxId())\n        .result();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/SegmentRecoveryComparator.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumJournalManager.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/SegmentRecoveryComparator.java",
            "oldMethodName": "compare",
            "newMethodName": "compare"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3845. Fixes for edge cases in QJM recovery protocol. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1377809 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/08/12 12:55 PM",
          "commitName": "1e68d4726b225fb4a62eb8d79a3160dd03059ccb",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "24/08/12 1:38 PM",
          "commitNameOld": "a8ff29266934d6d1455cc2f0af16856dbbf1796d",
          "commitAuthorOld": "Aaron Myers",
          "daysBetweenCommits": 2.97,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,24 +1,53 @@\n-      public int compare(\n-          Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e a,\n-          Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e b) {\n-        \n-        PrepareRecoveryResponseProto r1 \u003d a.getValue();\n-        PrepareRecoveryResponseProto r2 \u003d b.getValue();\n-        \n-        if (r1.hasSegmentState() \u0026\u0026 r2.hasSegmentState()) {\n-          assert r1.getSegmentState().getStartTxId() \u003d\u003d\n-              r2.getSegmentState().getStartTxId() : \"bad args: \" + r1 + \", \" + r2;\n-        }\n-        \n-        return ComparisonChain.start()\n-            // If one of them has accepted something and the other hasn\u0027t,\n-            // use the one with an accepted recovery\n-            .compare(r1.hasAcceptedInEpoch(), r2.hasAcceptedInEpoch())\n-            // If they both accepted, use the one that\u0027s more recent\n-            .compare(r1.getAcceptedInEpoch(),\n-                     r2.getAcceptedInEpoch())\n-            // Otherwise, choose based on which log is longer\n-            .compare(r1.hasSegmentState(), r2.hasSegmentState())\n-            .compare(r1.getSegmentState().getEndTxId(), r2.getSegmentState().getEndTxId())\n-            .result();\n-      }\n\\ No newline at end of file\n+  public int compare(\n+      Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e a,\n+      Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e b) {\n+    \n+    PrepareRecoveryResponseProto r1 \u003d a.getValue();\n+    PrepareRecoveryResponseProto r2 \u003d b.getValue();\n+    \n+    // A response that has data for a segment is always better than one\n+    // that doesn\u0027t.\n+    if (r1.hasSegmentState() !\u003d r2.hasSegmentState()) {\n+      return Booleans.compare(r1.hasSegmentState(), r2.hasSegmentState());\n+    }\n+    \n+    if (!r1.hasSegmentState()) {\n+      // Neither has a segment, so neither can be used for recover.\n+      // Call them equal.\n+      return 0;\n+    }\n+    \n+    // They both have a segment.\n+    SegmentStateProto r1Seg \u003d r1.getSegmentState();\n+    SegmentStateProto r2Seg \u003d r2.getSegmentState();\n+    \n+    Preconditions.checkArgument(r1Seg.getStartTxId() \u003d\u003d r2Seg.getStartTxId(),\n+        \"Should only be called with responses for corresponding segments: \" +\n+        \"%s and %s do not have the same start txid.\", r1, r2);\n+\n+    // If one is in-progress but the other is finalized,\n+    // the finalized one is greater.\n+    if (r1Seg.getIsInProgress() !\u003d r2Seg.getIsInProgress()) {\n+      return Booleans.compare(!r1Seg.getIsInProgress(), !r2Seg.getIsInProgress());\n+    }\n+    \n+    if (!r1Seg.getIsInProgress()) {\n+      // If both are finalized, they should match lengths, and be considered\n+      // equal\n+      if (r1Seg.getEndTxId() !\u003d r2Seg.getEndTxId()  ||\n+          !r1Seg.getMd5Sum().equals(r2Seg.getMd5Sum())) {\n+        throw new AssertionError(\"finalized segs with different lengths: \" + \n+            r1 + \", \" + r2);\n+      }\n+      return 0;\n+    }\n+    \n+    // Both are in-progress.\n+    long r1SeenEpoch \u003d Math.max(r1.getAcceptedInEpoch(), r1.getLastWriterEpoch());\n+    long r2SeenEpoch \u003d Math.max(r2.getAcceptedInEpoch(), r2.getLastWriterEpoch());\n+    \n+    return ComparisonChain.start()\n+        .compare(r1SeenEpoch, r2SeenEpoch)\n+        .compare(r1.getSegmentState().getEndTxId(), r2.getSegmentState().getEndTxId())\n+        .result();\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  public int compare(\n      Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e a,\n      Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e b) {\n    \n    PrepareRecoveryResponseProto r1 \u003d a.getValue();\n    PrepareRecoveryResponseProto r2 \u003d b.getValue();\n    \n    // A response that has data for a segment is always better than one\n    // that doesn\u0027t.\n    if (r1.hasSegmentState() !\u003d r2.hasSegmentState()) {\n      return Booleans.compare(r1.hasSegmentState(), r2.hasSegmentState());\n    }\n    \n    if (!r1.hasSegmentState()) {\n      // Neither has a segment, so neither can be used for recover.\n      // Call them equal.\n      return 0;\n    }\n    \n    // They both have a segment.\n    SegmentStateProto r1Seg \u003d r1.getSegmentState();\n    SegmentStateProto r2Seg \u003d r2.getSegmentState();\n    \n    Preconditions.checkArgument(r1Seg.getStartTxId() \u003d\u003d r2Seg.getStartTxId(),\n        \"Should only be called with responses for corresponding segments: \" +\n        \"%s and %s do not have the same start txid.\", r1, r2);\n\n    // If one is in-progress but the other is finalized,\n    // the finalized one is greater.\n    if (r1Seg.getIsInProgress() !\u003d r2Seg.getIsInProgress()) {\n      return Booleans.compare(!r1Seg.getIsInProgress(), !r2Seg.getIsInProgress());\n    }\n    \n    if (!r1Seg.getIsInProgress()) {\n      // If both are finalized, they should match lengths, and be considered\n      // equal\n      if (r1Seg.getEndTxId() !\u003d r2Seg.getEndTxId()  ||\n          !r1Seg.getMd5Sum().equals(r2Seg.getMd5Sum())) {\n        throw new AssertionError(\"finalized segs with different lengths: \" + \n            r1 + \", \" + r2);\n      }\n      return 0;\n    }\n    \n    // Both are in-progress.\n    long r1SeenEpoch \u003d Math.max(r1.getAcceptedInEpoch(), r1.getLastWriterEpoch());\n    long r2SeenEpoch \u003d Math.max(r2.getAcceptedInEpoch(), r2.getLastWriterEpoch());\n    \n    return ComparisonChain.start()\n        .compare(r1SeenEpoch, r2SeenEpoch)\n        .compare(r1.getSegmentState().getEndTxId(), r2.getSegmentState().getEndTxId())\n        .result();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/SegmentRecoveryComparator.java",
          "extendedDetails": {}
        }
      ]
    },
    "74d4573a23db5586c6e47ff2277aa7c35237da34": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-3077. Quorum-based protocol for reading and writing edit logs. Contributed by Todd Lipcon based on initial work from Brandon Li and Hari Mankude.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3077@1363596 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/07/12 5:25 PM",
      "commitName": "74d4573a23db5586c6e47ff2277aa7c35237da34",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,24 @@\n+      public int compare(\n+          Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e a,\n+          Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e b) {\n+        \n+        PrepareRecoveryResponseProto r1 \u003d a.getValue();\n+        PrepareRecoveryResponseProto r2 \u003d b.getValue();\n+        \n+        if (r1.hasSegmentState() \u0026\u0026 r2.hasSegmentState()) {\n+          assert r1.getSegmentState().getStartTxId() \u003d\u003d\n+              r2.getSegmentState().getStartTxId() : \"bad args: \" + r1 + \", \" + r2;\n+        }\n+        \n+        return ComparisonChain.start()\n+            // If one of them has accepted something and the other hasn\u0027t,\n+            // use the one with an accepted recovery\n+            .compare(r1.hasAcceptedInEpoch(), r2.hasAcceptedInEpoch())\n+            // If they both accepted, use the one that\u0027s more recent\n+            .compare(r1.getAcceptedInEpoch(),\n+                     r2.getAcceptedInEpoch())\n+            // Otherwise, choose based on which log is longer\n+            .compare(r1.hasSegmentState(), r2.hasSegmentState())\n+            .compare(r1.getSegmentState().getEndTxId(), r2.getSegmentState().getEndTxId())\n+            .result();\n+      }\n\\ No newline at end of file\n",
      "actualSource": "      public int compare(\n          Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e a,\n          Entry\u003cAsyncLogger, PrepareRecoveryResponseProto\u003e b) {\n        \n        PrepareRecoveryResponseProto r1 \u003d a.getValue();\n        PrepareRecoveryResponseProto r2 \u003d b.getValue();\n        \n        if (r1.hasSegmentState() \u0026\u0026 r2.hasSegmentState()) {\n          assert r1.getSegmentState().getStartTxId() \u003d\u003d\n              r2.getSegmentState().getStartTxId() : \"bad args: \" + r1 + \", \" + r2;\n        }\n        \n        return ComparisonChain.start()\n            // If one of them has accepted something and the other hasn\u0027t,\n            // use the one with an accepted recovery\n            .compare(r1.hasAcceptedInEpoch(), r2.hasAcceptedInEpoch())\n            // If they both accepted, use the one that\u0027s more recent\n            .compare(r1.getAcceptedInEpoch(),\n                     r2.getAcceptedInEpoch())\n            // Otherwise, choose based on which log is longer\n            .compare(r1.hasSegmentState(), r2.hasSegmentState())\n            .compare(r1.getSegmentState().getEndTxId(), r2.getSegmentState().getEndTxId())\n            .result();\n      }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/qjournal/client/QuorumJournalManager.java"
    }
  }
}