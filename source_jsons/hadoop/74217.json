{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LdapGroupsMapping.java",
  "functionName": "lookupGroup",
  "functionId": "lookupGroup___result-SearchResult__c-DirContext__goUpHierarchy-int",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
  "functionStartLine": 461,
  "functionEndLine": 495,
  "numCommitsSeen": 46,
  "timeTaken": 2473,
  "changeHistory": [
    "c9a3aa64dc95b097c51070f71a3b1a2ad126b2b9",
    "a2121cb0d907be439d19cd1165a0371b37a5fe68",
    "6f0aa75121224589fe1e20630c597f851ef3bed2",
    "182fc1986a984ed0be6bed297390a830c2305af1"
  ],
  "changeHistoryShort": {
    "c9a3aa64dc95b097c51070f71a3b1a2ad126b2b9": "Ybodychange",
    "a2121cb0d907be439d19cd1165a0371b37a5fe68": "Ybodychange",
    "6f0aa75121224589fe1e20630c597f851ef3bed2": "Ymultichange(Yparameterchange,Ybodychange)",
    "182fc1986a984ed0be6bed297390a830c2305af1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c9a3aa64dc95b097c51070f71a3b1a2ad126b2b9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15950. Failover for LdapGroupsMapping. Contributed by Lukas Majercak.\n",
      "commitDate": "03/12/18 12:10 PM",
      "commitName": "c9a3aa64dc95b097c51070f71a3b1a2ad126b2b9",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "29/03/18 5:16 PM",
      "commitNameOld": "2216bde322961c0fe33b5822510880a65d5c45fd",
      "commitAuthorOld": "Konstantin V Shvachko",
      "daysBetweenCommits": 248.83,
      "commitsBetweenForRepo": 2455,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private List\u003cString\u003e lookupGroup(SearchResult result, DirContext c,\n       int goUpHierarchy)\n       throws NamingException {\n-    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n-    Set\u003cString\u003e groupDNs \u003d new HashSet\u003cString\u003e();\n+    List\u003cString\u003e groups \u003d new ArrayList\u003c\u003e();\n+    Set\u003cString\u003e groupDNs \u003d new HashSet\u003c\u003e();\n \n-    NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n+    NamingEnumeration\u003cSearchResult\u003e groupResults;\n     // perform the second LDAP query\n     if (isPosix) {\n       groupResults \u003d lookupPosixGroup(result, c);\n     } else {\n       String userDn \u003d result.getNameInNamespace();\n       groupResults \u003d\n           c.search(groupbaseDN,\n               \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n               new Object[]{userDn},\n               SEARCH_CONTROLS);\n     }\n     // if the second query is successful, group objects of the user will be\n     // returned. Get group names from the returned objects.\n     if (groupResults !\u003d null) {\n       while (groupResults.hasMoreElements()) {\n         SearchResult groupResult \u003d groupResults.nextElement();\n         getGroupNames(groupResult, groups, groupDNs, goUpHierarchy \u003e 0);\n       }\n       if (goUpHierarchy \u003e 0 \u0026\u0026 !isPosix) {\n         // convert groups to a set to ensure uniqueness\n-        Set\u003cString\u003e groupset \u003d new HashSet\u003cString\u003e(groups);\n+        Set\u003cString\u003e groupset \u003d new HashSet\u003c\u003e(groups);\n         goUpGroupHierarchy(groupDNs, goUpHierarchy, groupset);\n         // convert set back to list for compatibility\n-        groups \u003d new ArrayList\u003cString\u003e(groupset);\n+        groups \u003d new ArrayList\u003c\u003e(groupset);\n       }\n     }\n     return groups;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cString\u003e lookupGroup(SearchResult result, DirContext c,\n      int goUpHierarchy)\n      throws NamingException {\n    List\u003cString\u003e groups \u003d new ArrayList\u003c\u003e();\n    Set\u003cString\u003e groupDNs \u003d new HashSet\u003c\u003e();\n\n    NamingEnumeration\u003cSearchResult\u003e groupResults;\n    // perform the second LDAP query\n    if (isPosix) {\n      groupResults \u003d lookupPosixGroup(result, c);\n    } else {\n      String userDn \u003d result.getNameInNamespace();\n      groupResults \u003d\n          c.search(groupbaseDN,\n              \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n              new Object[]{userDn},\n              SEARCH_CONTROLS);\n    }\n    // if the second query is successful, group objects of the user will be\n    // returned. Get group names from the returned objects.\n    if (groupResults !\u003d null) {\n      while (groupResults.hasMoreElements()) {\n        SearchResult groupResult \u003d groupResults.nextElement();\n        getGroupNames(groupResult, groups, groupDNs, goUpHierarchy \u003e 0);\n      }\n      if (goUpHierarchy \u003e 0 \u0026\u0026 !isPosix) {\n        // convert groups to a set to ensure uniqueness\n        Set\u003cString\u003e groupset \u003d new HashSet\u003c\u003e(groups);\n        goUpGroupHierarchy(groupDNs, goUpHierarchy, groupset);\n        // convert set back to list for compatibility\n        groups \u003d new ArrayList\u003c\u003e(groupset);\n      }\n    }\n    return groups;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "a2121cb0d907be439d19cd1165a0371b37a5fe68": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14465. LdapGroupsMapping - support user and group search base. Contributed by Shwetha G S and Mingliang Liu\n",
      "commitDate": "09/06/17 2:55 PM",
      "commitName": "a2121cb0d907be439d19cd1165a0371b37a5fe68",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "05/08/16 4:32 PM",
      "commitNameOld": "49ba09a9221ad1e25e89800f6c455bbaad41483b",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 307.93,
      "commitsBetweenForRepo": 1866,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   private List\u003cString\u003e lookupGroup(SearchResult result, DirContext c,\n       int goUpHierarchy)\n       throws NamingException {\n     List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n     Set\u003cString\u003e groupDNs \u003d new HashSet\u003cString\u003e();\n \n     NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n     // perform the second LDAP query\n     if (isPosix) {\n       groupResults \u003d lookupPosixGroup(result, c);\n     } else {\n       String userDn \u003d result.getNameInNamespace();\n       groupResults \u003d\n-          c.search(baseDN,\n+          c.search(groupbaseDN,\n               \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n               new Object[]{userDn},\n               SEARCH_CONTROLS);\n     }\n     // if the second query is successful, group objects of the user will be\n     // returned. Get group names from the returned objects.\n     if (groupResults !\u003d null) {\n       while (groupResults.hasMoreElements()) {\n         SearchResult groupResult \u003d groupResults.nextElement();\n         getGroupNames(groupResult, groups, groupDNs, goUpHierarchy \u003e 0);\n       }\n       if (goUpHierarchy \u003e 0 \u0026\u0026 !isPosix) {\n         // convert groups to a set to ensure uniqueness\n         Set\u003cString\u003e groupset \u003d new HashSet\u003cString\u003e(groups);\n         goUpGroupHierarchy(groupDNs, goUpHierarchy, groupset);\n         // convert set back to list for compatibility\n         groups \u003d new ArrayList\u003cString\u003e(groupset);\n       }\n     }\n     return groups;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cString\u003e lookupGroup(SearchResult result, DirContext c,\n      int goUpHierarchy)\n      throws NamingException {\n    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n    Set\u003cString\u003e groupDNs \u003d new HashSet\u003cString\u003e();\n\n    NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n    // perform the second LDAP query\n    if (isPosix) {\n      groupResults \u003d lookupPosixGroup(result, c);\n    } else {\n      String userDn \u003d result.getNameInNamespace();\n      groupResults \u003d\n          c.search(groupbaseDN,\n              \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n              new Object[]{userDn},\n              SEARCH_CONTROLS);\n    }\n    // if the second query is successful, group objects of the user will be\n    // returned. Get group names from the returned objects.\n    if (groupResults !\u003d null) {\n      while (groupResults.hasMoreElements()) {\n        SearchResult groupResult \u003d groupResults.nextElement();\n        getGroupNames(groupResult, groups, groupDNs, goUpHierarchy \u003e 0);\n      }\n      if (goUpHierarchy \u003e 0 \u0026\u0026 !isPosix) {\n        // convert groups to a set to ensure uniqueness\n        Set\u003cString\u003e groupset \u003d new HashSet\u003cString\u003e(groups);\n        goUpGroupHierarchy(groupDNs, goUpHierarchy, groupset);\n        // convert set back to list for compatibility\n        groups \u003d new ArrayList\u003cString\u003e(groupset);\n      }\n    }\n    return groups;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
      "extendedDetails": {}
    },
    "6f0aa75121224589fe1e20630c597f851ef3bed2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-12291. Add support for nested groups in LdapGroupsMapping. Contributed by Esther Kundin.\n",
      "commitDate": "15/06/16 11:41 AM",
      "commitName": "6f0aa75121224589fe1e20630c597f851ef3bed2",
      "commitAuthor": "Jitendra Pandey",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-12291. Add support for nested groups in LdapGroupsMapping. Contributed by Esther Kundin.\n",
          "commitDate": "15/06/16 11:41 AM",
          "commitName": "6f0aa75121224589fe1e20630c597f851ef3bed2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "03/06/16 4:38 PM",
          "commitNameOld": "d82bc8501869be78780fc09752dbf7af918c14af",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 11.79,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,35 @@\n-  private List\u003cString\u003e lookupGroup(SearchResult result, DirContext c)\n+  private List\u003cString\u003e lookupGroup(SearchResult result, DirContext c,\n+      int goUpHierarchy)\n       throws NamingException {\n     List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n+    Set\u003cString\u003e groupDNs \u003d new HashSet\u003cString\u003e();\n \n     NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n     // perform the second LDAP query\n     if (isPosix) {\n       groupResults \u003d lookupPosixGroup(result, c);\n     } else {\n       String userDn \u003d result.getNameInNamespace();\n       groupResults \u003d\n           c.search(baseDN,\n               \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n               new Object[]{userDn},\n               SEARCH_CONTROLS);\n     }\n     // if the second query is successful, group objects of the user will be\n     // returned. Get group names from the returned objects.\n     if (groupResults !\u003d null) {\n       while (groupResults.hasMoreElements()) {\n         SearchResult groupResult \u003d groupResults.nextElement();\n-        Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n-        if (groupName \u003d\u003d null) {\n-          throw new NamingException(\"The group object does not have \" +\n-              \"attribute \u0027\" + groupNameAttr + \"\u0027.\");\n-        }\n-        groups.add(groupName.get().toString());\n+        getGroupNames(groupResult, groups, groupDNs, goUpHierarchy \u003e 0);\n+      }\n+      if (goUpHierarchy \u003e 0 \u0026\u0026 !isPosix) {\n+        // convert groups to a set to ensure uniqueness\n+        Set\u003cString\u003e groupset \u003d new HashSet\u003cString\u003e(groups);\n+        goUpGroupHierarchy(groupDNs, goUpHierarchy, groupset);\n+        // convert set back to list for compatibility\n+        groups \u003d new ArrayList\u003cString\u003e(groupset);\n       }\n     }\n     return groups;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cString\u003e lookupGroup(SearchResult result, DirContext c,\n      int goUpHierarchy)\n      throws NamingException {\n    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n    Set\u003cString\u003e groupDNs \u003d new HashSet\u003cString\u003e();\n\n    NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n    // perform the second LDAP query\n    if (isPosix) {\n      groupResults \u003d lookupPosixGroup(result, c);\n    } else {\n      String userDn \u003d result.getNameInNamespace();\n      groupResults \u003d\n          c.search(baseDN,\n              \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n              new Object[]{userDn},\n              SEARCH_CONTROLS);\n    }\n    // if the second query is successful, group objects of the user will be\n    // returned. Get group names from the returned objects.\n    if (groupResults !\u003d null) {\n      while (groupResults.hasMoreElements()) {\n        SearchResult groupResult \u003d groupResults.nextElement();\n        getGroupNames(groupResult, groups, groupDNs, goUpHierarchy \u003e 0);\n      }\n      if (goUpHierarchy \u003e 0 \u0026\u0026 !isPosix) {\n        // convert groups to a set to ensure uniqueness\n        Set\u003cString\u003e groupset \u003d new HashSet\u003cString\u003e(groups);\n        goUpGroupHierarchy(groupDNs, goUpHierarchy, groupset);\n        // convert set back to list for compatibility\n        groups \u003d new ArrayList\u003cString\u003e(groupset);\n      }\n    }\n    return groups;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
          "extendedDetails": {
            "oldValue": "[result-SearchResult, c-DirContext]",
            "newValue": "[result-SearchResult, c-DirContext, goUpHierarchy-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-12291. Add support for nested groups in LdapGroupsMapping. Contributed by Esther Kundin.\n",
          "commitDate": "15/06/16 11:41 AM",
          "commitName": "6f0aa75121224589fe1e20630c597f851ef3bed2",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "03/06/16 4:38 PM",
          "commitNameOld": "d82bc8501869be78780fc09752dbf7af918c14af",
          "commitAuthorOld": "Chris Nauroth",
          "daysBetweenCommits": 11.79,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,35 @@\n-  private List\u003cString\u003e lookupGroup(SearchResult result, DirContext c)\n+  private List\u003cString\u003e lookupGroup(SearchResult result, DirContext c,\n+      int goUpHierarchy)\n       throws NamingException {\n     List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n+    Set\u003cString\u003e groupDNs \u003d new HashSet\u003cString\u003e();\n \n     NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n     // perform the second LDAP query\n     if (isPosix) {\n       groupResults \u003d lookupPosixGroup(result, c);\n     } else {\n       String userDn \u003d result.getNameInNamespace();\n       groupResults \u003d\n           c.search(baseDN,\n               \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n               new Object[]{userDn},\n               SEARCH_CONTROLS);\n     }\n     // if the second query is successful, group objects of the user will be\n     // returned. Get group names from the returned objects.\n     if (groupResults !\u003d null) {\n       while (groupResults.hasMoreElements()) {\n         SearchResult groupResult \u003d groupResults.nextElement();\n-        Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n-        if (groupName \u003d\u003d null) {\n-          throw new NamingException(\"The group object does not have \" +\n-              \"attribute \u0027\" + groupNameAttr + \"\u0027.\");\n-        }\n-        groups.add(groupName.get().toString());\n+        getGroupNames(groupResult, groups, groupDNs, goUpHierarchy \u003e 0);\n+      }\n+      if (goUpHierarchy \u003e 0 \u0026\u0026 !isPosix) {\n+        // convert groups to a set to ensure uniqueness\n+        Set\u003cString\u003e groupset \u003d new HashSet\u003cString\u003e(groups);\n+        goUpGroupHierarchy(groupDNs, goUpHierarchy, groupset);\n+        // convert set back to list for compatibility\n+        groups \u003d new ArrayList\u003cString\u003e(groupset);\n       }\n     }\n     return groups;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private List\u003cString\u003e lookupGroup(SearchResult result, DirContext c,\n      int goUpHierarchy)\n      throws NamingException {\n    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n    Set\u003cString\u003e groupDNs \u003d new HashSet\u003cString\u003e();\n\n    NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n    // perform the second LDAP query\n    if (isPosix) {\n      groupResults \u003d lookupPosixGroup(result, c);\n    } else {\n      String userDn \u003d result.getNameInNamespace();\n      groupResults \u003d\n          c.search(baseDN,\n              \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n              new Object[]{userDn},\n              SEARCH_CONTROLS);\n    }\n    // if the second query is successful, group objects of the user will be\n    // returned. Get group names from the returned objects.\n    if (groupResults !\u003d null) {\n      while (groupResults.hasMoreElements()) {\n        SearchResult groupResult \u003d groupResults.nextElement();\n        getGroupNames(groupResult, groups, groupDNs, goUpHierarchy \u003e 0);\n      }\n      if (goUpHierarchy \u003e 0 \u0026\u0026 !isPosix) {\n        // convert groups to a set to ensure uniqueness\n        Set\u003cString\u003e groupset \u003d new HashSet\u003cString\u003e(groups);\n        goUpGroupHierarchy(groupDNs, goUpHierarchy, groupset);\n        // convert set back to list for compatibility\n        groups \u003d new ArrayList\u003cString\u003e(groupset);\n      }\n    }\n    return groups;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java",
          "extendedDetails": {}
        }
      ]
    },
    "182fc1986a984ed0be6bed297390a830c2305af1": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-12782. Faster LDAP group name resolution with ActiveDirectory. Contributed by Wei-Chiu Chuang\n",
      "commitDate": "19/05/16 7:15 AM",
      "commitName": "182fc1986a984ed0be6bed297390a830c2305af1",
      "commitAuthor": "Kai Zheng",
      "diff": "@@ -0,0 +1,31 @@\n+  private List\u003cString\u003e lookupGroup(SearchResult result, DirContext c)\n+      throws NamingException {\n+    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n+\n+    NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n+    // perform the second LDAP query\n+    if (isPosix) {\n+      groupResults \u003d lookupPosixGroup(result, c);\n+    } else {\n+      String userDn \u003d result.getNameInNamespace();\n+      groupResults \u003d\n+          c.search(baseDN,\n+              \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n+              new Object[]{userDn},\n+              SEARCH_CONTROLS);\n+    }\n+    // if the second query is successful, group objects of the user will be\n+    // returned. Get group names from the returned objects.\n+    if (groupResults !\u003d null) {\n+      while (groupResults.hasMoreElements()) {\n+        SearchResult groupResult \u003d groupResults.nextElement();\n+        Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n+        if (groupName \u003d\u003d null) {\n+          throw new NamingException(\"The group object does not have \" +\n+              \"attribute \u0027\" + groupNameAttr + \"\u0027.\");\n+        }\n+        groups.add(groupName.get().toString());\n+      }\n+    }\n+    return groups;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private List\u003cString\u003e lookupGroup(SearchResult result, DirContext c)\n      throws NamingException {\n    List\u003cString\u003e groups \u003d new ArrayList\u003cString\u003e();\n\n    NamingEnumeration\u003cSearchResult\u003e groupResults \u003d null;\n    // perform the second LDAP query\n    if (isPosix) {\n      groupResults \u003d lookupPosixGroup(result, c);\n    } else {\n      String userDn \u003d result.getNameInNamespace();\n      groupResults \u003d\n          c.search(baseDN,\n              \"(\u0026\" + groupSearchFilter + \"(\" + groupMemberAttr + \"\u003d{0}))\",\n              new Object[]{userDn},\n              SEARCH_CONTROLS);\n    }\n    // if the second query is successful, group objects of the user will be\n    // returned. Get group names from the returned objects.\n    if (groupResults !\u003d null) {\n      while (groupResults.hasMoreElements()) {\n        SearchResult groupResult \u003d groupResults.nextElement();\n        Attribute groupName \u003d groupResult.getAttributes().get(groupNameAttr);\n        if (groupName \u003d\u003d null) {\n          throw new NamingException(\"The group object does not have \" +\n              \"attribute \u0027\" + groupNameAttr + \"\u0027.\");\n        }\n        groups.add(groupName.get().toString());\n      }\n    }\n    return groups;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/LdapGroupsMapping.java"
    }
  }
}