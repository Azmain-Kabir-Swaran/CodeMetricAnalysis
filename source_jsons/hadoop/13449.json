{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DatanodeAdminManager.java",
  "functionName": "startMaintenance",
  "functionId": "startMaintenance___node-DatanodeDescriptor__maintenanceExpireTimeInMS-long",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DatanodeAdminManager.java",
  "functionStartLine": 222,
  "functionEndLine": 245,
  "numCommitsSeen": 41,
  "timeTaken": 5508,
  "changeHistory": [
    "c93cb6790e0f1c64efd03d859f907a0522010894",
    "6f81cc0beea00843b44424417f09d8ee12cd7bae",
    "79df1e750ef558afed6d166ce225a23061b36aed",
    "b61fb267b92b2736920b4bd0c673d31e7632ebb9",
    "9dcbdbdb5a34d85910707f81ebc1bb1f81c99978"
  ],
  "changeHistoryShort": {
    "c93cb6790e0f1c64efd03d859f907a0522010894": "Ybodychange",
    "6f81cc0beea00843b44424417f09d8ee12cd7bae": "Ybodychange",
    "79df1e750ef558afed6d166ce225a23061b36aed": "Yfilerename",
    "b61fb267b92b2736920b4bd0c673d31e7632ebb9": "Ybodychange",
    "9dcbdbdb5a34d85910707f81ebc1bb1f81c99978": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c93cb6790e0f1c64efd03d859f907a0522010894": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14854. Create improved decommission monitor implementation. Contributed by Stephen O\u0027Donnell.\n\nReviewed-by: Inigo Goiri \u003cinigoiri@apache.org\u003e\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "10/12/19 5:16 PM",
      "commitName": "c93cb6790e0f1c64efd03d859f907a0522010894",
      "commitAuthor": "Stephen O\u0027Donnell",
      "commitDateOld": "19/10/19 5:40 PM",
      "commitNameOld": "447f46d9628db54e77f88e2d109587cc7dfd6154",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 52.02,
      "commitsBetweenForRepo": 198,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,24 @@\n   public void startMaintenance(DatanodeDescriptor node,\n       long maintenanceExpireTimeInMS) {\n     // Even if the node is already in maintenance, we still need to adjust\n     // the expiration time.\n     node.setMaintenanceExpireTimeInMS(maintenanceExpireTimeInMS);\n     if (!node.isMaintenance()) {\n       // Update DN stats maintained by HeartbeatManager\n       hbManager.startMaintenance(node);\n       // hbManager.startMaintenance will set dead node to IN_MAINTENANCE.\n       if (node.isEnteringMaintenance()) {\n         for (DatanodeStorageInfo storage : node.getStorageInfos()) {\n           LOG.info(\"Starting maintenance of {} {} with {} blocks\",\n               node, storage, storage.numBlocks());\n         }\n         node.getLeavingServiceStatus().setStartTime(monotonicNow());\n       }\n       // Track the node regardless whether it is ENTERING_MAINTENANCE or\n       // IN_MAINTENANCE to support maintenance expiration.\n-      pendingNodes.add(node);\n+      monitor.startTrackingNode(node);\n     } else {\n       LOG.trace(\"startMaintenance: Node {} in {}, nothing to do.\",\n           node, node.getAdminState());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void startMaintenance(DatanodeDescriptor node,\n      long maintenanceExpireTimeInMS) {\n    // Even if the node is already in maintenance, we still need to adjust\n    // the expiration time.\n    node.setMaintenanceExpireTimeInMS(maintenanceExpireTimeInMS);\n    if (!node.isMaintenance()) {\n      // Update DN stats maintained by HeartbeatManager\n      hbManager.startMaintenance(node);\n      // hbManager.startMaintenance will set dead node to IN_MAINTENANCE.\n      if (node.isEnteringMaintenance()) {\n        for (DatanodeStorageInfo storage : node.getStorageInfos()) {\n          LOG.info(\"Starting maintenance of {} {} with {} blocks\",\n              node, storage, storage.numBlocks());\n        }\n        node.getLeavingServiceStatus().setStartTime(monotonicNow());\n      }\n      // Track the node regardless whether it is ENTERING_MAINTENANCE or\n      // IN_MAINTENANCE to support maintenance expiration.\n      monitor.startTrackingNode(node);\n    } else {\n      LOG.trace(\"startMaintenance: Node {} in {}, nothing to do.\",\n          node, node.getAdminState());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DatanodeAdminManager.java",
      "extendedDetails": {}
    },
    "6f81cc0beea00843b44424417f09d8ee12cd7bae": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13167. DatanodeAdminManager Improvements. Contributed by BELUGA BEHR.\n",
      "commitDate": "20/02/18 3:18 PM",
      "commitName": "6f81cc0beea00843b44424417f09d8ee12cd7bae",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "02/01/18 2:59 PM",
      "commitNameOld": "42a1c98597e6dba2e371510a6b2b6b1fb94e4090",
      "commitAuthorOld": "Manoj Govindassamy",
      "daysBetweenCommits": 49.01,
      "commitsBetweenForRepo": 297,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,24 @@\n   public void startMaintenance(DatanodeDescriptor node,\n       long maintenanceExpireTimeInMS) {\n     // Even if the node is already in maintenance, we still need to adjust\n     // the expiration time.\n     node.setMaintenanceExpireTimeInMS(maintenanceExpireTimeInMS);\n     if (!node.isMaintenance()) {\n       // Update DN stats maintained by HeartbeatManager\n       hbManager.startMaintenance(node);\n       // hbManager.startMaintenance will set dead node to IN_MAINTENANCE.\n       if (node.isEnteringMaintenance()) {\n         for (DatanodeStorageInfo storage : node.getStorageInfos()) {\n           LOG.info(\"Starting maintenance of {} {} with {} blocks\",\n               node, storage, storage.numBlocks());\n         }\n         node.getLeavingServiceStatus().setStartTime(monotonicNow());\n       }\n       // Track the node regardless whether it is ENTERING_MAINTENANCE or\n       // IN_MAINTENANCE to support maintenance expiration.\n       pendingNodes.add(node);\n     } else {\n-      LOG.trace(\"startMaintenance: Node {} in {}, nothing to do.\" +\n+      LOG.trace(\"startMaintenance: Node {} in {}, nothing to do.\",\n           node, node.getAdminState());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void startMaintenance(DatanodeDescriptor node,\n      long maintenanceExpireTimeInMS) {\n    // Even if the node is already in maintenance, we still need to adjust\n    // the expiration time.\n    node.setMaintenanceExpireTimeInMS(maintenanceExpireTimeInMS);\n    if (!node.isMaintenance()) {\n      // Update DN stats maintained by HeartbeatManager\n      hbManager.startMaintenance(node);\n      // hbManager.startMaintenance will set dead node to IN_MAINTENANCE.\n      if (node.isEnteringMaintenance()) {\n        for (DatanodeStorageInfo storage : node.getStorageInfos()) {\n          LOG.info(\"Starting maintenance of {} {} with {} blocks\",\n              node, storage, storage.numBlocks());\n        }\n        node.getLeavingServiceStatus().setStartTime(monotonicNow());\n      }\n      // Track the node regardless whether it is ENTERING_MAINTENANCE or\n      // IN_MAINTENANCE to support maintenance expiration.\n      pendingNodes.add(node);\n    } else {\n      LOG.trace(\"startMaintenance: Node {} in {}, nothing to do.\",\n          node, node.getAdminState());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DatanodeAdminManager.java",
      "extendedDetails": {}
    },
    "79df1e750ef558afed6d166ce225a23061b36aed": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-9388. Decommission related code to support Maintenance State for datanodes.\n",
      "commitDate": "02/08/17 2:22 PM",
      "commitName": "79df1e750ef558afed6d166ce225a23061b36aed",
      "commitAuthor": "Manoj Govindassamy",
      "commitDateOld": "02/08/17 12:12 PM",
      "commitNameOld": "12e44e7bdaf53d3720a89d32f0cc2717241bd6b2",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void startMaintenance(DatanodeDescriptor node,\n      long maintenanceExpireTimeInMS) {\n    // Even if the node is already in maintenance, we still need to adjust\n    // the expiration time.\n    node.setMaintenanceExpireTimeInMS(maintenanceExpireTimeInMS);\n    if (!node.isMaintenance()) {\n      // Update DN stats maintained by HeartbeatManager\n      hbManager.startMaintenance(node);\n      // hbManager.startMaintenance will set dead node to IN_MAINTENANCE.\n      if (node.isEnteringMaintenance()) {\n        for (DatanodeStorageInfo storage : node.getStorageInfos()) {\n          LOG.info(\"Starting maintenance of {} {} with {} blocks\",\n              node, storage, storage.numBlocks());\n        }\n        node.getLeavingServiceStatus().setStartTime(monotonicNow());\n      }\n      // Track the node regardless whether it is ENTERING_MAINTENANCE or\n      // IN_MAINTENANCE to support maintenance expiration.\n      pendingNodes.add(node);\n    } else {\n      LOG.trace(\"startMaintenance: Node {} in {}, nothing to do.\" +\n          node, node.getAdminState());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DatanodeAdminManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DecommissionManager.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DatanodeAdminManager.java"
      }
    },
    "b61fb267b92b2736920b4bd0c673d31e7632ebb9": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9390. Block management for maintenance states.\n",
      "commitDate": "17/10/16 5:45 PM",
      "commitName": "b61fb267b92b2736920b4bd0c673d31e7632ebb9",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "13/10/16 11:52 AM",
      "commitNameOld": "332a61fd74fd2a9874319232c583ab5d2c53ff03",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 4.25,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,14 +1,24 @@\n   public void startMaintenance(DatanodeDescriptor node,\n       long maintenanceExpireTimeInMS) {\n     // Even if the node is already in maintenance, we still need to adjust\n     // the expiration time.\n     node.setMaintenanceExpireTimeInMS(maintenanceExpireTimeInMS);\n     if (!node.isMaintenance()) {\n       // Update DN stats maintained by HeartbeatManager\n       hbManager.startMaintenance(node);\n+      // hbManager.startMaintenance will set dead node to IN_MAINTENANCE.\n+      if (node.isEnteringMaintenance()) {\n+        for (DatanodeStorageInfo storage : node.getStorageInfos()) {\n+          LOG.info(\"Starting maintenance of {} {} with {} blocks\",\n+              node, storage, storage.numBlocks());\n+        }\n+        node.getLeavingServiceStatus().setStartTime(monotonicNow());\n+      }\n+      // Track the node regardless whether it is ENTERING_MAINTENANCE or\n+      // IN_MAINTENANCE to support maintenance expiration.\n       pendingNodes.add(node);\n     } else {\n       LOG.trace(\"startMaintenance: Node {} in {}, nothing to do.\" +\n           node, node.getAdminState());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void startMaintenance(DatanodeDescriptor node,\n      long maintenanceExpireTimeInMS) {\n    // Even if the node is already in maintenance, we still need to adjust\n    // the expiration time.\n    node.setMaintenanceExpireTimeInMS(maintenanceExpireTimeInMS);\n    if (!node.isMaintenance()) {\n      // Update DN stats maintained by HeartbeatManager\n      hbManager.startMaintenance(node);\n      // hbManager.startMaintenance will set dead node to IN_MAINTENANCE.\n      if (node.isEnteringMaintenance()) {\n        for (DatanodeStorageInfo storage : node.getStorageInfos()) {\n          LOG.info(\"Starting maintenance of {} {} with {} blocks\",\n              node, storage, storage.numBlocks());\n        }\n        node.getLeavingServiceStatus().setStartTime(monotonicNow());\n      }\n      // Track the node regardless whether it is ENTERING_MAINTENANCE or\n      // IN_MAINTENANCE to support maintenance expiration.\n      pendingNodes.add(node);\n    } else {\n      LOG.trace(\"startMaintenance: Node {} in {}, nothing to do.\" +\n          node, node.getAdminState());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DecommissionManager.java",
      "extendedDetails": {}
    },
    "9dcbdbdb5a34d85910707f81ebc1bb1f81c99978": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-9392. Admins support for maintenance state. Contributed by Ming Ma.\n",
      "commitDate": "30/08/16 2:00 PM",
      "commitName": "9dcbdbdb5a34d85910707f81ebc1bb1f81c99978",
      "commitAuthor": "Ming Ma",
      "diff": "@@ -0,0 +1,14 @@\n+  public void startMaintenance(DatanodeDescriptor node,\n+      long maintenanceExpireTimeInMS) {\n+    // Even if the node is already in maintenance, we still need to adjust\n+    // the expiration time.\n+    node.setMaintenanceExpireTimeInMS(maintenanceExpireTimeInMS);\n+    if (!node.isMaintenance()) {\n+      // Update DN stats maintained by HeartbeatManager\n+      hbManager.startMaintenance(node);\n+      pendingNodes.add(node);\n+    } else {\n+      LOG.trace(\"startMaintenance: Node {} in {}, nothing to do.\" +\n+          node, node.getAdminState());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void startMaintenance(DatanodeDescriptor node,\n      long maintenanceExpireTimeInMS) {\n    // Even if the node is already in maintenance, we still need to adjust\n    // the expiration time.\n    node.setMaintenanceExpireTimeInMS(maintenanceExpireTimeInMS);\n    if (!node.isMaintenance()) {\n      // Update DN stats maintained by HeartbeatManager\n      hbManager.startMaintenance(node);\n      pendingNodes.add(node);\n    } else {\n      LOG.trace(\"startMaintenance: Node {} in {}, nothing to do.\" +\n          node, node.getAdminState());\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/DecommissionManager.java"
    }
  }
}