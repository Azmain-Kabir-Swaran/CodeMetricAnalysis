{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "S3AFileSystem.java",
  "functionName": "create",
  "functionId": "create___f-Path__permission-FsPermission__overwrite-boolean__bufferSize-int__replication-short__blockSize-long__progress-Progressable",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
  "functionStartLine": 1204,
  "functionEndLine": 1251,
  "numCommitsSeen": 141,
  "timeTaken": 8605,
  "changeHistory": [
    "9221704f857e33a5f9e00c19d3705e46e94f427b",
    "1093a73689912f78547e6d23023be2fd1c7ddc85",
    "f274fe33ea359d26a31efec42a856320a0dbb5f4",
    "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c",
    "ef450df443f1dea1c52082cf281f25db7141972f",
    "35ad9b1dd279b769381ea1625d9bf776c309c5cb",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
    "49467165a57fb77932d1d526796624b88ebacd91",
    "621b43e254afaff708cd6fc4698b29628f6abc33",
    "2158496f6bed5f9d14751b82bd5d43b9fd786b95",
    "9ae270af02c243993f853513c731cb268430e492",
    "6c348c56918973fd988b110e79231324a8befe12",
    "86ae218893d018638e937c2528c8e84336254da7",
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944",
    "27c4e90efce04e1b1302f668b5eb22412e00d033",
    "d5403747b57b1e294e533ce17f197e7be8f5339c",
    "15b7076ad5f2ae92d231140b2f8cebc392a92c87",
    "27d8395867f665fea1360087325cda5ed70efd0c",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0"
  ],
  "changeHistoryShort": {
    "9221704f857e33a5f9e00c19d3705e46e94f427b": "Ybodychange",
    "1093a73689912f78547e6d23023be2fd1c7ddc85": "Ybodychange",
    "f274fe33ea359d26a31efec42a856320a0dbb5f4": "Ybodychange",
    "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c": "Ybodychange",
    "ef450df443f1dea1c52082cf281f25db7141972f": "Ybodychange",
    "35ad9b1dd279b769381ea1625d9bf776c309c5cb": "Ybodychange",
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": "Ybodychange",
    "49467165a57fb77932d1d526796624b88ebacd91": "Ybodychange",
    "621b43e254afaff708cd6fc4698b29628f6abc33": "Ybodychange",
    "2158496f6bed5f9d14751b82bd5d43b9fd786b95": "Ybodychange",
    "9ae270af02c243993f853513c731cb268430e492": "Ybodychange",
    "6c348c56918973fd988b110e79231324a8befe12": "Ybodychange",
    "86ae218893d018638e937c2528c8e84336254da7": "Ybodychange",
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944": "Ybodychange",
    "27c4e90efce04e1b1302f668b5eb22412e00d033": "Ybodychange",
    "d5403747b57b1e294e533ce17f197e7be8f5339c": "Ybodychange",
    "15b7076ad5f2ae92d231140b2f8cebc392a92c87": "Ybodychange",
    "27d8395867f665fea1360087325cda5ed70efd0c": "Ybodychange",
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9221704f857e33a5f9e00c19d3705e46e94f427b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16490. Avoid/handle cached 404s during S3A file creation.\n\nContributed by Steve Loughran.\n\nThis patch avoids issuing any HEAD path request when creating a file with overwrite\u003dtrue,\nso 404s will not end up in the S3 load balancers unless someone calls getFileStatus/exists/isFile\nin their own code.\n\nThe Hadoop FsShell CommandWithDestination class is modified to not register uncreated files\nfor deleteOnExit(), because that calls exists() and so can place the 404 in the cache, even\nafter S3A is patched to not do it itself.\n\nBecause S3Guard knows when a file should be present, it adds a special FileNotFound retry policy\nindependently configurable from other retry policies; it is also exponential, but with\ndifferent parameters. This is because every HEAD request will refresh any 404 cached in\nthe S3 Load Balancers. It\u0027s not enough to retry: we have to have a suitable gap between\nattempts to (hopefully) ensure any cached entry wil be gone.\n\nThe options and values are:\n\nfs.s3a.s3guard.consistency.retry.interval: 2s\nfs.s3a.s3guard.consistency.retry.limit: 7\n\nThe S3A copy() method used during rename() raises a RemoteFileChangedException which is not caught\nso not downgraded to false. Thus: when a rename is unrecoverable, this fact is propagated.\n\nCopy operations without S3Guard lack the confidence that the file exists, so don\u0027t retry the same way:\nit will fail fast with a different error message. However, because create(path, overwrite\u003dfalse) no\nlonger does HEAD path, we can at least be confident that S3A itself is not creating those cached\n404 markers.\n\nChange-Id: Ia7807faad8b9a8546836cb19f816cccf17cca26d\n",
      "commitDate": "11/09/19 8:46 AM",
      "commitName": "9221704f857e33a5f9e00c19d3705e46e94f427b",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/09/19 6:25 AM",
      "commitNameOld": "511df1e837b19ccb9271520589452d82d50ac69d",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 6.1,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,48 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n     entryPoint(INVOCATION_CREATE);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     FileStatus status \u003d null;\n     try {\n-      // get the status or throw an FNFE\n-      status \u003d getFileStatus(path);\n+      // get the status or throw an FNFE.\n+      // when overwriting, there is no need to look for any existing file,\n+      // and attempting to do so can poison the load balancers with 404\n+      // entries.\n+      status \u003d innerGetFileStatus(path, false,\n+          overwrite\n+              ? StatusProbeEnum.DIRECTORIES\n+              : StatusProbeEnum.ALL);\n \n       // if the thread reaches here, there is something at the path\n       if (status.isDirectory()) {\n         // path references a directory: automatic error\n         throw new FileAlreadyExistsException(path + \" is a directory\");\n       }\n       if (!overwrite) {\n         // path references a file and overwrite is disabled\n         throw new FileAlreadyExistsException(path + \" already exists\");\n       }\n       LOG.debug(\"Overwriting file {}\", path);\n     } catch (FileNotFoundException e) {\n       // this means the file is not found\n \n     }\n     instrumentation.fileCreated();\n     PutTracker putTracker \u003d\n         committerIntegration.createTracker(path, key);\n     String destKey \u003d putTracker.getDestKey();\n     return new FSDataOutputStream(\n         new S3ABlockOutputStream(this,\n             destKey,\n             new SemaphoredDelegatingExecutor(boundedThreadPool,\n                 blockOutputActiveBlocks, true),\n             progress,\n             partSize,\n             blockFactory,\n             instrumentation.newOutputStreamStatistics(statistics),\n             getWriteOperationHelper(),\n             putTracker),\n         null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    entryPoint(INVOCATION_CREATE);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    FileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE.\n      // when overwriting, there is no need to look for any existing file,\n      // and attempting to do so can poison the load balancers with 404\n      // entries.\n      status \u003d innerGetFileStatus(path, false,\n          overwrite\n              ? StatusProbeEnum.DIRECTORIES\n              : StatusProbeEnum.ALL);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(path + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(path + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", path);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    PutTracker putTracker \u003d\n        committerIntegration.createTracker(path, key);\n    String destKey \u003d putTracker.getDestKey();\n    return new FSDataOutputStream(\n        new S3ABlockOutputStream(this,\n            destKey,\n            new SemaphoredDelegatingExecutor(boundedThreadPool,\n                blockOutputActiveBlocks, true),\n            progress,\n            partSize,\n            blockFactory,\n            instrumentation.newOutputStreamStatistics(statistics),\n            getWriteOperationHelper(),\n            putTracker),\n        null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "1093a73689912f78547e6d23023be2fd1c7ddc85": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13974. S3Guard CLI to support list/purge of pending multipart commits.\nContributed by Aaron Fabbri\n",
      "commitDate": "18/01/18 5:13 AM",
      "commitName": "1093a73689912f78547e6d23023be2fd1c7ddc85",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/01/18 4:35 AM",
      "commitNameOld": "f274fe33ea359d26a31efec42a856320a0dbb5f4",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.03,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n     entryPoint(INVOCATION_CREATE);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     FileStatus status \u003d null;\n     try {\n       // get the status or throw an FNFE\n       status \u003d getFileStatus(path);\n \n       // if the thread reaches here, there is something at the path\n       if (status.isDirectory()) {\n         // path references a directory: automatic error\n         throw new FileAlreadyExistsException(path + \" is a directory\");\n       }\n       if (!overwrite) {\n         // path references a file and overwrite is disabled\n         throw new FileAlreadyExistsException(path + \" already exists\");\n       }\n       LOG.debug(\"Overwriting file {}\", path);\n     } catch (FileNotFoundException e) {\n       // this means the file is not found\n \n     }\n     instrumentation.fileCreated();\n     PutTracker putTracker \u003d\n         committerIntegration.createTracker(path, key);\n     String destKey \u003d putTracker.getDestKey();\n     return new FSDataOutputStream(\n         new S3ABlockOutputStream(this,\n             destKey,\n             new SemaphoredDelegatingExecutor(boundedThreadPool,\n                 blockOutputActiveBlocks, true),\n             progress,\n             partSize,\n             blockFactory,\n             instrumentation.newOutputStreamStatistics(statistics),\n-            createWriteOperationHelper(),\n+            getWriteOperationHelper(),\n             putTracker),\n         null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    entryPoint(INVOCATION_CREATE);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    FileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE\n      status \u003d getFileStatus(path);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(path + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(path + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", path);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    PutTracker putTracker \u003d\n        committerIntegration.createTracker(path, key);\n    String destKey \u003d putTracker.getDestKey();\n    return new FSDataOutputStream(\n        new S3ABlockOutputStream(this,\n            destKey,\n            new SemaphoredDelegatingExecutor(boundedThreadPool,\n                blockOutputActiveBlocks, true),\n            progress,\n            partSize,\n            blockFactory,\n            instrumentation.newOutputStreamStatistics(statistics),\n            getWriteOperationHelper(),\n            putTracker),\n        null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "f274fe33ea359d26a31efec42a856320a0dbb5f4": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13974. S3Guard CLI to support list/purge of pending multipart commits.\"\n\nThis reverts commit 35ad9b1dd279b769381ea1625d9bf776c309c5cb.\n",
      "commitDate": "18/01/18 4:35 AM",
      "commitName": "f274fe33ea359d26a31efec42a856320a0dbb5f4",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/01/18 12:05 AM",
      "commitNameOld": "268ab4e0279b3e40f4a627d3dfe91e2a3523a8cc",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 1.19,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n     entryPoint(INVOCATION_CREATE);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     FileStatus status \u003d null;\n     try {\n       // get the status or throw an FNFE\n       status \u003d getFileStatus(path);\n \n       // if the thread reaches here, there is something at the path\n       if (status.isDirectory()) {\n         // path references a directory: automatic error\n         throw new FileAlreadyExistsException(path + \" is a directory\");\n       }\n       if (!overwrite) {\n         // path references a file and overwrite is disabled\n         throw new FileAlreadyExistsException(path + \" already exists\");\n       }\n       LOG.debug(\"Overwriting file {}\", path);\n     } catch (FileNotFoundException e) {\n       // this means the file is not found\n \n     }\n     instrumentation.fileCreated();\n     PutTracker putTracker \u003d\n         committerIntegration.createTracker(path, key);\n     String destKey \u003d putTracker.getDestKey();\n     return new FSDataOutputStream(\n         new S3ABlockOutputStream(this,\n             destKey,\n             new SemaphoredDelegatingExecutor(boundedThreadPool,\n                 blockOutputActiveBlocks, true),\n             progress,\n             partSize,\n             blockFactory,\n             instrumentation.newOutputStreamStatistics(statistics),\n-            getWriteOperationHelper(),\n+            createWriteOperationHelper(),\n             putTracker),\n         null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    entryPoint(INVOCATION_CREATE);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    FileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE\n      status \u003d getFileStatus(path);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(path + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(path + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", path);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    PutTracker putTracker \u003d\n        committerIntegration.createTracker(path, key);\n    String destKey \u003d putTracker.getDestKey();\n    return new FSDataOutputStream(\n        new S3ABlockOutputStream(this,\n            destKey,\n            new SemaphoredDelegatingExecutor(boundedThreadPool,\n                blockOutputActiveBlocks, true),\n            progress,\n            partSize,\n            blockFactory,\n            instrumentation.newOutputStreamStatistics(statistics),\n            createWriteOperationHelper(),\n            putTracker),\n        null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15161. s3a: Stream and common statistics missing from metrics\nContributed by Sean Mackrory\n",
      "commitDate": "09/01/18 10:46 AM",
      "commitName": "b62a5ece95a6b5bbb17f273debd55bcbf0c5f28c",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "21/12/17 6:58 AM",
      "commitNameOld": "c8ff0cc304f07bf793192291e0611b2fb4bcc4e3",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 19.16,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n-    checkNotClosed();\n+    entryPoint(INVOCATION_CREATE);\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     FileStatus status \u003d null;\n     try {\n       // get the status or throw an FNFE\n       status \u003d getFileStatus(path);\n \n       // if the thread reaches here, there is something at the path\n       if (status.isDirectory()) {\n         // path references a directory: automatic error\n         throw new FileAlreadyExistsException(path + \" is a directory\");\n       }\n       if (!overwrite) {\n         // path references a file and overwrite is disabled\n         throw new FileAlreadyExistsException(path + \" already exists\");\n       }\n       LOG.debug(\"Overwriting file {}\", path);\n     } catch (FileNotFoundException e) {\n       // this means the file is not found\n \n     }\n     instrumentation.fileCreated();\n     PutTracker putTracker \u003d\n         committerIntegration.createTracker(path, key);\n     String destKey \u003d putTracker.getDestKey();\n     return new FSDataOutputStream(\n         new S3ABlockOutputStream(this,\n             destKey,\n             new SemaphoredDelegatingExecutor(boundedThreadPool,\n                 blockOutputActiveBlocks, true),\n             progress,\n             partSize,\n             blockFactory,\n             instrumentation.newOutputStreamStatistics(statistics),\n             getWriteOperationHelper(),\n             putTracker),\n         null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    entryPoint(INVOCATION_CREATE);\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    FileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE\n      status \u003d getFileStatus(path);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(path + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(path + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", path);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    PutTracker putTracker \u003d\n        committerIntegration.createTracker(path, key);\n    String destKey \u003d putTracker.getDestKey();\n    return new FSDataOutputStream(\n        new S3ABlockOutputStream(this,\n            destKey,\n            new SemaphoredDelegatingExecutor(boundedThreadPool,\n                blockOutputActiveBlocks, true),\n            progress,\n            partSize,\n            blockFactory,\n            instrumentation.newOutputStreamStatistics(statistics),\n            getWriteOperationHelper(),\n            putTracker),\n        null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "ef450df443f1dea1c52082cf281f25db7141972f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15113. NPE in S3A getFileStatus: null instrumentation on using closed instance.\nContributed by Steve Loughran.\n",
      "commitDate": "21/12/17 6:15 AM",
      "commitName": "ef450df443f1dea1c52082cf281f25db7141972f",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/12/17 1:19 PM",
      "commitNameOld": "35ad9b1dd279b769381ea1625d9bf776c309c5cb",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 2.71,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,42 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n+    checkNotClosed();\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     FileStatus status \u003d null;\n     try {\n       // get the status or throw an FNFE\n       status \u003d getFileStatus(path);\n \n       // if the thread reaches here, there is something at the path\n       if (status.isDirectory()) {\n         // path references a directory: automatic error\n         throw new FileAlreadyExistsException(path + \" is a directory\");\n       }\n       if (!overwrite) {\n         // path references a file and overwrite is disabled\n         throw new FileAlreadyExistsException(path + \" already exists\");\n       }\n       LOG.debug(\"Overwriting file {}\", path);\n     } catch (FileNotFoundException e) {\n       // this means the file is not found\n \n     }\n     instrumentation.fileCreated();\n     PutTracker putTracker \u003d\n         committerIntegration.createTracker(path, key);\n     String destKey \u003d putTracker.getDestKey();\n     return new FSDataOutputStream(\n         new S3ABlockOutputStream(this,\n             destKey,\n             new SemaphoredDelegatingExecutor(boundedThreadPool,\n                 blockOutputActiveBlocks, true),\n             progress,\n             partSize,\n             blockFactory,\n             instrumentation.newOutputStreamStatistics(statistics),\n             getWriteOperationHelper(),\n             putTracker),\n         null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    checkNotClosed();\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    FileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE\n      status \u003d getFileStatus(path);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(path + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(path + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", path);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    PutTracker putTracker \u003d\n        committerIntegration.createTracker(path, key);\n    String destKey \u003d putTracker.getDestKey();\n    return new FSDataOutputStream(\n        new S3ABlockOutputStream(this,\n            destKey,\n            new SemaphoredDelegatingExecutor(boundedThreadPool,\n                blockOutputActiveBlocks, true),\n            progress,\n            partSize,\n            blockFactory,\n            instrumentation.newOutputStreamStatistics(statistics),\n            getWriteOperationHelper(),\n            putTracker),\n        null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "35ad9b1dd279b769381ea1625d9bf776c309c5cb": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13974. S3Guard CLI to support list/purge of pending multipart commits.\nContributed by Aaron Fabbri\n",
      "commitDate": "18/12/17 1:19 PM",
      "commitName": "35ad9b1dd279b769381ea1625d9bf776c309c5cb",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "13/12/17 7:14 PM",
      "commitNameOld": "f86c81d923ecce9d1c9fb691bbc78e93b4a65ae7",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 4.75,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,41 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n     final Path path \u003d qualify(f);\n     String key \u003d pathToKey(path);\n     FileStatus status \u003d null;\n     try {\n       // get the status or throw an FNFE\n       status \u003d getFileStatus(path);\n \n       // if the thread reaches here, there is something at the path\n       if (status.isDirectory()) {\n         // path references a directory: automatic error\n         throw new FileAlreadyExistsException(path + \" is a directory\");\n       }\n       if (!overwrite) {\n         // path references a file and overwrite is disabled\n         throw new FileAlreadyExistsException(path + \" already exists\");\n       }\n       LOG.debug(\"Overwriting file {}\", path);\n     } catch (FileNotFoundException e) {\n       // this means the file is not found\n \n     }\n     instrumentation.fileCreated();\n     PutTracker putTracker \u003d\n         committerIntegration.createTracker(path, key);\n     String destKey \u003d putTracker.getDestKey();\n     return new FSDataOutputStream(\n         new S3ABlockOutputStream(this,\n             destKey,\n             new SemaphoredDelegatingExecutor(boundedThreadPool,\n                 blockOutputActiveBlocks, true),\n             progress,\n             partSize,\n             blockFactory,\n             instrumentation.newOutputStreamStatistics(statistics),\n-            createWriteOperationHelper(),\n+            getWriteOperationHelper(),\n             putTracker),\n         null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    FileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE\n      status \u003d getFileStatus(path);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(path + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(path + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", path);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    PutTracker putTracker \u003d\n        committerIntegration.createTracker(path, key);\n    String destKey \u003d putTracker.getDestKey();\n    return new FSDataOutputStream(\n        new S3ABlockOutputStream(this,\n            destKey,\n            new SemaphoredDelegatingExecutor(boundedThreadPool,\n                blockOutputActiveBlocks, true),\n            progress,\n            partSize,\n            blockFactory,\n            instrumentation.newOutputStreamStatistics(statistics),\n            getWriteOperationHelper(),\n            putTracker),\n        null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "de8b6ca5ef8614de6d6277b7617e27c788b0555c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13786 Add S3A committer for zero-rename commits to S3 endpoints.\nContributed by Steve Loughran and Ryan Blue.\n",
      "commitDate": "22/11/17 7:28 AM",
      "commitName": "de8b6ca5ef8614de6d6277b7617e27c788b0555c",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "25/09/17 3:59 PM",
      "commitNameOld": "47011d7dd300b0c74bb6cfe25b918c479d718f4f",
      "commitAuthorOld": "Aaron Fabbri",
      "daysBetweenCommits": 57.69,
      "commitsBetweenForRepo": 477,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,41 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n-    String key \u003d pathToKey(f);\n+    final Path path \u003d qualify(f);\n+    String key \u003d pathToKey(path);\n     FileStatus status \u003d null;\n     try {\n       // get the status or throw an FNFE\n-      status \u003d getFileStatus(f);\n+      status \u003d getFileStatus(path);\n \n       // if the thread reaches here, there is something at the path\n       if (status.isDirectory()) {\n         // path references a directory: automatic error\n-        throw new FileAlreadyExistsException(f + \" is a directory\");\n+        throw new FileAlreadyExistsException(path + \" is a directory\");\n       }\n       if (!overwrite) {\n         // path references a file and overwrite is disabled\n-        throw new FileAlreadyExistsException(f + \" already exists\");\n+        throw new FileAlreadyExistsException(path + \" already exists\");\n       }\n-      LOG.debug(\"Overwriting file {}\", f);\n+      LOG.debug(\"Overwriting file {}\", path);\n     } catch (FileNotFoundException e) {\n       // this means the file is not found\n \n     }\n     instrumentation.fileCreated();\n+    PutTracker putTracker \u003d\n+        committerIntegration.createTracker(path, key);\n+    String destKey \u003d putTracker.getDestKey();\n     return new FSDataOutputStream(\n         new S3ABlockOutputStream(this,\n-            key,\n+            destKey,\n             new SemaphoredDelegatingExecutor(boundedThreadPool,\n                 blockOutputActiveBlocks, true),\n             progress,\n             partSize,\n             blockFactory,\n             instrumentation.newOutputStreamStatistics(statistics),\n-            new WriteOperationHelper(key)\n-        ),\n+            createWriteOperationHelper(),\n+            putTracker),\n         null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    final Path path \u003d qualify(f);\n    String key \u003d pathToKey(path);\n    FileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE\n      status \u003d getFileStatus(path);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(path + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(path + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", path);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    PutTracker putTracker \u003d\n        committerIntegration.createTracker(path, key);\n    String destKey \u003d putTracker.getDestKey();\n    return new FSDataOutputStream(\n        new S3ABlockOutputStream(this,\n            destKey,\n            new SemaphoredDelegatingExecutor(boundedThreadPool,\n                blockOutputActiveBlocks, true),\n            progress,\n            partSize,\n            blockFactory,\n            instrumentation.newOutputStreamStatistics(statistics),\n            createWriteOperationHelper(),\n            putTracker),\n        null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "49467165a57fb77932d1d526796624b88ebacd91": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14738 Remove S3N and obsolete bits of S3A; rework docs.  Contributed by Steve Loughran.\n",
      "commitDate": "14/09/17 2:10 PM",
      "commitName": "49467165a57fb77932d1d526796624b88ebacd91",
      "commitAuthor": "Aaron Fabbri",
      "commitDateOld": "08/09/17 4:07 AM",
      "commitNameOld": "5bbca80428ffbe776650652de86a3bba885edb31",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 6.42,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,37 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n     String key \u003d pathToKey(f);\n     FileStatus status \u003d null;\n     try {\n       // get the status or throw an FNFE\n       status \u003d getFileStatus(f);\n \n       // if the thread reaches here, there is something at the path\n       if (status.isDirectory()) {\n         // path references a directory: automatic error\n         throw new FileAlreadyExistsException(f + \" is a directory\");\n       }\n       if (!overwrite) {\n         // path references a file and overwrite is disabled\n         throw new FileAlreadyExistsException(f + \" already exists\");\n       }\n       LOG.debug(\"Overwriting file {}\", f);\n     } catch (FileNotFoundException e) {\n       // this means the file is not found\n \n     }\n     instrumentation.fileCreated();\n-    FSDataOutputStream output;\n-    if (blockUploadEnabled) {\n-      output \u003d new FSDataOutputStream(\n-          new S3ABlockOutputStream(this,\n-              key,\n-              new SemaphoredDelegatingExecutor(boundedThreadPool,\n-                  blockOutputActiveBlocks, true),\n-              progress,\n-              partSize,\n-              blockFactory,\n-              instrumentation.newOutputStreamStatistics(statistics),\n-              new WriteOperationHelper(key)\n-          ),\n-          null);\n-    } else {\n-\n-      // We pass null to FSDataOutputStream so it won\u0027t count writes that\n-      // are being buffered to a file\n-      output \u003d new FSDataOutputStream(\n-          new S3AOutputStream(getConf(),\n-              this,\n-              key,\n-              progress\n-          ),\n-          null);\n-    }\n-    return output;\n+    return new FSDataOutputStream(\n+        new S3ABlockOutputStream(this,\n+            key,\n+            new SemaphoredDelegatingExecutor(boundedThreadPool,\n+                blockOutputActiveBlocks, true),\n+            progress,\n+            partSize,\n+            blockFactory,\n+            instrumentation.newOutputStreamStatistics(statistics),\n+            new WriteOperationHelper(key)\n+        ),\n+        null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    String key \u003d pathToKey(f);\n    FileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE\n      status \u003d getFileStatus(f);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(f + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(f + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", f);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    return new FSDataOutputStream(\n        new S3ABlockOutputStream(this,\n            key,\n            new SemaphoredDelegatingExecutor(boundedThreadPool,\n                blockOutputActiveBlocks, true),\n            progress,\n            partSize,\n            blockFactory,\n            instrumentation.newOutputStreamStatistics(statistics),\n            new WriteOperationHelper(key)\n        ),\n        null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "621b43e254afaff708cd6fc4698b29628f6abc33": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13345 HS3Guard: Improved Consistency for S3A.\nContributed by: Chris Nauroth, Aaron Fabbri, Mingliang Liu, Lei (Eddy) Xu,\nSean Mackrory, Steve Loughran and others.\n",
      "commitDate": "01/09/17 6:13 AM",
      "commitName": "621b43e254afaff708cd6fc4698b29628f6abc33",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "05/06/17 11:26 AM",
      "commitNameOld": "6aeda55bb8f741d9dafd41f6dfbf1a88acdd4003",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 87.78,
      "commitsBetweenForRepo": 591,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n     String key \u003d pathToKey(f);\n-    S3AFileStatus status \u003d null;\n+    FileStatus status \u003d null;\n     try {\n       // get the status or throw an FNFE\n       status \u003d getFileStatus(f);\n \n       // if the thread reaches here, there is something at the path\n       if (status.isDirectory()) {\n         // path references a directory: automatic error\n         throw new FileAlreadyExistsException(f + \" is a directory\");\n       }\n       if (!overwrite) {\n         // path references a file and overwrite is disabled\n         throw new FileAlreadyExistsException(f + \" already exists\");\n       }\n       LOG.debug(\"Overwriting file {}\", f);\n     } catch (FileNotFoundException e) {\n       // this means the file is not found\n \n     }\n     instrumentation.fileCreated();\n     FSDataOutputStream output;\n     if (blockUploadEnabled) {\n       output \u003d new FSDataOutputStream(\n           new S3ABlockOutputStream(this,\n               key,\n               new SemaphoredDelegatingExecutor(boundedThreadPool,\n                   blockOutputActiveBlocks, true),\n               progress,\n               partSize,\n               blockFactory,\n               instrumentation.newOutputStreamStatistics(statistics),\n               new WriteOperationHelper(key)\n           ),\n           null);\n     } else {\n \n       // We pass null to FSDataOutputStream so it won\u0027t count writes that\n       // are being buffered to a file\n       output \u003d new FSDataOutputStream(\n           new S3AOutputStream(getConf(),\n               this,\n               key,\n               progress\n           ),\n           null);\n     }\n     return output;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    String key \u003d pathToKey(f);\n    FileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE\n      status \u003d getFileStatus(f);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(f + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(f + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", f);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    FSDataOutputStream output;\n    if (blockUploadEnabled) {\n      output \u003d new FSDataOutputStream(\n          new S3ABlockOutputStream(this,\n              key,\n              new SemaphoredDelegatingExecutor(boundedThreadPool,\n                  blockOutputActiveBlocks, true),\n              progress,\n              partSize,\n              blockFactory,\n              instrumentation.newOutputStreamStatistics(statistics),\n              new WriteOperationHelper(key)\n          ),\n          null);\n    } else {\n\n      // We pass null to FSDataOutputStream so it won\u0027t count writes that\n      // are being buffered to a file\n      output \u003d new FSDataOutputStream(\n          new S3AOutputStream(getConf(),\n              this,\n              key,\n              progress\n          ),\n          null);\n    }\n    return output;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "2158496f6bed5f9d14751b82bd5d43b9fd786b95": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13826. S3A Deadlock in multipart copy due to thread pool limits. Contributed by  Sean Mackrory.\n\n(cherry picked from commit e3a74e0369e6e2217d1280179b390227fe1b1684)\n",
      "commitDate": "21/02/17 10:28 AM",
      "commitName": "2158496f6bed5f9d14751b82bd5d43b9fd786b95",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "11/02/17 1:59 PM",
      "commitNameOld": "839b690ed5edc2ac4984640d58c005bb63cd8a07",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 9.85,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n     String key \u003d pathToKey(f);\n     S3AFileStatus status \u003d null;\n     try {\n       // get the status or throw an FNFE\n       status \u003d getFileStatus(f);\n \n       // if the thread reaches here, there is something at the path\n       if (status.isDirectory()) {\n         // path references a directory: automatic error\n         throw new FileAlreadyExistsException(f + \" is a directory\");\n       }\n       if (!overwrite) {\n         // path references a file and overwrite is disabled\n         throw new FileAlreadyExistsException(f + \" already exists\");\n       }\n       LOG.debug(\"Overwriting file {}\", f);\n     } catch (FileNotFoundException e) {\n       // this means the file is not found\n \n     }\n     instrumentation.fileCreated();\n     FSDataOutputStream output;\n     if (blockUploadEnabled) {\n       output \u003d new FSDataOutputStream(\n           new S3ABlockOutputStream(this,\n               key,\n-              new SemaphoredDelegatingExecutor(threadPoolExecutor,\n+              new SemaphoredDelegatingExecutor(boundedThreadPool,\n                   blockOutputActiveBlocks, true),\n               progress,\n               partSize,\n               blockFactory,\n               instrumentation.newOutputStreamStatistics(statistics),\n               new WriteOperationHelper(key)\n           ),\n           null);\n     } else {\n \n       // We pass null to FSDataOutputStream so it won\u0027t count writes that\n       // are being buffered to a file\n       output \u003d new FSDataOutputStream(\n           new S3AOutputStream(getConf(),\n               this,\n               key,\n               progress\n           ),\n           null);\n     }\n     return output;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    String key \u003d pathToKey(f);\n    S3AFileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE\n      status \u003d getFileStatus(f);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(f + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(f + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", f);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    FSDataOutputStream output;\n    if (blockUploadEnabled) {\n      output \u003d new FSDataOutputStream(\n          new S3ABlockOutputStream(this,\n              key,\n              new SemaphoredDelegatingExecutor(boundedThreadPool,\n                  blockOutputActiveBlocks, true),\n              progress,\n              partSize,\n              blockFactory,\n              instrumentation.newOutputStreamStatistics(statistics),\n              new WriteOperationHelper(key)\n          ),\n          null);\n    } else {\n\n      // We pass null to FSDataOutputStream so it won\u0027t count writes that\n      // are being buffered to a file\n      output \u003d new FSDataOutputStream(\n          new S3AOutputStream(getConf(),\n              this,\n              key,\n              progress\n          ),\n          null);\n    }\n    return output;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "9ae270af02c243993f853513c731cb268430e492": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13735 ITestS3AFileContextStatistics.testStatistics() failing. Contributed by Pieter Reuse\n",
      "commitDate": "20/10/16 6:50 AM",
      "commitName": "9ae270af02c243993f853513c731cb268430e492",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "18/10/16 1:16 PM",
      "commitNameOld": "6c348c56918973fd988b110e79231324a8befe12",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 1.73,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n     String key \u003d pathToKey(f);\n     S3AFileStatus status \u003d null;\n     try {\n       // get the status or throw an FNFE\n       status \u003d getFileStatus(f);\n \n       // if the thread reaches here, there is something at the path\n       if (status.isDirectory()) {\n         // path references a directory: automatic error\n         throw new FileAlreadyExistsException(f + \" is a directory\");\n       }\n       if (!overwrite) {\n         // path references a file and overwrite is disabled\n         throw new FileAlreadyExistsException(f + \" already exists\");\n       }\n       LOG.debug(\"Overwriting file {}\", f);\n     } catch (FileNotFoundException e) {\n       // this means the file is not found\n \n     }\n     instrumentation.fileCreated();\n     FSDataOutputStream output;\n     if (blockUploadEnabled) {\n       output \u003d new FSDataOutputStream(\n           new S3ABlockOutputStream(this,\n               key,\n               new SemaphoredDelegatingExecutor(threadPoolExecutor,\n                   blockOutputActiveBlocks, true),\n               progress,\n               partSize,\n               blockFactory,\n-              instrumentation.newOutputStreamStatistics(),\n+              instrumentation.newOutputStreamStatistics(statistics),\n               new WriteOperationHelper(key)\n           ),\n           null);\n     } else {\n \n       // We pass null to FSDataOutputStream so it won\u0027t count writes that\n       // are being buffered to a file\n       output \u003d new FSDataOutputStream(\n           new S3AOutputStream(getConf(),\n               this,\n               key,\n               progress\n           ),\n           null);\n     }\n     return output;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    String key \u003d pathToKey(f);\n    S3AFileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE\n      status \u003d getFileStatus(f);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(f + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(f + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", f);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    FSDataOutputStream output;\n    if (blockUploadEnabled) {\n      output \u003d new FSDataOutputStream(\n          new S3ABlockOutputStream(this,\n              key,\n              new SemaphoredDelegatingExecutor(threadPoolExecutor,\n                  blockOutputActiveBlocks, true),\n              progress,\n              partSize,\n              blockFactory,\n              instrumentation.newOutputStreamStatistics(statistics),\n              new WriteOperationHelper(key)\n          ),\n          null);\n    } else {\n\n      // We pass null to FSDataOutputStream so it won\u0027t count writes that\n      // are being buffered to a file\n      output \u003d new FSDataOutputStream(\n          new S3AOutputStream(getConf(),\n              this,\n              key,\n              progress\n          ),\n          null);\n    }\n    return output;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "6c348c56918973fd988b110e79231324a8befe12": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13560. S3ABlockOutputStream to support huge (many GB) file writes. Contributed by Steve Loughran\n",
      "commitDate": "18/10/16 1:16 PM",
      "commitName": "6c348c56918973fd988b110e79231324a8befe12",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "07/10/16 4:51 AM",
      "commitNameOld": "ebd4f39a393e5fa9a810c6a36b749549229a53df",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 11.35,
      "commitsBetweenForRepo": 80,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,52 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n     String key \u003d pathToKey(f);\n     S3AFileStatus status \u003d null;\n     try {\n       // get the status or throw an FNFE\n       status \u003d getFileStatus(f);\n \n       // if the thread reaches here, there is something at the path\n       if (status.isDirectory()) {\n         // path references a directory: automatic error\n         throw new FileAlreadyExistsException(f + \" is a directory\");\n       }\n       if (!overwrite) {\n         // path references a file and overwrite is disabled\n         throw new FileAlreadyExistsException(f + \" already exists\");\n       }\n       LOG.debug(\"Overwriting file {}\", f);\n     } catch (FileNotFoundException e) {\n       // this means the file is not found\n \n     }\n     instrumentation.fileCreated();\n-    if (getConf().getBoolean(FAST_UPLOAD, DEFAULT_FAST_UPLOAD)) {\n-      return new FSDataOutputStream(\n-          new S3AFastOutputStream(s3,\n-              this,\n-              bucket,\n+    FSDataOutputStream output;\n+    if (blockUploadEnabled) {\n+      output \u003d new FSDataOutputStream(\n+          new S3ABlockOutputStream(this,\n               key,\n+              new SemaphoredDelegatingExecutor(threadPoolExecutor,\n+                  blockOutputActiveBlocks, true),\n               progress,\n-              cannedACL,\n               partSize,\n-              multiPartThreshold,\n-              threadPoolExecutor),\n-          statistics);\n+              blockFactory,\n+              instrumentation.newOutputStreamStatistics(),\n+              new WriteOperationHelper(key)\n+          ),\n+          null);\n+    } else {\n+\n+      // We pass null to FSDataOutputStream so it won\u0027t count writes that\n+      // are being buffered to a file\n+      output \u003d new FSDataOutputStream(\n+          new S3AOutputStream(getConf(),\n+              this,\n+              key,\n+              progress\n+          ),\n+          null);\n     }\n-    // We pass null to FSDataOutputStream so it won\u0027t count writes that\n-    // are being buffered to a file\n-    return new FSDataOutputStream(\n-        new S3AOutputStream(getConf(),\n-            this,\n-            key,\n-            progress\n-        ),\n-        null);\n+    return output;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    String key \u003d pathToKey(f);\n    S3AFileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE\n      status \u003d getFileStatus(f);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(f + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(f + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", f);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    FSDataOutputStream output;\n    if (blockUploadEnabled) {\n      output \u003d new FSDataOutputStream(\n          new S3ABlockOutputStream(this,\n              key,\n              new SemaphoredDelegatingExecutor(threadPoolExecutor,\n                  blockOutputActiveBlocks, true),\n              progress,\n              partSize,\n              blockFactory,\n              instrumentation.newOutputStreamStatistics(),\n              new WriteOperationHelper(key)\n          ),\n          null);\n    } else {\n\n      // We pass null to FSDataOutputStream so it won\u0027t count writes that\n      // are being buffered to a file\n      output \u003d new FSDataOutputStream(\n          new S3AOutputStream(getConf(),\n              this,\n              key,\n              progress\n          ),\n          null);\n    }\n    return output;\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "86ae218893d018638e937c2528c8e84336254da7": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13188 S3A file-create should throw error rather than overwrite directories. Contributed by Steve Loughran\n",
      "commitDate": "25/07/16 7:50 AM",
      "commitName": "86ae218893d018638e937c2528c8e84336254da7",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "25/07/16 6:45 AM",
      "commitNameOld": "be9e46b42dd1ed0b2295bd36a7d81d5ee6dffc25",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.05,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,47 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n     String key \u003d pathToKey(f);\n+    S3AFileStatus status \u003d null;\n+    try {\n+      // get the status or throw an FNFE\n+      status \u003d getFileStatus(f);\n \n-    if (!overwrite \u0026\u0026 exists(f)) {\n-      throw new FileAlreadyExistsException(f + \" already exists\");\n+      // if the thread reaches here, there is something at the path\n+      if (status.isDirectory()) {\n+        // path references a directory: automatic error\n+        throw new FileAlreadyExistsException(f + \" is a directory\");\n+      }\n+      if (!overwrite) {\n+        // path references a file and overwrite is disabled\n+        throw new FileAlreadyExistsException(f + \" already exists\");\n+      }\n+      LOG.debug(\"Overwriting file {}\", f);\n+    } catch (FileNotFoundException e) {\n+      // this means the file is not found\n+\n     }\n     instrumentation.fileCreated();\n     if (getConf().getBoolean(FAST_UPLOAD, DEFAULT_FAST_UPLOAD)) {\n       return new FSDataOutputStream(\n           new S3AFastOutputStream(s3,\n               this,\n               bucket,\n               key,\n               progress,\n               cannedACL,\n               partSize,\n               multiPartThreshold,\n               threadPoolExecutor),\n           statistics);\n     }\n     // We pass null to FSDataOutputStream so it won\u0027t count writes that\n     // are being buffered to a file\n     return new FSDataOutputStream(\n         new S3AOutputStream(getConf(),\n             this,\n             key,\n             progress\n         ),\n         null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    String key \u003d pathToKey(f);\n    S3AFileStatus status \u003d null;\n    try {\n      // get the status or throw an FNFE\n      status \u003d getFileStatus(f);\n\n      // if the thread reaches here, there is something at the path\n      if (status.isDirectory()) {\n        // path references a directory: automatic error\n        throw new FileAlreadyExistsException(f + \" is a directory\");\n      }\n      if (!overwrite) {\n        // path references a file and overwrite is disabled\n        throw new FileAlreadyExistsException(f + \" already exists\");\n      }\n      LOG.debug(\"Overwriting file {}\", f);\n    } catch (FileNotFoundException e) {\n      // this means the file is not found\n\n    }\n    instrumentation.fileCreated();\n    if (getConf().getBoolean(FAST_UPLOAD, DEFAULT_FAST_UPLOAD)) {\n      return new FSDataOutputStream(\n          new S3AFastOutputStream(s3,\n              this,\n              bucket,\n              key,\n              progress,\n              cannedACL,\n              partSize,\n              multiPartThreshold,\n              threadPoolExecutor),\n          statistics);\n    }\n    // We pass null to FSDataOutputStream so it won\u0027t count writes that\n    // are being buffered to a file\n    return new FSDataOutputStream(\n        new S3AOutputStream(getConf(),\n            this,\n            key,\n            progress\n        ),\n        null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "c58a59f7081d55dd2108545ebf9ee48cf43ca944": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13171. Add StorageStatistics to S3A; instrument some more operations. Contributed by Steve Loughran.\n",
      "commitDate": "03/06/16 8:55 AM",
      "commitName": "c58a59f7081d55dd2108545ebf9ee48cf43ca944",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "01/06/16 2:49 PM",
      "commitNameOld": "16b1cc7af9bd63b65ef50e1056f275a7baf111a2",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 1.75,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,32 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n     String key \u003d pathToKey(f);\n \n     if (!overwrite \u0026\u0026 exists(f)) {\n       throw new FileAlreadyExistsException(f + \" already exists\");\n     }\n     instrumentation.fileCreated();\n     if (getConf().getBoolean(FAST_UPLOAD, DEFAULT_FAST_UPLOAD)) {\n-      return new FSDataOutputStream(new S3AFastOutputStream(s3, this, bucket,\n-          key, progress, statistics, cannedACL,\n-          serverSideEncryptionAlgorithm, partSize, multiPartThreshold,\n-          threadPoolExecutor), statistics);\n+      return new FSDataOutputStream(\n+          new S3AFastOutputStream(s3,\n+              this,\n+              bucket,\n+              key,\n+              progress,\n+              cannedACL,\n+              partSize,\n+              multiPartThreshold,\n+              threadPoolExecutor),\n+          statistics);\n     }\n     // We pass null to FSDataOutputStream so it won\u0027t count writes that\n     // are being buffered to a file\n     return new FSDataOutputStream(\n         new S3AOutputStream(getConf(),\n-            transfers,\n             this,\n-            bucket,\n             key,\n-            progress,\n-            cannedACL,\n-            statistics,\n-            serverSideEncryptionAlgorithm),\n+            progress\n+        ),\n         null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    String key \u003d pathToKey(f);\n\n    if (!overwrite \u0026\u0026 exists(f)) {\n      throw new FileAlreadyExistsException(f + \" already exists\");\n    }\n    instrumentation.fileCreated();\n    if (getConf().getBoolean(FAST_UPLOAD, DEFAULT_FAST_UPLOAD)) {\n      return new FSDataOutputStream(\n          new S3AFastOutputStream(s3,\n              this,\n              bucket,\n              key,\n              progress,\n              cannedACL,\n              partSize,\n              multiPartThreshold,\n              threadPoolExecutor),\n          statistics);\n    }\n    // We pass null to FSDataOutputStream so it won\u0027t count writes that\n    // are being buffered to a file\n    return new FSDataOutputStream(\n        new S3AOutputStream(getConf(),\n            this,\n            key,\n            progress\n        ),\n        null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "27c4e90efce04e1b1302f668b5eb22412e00d033": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13028 add low level counter metrics for S3A; use in read performance tests. contributed by: stevel\npatch includes\nHADOOP-12844 Recover when S3A fails on IOException in read()\nHADOOP-13058 S3A FS fails during init against a read-only FS if multipart purge\nHADOOP-13047 S3a Forward seek in stream length to be configurable\n",
      "commitDate": "12/05/16 11:24 AM",
      "commitName": "27c4e90efce04e1b1302f668b5eb22412e00d033",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "12/05/16 5:57 AM",
      "commitNameOld": "def2a6d3856452d5c804f04e5bf485541a3bc53a",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,29 @@\n   public FSDataOutputStream create(Path f, FsPermission permission,\n       boolean overwrite, int bufferSize, short replication, long blockSize,\n       Progressable progress) throws IOException {\n     String key \u003d pathToKey(f);\n \n     if (!overwrite \u0026\u0026 exists(f)) {\n       throw new FileAlreadyExistsException(f + \" already exists\");\n     }\n+    instrumentation.fileCreated();\n     if (getConf().getBoolean(FAST_UPLOAD, DEFAULT_FAST_UPLOAD)) {\n       return new FSDataOutputStream(new S3AFastOutputStream(s3, this, bucket,\n           key, progress, statistics, cannedACL,\n           serverSideEncryptionAlgorithm, partSize, multiPartThreshold,\n           threadPoolExecutor), statistics);\n     }\n-    // We pass null to FSDataOutputStream so it won\u0027t count writes that are being buffered to a file\n-    return new FSDataOutputStream(new S3AOutputStream(getConf(), transfers, this,\n-      bucket, key, progress, cannedACL, statistics,\n-      serverSideEncryptionAlgorithm), null);\n+    // We pass null to FSDataOutputStream so it won\u0027t count writes that\n+    // are being buffered to a file\n+    return new FSDataOutputStream(\n+        new S3AOutputStream(getConf(),\n+            transfers,\n+            this,\n+            bucket,\n+            key,\n+            progress,\n+            cannedACL,\n+            statistics,\n+            serverSideEncryptionAlgorithm),\n+        null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission,\n      boolean overwrite, int bufferSize, short replication, long blockSize,\n      Progressable progress) throws IOException {\n    String key \u003d pathToKey(f);\n\n    if (!overwrite \u0026\u0026 exists(f)) {\n      throw new FileAlreadyExistsException(f + \" already exists\");\n    }\n    instrumentation.fileCreated();\n    if (getConf().getBoolean(FAST_UPLOAD, DEFAULT_FAST_UPLOAD)) {\n      return new FSDataOutputStream(new S3AFastOutputStream(s3, this, bucket,\n          key, progress, statistics, cannedACL,\n          serverSideEncryptionAlgorithm, partSize, multiPartThreshold,\n          threadPoolExecutor), statistics);\n    }\n    // We pass null to FSDataOutputStream so it won\u0027t count writes that\n    // are being buffered to a file\n    return new FSDataOutputStream(\n        new S3AOutputStream(getConf(),\n            transfers,\n            this,\n            bucket,\n            key,\n            progress,\n            cannedACL,\n            statistics,\n            serverSideEncryptionAlgorithm),\n        null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "d5403747b57b1e294e533ce17f197e7be8f5339c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12269. Update aws-sdk dependency to 1.10.6 (Thomas Demoor via Lei (Eddy) Xu)\n",
      "commitDate": "04/08/15 6:51 PM",
      "commitName": "d5403747b57b1e294e533ce17f197e7be8f5339c",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "08/03/15 11:22 AM",
      "commitNameOld": "64443490d7f189e8e42d284615f3814ef751395a",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 149.31,
      "commitsBetweenForRepo": 1216,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,18 +1,18 @@\n   public FSDataOutputStream create(Path f, FsPermission permission, boolean overwrite, \n     int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {\n     String key \u003d pathToKey(f);\n \n     if (!overwrite \u0026\u0026 exists(f)) {\n       throw new FileAlreadyExistsException(f + \" already exists\");\n     }\n     if (getConf().getBoolean(FAST_UPLOAD, DEFAULT_FAST_UPLOAD)) {\n       return new FSDataOutputStream(new S3AFastOutputStream(s3, this, bucket,\n           key, progress, statistics, cannedACL,\n-          serverSideEncryptionAlgorithm, partSize, (long)multiPartThreshold,\n+          serverSideEncryptionAlgorithm, partSize, multiPartThreshold,\n           threadPoolExecutor), statistics);\n     }\n     // We pass null to FSDataOutputStream so it won\u0027t count writes that are being buffered to a file\n     return new FSDataOutputStream(new S3AOutputStream(getConf(), transfers, this,\n       bucket, key, progress, cannedACL, statistics, \n       serverSideEncryptionAlgorithm), null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission, boolean overwrite, \n    int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {\n    String key \u003d pathToKey(f);\n\n    if (!overwrite \u0026\u0026 exists(f)) {\n      throw new FileAlreadyExistsException(f + \" already exists\");\n    }\n    if (getConf().getBoolean(FAST_UPLOAD, DEFAULT_FAST_UPLOAD)) {\n      return new FSDataOutputStream(new S3AFastOutputStream(s3, this, bucket,\n          key, progress, statistics, cannedACL,\n          serverSideEncryptionAlgorithm, partSize, multiPartThreshold,\n          threadPoolExecutor), statistics);\n    }\n    // We pass null to FSDataOutputStream so it won\u0027t count writes that are being buffered to a file\n    return new FSDataOutputStream(new S3AOutputStream(getConf(), transfers, this,\n      bucket, key, progress, cannedACL, statistics, \n      serverSideEncryptionAlgorithm), null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "15b7076ad5f2ae92d231140b2f8cebc392a92c87": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11183. Memory-based S3AOutputstream. (Thomas Demoor via stevel)\n",
      "commitDate": "03/03/15 4:18 PM",
      "commitName": "15b7076ad5f2ae92d231140b2f8cebc392a92c87",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "21/02/15 4:03 AM",
      "commitNameOld": "709ff99cff4124823bde631e272af7be9a22f83b",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 10.51,
      "commitsBetweenForRepo": 77,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,18 @@\n   public FSDataOutputStream create(Path f, FsPermission permission, boolean overwrite, \n     int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {\n     String key \u003d pathToKey(f);\n \n     if (!overwrite \u0026\u0026 exists(f)) {\n       throw new FileAlreadyExistsException(f + \" already exists\");\n     }\n-\n+    if (getConf().getBoolean(FAST_UPLOAD, DEFAULT_FAST_UPLOAD)) {\n+      return new FSDataOutputStream(new S3AFastOutputStream(s3, this, bucket,\n+          key, progress, statistics, cannedACL,\n+          serverSideEncryptionAlgorithm, partSize, (long)multiPartThreshold,\n+          threadPoolExecutor), statistics);\n+    }\n     // We pass null to FSDataOutputStream so it won\u0027t count writes that are being buffered to a file\n     return new FSDataOutputStream(new S3AOutputStream(getConf(), transfers, this,\n       bucket, key, progress, cannedACL, statistics, \n       serverSideEncryptionAlgorithm), null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission, boolean overwrite, \n    int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {\n    String key \u003d pathToKey(f);\n\n    if (!overwrite \u0026\u0026 exists(f)) {\n      throw new FileAlreadyExistsException(f + \" already exists\");\n    }\n    if (getConf().getBoolean(FAST_UPLOAD, DEFAULT_FAST_UPLOAD)) {\n      return new FSDataOutputStream(new S3AFastOutputStream(s3, this, bucket,\n          key, progress, statistics, cannedACL,\n          serverSideEncryptionAlgorithm, partSize, (long)multiPartThreshold,\n          threadPoolExecutor), statistics);\n    }\n    // We pass null to FSDataOutputStream so it won\u0027t count writes that are being buffered to a file\n    return new FSDataOutputStream(new S3AOutputStream(getConf(), transfers, this,\n      bucket, key, progress, cannedACL, statistics, \n      serverSideEncryptionAlgorithm), null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "27d8395867f665fea1360087325cda5ed70efd0c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11446 S3AOutputStream should use shared thread pool to avoid OutOfMemoryError\n",
      "commitDate": "05/01/15 5:00 AM",
      "commitName": "27d8395867f665fea1360087325cda5ed70efd0c",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "09/12/14 8:45 PM",
      "commitNameOld": "2e98ad34ce64a9e5184c53447004de20a637f927",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 26.34,
      "commitsBetweenForRepo": 126,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,13 +1,13 @@\n   public FSDataOutputStream create(Path f, FsPermission permission, boolean overwrite, \n     int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {\n     String key \u003d pathToKey(f);\n \n     if (!overwrite \u0026\u0026 exists(f)) {\n       throw new FileAlreadyExistsException(f + \" already exists\");\n     }\n \n     // We pass null to FSDataOutputStream so it won\u0027t count writes that are being buffered to a file\n-    return new FSDataOutputStream(new S3AOutputStream(getConf(), s3, this, \n+    return new FSDataOutputStream(new S3AOutputStream(getConf(), transfers, this,\n       bucket, key, progress, cannedACL, statistics, \n       serverSideEncryptionAlgorithm), null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission, boolean overwrite, \n    int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {\n    String key \u003d pathToKey(f);\n\n    if (!overwrite \u0026\u0026 exists(f)) {\n      throw new FileAlreadyExistsException(f + \" already exists\");\n    }\n\n    // We pass null to FSDataOutputStream so it won\u0027t count writes that are being buffered to a file\n    return new FSDataOutputStream(new S3AOutputStream(getConf(), transfers, this,\n      bucket, key, progress, cannedACL, statistics, \n      serverSideEncryptionAlgorithm), null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java",
      "extendedDetails": {}
    },
    "24d920b80eb3626073925a1d0b6dcf148add8cc0": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10400. Incorporate new S3A FileSystem implementation. Contributed by Jordan Mendelson and Dave Wang.\n",
      "commitDate": "15/09/14 8:27 AM",
      "commitName": "24d920b80eb3626073925a1d0b6dcf148add8cc0",
      "commitAuthor": "Aaron T. Myers",
      "diff": "@@ -0,0 +1,13 @@\n+  public FSDataOutputStream create(Path f, FsPermission permission, boolean overwrite, \n+    int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {\n+    String key \u003d pathToKey(f);\n+\n+    if (!overwrite \u0026\u0026 exists(f)) {\n+      throw new FileAlreadyExistsException(f + \" already exists\");\n+    }\n+\n+    // We pass null to FSDataOutputStream so it won\u0027t count writes that are being buffered to a file\n+    return new FSDataOutputStream(new S3AOutputStream(getConf(), s3, this, \n+      bucket, key, progress, cannedACL, statistics, \n+      serverSideEncryptionAlgorithm), null);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public FSDataOutputStream create(Path f, FsPermission permission, boolean overwrite, \n    int bufferSize, short replication, long blockSize, Progressable progress) throws IOException {\n    String key \u003d pathToKey(f);\n\n    if (!overwrite \u0026\u0026 exists(f)) {\n      throw new FileAlreadyExistsException(f + \" already exists\");\n    }\n\n    // We pass null to FSDataOutputStream so it won\u0027t count writes that are being buffered to a file\n    return new FSDataOutputStream(new S3AOutputStream(getConf(), s3, this, \n      bucket, key, progress, cannedACL, statistics, \n      serverSideEncryptionAlgorithm), null);\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/S3AFileSystem.java"
    }
  }
}