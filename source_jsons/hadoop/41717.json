{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AbstractYarnScheduler.java",
  "functionName": "recoverContainersOnNode",
  "functionId": "recoverContainersOnNode___containerReports-List__NMContainerStatus____nm-RMNode",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
  "functionStartLine": 509,
  "functionEndLine": 612,
  "numCommitsSeen": 115,
  "timeTaken": 7294,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "6b96a73bb0f0ad1c877a062b19091e3e15a33ec4",
    "f69a107aeccc68ca1085a7be8093d36b2f45eaa1",
    "ab1faa4ba80702fb04e28ffb23a4b3bb6e64ee16",
    "e0f2379312c48e26b0cb2c1e1e803ef71d1839cf",
    "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "097baaaebae021c47bb7d69aa1ff1a2440df5166",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
    "586348e4cbf197188057d6b843a6701cfffdaff3",
    "4236c6600eda9cdda708d02f3a5a3fe31228f70c",
    "f6a778c3725bcdaba1e1de43786af17dd44deb78",
    "03a25d2cc1a2fb124d00edf874d67e329c65a5e6",
    "424fd9494f144c035fdef8c533be51e2027ad8d9"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "6b96a73bb0f0ad1c877a062b19091e3e15a33ec4": "Ybodychange",
    "f69a107aeccc68ca1085a7be8093d36b2f45eaa1": "Ymodifierchange",
    "ab1faa4ba80702fb04e28ffb23a4b3bb6e64ee16": "Ymodifierchange",
    "e0f2379312c48e26b0cb2c1e1e803ef71d1839cf": "Ymodifierchange",
    "754cb4e30fac1c5fe8d44626968c0ddbfe459335": "Ymodifierchange",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ymultichange(Ymodifierchange,Ybodychange)",
    "097baaaebae021c47bb7d69aa1ff1a2440df5166": "Ybodychange",
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": "Ybodychange",
    "586348e4cbf197188057d6b843a6701cfffdaff3": "Ybodychange",
    "4236c6600eda9cdda708d02f3a5a3fe31228f70c": "Ybodychange",
    "f6a778c3725bcdaba1e1de43786af17dd44deb78": "Ybodychange",
    "03a25d2cc1a2fb124d00edf874d67e329c65a5e6": "Ybodychange",
    "424fd9494f144c035fdef8c533be51e2027ad8d9": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "14/10/19 8:19 AM",
      "commitNameOld": "5cc7873a4723a6c8e8e001d008fcd522eec0433d",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 162.83,
      "commitsBetweenForRepo": 563,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,104 @@\n   public void recoverContainersOnNode(List\u003cNMContainerStatus\u003e containerReports,\n       RMNode nm) {\n     writeLock.lock();\n     try {\n       if (!rmContext.isWorkPreservingRecoveryEnabled()\n           || containerReports \u003d\u003d null || (containerReports !\u003d null\n           \u0026\u0026 containerReports.isEmpty())) {\n         return;\n       }\n \n       for (NMContainerStatus container : containerReports) {\n         ApplicationId appId \u003d\n             container.getContainerId().getApplicationAttemptId()\n                 .getApplicationId();\n         RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n         if (rmApp \u003d\u003d null) {\n           LOG.error(\"Skip recovering container \" + container\n               + \" for unknown application.\");\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n         if (schedulerApp \u003d\u003d null) {\n           LOG.info(\"Skip recovering container  \" + container\n               + \" for unknown SchedulerApplication. \"\n               + \"Application current state is \" + rmApp.getState());\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         LOG.info(\"Recovering container \" + container);\n         SchedulerApplicationAttempt schedulerAttempt \u003d\n             schedulerApp.getCurrentAppAttempt();\n \n         if (!rmApp.getApplicationSubmissionContext()\n             .getKeepContainersAcrossApplicationAttempts()) {\n           // Do not recover containers for stopped attempt or previous attempt.\n           if (schedulerAttempt.isStopped() || !schedulerAttempt\n               .getApplicationAttemptId().equals(\n                   container.getContainerId().getApplicationAttemptId())) {\n             LOG.info(\"Skip recovering container \" + container\n                 + \" for already stopped attempt.\");\n             killOrphanContainerOnNode(nm, container);\n             continue;\n           }\n         }\n \n+        Queue queue \u003d schedulerApp.getQueue();\n+        //To make sure we don\u0027t face ambiguity, CS queues should be referenced\n+        //by their full queue names\n+        String queueName \u003d  queue instanceof CSQueue ?\n+            ((CSQueue)queue).getQueuePath() : queue.getQueueName();\n+\n         // create container\n         RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm,\n-            schedulerApp.getQueue().getQueueName());\n+            queueName);\n \n         // recover RMContainer\n         rmContainer.handle(\n             new RMContainerRecoverEvent(container.getContainerId(), container));\n \n         // recover scheduler node\n         SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n         schedulerNode.recoverContainer(rmContainer);\n \n         // recover queue: update headroom etc.\n-        Queue queue \u003d schedulerAttempt.getQueue();\n-        queue.recoverContainer(getClusterResource(), schedulerAttempt,\n+        Queue queueToRecover \u003d schedulerAttempt.getQueue();\n+        queueToRecover.recoverContainer(getClusterResource(), schedulerAttempt,\n             rmContainer);\n \n         // recover scheduler attempt\n         schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n \n         // set master container for the current running AMContainer for this\n         // attempt.\n         RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n         if (appAttempt !\u003d null) {\n           Container masterContainer \u003d appAttempt.getMasterContainer();\n \n           // Mark current running AMContainer\u0027s RMContainer based on the master\n           // container ID stored in AppAttempt.\n           if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n               rmContainer.getContainerId())) {\n             ((RMContainerImpl) rmContainer).setAMContainer(true);\n           }\n         }\n \n         if (schedulerAttempt.getPendingRelease().remove(\n             container.getContainerId())) {\n           // release the container\n           rmContainer.handle(\n               new RMContainerFinishedEvent(container.getContainerId(),\n                   SchedulerUtils\n                       .createAbnormalContainerStatus(container.getContainerId(),\n                           SchedulerUtils.RELEASED_CONTAINER),\n                   RMContainerEventType.RELEASED));\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recoverContainersOnNode(List\u003cNMContainerStatus\u003e containerReports,\n      RMNode nm) {\n    writeLock.lock();\n    try {\n      if (!rmContext.isWorkPreservingRecoveryEnabled()\n          || containerReports \u003d\u003d null || (containerReports !\u003d null\n          \u0026\u0026 containerReports.isEmpty())) {\n        return;\n      }\n\n      for (NMContainerStatus container : containerReports) {\n        ApplicationId appId \u003d\n            container.getContainerId().getApplicationAttemptId()\n                .getApplicationId();\n        RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n        if (rmApp \u003d\u003d null) {\n          LOG.error(\"Skip recovering container \" + container\n              + \" for unknown application.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n        if (schedulerApp \u003d\u003d null) {\n          LOG.info(\"Skip recovering container  \" + container\n              + \" for unknown SchedulerApplication. \"\n              + \"Application current state is \" + rmApp.getState());\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        LOG.info(\"Recovering container \" + container);\n        SchedulerApplicationAttempt schedulerAttempt \u003d\n            schedulerApp.getCurrentAppAttempt();\n\n        if (!rmApp.getApplicationSubmissionContext()\n            .getKeepContainersAcrossApplicationAttempts()) {\n          // Do not recover containers for stopped attempt or previous attempt.\n          if (schedulerAttempt.isStopped() || !schedulerAttempt\n              .getApplicationAttemptId().equals(\n                  container.getContainerId().getApplicationAttemptId())) {\n            LOG.info(\"Skip recovering container \" + container\n                + \" for already stopped attempt.\");\n            killOrphanContainerOnNode(nm, container);\n            continue;\n          }\n        }\n\n        Queue queue \u003d schedulerApp.getQueue();\n        //To make sure we don\u0027t face ambiguity, CS queues should be referenced\n        //by their full queue names\n        String queueName \u003d  queue instanceof CSQueue ?\n            ((CSQueue)queue).getQueuePath() : queue.getQueueName();\n\n        // create container\n        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm,\n            queueName);\n\n        // recover RMContainer\n        rmContainer.handle(\n            new RMContainerRecoverEvent(container.getContainerId(), container));\n\n        // recover scheduler node\n        SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n        schedulerNode.recoverContainer(rmContainer);\n\n        // recover queue: update headroom etc.\n        Queue queueToRecover \u003d schedulerAttempt.getQueue();\n        queueToRecover.recoverContainer(getClusterResource(), schedulerAttempt,\n            rmContainer);\n\n        // recover scheduler attempt\n        schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n\n        // set master container for the current running AMContainer for this\n        // attempt.\n        RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n        if (appAttempt !\u003d null) {\n          Container masterContainer \u003d appAttempt.getMasterContainer();\n\n          // Mark current running AMContainer\u0027s RMContainer based on the master\n          // container ID stored in AppAttempt.\n          if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n              rmContainer.getContainerId())) {\n            ((RMContainerImpl) rmContainer).setAMContainer(true);\n          }\n        }\n\n        if (schedulerAttempt.getPendingRelease().remove(\n            container.getContainerId())) {\n          // release the container\n          rmContainer.handle(\n              new RMContainerFinishedEvent(container.getContainerId(),\n                  SchedulerUtils\n                      .createAbnormalContainerStatus(container.getContainerId(),\n                          SchedulerUtils.RELEASED_CONTAINER),\n                  RMContainerEventType.RELEASED));\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,98 @@\n   public void recoverContainersOnNode(List\u003cNMContainerStatus\u003e containerReports,\n       RMNode nm) {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       if (!rmContext.isWorkPreservingRecoveryEnabled()\n           || containerReports \u003d\u003d null || (containerReports !\u003d null\n           \u0026\u0026 containerReports.isEmpty())) {\n         return;\n       }\n \n       for (NMContainerStatus container : containerReports) {\n         ApplicationId appId \u003d\n             container.getContainerId().getApplicationAttemptId()\n                 .getApplicationId();\n         RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n         if (rmApp \u003d\u003d null) {\n           LOG.error(\"Skip recovering container \" + container\n               + \" for unknown application.\");\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n         if (schedulerApp \u003d\u003d null) {\n           LOG.info(\"Skip recovering container  \" + container\n               + \" for unknown SchedulerApplication. \"\n               + \"Application current state is \" + rmApp.getState());\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         LOG.info(\"Recovering container \" + container);\n         SchedulerApplicationAttempt schedulerAttempt \u003d\n             schedulerApp.getCurrentAppAttempt();\n \n         if (!rmApp.getApplicationSubmissionContext()\n             .getKeepContainersAcrossApplicationAttempts()) {\n           // Do not recover containers for stopped attempt or previous attempt.\n           if (schedulerAttempt.isStopped() || !schedulerAttempt\n               .getApplicationAttemptId().equals(\n                   container.getContainerId().getApplicationAttemptId())) {\n             LOG.info(\"Skip recovering container \" + container\n                 + \" for already stopped attempt.\");\n             killOrphanContainerOnNode(nm, container);\n             continue;\n           }\n         }\n \n         // create container\n         RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm,\n             schedulerApp.getQueue().getQueueName());\n \n         // recover RMContainer\n         rmContainer.handle(\n             new RMContainerRecoverEvent(container.getContainerId(), container));\n \n         // recover scheduler node\n         SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n         schedulerNode.recoverContainer(rmContainer);\n \n         // recover queue: update headroom etc.\n         Queue queue \u003d schedulerAttempt.getQueue();\n         queue.recoverContainer(getClusterResource(), schedulerAttempt,\n             rmContainer);\n \n         // recover scheduler attempt\n         schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n \n         // set master container for the current running AMContainer for this\n         // attempt.\n         RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n         if (appAttempt !\u003d null) {\n           Container masterContainer \u003d appAttempt.getMasterContainer();\n \n           // Mark current running AMContainer\u0027s RMContainer based on the master\n           // container ID stored in AppAttempt.\n           if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n               rmContainer.getContainerId())) {\n             ((RMContainerImpl) rmContainer).setAMContainer(true);\n           }\n         }\n \n         if (schedulerAttempt.getPendingRelease().remove(\n             container.getContainerId())) {\n           // release the container\n           rmContainer.handle(\n               new RMContainerFinishedEvent(container.getContainerId(),\n                   SchedulerUtils\n                       .createAbnormalContainerStatus(container.getContainerId(),\n                           SchedulerUtils.RELEASED_CONTAINER),\n                   RMContainerEventType.RELEASED));\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recoverContainersOnNode(List\u003cNMContainerStatus\u003e containerReports,\n      RMNode nm) {\n    writeLock.lock();\n    try {\n      if (!rmContext.isWorkPreservingRecoveryEnabled()\n          || containerReports \u003d\u003d null || (containerReports !\u003d null\n          \u0026\u0026 containerReports.isEmpty())) {\n        return;\n      }\n\n      for (NMContainerStatus container : containerReports) {\n        ApplicationId appId \u003d\n            container.getContainerId().getApplicationAttemptId()\n                .getApplicationId();\n        RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n        if (rmApp \u003d\u003d null) {\n          LOG.error(\"Skip recovering container \" + container\n              + \" for unknown application.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n        if (schedulerApp \u003d\u003d null) {\n          LOG.info(\"Skip recovering container  \" + container\n              + \" for unknown SchedulerApplication. \"\n              + \"Application current state is \" + rmApp.getState());\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        LOG.info(\"Recovering container \" + container);\n        SchedulerApplicationAttempt schedulerAttempt \u003d\n            schedulerApp.getCurrentAppAttempt();\n\n        if (!rmApp.getApplicationSubmissionContext()\n            .getKeepContainersAcrossApplicationAttempts()) {\n          // Do not recover containers for stopped attempt or previous attempt.\n          if (schedulerAttempt.isStopped() || !schedulerAttempt\n              .getApplicationAttemptId().equals(\n                  container.getContainerId().getApplicationAttemptId())) {\n            LOG.info(\"Skip recovering container \" + container\n                + \" for already stopped attempt.\");\n            killOrphanContainerOnNode(nm, container);\n            continue;\n          }\n        }\n\n        // create container\n        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm,\n            schedulerApp.getQueue().getQueueName());\n\n        // recover RMContainer\n        rmContainer.handle(\n            new RMContainerRecoverEvent(container.getContainerId(), container));\n\n        // recover scheduler node\n        SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n        schedulerNode.recoverContainer(rmContainer);\n\n        // recover queue: update headroom etc.\n        Queue queue \u003d schedulerAttempt.getQueue();\n        queue.recoverContainer(getClusterResource(), schedulerAttempt,\n            rmContainer);\n\n        // recover scheduler attempt\n        schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n\n        // set master container for the current running AMContainer for this\n        // attempt.\n        RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n        if (appAttempt !\u003d null) {\n          Container masterContainer \u003d appAttempt.getMasterContainer();\n\n          // Mark current running AMContainer\u0027s RMContainer based on the master\n          // container ID stored in AppAttempt.\n          if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n              rmContainer.getContainerId())) {\n            ((RMContainerImpl) rmContainer).setAMContainer(true);\n          }\n        }\n\n        if (schedulerAttempt.getPendingRelease().remove(\n            container.getContainerId())) {\n          // release the container\n          rmContainer.handle(\n              new RMContainerFinishedEvent(container.getContainerId(),\n                  SchedulerUtils\n                      .createAbnormalContainerStatus(container.getContainerId(),\n                          SchedulerUtils.RELEASED_CONTAINER),\n                  RMContainerEventType.RELEASED));\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "6b96a73bb0f0ad1c877a062b19091e3e15a33ec4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8232. RMContainer lost queue name when RM HA happens. (Hu Ziqian via wangda)\n\nChange-Id: Ia21e1da6871570c993bbedde76ce32929e95970f\n",
      "commitDate": "08/05/18 11:34 AM",
      "commitName": "6b96a73bb0f0ad1c877a062b19091e3e15a33ec4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "31/01/18 1:30 AM",
      "commitNameOld": "c23980c4f2cf4c751a99fd310e60149cb32ea7c7",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 97.38,
      "commitsBetweenForRepo": 1264,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,98 @@\n   public void recoverContainersOnNode(List\u003cNMContainerStatus\u003e containerReports,\n       RMNode nm) {\n     try {\n       writeLock.lock();\n       if (!rmContext.isWorkPreservingRecoveryEnabled()\n           || containerReports \u003d\u003d null || (containerReports !\u003d null\n           \u0026\u0026 containerReports.isEmpty())) {\n         return;\n       }\n \n       for (NMContainerStatus container : containerReports) {\n         ApplicationId appId \u003d\n             container.getContainerId().getApplicationAttemptId()\n                 .getApplicationId();\n         RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n         if (rmApp \u003d\u003d null) {\n           LOG.error(\"Skip recovering container \" + container\n               + \" for unknown application.\");\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n         if (schedulerApp \u003d\u003d null) {\n           LOG.info(\"Skip recovering container  \" + container\n               + \" for unknown SchedulerApplication. \"\n               + \"Application current state is \" + rmApp.getState());\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         LOG.info(\"Recovering container \" + container);\n         SchedulerApplicationAttempt schedulerAttempt \u003d\n             schedulerApp.getCurrentAppAttempt();\n \n         if (!rmApp.getApplicationSubmissionContext()\n             .getKeepContainersAcrossApplicationAttempts()) {\n           // Do not recover containers for stopped attempt or previous attempt.\n           if (schedulerAttempt.isStopped() || !schedulerAttempt\n               .getApplicationAttemptId().equals(\n                   container.getContainerId().getApplicationAttemptId())) {\n             LOG.info(\"Skip recovering container \" + container\n                 + \" for already stopped attempt.\");\n             killOrphanContainerOnNode(nm, container);\n             continue;\n           }\n         }\n \n         // create container\n-        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n+        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm,\n+            schedulerApp.getQueue().getQueueName());\n \n         // recover RMContainer\n         rmContainer.handle(\n             new RMContainerRecoverEvent(container.getContainerId(), container));\n \n         // recover scheduler node\n         SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n         schedulerNode.recoverContainer(rmContainer);\n \n         // recover queue: update headroom etc.\n         Queue queue \u003d schedulerAttempt.getQueue();\n         queue.recoverContainer(getClusterResource(), schedulerAttempt,\n             rmContainer);\n \n         // recover scheduler attempt\n         schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n \n         // set master container for the current running AMContainer for this\n         // attempt.\n         RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n         if (appAttempt !\u003d null) {\n           Container masterContainer \u003d appAttempt.getMasterContainer();\n \n           // Mark current running AMContainer\u0027s RMContainer based on the master\n           // container ID stored in AppAttempt.\n           if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n               rmContainer.getContainerId())) {\n             ((RMContainerImpl) rmContainer).setAMContainer(true);\n           }\n         }\n \n         if (schedulerAttempt.getPendingRelease().remove(\n             container.getContainerId())) {\n           // release the container\n           rmContainer.handle(\n               new RMContainerFinishedEvent(container.getContainerId(),\n                   SchedulerUtils\n                       .createAbnormalContainerStatus(container.getContainerId(),\n                           SchedulerUtils.RELEASED_CONTAINER),\n                   RMContainerEventType.RELEASED));\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recoverContainersOnNode(List\u003cNMContainerStatus\u003e containerReports,\n      RMNode nm) {\n    try {\n      writeLock.lock();\n      if (!rmContext.isWorkPreservingRecoveryEnabled()\n          || containerReports \u003d\u003d null || (containerReports !\u003d null\n          \u0026\u0026 containerReports.isEmpty())) {\n        return;\n      }\n\n      for (NMContainerStatus container : containerReports) {\n        ApplicationId appId \u003d\n            container.getContainerId().getApplicationAttemptId()\n                .getApplicationId();\n        RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n        if (rmApp \u003d\u003d null) {\n          LOG.error(\"Skip recovering container \" + container\n              + \" for unknown application.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n        if (schedulerApp \u003d\u003d null) {\n          LOG.info(\"Skip recovering container  \" + container\n              + \" for unknown SchedulerApplication. \"\n              + \"Application current state is \" + rmApp.getState());\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        LOG.info(\"Recovering container \" + container);\n        SchedulerApplicationAttempt schedulerAttempt \u003d\n            schedulerApp.getCurrentAppAttempt();\n\n        if (!rmApp.getApplicationSubmissionContext()\n            .getKeepContainersAcrossApplicationAttempts()) {\n          // Do not recover containers for stopped attempt or previous attempt.\n          if (schedulerAttempt.isStopped() || !schedulerAttempt\n              .getApplicationAttemptId().equals(\n                  container.getContainerId().getApplicationAttemptId())) {\n            LOG.info(\"Skip recovering container \" + container\n                + \" for already stopped attempt.\");\n            killOrphanContainerOnNode(nm, container);\n            continue;\n          }\n        }\n\n        // create container\n        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm,\n            schedulerApp.getQueue().getQueueName());\n\n        // recover RMContainer\n        rmContainer.handle(\n            new RMContainerRecoverEvent(container.getContainerId(), container));\n\n        // recover scheduler node\n        SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n        schedulerNode.recoverContainer(rmContainer);\n\n        // recover queue: update headroom etc.\n        Queue queue \u003d schedulerAttempt.getQueue();\n        queue.recoverContainer(getClusterResource(), schedulerAttempt,\n            rmContainer);\n\n        // recover scheduler attempt\n        schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n\n        // set master container for the current running AMContainer for this\n        // attempt.\n        RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n        if (appAttempt !\u003d null) {\n          Container masterContainer \u003d appAttempt.getMasterContainer();\n\n          // Mark current running AMContainer\u0027s RMContainer based on the master\n          // container ID stored in AppAttempt.\n          if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n              rmContainer.getContainerId())) {\n            ((RMContainerImpl) rmContainer).setAMContainer(true);\n          }\n        }\n\n        if (schedulerAttempt.getPendingRelease().remove(\n            container.getContainerId())) {\n          // release the container\n          rmContainer.handle(\n              new RMContainerFinishedEvent(container.getContainerId(),\n                  SchedulerUtils\n                      .createAbnormalContainerStatus(container.getContainerId(),\n                          SchedulerUtils.RELEASED_CONTAINER),\n                  RMContainerEventType.RELEASED));\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "f69a107aeccc68ca1085a7be8093d36b2f45eaa1": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-6025. Fix synchronization issues of AbstractYarnScheduler#nodeUpdate and its implementations. (Naganarasimha G R via wangda)\n\n(cherry picked from commit e0f2379312c48e26b0cb2c1e1e803ef71d1839cf)\n",
      "commitDate": "03/01/17 2:53 PM",
      "commitName": "f69a107aeccc68ca1085a7be8093d36b2f45eaa1",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "03/01/17 2:53 PM",
      "commitNameOld": "ab1faa4ba80702fb04e28ffb23a4b3bb6e64ee16",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,97 @@\n-  public synchronized void recoverContainersOnNode(\n-      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n+  public void recoverContainersOnNode(List\u003cNMContainerStatus\u003e containerReports,\n+      RMNode nm) {\n     try {\n       writeLock.lock();\n       if (!rmContext.isWorkPreservingRecoveryEnabled()\n           || containerReports \u003d\u003d null || (containerReports !\u003d null\n           \u0026\u0026 containerReports.isEmpty())) {\n         return;\n       }\n \n       for (NMContainerStatus container : containerReports) {\n         ApplicationId appId \u003d\n             container.getContainerId().getApplicationAttemptId()\n                 .getApplicationId();\n         RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n         if (rmApp \u003d\u003d null) {\n           LOG.error(\"Skip recovering container \" + container\n               + \" for unknown application.\");\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n         if (schedulerApp \u003d\u003d null) {\n           LOG.info(\"Skip recovering container  \" + container\n               + \" for unknown SchedulerApplication. \"\n               + \"Application current state is \" + rmApp.getState());\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         LOG.info(\"Recovering container \" + container);\n         SchedulerApplicationAttempt schedulerAttempt \u003d\n             schedulerApp.getCurrentAppAttempt();\n \n         if (!rmApp.getApplicationSubmissionContext()\n             .getKeepContainersAcrossApplicationAttempts()) {\n           // Do not recover containers for stopped attempt or previous attempt.\n           if (schedulerAttempt.isStopped() || !schedulerAttempt\n               .getApplicationAttemptId().equals(\n                   container.getContainerId().getApplicationAttemptId())) {\n             LOG.info(\"Skip recovering container \" + container\n                 + \" for already stopped attempt.\");\n             killOrphanContainerOnNode(nm, container);\n             continue;\n           }\n         }\n \n         // create container\n         RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n \n         // recover RMContainer\n         rmContainer.handle(\n             new RMContainerRecoverEvent(container.getContainerId(), container));\n \n         // recover scheduler node\n         SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n         schedulerNode.recoverContainer(rmContainer);\n \n         // recover queue: update headroom etc.\n         Queue queue \u003d schedulerAttempt.getQueue();\n         queue.recoverContainer(getClusterResource(), schedulerAttempt,\n             rmContainer);\n \n         // recover scheduler attempt\n         schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n \n         // set master container for the current running AMContainer for this\n         // attempt.\n         RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n         if (appAttempt !\u003d null) {\n           Container masterContainer \u003d appAttempt.getMasterContainer();\n \n           // Mark current running AMContainer\u0027s RMContainer based on the master\n           // container ID stored in AppAttempt.\n           if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n               rmContainer.getContainerId())) {\n             ((RMContainerImpl) rmContainer).setAMContainer(true);\n           }\n         }\n \n         if (schedulerAttempt.getPendingRelease().remove(\n             container.getContainerId())) {\n           // release the container\n           rmContainer.handle(\n               new RMContainerFinishedEvent(container.getContainerId(),\n                   SchedulerUtils\n                       .createAbnormalContainerStatus(container.getContainerId(),\n                           SchedulerUtils.RELEASED_CONTAINER),\n                   RMContainerEventType.RELEASED));\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recoverContainersOnNode(List\u003cNMContainerStatus\u003e containerReports,\n      RMNode nm) {\n    try {\n      writeLock.lock();\n      if (!rmContext.isWorkPreservingRecoveryEnabled()\n          || containerReports \u003d\u003d null || (containerReports !\u003d null\n          \u0026\u0026 containerReports.isEmpty())) {\n        return;\n      }\n\n      for (NMContainerStatus container : containerReports) {\n        ApplicationId appId \u003d\n            container.getContainerId().getApplicationAttemptId()\n                .getApplicationId();\n        RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n        if (rmApp \u003d\u003d null) {\n          LOG.error(\"Skip recovering container \" + container\n              + \" for unknown application.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n        if (schedulerApp \u003d\u003d null) {\n          LOG.info(\"Skip recovering container  \" + container\n              + \" for unknown SchedulerApplication. \"\n              + \"Application current state is \" + rmApp.getState());\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        LOG.info(\"Recovering container \" + container);\n        SchedulerApplicationAttempt schedulerAttempt \u003d\n            schedulerApp.getCurrentAppAttempt();\n\n        if (!rmApp.getApplicationSubmissionContext()\n            .getKeepContainersAcrossApplicationAttempts()) {\n          // Do not recover containers for stopped attempt or previous attempt.\n          if (schedulerAttempt.isStopped() || !schedulerAttempt\n              .getApplicationAttemptId().equals(\n                  container.getContainerId().getApplicationAttemptId())) {\n            LOG.info(\"Skip recovering container \" + container\n                + \" for already stopped attempt.\");\n            killOrphanContainerOnNode(nm, container);\n            continue;\n          }\n        }\n\n        // create container\n        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n        // recover RMContainer\n        rmContainer.handle(\n            new RMContainerRecoverEvent(container.getContainerId(), container));\n\n        // recover scheduler node\n        SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n        schedulerNode.recoverContainer(rmContainer);\n\n        // recover queue: update headroom etc.\n        Queue queue \u003d schedulerAttempt.getQueue();\n        queue.recoverContainer(getClusterResource(), schedulerAttempt,\n            rmContainer);\n\n        // recover scheduler attempt\n        schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n\n        // set master container for the current running AMContainer for this\n        // attempt.\n        RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n        if (appAttempt !\u003d null) {\n          Container masterContainer \u003d appAttempt.getMasterContainer();\n\n          // Mark current running AMContainer\u0027s RMContainer based on the master\n          // container ID stored in AppAttempt.\n          if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n              rmContainer.getContainerId())) {\n            ((RMContainerImpl) rmContainer).setAMContainer(true);\n          }\n        }\n\n        if (schedulerAttempt.getPendingRelease().remove(\n            container.getContainerId())) {\n          // release the container\n          rmContainer.handle(\n              new RMContainerFinishedEvent(container.getContainerId(),\n                  SchedulerUtils\n                      .createAbnormalContainerStatus(container.getContainerId(),\n                          SchedulerUtils.RELEASED_CONTAINER),\n                  RMContainerEventType.RELEASED));\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {
        "oldValue": "[public, synchronized]",
        "newValue": "[public]"
      }
    },
    "ab1faa4ba80702fb04e28ffb23a4b3bb6e64ee16": {
      "type": "Ymodifierchange",
      "commitMessage": "Revert \"Fix synchronization issues of AbstractYarnScheduler#nodeUpdate and its implementations. (Naganarasimha G R via wangda)\" to add correct JIRA number\n\nThis reverts commit e0f2379312c48e26b0cb2c1e1e803ef71d1839cf.\n",
      "commitDate": "03/01/17 2:53 PM",
      "commitName": "ab1faa4ba80702fb04e28ffb23a4b3bb6e64ee16",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "03/01/17 2:46 PM",
      "commitNameOld": "e0f2379312c48e26b0cb2c1e1e803ef71d1839cf",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,97 @@\n-  public void recoverContainersOnNode(List\u003cNMContainerStatus\u003e containerReports,\n-      RMNode nm) {\n+  public synchronized void recoverContainersOnNode(\n+      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n     try {\n       writeLock.lock();\n       if (!rmContext.isWorkPreservingRecoveryEnabled()\n           || containerReports \u003d\u003d null || (containerReports !\u003d null\n           \u0026\u0026 containerReports.isEmpty())) {\n         return;\n       }\n \n       for (NMContainerStatus container : containerReports) {\n         ApplicationId appId \u003d\n             container.getContainerId().getApplicationAttemptId()\n                 .getApplicationId();\n         RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n         if (rmApp \u003d\u003d null) {\n           LOG.error(\"Skip recovering container \" + container\n               + \" for unknown application.\");\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n         if (schedulerApp \u003d\u003d null) {\n           LOG.info(\"Skip recovering container  \" + container\n               + \" for unknown SchedulerApplication. \"\n               + \"Application current state is \" + rmApp.getState());\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         LOG.info(\"Recovering container \" + container);\n         SchedulerApplicationAttempt schedulerAttempt \u003d\n             schedulerApp.getCurrentAppAttempt();\n \n         if (!rmApp.getApplicationSubmissionContext()\n             .getKeepContainersAcrossApplicationAttempts()) {\n           // Do not recover containers for stopped attempt or previous attempt.\n           if (schedulerAttempt.isStopped() || !schedulerAttempt\n               .getApplicationAttemptId().equals(\n                   container.getContainerId().getApplicationAttemptId())) {\n             LOG.info(\"Skip recovering container \" + container\n                 + \" for already stopped attempt.\");\n             killOrphanContainerOnNode(nm, container);\n             continue;\n           }\n         }\n \n         // create container\n         RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n \n         // recover RMContainer\n         rmContainer.handle(\n             new RMContainerRecoverEvent(container.getContainerId(), container));\n \n         // recover scheduler node\n         SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n         schedulerNode.recoverContainer(rmContainer);\n \n         // recover queue: update headroom etc.\n         Queue queue \u003d schedulerAttempt.getQueue();\n         queue.recoverContainer(getClusterResource(), schedulerAttempt,\n             rmContainer);\n \n         // recover scheduler attempt\n         schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n \n         // set master container for the current running AMContainer for this\n         // attempt.\n         RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n         if (appAttempt !\u003d null) {\n           Container masterContainer \u003d appAttempt.getMasterContainer();\n \n           // Mark current running AMContainer\u0027s RMContainer based on the master\n           // container ID stored in AppAttempt.\n           if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n               rmContainer.getContainerId())) {\n             ((RMContainerImpl) rmContainer).setAMContainer(true);\n           }\n         }\n \n         if (schedulerAttempt.getPendingRelease().remove(\n             container.getContainerId())) {\n           // release the container\n           rmContainer.handle(\n               new RMContainerFinishedEvent(container.getContainerId(),\n                   SchedulerUtils\n                       .createAbnormalContainerStatus(container.getContainerId(),\n                           SchedulerUtils.RELEASED_CONTAINER),\n                   RMContainerEventType.RELEASED));\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void recoverContainersOnNode(\n      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n    try {\n      writeLock.lock();\n      if (!rmContext.isWorkPreservingRecoveryEnabled()\n          || containerReports \u003d\u003d null || (containerReports !\u003d null\n          \u0026\u0026 containerReports.isEmpty())) {\n        return;\n      }\n\n      for (NMContainerStatus container : containerReports) {\n        ApplicationId appId \u003d\n            container.getContainerId().getApplicationAttemptId()\n                .getApplicationId();\n        RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n        if (rmApp \u003d\u003d null) {\n          LOG.error(\"Skip recovering container \" + container\n              + \" for unknown application.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n        if (schedulerApp \u003d\u003d null) {\n          LOG.info(\"Skip recovering container  \" + container\n              + \" for unknown SchedulerApplication. \"\n              + \"Application current state is \" + rmApp.getState());\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        LOG.info(\"Recovering container \" + container);\n        SchedulerApplicationAttempt schedulerAttempt \u003d\n            schedulerApp.getCurrentAppAttempt();\n\n        if (!rmApp.getApplicationSubmissionContext()\n            .getKeepContainersAcrossApplicationAttempts()) {\n          // Do not recover containers for stopped attempt or previous attempt.\n          if (schedulerAttempt.isStopped() || !schedulerAttempt\n              .getApplicationAttemptId().equals(\n                  container.getContainerId().getApplicationAttemptId())) {\n            LOG.info(\"Skip recovering container \" + container\n                + \" for already stopped attempt.\");\n            killOrphanContainerOnNode(nm, container);\n            continue;\n          }\n        }\n\n        // create container\n        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n        // recover RMContainer\n        rmContainer.handle(\n            new RMContainerRecoverEvent(container.getContainerId(), container));\n\n        // recover scheduler node\n        SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n        schedulerNode.recoverContainer(rmContainer);\n\n        // recover queue: update headroom etc.\n        Queue queue \u003d schedulerAttempt.getQueue();\n        queue.recoverContainer(getClusterResource(), schedulerAttempt,\n            rmContainer);\n\n        // recover scheduler attempt\n        schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n\n        // set master container for the current running AMContainer for this\n        // attempt.\n        RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n        if (appAttempt !\u003d null) {\n          Container masterContainer \u003d appAttempt.getMasterContainer();\n\n          // Mark current running AMContainer\u0027s RMContainer based on the master\n          // container ID stored in AppAttempt.\n          if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n              rmContainer.getContainerId())) {\n            ((RMContainerImpl) rmContainer).setAMContainer(true);\n          }\n        }\n\n        if (schedulerAttempt.getPendingRelease().remove(\n            container.getContainerId())) {\n          // release the container\n          rmContainer.handle(\n              new RMContainerFinishedEvent(container.getContainerId(),\n                  SchedulerUtils\n                      .createAbnormalContainerStatus(container.getContainerId(),\n                          SchedulerUtils.RELEASED_CONTAINER),\n                  RMContainerEventType.RELEASED));\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[public, synchronized]"
      }
    },
    "e0f2379312c48e26b0cb2c1e1e803ef71d1839cf": {
      "type": "Ymodifierchange",
      "commitMessage": "Fix synchronization issues of AbstractYarnScheduler#nodeUpdate and its implementations. (Naganarasimha G R via wangda)\n",
      "commitDate": "03/01/17 2:46 PM",
      "commitName": "e0f2379312c48e26b0cb2c1e1e803ef71d1839cf",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "06/12/16 9:09 PM",
      "commitNameOld": "563480dccd0136d82730f4228f1df44449ed5822",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 27.73,
      "commitsBetweenForRepo": 119,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,97 @@\n-  public synchronized void recoverContainersOnNode(\n-      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n+  public void recoverContainersOnNode(List\u003cNMContainerStatus\u003e containerReports,\n+      RMNode nm) {\n     try {\n       writeLock.lock();\n       if (!rmContext.isWorkPreservingRecoveryEnabled()\n           || containerReports \u003d\u003d null || (containerReports !\u003d null\n           \u0026\u0026 containerReports.isEmpty())) {\n         return;\n       }\n \n       for (NMContainerStatus container : containerReports) {\n         ApplicationId appId \u003d\n             container.getContainerId().getApplicationAttemptId()\n                 .getApplicationId();\n         RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n         if (rmApp \u003d\u003d null) {\n           LOG.error(\"Skip recovering container \" + container\n               + \" for unknown application.\");\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n         if (schedulerApp \u003d\u003d null) {\n           LOG.info(\"Skip recovering container  \" + container\n               + \" for unknown SchedulerApplication. \"\n               + \"Application current state is \" + rmApp.getState());\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         LOG.info(\"Recovering container \" + container);\n         SchedulerApplicationAttempt schedulerAttempt \u003d\n             schedulerApp.getCurrentAppAttempt();\n \n         if (!rmApp.getApplicationSubmissionContext()\n             .getKeepContainersAcrossApplicationAttempts()) {\n           // Do not recover containers for stopped attempt or previous attempt.\n           if (schedulerAttempt.isStopped() || !schedulerAttempt\n               .getApplicationAttemptId().equals(\n                   container.getContainerId().getApplicationAttemptId())) {\n             LOG.info(\"Skip recovering container \" + container\n                 + \" for already stopped attempt.\");\n             killOrphanContainerOnNode(nm, container);\n             continue;\n           }\n         }\n \n         // create container\n         RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n \n         // recover RMContainer\n         rmContainer.handle(\n             new RMContainerRecoverEvent(container.getContainerId(), container));\n \n         // recover scheduler node\n         SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n         schedulerNode.recoverContainer(rmContainer);\n \n         // recover queue: update headroom etc.\n         Queue queue \u003d schedulerAttempt.getQueue();\n         queue.recoverContainer(getClusterResource(), schedulerAttempt,\n             rmContainer);\n \n         // recover scheduler attempt\n         schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n \n         // set master container for the current running AMContainer for this\n         // attempt.\n         RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n         if (appAttempt !\u003d null) {\n           Container masterContainer \u003d appAttempt.getMasterContainer();\n \n           // Mark current running AMContainer\u0027s RMContainer based on the master\n           // container ID stored in AppAttempt.\n           if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n               rmContainer.getContainerId())) {\n             ((RMContainerImpl) rmContainer).setAMContainer(true);\n           }\n         }\n \n         if (schedulerAttempt.getPendingRelease().remove(\n             container.getContainerId())) {\n           // release the container\n           rmContainer.handle(\n               new RMContainerFinishedEvent(container.getContainerId(),\n                   SchedulerUtils\n                       .createAbnormalContainerStatus(container.getContainerId(),\n                           SchedulerUtils.RELEASED_CONTAINER),\n                   RMContainerEventType.RELEASED));\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recoverContainersOnNode(List\u003cNMContainerStatus\u003e containerReports,\n      RMNode nm) {\n    try {\n      writeLock.lock();\n      if (!rmContext.isWorkPreservingRecoveryEnabled()\n          || containerReports \u003d\u003d null || (containerReports !\u003d null\n          \u0026\u0026 containerReports.isEmpty())) {\n        return;\n      }\n\n      for (NMContainerStatus container : containerReports) {\n        ApplicationId appId \u003d\n            container.getContainerId().getApplicationAttemptId()\n                .getApplicationId();\n        RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n        if (rmApp \u003d\u003d null) {\n          LOG.error(\"Skip recovering container \" + container\n              + \" for unknown application.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n        if (schedulerApp \u003d\u003d null) {\n          LOG.info(\"Skip recovering container  \" + container\n              + \" for unknown SchedulerApplication. \"\n              + \"Application current state is \" + rmApp.getState());\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        LOG.info(\"Recovering container \" + container);\n        SchedulerApplicationAttempt schedulerAttempt \u003d\n            schedulerApp.getCurrentAppAttempt();\n\n        if (!rmApp.getApplicationSubmissionContext()\n            .getKeepContainersAcrossApplicationAttempts()) {\n          // Do not recover containers for stopped attempt or previous attempt.\n          if (schedulerAttempt.isStopped() || !schedulerAttempt\n              .getApplicationAttemptId().equals(\n                  container.getContainerId().getApplicationAttemptId())) {\n            LOG.info(\"Skip recovering container \" + container\n                + \" for already stopped attempt.\");\n            killOrphanContainerOnNode(nm, container);\n            continue;\n          }\n        }\n\n        // create container\n        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n        // recover RMContainer\n        rmContainer.handle(\n            new RMContainerRecoverEvent(container.getContainerId(), container));\n\n        // recover scheduler node\n        SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n        schedulerNode.recoverContainer(rmContainer);\n\n        // recover queue: update headroom etc.\n        Queue queue \u003d schedulerAttempt.getQueue();\n        queue.recoverContainer(getClusterResource(), schedulerAttempt,\n            rmContainer);\n\n        // recover scheduler attempt\n        schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n\n        // set master container for the current running AMContainer for this\n        // attempt.\n        RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n        if (appAttempt !\u003d null) {\n          Container masterContainer \u003d appAttempt.getMasterContainer();\n\n          // Mark current running AMContainer\u0027s RMContainer based on the master\n          // container ID stored in AppAttempt.\n          if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n              rmContainer.getContainerId())) {\n            ((RMContainerImpl) rmContainer).setAMContainer(true);\n          }\n        }\n\n        if (schedulerAttempt.getPendingRelease().remove(\n            container.getContainerId())) {\n          // release the container\n          rmContainer.handle(\n              new RMContainerFinishedEvent(container.getContainerId(),\n                  SchedulerUtils\n                      .createAbnormalContainerStatus(container.getContainerId(),\n                          SchedulerUtils.RELEASED_CONTAINER),\n                  RMContainerEventType.RELEASED));\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {
        "oldValue": "[public, synchronized]",
        "newValue": "[public]"
      }
    },
    "754cb4e30fac1c5fe8d44626968c0ddbfe459335": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-5047. Refactor nodeUpdate across schedulers. (Ray Chiang via kasha)\n",
      "commitDate": "20/10/16 9:17 PM",
      "commitName": "754cb4e30fac1c5fe8d44626968c0ddbfe459335",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "04/10/16 5:23 PM",
      "commitNameOld": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 16.16,
      "commitsBetweenForRepo": 125,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,97 +1,97 @@\n-  public void recoverContainersOnNode(\n+  public synchronized void recoverContainersOnNode(\n       List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n     try {\n       writeLock.lock();\n       if (!rmContext.isWorkPreservingRecoveryEnabled()\n           || containerReports \u003d\u003d null || (containerReports !\u003d null\n           \u0026\u0026 containerReports.isEmpty())) {\n         return;\n       }\n \n       for (NMContainerStatus container : containerReports) {\n         ApplicationId appId \u003d\n             container.getContainerId().getApplicationAttemptId()\n                 .getApplicationId();\n         RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n         if (rmApp \u003d\u003d null) {\n           LOG.error(\"Skip recovering container \" + container\n               + \" for unknown application.\");\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n         if (schedulerApp \u003d\u003d null) {\n           LOG.info(\"Skip recovering container  \" + container\n               + \" for unknown SchedulerApplication. \"\n               + \"Application current state is \" + rmApp.getState());\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n \n         LOG.info(\"Recovering container \" + container);\n         SchedulerApplicationAttempt schedulerAttempt \u003d\n             schedulerApp.getCurrentAppAttempt();\n \n         if (!rmApp.getApplicationSubmissionContext()\n             .getKeepContainersAcrossApplicationAttempts()) {\n           // Do not recover containers for stopped attempt or previous attempt.\n           if (schedulerAttempt.isStopped() || !schedulerAttempt\n               .getApplicationAttemptId().equals(\n                   container.getContainerId().getApplicationAttemptId())) {\n             LOG.info(\"Skip recovering container \" + container\n                 + \" for already stopped attempt.\");\n             killOrphanContainerOnNode(nm, container);\n             continue;\n           }\n         }\n \n         // create container\n         RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n \n         // recover RMContainer\n         rmContainer.handle(\n             new RMContainerRecoverEvent(container.getContainerId(), container));\n \n         // recover scheduler node\n         SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n         schedulerNode.recoverContainer(rmContainer);\n \n         // recover queue: update headroom etc.\n         Queue queue \u003d schedulerAttempt.getQueue();\n         queue.recoverContainer(getClusterResource(), schedulerAttempt,\n             rmContainer);\n \n         // recover scheduler attempt\n         schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n \n         // set master container for the current running AMContainer for this\n         // attempt.\n         RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n         if (appAttempt !\u003d null) {\n           Container masterContainer \u003d appAttempt.getMasterContainer();\n \n           // Mark current running AMContainer\u0027s RMContainer based on the master\n           // container ID stored in AppAttempt.\n           if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n               rmContainer.getContainerId())) {\n             ((RMContainerImpl) rmContainer).setAMContainer(true);\n           }\n         }\n \n         if (schedulerAttempt.getPendingRelease().remove(\n             container.getContainerId())) {\n           // release the container\n           rmContainer.handle(\n               new RMContainerFinishedEvent(container.getContainerId(),\n                   SchedulerUtils\n                       .createAbnormalContainerStatus(container.getContainerId(),\n                           SchedulerUtils.RELEASED_CONTAINER),\n                   RMContainerEventType.RELEASED));\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void recoverContainersOnNode(\n      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n    try {\n      writeLock.lock();\n      if (!rmContext.isWorkPreservingRecoveryEnabled()\n          || containerReports \u003d\u003d null || (containerReports !\u003d null\n          \u0026\u0026 containerReports.isEmpty())) {\n        return;\n      }\n\n      for (NMContainerStatus container : containerReports) {\n        ApplicationId appId \u003d\n            container.getContainerId().getApplicationAttemptId()\n                .getApplicationId();\n        RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n        if (rmApp \u003d\u003d null) {\n          LOG.error(\"Skip recovering container \" + container\n              + \" for unknown application.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n        if (schedulerApp \u003d\u003d null) {\n          LOG.info(\"Skip recovering container  \" + container\n              + \" for unknown SchedulerApplication. \"\n              + \"Application current state is \" + rmApp.getState());\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        LOG.info(\"Recovering container \" + container);\n        SchedulerApplicationAttempt schedulerAttempt \u003d\n            schedulerApp.getCurrentAppAttempt();\n\n        if (!rmApp.getApplicationSubmissionContext()\n            .getKeepContainersAcrossApplicationAttempts()) {\n          // Do not recover containers for stopped attempt or previous attempt.\n          if (schedulerAttempt.isStopped() || !schedulerAttempt\n              .getApplicationAttemptId().equals(\n                  container.getContainerId().getApplicationAttemptId())) {\n            LOG.info(\"Skip recovering container \" + container\n                + \" for already stopped attempt.\");\n            killOrphanContainerOnNode(nm, container);\n            continue;\n          }\n        }\n\n        // create container\n        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n        // recover RMContainer\n        rmContainer.handle(\n            new RMContainerRecoverEvent(container.getContainerId(), container));\n\n        // recover scheduler node\n        SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n        schedulerNode.recoverContainer(rmContainer);\n\n        // recover queue: update headroom etc.\n        Queue queue \u003d schedulerAttempt.getQueue();\n        queue.recoverContainer(getClusterResource(), schedulerAttempt,\n            rmContainer);\n\n        // recover scheduler attempt\n        schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n\n        // set master container for the current running AMContainer for this\n        // attempt.\n        RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n        if (appAttempt !\u003d null) {\n          Container masterContainer \u003d appAttempt.getMasterContainer();\n\n          // Mark current running AMContainer\u0027s RMContainer based on the master\n          // container ID stored in AppAttempt.\n          if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n              rmContainer.getContainerId())) {\n            ((RMContainerImpl) rmContainer).setAMContainer(true);\n          }\n        }\n\n        if (schedulerAttempt.getPendingRelease().remove(\n            container.getContainerId())) {\n          // release the container\n          rmContainer.handle(\n              new RMContainerFinishedEvent(container.getContainerId(),\n                  SchedulerUtils\n                      .createAbnormalContainerStatus(container.getContainerId(),\n                          SchedulerUtils.RELEASED_CONTAINER),\n                  RMContainerEventType.RELEASED));\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {
        "oldValue": "[public]",
        "newValue": "[public, synchronized]"
      }
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,92 +1,97 @@\n-  public synchronized void recoverContainersOnNode(\n+  public void recoverContainersOnNode(\n       List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n-    if (!rmContext.isWorkPreservingRecoveryEnabled()\n-        || containerReports \u003d\u003d null\n-        || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n-      return;\n-    }\n-\n-    for (NMContainerStatus container : containerReports) {\n-      ApplicationId appId \u003d\n-          container.getContainerId().getApplicationAttemptId().getApplicationId();\n-      RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n-      if (rmApp \u003d\u003d null) {\n-        LOG.error(\"Skip recovering container \" + container\n-            + \" for unknown application.\");\n-        killOrphanContainerOnNode(nm, container);\n-        continue;\n+    try {\n+      writeLock.lock();\n+      if (!rmContext.isWorkPreservingRecoveryEnabled()\n+          || containerReports \u003d\u003d null || (containerReports !\u003d null\n+          \u0026\u0026 containerReports.isEmpty())) {\n+        return;\n       }\n \n-      SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n-      if (schedulerApp \u003d\u003d null) {\n-        LOG.info(\"Skip recovering container  \" + container\n-            + \" for unknown SchedulerApplication. Application current state is \"\n-            + rmApp.getState());\n-        killOrphanContainerOnNode(nm, container);\n-        continue;\n-      }\n-\n-      LOG.info(\"Recovering container \" + container);\n-      SchedulerApplicationAttempt schedulerAttempt \u003d\n-          schedulerApp.getCurrentAppAttempt();\n-\n-      if (!rmApp.getApplicationSubmissionContext()\n-        .getKeepContainersAcrossApplicationAttempts()) {\n-        // Do not recover containers for stopped attempt or previous attempt.\n-        if (schedulerAttempt.isStopped()\n-            || !schedulerAttempt.getApplicationAttemptId().equals(\n-              container.getContainerId().getApplicationAttemptId())) {\n-          LOG.info(\"Skip recovering container \" + container\n-              + \" for already stopped attempt.\");\n+      for (NMContainerStatus container : containerReports) {\n+        ApplicationId appId \u003d\n+            container.getContainerId().getApplicationAttemptId()\n+                .getApplicationId();\n+        RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n+        if (rmApp \u003d\u003d null) {\n+          LOG.error(\"Skip recovering container \" + container\n+              + \" for unknown application.\");\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n-      }\n \n-      // create container\n-      RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n-\n-      // recover RMContainer\n-      rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n-        container));\n-\n-      // recover scheduler node\n-      SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n-      schedulerNode.recoverContainer(rmContainer);\n-\n-      // recover queue: update headroom etc.\n-      Queue queue \u003d schedulerAttempt.getQueue();\n-      queue.recoverContainer(\n-          getClusterResource(), schedulerAttempt, rmContainer);\n-\n-      // recover scheduler attempt\n-      schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n-            \n-      // set master container for the current running AMContainer for this\n-      // attempt.\n-      RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n-      if (appAttempt !\u003d null) {\n-        Container masterContainer \u003d appAttempt.getMasterContainer();\n-\n-        // Mark current running AMContainer\u0027s RMContainer based on the master\n-        // container ID stored in AppAttempt.\n-        if (masterContainer !\u003d null\n-            \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n-          ((RMContainerImpl)rmContainer).setAMContainer(true);\n+        SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n+        if (schedulerApp \u003d\u003d null) {\n+          LOG.info(\"Skip recovering container  \" + container\n+              + \" for unknown SchedulerApplication. \"\n+              + \"Application current state is \" + rmApp.getState());\n+          killOrphanContainerOnNode(nm, container);\n+          continue;\n         }\n-      }\n \n-      synchronized (schedulerAttempt) {\n-        Set\u003cContainerId\u003e releases \u003d schedulerAttempt.getPendingRelease();\n-        if (releases.contains(container.getContainerId())) {\n+        LOG.info(\"Recovering container \" + container);\n+        SchedulerApplicationAttempt schedulerAttempt \u003d\n+            schedulerApp.getCurrentAppAttempt();\n+\n+        if (!rmApp.getApplicationSubmissionContext()\n+            .getKeepContainersAcrossApplicationAttempts()) {\n+          // Do not recover containers for stopped attempt or previous attempt.\n+          if (schedulerAttempt.isStopped() || !schedulerAttempt\n+              .getApplicationAttemptId().equals(\n+                  container.getContainerId().getApplicationAttemptId())) {\n+            LOG.info(\"Skip recovering container \" + container\n+                + \" for already stopped attempt.\");\n+            killOrphanContainerOnNode(nm, container);\n+            continue;\n+          }\n+        }\n+\n+        // create container\n+        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n+\n+        // recover RMContainer\n+        rmContainer.handle(\n+            new RMContainerRecoverEvent(container.getContainerId(), container));\n+\n+        // recover scheduler node\n+        SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n+        schedulerNode.recoverContainer(rmContainer);\n+\n+        // recover queue: update headroom etc.\n+        Queue queue \u003d schedulerAttempt.getQueue();\n+        queue.recoverContainer(getClusterResource(), schedulerAttempt,\n+            rmContainer);\n+\n+        // recover scheduler attempt\n+        schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n+\n+        // set master container for the current running AMContainer for this\n+        // attempt.\n+        RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n+        if (appAttempt !\u003d null) {\n+          Container masterContainer \u003d appAttempt.getMasterContainer();\n+\n+          // Mark current running AMContainer\u0027s RMContainer based on the master\n+          // container ID stored in AppAttempt.\n+          if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n+              rmContainer.getContainerId())) {\n+            ((RMContainerImpl) rmContainer).setAMContainer(true);\n+          }\n+        }\n+\n+        if (schedulerAttempt.getPendingRelease().remove(\n+            container.getContainerId())) {\n           // release the container\n-          rmContainer.handle(new RMContainerFinishedEvent(container\n-            .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(\n-            container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),\n-            RMContainerEventType.RELEASED));\n-          releases.remove(container.getContainerId());\n+          rmContainer.handle(\n+              new RMContainerFinishedEvent(container.getContainerId(),\n+                  SchedulerUtils\n+                      .createAbnormalContainerStatus(container.getContainerId(),\n+                          SchedulerUtils.RELEASED_CONTAINER),\n+                  RMContainerEventType.RELEASED));\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void recoverContainersOnNode(\n      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n    try {\n      writeLock.lock();\n      if (!rmContext.isWorkPreservingRecoveryEnabled()\n          || containerReports \u003d\u003d null || (containerReports !\u003d null\n          \u0026\u0026 containerReports.isEmpty())) {\n        return;\n      }\n\n      for (NMContainerStatus container : containerReports) {\n        ApplicationId appId \u003d\n            container.getContainerId().getApplicationAttemptId()\n                .getApplicationId();\n        RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n        if (rmApp \u003d\u003d null) {\n          LOG.error(\"Skip recovering container \" + container\n              + \" for unknown application.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n        if (schedulerApp \u003d\u003d null) {\n          LOG.info(\"Skip recovering container  \" + container\n              + \" for unknown SchedulerApplication. \"\n              + \"Application current state is \" + rmApp.getState());\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        LOG.info(\"Recovering container \" + container);\n        SchedulerApplicationAttempt schedulerAttempt \u003d\n            schedulerApp.getCurrentAppAttempt();\n\n        if (!rmApp.getApplicationSubmissionContext()\n            .getKeepContainersAcrossApplicationAttempts()) {\n          // Do not recover containers for stopped attempt or previous attempt.\n          if (schedulerAttempt.isStopped() || !schedulerAttempt\n              .getApplicationAttemptId().equals(\n                  container.getContainerId().getApplicationAttemptId())) {\n            LOG.info(\"Skip recovering container \" + container\n                + \" for already stopped attempt.\");\n            killOrphanContainerOnNode(nm, container);\n            continue;\n          }\n        }\n\n        // create container\n        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n        // recover RMContainer\n        rmContainer.handle(\n            new RMContainerRecoverEvent(container.getContainerId(), container));\n\n        // recover scheduler node\n        SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n        schedulerNode.recoverContainer(rmContainer);\n\n        // recover queue: update headroom etc.\n        Queue queue \u003d schedulerAttempt.getQueue();\n        queue.recoverContainer(getClusterResource(), schedulerAttempt,\n            rmContainer);\n\n        // recover scheduler attempt\n        schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n\n        // set master container for the current running AMContainer for this\n        // attempt.\n        RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n        if (appAttempt !\u003d null) {\n          Container masterContainer \u003d appAttempt.getMasterContainer();\n\n          // Mark current running AMContainer\u0027s RMContainer based on the master\n          // container ID stored in AppAttempt.\n          if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n              rmContainer.getContainerId())) {\n            ((RMContainerImpl) rmContainer).setAMContainer(true);\n          }\n        }\n\n        if (schedulerAttempt.getPendingRelease().remove(\n            container.getContainerId())) {\n          // release the container\n          rmContainer.handle(\n              new RMContainerFinishedEvent(container.getContainerId(),\n                  SchedulerUtils\n                      .createAbnormalContainerStatus(container.getContainerId(),\n                          SchedulerUtils.RELEASED_CONTAINER),\n                  RMContainerEventType.RELEASED));\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,92 +1,97 @@\n-  public synchronized void recoverContainersOnNode(\n+  public void recoverContainersOnNode(\n       List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n-    if (!rmContext.isWorkPreservingRecoveryEnabled()\n-        || containerReports \u003d\u003d null\n-        || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n-      return;\n-    }\n-\n-    for (NMContainerStatus container : containerReports) {\n-      ApplicationId appId \u003d\n-          container.getContainerId().getApplicationAttemptId().getApplicationId();\n-      RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n-      if (rmApp \u003d\u003d null) {\n-        LOG.error(\"Skip recovering container \" + container\n-            + \" for unknown application.\");\n-        killOrphanContainerOnNode(nm, container);\n-        continue;\n+    try {\n+      writeLock.lock();\n+      if (!rmContext.isWorkPreservingRecoveryEnabled()\n+          || containerReports \u003d\u003d null || (containerReports !\u003d null\n+          \u0026\u0026 containerReports.isEmpty())) {\n+        return;\n       }\n \n-      SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n-      if (schedulerApp \u003d\u003d null) {\n-        LOG.info(\"Skip recovering container  \" + container\n-            + \" for unknown SchedulerApplication. Application current state is \"\n-            + rmApp.getState());\n-        killOrphanContainerOnNode(nm, container);\n-        continue;\n-      }\n-\n-      LOG.info(\"Recovering container \" + container);\n-      SchedulerApplicationAttempt schedulerAttempt \u003d\n-          schedulerApp.getCurrentAppAttempt();\n-\n-      if (!rmApp.getApplicationSubmissionContext()\n-        .getKeepContainersAcrossApplicationAttempts()) {\n-        // Do not recover containers for stopped attempt or previous attempt.\n-        if (schedulerAttempt.isStopped()\n-            || !schedulerAttempt.getApplicationAttemptId().equals(\n-              container.getContainerId().getApplicationAttemptId())) {\n-          LOG.info(\"Skip recovering container \" + container\n-              + \" for already stopped attempt.\");\n+      for (NMContainerStatus container : containerReports) {\n+        ApplicationId appId \u003d\n+            container.getContainerId().getApplicationAttemptId()\n+                .getApplicationId();\n+        RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n+        if (rmApp \u003d\u003d null) {\n+          LOG.error(\"Skip recovering container \" + container\n+              + \" for unknown application.\");\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n-      }\n \n-      // create container\n-      RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n-\n-      // recover RMContainer\n-      rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n-        container));\n-\n-      // recover scheduler node\n-      SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n-      schedulerNode.recoverContainer(rmContainer);\n-\n-      // recover queue: update headroom etc.\n-      Queue queue \u003d schedulerAttempt.getQueue();\n-      queue.recoverContainer(\n-          getClusterResource(), schedulerAttempt, rmContainer);\n-\n-      // recover scheduler attempt\n-      schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n-            \n-      // set master container for the current running AMContainer for this\n-      // attempt.\n-      RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n-      if (appAttempt !\u003d null) {\n-        Container masterContainer \u003d appAttempt.getMasterContainer();\n-\n-        // Mark current running AMContainer\u0027s RMContainer based on the master\n-        // container ID stored in AppAttempt.\n-        if (masterContainer !\u003d null\n-            \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n-          ((RMContainerImpl)rmContainer).setAMContainer(true);\n+        SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n+        if (schedulerApp \u003d\u003d null) {\n+          LOG.info(\"Skip recovering container  \" + container\n+              + \" for unknown SchedulerApplication. \"\n+              + \"Application current state is \" + rmApp.getState());\n+          killOrphanContainerOnNode(nm, container);\n+          continue;\n         }\n-      }\n \n-      synchronized (schedulerAttempt) {\n-        Set\u003cContainerId\u003e releases \u003d schedulerAttempt.getPendingRelease();\n-        if (releases.contains(container.getContainerId())) {\n+        LOG.info(\"Recovering container \" + container);\n+        SchedulerApplicationAttempt schedulerAttempt \u003d\n+            schedulerApp.getCurrentAppAttempt();\n+\n+        if (!rmApp.getApplicationSubmissionContext()\n+            .getKeepContainersAcrossApplicationAttempts()) {\n+          // Do not recover containers for stopped attempt or previous attempt.\n+          if (schedulerAttempt.isStopped() || !schedulerAttempt\n+              .getApplicationAttemptId().equals(\n+                  container.getContainerId().getApplicationAttemptId())) {\n+            LOG.info(\"Skip recovering container \" + container\n+                + \" for already stopped attempt.\");\n+            killOrphanContainerOnNode(nm, container);\n+            continue;\n+          }\n+        }\n+\n+        // create container\n+        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n+\n+        // recover RMContainer\n+        rmContainer.handle(\n+            new RMContainerRecoverEvent(container.getContainerId(), container));\n+\n+        // recover scheduler node\n+        SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n+        schedulerNode.recoverContainer(rmContainer);\n+\n+        // recover queue: update headroom etc.\n+        Queue queue \u003d schedulerAttempt.getQueue();\n+        queue.recoverContainer(getClusterResource(), schedulerAttempt,\n+            rmContainer);\n+\n+        // recover scheduler attempt\n+        schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n+\n+        // set master container for the current running AMContainer for this\n+        // attempt.\n+        RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n+        if (appAttempt !\u003d null) {\n+          Container masterContainer \u003d appAttempt.getMasterContainer();\n+\n+          // Mark current running AMContainer\u0027s RMContainer based on the master\n+          // container ID stored in AppAttempt.\n+          if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n+              rmContainer.getContainerId())) {\n+            ((RMContainerImpl) rmContainer).setAMContainer(true);\n+          }\n+        }\n+\n+        if (schedulerAttempt.getPendingRelease().remove(\n+            container.getContainerId())) {\n           // release the container\n-          rmContainer.handle(new RMContainerFinishedEvent(container\n-            .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(\n-            container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),\n-            RMContainerEventType.RELEASED));\n-          releases.remove(container.getContainerId());\n+          rmContainer.handle(\n+              new RMContainerFinishedEvent(container.getContainerId(),\n+                  SchedulerUtils\n+                      .createAbnormalContainerStatus(container.getContainerId(),\n+                          SchedulerUtils.RELEASED_CONTAINER),\n+                  RMContainerEventType.RELEASED));\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void recoverContainersOnNode(\n      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n    try {\n      writeLock.lock();\n      if (!rmContext.isWorkPreservingRecoveryEnabled()\n          || containerReports \u003d\u003d null || (containerReports !\u003d null\n          \u0026\u0026 containerReports.isEmpty())) {\n        return;\n      }\n\n      for (NMContainerStatus container : containerReports) {\n        ApplicationId appId \u003d\n            container.getContainerId().getApplicationAttemptId()\n                .getApplicationId();\n        RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n        if (rmApp \u003d\u003d null) {\n          LOG.error(\"Skip recovering container \" + container\n              + \" for unknown application.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n        if (schedulerApp \u003d\u003d null) {\n          LOG.info(\"Skip recovering container  \" + container\n              + \" for unknown SchedulerApplication. \"\n              + \"Application current state is \" + rmApp.getState());\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n\n        LOG.info(\"Recovering container \" + container);\n        SchedulerApplicationAttempt schedulerAttempt \u003d\n            schedulerApp.getCurrentAppAttempt();\n\n        if (!rmApp.getApplicationSubmissionContext()\n            .getKeepContainersAcrossApplicationAttempts()) {\n          // Do not recover containers for stopped attempt or previous attempt.\n          if (schedulerAttempt.isStopped() || !schedulerAttempt\n              .getApplicationAttemptId().equals(\n                  container.getContainerId().getApplicationAttemptId())) {\n            LOG.info(\"Skip recovering container \" + container\n                + \" for already stopped attempt.\");\n            killOrphanContainerOnNode(nm, container);\n            continue;\n          }\n        }\n\n        // create container\n        RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n        // recover RMContainer\n        rmContainer.handle(\n            new RMContainerRecoverEvent(container.getContainerId(), container));\n\n        // recover scheduler node\n        SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n        schedulerNode.recoverContainer(rmContainer);\n\n        // recover queue: update headroom etc.\n        Queue queue \u003d schedulerAttempt.getQueue();\n        queue.recoverContainer(getClusterResource(), schedulerAttempt,\n            rmContainer);\n\n        // recover scheduler attempt\n        schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n\n        // set master container for the current running AMContainer for this\n        // attempt.\n        RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n        if (appAttempt !\u003d null) {\n          Container masterContainer \u003d appAttempt.getMasterContainer();\n\n          // Mark current running AMContainer\u0027s RMContainer based on the master\n          // container ID stored in AppAttempt.\n          if (masterContainer !\u003d null \u0026\u0026 masterContainer.getId().equals(\n              rmContainer.getContainerId())) {\n            ((RMContainerImpl) rmContainer).setAMContainer(true);\n          }\n        }\n\n        if (schedulerAttempt.getPendingRelease().remove(\n            container.getContainerId())) {\n          // release the container\n          rmContainer.handle(\n              new RMContainerFinishedEvent(container.getContainerId(),\n                  SchedulerUtils\n                      .createAbnormalContainerStatus(container.getContainerId(),\n                          SchedulerUtils.RELEASED_CONTAINER),\n                  RMContainerEventType.RELEASED));\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "097baaaebae021c47bb7d69aa1ff1a2440df5166": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1815. Work preserving recovery of Unmanged AMs. Contributed by Subru Krishnan\n",
      "commitDate": "03/06/16 10:49 AM",
      "commitName": "097baaaebae021c47bb7d69aa1ff1a2440df5166",
      "commitAuthor": "Jian He",
      "commitDateOld": "05/05/16 12:56 PM",
      "commitNameOld": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 28.91,
      "commitsBetweenForRepo": 195,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,92 @@\n   public synchronized void recoverContainersOnNode(\n       List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n     if (!rmContext.isWorkPreservingRecoveryEnabled()\n         || containerReports \u003d\u003d null\n         || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n       return;\n     }\n \n     for (NMContainerStatus container : containerReports) {\n       ApplicationId appId \u003d\n           container.getContainerId().getApplicationAttemptId().getApplicationId();\n       RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n       if (rmApp \u003d\u003d null) {\n         LOG.error(\"Skip recovering container \" + container\n             + \" for unknown application.\");\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n-      // Unmanaged AM recovery is addressed in YARN-1815\n-      if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n-        LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n-            + rmApp.getApplicationId());\n-        killOrphanContainerOnNode(nm, container);\n-        continue;\n-      }\n-\n       SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n       if (schedulerApp \u003d\u003d null) {\n         LOG.info(\"Skip recovering container  \" + container\n             + \" for unknown SchedulerApplication. Application current state is \"\n             + rmApp.getState());\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       LOG.info(\"Recovering container \" + container);\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           schedulerApp.getCurrentAppAttempt();\n \n       if (!rmApp.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n         // Do not recover containers for stopped attempt or previous attempt.\n         if (schedulerAttempt.isStopped()\n             || !schedulerAttempt.getApplicationAttemptId().equals(\n               container.getContainerId().getApplicationAttemptId())) {\n           LOG.info(\"Skip recovering container \" + container\n               + \" for already stopped attempt.\");\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n       }\n \n       // create container\n       RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n \n       // recover RMContainer\n       rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n         container));\n \n       // recover scheduler node\n       SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n       schedulerNode.recoverContainer(rmContainer);\n \n       // recover queue: update headroom etc.\n       Queue queue \u003d schedulerAttempt.getQueue();\n       queue.recoverContainer(\n           getClusterResource(), schedulerAttempt, rmContainer);\n \n       // recover scheduler attempt\n       schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n             \n       // set master container for the current running AMContainer for this\n       // attempt.\n       RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n       if (appAttempt !\u003d null) {\n         Container masterContainer \u003d appAttempt.getMasterContainer();\n \n         // Mark current running AMContainer\u0027s RMContainer based on the master\n         // container ID stored in AppAttempt.\n         if (masterContainer !\u003d null\n             \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n           ((RMContainerImpl)rmContainer).setAMContainer(true);\n         }\n       }\n \n       synchronized (schedulerAttempt) {\n         Set\u003cContainerId\u003e releases \u003d schedulerAttempt.getPendingRelease();\n         if (releases.contains(container.getContainerId())) {\n           // release the container\n           rmContainer.handle(new RMContainerFinishedEvent(container\n             .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(\n             container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),\n             RMContainerEventType.RELEASED));\n           releases.remove(container.getContainerId());\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void recoverContainersOnNode(\n      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n    if (!rmContext.isWorkPreservingRecoveryEnabled()\n        || containerReports \u003d\u003d null\n        || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n      return;\n    }\n\n    for (NMContainerStatus container : containerReports) {\n      ApplicationId appId \u003d\n          container.getContainerId().getApplicationAttemptId().getApplicationId();\n      RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n      if (rmApp \u003d\u003d null) {\n        LOG.error(\"Skip recovering container \" + container\n            + \" for unknown application.\");\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n      if (schedulerApp \u003d\u003d null) {\n        LOG.info(\"Skip recovering container  \" + container\n            + \" for unknown SchedulerApplication. Application current state is \"\n            + rmApp.getState());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      LOG.info(\"Recovering container \" + container);\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          schedulerApp.getCurrentAppAttempt();\n\n      if (!rmApp.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n        // Do not recover containers for stopped attempt or previous attempt.\n        if (schedulerAttempt.isStopped()\n            || !schedulerAttempt.getApplicationAttemptId().equals(\n              container.getContainerId().getApplicationAttemptId())) {\n          LOG.info(\"Skip recovering container \" + container\n              + \" for already stopped attempt.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n      }\n\n      // create container\n      RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n      // recover RMContainer\n      rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n        container));\n\n      // recover scheduler node\n      SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n      schedulerNode.recoverContainer(rmContainer);\n\n      // recover queue: update headroom etc.\n      Queue queue \u003d schedulerAttempt.getQueue();\n      queue.recoverContainer(\n          getClusterResource(), schedulerAttempt, rmContainer);\n\n      // recover scheduler attempt\n      schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n            \n      // set master container for the current running AMContainer for this\n      // attempt.\n      RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n      if (appAttempt !\u003d null) {\n        Container masterContainer \u003d appAttempt.getMasterContainer();\n\n        // Mark current running AMContainer\u0027s RMContainer based on the master\n        // container ID stored in AppAttempt.\n        if (masterContainer !\u003d null\n            \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n          ((RMContainerImpl)rmContainer).setAMContainer(true);\n        }\n      }\n\n      synchronized (schedulerAttempt) {\n        Set\u003cContainerId\u003e releases \u003d schedulerAttempt.getPendingRelease();\n        if (releases.contains(container.getContainerId())) {\n          // release the container\n          rmContainer.handle(new RMContainerFinishedEvent(container\n            .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(\n            container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),\n            RMContainerEventType.RELEASED));\n          releases.remove(container.getContainerId());\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "20d389ce61eaacb5ddfb329015f50e96ad894f8d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4719. Add a helper library to maintain node state and allows common queries. (kasha)\n",
      "commitDate": "14/03/16 2:19 PM",
      "commitName": "20d389ce61eaacb5ddfb329015f50e96ad894f8d",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "10/02/16 6:06 PM",
      "commitNameOld": "d16b17b4d299b4d58f879a2a15708bacd0938685",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 32.8,
      "commitsBetweenForRepo": 206,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,100 @@\n   public synchronized void recoverContainersOnNode(\n       List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n     if (!rmContext.isWorkPreservingRecoveryEnabled()\n         || containerReports \u003d\u003d null\n         || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n       return;\n     }\n \n     for (NMContainerStatus container : containerReports) {\n       ApplicationId appId \u003d\n           container.getContainerId().getApplicationAttemptId().getApplicationId();\n       RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n       if (rmApp \u003d\u003d null) {\n         LOG.error(\"Skip recovering container \" + container\n             + \" for unknown application.\");\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       // Unmanaged AM recovery is addressed in YARN-1815\n       if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n         LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n             + rmApp.getApplicationId());\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n       if (schedulerApp \u003d\u003d null) {\n         LOG.info(\"Skip recovering container  \" + container\n             + \" for unknown SchedulerApplication. Application current state is \"\n             + rmApp.getState());\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       LOG.info(\"Recovering container \" + container);\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           schedulerApp.getCurrentAppAttempt();\n \n       if (!rmApp.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n         // Do not recover containers for stopped attempt or previous attempt.\n         if (schedulerAttempt.isStopped()\n             || !schedulerAttempt.getApplicationAttemptId().equals(\n               container.getContainerId().getApplicationAttemptId())) {\n           LOG.info(\"Skip recovering container \" + container\n               + \" for already stopped attempt.\");\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n       }\n \n       // create container\n       RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n \n       // recover RMContainer\n       rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n         container));\n \n       // recover scheduler node\n-      SchedulerNode schedulerNode \u003d nodes.get(nm.getNodeID());\n+      SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n       schedulerNode.recoverContainer(rmContainer);\n \n       // recover queue: update headroom etc.\n       Queue queue \u003d schedulerAttempt.getQueue();\n-      queue.recoverContainer(clusterResource, schedulerAttempt, rmContainer);\n+      queue.recoverContainer(\n+          getClusterResource(), schedulerAttempt, rmContainer);\n \n       // recover scheduler attempt\n       schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n             \n       // set master container for the current running AMContainer for this\n       // attempt.\n       RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n       if (appAttempt !\u003d null) {\n         Container masterContainer \u003d appAttempt.getMasterContainer();\n \n         // Mark current running AMContainer\u0027s RMContainer based on the master\n         // container ID stored in AppAttempt.\n         if (masterContainer !\u003d null\n             \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n           ((RMContainerImpl)rmContainer).setAMContainer(true);\n         }\n       }\n \n       synchronized (schedulerAttempt) {\n         Set\u003cContainerId\u003e releases \u003d schedulerAttempt.getPendingRelease();\n         if (releases.contains(container.getContainerId())) {\n           // release the container\n           rmContainer.handle(new RMContainerFinishedEvent(container\n             .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(\n             container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),\n             RMContainerEventType.RELEASED));\n           releases.remove(container.getContainerId());\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void recoverContainersOnNode(\n      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n    if (!rmContext.isWorkPreservingRecoveryEnabled()\n        || containerReports \u003d\u003d null\n        || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n      return;\n    }\n\n    for (NMContainerStatus container : containerReports) {\n      ApplicationId appId \u003d\n          container.getContainerId().getApplicationAttemptId().getApplicationId();\n      RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n      if (rmApp \u003d\u003d null) {\n        LOG.error(\"Skip recovering container \" + container\n            + \" for unknown application.\");\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      // Unmanaged AM recovery is addressed in YARN-1815\n      if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n        LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n            + rmApp.getApplicationId());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n      if (schedulerApp \u003d\u003d null) {\n        LOG.info(\"Skip recovering container  \" + container\n            + \" for unknown SchedulerApplication. Application current state is \"\n            + rmApp.getState());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      LOG.info(\"Recovering container \" + container);\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          schedulerApp.getCurrentAppAttempt();\n\n      if (!rmApp.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n        // Do not recover containers for stopped attempt or previous attempt.\n        if (schedulerAttempt.isStopped()\n            || !schedulerAttempt.getApplicationAttemptId().equals(\n              container.getContainerId().getApplicationAttemptId())) {\n          LOG.info(\"Skip recovering container \" + container\n              + \" for already stopped attempt.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n      }\n\n      // create container\n      RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n      // recover RMContainer\n      rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n        container));\n\n      // recover scheduler node\n      SchedulerNode schedulerNode \u003d nodeTracker.getNode(nm.getNodeID());\n      schedulerNode.recoverContainer(rmContainer);\n\n      // recover queue: update headroom etc.\n      Queue queue \u003d schedulerAttempt.getQueue();\n      queue.recoverContainer(\n          getClusterResource(), schedulerAttempt, rmContainer);\n\n      // recover scheduler attempt\n      schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n            \n      // set master container for the current running AMContainer for this\n      // attempt.\n      RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n      if (appAttempt !\u003d null) {\n        Container masterContainer \u003d appAttempt.getMasterContainer();\n\n        // Mark current running AMContainer\u0027s RMContainer based on the master\n        // container ID stored in AppAttempt.\n        if (masterContainer !\u003d null\n            \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n          ((RMContainerImpl)rmContainer).setAMContainer(true);\n        }\n      }\n\n      synchronized (schedulerAttempt) {\n        Set\u003cContainerId\u003e releases \u003d schedulerAttempt.getPendingRelease();\n        if (releases.contains(container.getContainerId())) {\n          // release the container\n          rmContainer.handle(new RMContainerFinishedEvent(container\n            .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(\n            container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),\n            RMContainerEventType.RELEASED));\n          releases.remove(container.getContainerId());\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "586348e4cbf197188057d6b843a6701cfffdaff3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3356. Capacity Scheduler FiCaSchedulerApp should use ResourceUsage to track used-resources-by-label. Contributed by Wangda Tan\n",
      "commitDate": "20/03/15 1:54 PM",
      "commitName": "586348e4cbf197188057d6b843a6701cfffdaff3",
      "commitAuthor": "Jian He",
      "commitDateOld": "27/02/15 4:13 PM",
      "commitNameOld": "edcecedc1c39d54db0f86a1325b4db26c38d2d4d",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 20.86,
      "commitsBetweenForRepo": 183,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,99 @@\n   public synchronized void recoverContainersOnNode(\n       List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n     if (!rmContext.isWorkPreservingRecoveryEnabled()\n         || containerReports \u003d\u003d null\n         || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n       return;\n     }\n \n     for (NMContainerStatus container : containerReports) {\n       ApplicationId appId \u003d\n           container.getContainerId().getApplicationAttemptId().getApplicationId();\n       RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n       if (rmApp \u003d\u003d null) {\n         LOG.error(\"Skip recovering container \" + container\n             + \" for unknown application.\");\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       // Unmanaged AM recovery is addressed in YARN-1815\n       if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n         LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n             + rmApp.getApplicationId());\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n       if (schedulerApp \u003d\u003d null) {\n         LOG.info(\"Skip recovering container  \" + container\n             + \" for unknown SchedulerApplication. Application current state is \"\n             + rmApp.getState());\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       LOG.info(\"Recovering container \" + container);\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           schedulerApp.getCurrentAppAttempt();\n \n       if (!rmApp.getApplicationSubmissionContext()\n         .getKeepContainersAcrossApplicationAttempts()) {\n         // Do not recover containers for stopped attempt or previous attempt.\n         if (schedulerAttempt.isStopped()\n             || !schedulerAttempt.getApplicationAttemptId().equals(\n               container.getContainerId().getApplicationAttemptId())) {\n           LOG.info(\"Skip recovering container \" + container\n               + \" for already stopped attempt.\");\n           killOrphanContainerOnNode(nm, container);\n           continue;\n         }\n       }\n \n       // create container\n       RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n \n       // recover RMContainer\n       rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n         container));\n \n       // recover scheduler node\n-      nodes.get(nm.getNodeID()).recoverContainer(rmContainer);\n+      SchedulerNode schedulerNode \u003d nodes.get(nm.getNodeID());\n+      schedulerNode.recoverContainer(rmContainer);\n \n       // recover queue: update headroom etc.\n       Queue queue \u003d schedulerAttempt.getQueue();\n       queue.recoverContainer(clusterResource, schedulerAttempt, rmContainer);\n \n       // recover scheduler attempt\n-      schedulerAttempt.recoverContainer(rmContainer);\n+      schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n             \n       // set master container for the current running AMContainer for this\n       // attempt.\n       RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n       if (appAttempt !\u003d null) {\n         Container masterContainer \u003d appAttempt.getMasterContainer();\n \n         // Mark current running AMContainer\u0027s RMContainer based on the master\n         // container ID stored in AppAttempt.\n         if (masterContainer !\u003d null\n             \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n           ((RMContainerImpl)rmContainer).setAMContainer(true);\n         }\n       }\n \n       synchronized (schedulerAttempt) {\n         Set\u003cContainerId\u003e releases \u003d schedulerAttempt.getPendingRelease();\n         if (releases.contains(container.getContainerId())) {\n           // release the container\n           rmContainer.handle(new RMContainerFinishedEvent(container\n             .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(\n             container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),\n             RMContainerEventType.RELEASED));\n           releases.remove(container.getContainerId());\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void recoverContainersOnNode(\n      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n    if (!rmContext.isWorkPreservingRecoveryEnabled()\n        || containerReports \u003d\u003d null\n        || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n      return;\n    }\n\n    for (NMContainerStatus container : containerReports) {\n      ApplicationId appId \u003d\n          container.getContainerId().getApplicationAttemptId().getApplicationId();\n      RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n      if (rmApp \u003d\u003d null) {\n        LOG.error(\"Skip recovering container \" + container\n            + \" for unknown application.\");\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      // Unmanaged AM recovery is addressed in YARN-1815\n      if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n        LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n            + rmApp.getApplicationId());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n      if (schedulerApp \u003d\u003d null) {\n        LOG.info(\"Skip recovering container  \" + container\n            + \" for unknown SchedulerApplication. Application current state is \"\n            + rmApp.getState());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      LOG.info(\"Recovering container \" + container);\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          schedulerApp.getCurrentAppAttempt();\n\n      if (!rmApp.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n        // Do not recover containers for stopped attempt or previous attempt.\n        if (schedulerAttempt.isStopped()\n            || !schedulerAttempt.getApplicationAttemptId().equals(\n              container.getContainerId().getApplicationAttemptId())) {\n          LOG.info(\"Skip recovering container \" + container\n              + \" for already stopped attempt.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n      }\n\n      // create container\n      RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n      // recover RMContainer\n      rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n        container));\n\n      // recover scheduler node\n      SchedulerNode schedulerNode \u003d nodes.get(nm.getNodeID());\n      schedulerNode.recoverContainer(rmContainer);\n\n      // recover queue: update headroom etc.\n      Queue queue \u003d schedulerAttempt.getQueue();\n      queue.recoverContainer(clusterResource, schedulerAttempt, rmContainer);\n\n      // recover scheduler attempt\n      schedulerAttempt.recoverContainer(schedulerNode, rmContainer);\n            \n      // set master container for the current running AMContainer for this\n      // attempt.\n      RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n      if (appAttempt !\u003d null) {\n        Container masterContainer \u003d appAttempt.getMasterContainer();\n\n        // Mark current running AMContainer\u0027s RMContainer based on the master\n        // container ID stored in AppAttempt.\n        if (masterContainer !\u003d null\n            \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n          ((RMContainerImpl)rmContainer).setAMContainer(true);\n        }\n      }\n\n      synchronized (schedulerAttempt) {\n        Set\u003cContainerId\u003e releases \u003d schedulerAttempt.getPendingRelease();\n        if (releases.contains(container.getContainerId())) {\n          // release the container\n          rmContainer.handle(new RMContainerFinishedEvent(container\n            .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(\n            container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),\n            RMContainerEventType.RELEASED));\n          releases.remove(container.getContainerId());\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "4236c6600eda9cdda708d02f3a5a3fe31228f70c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2434. RM should not recover containers from previously failed attempt when AM restart is not enabled. Contributed by Jian He\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1619614 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/08/14 3:41 PM",
      "commitName": "4236c6600eda9cdda708d02f3a5a3fe31228f70c",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "19/08/14 1:33 PM",
      "commitNameOld": "f6a778c3725bcdaba1e1de43786af17dd44deb78",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 2.09,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,98 @@\n   public synchronized void recoverContainersOnNode(\n       List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n     if (!rmContext.isWorkPreservingRecoveryEnabled()\n         || containerReports \u003d\u003d null\n         || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n       return;\n     }\n \n     for (NMContainerStatus container : containerReports) {\n       ApplicationId appId \u003d\n           container.getContainerId().getApplicationAttemptId().getApplicationId();\n       RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n       if (rmApp \u003d\u003d null) {\n         LOG.error(\"Skip recovering container \" + container\n             + \" for unknown application.\");\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       // Unmanaged AM recovery is addressed in YARN-1815\n       if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n         LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n             + rmApp.getApplicationId());\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n       if (schedulerApp \u003d\u003d null) {\n         LOG.info(\"Skip recovering container  \" + container\n             + \" for unknown SchedulerApplication. Application current state is \"\n             + rmApp.getState());\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       LOG.info(\"Recovering container \" + container);\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           schedulerApp.getCurrentAppAttempt();\n \n+      if (!rmApp.getApplicationSubmissionContext()\n+        .getKeepContainersAcrossApplicationAttempts()) {\n+        // Do not recover containers for stopped attempt or previous attempt.\n+        if (schedulerAttempt.isStopped()\n+            || !schedulerAttempt.getApplicationAttemptId().equals(\n+              container.getContainerId().getApplicationAttemptId())) {\n+          LOG.info(\"Skip recovering container \" + container\n+              + \" for already stopped attempt.\");\n+          killOrphanContainerOnNode(nm, container);\n+          continue;\n+        }\n+      }\n+\n       // create container\n       RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n \n       // recover RMContainer\n       rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n         container));\n \n       // recover scheduler node\n       nodes.get(nm.getNodeID()).recoverContainer(rmContainer);\n \n       // recover queue: update headroom etc.\n       Queue queue \u003d schedulerAttempt.getQueue();\n       queue.recoverContainer(clusterResource, schedulerAttempt, rmContainer);\n \n       // recover scheduler attempt\n       schedulerAttempt.recoverContainer(rmContainer);\n             \n       // set master container for the current running AMContainer for this\n       // attempt.\n       RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n       if (appAttempt !\u003d null) {\n         Container masterContainer \u003d appAttempt.getMasterContainer();\n \n         // Mark current running AMContainer\u0027s RMContainer based on the master\n         // container ID stored in AppAttempt.\n         if (masterContainer !\u003d null\n             \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n           ((RMContainerImpl)rmContainer).setAMContainer(true);\n         }\n       }\n \n       synchronized (schedulerAttempt) {\n         Set\u003cContainerId\u003e releases \u003d schedulerAttempt.getPendingRelease();\n         if (releases.contains(container.getContainerId())) {\n           // release the container\n           rmContainer.handle(new RMContainerFinishedEvent(container\n             .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(\n             container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),\n             RMContainerEventType.RELEASED));\n           releases.remove(container.getContainerId());\n           LOG.info(container.getContainerId() + \" is released by application.\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void recoverContainersOnNode(\n      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n    if (!rmContext.isWorkPreservingRecoveryEnabled()\n        || containerReports \u003d\u003d null\n        || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n      return;\n    }\n\n    for (NMContainerStatus container : containerReports) {\n      ApplicationId appId \u003d\n          container.getContainerId().getApplicationAttemptId().getApplicationId();\n      RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n      if (rmApp \u003d\u003d null) {\n        LOG.error(\"Skip recovering container \" + container\n            + \" for unknown application.\");\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      // Unmanaged AM recovery is addressed in YARN-1815\n      if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n        LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n            + rmApp.getApplicationId());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n      if (schedulerApp \u003d\u003d null) {\n        LOG.info(\"Skip recovering container  \" + container\n            + \" for unknown SchedulerApplication. Application current state is \"\n            + rmApp.getState());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      LOG.info(\"Recovering container \" + container);\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          schedulerApp.getCurrentAppAttempt();\n\n      if (!rmApp.getApplicationSubmissionContext()\n        .getKeepContainersAcrossApplicationAttempts()) {\n        // Do not recover containers for stopped attempt or previous attempt.\n        if (schedulerAttempt.isStopped()\n            || !schedulerAttempt.getApplicationAttemptId().equals(\n              container.getContainerId().getApplicationAttemptId())) {\n          LOG.info(\"Skip recovering container \" + container\n              + \" for already stopped attempt.\");\n          killOrphanContainerOnNode(nm, container);\n          continue;\n        }\n      }\n\n      // create container\n      RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n      // recover RMContainer\n      rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n        container));\n\n      // recover scheduler node\n      nodes.get(nm.getNodeID()).recoverContainer(rmContainer);\n\n      // recover queue: update headroom etc.\n      Queue queue \u003d schedulerAttempt.getQueue();\n      queue.recoverContainer(clusterResource, schedulerAttempt, rmContainer);\n\n      // recover scheduler attempt\n      schedulerAttempt.recoverContainer(rmContainer);\n            \n      // set master container for the current running AMContainer for this\n      // attempt.\n      RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n      if (appAttempt !\u003d null) {\n        Container masterContainer \u003d appAttempt.getMasterContainer();\n\n        // Mark current running AMContainer\u0027s RMContainer based on the master\n        // container ID stored in AppAttempt.\n        if (masterContainer !\u003d null\n            \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n          ((RMContainerImpl)rmContainer).setAMContainer(true);\n        }\n      }\n\n      synchronized (schedulerAttempt) {\n        Set\u003cContainerId\u003e releases \u003d schedulerAttempt.getPendingRelease();\n        if (releases.contains(container.getContainerId())) {\n          // release the container\n          rmContainer.handle(new RMContainerFinishedEvent(container\n            .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(\n            container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),\n            RMContainerEventType.RELEASED));\n          releases.remove(container.getContainerId());\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "f6a778c3725bcdaba1e1de43786af17dd44deb78": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2249. Avoided AM release requests being lost on work preserving RM restart. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1618972 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/14 1:33 PM",
      "commitName": "f6a778c3725bcdaba1e1de43786af17dd44deb78",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "15/08/14 4:53 PM",
      "commitNameOld": "c3084d6c1661332a4771882529077e778d9c5692",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 3.86,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,85 @@\n   public synchronized void recoverContainersOnNode(\n       List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n     if (!rmContext.isWorkPreservingRecoveryEnabled()\n         || containerReports \u003d\u003d null\n         || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n       return;\n     }\n \n     for (NMContainerStatus container : containerReports) {\n       ApplicationId appId \u003d\n           container.getContainerId().getApplicationAttemptId().getApplicationId();\n       RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n       if (rmApp \u003d\u003d null) {\n         LOG.error(\"Skip recovering container \" + container\n             + \" for unknown application.\");\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       // Unmanaged AM recovery is addressed in YARN-1815\n       if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n         LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n             + rmApp.getApplicationId());\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n       if (schedulerApp \u003d\u003d null) {\n         LOG.info(\"Skip recovering container  \" + container\n             + \" for unknown SchedulerApplication. Application current state is \"\n             + rmApp.getState());\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       LOG.info(\"Recovering container \" + container);\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           schedulerApp.getCurrentAppAttempt();\n \n       // create container\n       RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n \n       // recover RMContainer\n       rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n         container));\n \n       // recover scheduler node\n       nodes.get(nm.getNodeID()).recoverContainer(rmContainer);\n \n       // recover queue: update headroom etc.\n       Queue queue \u003d schedulerAttempt.getQueue();\n       queue.recoverContainer(clusterResource, schedulerAttempt, rmContainer);\n \n       // recover scheduler attempt\n       schedulerAttempt.recoverContainer(rmContainer);\n             \n       // set master container for the current running AMContainer for this\n       // attempt.\n       RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n       if (appAttempt !\u003d null) {\n         Container masterContainer \u003d appAttempt.getMasterContainer();\n \n         // Mark current running AMContainer\u0027s RMContainer based on the master\n         // container ID stored in AppAttempt.\n         if (masterContainer !\u003d null\n             \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n           ((RMContainerImpl)rmContainer).setAMContainer(true);\n         }\n       }\n+\n+      synchronized (schedulerAttempt) {\n+        Set\u003cContainerId\u003e releases \u003d schedulerAttempt.getPendingRelease();\n+        if (releases.contains(container.getContainerId())) {\n+          // release the container\n+          rmContainer.handle(new RMContainerFinishedEvent(container\n+            .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(\n+            container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),\n+            RMContainerEventType.RELEASED));\n+          releases.remove(container.getContainerId());\n+          LOG.info(container.getContainerId() + \" is released by application.\");\n+        }\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void recoverContainersOnNode(\n      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n    if (!rmContext.isWorkPreservingRecoveryEnabled()\n        || containerReports \u003d\u003d null\n        || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n      return;\n    }\n\n    for (NMContainerStatus container : containerReports) {\n      ApplicationId appId \u003d\n          container.getContainerId().getApplicationAttemptId().getApplicationId();\n      RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n      if (rmApp \u003d\u003d null) {\n        LOG.error(\"Skip recovering container \" + container\n            + \" for unknown application.\");\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      // Unmanaged AM recovery is addressed in YARN-1815\n      if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n        LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n            + rmApp.getApplicationId());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n      if (schedulerApp \u003d\u003d null) {\n        LOG.info(\"Skip recovering container  \" + container\n            + \" for unknown SchedulerApplication. Application current state is \"\n            + rmApp.getState());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      LOG.info(\"Recovering container \" + container);\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          schedulerApp.getCurrentAppAttempt();\n\n      // create container\n      RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n      // recover RMContainer\n      rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n        container));\n\n      // recover scheduler node\n      nodes.get(nm.getNodeID()).recoverContainer(rmContainer);\n\n      // recover queue: update headroom etc.\n      Queue queue \u003d schedulerAttempt.getQueue();\n      queue.recoverContainer(clusterResource, schedulerAttempt, rmContainer);\n\n      // recover scheduler attempt\n      schedulerAttempt.recoverContainer(rmContainer);\n            \n      // set master container for the current running AMContainer for this\n      // attempt.\n      RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n      if (appAttempt !\u003d null) {\n        Container masterContainer \u003d appAttempt.getMasterContainer();\n\n        // Mark current running AMContainer\u0027s RMContainer based on the master\n        // container ID stored in AppAttempt.\n        if (masterContainer !\u003d null\n            \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n          ((RMContainerImpl)rmContainer).setAMContainer(true);\n        }\n      }\n\n      synchronized (schedulerAttempt) {\n        Set\u003cContainerId\u003e releases \u003d schedulerAttempt.getPendingRelease();\n        if (releases.contains(container.getContainerId())) {\n          // release the container\n          rmContainer.handle(new RMContainerFinishedEvent(container\n            .getContainerId(), SchedulerUtils.createAbnormalContainerStatus(\n            container.getContainerId(), SchedulerUtils.RELEASED_CONTAINER),\n            RMContainerEventType.RELEASED));\n          releases.remove(container.getContainerId());\n          LOG.info(container.getContainerId() + \" is released by application.\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "03a25d2cc1a2fb124d00edf874d67e329c65a5e6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2022 Preempting an Application Master container can be kept as least priority when multiple applications are marked for preemption by ProportionalCapacityPreemptionPolicy (Sunil G via mayank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1607227 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/07/14 6:54 PM",
      "commitName": "03a25d2cc1a2fb124d00edf874d67e329c65a5e6",
      "commitAuthor": "Mayank Bansal",
      "commitDateOld": "24/06/14 2:43 PM",
      "commitNameOld": "e285b98f0fe8637b574c52498035f7f11fb4e962",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.17,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,72 @@\n   public synchronized void recoverContainersOnNode(\n       List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n     if (!rmContext.isWorkPreservingRecoveryEnabled()\n         || containerReports \u003d\u003d null\n         || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n       return;\n     }\n \n     for (NMContainerStatus container : containerReports) {\n       ApplicationId appId \u003d\n           container.getContainerId().getApplicationAttemptId().getApplicationId();\n       RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n       if (rmApp \u003d\u003d null) {\n         LOG.error(\"Skip recovering container \" + container\n             + \" for unknown application.\");\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       // Unmanaged AM recovery is addressed in YARN-1815\n       if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n         LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n             + rmApp.getApplicationId());\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n       if (schedulerApp \u003d\u003d null) {\n         LOG.info(\"Skip recovering container  \" + container\n             + \" for unknown SchedulerApplication. Application current state is \"\n             + rmApp.getState());\n         killOrphanContainerOnNode(nm, container);\n         continue;\n       }\n \n       LOG.info(\"Recovering container \" + container);\n       SchedulerApplicationAttempt schedulerAttempt \u003d\n           schedulerApp.getCurrentAppAttempt();\n \n       // create container\n       RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n \n       // recover RMContainer\n       rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n         container));\n \n       // recover scheduler node\n       nodes.get(nm.getNodeID()).recoverContainer(rmContainer);\n \n       // recover queue: update headroom etc.\n       Queue queue \u003d schedulerAttempt.getQueue();\n       queue.recoverContainer(clusterResource, schedulerAttempt, rmContainer);\n \n       // recover scheduler attempt\n       schedulerAttempt.recoverContainer(rmContainer);\n+            \n+      // set master container for the current running AMContainer for this\n+      // attempt.\n+      RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n+      if (appAttempt !\u003d null) {\n+        Container masterContainer \u003d appAttempt.getMasterContainer();\n+\n+        // Mark current running AMContainer\u0027s RMContainer based on the master\n+        // container ID stored in AppAttempt.\n+        if (masterContainer !\u003d null\n+            \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n+          ((RMContainerImpl)rmContainer).setAMContainer(true);\n+        }\n+      }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void recoverContainersOnNode(\n      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n    if (!rmContext.isWorkPreservingRecoveryEnabled()\n        || containerReports \u003d\u003d null\n        || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n      return;\n    }\n\n    for (NMContainerStatus container : containerReports) {\n      ApplicationId appId \u003d\n          container.getContainerId().getApplicationAttemptId().getApplicationId();\n      RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n      if (rmApp \u003d\u003d null) {\n        LOG.error(\"Skip recovering container \" + container\n            + \" for unknown application.\");\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      // Unmanaged AM recovery is addressed in YARN-1815\n      if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n        LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n            + rmApp.getApplicationId());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n      if (schedulerApp \u003d\u003d null) {\n        LOG.info(\"Skip recovering container  \" + container\n            + \" for unknown SchedulerApplication. Application current state is \"\n            + rmApp.getState());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      LOG.info(\"Recovering container \" + container);\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          schedulerApp.getCurrentAppAttempt();\n\n      // create container\n      RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n      // recover RMContainer\n      rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n        container));\n\n      // recover scheduler node\n      nodes.get(nm.getNodeID()).recoverContainer(rmContainer);\n\n      // recover queue: update headroom etc.\n      Queue queue \u003d schedulerAttempt.getQueue();\n      queue.recoverContainer(clusterResource, schedulerAttempt, rmContainer);\n\n      // recover scheduler attempt\n      schedulerAttempt.recoverContainer(rmContainer);\n            \n      // set master container for the current running AMContainer for this\n      // attempt.\n      RMAppAttempt appAttempt \u003d rmApp.getCurrentAppAttempt();\n      if (appAttempt !\u003d null) {\n        Container masterContainer \u003d appAttempt.getMasterContainer();\n\n        // Mark current running AMContainer\u0027s RMContainer based on the master\n        // container ID stored in AppAttempt.\n        if (masterContainer !\u003d null\n            \u0026\u0026 masterContainer.getId().equals(rmContainer.getContainerId())) {\n          ((RMContainerImpl)rmContainer).setAMContainer(true);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java",
      "extendedDetails": {}
    },
    "424fd9494f144c035fdef8c533be51e2027ad8d9": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1368. Added core functionality of recovering container state into schedulers after ResourceManager Restart so as to preserve running work in the cluster. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601303 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/06/14 8:09 PM",
      "commitName": "424fd9494f144c035fdef8c533be51e2027ad8d9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,58 @@\n+  public synchronized void recoverContainersOnNode(\n+      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n+    if (!rmContext.isWorkPreservingRecoveryEnabled()\n+        || containerReports \u003d\u003d null\n+        || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n+      return;\n+    }\n+\n+    for (NMContainerStatus container : containerReports) {\n+      ApplicationId appId \u003d\n+          container.getContainerId().getApplicationAttemptId().getApplicationId();\n+      RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n+      if (rmApp \u003d\u003d null) {\n+        LOG.error(\"Skip recovering container \" + container\n+            + \" for unknown application.\");\n+        killOrphanContainerOnNode(nm, container);\n+        continue;\n+      }\n+\n+      // Unmanaged AM recovery is addressed in YARN-1815\n+      if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n+        LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n+            + rmApp.getApplicationId());\n+        killOrphanContainerOnNode(nm, container);\n+        continue;\n+      }\n+\n+      SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n+      if (schedulerApp \u003d\u003d null) {\n+        LOG.info(\"Skip recovering container  \" + container\n+            + \" for unknown SchedulerApplication. Application current state is \"\n+            + rmApp.getState());\n+        killOrphanContainerOnNode(nm, container);\n+        continue;\n+      }\n+\n+      LOG.info(\"Recovering container \" + container);\n+      SchedulerApplicationAttempt schedulerAttempt \u003d\n+          schedulerApp.getCurrentAppAttempt();\n+\n+      // create container\n+      RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n+\n+      // recover RMContainer\n+      rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n+        container));\n+\n+      // recover scheduler node\n+      nodes.get(nm.getNodeID()).recoverContainer(rmContainer);\n+\n+      // recover queue: update headroom etc.\n+      Queue queue \u003d schedulerAttempt.getQueue();\n+      queue.recoverContainer(clusterResource, schedulerAttempt, rmContainer);\n+\n+      // recover scheduler attempt\n+      schedulerAttempt.recoverContainer(rmContainer);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void recoverContainersOnNode(\n      List\u003cNMContainerStatus\u003e containerReports, RMNode nm) {\n    if (!rmContext.isWorkPreservingRecoveryEnabled()\n        || containerReports \u003d\u003d null\n        || (containerReports !\u003d null \u0026\u0026 containerReports.isEmpty())) {\n      return;\n    }\n\n    for (NMContainerStatus container : containerReports) {\n      ApplicationId appId \u003d\n          container.getContainerId().getApplicationAttemptId().getApplicationId();\n      RMApp rmApp \u003d rmContext.getRMApps().get(appId);\n      if (rmApp \u003d\u003d null) {\n        LOG.error(\"Skip recovering container \" + container\n            + \" for unknown application.\");\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      // Unmanaged AM recovery is addressed in YARN-1815\n      if (rmApp.getApplicationSubmissionContext().getUnmanagedAM()) {\n        LOG.info(\"Skip recovering container \" + container + \" for unmanaged AM.\"\n            + rmApp.getApplicationId());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      SchedulerApplication\u003cT\u003e schedulerApp \u003d applications.get(appId);\n      if (schedulerApp \u003d\u003d null) {\n        LOG.info(\"Skip recovering container  \" + container\n            + \" for unknown SchedulerApplication. Application current state is \"\n            + rmApp.getState());\n        killOrphanContainerOnNode(nm, container);\n        continue;\n      }\n\n      LOG.info(\"Recovering container \" + container);\n      SchedulerApplicationAttempt schedulerAttempt \u003d\n          schedulerApp.getCurrentAppAttempt();\n\n      // create container\n      RMContainer rmContainer \u003d recoverAndCreateContainer(container, nm);\n\n      // recover RMContainer\n      rmContainer.handle(new RMContainerRecoverEvent(container.getContainerId(),\n        container));\n\n      // recover scheduler node\n      nodes.get(nm.getNodeID()).recoverContainer(rmContainer);\n\n      // recover queue: update headroom etc.\n      Queue queue \u003d schedulerAttempt.getQueue();\n      queue.recoverContainer(clusterResource, schedulerAttempt, rmContainer);\n\n      // recover scheduler attempt\n      schedulerAttempt.recoverContainer(rmContainer);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/AbstractYarnScheduler.java"
    }
  }
}