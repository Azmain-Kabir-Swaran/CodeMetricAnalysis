{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SLSWebApp.java",
  "functionName": "generateRealTimeTrackingMetrics",
  "functionId": "generateRealTimeTrackingMetrics",
  "sourceFilePath": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/web/SLSWebApp.java",
  "functionStartLine": 317,
  "functionEndLine": 547,
  "numCommitsSeen": 10,
  "timeTaken": 1189,
  "changeHistory": [
    "ba2db39c655600d00d2d3d3951e0c780f4d6f622",
    "6a5516c2381f107d96b8326939514de3c6e53d3d",
    "58b08e11b9f04c9190ab4a07473f0ee04e01ec6b"
  ],
  "changeHistoryShort": {
    "ba2db39c655600d00d2d3d3951e0c780f4d6f622": "Ybodychange",
    "6a5516c2381f107d96b8326939514de3c6e53d3d": "Ybodychange",
    "58b08e11b9f04c9190ab4a07473f0ee04e01ec6b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "ba2db39c655600d00d2d3d3951e0c780f4d6f622": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8152. Add chart in SLS to illustrate the throughput of the scheduler. Contributed by Tao Yang.\n",
      "commitDate": "27/04/18 12:36 AM",
      "commitName": "ba2db39c655600d00d2d3d3951e0c780f4d6f622",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "10/05/17 3:57 AM",
      "commitNameOld": "2ba9903932e3c99afb0e6abb7cd3c5d29a554bd9",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 351.86,
      "commitsBetweenForRepo": 3024,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,171 +1,231 @@\n   public String generateRealTimeTrackingMetrics() {\n     // JVM\n     double jvmFreeMemoryGB, jvmMaxMemoryGB, jvmTotalMemoryGB;\n     if (jvmFreeMemoryGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges().containsKey(\"variable.jvm.free.memory\")) {\n       jvmFreeMemoryGauge \u003d metrics.getGauges().get(\"variable.jvm.free.memory\");\n     }\n     if (jvmMaxMemoryGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges().containsKey(\"variable.jvm.max.memory\")) {\n       jvmMaxMemoryGauge \u003d metrics.getGauges().get(\"variable.jvm.max.memory\");\n     }\n     if (jvmTotalMemoryGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges().containsKey(\"variable.jvm.total.memory\")) {\n       jvmTotalMemoryGauge \u003d metrics.getGauges()\n               .get(\"variable.jvm.total.memory\");\n     }\n     jvmFreeMemoryGB \u003d jvmFreeMemoryGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(jvmFreeMemoryGauge.getValue().toString())\n                     /1024/1024/1024;\n     jvmMaxMemoryGB \u003d jvmMaxMemoryGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(jvmMaxMemoryGauge.getValue().toString())\n                     /1024/1024/1024;\n     jvmTotalMemoryGB \u003d jvmTotalMemoryGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(jvmTotalMemoryGauge.getValue().toString())\n                     /1024/1024/1024;\n \n     // number of running applications/containers\n     String numRunningApps, numRunningContainers;\n     if (numRunningAppsGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges().containsKey(\"variable.running.application\")) {\n       numRunningAppsGauge \u003d\n               metrics.getGauges().get(\"variable.running.application\");\n     }\n     if (numRunningContainersGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges().containsKey(\"variable.running.container\")) {\n       numRunningContainersGauge \u003d\n               metrics.getGauges().get(\"variable.running.container\");\n     }\n     numRunningApps \u003d numRunningAppsGauge \u003d\u003d null ? \"0\" :\n             numRunningAppsGauge.getValue().toString();\n     numRunningContainers \u003d numRunningContainersGauge \u003d\u003d null ? \"0\" :\n             numRunningContainersGauge.getValue().toString();\n \n     // cluster available/allocate resource\n     double allocatedMemoryGB, allocatedVCoresGB,\n             availableMemoryGB, availableVCoresGB;\n     if (allocatedMemoryGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges()\n                     .containsKey(\"variable.cluster.allocated.memory\")) {\n       allocatedMemoryGauge \u003d metrics.getGauges()\n               .get(\"variable.cluster.allocated.memory\");\n     }\n     if (allocatedVCoresGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges()\n                     .containsKey(\"variable.cluster.allocated.vcores\")) {\n       allocatedVCoresGauge \u003d metrics.getGauges()\n               .get(\"variable.cluster.allocated.vcores\");\n     }\n     if (availableMemoryGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges()\n                     .containsKey(\"variable.cluster.available.memory\")) {\n       availableMemoryGauge \u003d metrics.getGauges()\n               .get(\"variable.cluster.available.memory\");\n     }\n     if (availableVCoresGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges()\n                     .containsKey(\"variable.cluster.available.vcores\")) {\n       availableVCoresGauge \u003d metrics.getGauges()\n               .get(\"variable.cluster.available.vcores\");\n     }\n     allocatedMemoryGB \u003d allocatedMemoryGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(allocatedMemoryGauge.getValue().toString())/1024;\n     allocatedVCoresGB \u003d allocatedVCoresGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(allocatedVCoresGauge.getValue().toString());\n     availableMemoryGB \u003d availableMemoryGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(availableMemoryGauge.getValue().toString())/1024;\n     availableVCoresGB \u003d availableVCoresGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(availableVCoresGauge.getValue().toString());\n \n     // scheduler operation\n-    double allocateTimecost, handleTimecost;\n+    double allocateTimecost, commitSuccessTimecost, commitFailureTimecost,\n+        handleTimecost;\n     if (allocateTimecostHistogram \u003d\u003d null \u0026\u0026\n             metrics.getHistograms().containsKey(\n                     \"sampler.scheduler.operation.allocate.timecost\")) {\n       allocateTimecostHistogram \u003d metrics.getHistograms()\n               .get(\"sampler.scheduler.operation.allocate.timecost\");\n     }\n+    if (commitSuccessTimecostHistogram \u003d\u003d null \u0026\u0026\n+        metrics.getHistograms().containsKey(\n+            \"sampler.scheduler.operation.commit.success.timecost\")) {\n+      commitSuccessTimecostHistogram \u003d metrics.getHistograms()\n+          .get(\"sampler.scheduler.operation.commit.success.timecost\");\n+    }\n+    if (commitFailureTimecostHistogram \u003d\u003d null \u0026\u0026\n+        metrics.getHistograms().containsKey(\n+            \"sampler.scheduler.operation.commit.failure.timecost\")) {\n+      commitFailureTimecostHistogram \u003d metrics.getHistograms()\n+          .get(\"sampler.scheduler.operation.commit.failure.timecost\");\n+    }\n     if (handleTimecostHistogram \u003d\u003d null \u0026\u0026\n             metrics.getHistograms().containsKey(\n                     \"sampler.scheduler.operation.handle.timecost\")) {\n       handleTimecostHistogram \u003d metrics.getHistograms()\n               .get(\"sampler.scheduler.operation.handle.timecost\");\n     }\n     allocateTimecost \u003d allocateTimecostHistogram \u003d\u003d null ? 0.0 :\n             allocateTimecostHistogram.getSnapshot().getMean()/1000000;\n+    commitSuccessTimecost \u003d commitSuccessTimecostHistogram \u003d\u003d null ? 0.0 :\n+            commitSuccessTimecostHistogram.getSnapshot().getMean()/1000000;\n+    commitFailureTimecost \u003d commitFailureTimecostHistogram \u003d\u003d null ? 0.0 :\n+            commitFailureTimecostHistogram.getSnapshot().getMean()/1000000;\n     handleTimecost \u003d handleTimecostHistogram \u003d\u003d null ? 0.0 :\n             handleTimecostHistogram.getSnapshot().getMean()/1000000;\n     // various handle operation\n     Map\u003cSchedulerEventType, Double\u003e handleOperTimecostMap \u003d\n             new HashMap\u003cSchedulerEventType, Double\u003e();\n     for (SchedulerEventType e : SchedulerEventType.values()) {\n       String key \u003d \"sampler.scheduler.operation.handle.\" + e + \".timecost\";\n       if (! handleOperTimecostHistogramMap.containsKey(e) \u0026\u0026\n               metrics.getHistograms().containsKey(key)) {\n         handleOperTimecostHistogramMap.put(e, metrics.getHistograms().get(key));\n       }\n       double timecost \u003d handleOperTimecostHistogramMap.containsKey(e) ?\n           handleOperTimecostHistogramMap.get(e).getSnapshot().getMean()/1000000\n               : 0;\n       handleOperTimecostMap.put(e, timecost);\n     }\n \n     // allocated resource for each queue\n     Map\u003cString, Double\u003e queueAllocatedMemoryMap \u003d new HashMap\u003cString, Double\u003e();\n     Map\u003cString, Long\u003e queueAllocatedVCoresMap \u003d new HashMap\u003cString, Long\u003e();\n     for (String queue : wrapper.getTracker().getQueueSet()) {\n       // memory\n       String key \u003d \"counter.queue.\" + queue + \".allocated.memory\";\n       if (! queueAllocatedMemoryCounterMap.containsKey(queue) \u0026\u0026\n               metrics.getCounters().containsKey(key)) {\n         queueAllocatedMemoryCounterMap.put(queue,\n                 metrics.getCounters().get(key));\n       }\n       double queueAllocatedMemoryGB \u003d\n               queueAllocatedMemoryCounterMap.containsKey(queue) ?\n                   queueAllocatedMemoryCounterMap.get(queue).getCount()/1024.0\n                       : 0;\n       queueAllocatedMemoryMap.put(queue, queueAllocatedMemoryGB);\n       // vCores\n       key \u003d \"counter.queue.\" + queue + \".allocated.cores\";\n       if (! queueAllocatedVCoresCounterMap.containsKey(queue) \u0026\u0026\n               metrics.getCounters().containsKey(key)) {\n         queueAllocatedVCoresCounterMap.put(\n                 queue, metrics.getCounters().get(key));\n       }\n       long queueAllocatedVCores \u003d\n               queueAllocatedVCoresCounterMap.containsKey(queue) ?\n                       queueAllocatedVCoresCounterMap.get(queue).getCount(): 0;\n       queueAllocatedVCoresMap.put(queue, queueAllocatedVCores);\n     }\n \n+    // calculate commit throughput, unit is number/second\n+    if (schedulerCommitSuccessCounter \u003d\u003d null \u0026\u0026 metrics.getCounters()\n+        .containsKey(\"counter.scheduler.operation.commit.success\")) {\n+      schedulerCommitSuccessCounter \u003d metrics.getCounters()\n+          .get(\"counter.scheduler.operation.commit.success\");\n+    }\n+    if (schedulerCommitFailureCounter \u003d\u003d null \u0026\u0026 metrics.getCounters()\n+        .containsKey(\"counter.scheduler.operation.commit.failure\")) {\n+      schedulerCommitFailureCounter \u003d metrics.getCounters()\n+          .get(\"counter.scheduler.operation.commit.failure\");\n+    }\n+    long schedulerCommitSuccessThroughput \u003d 0;\n+    long schedulerCommitFailureThroughput \u003d 0;\n+    if (schedulerCommitSuccessCounter !\u003d null\n+        \u0026\u0026 schedulerCommitFailureCounter !\u003d null) {\n+      long currentTrackingTime \u003d System.currentTimeMillis();\n+      long currentSchedulerCommitSucessCount \u003d\n+          schedulerCommitSuccessCounter.getCount();\n+      long currentSchedulerCommitFailureCount \u003d\n+          schedulerCommitFailureCounter.getCount();\n+      if (lastTrackingTime !\u003d null) {\n+        double intervalSeconds \u003d\n+            (double) (currentTrackingTime - lastTrackingTime) / 1000;\n+        schedulerCommitSuccessThroughput \u003d Math.round(\n+            (currentSchedulerCommitSucessCount\n+                - lastSchedulerCommitSuccessCount) / intervalSeconds);\n+        schedulerCommitFailureThroughput \u003d Math.round(\n+            (currentSchedulerCommitFailureCount\n+                - lastSchedulerCommitFailureCount) / intervalSeconds);\n+      }\n+      lastTrackingTime \u003d currentTrackingTime;\n+      lastSchedulerCommitSuccessCount \u003d currentSchedulerCommitSucessCount;\n+      lastSchedulerCommitFailureCount \u003d currentSchedulerCommitFailureCount;\n+    }\n+\n     // package results\n     StringBuilder sb \u003d new StringBuilder();\n     sb.append(\"{\");\n     sb.append(\"\\\"time\\\":\" ).append(System.currentTimeMillis())\n             .append(\",\\\"jvm.free.memory\\\":\").append(jvmFreeMemoryGB)\n             .append(\",\\\"jvm.max.memory\\\":\").append(jvmMaxMemoryGB)\n             .append(\",\\\"jvm.total.memory\\\":\").append(jvmTotalMemoryGB)\n             .append(\",\\\"running.applications\\\":\").append(numRunningApps)\n             .append(\",\\\"running.containers\\\":\").append(numRunningContainers)\n             .append(\",\\\"cluster.allocated.memory\\\":\").append(allocatedMemoryGB)\n             .append(\",\\\"cluster.allocated.vcores\\\":\").append(allocatedVCoresGB)\n             .append(\",\\\"cluster.available.memory\\\":\").append(availableMemoryGB)\n             .append(\",\\\"cluster.available.vcores\\\":\").append(availableVCoresGB);\n \n     for (String queue : wrapper.getTracker().getQueueSet()) {\n       sb.append(\",\\\"queue.\").append(queue).append(\".allocated.memory\\\":\")\n               .append(queueAllocatedMemoryMap.get(queue));\n       sb.append(\",\\\"queue.\").append(queue).append(\".allocated.vcores\\\":\")\n               .append(queueAllocatedVCoresMap.get(queue));\n     }\n     // scheduler allocate \u0026 handle\n     sb.append(\",\\\"scheduler.allocate.timecost\\\":\").append(allocateTimecost);\n+    sb.append(\",\\\"scheduler.commit.success.timecost\\\":\")\n+        .append(commitSuccessTimecost);\n+    sb.append(\",\\\"scheduler.commit.failure.timecost\\\":\")\n+        .append(commitFailureTimecost);\n+    sb.append(\",\\\"scheduler.commit.success.throughput\\\":\")\n+        .append(schedulerCommitSuccessThroughput);\n+    sb.append(\",\\\"scheduler.commit.failure.throughput\\\":\")\n+        .append(schedulerCommitFailureThroughput);\n     sb.append(\",\\\"scheduler.handle.timecost\\\":\").append(handleTimecost);\n     for (SchedulerEventType e : SchedulerEventType.values()) {\n       sb.append(\",\\\"scheduler.handle-\").append(e).append(\".timecost\\\":\")\n               .append(handleOperTimecostMap.get(e));\n     }\n     sb.append(\"}\");\n     return sb.toString();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public String generateRealTimeTrackingMetrics() {\n    // JVM\n    double jvmFreeMemoryGB, jvmMaxMemoryGB, jvmTotalMemoryGB;\n    if (jvmFreeMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.jvm.free.memory\")) {\n      jvmFreeMemoryGauge \u003d metrics.getGauges().get(\"variable.jvm.free.memory\");\n    }\n    if (jvmMaxMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.jvm.max.memory\")) {\n      jvmMaxMemoryGauge \u003d metrics.getGauges().get(\"variable.jvm.max.memory\");\n    }\n    if (jvmTotalMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.jvm.total.memory\")) {\n      jvmTotalMemoryGauge \u003d metrics.getGauges()\n              .get(\"variable.jvm.total.memory\");\n    }\n    jvmFreeMemoryGB \u003d jvmFreeMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(jvmFreeMemoryGauge.getValue().toString())\n                    /1024/1024/1024;\n    jvmMaxMemoryGB \u003d jvmMaxMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(jvmMaxMemoryGauge.getValue().toString())\n                    /1024/1024/1024;\n    jvmTotalMemoryGB \u003d jvmTotalMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(jvmTotalMemoryGauge.getValue().toString())\n                    /1024/1024/1024;\n\n    // number of running applications/containers\n    String numRunningApps, numRunningContainers;\n    if (numRunningAppsGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.running.application\")) {\n      numRunningAppsGauge \u003d\n              metrics.getGauges().get(\"variable.running.application\");\n    }\n    if (numRunningContainersGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.running.container\")) {\n      numRunningContainersGauge \u003d\n              metrics.getGauges().get(\"variable.running.container\");\n    }\n    numRunningApps \u003d numRunningAppsGauge \u003d\u003d null ? \"0\" :\n            numRunningAppsGauge.getValue().toString();\n    numRunningContainers \u003d numRunningContainersGauge \u003d\u003d null ? \"0\" :\n            numRunningContainersGauge.getValue().toString();\n\n    // cluster available/allocate resource\n    double allocatedMemoryGB, allocatedVCoresGB,\n            availableMemoryGB, availableVCoresGB;\n    if (allocatedMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges()\n                    .containsKey(\"variable.cluster.allocated.memory\")) {\n      allocatedMemoryGauge \u003d metrics.getGauges()\n              .get(\"variable.cluster.allocated.memory\");\n    }\n    if (allocatedVCoresGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges()\n                    .containsKey(\"variable.cluster.allocated.vcores\")) {\n      allocatedVCoresGauge \u003d metrics.getGauges()\n              .get(\"variable.cluster.allocated.vcores\");\n    }\n    if (availableMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges()\n                    .containsKey(\"variable.cluster.available.memory\")) {\n      availableMemoryGauge \u003d metrics.getGauges()\n              .get(\"variable.cluster.available.memory\");\n    }\n    if (availableVCoresGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges()\n                    .containsKey(\"variable.cluster.available.vcores\")) {\n      availableVCoresGauge \u003d metrics.getGauges()\n              .get(\"variable.cluster.available.vcores\");\n    }\n    allocatedMemoryGB \u003d allocatedMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(allocatedMemoryGauge.getValue().toString())/1024;\n    allocatedVCoresGB \u003d allocatedVCoresGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(allocatedVCoresGauge.getValue().toString());\n    availableMemoryGB \u003d availableMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(availableMemoryGauge.getValue().toString())/1024;\n    availableVCoresGB \u003d availableVCoresGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(availableVCoresGauge.getValue().toString());\n\n    // scheduler operation\n    double allocateTimecost, commitSuccessTimecost, commitFailureTimecost,\n        handleTimecost;\n    if (allocateTimecostHistogram \u003d\u003d null \u0026\u0026\n            metrics.getHistograms().containsKey(\n                    \"sampler.scheduler.operation.allocate.timecost\")) {\n      allocateTimecostHistogram \u003d metrics.getHistograms()\n              .get(\"sampler.scheduler.operation.allocate.timecost\");\n    }\n    if (commitSuccessTimecostHistogram \u003d\u003d null \u0026\u0026\n        metrics.getHistograms().containsKey(\n            \"sampler.scheduler.operation.commit.success.timecost\")) {\n      commitSuccessTimecostHistogram \u003d metrics.getHistograms()\n          .get(\"sampler.scheduler.operation.commit.success.timecost\");\n    }\n    if (commitFailureTimecostHistogram \u003d\u003d null \u0026\u0026\n        metrics.getHistograms().containsKey(\n            \"sampler.scheduler.operation.commit.failure.timecost\")) {\n      commitFailureTimecostHistogram \u003d metrics.getHistograms()\n          .get(\"sampler.scheduler.operation.commit.failure.timecost\");\n    }\n    if (handleTimecostHistogram \u003d\u003d null \u0026\u0026\n            metrics.getHistograms().containsKey(\n                    \"sampler.scheduler.operation.handle.timecost\")) {\n      handleTimecostHistogram \u003d metrics.getHistograms()\n              .get(\"sampler.scheduler.operation.handle.timecost\");\n    }\n    allocateTimecost \u003d allocateTimecostHistogram \u003d\u003d null ? 0.0 :\n            allocateTimecostHistogram.getSnapshot().getMean()/1000000;\n    commitSuccessTimecost \u003d commitSuccessTimecostHistogram \u003d\u003d null ? 0.0 :\n            commitSuccessTimecostHistogram.getSnapshot().getMean()/1000000;\n    commitFailureTimecost \u003d commitFailureTimecostHistogram \u003d\u003d null ? 0.0 :\n            commitFailureTimecostHistogram.getSnapshot().getMean()/1000000;\n    handleTimecost \u003d handleTimecostHistogram \u003d\u003d null ? 0.0 :\n            handleTimecostHistogram.getSnapshot().getMean()/1000000;\n    // various handle operation\n    Map\u003cSchedulerEventType, Double\u003e handleOperTimecostMap \u003d\n            new HashMap\u003cSchedulerEventType, Double\u003e();\n    for (SchedulerEventType e : SchedulerEventType.values()) {\n      String key \u003d \"sampler.scheduler.operation.handle.\" + e + \".timecost\";\n      if (! handleOperTimecostHistogramMap.containsKey(e) \u0026\u0026\n              metrics.getHistograms().containsKey(key)) {\n        handleOperTimecostHistogramMap.put(e, metrics.getHistograms().get(key));\n      }\n      double timecost \u003d handleOperTimecostHistogramMap.containsKey(e) ?\n          handleOperTimecostHistogramMap.get(e).getSnapshot().getMean()/1000000\n              : 0;\n      handleOperTimecostMap.put(e, timecost);\n    }\n\n    // allocated resource for each queue\n    Map\u003cString, Double\u003e queueAllocatedMemoryMap \u003d new HashMap\u003cString, Double\u003e();\n    Map\u003cString, Long\u003e queueAllocatedVCoresMap \u003d new HashMap\u003cString, Long\u003e();\n    for (String queue : wrapper.getTracker().getQueueSet()) {\n      // memory\n      String key \u003d \"counter.queue.\" + queue + \".allocated.memory\";\n      if (! queueAllocatedMemoryCounterMap.containsKey(queue) \u0026\u0026\n              metrics.getCounters().containsKey(key)) {\n        queueAllocatedMemoryCounterMap.put(queue,\n                metrics.getCounters().get(key));\n      }\n      double queueAllocatedMemoryGB \u003d\n              queueAllocatedMemoryCounterMap.containsKey(queue) ?\n                  queueAllocatedMemoryCounterMap.get(queue).getCount()/1024.0\n                      : 0;\n      queueAllocatedMemoryMap.put(queue, queueAllocatedMemoryGB);\n      // vCores\n      key \u003d \"counter.queue.\" + queue + \".allocated.cores\";\n      if (! queueAllocatedVCoresCounterMap.containsKey(queue) \u0026\u0026\n              metrics.getCounters().containsKey(key)) {\n        queueAllocatedVCoresCounterMap.put(\n                queue, metrics.getCounters().get(key));\n      }\n      long queueAllocatedVCores \u003d\n              queueAllocatedVCoresCounterMap.containsKey(queue) ?\n                      queueAllocatedVCoresCounterMap.get(queue).getCount(): 0;\n      queueAllocatedVCoresMap.put(queue, queueAllocatedVCores);\n    }\n\n    // calculate commit throughput, unit is number/second\n    if (schedulerCommitSuccessCounter \u003d\u003d null \u0026\u0026 metrics.getCounters()\n        .containsKey(\"counter.scheduler.operation.commit.success\")) {\n      schedulerCommitSuccessCounter \u003d metrics.getCounters()\n          .get(\"counter.scheduler.operation.commit.success\");\n    }\n    if (schedulerCommitFailureCounter \u003d\u003d null \u0026\u0026 metrics.getCounters()\n        .containsKey(\"counter.scheduler.operation.commit.failure\")) {\n      schedulerCommitFailureCounter \u003d metrics.getCounters()\n          .get(\"counter.scheduler.operation.commit.failure\");\n    }\n    long schedulerCommitSuccessThroughput \u003d 0;\n    long schedulerCommitFailureThroughput \u003d 0;\n    if (schedulerCommitSuccessCounter !\u003d null\n        \u0026\u0026 schedulerCommitFailureCounter !\u003d null) {\n      long currentTrackingTime \u003d System.currentTimeMillis();\n      long currentSchedulerCommitSucessCount \u003d\n          schedulerCommitSuccessCounter.getCount();\n      long currentSchedulerCommitFailureCount \u003d\n          schedulerCommitFailureCounter.getCount();\n      if (lastTrackingTime !\u003d null) {\n        double intervalSeconds \u003d\n            (double) (currentTrackingTime - lastTrackingTime) / 1000;\n        schedulerCommitSuccessThroughput \u003d Math.round(\n            (currentSchedulerCommitSucessCount\n                - lastSchedulerCommitSuccessCount) / intervalSeconds);\n        schedulerCommitFailureThroughput \u003d Math.round(\n            (currentSchedulerCommitFailureCount\n                - lastSchedulerCommitFailureCount) / intervalSeconds);\n      }\n      lastTrackingTime \u003d currentTrackingTime;\n      lastSchedulerCommitSuccessCount \u003d currentSchedulerCommitSucessCount;\n      lastSchedulerCommitFailureCount \u003d currentSchedulerCommitFailureCount;\n    }\n\n    // package results\n    StringBuilder sb \u003d new StringBuilder();\n    sb.append(\"{\");\n    sb.append(\"\\\"time\\\":\" ).append(System.currentTimeMillis())\n            .append(\",\\\"jvm.free.memory\\\":\").append(jvmFreeMemoryGB)\n            .append(\",\\\"jvm.max.memory\\\":\").append(jvmMaxMemoryGB)\n            .append(\",\\\"jvm.total.memory\\\":\").append(jvmTotalMemoryGB)\n            .append(\",\\\"running.applications\\\":\").append(numRunningApps)\n            .append(\",\\\"running.containers\\\":\").append(numRunningContainers)\n            .append(\",\\\"cluster.allocated.memory\\\":\").append(allocatedMemoryGB)\n            .append(\",\\\"cluster.allocated.vcores\\\":\").append(allocatedVCoresGB)\n            .append(\",\\\"cluster.available.memory\\\":\").append(availableMemoryGB)\n            .append(\",\\\"cluster.available.vcores\\\":\").append(availableVCoresGB);\n\n    for (String queue : wrapper.getTracker().getQueueSet()) {\n      sb.append(\",\\\"queue.\").append(queue).append(\".allocated.memory\\\":\")\n              .append(queueAllocatedMemoryMap.get(queue));\n      sb.append(\",\\\"queue.\").append(queue).append(\".allocated.vcores\\\":\")\n              .append(queueAllocatedVCoresMap.get(queue));\n    }\n    // scheduler allocate \u0026 handle\n    sb.append(\",\\\"scheduler.allocate.timecost\\\":\").append(allocateTimecost);\n    sb.append(\",\\\"scheduler.commit.success.timecost\\\":\")\n        .append(commitSuccessTimecost);\n    sb.append(\",\\\"scheduler.commit.failure.timecost\\\":\")\n        .append(commitFailureTimecost);\n    sb.append(\",\\\"scheduler.commit.success.throughput\\\":\")\n        .append(schedulerCommitSuccessThroughput);\n    sb.append(\",\\\"scheduler.commit.failure.throughput\\\":\")\n        .append(schedulerCommitFailureThroughput);\n    sb.append(\",\\\"scheduler.handle.timecost\\\":\").append(handleTimecost);\n    for (SchedulerEventType e : SchedulerEventType.values()) {\n      sb.append(\",\\\"scheduler.handle-\").append(e).append(\".timecost\\\":\")\n              .append(handleOperTimecostMap.get(e));\n    }\n    sb.append(\"}\");\n    return sb.toString();\n  }",
      "path": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/web/SLSWebApp.java",
      "extendedDetails": {}
    },
    "6a5516c2381f107d96b8326939514de3c6e53d3d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5654. Not be able to run SLS with FairScheduler (yufeigu via rkanter)\n",
      "commitDate": "29/03/17 4:18 PM",
      "commitName": "6a5516c2381f107d96b8326939514de3c6e53d3d",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "07/03/17 1:47 PM",
      "commitNameOld": "1598fd3b7948b3592775e3be3227c4a336122bc9",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 22.06,
      "commitsBetweenForRepo": 131,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,171 +1,171 @@\n   public String generateRealTimeTrackingMetrics() {\n     // JVM\n     double jvmFreeMemoryGB, jvmMaxMemoryGB, jvmTotalMemoryGB;\n     if (jvmFreeMemoryGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges().containsKey(\"variable.jvm.free.memory\")) {\n       jvmFreeMemoryGauge \u003d metrics.getGauges().get(\"variable.jvm.free.memory\");\n     }\n     if (jvmMaxMemoryGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges().containsKey(\"variable.jvm.max.memory\")) {\n       jvmMaxMemoryGauge \u003d metrics.getGauges().get(\"variable.jvm.max.memory\");\n     }\n     if (jvmTotalMemoryGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges().containsKey(\"variable.jvm.total.memory\")) {\n       jvmTotalMemoryGauge \u003d metrics.getGauges()\n               .get(\"variable.jvm.total.memory\");\n     }\n     jvmFreeMemoryGB \u003d jvmFreeMemoryGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(jvmFreeMemoryGauge.getValue().toString())\n                     /1024/1024/1024;\n     jvmMaxMemoryGB \u003d jvmMaxMemoryGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(jvmMaxMemoryGauge.getValue().toString())\n                     /1024/1024/1024;\n     jvmTotalMemoryGB \u003d jvmTotalMemoryGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(jvmTotalMemoryGauge.getValue().toString())\n                     /1024/1024/1024;\n \n     // number of running applications/containers\n     String numRunningApps, numRunningContainers;\n     if (numRunningAppsGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges().containsKey(\"variable.running.application\")) {\n       numRunningAppsGauge \u003d\n               metrics.getGauges().get(\"variable.running.application\");\n     }\n     if (numRunningContainersGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges().containsKey(\"variable.running.container\")) {\n       numRunningContainersGauge \u003d\n               metrics.getGauges().get(\"variable.running.container\");\n     }\n     numRunningApps \u003d numRunningAppsGauge \u003d\u003d null ? \"0\" :\n             numRunningAppsGauge.getValue().toString();\n     numRunningContainers \u003d numRunningContainersGauge \u003d\u003d null ? \"0\" :\n             numRunningContainersGauge.getValue().toString();\n \n     // cluster available/allocate resource\n     double allocatedMemoryGB, allocatedVCoresGB,\n             availableMemoryGB, availableVCoresGB;\n     if (allocatedMemoryGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges()\n                     .containsKey(\"variable.cluster.allocated.memory\")) {\n       allocatedMemoryGauge \u003d metrics.getGauges()\n               .get(\"variable.cluster.allocated.memory\");\n     }\n     if (allocatedVCoresGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges()\n                     .containsKey(\"variable.cluster.allocated.vcores\")) {\n       allocatedVCoresGauge \u003d metrics.getGauges()\n               .get(\"variable.cluster.allocated.vcores\");\n     }\n     if (availableMemoryGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges()\n                     .containsKey(\"variable.cluster.available.memory\")) {\n       availableMemoryGauge \u003d metrics.getGauges()\n               .get(\"variable.cluster.available.memory\");\n     }\n     if (availableVCoresGauge \u003d\u003d null \u0026\u0026\n             metrics.getGauges()\n                     .containsKey(\"variable.cluster.available.vcores\")) {\n       availableVCoresGauge \u003d metrics.getGauges()\n               .get(\"variable.cluster.available.vcores\");\n     }\n     allocatedMemoryGB \u003d allocatedMemoryGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(allocatedMemoryGauge.getValue().toString())/1024;\n     allocatedVCoresGB \u003d allocatedVCoresGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(allocatedVCoresGauge.getValue().toString());\n     availableMemoryGB \u003d availableMemoryGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(availableMemoryGauge.getValue().toString())/1024;\n     availableVCoresGB \u003d availableVCoresGauge \u003d\u003d null ? 0 :\n             Double.parseDouble(availableVCoresGauge.getValue().toString());\n \n     // scheduler operation\n     double allocateTimecost, handleTimecost;\n     if (allocateTimecostHistogram \u003d\u003d null \u0026\u0026\n             metrics.getHistograms().containsKey(\n                     \"sampler.scheduler.operation.allocate.timecost\")) {\n       allocateTimecostHistogram \u003d metrics.getHistograms()\n               .get(\"sampler.scheduler.operation.allocate.timecost\");\n     }\n     if (handleTimecostHistogram \u003d\u003d null \u0026\u0026\n             metrics.getHistograms().containsKey(\n                     \"sampler.scheduler.operation.handle.timecost\")) {\n       handleTimecostHistogram \u003d metrics.getHistograms()\n               .get(\"sampler.scheduler.operation.handle.timecost\");\n     }\n     allocateTimecost \u003d allocateTimecostHistogram \u003d\u003d null ? 0.0 :\n             allocateTimecostHistogram.getSnapshot().getMean()/1000000;\n     handleTimecost \u003d handleTimecostHistogram \u003d\u003d null ? 0.0 :\n             handleTimecostHistogram.getSnapshot().getMean()/1000000;\n     // various handle operation\n     Map\u003cSchedulerEventType, Double\u003e handleOperTimecostMap \u003d\n             new HashMap\u003cSchedulerEventType, Double\u003e();\n     for (SchedulerEventType e : SchedulerEventType.values()) {\n       String key \u003d \"sampler.scheduler.operation.handle.\" + e + \".timecost\";\n       if (! handleOperTimecostHistogramMap.containsKey(e) \u0026\u0026\n               metrics.getHistograms().containsKey(key)) {\n         handleOperTimecostHistogramMap.put(e, metrics.getHistograms().get(key));\n       }\n       double timecost \u003d handleOperTimecostHistogramMap.containsKey(e) ?\n           handleOperTimecostHistogramMap.get(e).getSnapshot().getMean()/1000000\n               : 0;\n       handleOperTimecostMap.put(e, timecost);\n     }\n \n     // allocated resource for each queue\n     Map\u003cString, Double\u003e queueAllocatedMemoryMap \u003d new HashMap\u003cString, Double\u003e();\n     Map\u003cString, Long\u003e queueAllocatedVCoresMap \u003d new HashMap\u003cString, Long\u003e();\n-    for (String queue : wrapper.getQueueSet()) {\n+    for (String queue : wrapper.getTracker().getQueueSet()) {\n       // memory\n       String key \u003d \"counter.queue.\" + queue + \".allocated.memory\";\n       if (! queueAllocatedMemoryCounterMap.containsKey(queue) \u0026\u0026\n               metrics.getCounters().containsKey(key)) {\n         queueAllocatedMemoryCounterMap.put(queue,\n                 metrics.getCounters().get(key));\n       }\n       double queueAllocatedMemoryGB \u003d\n               queueAllocatedMemoryCounterMap.containsKey(queue) ?\n                   queueAllocatedMemoryCounterMap.get(queue).getCount()/1024.0\n                       : 0;\n       queueAllocatedMemoryMap.put(queue, queueAllocatedMemoryGB);\n       // vCores\n       key \u003d \"counter.queue.\" + queue + \".allocated.cores\";\n       if (! queueAllocatedVCoresCounterMap.containsKey(queue) \u0026\u0026\n               metrics.getCounters().containsKey(key)) {\n         queueAllocatedVCoresCounterMap.put(\n                 queue, metrics.getCounters().get(key));\n       }\n       long queueAllocatedVCores \u003d\n               queueAllocatedVCoresCounterMap.containsKey(queue) ?\n                       queueAllocatedVCoresCounterMap.get(queue).getCount(): 0;\n       queueAllocatedVCoresMap.put(queue, queueAllocatedVCores);\n     }\n \n     // package results\n     StringBuilder sb \u003d new StringBuilder();\n     sb.append(\"{\");\n     sb.append(\"\\\"time\\\":\" ).append(System.currentTimeMillis())\n             .append(\",\\\"jvm.free.memory\\\":\").append(jvmFreeMemoryGB)\n             .append(\",\\\"jvm.max.memory\\\":\").append(jvmMaxMemoryGB)\n             .append(\",\\\"jvm.total.memory\\\":\").append(jvmTotalMemoryGB)\n             .append(\",\\\"running.applications\\\":\").append(numRunningApps)\n             .append(\",\\\"running.containers\\\":\").append(numRunningContainers)\n             .append(\",\\\"cluster.allocated.memory\\\":\").append(allocatedMemoryGB)\n             .append(\",\\\"cluster.allocated.vcores\\\":\").append(allocatedVCoresGB)\n             .append(\",\\\"cluster.available.memory\\\":\").append(availableMemoryGB)\n             .append(\",\\\"cluster.available.vcores\\\":\").append(availableVCoresGB);\n \n-    for (String queue : wrapper.getQueueSet()) {\n+    for (String queue : wrapper.getTracker().getQueueSet()) {\n       sb.append(\",\\\"queue.\").append(queue).append(\".allocated.memory\\\":\")\n               .append(queueAllocatedMemoryMap.get(queue));\n       sb.append(\",\\\"queue.\").append(queue).append(\".allocated.vcores\\\":\")\n               .append(queueAllocatedVCoresMap.get(queue));\n     }\n     // scheduler allocate \u0026 handle\n     sb.append(\",\\\"scheduler.allocate.timecost\\\":\").append(allocateTimecost);\n     sb.append(\",\\\"scheduler.handle.timecost\\\":\").append(handleTimecost);\n     for (SchedulerEventType e : SchedulerEventType.values()) {\n       sb.append(\",\\\"scheduler.handle-\").append(e).append(\".timecost\\\":\")\n               .append(handleOperTimecostMap.get(e));\n     }\n     sb.append(\"}\");\n     return sb.toString();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public String generateRealTimeTrackingMetrics() {\n    // JVM\n    double jvmFreeMemoryGB, jvmMaxMemoryGB, jvmTotalMemoryGB;\n    if (jvmFreeMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.jvm.free.memory\")) {\n      jvmFreeMemoryGauge \u003d metrics.getGauges().get(\"variable.jvm.free.memory\");\n    }\n    if (jvmMaxMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.jvm.max.memory\")) {\n      jvmMaxMemoryGauge \u003d metrics.getGauges().get(\"variable.jvm.max.memory\");\n    }\n    if (jvmTotalMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.jvm.total.memory\")) {\n      jvmTotalMemoryGauge \u003d metrics.getGauges()\n              .get(\"variable.jvm.total.memory\");\n    }\n    jvmFreeMemoryGB \u003d jvmFreeMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(jvmFreeMemoryGauge.getValue().toString())\n                    /1024/1024/1024;\n    jvmMaxMemoryGB \u003d jvmMaxMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(jvmMaxMemoryGauge.getValue().toString())\n                    /1024/1024/1024;\n    jvmTotalMemoryGB \u003d jvmTotalMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(jvmTotalMemoryGauge.getValue().toString())\n                    /1024/1024/1024;\n\n    // number of running applications/containers\n    String numRunningApps, numRunningContainers;\n    if (numRunningAppsGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.running.application\")) {\n      numRunningAppsGauge \u003d\n              metrics.getGauges().get(\"variable.running.application\");\n    }\n    if (numRunningContainersGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.running.container\")) {\n      numRunningContainersGauge \u003d\n              metrics.getGauges().get(\"variable.running.container\");\n    }\n    numRunningApps \u003d numRunningAppsGauge \u003d\u003d null ? \"0\" :\n            numRunningAppsGauge.getValue().toString();\n    numRunningContainers \u003d numRunningContainersGauge \u003d\u003d null ? \"0\" :\n            numRunningContainersGauge.getValue().toString();\n\n    // cluster available/allocate resource\n    double allocatedMemoryGB, allocatedVCoresGB,\n            availableMemoryGB, availableVCoresGB;\n    if (allocatedMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges()\n                    .containsKey(\"variable.cluster.allocated.memory\")) {\n      allocatedMemoryGauge \u003d metrics.getGauges()\n              .get(\"variable.cluster.allocated.memory\");\n    }\n    if (allocatedVCoresGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges()\n                    .containsKey(\"variable.cluster.allocated.vcores\")) {\n      allocatedVCoresGauge \u003d metrics.getGauges()\n              .get(\"variable.cluster.allocated.vcores\");\n    }\n    if (availableMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges()\n                    .containsKey(\"variable.cluster.available.memory\")) {\n      availableMemoryGauge \u003d metrics.getGauges()\n              .get(\"variable.cluster.available.memory\");\n    }\n    if (availableVCoresGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges()\n                    .containsKey(\"variable.cluster.available.vcores\")) {\n      availableVCoresGauge \u003d metrics.getGauges()\n              .get(\"variable.cluster.available.vcores\");\n    }\n    allocatedMemoryGB \u003d allocatedMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(allocatedMemoryGauge.getValue().toString())/1024;\n    allocatedVCoresGB \u003d allocatedVCoresGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(allocatedVCoresGauge.getValue().toString());\n    availableMemoryGB \u003d availableMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(availableMemoryGauge.getValue().toString())/1024;\n    availableVCoresGB \u003d availableVCoresGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(availableVCoresGauge.getValue().toString());\n\n    // scheduler operation\n    double allocateTimecost, handleTimecost;\n    if (allocateTimecostHistogram \u003d\u003d null \u0026\u0026\n            metrics.getHistograms().containsKey(\n                    \"sampler.scheduler.operation.allocate.timecost\")) {\n      allocateTimecostHistogram \u003d metrics.getHistograms()\n              .get(\"sampler.scheduler.operation.allocate.timecost\");\n    }\n    if (handleTimecostHistogram \u003d\u003d null \u0026\u0026\n            metrics.getHistograms().containsKey(\n                    \"sampler.scheduler.operation.handle.timecost\")) {\n      handleTimecostHistogram \u003d metrics.getHistograms()\n              .get(\"sampler.scheduler.operation.handle.timecost\");\n    }\n    allocateTimecost \u003d allocateTimecostHistogram \u003d\u003d null ? 0.0 :\n            allocateTimecostHistogram.getSnapshot().getMean()/1000000;\n    handleTimecost \u003d handleTimecostHistogram \u003d\u003d null ? 0.0 :\n            handleTimecostHistogram.getSnapshot().getMean()/1000000;\n    // various handle operation\n    Map\u003cSchedulerEventType, Double\u003e handleOperTimecostMap \u003d\n            new HashMap\u003cSchedulerEventType, Double\u003e();\n    for (SchedulerEventType e : SchedulerEventType.values()) {\n      String key \u003d \"sampler.scheduler.operation.handle.\" + e + \".timecost\";\n      if (! handleOperTimecostHistogramMap.containsKey(e) \u0026\u0026\n              metrics.getHistograms().containsKey(key)) {\n        handleOperTimecostHistogramMap.put(e, metrics.getHistograms().get(key));\n      }\n      double timecost \u003d handleOperTimecostHistogramMap.containsKey(e) ?\n          handleOperTimecostHistogramMap.get(e).getSnapshot().getMean()/1000000\n              : 0;\n      handleOperTimecostMap.put(e, timecost);\n    }\n\n    // allocated resource for each queue\n    Map\u003cString, Double\u003e queueAllocatedMemoryMap \u003d new HashMap\u003cString, Double\u003e();\n    Map\u003cString, Long\u003e queueAllocatedVCoresMap \u003d new HashMap\u003cString, Long\u003e();\n    for (String queue : wrapper.getTracker().getQueueSet()) {\n      // memory\n      String key \u003d \"counter.queue.\" + queue + \".allocated.memory\";\n      if (! queueAllocatedMemoryCounterMap.containsKey(queue) \u0026\u0026\n              metrics.getCounters().containsKey(key)) {\n        queueAllocatedMemoryCounterMap.put(queue,\n                metrics.getCounters().get(key));\n      }\n      double queueAllocatedMemoryGB \u003d\n              queueAllocatedMemoryCounterMap.containsKey(queue) ?\n                  queueAllocatedMemoryCounterMap.get(queue).getCount()/1024.0\n                      : 0;\n      queueAllocatedMemoryMap.put(queue, queueAllocatedMemoryGB);\n      // vCores\n      key \u003d \"counter.queue.\" + queue + \".allocated.cores\";\n      if (! queueAllocatedVCoresCounterMap.containsKey(queue) \u0026\u0026\n              metrics.getCounters().containsKey(key)) {\n        queueAllocatedVCoresCounterMap.put(\n                queue, metrics.getCounters().get(key));\n      }\n      long queueAllocatedVCores \u003d\n              queueAllocatedVCoresCounterMap.containsKey(queue) ?\n                      queueAllocatedVCoresCounterMap.get(queue).getCount(): 0;\n      queueAllocatedVCoresMap.put(queue, queueAllocatedVCores);\n    }\n\n    // package results\n    StringBuilder sb \u003d new StringBuilder();\n    sb.append(\"{\");\n    sb.append(\"\\\"time\\\":\" ).append(System.currentTimeMillis())\n            .append(\",\\\"jvm.free.memory\\\":\").append(jvmFreeMemoryGB)\n            .append(\",\\\"jvm.max.memory\\\":\").append(jvmMaxMemoryGB)\n            .append(\",\\\"jvm.total.memory\\\":\").append(jvmTotalMemoryGB)\n            .append(\",\\\"running.applications\\\":\").append(numRunningApps)\n            .append(\",\\\"running.containers\\\":\").append(numRunningContainers)\n            .append(\",\\\"cluster.allocated.memory\\\":\").append(allocatedMemoryGB)\n            .append(\",\\\"cluster.allocated.vcores\\\":\").append(allocatedVCoresGB)\n            .append(\",\\\"cluster.available.memory\\\":\").append(availableMemoryGB)\n            .append(\",\\\"cluster.available.vcores\\\":\").append(availableVCoresGB);\n\n    for (String queue : wrapper.getTracker().getQueueSet()) {\n      sb.append(\",\\\"queue.\").append(queue).append(\".allocated.memory\\\":\")\n              .append(queueAllocatedMemoryMap.get(queue));\n      sb.append(\",\\\"queue.\").append(queue).append(\".allocated.vcores\\\":\")\n              .append(queueAllocatedVCoresMap.get(queue));\n    }\n    // scheduler allocate \u0026 handle\n    sb.append(\",\\\"scheduler.allocate.timecost\\\":\").append(allocateTimecost);\n    sb.append(\",\\\"scheduler.handle.timecost\\\":\").append(handleTimecost);\n    for (SchedulerEventType e : SchedulerEventType.values()) {\n      sb.append(\",\\\"scheduler.handle-\").append(e).append(\".timecost\\\":\")\n              .append(handleOperTimecostMap.get(e));\n    }\n    sb.append(\"}\");\n    return sb.toString();\n  }",
      "path": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/web/SLSWebApp.java",
      "extendedDetails": {}
    },
    "58b08e11b9f04c9190ab4a07473f0ee04e01ec6b": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1021. Yarn Scheduler Load Simulator. (ywskycn via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527059 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/09/13 1:23 PM",
      "commitName": "58b08e11b9f04c9190ab4a07473f0ee04e01ec6b",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,171 @@\n+  public String generateRealTimeTrackingMetrics() {\n+    // JVM\n+    double jvmFreeMemoryGB, jvmMaxMemoryGB, jvmTotalMemoryGB;\n+    if (jvmFreeMemoryGauge \u003d\u003d null \u0026\u0026\n+            metrics.getGauges().containsKey(\"variable.jvm.free.memory\")) {\n+      jvmFreeMemoryGauge \u003d metrics.getGauges().get(\"variable.jvm.free.memory\");\n+    }\n+    if (jvmMaxMemoryGauge \u003d\u003d null \u0026\u0026\n+            metrics.getGauges().containsKey(\"variable.jvm.max.memory\")) {\n+      jvmMaxMemoryGauge \u003d metrics.getGauges().get(\"variable.jvm.max.memory\");\n+    }\n+    if (jvmTotalMemoryGauge \u003d\u003d null \u0026\u0026\n+            metrics.getGauges().containsKey(\"variable.jvm.total.memory\")) {\n+      jvmTotalMemoryGauge \u003d metrics.getGauges()\n+              .get(\"variable.jvm.total.memory\");\n+    }\n+    jvmFreeMemoryGB \u003d jvmFreeMemoryGauge \u003d\u003d null ? 0 :\n+            Double.parseDouble(jvmFreeMemoryGauge.getValue().toString())\n+                    /1024/1024/1024;\n+    jvmMaxMemoryGB \u003d jvmMaxMemoryGauge \u003d\u003d null ? 0 :\n+            Double.parseDouble(jvmMaxMemoryGauge.getValue().toString())\n+                    /1024/1024/1024;\n+    jvmTotalMemoryGB \u003d jvmTotalMemoryGauge \u003d\u003d null ? 0 :\n+            Double.parseDouble(jvmTotalMemoryGauge.getValue().toString())\n+                    /1024/1024/1024;\n+\n+    // number of running applications/containers\n+    String numRunningApps, numRunningContainers;\n+    if (numRunningAppsGauge \u003d\u003d null \u0026\u0026\n+            metrics.getGauges().containsKey(\"variable.running.application\")) {\n+      numRunningAppsGauge \u003d\n+              metrics.getGauges().get(\"variable.running.application\");\n+    }\n+    if (numRunningContainersGauge \u003d\u003d null \u0026\u0026\n+            metrics.getGauges().containsKey(\"variable.running.container\")) {\n+      numRunningContainersGauge \u003d\n+              metrics.getGauges().get(\"variable.running.container\");\n+    }\n+    numRunningApps \u003d numRunningAppsGauge \u003d\u003d null ? \"0\" :\n+            numRunningAppsGauge.getValue().toString();\n+    numRunningContainers \u003d numRunningContainersGauge \u003d\u003d null ? \"0\" :\n+            numRunningContainersGauge.getValue().toString();\n+\n+    // cluster available/allocate resource\n+    double allocatedMemoryGB, allocatedVCoresGB,\n+            availableMemoryGB, availableVCoresGB;\n+    if (allocatedMemoryGauge \u003d\u003d null \u0026\u0026\n+            metrics.getGauges()\n+                    .containsKey(\"variable.cluster.allocated.memory\")) {\n+      allocatedMemoryGauge \u003d metrics.getGauges()\n+              .get(\"variable.cluster.allocated.memory\");\n+    }\n+    if (allocatedVCoresGauge \u003d\u003d null \u0026\u0026\n+            metrics.getGauges()\n+                    .containsKey(\"variable.cluster.allocated.vcores\")) {\n+      allocatedVCoresGauge \u003d metrics.getGauges()\n+              .get(\"variable.cluster.allocated.vcores\");\n+    }\n+    if (availableMemoryGauge \u003d\u003d null \u0026\u0026\n+            metrics.getGauges()\n+                    .containsKey(\"variable.cluster.available.memory\")) {\n+      availableMemoryGauge \u003d metrics.getGauges()\n+              .get(\"variable.cluster.available.memory\");\n+    }\n+    if (availableVCoresGauge \u003d\u003d null \u0026\u0026\n+            metrics.getGauges()\n+                    .containsKey(\"variable.cluster.available.vcores\")) {\n+      availableVCoresGauge \u003d metrics.getGauges()\n+              .get(\"variable.cluster.available.vcores\");\n+    }\n+    allocatedMemoryGB \u003d allocatedMemoryGauge \u003d\u003d null ? 0 :\n+            Double.parseDouble(allocatedMemoryGauge.getValue().toString())/1024;\n+    allocatedVCoresGB \u003d allocatedVCoresGauge \u003d\u003d null ? 0 :\n+            Double.parseDouble(allocatedVCoresGauge.getValue().toString());\n+    availableMemoryGB \u003d availableMemoryGauge \u003d\u003d null ? 0 :\n+            Double.parseDouble(availableMemoryGauge.getValue().toString())/1024;\n+    availableVCoresGB \u003d availableVCoresGauge \u003d\u003d null ? 0 :\n+            Double.parseDouble(availableVCoresGauge.getValue().toString());\n+\n+    // scheduler operation\n+    double allocateTimecost, handleTimecost;\n+    if (allocateTimecostHistogram \u003d\u003d null \u0026\u0026\n+            metrics.getHistograms().containsKey(\n+                    \"sampler.scheduler.operation.allocate.timecost\")) {\n+      allocateTimecostHistogram \u003d metrics.getHistograms()\n+              .get(\"sampler.scheduler.operation.allocate.timecost\");\n+    }\n+    if (handleTimecostHistogram \u003d\u003d null \u0026\u0026\n+            metrics.getHistograms().containsKey(\n+                    \"sampler.scheduler.operation.handle.timecost\")) {\n+      handleTimecostHistogram \u003d metrics.getHistograms()\n+              .get(\"sampler.scheduler.operation.handle.timecost\");\n+    }\n+    allocateTimecost \u003d allocateTimecostHistogram \u003d\u003d null ? 0.0 :\n+            allocateTimecostHistogram.getSnapshot().getMean()/1000000;\n+    handleTimecost \u003d handleTimecostHistogram \u003d\u003d null ? 0.0 :\n+            handleTimecostHistogram.getSnapshot().getMean()/1000000;\n+    // various handle operation\n+    Map\u003cSchedulerEventType, Double\u003e handleOperTimecostMap \u003d\n+            new HashMap\u003cSchedulerEventType, Double\u003e();\n+    for (SchedulerEventType e : SchedulerEventType.values()) {\n+      String key \u003d \"sampler.scheduler.operation.handle.\" + e + \".timecost\";\n+      if (! handleOperTimecostHistogramMap.containsKey(e) \u0026\u0026\n+              metrics.getHistograms().containsKey(key)) {\n+        handleOperTimecostHistogramMap.put(e, metrics.getHistograms().get(key));\n+      }\n+      double timecost \u003d handleOperTimecostHistogramMap.containsKey(e) ?\n+          handleOperTimecostHistogramMap.get(e).getSnapshot().getMean()/1000000\n+              : 0;\n+      handleOperTimecostMap.put(e, timecost);\n+    }\n+\n+    // allocated resource for each queue\n+    Map\u003cString, Double\u003e queueAllocatedMemoryMap \u003d new HashMap\u003cString, Double\u003e();\n+    Map\u003cString, Long\u003e queueAllocatedVCoresMap \u003d new HashMap\u003cString, Long\u003e();\n+    for (String queue : wrapper.getQueueSet()) {\n+      // memory\n+      String key \u003d \"counter.queue.\" + queue + \".allocated.memory\";\n+      if (! queueAllocatedMemoryCounterMap.containsKey(queue) \u0026\u0026\n+              metrics.getCounters().containsKey(key)) {\n+        queueAllocatedMemoryCounterMap.put(queue,\n+                metrics.getCounters().get(key));\n+      }\n+      double queueAllocatedMemoryGB \u003d\n+              queueAllocatedMemoryCounterMap.containsKey(queue) ?\n+                  queueAllocatedMemoryCounterMap.get(queue).getCount()/1024.0\n+                      : 0;\n+      queueAllocatedMemoryMap.put(queue, queueAllocatedMemoryGB);\n+      // vCores\n+      key \u003d \"counter.queue.\" + queue + \".allocated.cores\";\n+      if (! queueAllocatedVCoresCounterMap.containsKey(queue) \u0026\u0026\n+              metrics.getCounters().containsKey(key)) {\n+        queueAllocatedVCoresCounterMap.put(\n+                queue, metrics.getCounters().get(key));\n+      }\n+      long queueAllocatedVCores \u003d\n+              queueAllocatedVCoresCounterMap.containsKey(queue) ?\n+                      queueAllocatedVCoresCounterMap.get(queue).getCount(): 0;\n+      queueAllocatedVCoresMap.put(queue, queueAllocatedVCores);\n+    }\n+\n+    // package results\n+    StringBuilder sb \u003d new StringBuilder();\n+    sb.append(\"{\");\n+    sb.append(\"\\\"time\\\":\" ).append(System.currentTimeMillis())\n+            .append(\",\\\"jvm.free.memory\\\":\").append(jvmFreeMemoryGB)\n+            .append(\",\\\"jvm.max.memory\\\":\").append(jvmMaxMemoryGB)\n+            .append(\",\\\"jvm.total.memory\\\":\").append(jvmTotalMemoryGB)\n+            .append(\",\\\"running.applications\\\":\").append(numRunningApps)\n+            .append(\",\\\"running.containers\\\":\").append(numRunningContainers)\n+            .append(\",\\\"cluster.allocated.memory\\\":\").append(allocatedMemoryGB)\n+            .append(\",\\\"cluster.allocated.vcores\\\":\").append(allocatedVCoresGB)\n+            .append(\",\\\"cluster.available.memory\\\":\").append(availableMemoryGB)\n+            .append(\",\\\"cluster.available.vcores\\\":\").append(availableVCoresGB);\n+\n+    for (String queue : wrapper.getQueueSet()) {\n+      sb.append(\",\\\"queue.\").append(queue).append(\".allocated.memory\\\":\")\n+              .append(queueAllocatedMemoryMap.get(queue));\n+      sb.append(\",\\\"queue.\").append(queue).append(\".allocated.vcores\\\":\")\n+              .append(queueAllocatedVCoresMap.get(queue));\n+    }\n+    // scheduler allocate \u0026 handle\n+    sb.append(\",\\\"scheduler.allocate.timecost\\\":\").append(allocateTimecost);\n+    sb.append(\",\\\"scheduler.handle.timecost\\\":\").append(handleTimecost);\n+    for (SchedulerEventType e : SchedulerEventType.values()) {\n+      sb.append(\",\\\"scheduler.handle-\").append(e).append(\".timecost\\\":\")\n+              .append(handleOperTimecostMap.get(e));\n+    }\n+    sb.append(\"}\");\n+    return sb.toString();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public String generateRealTimeTrackingMetrics() {\n    // JVM\n    double jvmFreeMemoryGB, jvmMaxMemoryGB, jvmTotalMemoryGB;\n    if (jvmFreeMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.jvm.free.memory\")) {\n      jvmFreeMemoryGauge \u003d metrics.getGauges().get(\"variable.jvm.free.memory\");\n    }\n    if (jvmMaxMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.jvm.max.memory\")) {\n      jvmMaxMemoryGauge \u003d metrics.getGauges().get(\"variable.jvm.max.memory\");\n    }\n    if (jvmTotalMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.jvm.total.memory\")) {\n      jvmTotalMemoryGauge \u003d metrics.getGauges()\n              .get(\"variable.jvm.total.memory\");\n    }\n    jvmFreeMemoryGB \u003d jvmFreeMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(jvmFreeMemoryGauge.getValue().toString())\n                    /1024/1024/1024;\n    jvmMaxMemoryGB \u003d jvmMaxMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(jvmMaxMemoryGauge.getValue().toString())\n                    /1024/1024/1024;\n    jvmTotalMemoryGB \u003d jvmTotalMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(jvmTotalMemoryGauge.getValue().toString())\n                    /1024/1024/1024;\n\n    // number of running applications/containers\n    String numRunningApps, numRunningContainers;\n    if (numRunningAppsGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.running.application\")) {\n      numRunningAppsGauge \u003d\n              metrics.getGauges().get(\"variable.running.application\");\n    }\n    if (numRunningContainersGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges().containsKey(\"variable.running.container\")) {\n      numRunningContainersGauge \u003d\n              metrics.getGauges().get(\"variable.running.container\");\n    }\n    numRunningApps \u003d numRunningAppsGauge \u003d\u003d null ? \"0\" :\n            numRunningAppsGauge.getValue().toString();\n    numRunningContainers \u003d numRunningContainersGauge \u003d\u003d null ? \"0\" :\n            numRunningContainersGauge.getValue().toString();\n\n    // cluster available/allocate resource\n    double allocatedMemoryGB, allocatedVCoresGB,\n            availableMemoryGB, availableVCoresGB;\n    if (allocatedMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges()\n                    .containsKey(\"variable.cluster.allocated.memory\")) {\n      allocatedMemoryGauge \u003d metrics.getGauges()\n              .get(\"variable.cluster.allocated.memory\");\n    }\n    if (allocatedVCoresGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges()\n                    .containsKey(\"variable.cluster.allocated.vcores\")) {\n      allocatedVCoresGauge \u003d metrics.getGauges()\n              .get(\"variable.cluster.allocated.vcores\");\n    }\n    if (availableMemoryGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges()\n                    .containsKey(\"variable.cluster.available.memory\")) {\n      availableMemoryGauge \u003d metrics.getGauges()\n              .get(\"variable.cluster.available.memory\");\n    }\n    if (availableVCoresGauge \u003d\u003d null \u0026\u0026\n            metrics.getGauges()\n                    .containsKey(\"variable.cluster.available.vcores\")) {\n      availableVCoresGauge \u003d metrics.getGauges()\n              .get(\"variable.cluster.available.vcores\");\n    }\n    allocatedMemoryGB \u003d allocatedMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(allocatedMemoryGauge.getValue().toString())/1024;\n    allocatedVCoresGB \u003d allocatedVCoresGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(allocatedVCoresGauge.getValue().toString());\n    availableMemoryGB \u003d availableMemoryGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(availableMemoryGauge.getValue().toString())/1024;\n    availableVCoresGB \u003d availableVCoresGauge \u003d\u003d null ? 0 :\n            Double.parseDouble(availableVCoresGauge.getValue().toString());\n\n    // scheduler operation\n    double allocateTimecost, handleTimecost;\n    if (allocateTimecostHistogram \u003d\u003d null \u0026\u0026\n            metrics.getHistograms().containsKey(\n                    \"sampler.scheduler.operation.allocate.timecost\")) {\n      allocateTimecostHistogram \u003d metrics.getHistograms()\n              .get(\"sampler.scheduler.operation.allocate.timecost\");\n    }\n    if (handleTimecostHistogram \u003d\u003d null \u0026\u0026\n            metrics.getHistograms().containsKey(\n                    \"sampler.scheduler.operation.handle.timecost\")) {\n      handleTimecostHistogram \u003d metrics.getHistograms()\n              .get(\"sampler.scheduler.operation.handle.timecost\");\n    }\n    allocateTimecost \u003d allocateTimecostHistogram \u003d\u003d null ? 0.0 :\n            allocateTimecostHistogram.getSnapshot().getMean()/1000000;\n    handleTimecost \u003d handleTimecostHistogram \u003d\u003d null ? 0.0 :\n            handleTimecostHistogram.getSnapshot().getMean()/1000000;\n    // various handle operation\n    Map\u003cSchedulerEventType, Double\u003e handleOperTimecostMap \u003d\n            new HashMap\u003cSchedulerEventType, Double\u003e();\n    for (SchedulerEventType e : SchedulerEventType.values()) {\n      String key \u003d \"sampler.scheduler.operation.handle.\" + e + \".timecost\";\n      if (! handleOperTimecostHistogramMap.containsKey(e) \u0026\u0026\n              metrics.getHistograms().containsKey(key)) {\n        handleOperTimecostHistogramMap.put(e, metrics.getHistograms().get(key));\n      }\n      double timecost \u003d handleOperTimecostHistogramMap.containsKey(e) ?\n          handleOperTimecostHistogramMap.get(e).getSnapshot().getMean()/1000000\n              : 0;\n      handleOperTimecostMap.put(e, timecost);\n    }\n\n    // allocated resource for each queue\n    Map\u003cString, Double\u003e queueAllocatedMemoryMap \u003d new HashMap\u003cString, Double\u003e();\n    Map\u003cString, Long\u003e queueAllocatedVCoresMap \u003d new HashMap\u003cString, Long\u003e();\n    for (String queue : wrapper.getQueueSet()) {\n      // memory\n      String key \u003d \"counter.queue.\" + queue + \".allocated.memory\";\n      if (! queueAllocatedMemoryCounterMap.containsKey(queue) \u0026\u0026\n              metrics.getCounters().containsKey(key)) {\n        queueAllocatedMemoryCounterMap.put(queue,\n                metrics.getCounters().get(key));\n      }\n      double queueAllocatedMemoryGB \u003d\n              queueAllocatedMemoryCounterMap.containsKey(queue) ?\n                  queueAllocatedMemoryCounterMap.get(queue).getCount()/1024.0\n                      : 0;\n      queueAllocatedMemoryMap.put(queue, queueAllocatedMemoryGB);\n      // vCores\n      key \u003d \"counter.queue.\" + queue + \".allocated.cores\";\n      if (! queueAllocatedVCoresCounterMap.containsKey(queue) \u0026\u0026\n              metrics.getCounters().containsKey(key)) {\n        queueAllocatedVCoresCounterMap.put(\n                queue, metrics.getCounters().get(key));\n      }\n      long queueAllocatedVCores \u003d\n              queueAllocatedVCoresCounterMap.containsKey(queue) ?\n                      queueAllocatedVCoresCounterMap.get(queue).getCount(): 0;\n      queueAllocatedVCoresMap.put(queue, queueAllocatedVCores);\n    }\n\n    // package results\n    StringBuilder sb \u003d new StringBuilder();\n    sb.append(\"{\");\n    sb.append(\"\\\"time\\\":\" ).append(System.currentTimeMillis())\n            .append(\",\\\"jvm.free.memory\\\":\").append(jvmFreeMemoryGB)\n            .append(\",\\\"jvm.max.memory\\\":\").append(jvmMaxMemoryGB)\n            .append(\",\\\"jvm.total.memory\\\":\").append(jvmTotalMemoryGB)\n            .append(\",\\\"running.applications\\\":\").append(numRunningApps)\n            .append(\",\\\"running.containers\\\":\").append(numRunningContainers)\n            .append(\",\\\"cluster.allocated.memory\\\":\").append(allocatedMemoryGB)\n            .append(\",\\\"cluster.allocated.vcores\\\":\").append(allocatedVCoresGB)\n            .append(\",\\\"cluster.available.memory\\\":\").append(availableMemoryGB)\n            .append(\",\\\"cluster.available.vcores\\\":\").append(availableVCoresGB);\n\n    for (String queue : wrapper.getQueueSet()) {\n      sb.append(\",\\\"queue.\").append(queue).append(\".allocated.memory\\\":\")\n              .append(queueAllocatedMemoryMap.get(queue));\n      sb.append(\",\\\"queue.\").append(queue).append(\".allocated.vcores\\\":\")\n              .append(queueAllocatedVCoresMap.get(queue));\n    }\n    // scheduler allocate \u0026 handle\n    sb.append(\",\\\"scheduler.allocate.timecost\\\":\").append(allocateTimecost);\n    sb.append(\",\\\"scheduler.handle.timecost\\\":\").append(handleTimecost);\n    for (SchedulerEventType e : SchedulerEventType.values()) {\n      sb.append(\",\\\"scheduler.handle-\").append(e).append(\".timecost\\\":\")\n              .append(handleOperTimecostMap.get(e));\n    }\n    sb.append(\"}\");\n    return sb.toString();\n  }",
      "path": "hadoop-tools/hadoop-sls/src/main/java/org/apache/hadoop/yarn/sls/web/SLSWebApp.java"
    }
  }
}