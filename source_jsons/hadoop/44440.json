{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "PlacementSpec.java",
  "functionName": "parse",
  "functionId": "parse___specs-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/PlacementSpec.java",
  "functionStartLine": 87,
  "functionEndLine": 115,
  "numCommitsSeen": 4,
  "timeTaken": 1817,
  "changeHistory": [
    "6c4ab0312b9829f5cb3db0480406fe79f0125f5e",
    "a08c048832d68c203fbdfce8d9f0e7dcccb02a55",
    "e60f51299dba360d13aa39f9ab714fdfc666b532"
  ],
  "changeHistoryShort": {
    "6c4ab0312b9829f5cb3db0480406fe79f0125f5e": "Ybodychange",
    "a08c048832d68c203fbdfce8d9f0e7dcccb02a55": "Ymultichange(Yexceptionschange,Ybodychange)",
    "e60f51299dba360d13aa39f9ab714fdfc666b532": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6c4ab0312b9829f5cb3db0480406fe79f0125f5e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9258. Support to specify allocation tags without constraint in distributed shell CLI. Contributed by Prabhu Joseph.\n",
      "commitDate": "21/02/19 8:18 AM",
      "commitName": "6c4ab0312b9829f5cb3db0480406fe79f0125f5e",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "12/09/18 3:31 AM",
      "commitNameOld": "67ae81f0e0ac7f107261ee15f2eb4d189e3b1983",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 162.24,
      "commitsBetweenForRepo": 1283,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,29 @@\n   public static Map\u003cString, PlacementSpec\u003e parse(String specs)\n       throws IllegalArgumentException {\n     LOG.info(\"Parsing Placement Specs: [{}]\", specs);\n \n     Map\u003cString, PlacementSpec\u003e pSpecs \u003d new HashMap\u003c\u003e();\n     Map\u003cSourceTags, PlacementConstraint\u003e parsed;\n     try {\n       parsed \u003d PlacementConstraintParser.parsePlacementSpec(specs);\n       for (Map.Entry\u003cSourceTags, PlacementConstraint\u003e entry :\n           parsed.entrySet()) {\n         LOG.info(\"Parsed source tag: {}, number of allocations: {}\",\n             entry.getKey().getTag(), entry.getKey().getNumOfAllocations());\n-        LOG.info(\"Parsed constraint: {}\", entry.getValue()\n-            .getConstraintExpr().getClass().getSimpleName());\n+        if (entry.getValue() !\u003d null) {\n+          LOG.info(\"Parsed constraint: {}\", entry.getValue()\n+              .getConstraintExpr().getClass().getSimpleName());\n+        } else {\n+          LOG.info(\"Parsed constraint Empty\");\n+        }\n         pSpecs.put(entry.getKey().getTag(), new PlacementSpec(\n             entry.getKey().getTag(),\n             entry.getKey().getNumOfAllocations(),\n             entry.getValue()));\n       }\n       return pSpecs;\n     } catch (PlacementConstraintParseException e) {\n       throw new IllegalArgumentException(\n           \"Invalid placement spec: \" + specs, e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static Map\u003cString, PlacementSpec\u003e parse(String specs)\n      throws IllegalArgumentException {\n    LOG.info(\"Parsing Placement Specs: [{}]\", specs);\n\n    Map\u003cString, PlacementSpec\u003e pSpecs \u003d new HashMap\u003c\u003e();\n    Map\u003cSourceTags, PlacementConstraint\u003e parsed;\n    try {\n      parsed \u003d PlacementConstraintParser.parsePlacementSpec(specs);\n      for (Map.Entry\u003cSourceTags, PlacementConstraint\u003e entry :\n          parsed.entrySet()) {\n        LOG.info(\"Parsed source tag: {}, number of allocations: {}\",\n            entry.getKey().getTag(), entry.getKey().getNumOfAllocations());\n        if (entry.getValue() !\u003d null) {\n          LOG.info(\"Parsed constraint: {}\", entry.getValue()\n              .getConstraintExpr().getClass().getSimpleName());\n        } else {\n          LOG.info(\"Parsed constraint Empty\");\n        }\n        pSpecs.put(entry.getKey().getTag(), new PlacementSpec(\n            entry.getKey().getTag(),\n            entry.getKey().getNumOfAllocations(),\n            entry.getValue()));\n      }\n      return pSpecs;\n    } catch (PlacementConstraintParseException e) {\n      throw new IllegalArgumentException(\n          \"Invalid placement spec: \" + specs, e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/PlacementSpec.java",
      "extendedDetails": {}
    },
    "a08c048832d68c203fbdfce8d9f0e7dcccb02a55": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-7838. Support AND/OR constraints in Distributed Shell. Contributed by Weiwei Yang.\n",
      "commitDate": "10/02/18 10:20 PM",
      "commitName": "a08c048832d68c203fbdfce8d9f0e7dcccb02a55",
      "commitAuthor": "Weiwei Yang",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-7838. Support AND/OR constraints in Distributed Shell. Contributed by Weiwei Yang.\n",
          "commitDate": "10/02/18 10:20 PM",
          "commitName": "a08c048832d68c203fbdfce8d9f0e7dcccb02a55",
          "commitAuthor": "Weiwei Yang",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "e60f51299dba360d13aa39f9ab714fdfc666b532",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 10.87,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,24 @@\n-  public static Map\u003cString, PlacementSpec\u003e parse(String specs) {\n+  public static Map\u003cString, PlacementSpec\u003e parse(String specs)\n+      throws IllegalArgumentException {\n     LOG.info(\"Parsing Placement Specs: [{}]\", specs);\n-    Scanner s \u003d new Scanner(specs).useDelimiter(SPEC_DELIM);\n     Map\u003cString, PlacementSpec\u003e pSpecs \u003d new HashMap\u003c\u003e();\n-    while (s.hasNext()) {\n-      String sp \u003d s.next();\n-      LOG.info(\"Parsing Spec: [{}]\", sp);\n-      String[] specSplit \u003d sp.split(KV_SPLIT_DELIM);\n-      String sourceTag \u003d specSplit[0];\n-      Scanner ps \u003d new Scanner(specSplit[1]).useDelimiter(SPEC_VAL_DELIM);\n-      int numContainers \u003d ps.nextInt();\n-      if (!ps.hasNext()) {\n-        pSpecs.put(sourceTag,\n-            new PlacementSpec(sourceTag, numContainers, null));\n-        LOG.info(\"Creating Spec without constraint {}: num[{}]\",\n-            sourceTag, numContainers);\n-        continue;\n+    Map\u003cSourceTags, PlacementConstraint\u003e parsed;\n+    try {\n+      parsed \u003d PlacementConstraintParser.parsePlacementSpec(specs);\n+      for (Map.Entry\u003cSourceTags, PlacementConstraint\u003e entry :\n+          parsed.entrySet()) {\n+        LOG.info(\"Parsed source tag: {}, number of allocations: {}\",\n+            entry.getKey().getTag(), entry.getKey().getNumOfAllocations());\n+        LOG.info(\"Parsed constraint: {}\", entry.getValue()\n+            .getConstraintExpr().getClass().getSimpleName());\n+        pSpecs.put(entry.getKey().getTag(), new PlacementSpec(\n+            entry.getKey().getTag(),\n+            entry.getKey().getNumOfAllocations(),\n+            entry.getValue()));\n       }\n-      String cType \u003d ps.next().toLowerCase();\n-      String scope \u003d ps.next().toLowerCase();\n-\n-      String targetTag \u003d ps.next();\n-      scope \u003d scope.equals(\"rack\") ? PlacementConstraints.RACK :\n-          PlacementConstraints.NODE;\n-\n-      PlacementConstraint pc;\n-      if (cType.equals(IN)) {\n-        pc \u003d PlacementConstraints.build(\n-            PlacementConstraints.targetIn(scope,\n-                PlacementConstraints.PlacementTargets.allocationTag(\n-                    targetTag)));\n-        LOG.info(\"Creating IN Constraint for source tag [{}], num[{}]: \" +\n-                \"scope[{}], target[{}]\",\n-            sourceTag, numContainers, scope, targetTag);\n-      } else if (cType.equals(NOT_IN)) {\n-        pc \u003d PlacementConstraints.build(\n-            PlacementConstraints.targetNotIn(scope,\n-                PlacementConstraints.PlacementTargets.allocationTag(\n-                    targetTag)));\n-        LOG.info(\"Creating NOT_IN Constraint for source tag [{}], num[{}]: \" +\n-                \"scope[{}], target[{}]\",\n-            sourceTag, numContainers, scope, targetTag);\n-      } else if (cType.equals(CARDINALITY)) {\n-        int minCard \u003d ps.nextInt();\n-        int maxCard \u003d ps.nextInt();\n-        pc \u003d PlacementConstraints.build(\n-            PlacementConstraints.targetCardinality(scope, minCard, maxCard,\n-                PlacementConstraints.PlacementTargets.allocationTag(\n-                    targetTag)));\n-        LOG.info(\"Creating CARDINALITY Constraint source tag [{}], num[{}]: \" +\n-                \"scope[{}], min[{}], max[{}], target[{}]\",\n-            sourceTag, numContainers, scope, minCard, maxCard, targetTag);\n-      } else {\n-        throw new RuntimeException(\n-            \"Could not parse constraintType [\" + cType + \"]\" +\n-                \" in [\" + specSplit[1] + \"]\");\n-      }\n-      pSpecs.put(sourceTag, new PlacementSpec(sourceTag, numContainers, pc));\n+      return pSpecs;\n+    } catch (PlacementConstraintParseException e) {\n+      throw new IllegalArgumentException(\n+          \"Invalid placement spec: \" + specs, e);\n     }\n-    return pSpecs;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static Map\u003cString, PlacementSpec\u003e parse(String specs)\n      throws IllegalArgumentException {\n    LOG.info(\"Parsing Placement Specs: [{}]\", specs);\n    Map\u003cString, PlacementSpec\u003e pSpecs \u003d new HashMap\u003c\u003e();\n    Map\u003cSourceTags, PlacementConstraint\u003e parsed;\n    try {\n      parsed \u003d PlacementConstraintParser.parsePlacementSpec(specs);\n      for (Map.Entry\u003cSourceTags, PlacementConstraint\u003e entry :\n          parsed.entrySet()) {\n        LOG.info(\"Parsed source tag: {}, number of allocations: {}\",\n            entry.getKey().getTag(), entry.getKey().getNumOfAllocations());\n        LOG.info(\"Parsed constraint: {}\", entry.getValue()\n            .getConstraintExpr().getClass().getSimpleName());\n        pSpecs.put(entry.getKey().getTag(), new PlacementSpec(\n            entry.getKey().getTag(),\n            entry.getKey().getNumOfAllocations(),\n            entry.getValue()));\n      }\n      return pSpecs;\n    } catch (PlacementConstraintParseException e) {\n      throw new IllegalArgumentException(\n          \"Invalid placement spec: \" + specs, e);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/PlacementSpec.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IllegalArgumentException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7838. Support AND/OR constraints in Distributed Shell. Contributed by Weiwei Yang.\n",
          "commitDate": "10/02/18 10:20 PM",
          "commitName": "a08c048832d68c203fbdfce8d9f0e7dcccb02a55",
          "commitAuthor": "Weiwei Yang",
          "commitDateOld": "31/01/18 1:30 AM",
          "commitNameOld": "e60f51299dba360d13aa39f9ab714fdfc666b532",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 10.87,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,24 @@\n-  public static Map\u003cString, PlacementSpec\u003e parse(String specs) {\n+  public static Map\u003cString, PlacementSpec\u003e parse(String specs)\n+      throws IllegalArgumentException {\n     LOG.info(\"Parsing Placement Specs: [{}]\", specs);\n-    Scanner s \u003d new Scanner(specs).useDelimiter(SPEC_DELIM);\n     Map\u003cString, PlacementSpec\u003e pSpecs \u003d new HashMap\u003c\u003e();\n-    while (s.hasNext()) {\n-      String sp \u003d s.next();\n-      LOG.info(\"Parsing Spec: [{}]\", sp);\n-      String[] specSplit \u003d sp.split(KV_SPLIT_DELIM);\n-      String sourceTag \u003d specSplit[0];\n-      Scanner ps \u003d new Scanner(specSplit[1]).useDelimiter(SPEC_VAL_DELIM);\n-      int numContainers \u003d ps.nextInt();\n-      if (!ps.hasNext()) {\n-        pSpecs.put(sourceTag,\n-            new PlacementSpec(sourceTag, numContainers, null));\n-        LOG.info(\"Creating Spec without constraint {}: num[{}]\",\n-            sourceTag, numContainers);\n-        continue;\n+    Map\u003cSourceTags, PlacementConstraint\u003e parsed;\n+    try {\n+      parsed \u003d PlacementConstraintParser.parsePlacementSpec(specs);\n+      for (Map.Entry\u003cSourceTags, PlacementConstraint\u003e entry :\n+          parsed.entrySet()) {\n+        LOG.info(\"Parsed source tag: {}, number of allocations: {}\",\n+            entry.getKey().getTag(), entry.getKey().getNumOfAllocations());\n+        LOG.info(\"Parsed constraint: {}\", entry.getValue()\n+            .getConstraintExpr().getClass().getSimpleName());\n+        pSpecs.put(entry.getKey().getTag(), new PlacementSpec(\n+            entry.getKey().getTag(),\n+            entry.getKey().getNumOfAllocations(),\n+            entry.getValue()));\n       }\n-      String cType \u003d ps.next().toLowerCase();\n-      String scope \u003d ps.next().toLowerCase();\n-\n-      String targetTag \u003d ps.next();\n-      scope \u003d scope.equals(\"rack\") ? PlacementConstraints.RACK :\n-          PlacementConstraints.NODE;\n-\n-      PlacementConstraint pc;\n-      if (cType.equals(IN)) {\n-        pc \u003d PlacementConstraints.build(\n-            PlacementConstraints.targetIn(scope,\n-                PlacementConstraints.PlacementTargets.allocationTag(\n-                    targetTag)));\n-        LOG.info(\"Creating IN Constraint for source tag [{}], num[{}]: \" +\n-                \"scope[{}], target[{}]\",\n-            sourceTag, numContainers, scope, targetTag);\n-      } else if (cType.equals(NOT_IN)) {\n-        pc \u003d PlacementConstraints.build(\n-            PlacementConstraints.targetNotIn(scope,\n-                PlacementConstraints.PlacementTargets.allocationTag(\n-                    targetTag)));\n-        LOG.info(\"Creating NOT_IN Constraint for source tag [{}], num[{}]: \" +\n-                \"scope[{}], target[{}]\",\n-            sourceTag, numContainers, scope, targetTag);\n-      } else if (cType.equals(CARDINALITY)) {\n-        int minCard \u003d ps.nextInt();\n-        int maxCard \u003d ps.nextInt();\n-        pc \u003d PlacementConstraints.build(\n-            PlacementConstraints.targetCardinality(scope, minCard, maxCard,\n-                PlacementConstraints.PlacementTargets.allocationTag(\n-                    targetTag)));\n-        LOG.info(\"Creating CARDINALITY Constraint source tag [{}], num[{}]: \" +\n-                \"scope[{}], min[{}], max[{}], target[{}]\",\n-            sourceTag, numContainers, scope, minCard, maxCard, targetTag);\n-      } else {\n-        throw new RuntimeException(\n-            \"Could not parse constraintType [\" + cType + \"]\" +\n-                \" in [\" + specSplit[1] + \"]\");\n-      }\n-      pSpecs.put(sourceTag, new PlacementSpec(sourceTag, numContainers, pc));\n+      return pSpecs;\n+    } catch (PlacementConstraintParseException e) {\n+      throw new IllegalArgumentException(\n+          \"Invalid placement spec: \" + specs, e);\n     }\n-    return pSpecs;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public static Map\u003cString, PlacementSpec\u003e parse(String specs)\n      throws IllegalArgumentException {\n    LOG.info(\"Parsing Placement Specs: [{}]\", specs);\n    Map\u003cString, PlacementSpec\u003e pSpecs \u003d new HashMap\u003c\u003e();\n    Map\u003cSourceTags, PlacementConstraint\u003e parsed;\n    try {\n      parsed \u003d PlacementConstraintParser.parsePlacementSpec(specs);\n      for (Map.Entry\u003cSourceTags, PlacementConstraint\u003e entry :\n          parsed.entrySet()) {\n        LOG.info(\"Parsed source tag: {}, number of allocations: {}\",\n            entry.getKey().getTag(), entry.getKey().getNumOfAllocations());\n        LOG.info(\"Parsed constraint: {}\", entry.getValue()\n            .getConstraintExpr().getClass().getSimpleName());\n        pSpecs.put(entry.getKey().getTag(), new PlacementSpec(\n            entry.getKey().getTag(),\n            entry.getKey().getNumOfAllocations(),\n            entry.getValue()));\n      }\n      return pSpecs;\n    } catch (PlacementConstraintParseException e) {\n      throw new IllegalArgumentException(\n          \"Invalid placement spec: \" + specs, e);\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/PlacementSpec.java",
          "extendedDetails": {}
        }
      ]
    },
    "e60f51299dba360d13aa39f9ab714fdfc666b532": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7745. Allow DistributedShell to take a placement specification for containers it wants to launch. (Arun Suresh via wangda)\n\nChange-Id: Ided146d662e944a8a4692e5d6885f23fd9bbcad5\n",
      "commitDate": "31/01/18 1:30 AM",
      "commitName": "e60f51299dba360d13aa39f9ab714fdfc666b532",
      "commitAuthor": "Wangda Tan",
      "diff": "@@ -0,0 +1,61 @@\n+  public static Map\u003cString, PlacementSpec\u003e parse(String specs) {\n+    LOG.info(\"Parsing Placement Specs: [{}]\", specs);\n+    Scanner s \u003d new Scanner(specs).useDelimiter(SPEC_DELIM);\n+    Map\u003cString, PlacementSpec\u003e pSpecs \u003d new HashMap\u003c\u003e();\n+    while (s.hasNext()) {\n+      String sp \u003d s.next();\n+      LOG.info(\"Parsing Spec: [{}]\", sp);\n+      String[] specSplit \u003d sp.split(KV_SPLIT_DELIM);\n+      String sourceTag \u003d specSplit[0];\n+      Scanner ps \u003d new Scanner(specSplit[1]).useDelimiter(SPEC_VAL_DELIM);\n+      int numContainers \u003d ps.nextInt();\n+      if (!ps.hasNext()) {\n+        pSpecs.put(sourceTag,\n+            new PlacementSpec(sourceTag, numContainers, null));\n+        LOG.info(\"Creating Spec without constraint {}: num[{}]\",\n+            sourceTag, numContainers);\n+        continue;\n+      }\n+      String cType \u003d ps.next().toLowerCase();\n+      String scope \u003d ps.next().toLowerCase();\n+\n+      String targetTag \u003d ps.next();\n+      scope \u003d scope.equals(\"rack\") ? PlacementConstraints.RACK :\n+          PlacementConstraints.NODE;\n+\n+      PlacementConstraint pc;\n+      if (cType.equals(IN)) {\n+        pc \u003d PlacementConstraints.build(\n+            PlacementConstraints.targetIn(scope,\n+                PlacementConstraints.PlacementTargets.allocationTag(\n+                    targetTag)));\n+        LOG.info(\"Creating IN Constraint for source tag [{}], num[{}]: \" +\n+                \"scope[{}], target[{}]\",\n+            sourceTag, numContainers, scope, targetTag);\n+      } else if (cType.equals(NOT_IN)) {\n+        pc \u003d PlacementConstraints.build(\n+            PlacementConstraints.targetNotIn(scope,\n+                PlacementConstraints.PlacementTargets.allocationTag(\n+                    targetTag)));\n+        LOG.info(\"Creating NOT_IN Constraint for source tag [{}], num[{}]: \" +\n+                \"scope[{}], target[{}]\",\n+            sourceTag, numContainers, scope, targetTag);\n+      } else if (cType.equals(CARDINALITY)) {\n+        int minCard \u003d ps.nextInt();\n+        int maxCard \u003d ps.nextInt();\n+        pc \u003d PlacementConstraints.build(\n+            PlacementConstraints.targetCardinality(scope, minCard, maxCard,\n+                PlacementConstraints.PlacementTargets.allocationTag(\n+                    targetTag)));\n+        LOG.info(\"Creating CARDINALITY Constraint source tag [{}], num[{}]: \" +\n+                \"scope[{}], min[{}], max[{}], target[{}]\",\n+            sourceTag, numContainers, scope, minCard, maxCard, targetTag);\n+      } else {\n+        throw new RuntimeException(\n+            \"Could not parse constraintType [\" + cType + \"]\" +\n+                \" in [\" + specSplit[1] + \"]\");\n+      }\n+      pSpecs.put(sourceTag, new PlacementSpec(sourceTag, numContainers, pc));\n+    }\n+    return pSpecs;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static Map\u003cString, PlacementSpec\u003e parse(String specs) {\n    LOG.info(\"Parsing Placement Specs: [{}]\", specs);\n    Scanner s \u003d new Scanner(specs).useDelimiter(SPEC_DELIM);\n    Map\u003cString, PlacementSpec\u003e pSpecs \u003d new HashMap\u003c\u003e();\n    while (s.hasNext()) {\n      String sp \u003d s.next();\n      LOG.info(\"Parsing Spec: [{}]\", sp);\n      String[] specSplit \u003d sp.split(KV_SPLIT_DELIM);\n      String sourceTag \u003d specSplit[0];\n      Scanner ps \u003d new Scanner(specSplit[1]).useDelimiter(SPEC_VAL_DELIM);\n      int numContainers \u003d ps.nextInt();\n      if (!ps.hasNext()) {\n        pSpecs.put(sourceTag,\n            new PlacementSpec(sourceTag, numContainers, null));\n        LOG.info(\"Creating Spec without constraint {}: num[{}]\",\n            sourceTag, numContainers);\n        continue;\n      }\n      String cType \u003d ps.next().toLowerCase();\n      String scope \u003d ps.next().toLowerCase();\n\n      String targetTag \u003d ps.next();\n      scope \u003d scope.equals(\"rack\") ? PlacementConstraints.RACK :\n          PlacementConstraints.NODE;\n\n      PlacementConstraint pc;\n      if (cType.equals(IN)) {\n        pc \u003d PlacementConstraints.build(\n            PlacementConstraints.targetIn(scope,\n                PlacementConstraints.PlacementTargets.allocationTag(\n                    targetTag)));\n        LOG.info(\"Creating IN Constraint for source tag [{}], num[{}]: \" +\n                \"scope[{}], target[{}]\",\n            sourceTag, numContainers, scope, targetTag);\n      } else if (cType.equals(NOT_IN)) {\n        pc \u003d PlacementConstraints.build(\n            PlacementConstraints.targetNotIn(scope,\n                PlacementConstraints.PlacementTargets.allocationTag(\n                    targetTag)));\n        LOG.info(\"Creating NOT_IN Constraint for source tag [{}], num[{}]: \" +\n                \"scope[{}], target[{}]\",\n            sourceTag, numContainers, scope, targetTag);\n      } else if (cType.equals(CARDINALITY)) {\n        int minCard \u003d ps.nextInt();\n        int maxCard \u003d ps.nextInt();\n        pc \u003d PlacementConstraints.build(\n            PlacementConstraints.targetCardinality(scope, minCard, maxCard,\n                PlacementConstraints.PlacementTargets.allocationTag(\n                    targetTag)));\n        LOG.info(\"Creating CARDINALITY Constraint source tag [{}], num[{}]: \" +\n                \"scope[{}], min[{}], max[{}], target[{}]\",\n            sourceTag, numContainers, scope, minCard, maxCard, targetTag);\n      } else {\n        throw new RuntimeException(\n            \"Could not parse constraintType [\" + cType + \"]\" +\n                \" in [\" + specSplit[1] + \"]\");\n      }\n      pSpecs.put(sourceTag, new PlacementSpec(sourceTag, numContainers, pc));\n    }\n    return pSpecs;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-applications/hadoop-yarn-applications-distributedshell/src/main/java/org/apache/hadoop/yarn/applications/distributedshell/PlacementSpec.java"
    }
  }
}