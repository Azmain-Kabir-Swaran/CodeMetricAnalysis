{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSNamesystem.java",
  "functionName": "finalizeRollingUpgrade",
  "functionId": "finalizeRollingUpgrade",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
  "functionStartLine": 7379,
  "functionEndLine": 7410,
  "numCommitsSeen": 873,
  "timeTaken": 36388,
  "changeHistory": [
    "1824aee9da4056de0fb638906b2172e486bbebe7",
    "9d3e4cccf9cd0ffb60ee0e7c65cea5ae3c8015c2",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893",
    "d27d7fc72e279614212c1eae52a84675073e89fb",
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
    "1a495fbb489c9e9a23b341a52696d10e9e272b04",
    "3560180b6e9926aa3ee1357da59b28a4b4689a0d",
    "3dfd6e68fe5028fe3766ae5056dc175c38cc97e1",
    "94a1462bd55ad5c71d776d22b9150003fe9ae30d",
    "2298f3d2418c1edc14d7b986eb4f0e5b9507f7a0",
    "5d29338017fb8ebe8626002c1ca670842968ca4a"
  ],
  "changeHistoryShort": {
    "1824aee9da4056de0fb638906b2172e486bbebe7": "Ybodychange",
    "9d3e4cccf9cd0ffb60ee0e7c65cea5ae3c8015c2": "Ybodychange",
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": "Ybodychange",
    "d27d7fc72e279614212c1eae52a84675073e89fb": "Ybodychange",
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5": "Ybodychange",
    "1a495fbb489c9e9a23b341a52696d10e9e272b04": "Ybodychange",
    "3560180b6e9926aa3ee1357da59b28a4b4689a0d": "Ymultichange(Yreturntypechange,Ybodychange)",
    "3dfd6e68fe5028fe3766ae5056dc175c38cc97e1": "Ymultichange(Yreturntypechange,Ybodychange)",
    "94a1462bd55ad5c71d776d22b9150003fe9ae30d": "Ybodychange",
    "2298f3d2418c1edc14d7b986eb4f0e5b9507f7a0": "Ybodychange",
    "5d29338017fb8ebe8626002c1ca670842968ca4a": "Ybodychange"
  },
  "changeHistoryDetails": {
    "1824aee9da4056de0fb638906b2172e486bbebe7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15217 Add more information to longest write/read lock held log\n\n",
      "commitDate": "18/04/20 1:52 PM",
      "commitName": "1824aee9da4056de0fb638906b2172e486bbebe7",
      "commitAuthor": "Toshihiro Suzuki",
      "commitDateOld": "25/03/20 10:28 AM",
      "commitNameOld": "a700803a18fb957d2799001a2ce1dcb70f75c080",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 24.14,
      "commitsBetweenForRepo": 78,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n   RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n     final String operationName \u003d \"finalizeRollingUpgrade\";\n     checkSuperuserPrivilege(operationName);\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n     try {\n       checkOperation(OperationCategory.WRITE);\n       if (!isRollingUpgrade()) {\n         return null;\n       }\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n       finalizeRollingUpgradeInternal(now());\n       getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());\n       if (haEnabled) {\n         // roll the edit log to make sure the standby NameNode can tail\n         getFSImage().rollEditLog(getEffectiveLayoutVersion());\n       }\n       getFSImage().updateStorageVersion();\n       getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n           NameNodeFile.IMAGE);\n     } finally {\n-      writeUnlock(operationName);\n+      writeUnlock(operationName, getLockReportInfoSupplier(null));\n     }\n \n     if (!haEnabled) {\n       // Sync not needed for ha since the edit was rolled after logging.\n       getEditLog().logSync();\n     }\n     logAuditEvent(true, operationName, null, null, null);\n     return rollingUpgradeInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n    final String operationName \u003d \"finalizeRollingUpgrade\";\n    checkSuperuserPrivilege(operationName);\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    try {\n      checkOperation(OperationCategory.WRITE);\n      if (!isRollingUpgrade()) {\n        return null;\n      }\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());\n      if (haEnabled) {\n        // roll the edit log to make sure the standby NameNode can tail\n        getFSImage().rollEditLog(getEffectiveLayoutVersion());\n      }\n      getFSImage().updateStorageVersion();\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock(operationName, getLockReportInfoSupplier(null));\n    }\n\n    if (!haEnabled) {\n      // Sync not needed for ha since the edit was rolled after logging.\n      getEditLog().logSync();\n    }\n    logAuditEvent(true, operationName, null, null, null);\n    return rollingUpgradeInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "9d3e4cccf9cd0ffb60ee0e7c65cea5ae3c8015c2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5040.Audit log for admin commands/ logging output of all DFS admin commands. Contributed by Kuhu Shukla.\n",
      "commitDate": "26/09/17 9:29 AM",
      "commitName": "9d3e4cccf9cd0ffb60ee0e7c65cea5ae3c8015c2",
      "commitAuthor": "Brahma Reddy Battula",
      "commitDateOld": "24/09/17 9:03 PM",
      "commitNameOld": "d0b2c5850b523a3888b2fadcfcdf6edbed33f221",
      "commitAuthorOld": "Anu Engineer",
      "daysBetweenCommits": 1.52,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,32 @@\n   RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n     final String operationName \u003d \"finalizeRollingUpgrade\";\n-    checkSuperuserPrivilege();\n+    checkSuperuserPrivilege(operationName);\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n     try {\n       checkOperation(OperationCategory.WRITE);\n       if (!isRollingUpgrade()) {\n         return null;\n       }\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n       finalizeRollingUpgradeInternal(now());\n       getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());\n       if (haEnabled) {\n         // roll the edit log to make sure the standby NameNode can tail\n         getFSImage().rollEditLog(getEffectiveLayoutVersion());\n       }\n       getFSImage().updateStorageVersion();\n       getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n           NameNodeFile.IMAGE);\n     } finally {\n       writeUnlock(operationName);\n     }\n \n     if (!haEnabled) {\n       // Sync not needed for ha since the edit was rolled after logging.\n       getEditLog().logSync();\n     }\n     logAuditEvent(true, operationName, null, null, null);\n     return rollingUpgradeInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n    final String operationName \u003d \"finalizeRollingUpgrade\";\n    checkSuperuserPrivilege(operationName);\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    try {\n      checkOperation(OperationCategory.WRITE);\n      if (!isRollingUpgrade()) {\n        return null;\n      }\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());\n      if (haEnabled) {\n        // roll the edit log to make sure the standby NameNode can tail\n        getFSImage().rollEditLog(getEffectiveLayoutVersion());\n      }\n      getFSImage().updateStorageVersion();\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock(operationName);\n    }\n\n    if (!haEnabled) {\n      // Sync not needed for ha since the edit was rolled after logging.\n      getEditLog().logSync();\n    }\n    logAuditEvent(true, operationName, null, null, null);\n    return rollingUpgradeInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "ff0b99eafeda035ebe0dc82cfe689808047a8893": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10872. Add MutableRate metrics for FSNamesystemLock operations. Contributed by Erik Krogen.\n",
      "commitDate": "14/11/16 11:05 AM",
      "commitName": "ff0b99eafeda035ebe0dc82cfe689808047a8893",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "08/11/16 6:17 PM",
      "commitNameOld": "ed0bebabaaf27cd730f7f8eb002d92c9c7db327d",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 5.7,
      "commitsBetweenForRepo": 36,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,32 @@\n   RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n+    final String operationName \u003d \"finalizeRollingUpgrade\";\n     checkSuperuserPrivilege();\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n     try {\n       checkOperation(OperationCategory.WRITE);\n       if (!isRollingUpgrade()) {\n         return null;\n       }\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n       finalizeRollingUpgradeInternal(now());\n       getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());\n       if (haEnabled) {\n         // roll the edit log to make sure the standby NameNode can tail\n         getFSImage().rollEditLog(getEffectiveLayoutVersion());\n       }\n       getFSImage().updateStorageVersion();\n       getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n           NameNodeFile.IMAGE);\n     } finally {\n-      writeUnlock();\n+      writeUnlock(operationName);\n     }\n \n     if (!haEnabled) {\n       // Sync not needed for ha since the edit was rolled after logging.\n       getEditLog().logSync();\n     }\n-    logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n+    logAuditEvent(true, operationName, null, null, null);\n     return rollingUpgradeInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n    final String operationName \u003d \"finalizeRollingUpgrade\";\n    checkSuperuserPrivilege();\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    try {\n      checkOperation(OperationCategory.WRITE);\n      if (!isRollingUpgrade()) {\n        return null;\n      }\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());\n      if (haEnabled) {\n        // roll the edit log to make sure the standby NameNode can tail\n        getFSImage().rollEditLog(getEffectiveLayoutVersion());\n      }\n      getFSImage().updateStorageVersion();\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock(operationName);\n    }\n\n    if (!haEnabled) {\n      // Sync not needed for ha since the edit was rolled after logging.\n      getEditLog().logSync();\n    }\n    logAuditEvent(true, operationName, null, null, null);\n    return rollingUpgradeInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "d27d7fc72e279614212c1eae52a84675073e89fb": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9395. Make HDFS audit logging consistant. Contributed by Kuhu Shukla.\n",
      "commitDate": "24/02/16 10:04 AM",
      "commitName": "d27d7fc72e279614212c1eae52a84675073e89fb",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "21/02/16 7:51 PM",
      "commitNameOld": "f313516731d787f6be64c9406ca83d941d47ee99",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 2.59,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,31 @@\n   RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n     checkSuperuserPrivilege();\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n     try {\n       checkOperation(OperationCategory.WRITE);\n       if (!isRollingUpgrade()) {\n         return null;\n       }\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n       finalizeRollingUpgradeInternal(now());\n       getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());\n       if (haEnabled) {\n         // roll the edit log to make sure the standby NameNode can tail\n         getFSImage().rollEditLog(getEffectiveLayoutVersion());\n       }\n       getFSImage().updateStorageVersion();\n       getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n           NameNodeFile.IMAGE);\n     } finally {\n       writeUnlock();\n     }\n \n     if (!haEnabled) {\n       // Sync not needed for ha since the edit was rolled after logging.\n       getEditLog().logSync();\n     }\n-\n-    if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n-      logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n-    }\n+    logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n     return rollingUpgradeInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n    checkSuperuserPrivilege();\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    try {\n      checkOperation(OperationCategory.WRITE);\n      if (!isRollingUpgrade()) {\n        return null;\n      }\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());\n      if (haEnabled) {\n        // roll the edit log to make sure the standby NameNode can tail\n        getFSImage().rollEditLog(getEffectiveLayoutVersion());\n      }\n      getFSImage().updateStorageVersion();\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock();\n    }\n\n    if (!haEnabled) {\n      // Sync not needed for ha since the edit was rolled after logging.\n      getEditLog().logSync();\n    }\n    logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n    return rollingUpgradeInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "71de367c5e80ea76d1e8d21f0216cd6b879dcee5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8432. Introduce a minimum compatible layout version to allow downgrade in more rolling upgrade use cases. Contributed by Chris Nauroth.\n",
      "commitDate": "06/06/15 9:43 AM",
      "commitName": "71de367c5e80ea76d1e8d21f0216cd6b879dcee5",
      "commitAuthor": "cnauroth",
      "commitDateOld": "05/06/15 3:09 PM",
      "commitNameOld": "3841d09765bab332c9ae4803c5981799585b1f41",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 0.77,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n     checkSuperuserPrivilege();\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n     try {\n       checkOperation(OperationCategory.WRITE);\n       if (!isRollingUpgrade()) {\n         return null;\n       }\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n       finalizeRollingUpgradeInternal(now());\n       getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());\n       if (haEnabled) {\n         // roll the edit log to make sure the standby NameNode can tail\n-        getFSImage().rollEditLog();\n+        getFSImage().rollEditLog(getEffectiveLayoutVersion());\n       }\n       getFSImage().updateStorageVersion();\n       getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n           NameNodeFile.IMAGE);\n     } finally {\n       writeUnlock();\n     }\n \n     if (!haEnabled) {\n       // Sync not needed for ha since the edit was rolled after logging.\n       getEditLog().logSync();\n     }\n \n     if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n       logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n     }\n     return rollingUpgradeInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n    checkSuperuserPrivilege();\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    try {\n      checkOperation(OperationCategory.WRITE);\n      if (!isRollingUpgrade()) {\n        return null;\n      }\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());\n      if (haEnabled) {\n        // roll the edit log to make sure the standby NameNode can tail\n        getFSImage().rollEditLog(getEffectiveLayoutVersion());\n      }\n      getFSImage().updateStorageVersion();\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock();\n    }\n\n    if (!haEnabled) {\n      // Sync not needed for ha since the edit was rolled after logging.\n      getEditLog().logSync();\n    }\n\n    if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n      logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n    }\n    return rollingUpgradeInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "1a495fbb489c9e9a23b341a52696d10e9e272b04": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7645. Rolling upgrade is restoring blocks from trash multiple times (Contributed by Vinayakumar B and Keisuke Ogiwara)\n",
      "commitDate": "30/03/15 3:25 PM",
      "commitName": "1a495fbb489c9e9a23b341a52696d10e9e272b04",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "28/03/15 12:15 PM",
      "commitNameOld": "3d9132d434c39e9b6e142e5cf9fd7a8afa4190a6",
      "commitAuthorOld": "Harsh J",
      "daysBetweenCommits": 2.13,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,34 @@\n   RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n     checkSuperuserPrivilege();\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n-    final RollingUpgradeInfo returnInfo;\n     try {\n       checkOperation(OperationCategory.WRITE);\n       if (!isRollingUpgrade()) {\n         return null;\n       }\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n-      returnInfo \u003d finalizeRollingUpgradeInternal(now());\n-      getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n+      finalizeRollingUpgradeInternal(now());\n+      getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());\n       if (haEnabled) {\n         // roll the edit log to make sure the standby NameNode can tail\n         getFSImage().rollEditLog();\n       }\n       getFSImage().updateStorageVersion();\n       getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n           NameNodeFile.IMAGE);\n     } finally {\n       writeUnlock();\n     }\n \n     if (!haEnabled) {\n       // Sync not needed for ha since the edit was rolled after logging.\n       getEditLog().logSync();\n     }\n \n     if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n       logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n     }\n-    return returnInfo;\n+    return rollingUpgradeInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n    checkSuperuserPrivilege();\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    try {\n      checkOperation(OperationCategory.WRITE);\n      if (!isRollingUpgrade()) {\n        return null;\n      }\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());\n      if (haEnabled) {\n        // roll the edit log to make sure the standby NameNode can tail\n        getFSImage().rollEditLog();\n      }\n      getFSImage().updateStorageVersion();\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock();\n    }\n\n    if (!haEnabled) {\n      // Sync not needed for ha since the edit was rolled after logging.\n      getEditLog().logSync();\n    }\n\n    if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n      logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n    }\n    return rollingUpgradeInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "3560180b6e9926aa3ee1357da59b28a4b4689a0d": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-7869. Inconsistency in the return information while performing rolling upgrade ( Contributed by J.Andreina )\n",
      "commitDate": "04/03/15 1:08 AM",
      "commitName": "3560180b6e9926aa3ee1357da59b28a4b4689a0d",
      "commitAuthor": "Vinayakumar B",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-7869. Inconsistency in the return information while performing rolling upgrade ( Contributed by J.Andreina )\n",
          "commitDate": "04/03/15 1:08 AM",
          "commitName": "3560180b6e9926aa3ee1357da59b28a4b4689a0d",
          "commitAuthor": "Vinayakumar B",
          "commitDateOld": "02/03/15 8:22 PM",
          "commitNameOld": "b442aeec95abfa1c6f835a116dfe6e186b0d841d",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 1.2,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,35 @@\n-  void finalizeRollingUpgrade() throws IOException {\n+  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n     checkSuperuserPrivilege();\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n     final RollingUpgradeInfo returnInfo;\n     try {\n       checkOperation(OperationCategory.WRITE);\n       if (!isRollingUpgrade()) {\n-        return;\n+        return null;\n       }\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n       returnInfo \u003d finalizeRollingUpgradeInternal(now());\n       getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n       if (haEnabled) {\n         // roll the edit log to make sure the standby NameNode can tail\n         getFSImage().rollEditLog();\n       }\n       getFSImage().updateStorageVersion();\n       getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n           NameNodeFile.IMAGE);\n     } finally {\n       writeUnlock();\n     }\n \n     if (!haEnabled) {\n       // Sync not needed for ha since the edit was rolled after logging.\n       getEditLog().logSync();\n     }\n \n     if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n       logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n     }\n-    return;\n+    return returnInfo;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n    checkSuperuserPrivilege();\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    final RollingUpgradeInfo returnInfo;\n    try {\n      checkOperation(OperationCategory.WRITE);\n      if (!isRollingUpgrade()) {\n        return null;\n      }\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      returnInfo \u003d finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n      if (haEnabled) {\n        // roll the edit log to make sure the standby NameNode can tail\n        getFSImage().rollEditLog();\n      }\n      getFSImage().updateStorageVersion();\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock();\n    }\n\n    if (!haEnabled) {\n      // Sync not needed for ha since the edit was rolled after logging.\n      getEditLog().logSync();\n    }\n\n    if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n      logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n    }\n    return returnInfo;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "RollingUpgradeInfo"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7869. Inconsistency in the return information while performing rolling upgrade ( Contributed by J.Andreina )\n",
          "commitDate": "04/03/15 1:08 AM",
          "commitName": "3560180b6e9926aa3ee1357da59b28a4b4689a0d",
          "commitAuthor": "Vinayakumar B",
          "commitDateOld": "02/03/15 8:22 PM",
          "commitNameOld": "b442aeec95abfa1c6f835a116dfe6e186b0d841d",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 1.2,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,35 +1,35 @@\n-  void finalizeRollingUpgrade() throws IOException {\n+  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n     checkSuperuserPrivilege();\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n     final RollingUpgradeInfo returnInfo;\n     try {\n       checkOperation(OperationCategory.WRITE);\n       if (!isRollingUpgrade()) {\n-        return;\n+        return null;\n       }\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n       returnInfo \u003d finalizeRollingUpgradeInternal(now());\n       getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n       if (haEnabled) {\n         // roll the edit log to make sure the standby NameNode can tail\n         getFSImage().rollEditLog();\n       }\n       getFSImage().updateStorageVersion();\n       getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n           NameNodeFile.IMAGE);\n     } finally {\n       writeUnlock();\n     }\n \n     if (!haEnabled) {\n       // Sync not needed for ha since the edit was rolled after logging.\n       getEditLog().logSync();\n     }\n \n     if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n       logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n     }\n-    return;\n+    return returnInfo;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n    checkSuperuserPrivilege();\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    final RollingUpgradeInfo returnInfo;\n    try {\n      checkOperation(OperationCategory.WRITE);\n      if (!isRollingUpgrade()) {\n        return null;\n      }\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      returnInfo \u003d finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n      if (haEnabled) {\n        // roll the edit log to make sure the standby NameNode can tail\n        getFSImage().rollEditLog();\n      }\n      getFSImage().updateStorageVersion();\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock();\n    }\n\n    if (!haEnabled) {\n      // Sync not needed for ha since the edit was rolled after logging.\n      getEditLog().logSync();\n    }\n\n    if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n      logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n    }\n    return returnInfo;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "3dfd6e68fe5028fe3766ae5056dc175c38cc97e1": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-7340. Make rollingUpgrade start/finalize idempotent. Contributed by Jing Zhao.\n",
      "commitDate": "04/11/14 10:16 AM",
      "commitName": "3dfd6e68fe5028fe3766ae5056dc175c38cc97e1",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-7340. Make rollingUpgrade start/finalize idempotent. Contributed by Jing Zhao.\n",
          "commitDate": "04/11/14 10:16 AM",
          "commitName": "3dfd6e68fe5028fe3766ae5056dc175c38cc97e1",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "30/10/14 10:26 PM",
          "commitNameOld": "c637d6d9d5cb36b8cd5180787c5d25b68f2aa370",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 4.53,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,35 @@\n-  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n+  void finalizeRollingUpgrade() throws IOException {\n     checkSuperuserPrivilege();\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n     final RollingUpgradeInfo returnInfo;\n     try {\n       checkOperation(OperationCategory.WRITE);\n+      if (!isRollingUpgrade()) {\n+        return;\n+      }\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n       returnInfo \u003d finalizeRollingUpgradeInternal(now());\n       getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n       if (haEnabled) {\n         // roll the edit log to make sure the standby NameNode can tail\n         getFSImage().rollEditLog();\n       }\n       getFSImage().updateStorageVersion();\n       getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n           NameNodeFile.IMAGE);\n     } finally {\n       writeUnlock();\n     }\n \n     if (!haEnabled) {\n       // Sync not needed for ha since the edit was rolled after logging.\n       getEditLog().logSync();\n     }\n \n     if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n       logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n     }\n-    return returnInfo;\n+    return;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void finalizeRollingUpgrade() throws IOException {\n    checkSuperuserPrivilege();\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    final RollingUpgradeInfo returnInfo;\n    try {\n      checkOperation(OperationCategory.WRITE);\n      if (!isRollingUpgrade()) {\n        return;\n      }\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      returnInfo \u003d finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n      if (haEnabled) {\n        // roll the edit log to make sure the standby NameNode can tail\n        getFSImage().rollEditLog();\n      }\n      getFSImage().updateStorageVersion();\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock();\n    }\n\n    if (!haEnabled) {\n      // Sync not needed for ha since the edit was rolled after logging.\n      getEditLog().logSync();\n    }\n\n    if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n      logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n    }\n    return;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {
            "oldValue": "RollingUpgradeInfo",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-7340. Make rollingUpgrade start/finalize idempotent. Contributed by Jing Zhao.\n",
          "commitDate": "04/11/14 10:16 AM",
          "commitName": "3dfd6e68fe5028fe3766ae5056dc175c38cc97e1",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "30/10/14 10:26 PM",
          "commitNameOld": "c637d6d9d5cb36b8cd5180787c5d25b68f2aa370",
          "commitAuthorOld": "cnauroth",
          "daysBetweenCommits": 4.53,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,32 +1,35 @@\n-  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n+  void finalizeRollingUpgrade() throws IOException {\n     checkSuperuserPrivilege();\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n     final RollingUpgradeInfo returnInfo;\n     try {\n       checkOperation(OperationCategory.WRITE);\n+      if (!isRollingUpgrade()) {\n+        return;\n+      }\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n       returnInfo \u003d finalizeRollingUpgradeInternal(now());\n       getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n       if (haEnabled) {\n         // roll the edit log to make sure the standby NameNode can tail\n         getFSImage().rollEditLog();\n       }\n       getFSImage().updateStorageVersion();\n       getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n           NameNodeFile.IMAGE);\n     } finally {\n       writeUnlock();\n     }\n \n     if (!haEnabled) {\n       // Sync not needed for ha since the edit was rolled after logging.\n       getEditLog().logSync();\n     }\n \n     if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n       logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n     }\n-    return returnInfo;\n+    return;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void finalizeRollingUpgrade() throws IOException {\n    checkSuperuserPrivilege();\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    final RollingUpgradeInfo returnInfo;\n    try {\n      checkOperation(OperationCategory.WRITE);\n      if (!isRollingUpgrade()) {\n        return;\n      }\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      returnInfo \u003d finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n      if (haEnabled) {\n        // roll the edit log to make sure the standby NameNode can tail\n        getFSImage().rollEditLog();\n      }\n      getFSImage().updateStorageVersion();\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock();\n    }\n\n    if (!haEnabled) {\n      // Sync not needed for ha since the edit was rolled after logging.\n      getEditLog().logSync();\n    }\n\n    if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n      logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n    }\n    return;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "94a1462bd55ad5c71d776d22b9150003fe9ae30d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6601. Issues in finalizing rolling upgrade when there is a layout version change. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1606371 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/06/14 8:21 AM",
      "commitName": "94a1462bd55ad5c71d776d22b9150003fe9ae30d",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "28/06/14 4:40 AM",
      "commitNameOld": "78cafe34e6ed218b409057aac09828bf1c9fae9c",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,32 @@\n   RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n     checkSuperuserPrivilege();\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n     final RollingUpgradeInfo returnInfo;\n     try {\n       checkOperation(OperationCategory.WRITE);\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n       returnInfo \u003d finalizeRollingUpgradeInternal(now());\n       getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n       if (haEnabled) {\n         // roll the edit log to make sure the standby NameNode can tail\n         getFSImage().rollEditLog();\n       }\n+      getFSImage().updateStorageVersion();\n       getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n           NameNodeFile.IMAGE);\n     } finally {\n       writeUnlock();\n     }\n \n     if (!haEnabled) {\n       // Sync not needed for ha since the edit was rolled after logging.\n       getEditLog().logSync();\n     }\n \n     if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n       logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n     }\n     return returnInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n    checkSuperuserPrivilege();\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    final RollingUpgradeInfo returnInfo;\n    try {\n      checkOperation(OperationCategory.WRITE);\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      returnInfo \u003d finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n      if (haEnabled) {\n        // roll the edit log to make sure the standby NameNode can tail\n        getFSImage().rollEditLog();\n      }\n      getFSImage().updateStorageVersion();\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock();\n    }\n\n    if (!haEnabled) {\n      // Sync not needed for ha since the edit was rolled after logging.\n      getEditLog().logSync();\n    }\n\n    if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n      logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n    }\n    return returnInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "2298f3d2418c1edc14d7b986eb4f0e5b9507f7a0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6545. Finalizing rolling upgrade can make NN unavailable for a long duration. Contributed by Kihwal Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1603239 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/14 10:58 AM",
      "commitName": "2298f3d2418c1edc14d7b986eb4f0e5b9507f7a0",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "13/06/14 11:04 AM",
      "commitNameOld": "02f3ff33876752f0cce0d91eef62a4d564e11072",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 4.0,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,31 @@\n   RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n     checkSuperuserPrivilege();\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n     final RollingUpgradeInfo returnInfo;\n     try {\n       checkOperation(OperationCategory.WRITE);\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n       returnInfo \u003d finalizeRollingUpgradeInternal(now());\n       getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n-      getFSImage().saveNamespace(this);\n+      if (haEnabled) {\n+        // roll the edit log to make sure the standby NameNode can tail\n+        getFSImage().rollEditLog();\n+      }\n       getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n           NameNodeFile.IMAGE);\n     } finally {\n       writeUnlock();\n     }\n \n-    // getEditLog().logSync() is not needed since it does saveNamespace \n+    if (!haEnabled) {\n+      // Sync not needed for ha since the edit was rolled after logging.\n+      getEditLog().logSync();\n+    }\n \n     if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n       logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n     }\n     return returnInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n    checkSuperuserPrivilege();\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    final RollingUpgradeInfo returnInfo;\n    try {\n      checkOperation(OperationCategory.WRITE);\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      returnInfo \u003d finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n      if (haEnabled) {\n        // roll the edit log to make sure the standby NameNode can tail\n        getFSImage().rollEditLog();\n      }\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock();\n    }\n\n    if (!haEnabled) {\n      // Sync not needed for ha since the edit was rolled after logging.\n      getEditLog().logSync();\n    }\n\n    if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n      logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n    }\n    return returnInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    },
    "5d29338017fb8ebe8626002c1ca670842968ca4a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6041. Downgrade/Finalize should rename the rollback image instead of purging it. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1573851 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/03/14 8:42 PM",
      "commitName": "5d29338017fb8ebe8626002c1ca670842968ca4a",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "03/03/14 2:31 PM",
      "commitNameOld": "98983b2788508936ad489e61ff61cacfe73ab1b9",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,24 +1,25 @@\n   RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n     checkSuperuserPrivilege();\n     checkOperation(OperationCategory.WRITE);\n     writeLock();\n     final RollingUpgradeInfo returnInfo;\n     try {\n       checkOperation(OperationCategory.WRITE);\n       checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n \n       returnInfo \u003d finalizeRollingUpgradeInternal(now());\n       getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n       getFSImage().saveNamespace(this);\n-      getFSImage().purgeCheckpoints(NameNodeFile.IMAGE_ROLLBACK);\n+      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n+          NameNodeFile.IMAGE);\n     } finally {\n       writeUnlock();\n     }\n \n     // getEditLog().logSync() is not needed since it does saveNamespace \n \n     if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n       logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n     }\n     return returnInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  RollingUpgradeInfo finalizeRollingUpgrade() throws IOException {\n    checkSuperuserPrivilege();\n    checkOperation(OperationCategory.WRITE);\n    writeLock();\n    final RollingUpgradeInfo returnInfo;\n    try {\n      checkOperation(OperationCategory.WRITE);\n      checkNameNodeSafeMode(\"Failed to finalize rolling upgrade\");\n\n      returnInfo \u003d finalizeRollingUpgradeInternal(now());\n      getEditLog().logFinalizeRollingUpgrade(returnInfo.getFinalizeTime());\n      getFSImage().saveNamespace(this);\n      getFSImage().renameCheckpoint(NameNodeFile.IMAGE_ROLLBACK,\n          NameNodeFile.IMAGE);\n    } finally {\n      writeUnlock();\n    }\n\n    // getEditLog().logSync() is not needed since it does saveNamespace \n\n    if (auditLog.isInfoEnabled() \u0026\u0026 isExternalInvocation()) {\n      logAuditEvent(true, \"finalizeRollingUpgrade\", null, null, null);\n    }\n    return returnInfo;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java",
      "extendedDetails": {}
    }
  }
}