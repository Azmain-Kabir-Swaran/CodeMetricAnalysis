{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AMRMClientImpl.java",
  "functionName": "getMatchingRequests",
  "functionId": "getMatchingRequests___priority-Priority__resourceName-String__capability-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
  "functionStartLine": 716,
  "functionEndLine": 722,
  "numCommitsSeen": 69,
  "timeTaken": 2235,
  "changeHistory": [
    "51432779588fdd741b4840601f5db637ec783d92",
    "1fe8e2d7eed74453cfe172853881fafc360a10b6",
    "fe735f237c735a375d2bd194ed80ef9949fb1a68",
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a",
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e"
  ],
  "changeHistoryShort": {
    "51432779588fdd741b4840601f5db637ec783d92": "Ybodychange",
    "1fe8e2d7eed74453cfe172853881fafc360a10b6": "Ybodychange",
    "fe735f237c735a375d2bd194ed80ef9949fb1a68": "Ybodychange",
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a": "Yfilerename",
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "51432779588fdd741b4840601f5db637ec783d92": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5124. Modify AMRMClient to set the ExecutionType in the ResourceRequest. (asuresh)\n",
      "commitDate": "12/06/16 9:42 AM",
      "commitName": "51432779588fdd741b4840601f5db637ec783d92",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "29/05/16 8:54 AM",
      "commitNameOld": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 14.03,
      "commitsBetweenForRepo": 85,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,7 @@\n   public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n-                                          Priority priority, \n-                                          String resourceName, \n-                                          Resource capability) {\n-    Preconditions.checkArgument(capability !\u003d null,\n-        \"The Resource to be requested should not be null \");\n-    Preconditions.checkArgument(priority !\u003d null,\n-        \"The priority at which to request containers should not be null \");\n-    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n-    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n-        this.remoteRequestsTable.get(priority);\n-    if (remoteRequests \u003d\u003d null) {\n-      return list;\n-    }\n-    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n-        .get(resourceName);\n-    if (reqMap \u003d\u003d null) {\n-      return list;\n-    }\n-\n-    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n-    if (resourceRequestInfo !\u003d null \u0026\u0026\n-        !resourceRequestInfo.containerRequests.isEmpty()) {\n-      list.add(resourceRequestInfo.containerRequests);\n-      return list;\n-    }\n-    \n-    // no exact match. Container may be larger than what was requested.\n-    // get all resources \u003c\u003d capability. map is reverse sorted. \n-    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n-                                                  reqMap.tailMap(capability);\n-    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n-      if (canFit(entry.getKey(), capability) \u0026\u0026\n-          !entry.getValue().containerRequests.isEmpty()) {\n-        // match found that fits in the larger resource\n-        list.add(entry.getValue().containerRequests);\n-      }\n-    }\n-    \n-    // no match found\n-    return list;          \n+      Priority priority,\n+      String resourceName,\n+      Resource capability) {\n+    return getMatchingRequests(priority, resourceName,\n+        ExecutionType.GUARANTEED, capability);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n      Priority priority,\n      String resourceName,\n      Resource capability) {\n    return getMatchingRequests(priority, resourceName,\n        ExecutionType.GUARANTEED, capability);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "1fe8e2d7eed74453cfe172853881fafc360a10b6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-521. Augment AM - RM client module to be able to request containers only at specific locations (Sandy Ryza via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503526 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/07/13 5:23 PM",
      "commitName": "1fe8e2d7eed74453cfe172853881fafc360a10b6",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "15/07/13 10:13 AM",
      "commitNameOld": "fe735f237c735a375d2bd194ed80ef9949fb1a68",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,42 @@\n   public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n                                           Priority priority, \n                                           String resourceName, \n                                           Resource capability) {\n     Preconditions.checkArgument(capability !\u003d null,\n         \"The Resource to be requested should not be null \");\n     Preconditions.checkArgument(priority !\u003d null,\n         \"The priority at which to request containers should not be null \");\n     List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n     Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n         this.remoteRequestsTable.get(priority);\n     if (remoteRequests \u003d\u003d null) {\n       return list;\n     }\n     TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n         .get(resourceName);\n     if (reqMap \u003d\u003d null) {\n       return list;\n     }\n \n     ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n-    if (resourceRequestInfo !\u003d null) {\n+    if (resourceRequestInfo !\u003d null \u0026\u0026\n+        !resourceRequestInfo.containerRequests.isEmpty()) {\n       list.add(resourceRequestInfo.containerRequests);\n       return list;\n     }\n     \n     // no exact match. Container may be larger than what was requested.\n     // get all resources \u003c\u003d capability. map is reverse sorted. \n     SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n                                                   reqMap.tailMap(capability);\n     for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n-      if(canFit(entry.getKey(), capability)) {\n+      if (canFit(entry.getKey(), capability) \u0026\u0026\n+          !entry.getValue().containerRequests.isEmpty()) {\n         // match found that fits in the larger resource\n         list.add(entry.getValue().containerRequests);\n       }\n     }\n     \n     // no match found\n     return list;          \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n                                          Priority priority, \n                                          String resourceName, \n                                          Resource capability) {\n    Preconditions.checkArgument(capability !\u003d null,\n        \"The Resource to be requested should not be null \");\n    Preconditions.checkArgument(priority !\u003d null,\n        \"The priority at which to request containers should not be null \");\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n        this.remoteRequestsTable.get(priority);\n    if (remoteRequests \u003d\u003d null) {\n      return list;\n    }\n    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n        .get(resourceName);\n    if (reqMap \u003d\u003d null) {\n      return list;\n    }\n\n    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n    if (resourceRequestInfo !\u003d null \u0026\u0026\n        !resourceRequestInfo.containerRequests.isEmpty()) {\n      list.add(resourceRequestInfo.containerRequests);\n      return list;\n    }\n    \n    // no exact match. Container may be larger than what was requested.\n    // get all resources \u003c\u003d capability. map is reverse sorted. \n    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n                                                  reqMap.tailMap(capability);\n    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n      if (canFit(entry.getKey(), capability) \u0026\u0026\n          !entry.getValue().containerRequests.isEmpty()) {\n        // match found that fits in the larger resource\n        list.add(entry.getValue().containerRequests);\n      }\n    }\n    \n    // no match found\n    return list;          \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "fe735f237c735a375d2bd194ed80ef9949fb1a68": {
      "type": "Ybodychange",
      "commitMessage": "YARN-654. AMRMClient: Perform sanity checks for parameters of public methods (Xuan Gong via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1503353 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/07/13 10:13 AM",
      "commitName": "fe735f237c735a375d2bd194ed80ef9949fb1a68",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "13/07/13 3:31 PM",
      "commitNameOld": "2adee634269588b85c351e8a3bd2c0c26ad2ba1b",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 1.78,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,40 @@\n   public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n                                           Priority priority, \n                                           String resourceName, \n                                           Resource capability) {\n+    Preconditions.checkArgument(capability !\u003d null,\n+        \"The Resource to be requested should not be null \");\n+    Preconditions.checkArgument(priority !\u003d null,\n+        \"The priority at which to request containers should not be null \");\n     List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n     Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n         this.remoteRequestsTable.get(priority);\n     if (remoteRequests \u003d\u003d null) {\n       return list;\n     }\n     TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n         .get(resourceName);\n     if (reqMap \u003d\u003d null) {\n       return list;\n     }\n \n     ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n     if (resourceRequestInfo !\u003d null) {\n       list.add(resourceRequestInfo.containerRequests);\n       return list;\n     }\n     \n     // no exact match. Container may be larger than what was requested.\n     // get all resources \u003c\u003d capability. map is reverse sorted. \n     SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n                                                   reqMap.tailMap(capability);\n     for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n       if(canFit(entry.getKey(), capability)) {\n         // match found that fits in the larger resource\n         list.add(entry.getValue().containerRequests);\n       }\n     }\n     \n     // no match found\n     return list;          \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n                                          Priority priority, \n                                          String resourceName, \n                                          Resource capability) {\n    Preconditions.checkArgument(capability !\u003d null,\n        \"The Resource to be requested should not be null \");\n    Preconditions.checkArgument(priority !\u003d null,\n        \"The priority at which to request containers should not be null \");\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n        this.remoteRequestsTable.get(priority);\n    if (remoteRequests \u003d\u003d null) {\n      return list;\n    }\n    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n        .get(resourceName);\n    if (reqMap \u003d\u003d null) {\n      return list;\n    }\n\n    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n    if (resourceRequestInfo !\u003d null) {\n      list.add(resourceRequestInfo.containerRequests);\n      return list;\n    }\n    \n    // no exact match. Container may be larger than what was requested.\n    // get all resources \u003c\u003d capability. map is reverse sorted. \n    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n                                                  reqMap.tailMap(capability);\n    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n      if(canFit(entry.getKey(), capability)) {\n        // match found that fits in the larger resource\n        list.add(entry.getValue().containerRequests);\n      }\n    }\n    \n    // no match found\n    return list;          \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {}
    },
    "7ef54faad4bee4346da082a3f8cc5d6ea405d74a": {
      "type": "Yfilerename",
      "commitMessage": "YARN-834. Fixed annotations for yarn-client module, reorganized packages and clearly differentiated *Async apis. Contributed by Arun C Murthy and Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494017 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 9:02 PM",
      "commitName": "7ef54faad4bee4346da082a3f8cc5d6ea405d74a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/06/13 8:10 PM",
      "commitNameOld": "2b14656ab5050dd75935b64681cdc25fb49db94f",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n                                          Priority priority, \n                                          String resourceName, \n                                          Resource capability) {\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n        this.remoteRequestsTable.get(priority);\n    if (remoteRequests \u003d\u003d null) {\n      return list;\n    }\n    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n        .get(resourceName);\n    if (reqMap \u003d\u003d null) {\n      return list;\n    }\n\n    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n    if (resourceRequestInfo !\u003d null) {\n      list.add(resourceRequestInfo.containerRequests);\n      return list;\n    }\n    \n    // no exact match. Container may be larger than what was requested.\n    // get all resources \u003c\u003d capability. map is reverse sorted. \n    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n                                                  reqMap.tailMap(capability);\n    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n      if(canFit(entry.getKey(), capability)) {\n        // match found that fits in the larger resource\n        list.add(entry.getValue().containerRequests);\n      }\n    }\n    \n    // no match found\n    return list;          \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/AMRMClientImpl.java"
      }
    },
    "3492f5eff1a22aba0d09d72a9dfd3353525c072e": {
      "type": "Yintroduced",
      "commitMessage": "YARN-660. Improve AMRMClient with matching requests (bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488485 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/06/13 1:23 AM",
      "commitName": "3492f5eff1a22aba0d09d72a9dfd3353525c072e",
      "commitAuthor": "Bikas Saha",
      "diff": "@@ -0,0 +1,36 @@\n+  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n+                                          Priority priority, \n+                                          String resourceName, \n+                                          Resource capability) {\n+    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n+    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n+        this.remoteRequestsTable.get(priority);\n+    if (remoteRequests \u003d\u003d null) {\n+      return list;\n+    }\n+    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n+        .get(resourceName);\n+    if (reqMap \u003d\u003d null) {\n+      return list;\n+    }\n+\n+    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n+    if (resourceRequestInfo !\u003d null) {\n+      list.add(resourceRequestInfo.containerRequests);\n+      return list;\n+    }\n+    \n+    // no exact match. Container may be larger than what was requested.\n+    // get all resources \u003c\u003d capability. map is reverse sorted. \n+    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n+                                                  reqMap.tailMap(capability);\n+    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n+      if(canFit(entry.getKey(), capability)) {\n+        // match found that fits in the larger resource\n+        list.add(entry.getValue().containerRequests);\n+      }\n+    }\n+    \n+    // no match found\n+    return list;          \n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized List\u003c? extends Collection\u003cT\u003e\u003e getMatchingRequests(\n                                          Priority priority, \n                                          String resourceName, \n                                          Resource capability) {\n    List\u003cLinkedHashSet\u003cT\u003e\u003e list \u003d new LinkedList\u003cLinkedHashSet\u003cT\u003e\u003e();\n    Map\u003cString, TreeMap\u003cResource, ResourceRequestInfo\u003e\u003e remoteRequests \u003d \n        this.remoteRequestsTable.get(priority);\n    if (remoteRequests \u003d\u003d null) {\n      return list;\n    }\n    TreeMap\u003cResource, ResourceRequestInfo\u003e reqMap \u003d remoteRequests\n        .get(resourceName);\n    if (reqMap \u003d\u003d null) {\n      return list;\n    }\n\n    ResourceRequestInfo resourceRequestInfo \u003d reqMap.get(capability);\n    if (resourceRequestInfo !\u003d null) {\n      list.add(resourceRequestInfo.containerRequests);\n      return list;\n    }\n    \n    // no exact match. Container may be larger than what was requested.\n    // get all resources \u003c\u003d capability. map is reverse sorted. \n    SortedMap\u003cResource, ResourceRequestInfo\u003e tailMap \u003d \n                                                  reqMap.tailMap(capability);\n    for(Map.Entry\u003cResource, ResourceRequestInfo\u003e entry : tailMap.entrySet()) {\n      if(canFit(entry.getKey(), capability)) {\n        // match found that fits in the larger resource\n        list.add(entry.getValue().containerRequests);\n      }\n    }\n    \n    // no match found\n    return list;          \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/AMRMClientImpl.java"
    }
  }
}