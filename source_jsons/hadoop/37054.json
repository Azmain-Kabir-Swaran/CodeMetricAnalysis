{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "InMemoryPlan.java",
  "functionName": "addReservation",
  "functionId": "addReservation___reservation-ReservationAllocation__isRecovering-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
  "functionStartLine": 326,
  "functionEndLine": 379,
  "numCommitsSeen": 25,
  "timeTaken": 2477,
  "changeHistory": [
    "1bbd023275db535ab80fcb60e022151e9679d468",
    "2798723a5443d04455b9d79c48d61f435ab52267",
    "506d1b1dbcb7ae5dad4a3dc4d415af241c72887c",
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168"
  ],
  "changeHistoryShort": {
    "1bbd023275db535ab80fcb60e022151e9679d468": "Ybodychange",
    "2798723a5443d04455b9d79c48d61f435ab52267": "Ymultichange(Yparameterchange,Ybodychange)",
    "506d1b1dbcb7ae5dad4a3dc4d415af241c72887c": "Ybodychange",
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1bbd023275db535ab80fcb60e022151e9679d468": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5962. Spelling errors in logging and exceptions for resource manager code (gsohn via rkanter)\n",
      "commitDate": "27/12/16 1:35 PM",
      "commitName": "1bbd023275db535ab80fcb60e022151e9679d468",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "11/02/16 10:47 AM",
      "commitNameOld": "23f937e3b718f607d4fc975610ab3a03265f0f7e",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 320.12,
      "commitsBetweenForRepo": 2250,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   public boolean addReservation(ReservationAllocation reservation,\n       boolean isRecovering) throws PlanningException {\n     // Verify the allocation is memory based otherwise it is not supported\n     InMemoryReservationAllocation inMemReservation \u003d\n         (InMemoryReservationAllocation) reservation;\n     if (inMemReservation.getUser() \u003d\u003d null) {\n       String errMsg \u003d\n           \"The specified Reservation with ID \"\n               + inMemReservation.getReservationId()\n               + \" is not mapped to any user\";\n       LOG.error(errMsg);\n       throw new IllegalArgumentException(errMsg);\n     }\n     writeLock.lock();\n     try {\n       if (reservationTable.containsKey(inMemReservation.getReservationId())) {\n         String errMsg \u003d\n             \"The specified Reservation with ID \"\n                 + inMemReservation.getReservationId() + \" already exists\";\n         LOG.error(errMsg);\n         throw new IllegalArgumentException(errMsg);\n       }\n       // Validate if we can accept this reservation, throws exception if\n       // validation fails\n       if (!isRecovering) {\n         policy.validate(this, inMemReservation);\n         // we record here the time in which the allocation has been accepted\n         reservation.setAcceptanceTimestamp(clock.getTime());\n         if (rmStateStore !\u003d null) {\n           rmStateStore.storeNewReservation(\n               ReservationSystemUtil.buildStateProto(inMemReservation),\n               getQueueName(), inMemReservation.getReservationId().toString());\n         }\n       }\n       ReservationInterval searchInterval \u003d\n           new ReservationInterval(inMemReservation.getStartTime(),\n               inMemReservation.getEndTime());\n       Set\u003cInMemoryReservationAllocation\u003e reservations \u003d\n           currentReservations.get(searchInterval);\n       if (reservations \u003d\u003d null) {\n         reservations \u003d new HashSet\u003cInMemoryReservationAllocation\u003e();\n       }\n       if (!reservations.add(inMemReservation)) {\n         LOG.error(\"Unable to add reservation: {} to plan.\",\n             inMemReservation.getReservationId());\n         return false;\n       }\n       currentReservations.put(searchInterval, reservations);\n       reservationTable.put(inMemReservation.getReservationId(),\n           inMemReservation);\n       incrementAllocation(inMemReservation);\n-      LOG.info(\"Sucessfully added reservation: {} to plan.\",\n+      LOG.info(\"Successfully added reservation: {} to plan.\",\n           inMemReservation.getReservationId());\n       return true;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean addReservation(ReservationAllocation reservation,\n      boolean isRecovering) throws PlanningException {\n    // Verify the allocation is memory based otherwise it is not supported\n    InMemoryReservationAllocation inMemReservation \u003d\n        (InMemoryReservationAllocation) reservation;\n    if (inMemReservation.getUser() \u003d\u003d null) {\n      String errMsg \u003d\n          \"The specified Reservation with ID \"\n              + inMemReservation.getReservationId()\n              + \" is not mapped to any user\";\n      LOG.error(errMsg);\n      throw new IllegalArgumentException(errMsg);\n    }\n    writeLock.lock();\n    try {\n      if (reservationTable.containsKey(inMemReservation.getReservationId())) {\n        String errMsg \u003d\n            \"The specified Reservation with ID \"\n                + inMemReservation.getReservationId() + \" already exists\";\n        LOG.error(errMsg);\n        throw new IllegalArgumentException(errMsg);\n      }\n      // Validate if we can accept this reservation, throws exception if\n      // validation fails\n      if (!isRecovering) {\n        policy.validate(this, inMemReservation);\n        // we record here the time in which the allocation has been accepted\n        reservation.setAcceptanceTimestamp(clock.getTime());\n        if (rmStateStore !\u003d null) {\n          rmStateStore.storeNewReservation(\n              ReservationSystemUtil.buildStateProto(inMemReservation),\n              getQueueName(), inMemReservation.getReservationId().toString());\n        }\n      }\n      ReservationInterval searchInterval \u003d\n          new ReservationInterval(inMemReservation.getStartTime(),\n              inMemReservation.getEndTime());\n      Set\u003cInMemoryReservationAllocation\u003e reservations \u003d\n          currentReservations.get(searchInterval);\n      if (reservations \u003d\u003d null) {\n        reservations \u003d new HashSet\u003cInMemoryReservationAllocation\u003e();\n      }\n      if (!reservations.add(inMemReservation)) {\n        LOG.error(\"Unable to add reservation: {} to plan.\",\n            inMemReservation.getReservationId());\n        return false;\n      }\n      currentReservations.put(searchInterval, reservations);\n      reservationTable.put(inMemReservation.getReservationId(),\n          inMemReservation);\n      incrementAllocation(inMemReservation);\n      LOG.info(\"Successfully added reservation: {} to plan.\",\n          inMemReservation.getReservationId());\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "2798723a5443d04455b9d79c48d61f435ab52267": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3739. Add reservation system recovery to RM recovery process. Contributed by  Subru Krishnan.\n",
      "commitDate": "22/10/15 6:51 AM",
      "commitName": "2798723a5443d04455b9d79c48d61f435ab52267",
      "commitAuthor": "Anubhav Dhoot",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3739. Add reservation system recovery to RM recovery process. Contributed by  Subru Krishnan.\n",
          "commitDate": "22/10/15 6:51 AM",
          "commitName": "2798723a5443d04455b9d79c48d61f435ab52267",
          "commitAuthor": "Anubhav Dhoot",
          "commitDateOld": "20/10/15 4:46 PM",
          "commitNameOld": "506d1b1dbcb7ae5dad4a3dc4d415af241c72887c",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 1.59,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,58 @@\n-  public boolean addReservation(ReservationAllocation reservation)\n-      throws PlanningException {\n+  public boolean addReservation(ReservationAllocation reservation,\n+      boolean isRecovering) throws PlanningException {\n     // Verify the allocation is memory based otherwise it is not supported\n     InMemoryReservationAllocation inMemReservation \u003d\n         (InMemoryReservationAllocation) reservation;\n     if (inMemReservation.getUser() \u003d\u003d null) {\n       String errMsg \u003d\n           \"The specified Reservation with ID \"\n               + inMemReservation.getReservationId()\n               + \" is not mapped to any user\";\n       LOG.error(errMsg);\n       throw new IllegalArgumentException(errMsg);\n     }\n     writeLock.lock();\n     try {\n       if (reservationTable.containsKey(inMemReservation.getReservationId())) {\n         String errMsg \u003d\n             \"The specified Reservation with ID \"\n                 + inMemReservation.getReservationId() + \" already exists\";\n         LOG.error(errMsg);\n         throw new IllegalArgumentException(errMsg);\n       }\n       // Validate if we can accept this reservation, throws exception if\n       // validation fails\n-      policy.validate(this, inMemReservation);\n-      // we record here the time in which the allocation has been accepted\n-      reservation.setAcceptanceTimestamp(clock.getTime());\n+      if (!isRecovering) {\n+        policy.validate(this, inMemReservation);\n+        // we record here the time in which the allocation has been accepted\n+        reservation.setAcceptanceTimestamp(clock.getTime());\n+        if (rmStateStore !\u003d null) {\n+          rmStateStore.storeNewReservation(\n+              ReservationSystemUtil.buildStateProto(inMemReservation),\n+              getQueueName(), inMemReservation.getReservationId().toString());\n+        }\n+      }\n       ReservationInterval searchInterval \u003d\n           new ReservationInterval(inMemReservation.getStartTime(),\n               inMemReservation.getEndTime());\n       Set\u003cInMemoryReservationAllocation\u003e reservations \u003d\n           currentReservations.get(searchInterval);\n       if (reservations \u003d\u003d null) {\n         reservations \u003d new HashSet\u003cInMemoryReservationAllocation\u003e();\n       }\n       if (!reservations.add(inMemReservation)) {\n         LOG.error(\"Unable to add reservation: {} to plan.\",\n             inMemReservation.getReservationId());\n         return false;\n       }\n       currentReservations.put(searchInterval, reservations);\n       reservationTable.put(inMemReservation.getReservationId(),\n           inMemReservation);\n-      rmContext.getStateStore().storeNewReservation(\n-          ReservationSystemUtil.buildStateProto(inMemReservation),\n-          getQueueName(), inMemReservation.getReservationId().toString());\n       incrementAllocation(inMemReservation);\n       LOG.info(\"Sucessfully added reservation: {} to plan.\",\n           inMemReservation.getReservationId());\n       return true;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean addReservation(ReservationAllocation reservation,\n      boolean isRecovering) throws PlanningException {\n    // Verify the allocation is memory based otherwise it is not supported\n    InMemoryReservationAllocation inMemReservation \u003d\n        (InMemoryReservationAllocation) reservation;\n    if (inMemReservation.getUser() \u003d\u003d null) {\n      String errMsg \u003d\n          \"The specified Reservation with ID \"\n              + inMemReservation.getReservationId()\n              + \" is not mapped to any user\";\n      LOG.error(errMsg);\n      throw new IllegalArgumentException(errMsg);\n    }\n    writeLock.lock();\n    try {\n      if (reservationTable.containsKey(inMemReservation.getReservationId())) {\n        String errMsg \u003d\n            \"The specified Reservation with ID \"\n                + inMemReservation.getReservationId() + \" already exists\";\n        LOG.error(errMsg);\n        throw new IllegalArgumentException(errMsg);\n      }\n      // Validate if we can accept this reservation, throws exception if\n      // validation fails\n      if (!isRecovering) {\n        policy.validate(this, inMemReservation);\n        // we record here the time in which the allocation has been accepted\n        reservation.setAcceptanceTimestamp(clock.getTime());\n        if (rmStateStore !\u003d null) {\n          rmStateStore.storeNewReservation(\n              ReservationSystemUtil.buildStateProto(inMemReservation),\n              getQueueName(), inMemReservation.getReservationId().toString());\n        }\n      }\n      ReservationInterval searchInterval \u003d\n          new ReservationInterval(inMemReservation.getStartTime(),\n              inMemReservation.getEndTime());\n      Set\u003cInMemoryReservationAllocation\u003e reservations \u003d\n          currentReservations.get(searchInterval);\n      if (reservations \u003d\u003d null) {\n        reservations \u003d new HashSet\u003cInMemoryReservationAllocation\u003e();\n      }\n      if (!reservations.add(inMemReservation)) {\n        LOG.error(\"Unable to add reservation: {} to plan.\",\n            inMemReservation.getReservationId());\n        return false;\n      }\n      currentReservations.put(searchInterval, reservations);\n      reservationTable.put(inMemReservation.getReservationId(),\n          inMemReservation);\n      incrementAllocation(inMemReservation);\n      LOG.info(\"Sucessfully added reservation: {} to plan.\",\n          inMemReservation.getReservationId());\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
          "extendedDetails": {
            "oldValue": "[reservation-ReservationAllocation]",
            "newValue": "[reservation-ReservationAllocation, isRecovering-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3739. Add reservation system recovery to RM recovery process. Contributed by  Subru Krishnan.\n",
          "commitDate": "22/10/15 6:51 AM",
          "commitName": "2798723a5443d04455b9d79c48d61f435ab52267",
          "commitAuthor": "Anubhav Dhoot",
          "commitDateOld": "20/10/15 4:46 PM",
          "commitNameOld": "506d1b1dbcb7ae5dad4a3dc4d415af241c72887c",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 1.59,
          "commitsBetweenForRepo": 19,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,58 @@\n-  public boolean addReservation(ReservationAllocation reservation)\n-      throws PlanningException {\n+  public boolean addReservation(ReservationAllocation reservation,\n+      boolean isRecovering) throws PlanningException {\n     // Verify the allocation is memory based otherwise it is not supported\n     InMemoryReservationAllocation inMemReservation \u003d\n         (InMemoryReservationAllocation) reservation;\n     if (inMemReservation.getUser() \u003d\u003d null) {\n       String errMsg \u003d\n           \"The specified Reservation with ID \"\n               + inMemReservation.getReservationId()\n               + \" is not mapped to any user\";\n       LOG.error(errMsg);\n       throw new IllegalArgumentException(errMsg);\n     }\n     writeLock.lock();\n     try {\n       if (reservationTable.containsKey(inMemReservation.getReservationId())) {\n         String errMsg \u003d\n             \"The specified Reservation with ID \"\n                 + inMemReservation.getReservationId() + \" already exists\";\n         LOG.error(errMsg);\n         throw new IllegalArgumentException(errMsg);\n       }\n       // Validate if we can accept this reservation, throws exception if\n       // validation fails\n-      policy.validate(this, inMemReservation);\n-      // we record here the time in which the allocation has been accepted\n-      reservation.setAcceptanceTimestamp(clock.getTime());\n+      if (!isRecovering) {\n+        policy.validate(this, inMemReservation);\n+        // we record here the time in which the allocation has been accepted\n+        reservation.setAcceptanceTimestamp(clock.getTime());\n+        if (rmStateStore !\u003d null) {\n+          rmStateStore.storeNewReservation(\n+              ReservationSystemUtil.buildStateProto(inMemReservation),\n+              getQueueName(), inMemReservation.getReservationId().toString());\n+        }\n+      }\n       ReservationInterval searchInterval \u003d\n           new ReservationInterval(inMemReservation.getStartTime(),\n               inMemReservation.getEndTime());\n       Set\u003cInMemoryReservationAllocation\u003e reservations \u003d\n           currentReservations.get(searchInterval);\n       if (reservations \u003d\u003d null) {\n         reservations \u003d new HashSet\u003cInMemoryReservationAllocation\u003e();\n       }\n       if (!reservations.add(inMemReservation)) {\n         LOG.error(\"Unable to add reservation: {} to plan.\",\n             inMemReservation.getReservationId());\n         return false;\n       }\n       currentReservations.put(searchInterval, reservations);\n       reservationTable.put(inMemReservation.getReservationId(),\n           inMemReservation);\n-      rmContext.getStateStore().storeNewReservation(\n-          ReservationSystemUtil.buildStateProto(inMemReservation),\n-          getQueueName(), inMemReservation.getReservationId().toString());\n       incrementAllocation(inMemReservation);\n       LOG.info(\"Sucessfully added reservation: {} to plan.\",\n           inMemReservation.getReservationId());\n       return true;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean addReservation(ReservationAllocation reservation,\n      boolean isRecovering) throws PlanningException {\n    // Verify the allocation is memory based otherwise it is not supported\n    InMemoryReservationAllocation inMemReservation \u003d\n        (InMemoryReservationAllocation) reservation;\n    if (inMemReservation.getUser() \u003d\u003d null) {\n      String errMsg \u003d\n          \"The specified Reservation with ID \"\n              + inMemReservation.getReservationId()\n              + \" is not mapped to any user\";\n      LOG.error(errMsg);\n      throw new IllegalArgumentException(errMsg);\n    }\n    writeLock.lock();\n    try {\n      if (reservationTable.containsKey(inMemReservation.getReservationId())) {\n        String errMsg \u003d\n            \"The specified Reservation with ID \"\n                + inMemReservation.getReservationId() + \" already exists\";\n        LOG.error(errMsg);\n        throw new IllegalArgumentException(errMsg);\n      }\n      // Validate if we can accept this reservation, throws exception if\n      // validation fails\n      if (!isRecovering) {\n        policy.validate(this, inMemReservation);\n        // we record here the time in which the allocation has been accepted\n        reservation.setAcceptanceTimestamp(clock.getTime());\n        if (rmStateStore !\u003d null) {\n          rmStateStore.storeNewReservation(\n              ReservationSystemUtil.buildStateProto(inMemReservation),\n              getQueueName(), inMemReservation.getReservationId().toString());\n        }\n      }\n      ReservationInterval searchInterval \u003d\n          new ReservationInterval(inMemReservation.getStartTime(),\n              inMemReservation.getEndTime());\n      Set\u003cInMemoryReservationAllocation\u003e reservations \u003d\n          currentReservations.get(searchInterval);\n      if (reservations \u003d\u003d null) {\n        reservations \u003d new HashSet\u003cInMemoryReservationAllocation\u003e();\n      }\n      if (!reservations.add(inMemReservation)) {\n        LOG.error(\"Unable to add reservation: {} to plan.\",\n            inMemReservation.getReservationId());\n        return false;\n      }\n      currentReservations.put(searchInterval, reservations);\n      reservationTable.put(inMemReservation.getReservationId(),\n          inMemReservation);\n      incrementAllocation(inMemReservation);\n      LOG.info(\"Sucessfully added reservation: {} to plan.\",\n          inMemReservation.getReservationId());\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
          "extendedDetails": {}
        }
      ]
    },
    "506d1b1dbcb7ae5dad4a3dc4d415af241c72887c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3985. Make ReservationSystem persist state using RMStateStore reservation APIs. (adhoot via asuresh)\n",
      "commitDate": "20/10/15 4:46 PM",
      "commitName": "506d1b1dbcb7ae5dad4a3dc4d415af241c72887c",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "25/07/15 7:39 AM",
      "commitNameOld": "156f24ead00436faad5d4aeef327a546392cd265",
      "commitAuthorOld": "ccurino",
      "daysBetweenCommits": 87.38,
      "commitsBetweenForRepo": 560,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,54 @@\n   public boolean addReservation(ReservationAllocation reservation)\n       throws PlanningException {\n     // Verify the allocation is memory based otherwise it is not supported\n     InMemoryReservationAllocation inMemReservation \u003d\n         (InMemoryReservationAllocation) reservation;\n     if (inMemReservation.getUser() \u003d\u003d null) {\n       String errMsg \u003d\n           \"The specified Reservation with ID \"\n               + inMemReservation.getReservationId()\n               + \" is not mapped to any user\";\n       LOG.error(errMsg);\n       throw new IllegalArgumentException(errMsg);\n     }\n     writeLock.lock();\n     try {\n       if (reservationTable.containsKey(inMemReservation.getReservationId())) {\n         String errMsg \u003d\n             \"The specified Reservation with ID \"\n                 + inMemReservation.getReservationId() + \" already exists\";\n         LOG.error(errMsg);\n         throw new IllegalArgumentException(errMsg);\n       }\n       // Validate if we can accept this reservation, throws exception if\n       // validation fails\n       policy.validate(this, inMemReservation);\n       // we record here the time in which the allocation has been accepted\n       reservation.setAcceptanceTimestamp(clock.getTime());\n       ReservationInterval searchInterval \u003d\n           new ReservationInterval(inMemReservation.getStartTime(),\n               inMemReservation.getEndTime());\n       Set\u003cInMemoryReservationAllocation\u003e reservations \u003d\n           currentReservations.get(searchInterval);\n       if (reservations \u003d\u003d null) {\n         reservations \u003d new HashSet\u003cInMemoryReservationAllocation\u003e();\n       }\n       if (!reservations.add(inMemReservation)) {\n         LOG.error(\"Unable to add reservation: {} to plan.\",\n             inMemReservation.getReservationId());\n         return false;\n       }\n       currentReservations.put(searchInterval, reservations);\n       reservationTable.put(inMemReservation.getReservationId(),\n           inMemReservation);\n+      rmContext.getStateStore().storeNewReservation(\n+          ReservationSystemUtil.buildStateProto(inMemReservation),\n+          getQueueName(), inMemReservation.getReservationId().toString());\n       incrementAllocation(inMemReservation);\n       LOG.info(\"Sucessfully added reservation: {} to plan.\",\n           inMemReservation.getReservationId());\n       return true;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean addReservation(ReservationAllocation reservation)\n      throws PlanningException {\n    // Verify the allocation is memory based otherwise it is not supported\n    InMemoryReservationAllocation inMemReservation \u003d\n        (InMemoryReservationAllocation) reservation;\n    if (inMemReservation.getUser() \u003d\u003d null) {\n      String errMsg \u003d\n          \"The specified Reservation with ID \"\n              + inMemReservation.getReservationId()\n              + \" is not mapped to any user\";\n      LOG.error(errMsg);\n      throw new IllegalArgumentException(errMsg);\n    }\n    writeLock.lock();\n    try {\n      if (reservationTable.containsKey(inMemReservation.getReservationId())) {\n        String errMsg \u003d\n            \"The specified Reservation with ID \"\n                + inMemReservation.getReservationId() + \" already exists\";\n        LOG.error(errMsg);\n        throw new IllegalArgumentException(errMsg);\n      }\n      // Validate if we can accept this reservation, throws exception if\n      // validation fails\n      policy.validate(this, inMemReservation);\n      // we record here the time in which the allocation has been accepted\n      reservation.setAcceptanceTimestamp(clock.getTime());\n      ReservationInterval searchInterval \u003d\n          new ReservationInterval(inMemReservation.getStartTime(),\n              inMemReservation.getEndTime());\n      Set\u003cInMemoryReservationAllocation\u003e reservations \u003d\n          currentReservations.get(searchInterval);\n      if (reservations \u003d\u003d null) {\n        reservations \u003d new HashSet\u003cInMemoryReservationAllocation\u003e();\n      }\n      if (!reservations.add(inMemReservation)) {\n        LOG.error(\"Unable to add reservation: {} to plan.\",\n            inMemReservation.getReservationId());\n        return false;\n      }\n      currentReservations.put(searchInterval, reservations);\n      reservationTable.put(inMemReservation.getReservationId(),\n          inMemReservation);\n      rmContext.getStateStore().storeNewReservation(\n          ReservationSystemUtil.buildStateProto(inMemReservation),\n          getQueueName(), inMemReservation.getReservationId().toString());\n      incrementAllocation(inMemReservation);\n      LOG.info(\"Sucessfully added reservation: {} to plan.\",\n          inMemReservation.getReservationId());\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java",
      "extendedDetails": {}
    },
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1709. In-memory data structures used to track resources over time to enable reservations.\n(cherry picked from commit 0d8b2cd88b958b1e602fd4ea4078ef8d4742a7c3)\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "cf4b34282aafee9f6b09d3433c4de1ae4b359168",
      "commitAuthor": "subru",
      "diff": "@@ -0,0 +1,51 @@\n+  public boolean addReservation(ReservationAllocation reservation)\n+      throws PlanningException {\n+    // Verify the allocation is memory based otherwise it is not supported\n+    InMemoryReservationAllocation inMemReservation \u003d\n+        (InMemoryReservationAllocation) reservation;\n+    if (inMemReservation.getUser() \u003d\u003d null) {\n+      String errMsg \u003d\n+          \"The specified Reservation with ID \"\n+              + inMemReservation.getReservationId()\n+              + \" is not mapped to any user\";\n+      LOG.error(errMsg);\n+      throw new IllegalArgumentException(errMsg);\n+    }\n+    writeLock.lock();\n+    try {\n+      if (reservationTable.containsKey(inMemReservation.getReservationId())) {\n+        String errMsg \u003d\n+            \"The specified Reservation with ID \"\n+                + inMemReservation.getReservationId() + \" already exists\";\n+        LOG.error(errMsg);\n+        throw new IllegalArgumentException(errMsg);\n+      }\n+      // Validate if we can accept this reservation, throws exception if\n+      // validation fails\n+      policy.validate(this, inMemReservation);\n+      // we record here the time in which the allocation has been accepted\n+      reservation.setAcceptanceTimestamp(clock.getTime());\n+      ReservationInterval searchInterval \u003d\n+          new ReservationInterval(inMemReservation.getStartTime(),\n+              inMemReservation.getEndTime());\n+      Set\u003cInMemoryReservationAllocation\u003e reservations \u003d\n+          currentReservations.get(searchInterval);\n+      if (reservations \u003d\u003d null) {\n+        reservations \u003d new HashSet\u003cInMemoryReservationAllocation\u003e();\n+      }\n+      if (!reservations.add(inMemReservation)) {\n+        LOG.error(\"Unable to add reservation: {} to plan.\",\n+            inMemReservation.getReservationId());\n+        return false;\n+      }\n+      currentReservations.put(searchInterval, reservations);\n+      reservationTable.put(inMemReservation.getReservationId(),\n+          inMemReservation);\n+      incrementAllocation(inMemReservation);\n+      LOG.info(\"Sucessfully added reservation: {} to plan.\",\n+          inMemReservation.getReservationId());\n+      return true;\n+    } finally {\n+      writeLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean addReservation(ReservationAllocation reservation)\n      throws PlanningException {\n    // Verify the allocation is memory based otherwise it is not supported\n    InMemoryReservationAllocation inMemReservation \u003d\n        (InMemoryReservationAllocation) reservation;\n    if (inMemReservation.getUser() \u003d\u003d null) {\n      String errMsg \u003d\n          \"The specified Reservation with ID \"\n              + inMemReservation.getReservationId()\n              + \" is not mapped to any user\";\n      LOG.error(errMsg);\n      throw new IllegalArgumentException(errMsg);\n    }\n    writeLock.lock();\n    try {\n      if (reservationTable.containsKey(inMemReservation.getReservationId())) {\n        String errMsg \u003d\n            \"The specified Reservation with ID \"\n                + inMemReservation.getReservationId() + \" already exists\";\n        LOG.error(errMsg);\n        throw new IllegalArgumentException(errMsg);\n      }\n      // Validate if we can accept this reservation, throws exception if\n      // validation fails\n      policy.validate(this, inMemReservation);\n      // we record here the time in which the allocation has been accepted\n      reservation.setAcceptanceTimestamp(clock.getTime());\n      ReservationInterval searchInterval \u003d\n          new ReservationInterval(inMemReservation.getStartTime(),\n              inMemReservation.getEndTime());\n      Set\u003cInMemoryReservationAllocation\u003e reservations \u003d\n          currentReservations.get(searchInterval);\n      if (reservations \u003d\u003d null) {\n        reservations \u003d new HashSet\u003cInMemoryReservationAllocation\u003e();\n      }\n      if (!reservations.add(inMemReservation)) {\n        LOG.error(\"Unable to add reservation: {} to plan.\",\n            inMemReservation.getReservationId());\n        return false;\n      }\n      currentReservations.put(searchInterval, reservations);\n      reservationTable.put(inMemReservation.getReservationId(),\n          inMemReservation);\n      incrementAllocation(inMemReservation);\n      LOG.info(\"Sucessfully added reservation: {} to plan.\",\n          inMemReservation.getReservationId());\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/InMemoryPlan.java"
    }
  }
}