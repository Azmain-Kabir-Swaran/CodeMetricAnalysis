{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NamenodeHeartbeatService.java",
  "functionName": "getNamenodeStatusReport",
  "functionId": "getNamenodeStatusReport",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/NamenodeHeartbeatService.java",
  "functionStartLine": 252,
  "functionEndLine": 325,
  "numCommitsSeen": 14,
  "timeTaken": 2964,
  "changeHistory": [
    "cbe71eaddf21c0ac5967e67cdd4623bd770aa9e5",
    "79010627074c4b830008444f92d8410aa1717006",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
    "67785fe0063cfbfecab0e8deaae4a45d9c7c0073",
    "d8c81073320320a019fb3868be4f06f46aebea43"
  ],
  "changeHistoryShort": {
    "cbe71eaddf21c0ac5967e67cdd4623bd770aa9e5": "Ybodychange",
    "79010627074c4b830008444f92d8410aa1717006": "Ybodychange",
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": "Yfilerename",
    "67785fe0063cfbfecab0e8deaae4a45d9c7c0073": "Ybodychange",
    "d8c81073320320a019fb3868be4f06f46aebea43": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cbe71eaddf21c0ac5967e67cdd4623bd770aa9e5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15238. RBF: NamenodeHeartbeatService caused memory to grow rapidly. Contributed by xuzq.\n",
      "commitDate": "27/03/20 1:12 AM",
      "commitName": "cbe71eaddf21c0ac5967e67cdd4623bd770aa9e5",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "04/11/19 10:03 PM",
      "commitNameOld": "79010627074c4b830008444f92d8410aa1717006",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 143.09,
      "commitsBetweenForRepo": 502,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,74 @@\n   protected NamenodeStatusReport getNamenodeStatusReport() {\n     NamenodeStatusReport report \u003d new NamenodeStatusReport(nameserviceId,\n         namenodeId, rpcAddress, serviceAddress,\n         lifelineAddress, scheme, webAddress);\n \n     try {\n       LOG.debug(\"Probing NN at service address: {}\", serviceAddress);\n \n       URI serviceURI \u003d new URI(\"hdfs://\" + serviceAddress);\n       // Read the filesystem info from RPC (required)\n       NamenodeProtocol nn \u003d NameNodeProxies\n           .createProxy(this.conf, serviceURI, NamenodeProtocol.class)\n           .getProxy();\n \n       if (nn !\u003d null) {\n         NamespaceInfo info \u003d nn.versionRequest();\n         if (info !\u003d null) {\n           report.setNamespaceInfo(info);\n         }\n       }\n       if (!report.registrationValid()) {\n         return report;\n       }\n \n       // Check for safemode from the client protocol. Currently optional, but\n       // should be required at some point for QoS\n       try {\n         ClientProtocol client \u003d NameNodeProxies\n             .createProxy(this.conf, serviceURI, ClientProtocol.class)\n             .getProxy();\n         if (client !\u003d null) {\n           boolean isSafeMode \u003d client.setSafeMode(\n               SafeModeAction.SAFEMODE_GET, false);\n           report.setSafeMode(isSafeMode);\n         }\n       } catch (Exception e) {\n         LOG.error(\"Cannot fetch safemode state for {}\", getNamenodeDesc(), e);\n       }\n \n       // Read the stats from JMX (optional)\n       updateJMXParameters(webAddress, report);\n \n       if (localTarget !\u003d null) {\n         // Try to get the HA status\n         try {\n           // Determine if NN is active\n           // TODO: dynamic timeout\n-          HAServiceProtocol haProtocol \u003d localTarget.getProxy(conf, 30*1000);\n-          HAServiceStatus status \u003d haProtocol.getServiceStatus();\n+          if (localTargetHAProtocol \u003d\u003d null) {\n+            localTargetHAProtocol \u003d localTarget.getProxy(conf, 30*1000);\n+          }\n+          HAServiceStatus status \u003d localTargetHAProtocol.getServiceStatus();\n           report.setHAServiceState(status.getState());\n         } catch (Throwable e) {\n           if (e.getMessage().startsWith(\"HA for namenode is not enabled\")) {\n             LOG.error(\"HA for {} is not enabled\", getNamenodeDesc());\n             localTarget \u003d null;\n           } else {\n             // Failed to fetch HA status, ignoring failure\n             LOG.error(\"Cannot fetch HA status for {}: {}\",\n                 getNamenodeDesc(), e.getMessage(), e);\n           }\n+          localTargetHAProtocol \u003d null;\n         }\n       }\n     } catch(IOException e) {\n       LOG.error(\"Cannot communicate with {}: {}\",\n           getNamenodeDesc(), e.getMessage());\n     } catch(Throwable e) {\n       // Generic error that we don\u0027t know about\n       LOG.error(\"Unexpected exception while communicating with {}: {}\",\n           getNamenodeDesc(), e.getMessage(), e);\n     }\n     return report;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected NamenodeStatusReport getNamenodeStatusReport() {\n    NamenodeStatusReport report \u003d new NamenodeStatusReport(nameserviceId,\n        namenodeId, rpcAddress, serviceAddress,\n        lifelineAddress, scheme, webAddress);\n\n    try {\n      LOG.debug(\"Probing NN at service address: {}\", serviceAddress);\n\n      URI serviceURI \u003d new URI(\"hdfs://\" + serviceAddress);\n      // Read the filesystem info from RPC (required)\n      NamenodeProtocol nn \u003d NameNodeProxies\n          .createProxy(this.conf, serviceURI, NamenodeProtocol.class)\n          .getProxy();\n\n      if (nn !\u003d null) {\n        NamespaceInfo info \u003d nn.versionRequest();\n        if (info !\u003d null) {\n          report.setNamespaceInfo(info);\n        }\n      }\n      if (!report.registrationValid()) {\n        return report;\n      }\n\n      // Check for safemode from the client protocol. Currently optional, but\n      // should be required at some point for QoS\n      try {\n        ClientProtocol client \u003d NameNodeProxies\n            .createProxy(this.conf, serviceURI, ClientProtocol.class)\n            .getProxy();\n        if (client !\u003d null) {\n          boolean isSafeMode \u003d client.setSafeMode(\n              SafeModeAction.SAFEMODE_GET, false);\n          report.setSafeMode(isSafeMode);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Cannot fetch safemode state for {}\", getNamenodeDesc(), e);\n      }\n\n      // Read the stats from JMX (optional)\n      updateJMXParameters(webAddress, report);\n\n      if (localTarget !\u003d null) {\n        // Try to get the HA status\n        try {\n          // Determine if NN is active\n          // TODO: dynamic timeout\n          if (localTargetHAProtocol \u003d\u003d null) {\n            localTargetHAProtocol \u003d localTarget.getProxy(conf, 30*1000);\n          }\n          HAServiceStatus status \u003d localTargetHAProtocol.getServiceStatus();\n          report.setHAServiceState(status.getState());\n        } catch (Throwable e) {\n          if (e.getMessage().startsWith(\"HA for namenode is not enabled\")) {\n            LOG.error(\"HA for {} is not enabled\", getNamenodeDesc());\n            localTarget \u003d null;\n          } else {\n            // Failed to fetch HA status, ignoring failure\n            LOG.error(\"Cannot fetch HA status for {}: {}\",\n                getNamenodeDesc(), e.getMessage(), e);\n          }\n          localTargetHAProtocol \u003d null;\n        }\n      }\n    } catch(IOException e) {\n      LOG.error(\"Cannot communicate with {}: {}\",\n          getNamenodeDesc(), e.getMessage());\n    } catch(Throwable e) {\n      // Generic error that we don\u0027t know about\n      LOG.error(\"Unexpected exception while communicating with {}: {}\",\n          getNamenodeDesc(), e.getMessage(), e);\n    }\n    return report;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/NamenodeHeartbeatService.java",
      "extendedDetails": {}
    },
    "79010627074c4b830008444f92d8410aa1717006": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14891. RBF: namenode links in NameFederation Health page (federationhealth.html) cannot use https scheme. Contributed by Xieming Li\n",
      "commitDate": "04/11/19 10:03 PM",
      "commitName": "79010627074c4b830008444f92d8410aa1717006",
      "commitAuthor": "Takanobu Asanuma",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "8627f6532baa0488c28514d9dfdd5c4f8bf8f378",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 133.56,
      "commitsBetweenForRepo": 985,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,71 @@\n   protected NamenodeStatusReport getNamenodeStatusReport() {\n     NamenodeStatusReport report \u003d new NamenodeStatusReport(nameserviceId,\n-        namenodeId, rpcAddress, serviceAddress, lifelineAddress, webAddress);\n+        namenodeId, rpcAddress, serviceAddress,\n+        lifelineAddress, scheme, webAddress);\n \n     try {\n       LOG.debug(\"Probing NN at service address: {}\", serviceAddress);\n \n       URI serviceURI \u003d new URI(\"hdfs://\" + serviceAddress);\n       // Read the filesystem info from RPC (required)\n       NamenodeProtocol nn \u003d NameNodeProxies\n           .createProxy(this.conf, serviceURI, NamenodeProtocol.class)\n           .getProxy();\n \n       if (nn !\u003d null) {\n         NamespaceInfo info \u003d nn.versionRequest();\n         if (info !\u003d null) {\n           report.setNamespaceInfo(info);\n         }\n       }\n       if (!report.registrationValid()) {\n         return report;\n       }\n \n       // Check for safemode from the client protocol. Currently optional, but\n       // should be required at some point for QoS\n       try {\n         ClientProtocol client \u003d NameNodeProxies\n             .createProxy(this.conf, serviceURI, ClientProtocol.class)\n             .getProxy();\n         if (client !\u003d null) {\n           boolean isSafeMode \u003d client.setSafeMode(\n               SafeModeAction.SAFEMODE_GET, false);\n           report.setSafeMode(isSafeMode);\n         }\n       } catch (Exception e) {\n         LOG.error(\"Cannot fetch safemode state for {}\", getNamenodeDesc(), e);\n       }\n \n       // Read the stats from JMX (optional)\n       updateJMXParameters(webAddress, report);\n \n       if (localTarget !\u003d null) {\n         // Try to get the HA status\n         try {\n           // Determine if NN is active\n           // TODO: dynamic timeout\n           HAServiceProtocol haProtocol \u003d localTarget.getProxy(conf, 30*1000);\n           HAServiceStatus status \u003d haProtocol.getServiceStatus();\n           report.setHAServiceState(status.getState());\n         } catch (Throwable e) {\n           if (e.getMessage().startsWith(\"HA for namenode is not enabled\")) {\n             LOG.error(\"HA for {} is not enabled\", getNamenodeDesc());\n             localTarget \u003d null;\n           } else {\n             // Failed to fetch HA status, ignoring failure\n             LOG.error(\"Cannot fetch HA status for {}: {}\",\n                 getNamenodeDesc(), e.getMessage(), e);\n           }\n         }\n       }\n     } catch(IOException e) {\n       LOG.error(\"Cannot communicate with {}: {}\",\n           getNamenodeDesc(), e.getMessage());\n     } catch(Throwable e) {\n       // Generic error that we don\u0027t know about\n       LOG.error(\"Unexpected exception while communicating with {}: {}\",\n           getNamenodeDesc(), e.getMessage(), e);\n     }\n     return report;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected NamenodeStatusReport getNamenodeStatusReport() {\n    NamenodeStatusReport report \u003d new NamenodeStatusReport(nameserviceId,\n        namenodeId, rpcAddress, serviceAddress,\n        lifelineAddress, scheme, webAddress);\n\n    try {\n      LOG.debug(\"Probing NN at service address: {}\", serviceAddress);\n\n      URI serviceURI \u003d new URI(\"hdfs://\" + serviceAddress);\n      // Read the filesystem info from RPC (required)\n      NamenodeProtocol nn \u003d NameNodeProxies\n          .createProxy(this.conf, serviceURI, NamenodeProtocol.class)\n          .getProxy();\n\n      if (nn !\u003d null) {\n        NamespaceInfo info \u003d nn.versionRequest();\n        if (info !\u003d null) {\n          report.setNamespaceInfo(info);\n        }\n      }\n      if (!report.registrationValid()) {\n        return report;\n      }\n\n      // Check for safemode from the client protocol. Currently optional, but\n      // should be required at some point for QoS\n      try {\n        ClientProtocol client \u003d NameNodeProxies\n            .createProxy(this.conf, serviceURI, ClientProtocol.class)\n            .getProxy();\n        if (client !\u003d null) {\n          boolean isSafeMode \u003d client.setSafeMode(\n              SafeModeAction.SAFEMODE_GET, false);\n          report.setSafeMode(isSafeMode);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Cannot fetch safemode state for {}\", getNamenodeDesc(), e);\n      }\n\n      // Read the stats from JMX (optional)\n      updateJMXParameters(webAddress, report);\n\n      if (localTarget !\u003d null) {\n        // Try to get the HA status\n        try {\n          // Determine if NN is active\n          // TODO: dynamic timeout\n          HAServiceProtocol haProtocol \u003d localTarget.getProxy(conf, 30*1000);\n          HAServiceStatus status \u003d haProtocol.getServiceStatus();\n          report.setHAServiceState(status.getState());\n        } catch (Throwable e) {\n          if (e.getMessage().startsWith(\"HA for namenode is not enabled\")) {\n            LOG.error(\"HA for {} is not enabled\", getNamenodeDesc());\n            localTarget \u003d null;\n          } else {\n            // Failed to fetch HA status, ignoring failure\n            LOG.error(\"Cannot fetch HA status for {}: {}\",\n                getNamenodeDesc(), e.getMessage(), e);\n          }\n        }\n      }\n    } catch(IOException e) {\n      LOG.error(\"Cannot communicate with {}: {}\",\n          getNamenodeDesc(), e.getMessage());\n    } catch(Throwable e) {\n      // Generic error that we don\u0027t know about\n      LOG.error(\"Unexpected exception while communicating with {}: {}\",\n          getNamenodeDesc(), e.getMessage(), e);\n    }\n    return report;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/NamenodeHeartbeatService.java",
      "extendedDetails": {}
    },
    "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-13215. RBF: Move Router to its own module. Contributed by Wei Yan\n",
      "commitDate": "19/03/18 10:13 PM",
      "commitName": "6e2b5fa493ff8e8c2bb28e6f6f4c19347bc9b99d",
      "commitAuthor": "weiy",
      "commitDateOld": "19/03/18 5:19 PM",
      "commitNameOld": "e65ff1c8be48ef4f04ed96f96ac4caef4974944d",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.2,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected NamenodeStatusReport getNamenodeStatusReport() {\n    NamenodeStatusReport report \u003d new NamenodeStatusReport(nameserviceId,\n        namenodeId, rpcAddress, serviceAddress, lifelineAddress, webAddress);\n\n    try {\n      LOG.debug(\"Probing NN at service address: {}\", serviceAddress);\n\n      URI serviceURI \u003d new URI(\"hdfs://\" + serviceAddress);\n      // Read the filesystem info from RPC (required)\n      NamenodeProtocol nn \u003d NameNodeProxies\n          .createProxy(this.conf, serviceURI, NamenodeProtocol.class)\n          .getProxy();\n\n      if (nn !\u003d null) {\n        NamespaceInfo info \u003d nn.versionRequest();\n        if (info !\u003d null) {\n          report.setNamespaceInfo(info);\n        }\n      }\n      if (!report.registrationValid()) {\n        return report;\n      }\n\n      // Check for safemode from the client protocol. Currently optional, but\n      // should be required at some point for QoS\n      try {\n        ClientProtocol client \u003d NameNodeProxies\n            .createProxy(this.conf, serviceURI, ClientProtocol.class)\n            .getProxy();\n        if (client !\u003d null) {\n          boolean isSafeMode \u003d client.setSafeMode(\n              SafeModeAction.SAFEMODE_GET, false);\n          report.setSafeMode(isSafeMode);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Cannot fetch safemode state for {}\", getNamenodeDesc(), e);\n      }\n\n      // Read the stats from JMX (optional)\n      updateJMXParameters(webAddress, report);\n\n      if (localTarget !\u003d null) {\n        // Try to get the HA status\n        try {\n          // Determine if NN is active\n          // TODO: dynamic timeout\n          HAServiceProtocol haProtocol \u003d localTarget.getProxy(conf, 30*1000);\n          HAServiceStatus status \u003d haProtocol.getServiceStatus();\n          report.setHAServiceState(status.getState());\n        } catch (Throwable e) {\n          if (e.getMessage().startsWith(\"HA for namenode is not enabled\")) {\n            LOG.error(\"HA for {} is not enabled\", getNamenodeDesc());\n            localTarget \u003d null;\n          } else {\n            // Failed to fetch HA status, ignoring failure\n            LOG.error(\"Cannot fetch HA status for {}: {}\",\n                getNamenodeDesc(), e.getMessage(), e);\n          }\n        }\n      }\n    } catch(IOException e) {\n      LOG.error(\"Cannot communicate with {}: {}\",\n          getNamenodeDesc(), e.getMessage());\n    } catch(Throwable e) {\n      // Generic error that we don\u0027t know about\n      LOG.error(\"Unexpected exception while communicating with {}: {}\",\n          getNamenodeDesc(), e.getMessage(), e);\n    }\n    return report;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/NamenodeHeartbeatService.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/NamenodeHeartbeatService.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/NamenodeHeartbeatService.java"
      }
    },
    "67785fe0063cfbfecab0e8deaae4a45d9c7c0073": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12450. Fixing TestNamenodeHeartbeat and support non-HA. Contributed by Inigo Goiri.\n\n(cherry picked from commit 928d1e87f9dbe64f89b858ccc1780723f3af58e7)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "67785fe0063cfbfecab0e8deaae4a45d9c7c0073",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "06/10/17 6:50 PM",
      "commitNameOld": "d8c81073320320a019fb3868be4f06f46aebea43",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,70 @@\n   protected NamenodeStatusReport getNamenodeStatusReport() {\n     NamenodeStatusReport report \u003d new NamenodeStatusReport(nameserviceId,\n         namenodeId, rpcAddress, serviceAddress, lifelineAddress, webAddress);\n \n     try {\n       LOG.debug(\"Probing NN at service address: {}\", serviceAddress);\n \n       URI serviceURI \u003d new URI(\"hdfs://\" + serviceAddress);\n       // Read the filesystem info from RPC (required)\n       NamenodeProtocol nn \u003d NameNodeProxies\n           .createProxy(this.conf, serviceURI, NamenodeProtocol.class)\n           .getProxy();\n \n       if (nn !\u003d null) {\n         NamespaceInfo info \u003d nn.versionRequest();\n         if (info !\u003d null) {\n           report.setNamespaceInfo(info);\n         }\n       }\n       if (!report.registrationValid()) {\n         return report;\n       }\n \n       // Check for safemode from the client protocol. Currently optional, but\n       // should be required at some point for QoS\n       try {\n         ClientProtocol client \u003d NameNodeProxies\n             .createProxy(this.conf, serviceURI, ClientProtocol.class)\n             .getProxy();\n         if (client !\u003d null) {\n           boolean isSafeMode \u003d client.setSafeMode(\n               SafeModeAction.SAFEMODE_GET, false);\n           report.setSafeMode(isSafeMode);\n         }\n       } catch (Exception e) {\n         LOG.error(\"Cannot fetch safemode state for {}\", getNamenodeDesc(), e);\n       }\n \n       // Read the stats from JMX (optional)\n       updateJMXParameters(webAddress, report);\n \n       if (localTarget !\u003d null) {\n         // Try to get the HA status\n         try {\n           // Determine if NN is active\n           // TODO: dynamic timeout\n           HAServiceProtocol haProtocol \u003d localTarget.getProxy(conf, 30*1000);\n           HAServiceStatus status \u003d haProtocol.getServiceStatus();\n           report.setHAServiceState(status.getState());\n         } catch (Throwable e) {\n-          // Failed to fetch HA status, ignoring failure\n-          LOG.error(\"Cannot fetch HA status for {}: {}\",\n-              getNamenodeDesc(), e.getMessage(), e);\n+          if (e.getMessage().startsWith(\"HA for namenode is not enabled\")) {\n+            LOG.error(\"HA for {} is not enabled\", getNamenodeDesc());\n+            localTarget \u003d null;\n+          } else {\n+            // Failed to fetch HA status, ignoring failure\n+            LOG.error(\"Cannot fetch HA status for {}: {}\",\n+                getNamenodeDesc(), e.getMessage(), e);\n+          }\n         }\n       }\n     } catch(IOException e) {\n       LOG.error(\"Cannot communicate with {}: {}\",\n           getNamenodeDesc(), e.getMessage());\n     } catch(Throwable e) {\n       // Generic error that we don\u0027t know about\n       LOG.error(\"Unexpected exception while communicating with {}: {}\",\n           getNamenodeDesc(), e.getMessage(), e);\n     }\n     return report;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected NamenodeStatusReport getNamenodeStatusReport() {\n    NamenodeStatusReport report \u003d new NamenodeStatusReport(nameserviceId,\n        namenodeId, rpcAddress, serviceAddress, lifelineAddress, webAddress);\n\n    try {\n      LOG.debug(\"Probing NN at service address: {}\", serviceAddress);\n\n      URI serviceURI \u003d new URI(\"hdfs://\" + serviceAddress);\n      // Read the filesystem info from RPC (required)\n      NamenodeProtocol nn \u003d NameNodeProxies\n          .createProxy(this.conf, serviceURI, NamenodeProtocol.class)\n          .getProxy();\n\n      if (nn !\u003d null) {\n        NamespaceInfo info \u003d nn.versionRequest();\n        if (info !\u003d null) {\n          report.setNamespaceInfo(info);\n        }\n      }\n      if (!report.registrationValid()) {\n        return report;\n      }\n\n      // Check for safemode from the client protocol. Currently optional, but\n      // should be required at some point for QoS\n      try {\n        ClientProtocol client \u003d NameNodeProxies\n            .createProxy(this.conf, serviceURI, ClientProtocol.class)\n            .getProxy();\n        if (client !\u003d null) {\n          boolean isSafeMode \u003d client.setSafeMode(\n              SafeModeAction.SAFEMODE_GET, false);\n          report.setSafeMode(isSafeMode);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Cannot fetch safemode state for {}\", getNamenodeDesc(), e);\n      }\n\n      // Read the stats from JMX (optional)\n      updateJMXParameters(webAddress, report);\n\n      if (localTarget !\u003d null) {\n        // Try to get the HA status\n        try {\n          // Determine if NN is active\n          // TODO: dynamic timeout\n          HAServiceProtocol haProtocol \u003d localTarget.getProxy(conf, 30*1000);\n          HAServiceStatus status \u003d haProtocol.getServiceStatus();\n          report.setHAServiceState(status.getState());\n        } catch (Throwable e) {\n          if (e.getMessage().startsWith(\"HA for namenode is not enabled\")) {\n            LOG.error(\"HA for {} is not enabled\", getNamenodeDesc());\n            localTarget \u003d null;\n          } else {\n            // Failed to fetch HA status, ignoring failure\n            LOG.error(\"Cannot fetch HA status for {}: {}\",\n                getNamenodeDesc(), e.getMessage(), e);\n          }\n        }\n      }\n    } catch(IOException e) {\n      LOG.error(\"Cannot communicate with {}: {}\",\n          getNamenodeDesc(), e.getMessage());\n    } catch(Throwable e) {\n      // Generic error that we don\u0027t know about\n      LOG.error(\"Unexpected exception while communicating with {}: {}\",\n          getNamenodeDesc(), e.getMessage(), e);\n    }\n    return report;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/NamenodeHeartbeatService.java",
      "extendedDetails": {}
    },
    "d8c81073320320a019fb3868be4f06f46aebea43": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-11826. Federation Namenode Heartbeat. Contributed by Inigo Goiri.\n\n(cherry picked from commit 928f8dab52191e733984d37f47b69719ccf11313)\n",
      "commitDate": "06/10/17 6:50 PM",
      "commitName": "d8c81073320320a019fb3868be4f06f46aebea43",
      "commitAuthor": "Inigo Goiri",
      "diff": "@@ -0,0 +1,65 @@\n+  protected NamenodeStatusReport getNamenodeStatusReport() {\n+    NamenodeStatusReport report \u003d new NamenodeStatusReport(nameserviceId,\n+        namenodeId, rpcAddress, serviceAddress, lifelineAddress, webAddress);\n+\n+    try {\n+      LOG.debug(\"Probing NN at service address: {}\", serviceAddress);\n+\n+      URI serviceURI \u003d new URI(\"hdfs://\" + serviceAddress);\n+      // Read the filesystem info from RPC (required)\n+      NamenodeProtocol nn \u003d NameNodeProxies\n+          .createProxy(this.conf, serviceURI, NamenodeProtocol.class)\n+          .getProxy();\n+\n+      if (nn !\u003d null) {\n+        NamespaceInfo info \u003d nn.versionRequest();\n+        if (info !\u003d null) {\n+          report.setNamespaceInfo(info);\n+        }\n+      }\n+      if (!report.registrationValid()) {\n+        return report;\n+      }\n+\n+      // Check for safemode from the client protocol. Currently optional, but\n+      // should be required at some point for QoS\n+      try {\n+        ClientProtocol client \u003d NameNodeProxies\n+            .createProxy(this.conf, serviceURI, ClientProtocol.class)\n+            .getProxy();\n+        if (client !\u003d null) {\n+          boolean isSafeMode \u003d client.setSafeMode(\n+              SafeModeAction.SAFEMODE_GET, false);\n+          report.setSafeMode(isSafeMode);\n+        }\n+      } catch (Exception e) {\n+        LOG.error(\"Cannot fetch safemode state for {}\", getNamenodeDesc(), e);\n+      }\n+\n+      // Read the stats from JMX (optional)\n+      updateJMXParameters(webAddress, report);\n+\n+      if (localTarget !\u003d null) {\n+        // Try to get the HA status\n+        try {\n+          // Determine if NN is active\n+          // TODO: dynamic timeout\n+          HAServiceProtocol haProtocol \u003d localTarget.getProxy(conf, 30*1000);\n+          HAServiceStatus status \u003d haProtocol.getServiceStatus();\n+          report.setHAServiceState(status.getState());\n+        } catch (Throwable e) {\n+          // Failed to fetch HA status, ignoring failure\n+          LOG.error(\"Cannot fetch HA status for {}: {}\",\n+              getNamenodeDesc(), e.getMessage(), e);\n+        }\n+      }\n+    } catch(IOException e) {\n+      LOG.error(\"Cannot communicate with {}: {}\",\n+          getNamenodeDesc(), e.getMessage());\n+    } catch(Throwable e) {\n+      // Generic error that we don\u0027t know about\n+      LOG.error(\"Unexpected exception while communicating with {}: {}\",\n+          getNamenodeDesc(), e.getMessage(), e);\n+    }\n+    return report;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected NamenodeStatusReport getNamenodeStatusReport() {\n    NamenodeStatusReport report \u003d new NamenodeStatusReport(nameserviceId,\n        namenodeId, rpcAddress, serviceAddress, lifelineAddress, webAddress);\n\n    try {\n      LOG.debug(\"Probing NN at service address: {}\", serviceAddress);\n\n      URI serviceURI \u003d new URI(\"hdfs://\" + serviceAddress);\n      // Read the filesystem info from RPC (required)\n      NamenodeProtocol nn \u003d NameNodeProxies\n          .createProxy(this.conf, serviceURI, NamenodeProtocol.class)\n          .getProxy();\n\n      if (nn !\u003d null) {\n        NamespaceInfo info \u003d nn.versionRequest();\n        if (info !\u003d null) {\n          report.setNamespaceInfo(info);\n        }\n      }\n      if (!report.registrationValid()) {\n        return report;\n      }\n\n      // Check for safemode from the client protocol. Currently optional, but\n      // should be required at some point for QoS\n      try {\n        ClientProtocol client \u003d NameNodeProxies\n            .createProxy(this.conf, serviceURI, ClientProtocol.class)\n            .getProxy();\n        if (client !\u003d null) {\n          boolean isSafeMode \u003d client.setSafeMode(\n              SafeModeAction.SAFEMODE_GET, false);\n          report.setSafeMode(isSafeMode);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Cannot fetch safemode state for {}\", getNamenodeDesc(), e);\n      }\n\n      // Read the stats from JMX (optional)\n      updateJMXParameters(webAddress, report);\n\n      if (localTarget !\u003d null) {\n        // Try to get the HA status\n        try {\n          // Determine if NN is active\n          // TODO: dynamic timeout\n          HAServiceProtocol haProtocol \u003d localTarget.getProxy(conf, 30*1000);\n          HAServiceStatus status \u003d haProtocol.getServiceStatus();\n          report.setHAServiceState(status.getState());\n        } catch (Throwable e) {\n          // Failed to fetch HA status, ignoring failure\n          LOG.error(\"Cannot fetch HA status for {}: {}\",\n              getNamenodeDesc(), e.getMessage(), e);\n        }\n      }\n    } catch(IOException e) {\n      LOG.error(\"Cannot communicate with {}: {}\",\n          getNamenodeDesc(), e.getMessage());\n    } catch(Throwable e) {\n      // Generic error that we don\u0027t know about\n      LOG.error(\"Unexpected exception while communicating with {}: {}\",\n          getNamenodeDesc(), e.getMessage(), e);\n    }\n    return report;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/federation/router/NamenodeHeartbeatService.java"
    }
  }
}