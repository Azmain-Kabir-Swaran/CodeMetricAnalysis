{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacityScheduler.java",
  "functionName": "allocateOrReserveNewContainers",
  "functionId": "allocateOrReserveNewContainers___candidates-CandidateNodeSet__FiCaSchedulerNode____withNodeHeartbeat-boolean",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
  "functionStartLine": 1660,
  "functionEndLine": 1717,
  "numCommitsSeen": 411,
  "timeTaken": 6540,
  "changeHistory": [
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
    "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c"
  ],
  "changeHistoryShort": {
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181": "Ybodychange",
    "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949": "Ymultichange(Yparameterchange,Ybodychange)",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": "Ybodychange",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9c3fc3ef2865164aa5f121793ac914cfeb21a181": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7494. Add muti-node lookup mechanism and pluggable nodes sorting policies to optimize placement decision. Contributed by Sunil Govindan.\n",
      "commitDate": "21/08/18 7:42 AM",
      "commitName": "9c3fc3ef2865164aa5f121793ac914cfeb21a181",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "31/07/18 8:03 PM",
      "commitNameOld": "6310c0d17d6422a595f856a55b4f1fb82be43739",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 20.49,
      "commitsBetweenForRepo": 195,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,58 @@\n   private CSAssignment allocateOrReserveNewContainers(\n       CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n       boolean withNodeHeartbeat) {\n     CSAssignment assignment \u003d getRootQueue().assignContainers(\n         getClusterResource(), candidates, new ResourceLimits(labelManager\n             .getResourceByLabel(candidates.getPartition(),\n                 getClusterResource())),\n         SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n \n     assignment.setSchedulingMode(SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n     submitResourceCommitRequest(getClusterResource(), assignment);\n \n     if (Resources.greaterThan(calculator, getClusterResource(),\n         assignment.getResource(), Resources.none())) {\n+      FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n+      NodeId nodeId \u003d null;\n+      if (node !\u003d null) {\n+        nodeId \u003d node.getNodeID();\n+      }\n       if (withNodeHeartbeat) {\n-        updateSchedulerHealth(lastNodeUpdateTime,\n-            CandidateNodeSetUtils.getSingleNode(candidates).getNodeID(),\n-            assignment);\n+        updateSchedulerHealth(lastNodeUpdateTime, nodeId, assignment);\n       }\n       return assignment;\n     }\n \n     // Only do non-exclusive allocation when node has node-labels.\n     if (StringUtils.equals(candidates.getPartition(),\n         RMNodeLabelsManager.NO_LABEL)) {\n       return null;\n     }\n \n     // Only do non-exclusive allocation when the node-label supports that\n     try {\n       if (rmContext.getNodeLabelManager().isExclusiveNodeLabel(\n           candidates.getPartition())) {\n         return null;\n       }\n     } catch (IOException e) {\n       LOG.warn(\n           \"Exception when trying to get exclusivity of node label\u003d\" + candidates\n           .getPartition(), e);\n       return null;\n     }\n \n     // Try to use NON_EXCLUSIVE\n     assignment \u003d getRootQueue().assignContainers(getClusterResource(),\n         candidates,\n         // TODO, now we only consider limits for parent for non-labeled\n         // resources, should consider labeled resources as well.\n         new ResourceLimits(labelManager\n             .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                 getClusterResource())),\n         SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n     assignment.setSchedulingMode(SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n     submitResourceCommitRequest(getClusterResource(), assignment);\n \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private CSAssignment allocateOrReserveNewContainers(\n      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      boolean withNodeHeartbeat) {\n    CSAssignment assignment \u003d getRootQueue().assignContainers(\n        getClusterResource(), candidates, new ResourceLimits(labelManager\n            .getResourceByLabel(candidates.getPartition(),\n                getClusterResource())),\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n\n    assignment.setSchedulingMode(SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n\n    if (Resources.greaterThan(calculator, getClusterResource(),\n        assignment.getResource(), Resources.none())) {\n      FiCaSchedulerNode node \u003d CandidateNodeSetUtils.getSingleNode(candidates);\n      NodeId nodeId \u003d null;\n      if (node !\u003d null) {\n        nodeId \u003d node.getNodeID();\n      }\n      if (withNodeHeartbeat) {\n        updateSchedulerHealth(lastNodeUpdateTime, nodeId, assignment);\n      }\n      return assignment;\n    }\n\n    // Only do non-exclusive allocation when node has node-labels.\n    if (StringUtils.equals(candidates.getPartition(),\n        RMNodeLabelsManager.NO_LABEL)) {\n      return null;\n    }\n\n    // Only do non-exclusive allocation when the node-label supports that\n    try {\n      if (rmContext.getNodeLabelManager().isExclusiveNodeLabel(\n          candidates.getPartition())) {\n        return null;\n      }\n    } catch (IOException e) {\n      LOG.warn(\n          \"Exception when trying to get exclusivity of node label\u003d\" + candidates\n          .getPartition(), e);\n      return null;\n    }\n\n    // Try to use NON_EXCLUSIVE\n    assignment \u003d getRootQueue().assignContainers(getClusterResource(),\n        candidates,\n        // TODO, now we only consider limits for parent for non-labeled\n        // resources, should consider labeled resources as well.\n        new ResourceLimits(labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                getClusterResource())),\n        SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n    assignment.setSchedulingMode(SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n\n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-7437. Rename PlacementSet and SchedulingPlacementSet. (Wangda Tan via kkaranasos)\n",
      "commitDate": "09/11/17 1:01 PM",
      "commitName": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
      "commitAuthor": "Konstantinos Karanasos",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7437. Rename PlacementSet and SchedulingPlacementSet. (Wangda Tan via kkaranasos)\n",
          "commitDate": "09/11/17 1:01 PM",
          "commitName": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
          "commitAuthor": "Konstantinos Karanasos",
          "commitDateOld": "09/11/17 10:49 AM",
          "commitNameOld": "a1382a18dff8a70aa25240d6fbba6e22832a7679",
          "commitAuthorOld": "Haibo Chen",
          "daysBetweenCommits": 0.09,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,55 @@\n   private CSAssignment allocateOrReserveNewContainers(\n-      PlacementSet\u003cFiCaSchedulerNode\u003e ps, boolean withNodeHeartbeat) {\n+      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n+      boolean withNodeHeartbeat) {\n     CSAssignment assignment \u003d getRootQueue().assignContainers(\n-        getClusterResource(), ps, new ResourceLimits(labelManager\n-            .getResourceByLabel(ps.getPartition(), getClusterResource())),\n+        getClusterResource(), candidates, new ResourceLimits(labelManager\n+            .getResourceByLabel(candidates.getPartition(),\n+                getClusterResource())),\n         SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n \n     assignment.setSchedulingMode(SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n     submitResourceCommitRequest(getClusterResource(), assignment);\n \n     if (Resources.greaterThan(calculator, getClusterResource(),\n         assignment.getResource(), Resources.none())) {\n       if (withNodeHeartbeat) {\n         updateSchedulerHealth(lastNodeUpdateTime,\n-            PlacementSetUtils.getSingleNode(ps).getNodeID(), assignment);\n+            CandidateNodeSetUtils.getSingleNode(candidates).getNodeID(),\n+            assignment);\n       }\n       return assignment;\n     }\n \n     // Only do non-exclusive allocation when node has node-labels.\n-    if (StringUtils.equals(ps.getPartition(), RMNodeLabelsManager.NO_LABEL)) {\n+    if (StringUtils.equals(candidates.getPartition(),\n+        RMNodeLabelsManager.NO_LABEL)) {\n       return null;\n     }\n \n     // Only do non-exclusive allocation when the node-label supports that\n     try {\n       if (rmContext.getNodeLabelManager().isExclusiveNodeLabel(\n-          ps.getPartition())) {\n+          candidates.getPartition())) {\n         return null;\n       }\n     } catch (IOException e) {\n-      LOG.warn(\"Exception when trying to get exclusivity of node label\u003d\" + ps\n+      LOG.warn(\n+          \"Exception when trying to get exclusivity of node label\u003d\" + candidates\n           .getPartition(), e);\n       return null;\n     }\n \n     // Try to use NON_EXCLUSIVE\n-    assignment \u003d getRootQueue().assignContainers(getClusterResource(), ps,\n+    assignment \u003d getRootQueue().assignContainers(getClusterResource(),\n+        candidates,\n         // TODO, now we only consider limits for parent for non-labeled\n         // resources, should consider labeled resources as well.\n         new ResourceLimits(labelManager\n             .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                 getClusterResource())),\n         SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n     assignment.setSchedulingMode(SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n     submitResourceCommitRequest(getClusterResource(), assignment);\n \n     return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private CSAssignment allocateOrReserveNewContainers(\n      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      boolean withNodeHeartbeat) {\n    CSAssignment assignment \u003d getRootQueue().assignContainers(\n        getClusterResource(), candidates, new ResourceLimits(labelManager\n            .getResourceByLabel(candidates.getPartition(),\n                getClusterResource())),\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n\n    assignment.setSchedulingMode(SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n\n    if (Resources.greaterThan(calculator, getClusterResource(),\n        assignment.getResource(), Resources.none())) {\n      if (withNodeHeartbeat) {\n        updateSchedulerHealth(lastNodeUpdateTime,\n            CandidateNodeSetUtils.getSingleNode(candidates).getNodeID(),\n            assignment);\n      }\n      return assignment;\n    }\n\n    // Only do non-exclusive allocation when node has node-labels.\n    if (StringUtils.equals(candidates.getPartition(),\n        RMNodeLabelsManager.NO_LABEL)) {\n      return null;\n    }\n\n    // Only do non-exclusive allocation when the node-label supports that\n    try {\n      if (rmContext.getNodeLabelManager().isExclusiveNodeLabel(\n          candidates.getPartition())) {\n        return null;\n      }\n    } catch (IOException e) {\n      LOG.warn(\n          \"Exception when trying to get exclusivity of node label\u003d\" + candidates\n          .getPartition(), e);\n      return null;\n    }\n\n    // Try to use NON_EXCLUSIVE\n    assignment \u003d getRootQueue().assignContainers(getClusterResource(),\n        candidates,\n        // TODO, now we only consider limits for parent for non-labeled\n        // resources, should consider labeled resources as well.\n        new ResourceLimits(labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                getClusterResource())),\n        SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n    assignment.setSchedulingMode(SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n\n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[ps-PlacementSet\u003cFiCaSchedulerNode\u003e, withNodeHeartbeat-boolean]",
            "newValue": "[candidates-CandidateNodeSet\u003cFiCaSchedulerNode\u003e, withNodeHeartbeat-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7437. Rename PlacementSet and SchedulingPlacementSet. (Wangda Tan via kkaranasos)\n",
          "commitDate": "09/11/17 1:01 PM",
          "commitName": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
          "commitAuthor": "Konstantinos Karanasos",
          "commitDateOld": "09/11/17 10:49 AM",
          "commitNameOld": "a1382a18dff8a70aa25240d6fbba6e22832a7679",
          "commitAuthorOld": "Haibo Chen",
          "daysBetweenCommits": 0.09,
          "commitsBetweenForRepo": 4,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,49 +1,55 @@\n   private CSAssignment allocateOrReserveNewContainers(\n-      PlacementSet\u003cFiCaSchedulerNode\u003e ps, boolean withNodeHeartbeat) {\n+      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n+      boolean withNodeHeartbeat) {\n     CSAssignment assignment \u003d getRootQueue().assignContainers(\n-        getClusterResource(), ps, new ResourceLimits(labelManager\n-            .getResourceByLabel(ps.getPartition(), getClusterResource())),\n+        getClusterResource(), candidates, new ResourceLimits(labelManager\n+            .getResourceByLabel(candidates.getPartition(),\n+                getClusterResource())),\n         SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n \n     assignment.setSchedulingMode(SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n     submitResourceCommitRequest(getClusterResource(), assignment);\n \n     if (Resources.greaterThan(calculator, getClusterResource(),\n         assignment.getResource(), Resources.none())) {\n       if (withNodeHeartbeat) {\n         updateSchedulerHealth(lastNodeUpdateTime,\n-            PlacementSetUtils.getSingleNode(ps).getNodeID(), assignment);\n+            CandidateNodeSetUtils.getSingleNode(candidates).getNodeID(),\n+            assignment);\n       }\n       return assignment;\n     }\n \n     // Only do non-exclusive allocation when node has node-labels.\n-    if (StringUtils.equals(ps.getPartition(), RMNodeLabelsManager.NO_LABEL)) {\n+    if (StringUtils.equals(candidates.getPartition(),\n+        RMNodeLabelsManager.NO_LABEL)) {\n       return null;\n     }\n \n     // Only do non-exclusive allocation when the node-label supports that\n     try {\n       if (rmContext.getNodeLabelManager().isExclusiveNodeLabel(\n-          ps.getPartition())) {\n+          candidates.getPartition())) {\n         return null;\n       }\n     } catch (IOException e) {\n-      LOG.warn(\"Exception when trying to get exclusivity of node label\u003d\" + ps\n+      LOG.warn(\n+          \"Exception when trying to get exclusivity of node label\u003d\" + candidates\n           .getPartition(), e);\n       return null;\n     }\n \n     // Try to use NON_EXCLUSIVE\n-    assignment \u003d getRootQueue().assignContainers(getClusterResource(), ps,\n+    assignment \u003d getRootQueue().assignContainers(getClusterResource(),\n+        candidates,\n         // TODO, now we only consider limits for parent for non-labeled\n         // resources, should consider labeled resources as well.\n         new ResourceLimits(labelManager\n             .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                 getClusterResource())),\n         SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n     assignment.setSchedulingMode(SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n     submitResourceCommitRequest(getClusterResource(), assignment);\n \n     return assignment;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private CSAssignment allocateOrReserveNewContainers(\n      CandidateNodeSet\u003cFiCaSchedulerNode\u003e candidates,\n      boolean withNodeHeartbeat) {\n    CSAssignment assignment \u003d getRootQueue().assignContainers(\n        getClusterResource(), candidates, new ResourceLimits(labelManager\n            .getResourceByLabel(candidates.getPartition(),\n                getClusterResource())),\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n\n    assignment.setSchedulingMode(SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n\n    if (Resources.greaterThan(calculator, getClusterResource(),\n        assignment.getResource(), Resources.none())) {\n      if (withNodeHeartbeat) {\n        updateSchedulerHealth(lastNodeUpdateTime,\n            CandidateNodeSetUtils.getSingleNode(candidates).getNodeID(),\n            assignment);\n      }\n      return assignment;\n    }\n\n    // Only do non-exclusive allocation when node has node-labels.\n    if (StringUtils.equals(candidates.getPartition(),\n        RMNodeLabelsManager.NO_LABEL)) {\n      return null;\n    }\n\n    // Only do non-exclusive allocation when the node-label supports that\n    try {\n      if (rmContext.getNodeLabelManager().isExclusiveNodeLabel(\n          candidates.getPartition())) {\n        return null;\n      }\n    } catch (IOException e) {\n      LOG.warn(\n          \"Exception when trying to get exclusivity of node label\u003d\" + candidates\n          .getPartition(), e);\n      return null;\n    }\n\n    // Try to use NON_EXCLUSIVE\n    assignment \u003d getRootQueue().assignContainers(getClusterResource(),\n        candidates,\n        // TODO, now we only consider limits for parent for non-labeled\n        // resources, should consider labeled resources as well.\n        new ResourceLimits(labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                getClusterResource())),\n        SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n    assignment.setSchedulingMode(SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n\n    return assignment;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5761. Separate QueueManager from Scheduler. (Xuan Gong via gtcarrera9)\n",
      "commitDate": "30/11/16 1:38 PM",
      "commitName": "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
      "commitAuthor": "Li Lu",
      "commitDateOld": "29/11/16 9:40 AM",
      "commitNameOld": "25f9872be63423ada6a18481eaad2888e731fdac",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,49 @@\n   private CSAssignment allocateOrReserveNewContainers(\n       PlacementSet\u003cFiCaSchedulerNode\u003e ps, boolean withNodeHeartbeat) {\n-    CSAssignment assignment \u003d root.assignContainers(getClusterResource(), ps,\n-        new ResourceLimits(labelManager\n+    CSAssignment assignment \u003d getRootQueue().assignContainers(\n+        getClusterResource(), ps, new ResourceLimits(labelManager\n             .getResourceByLabel(ps.getPartition(), getClusterResource())),\n         SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n \n     assignment.setSchedulingMode(SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n     submitResourceCommitRequest(getClusterResource(), assignment);\n \n     if (Resources.greaterThan(calculator, getClusterResource(),\n         assignment.getResource(), Resources.none())) {\n       if (withNodeHeartbeat) {\n         updateSchedulerHealth(lastNodeUpdateTime,\n             PlacementSetUtils.getSingleNode(ps).getNodeID(), assignment);\n       }\n       return assignment;\n     }\n \n     // Only do non-exclusive allocation when node has node-labels.\n     if (StringUtils.equals(ps.getPartition(), RMNodeLabelsManager.NO_LABEL)) {\n       return null;\n     }\n \n     // Only do non-exclusive allocation when the node-label supports that\n     try {\n       if (rmContext.getNodeLabelManager().isExclusiveNodeLabel(\n           ps.getPartition())) {\n         return null;\n       }\n     } catch (IOException e) {\n       LOG.warn(\"Exception when trying to get exclusivity of node label\u003d\" + ps\n           .getPartition(), e);\n       return null;\n     }\n \n     // Try to use NON_EXCLUSIVE\n-    assignment \u003d root.assignContainers(getClusterResource(), ps,\n+    assignment \u003d getRootQueue().assignContainers(getClusterResource(), ps,\n         // TODO, now we only consider limits for parent for non-labeled\n         // resources, should consider labeled resources as well.\n         new ResourceLimits(labelManager\n             .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                 getClusterResource())),\n         SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n     assignment.setSchedulingMode(SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n     submitResourceCommitRequest(getClusterResource(), assignment);\n \n     return assignment;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private CSAssignment allocateOrReserveNewContainers(\n      PlacementSet\u003cFiCaSchedulerNode\u003e ps, boolean withNodeHeartbeat) {\n    CSAssignment assignment \u003d getRootQueue().assignContainers(\n        getClusterResource(), ps, new ResourceLimits(labelManager\n            .getResourceByLabel(ps.getPartition(), getClusterResource())),\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n\n    assignment.setSchedulingMode(SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n\n    if (Resources.greaterThan(calculator, getClusterResource(),\n        assignment.getResource(), Resources.none())) {\n      if (withNodeHeartbeat) {\n        updateSchedulerHealth(lastNodeUpdateTime,\n            PlacementSetUtils.getSingleNode(ps).getNodeID(), assignment);\n      }\n      return assignment;\n    }\n\n    // Only do non-exclusive allocation when node has node-labels.\n    if (StringUtils.equals(ps.getPartition(), RMNodeLabelsManager.NO_LABEL)) {\n      return null;\n    }\n\n    // Only do non-exclusive allocation when the node-label supports that\n    try {\n      if (rmContext.getNodeLabelManager().isExclusiveNodeLabel(\n          ps.getPartition())) {\n        return null;\n      }\n    } catch (IOException e) {\n      LOG.warn(\"Exception when trying to get exclusivity of node label\u003d\" + ps\n          .getPartition(), e);\n      return null;\n    }\n\n    // Try to use NON_EXCLUSIVE\n    assignment \u003d getRootQueue().assignContainers(getClusterResource(), ps,\n        // TODO, now we only consider limits for parent for non-labeled\n        // resources, should consider labeled resources as well.\n        new ResourceLimits(labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                getClusterResource())),\n        SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n    assignment.setSchedulingMode(SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n\n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "07/11/16 10:14 AM",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "diff": "@@ -0,0 +1,49 @@\n+  private CSAssignment allocateOrReserveNewContainers(\n+      PlacementSet\u003cFiCaSchedulerNode\u003e ps, boolean withNodeHeartbeat) {\n+    CSAssignment assignment \u003d root.assignContainers(getClusterResource(), ps,\n+        new ResourceLimits(labelManager\n+            .getResourceByLabel(ps.getPartition(), getClusterResource())),\n+        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n+\n+    assignment.setSchedulingMode(SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n+    submitResourceCommitRequest(getClusterResource(), assignment);\n+\n+    if (Resources.greaterThan(calculator, getClusterResource(),\n+        assignment.getResource(), Resources.none())) {\n+      if (withNodeHeartbeat) {\n+        updateSchedulerHealth(lastNodeUpdateTime,\n+            PlacementSetUtils.getSingleNode(ps).getNodeID(), assignment);\n+      }\n+      return assignment;\n+    }\n+\n+    // Only do non-exclusive allocation when node has node-labels.\n+    if (StringUtils.equals(ps.getPartition(), RMNodeLabelsManager.NO_LABEL)) {\n+      return null;\n+    }\n+\n+    // Only do non-exclusive allocation when the node-label supports that\n+    try {\n+      if (rmContext.getNodeLabelManager().isExclusiveNodeLabel(\n+          ps.getPartition())) {\n+        return null;\n+      }\n+    } catch (IOException e) {\n+      LOG.warn(\"Exception when trying to get exclusivity of node label\u003d\" + ps\n+          .getPartition(), e);\n+      return null;\n+    }\n+\n+    // Try to use NON_EXCLUSIVE\n+    assignment \u003d root.assignContainers(getClusterResource(), ps,\n+        // TODO, now we only consider limits for parent for non-labeled\n+        // resources, should consider labeled resources as well.\n+        new ResourceLimits(labelManager\n+            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n+                getClusterResource())),\n+        SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n+    assignment.setSchedulingMode(SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n+    submitResourceCommitRequest(getClusterResource(), assignment);\n+\n+    return assignment;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private CSAssignment allocateOrReserveNewContainers(\n      PlacementSet\u003cFiCaSchedulerNode\u003e ps, boolean withNodeHeartbeat) {\n    CSAssignment assignment \u003d root.assignContainers(getClusterResource(), ps,\n        new ResourceLimits(labelManager\n            .getResourceByLabel(ps.getPartition(), getClusterResource())),\n        SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n\n    assignment.setSchedulingMode(SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n\n    if (Resources.greaterThan(calculator, getClusterResource(),\n        assignment.getResource(), Resources.none())) {\n      if (withNodeHeartbeat) {\n        updateSchedulerHealth(lastNodeUpdateTime,\n            PlacementSetUtils.getSingleNode(ps).getNodeID(), assignment);\n      }\n      return assignment;\n    }\n\n    // Only do non-exclusive allocation when node has node-labels.\n    if (StringUtils.equals(ps.getPartition(), RMNodeLabelsManager.NO_LABEL)) {\n      return null;\n    }\n\n    // Only do non-exclusive allocation when the node-label supports that\n    try {\n      if (rmContext.getNodeLabelManager().isExclusiveNodeLabel(\n          ps.getPartition())) {\n        return null;\n      }\n    } catch (IOException e) {\n      LOG.warn(\"Exception when trying to get exclusivity of node label\u003d\" + ps\n          .getPartition(), e);\n      return null;\n    }\n\n    // Try to use NON_EXCLUSIVE\n    assignment \u003d root.assignContainers(getClusterResource(), ps,\n        // TODO, now we only consider limits for parent for non-labeled\n        // resources, should consider labeled resources as well.\n        new ResourceLimits(labelManager\n            .getResourceByLabel(RMNodeLabelsManager.NO_LABEL,\n                getClusterResource())),\n        SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n    assignment.setSchedulingMode(SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY);\n    submitResourceCommitRequest(getClusterResource(), assignment);\n\n    return assignment;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}