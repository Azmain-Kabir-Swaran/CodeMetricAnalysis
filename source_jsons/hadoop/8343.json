{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSDirErasureCodingOp.java",
  "functionName": "setErasureCodingPolicyXAttr",
  "functionId": "setErasureCodingPolicyXAttr___fsn-FSNamesystem(modifiers-final)__srcIIP-INodesInPath(modifiers-final)__ecPolicy-ErasureCodingPolicy",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
  "functionStartLine": 158,
  "functionEndLine": 195,
  "numCommitsSeen": 54,
  "timeTaken": 7590,
  "changeHistory": [
    "33a38a534110de454662256545a7f4c075d328c8",
    "3085a604300ed76d06a0011bd5555e419897b6cd",
    "3749152b661d0359b3b941ab1d17177230f3b8dc",
    "e69231658dc4a79da936e6856017b5c4f6124ecb",
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
    "96d6b516b2468fce346490e0b95931d1759b3d33",
    "f62237bc2f02afe11ce185e13aa51a60b5960037",
    "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
    "98d340745be682fb251677bb4830aca76119868f"
  ],
  "changeHistoryShort": {
    "33a38a534110de454662256545a7f4c075d328c8": "Ybodychange",
    "3085a604300ed76d06a0011bd5555e419897b6cd": "Ymodifierchange",
    "3749152b661d0359b3b941ab1d17177230f3b8dc": "Ybodychange",
    "e69231658dc4a79da936e6856017b5c4f6124ecb": "Ymultichange(Yrename,Ybodychange)",
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65": "Ybodychange",
    "96d6b516b2468fce346490e0b95931d1759b3d33": "Ybodychange",
    "f62237bc2f02afe11ce185e13aa51a60b5960037": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange,Yparametermetachange)",
    "1d37a8812160bb030244a1e6b1c753f962d8d2ed": "Ymultichange(Yparameterchange,Ybodychange)",
    "98d340745be682fb251677bb4830aca76119868f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "33a38a534110de454662256545a7f4c075d328c8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11314. Enforce set of enabled EC policies on the NameNode.\n",
      "commitDate": "08/03/17 4:41 PM",
      "commitName": "33a38a534110de454662256545a7f4c075d328c8",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "03/03/17 1:00 PM",
      "commitNameOld": "3085a604300ed76d06a0011bd5555e419897b6cd",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 5.15,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,38 @@\n   private static List\u003cXAttr\u003e setErasureCodingPolicyXAttr(final FSNamesystem fsn,\n       final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     assert fsd.hasWriteLock();\n     Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n     Preconditions.checkNotNull(ecPolicy, \"EC policy cannot be null\");\n     String src \u003d srcIIP.getPath();\n     final INode inode \u003d srcIIP.getLastINode();\n     if (inode \u003d\u003d null) {\n       throw new FileNotFoundException(\"Path not found: \" + srcIIP.getPath());\n     }\n     if (!inode.isDirectory()) {\n       throw new IOException(\"Attempt to set an erasure coding policy \" +\n           \"for a file \" + src);\n     }\n \n-    // Check that the EC policy is one of the active policies.\n-    boolean validPolicy \u003d false;\n-    ErasureCodingPolicy[] activePolicies \u003d\n-        FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n-    for (ErasureCodingPolicy activePolicy : activePolicies) {\n-      if (activePolicy.equals(ecPolicy)) {\n-        validPolicy \u003d true;\n-        break;\n-      }\n-    }\n-    if (!validPolicy) {\n-      List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n-      for (ErasureCodingPolicy activePolicy : activePolicies) {\n-        ecPolicyNames.add(activePolicy.getName());\n-      }\n-      throw new HadoopIllegalArgumentException(\"Policy [ \" +\n-          ecPolicy.getName() + \" ] does not match any of the \" +\n-          \"supported policies. Please select any one of \" + ecPolicyNames);\n-    }\n-\n     final XAttr ecXAttr;\n     DataOutputStream dOut \u003d null;\n     try {\n       ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n       dOut \u003d new DataOutputStream(bOut);\n       WritableUtils.writeString(dOut, ecPolicy.getName());\n       ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n           bOut.toByteArray());\n     } finally {\n       IOUtils.closeStream(dOut);\n     }\n     // check whether the directory already has an erasure coding policy\n     // directly on itself.\n     final Boolean hasEcXAttr \u003d\n         getErasureCodingPolicyXAttrForINode(fsn, inode) \u003d\u003d null ? false : true;\n     final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n     xattrs.add(ecXAttr);\n     final EnumSet\u003cXAttrSetFlag\u003e flag \u003d hasEcXAttr ?\n         EnumSet.of(XAttrSetFlag.REPLACE) : EnumSet.of(XAttrSetFlag.CREATE);\n     FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs, flag);\n     return xattrs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static List\u003cXAttr\u003e setErasureCodingPolicyXAttr(final FSNamesystem fsn,\n      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    assert fsd.hasWriteLock();\n    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n    Preconditions.checkNotNull(ecPolicy, \"EC policy cannot be null\");\n    String src \u003d srcIIP.getPath();\n    final INode inode \u003d srcIIP.getLastINode();\n    if (inode \u003d\u003d null) {\n      throw new FileNotFoundException(\"Path not found: \" + srcIIP.getPath());\n    }\n    if (!inode.isDirectory()) {\n      throw new IOException(\"Attempt to set an erasure coding policy \" +\n          \"for a file \" + src);\n    }\n\n    final XAttr ecXAttr;\n    DataOutputStream dOut \u003d null;\n    try {\n      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n      dOut \u003d new DataOutputStream(bOut);\n      WritableUtils.writeString(dOut, ecPolicy.getName());\n      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n          bOut.toByteArray());\n    } finally {\n      IOUtils.closeStream(dOut);\n    }\n    // check whether the directory already has an erasure coding policy\n    // directly on itself.\n    final Boolean hasEcXAttr \u003d\n        getErasureCodingPolicyXAttrForINode(fsn, inode) \u003d\u003d null ? false : true;\n    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n    xattrs.add(ecXAttr);\n    final EnumSet\u003cXAttrSetFlag\u003e flag \u003d hasEcXAttr ?\n        EnumSet.of(XAttrSetFlag.REPLACE) : EnumSet.of(XAttrSetFlag.CREATE);\n    FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs, flag);\n    return xattrs;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
      "extendedDetails": {}
    },
    "3085a604300ed76d06a0011bd5555e419897b6cd": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-8112. Relax permission checking for EC related operations.\n",
      "commitDate": "03/03/17 1:00 PM",
      "commitName": "3085a604300ed76d06a0011bd5555e419897b6cd",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "02/03/17 7:58 PM",
      "commitNameOld": "3749152b661d0359b3b941ab1d17177230f3b8dc",
      "commitAuthorOld": "Rakesh Radhakrishnan",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n-  static List\u003cXAttr\u003e setErasureCodingPolicyXAttr(final FSNamesystem fsn,\n+  private static List\u003cXAttr\u003e setErasureCodingPolicyXAttr(final FSNamesystem fsn,\n       final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     assert fsd.hasWriteLock();\n     Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n     Preconditions.checkNotNull(ecPolicy, \"EC policy cannot be null\");\n     String src \u003d srcIIP.getPath();\n     final INode inode \u003d srcIIP.getLastINode();\n     if (inode \u003d\u003d null) {\n       throw new FileNotFoundException(\"Path not found: \" + srcIIP.getPath());\n     }\n     if (!inode.isDirectory()) {\n       throw new IOException(\"Attempt to set an erasure coding policy \" +\n           \"for a file \" + src);\n     }\n \n     // Check that the EC policy is one of the active policies.\n     boolean validPolicy \u003d false;\n     ErasureCodingPolicy[] activePolicies \u003d\n         FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n     for (ErasureCodingPolicy activePolicy : activePolicies) {\n       if (activePolicy.equals(ecPolicy)) {\n         validPolicy \u003d true;\n         break;\n       }\n     }\n     if (!validPolicy) {\n       List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n       for (ErasureCodingPolicy activePolicy : activePolicies) {\n         ecPolicyNames.add(activePolicy.getName());\n       }\n       throw new HadoopIllegalArgumentException(\"Policy [ \" +\n           ecPolicy.getName() + \" ] does not match any of the \" +\n           \"supported policies. Please select any one of \" + ecPolicyNames);\n     }\n \n     final XAttr ecXAttr;\n     DataOutputStream dOut \u003d null;\n     try {\n       ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n       dOut \u003d new DataOutputStream(bOut);\n       WritableUtils.writeString(dOut, ecPolicy.getName());\n       ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n           bOut.toByteArray());\n     } finally {\n       IOUtils.closeStream(dOut);\n     }\n     // check whether the directory already has an erasure coding policy\n     // directly on itself.\n     final Boolean hasEcXAttr \u003d\n         getErasureCodingPolicyXAttrForINode(fsn, inode) \u003d\u003d null ? false : true;\n     final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n     xattrs.add(ecXAttr);\n     final EnumSet\u003cXAttrSetFlag\u003e flag \u003d hasEcXAttr ?\n         EnumSet.of(XAttrSetFlag.REPLACE) : EnumSet.of(XAttrSetFlag.CREATE);\n     FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs, flag);\n     return xattrs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static List\u003cXAttr\u003e setErasureCodingPolicyXAttr(final FSNamesystem fsn,\n      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    assert fsd.hasWriteLock();\n    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n    Preconditions.checkNotNull(ecPolicy, \"EC policy cannot be null\");\n    String src \u003d srcIIP.getPath();\n    final INode inode \u003d srcIIP.getLastINode();\n    if (inode \u003d\u003d null) {\n      throw new FileNotFoundException(\"Path not found: \" + srcIIP.getPath());\n    }\n    if (!inode.isDirectory()) {\n      throw new IOException(\"Attempt to set an erasure coding policy \" +\n          \"for a file \" + src);\n    }\n\n    // Check that the EC policy is one of the active policies.\n    boolean validPolicy \u003d false;\n    ErasureCodingPolicy[] activePolicies \u003d\n        FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n    for (ErasureCodingPolicy activePolicy : activePolicies) {\n      if (activePolicy.equals(ecPolicy)) {\n        validPolicy \u003d true;\n        break;\n      }\n    }\n    if (!validPolicy) {\n      List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n      for (ErasureCodingPolicy activePolicy : activePolicies) {\n        ecPolicyNames.add(activePolicy.getName());\n      }\n      throw new HadoopIllegalArgumentException(\"Policy [ \" +\n          ecPolicy.getName() + \" ] does not match any of the \" +\n          \"supported policies. Please select any one of \" + ecPolicyNames);\n    }\n\n    final XAttr ecXAttr;\n    DataOutputStream dOut \u003d null;\n    try {\n      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n      dOut \u003d new DataOutputStream(bOut);\n      WritableUtils.writeString(dOut, ecPolicy.getName());\n      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n          bOut.toByteArray());\n    } finally {\n      IOUtils.closeStream(dOut);\n    }\n    // check whether the directory already has an erasure coding policy\n    // directly on itself.\n    final Boolean hasEcXAttr \u003d\n        getErasureCodingPolicyXAttrForINode(fsn, inode) \u003d\u003d null ? false : true;\n    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n    xattrs.add(ecXAttr);\n    final EnumSet\u003cXAttrSetFlag\u003e flag \u003d hasEcXAttr ?\n        EnumSet.of(XAttrSetFlag.REPLACE) : EnumSet.of(XAttrSetFlag.CREATE);\n    FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs, flag);\n    return xattrs;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
      "extendedDetails": {
        "oldValue": "[static]",
        "newValue": "[private, static]"
      }
    },
    "3749152b661d0359b3b941ab1d17177230f3b8dc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11416. Refactor out system default erasure coding policy. Contributed by Andrew Wang.\n",
      "commitDate": "02/03/17 7:58 PM",
      "commitName": "3749152b661d0359b3b941ab1d17177230f3b8dc",
      "commitAuthor": "Rakesh Radhakrishnan",
      "commitDateOld": "01/03/17 2:36 AM",
      "commitNameOld": "82ef9accafe7318278efb169678e17065e082c8e",
      "commitAuthorOld": "Rakesh Radhakrishnan",
      "daysBetweenCommits": 1.72,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,58 @@\n   static List\u003cXAttr\u003e setErasureCodingPolicyXAttr(final FSNamesystem fsn,\n       final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     assert fsd.hasWriteLock();\n     Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n+    Preconditions.checkNotNull(ecPolicy, \"EC policy cannot be null\");\n     String src \u003d srcIIP.getPath();\n     final INode inode \u003d srcIIP.getLastINode();\n     if (inode \u003d\u003d null) {\n       throw new FileNotFoundException(\"Path not found: \" + srcIIP.getPath());\n     }\n     if (!inode.isDirectory()) {\n       throw new IOException(\"Attempt to set an erasure coding policy \" +\n           \"for a file \" + src);\n     }\n \n-    // System default erasure coding policy will be used since no specified.\n-    if (ecPolicy \u003d\u003d null) {\n-      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n-    } else {\n-      // If ecPolicy is specified check if it is one among active policies.\n-      boolean validPolicy \u003d false;\n-      ErasureCodingPolicy[] activePolicies \u003d\n-          FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n+    // Check that the EC policy is one of the active policies.\n+    boolean validPolicy \u003d false;\n+    ErasureCodingPolicy[] activePolicies \u003d\n+        FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n+    for (ErasureCodingPolicy activePolicy : activePolicies) {\n+      if (activePolicy.equals(ecPolicy)) {\n+        validPolicy \u003d true;\n+        break;\n+      }\n+    }\n+    if (!validPolicy) {\n+      List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n       for (ErasureCodingPolicy activePolicy : activePolicies) {\n-        if (activePolicy.equals(ecPolicy)) {\n-          validPolicy \u003d true;\n-          break;\n-        }\n+        ecPolicyNames.add(activePolicy.getName());\n       }\n-      if (!validPolicy) {\n-        List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n-        for (ErasureCodingPolicy activePolicy : activePolicies) {\n-          ecPolicyNames.add(activePolicy.getName());\n-        }\n-        throw new HadoopIllegalArgumentException(\"Policy [ \" +\n-            ecPolicy.getName() + \" ] does not match any of the \" +\n-            \"supported policies. Please select any one of \" + ecPolicyNames);\n-      }\n+      throw new HadoopIllegalArgumentException(\"Policy [ \" +\n+          ecPolicy.getName() + \" ] does not match any of the \" +\n+          \"supported policies. Please select any one of \" + ecPolicyNames);\n     }\n \n     final XAttr ecXAttr;\n     DataOutputStream dOut \u003d null;\n     try {\n       ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n       dOut \u003d new DataOutputStream(bOut);\n       WritableUtils.writeString(dOut, ecPolicy.getName());\n       ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n           bOut.toByteArray());\n     } finally {\n       IOUtils.closeStream(dOut);\n     }\n     // check whether the directory already has an erasure coding policy\n     // directly on itself.\n     final Boolean hasEcXAttr \u003d\n         getErasureCodingPolicyXAttrForINode(fsn, inode) \u003d\u003d null ? false : true;\n     final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n     xattrs.add(ecXAttr);\n     final EnumSet\u003cXAttrSetFlag\u003e flag \u003d hasEcXAttr ?\n         EnumSet.of(XAttrSetFlag.REPLACE) : EnumSet.of(XAttrSetFlag.CREATE);\n     FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs, flag);\n     return xattrs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static List\u003cXAttr\u003e setErasureCodingPolicyXAttr(final FSNamesystem fsn,\n      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    assert fsd.hasWriteLock();\n    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n    Preconditions.checkNotNull(ecPolicy, \"EC policy cannot be null\");\n    String src \u003d srcIIP.getPath();\n    final INode inode \u003d srcIIP.getLastINode();\n    if (inode \u003d\u003d null) {\n      throw new FileNotFoundException(\"Path not found: \" + srcIIP.getPath());\n    }\n    if (!inode.isDirectory()) {\n      throw new IOException(\"Attempt to set an erasure coding policy \" +\n          \"for a file \" + src);\n    }\n\n    // Check that the EC policy is one of the active policies.\n    boolean validPolicy \u003d false;\n    ErasureCodingPolicy[] activePolicies \u003d\n        FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n    for (ErasureCodingPolicy activePolicy : activePolicies) {\n      if (activePolicy.equals(ecPolicy)) {\n        validPolicy \u003d true;\n        break;\n      }\n    }\n    if (!validPolicy) {\n      List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n      for (ErasureCodingPolicy activePolicy : activePolicies) {\n        ecPolicyNames.add(activePolicy.getName());\n      }\n      throw new HadoopIllegalArgumentException(\"Policy [ \" +\n          ecPolicy.getName() + \" ] does not match any of the \" +\n          \"supported policies. Please select any one of \" + ecPolicyNames);\n    }\n\n    final XAttr ecXAttr;\n    DataOutputStream dOut \u003d null;\n    try {\n      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n      dOut \u003d new DataOutputStream(bOut);\n      WritableUtils.writeString(dOut, ecPolicy.getName());\n      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n          bOut.toByteArray());\n    } finally {\n      IOUtils.closeStream(dOut);\n    }\n    // check whether the directory already has an erasure coding policy\n    // directly on itself.\n    final Boolean hasEcXAttr \u003d\n        getErasureCodingPolicyXAttrForINode(fsn, inode) \u003d\u003d null ? false : true;\n    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n    xattrs.add(ecXAttr);\n    final EnumSet\u003cXAttrSetFlag\u003e flag \u003d hasEcXAttr ?\n        EnumSet.of(XAttrSetFlag.REPLACE) : EnumSet.of(XAttrSetFlag.CREATE);\n    FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs, flag);\n    return xattrs;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
      "extendedDetails": {}
    },
    "e69231658dc4a79da936e6856017b5c4f6124ecb": {
      "type": "Ymultichange(Yrename,Ybodychange)",
      "commitMessage": "HDFS-11072. Add ability to unset and change directory EC policy. Contributed by Sammi Chen.\n",
      "commitDate": "10/01/17 11:32 AM",
      "commitName": "e69231658dc4a79da936e6856017b5c4f6124ecb",
      "commitAuthor": "Andrew Wang",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-11072. Add ability to unset and change directory EC policy. Contributed by Sammi Chen.\n",
          "commitDate": "10/01/17 11:32 AM",
          "commitName": "e69231658dc4a79da936e6856017b5c4f6124ecb",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "24/10/16 3:14 PM",
          "commitNameOld": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 77.89,
          "commitsBetweenForRepo": 530,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,62 @@\n-  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n+  static List\u003cXAttr\u003e setErasureCodingPolicyXAttr(final FSNamesystem fsn,\n       final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     assert fsd.hasWriteLock();\n     Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n     String src \u003d srcIIP.getPath();\n-    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n-        !srcIIP.getLastINode().isDirectory()) {\n+    final INode inode \u003d srcIIP.getLastINode();\n+    if (inode \u003d\u003d null) {\n+      throw new FileNotFoundException(\"Path not found: \" + srcIIP.getPath());\n+    }\n+    if (!inode.isDirectory()) {\n       throw new IOException(\"Attempt to set an erasure coding policy \" +\n           \"for a file \" + src);\n     }\n-    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n-      throw new IOException(\"Directory \" + src + \" already has an \" +\n-          \"erasure coding policy.\");\n-    }\n \n     // System default erasure coding policy will be used since no specified.\n     if (ecPolicy \u003d\u003d null) {\n       ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n     } else {\n       // If ecPolicy is specified check if it is one among active policies.\n       boolean validPolicy \u003d false;\n       ErasureCodingPolicy[] activePolicies \u003d\n           FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n       for (ErasureCodingPolicy activePolicy : activePolicies) {\n         if (activePolicy.equals(ecPolicy)) {\n           validPolicy \u003d true;\n           break;\n         }\n       }\n       if (!validPolicy) {\n         List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n         for (ErasureCodingPolicy activePolicy : activePolicies) {\n           ecPolicyNames.add(activePolicy.getName());\n         }\n         throw new HadoopIllegalArgumentException(\"Policy [ \" +\n-            ecPolicy.getName()+ \" ] does not match any of the \" +\n+            ecPolicy.getName() + \" ] does not match any of the \" +\n             \"supported policies. Please select any one of \" + ecPolicyNames);\n       }\n     }\n \n     final XAttr ecXAttr;\n     DataOutputStream dOut \u003d null;\n     try {\n       ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n       dOut \u003d new DataOutputStream(bOut);\n       WritableUtils.writeString(dOut, ecPolicy.getName());\n       ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n           bOut.toByteArray());\n     } finally {\n       IOUtils.closeStream(dOut);\n     }\n+    // check whether the directory already has an erasure coding policy\n+    // directly on itself.\n+    final Boolean hasEcXAttr \u003d\n+        getErasureCodingPolicyXAttrForINode(fsn, inode) \u003d\u003d null ? false : true;\n     final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n     xattrs.add(ecXAttr);\n-    FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs,\n-        EnumSet.of(XAttrSetFlag.CREATE));\n+    final EnumSet\u003cXAttrSetFlag\u003e flag \u003d hasEcXAttr ?\n+        EnumSet.of(XAttrSetFlag.REPLACE) : EnumSet.of(XAttrSetFlag.CREATE);\n+    FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs, flag);\n     return xattrs;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static List\u003cXAttr\u003e setErasureCodingPolicyXAttr(final FSNamesystem fsn,\n      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    assert fsd.hasWriteLock();\n    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n    String src \u003d srcIIP.getPath();\n    final INode inode \u003d srcIIP.getLastINode();\n    if (inode \u003d\u003d null) {\n      throw new FileNotFoundException(\"Path not found: \" + srcIIP.getPath());\n    }\n    if (!inode.isDirectory()) {\n      throw new IOException(\"Attempt to set an erasure coding policy \" +\n          \"for a file \" + src);\n    }\n\n    // System default erasure coding policy will be used since no specified.\n    if (ecPolicy \u003d\u003d null) {\n      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n    } else {\n      // If ecPolicy is specified check if it is one among active policies.\n      boolean validPolicy \u003d false;\n      ErasureCodingPolicy[] activePolicies \u003d\n          FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n      for (ErasureCodingPolicy activePolicy : activePolicies) {\n        if (activePolicy.equals(ecPolicy)) {\n          validPolicy \u003d true;\n          break;\n        }\n      }\n      if (!validPolicy) {\n        List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n        for (ErasureCodingPolicy activePolicy : activePolicies) {\n          ecPolicyNames.add(activePolicy.getName());\n        }\n        throw new HadoopIllegalArgumentException(\"Policy [ \" +\n            ecPolicy.getName() + \" ] does not match any of the \" +\n            \"supported policies. Please select any one of \" + ecPolicyNames);\n      }\n    }\n\n    final XAttr ecXAttr;\n    DataOutputStream dOut \u003d null;\n    try {\n      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n      dOut \u003d new DataOutputStream(bOut);\n      WritableUtils.writeString(dOut, ecPolicy.getName());\n      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n          bOut.toByteArray());\n    } finally {\n      IOUtils.closeStream(dOut);\n    }\n    // check whether the directory already has an erasure coding policy\n    // directly on itself.\n    final Boolean hasEcXAttr \u003d\n        getErasureCodingPolicyXAttrForINode(fsn, inode) \u003d\u003d null ? false : true;\n    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n    xattrs.add(ecXAttr);\n    final EnumSet\u003cXAttrSetFlag\u003e flag \u003d hasEcXAttr ?\n        EnumSet.of(XAttrSetFlag.REPLACE) : EnumSet.of(XAttrSetFlag.CREATE);\n    FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs, flag);\n    return xattrs;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
          "extendedDetails": {
            "oldValue": "createErasureCodingPolicyXAttr",
            "newValue": "setErasureCodingPolicyXAttr"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-11072. Add ability to unset and change directory EC policy. Contributed by Sammi Chen.\n",
          "commitDate": "10/01/17 11:32 AM",
          "commitName": "e69231658dc4a79da936e6856017b5c4f6124ecb",
          "commitAuthor": "Andrew Wang",
          "commitDateOld": "24/10/16 3:14 PM",
          "commitNameOld": "9d175853b0170683ad5f21d9bcdeaac49fe89e04",
          "commitAuthorOld": "Kihwal Lee",
          "daysBetweenCommits": 77.89,
          "commitsBetweenForRepo": 530,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,58 +1,62 @@\n-  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n+  static List\u003cXAttr\u003e setErasureCodingPolicyXAttr(final FSNamesystem fsn,\n       final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     assert fsd.hasWriteLock();\n     Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n     String src \u003d srcIIP.getPath();\n-    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n-        !srcIIP.getLastINode().isDirectory()) {\n+    final INode inode \u003d srcIIP.getLastINode();\n+    if (inode \u003d\u003d null) {\n+      throw new FileNotFoundException(\"Path not found: \" + srcIIP.getPath());\n+    }\n+    if (!inode.isDirectory()) {\n       throw new IOException(\"Attempt to set an erasure coding policy \" +\n           \"for a file \" + src);\n     }\n-    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n-      throw new IOException(\"Directory \" + src + \" already has an \" +\n-          \"erasure coding policy.\");\n-    }\n \n     // System default erasure coding policy will be used since no specified.\n     if (ecPolicy \u003d\u003d null) {\n       ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n     } else {\n       // If ecPolicy is specified check if it is one among active policies.\n       boolean validPolicy \u003d false;\n       ErasureCodingPolicy[] activePolicies \u003d\n           FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n       for (ErasureCodingPolicy activePolicy : activePolicies) {\n         if (activePolicy.equals(ecPolicy)) {\n           validPolicy \u003d true;\n           break;\n         }\n       }\n       if (!validPolicy) {\n         List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n         for (ErasureCodingPolicy activePolicy : activePolicies) {\n           ecPolicyNames.add(activePolicy.getName());\n         }\n         throw new HadoopIllegalArgumentException(\"Policy [ \" +\n-            ecPolicy.getName()+ \" ] does not match any of the \" +\n+            ecPolicy.getName() + \" ] does not match any of the \" +\n             \"supported policies. Please select any one of \" + ecPolicyNames);\n       }\n     }\n \n     final XAttr ecXAttr;\n     DataOutputStream dOut \u003d null;\n     try {\n       ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n       dOut \u003d new DataOutputStream(bOut);\n       WritableUtils.writeString(dOut, ecPolicy.getName());\n       ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n           bOut.toByteArray());\n     } finally {\n       IOUtils.closeStream(dOut);\n     }\n+    // check whether the directory already has an erasure coding policy\n+    // directly on itself.\n+    final Boolean hasEcXAttr \u003d\n+        getErasureCodingPolicyXAttrForINode(fsn, inode) \u003d\u003d null ? false : true;\n     final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n     xattrs.add(ecXAttr);\n-    FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs,\n-        EnumSet.of(XAttrSetFlag.CREATE));\n+    final EnumSet\u003cXAttrSetFlag\u003e flag \u003d hasEcXAttr ?\n+        EnumSet.of(XAttrSetFlag.REPLACE) : EnumSet.of(XAttrSetFlag.CREATE);\n+    FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs, flag);\n     return xattrs;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static List\u003cXAttr\u003e setErasureCodingPolicyXAttr(final FSNamesystem fsn,\n      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    assert fsd.hasWriteLock();\n    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n    String src \u003d srcIIP.getPath();\n    final INode inode \u003d srcIIP.getLastINode();\n    if (inode \u003d\u003d null) {\n      throw new FileNotFoundException(\"Path not found: \" + srcIIP.getPath());\n    }\n    if (!inode.isDirectory()) {\n      throw new IOException(\"Attempt to set an erasure coding policy \" +\n          \"for a file \" + src);\n    }\n\n    // System default erasure coding policy will be used since no specified.\n    if (ecPolicy \u003d\u003d null) {\n      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n    } else {\n      // If ecPolicy is specified check if it is one among active policies.\n      boolean validPolicy \u003d false;\n      ErasureCodingPolicy[] activePolicies \u003d\n          FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n      for (ErasureCodingPolicy activePolicy : activePolicies) {\n        if (activePolicy.equals(ecPolicy)) {\n          validPolicy \u003d true;\n          break;\n        }\n      }\n      if (!validPolicy) {\n        List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n        for (ErasureCodingPolicy activePolicy : activePolicies) {\n          ecPolicyNames.add(activePolicy.getName());\n        }\n        throw new HadoopIllegalArgumentException(\"Policy [ \" +\n            ecPolicy.getName() + \" ] does not match any of the \" +\n            \"supported policies. Please select any one of \" + ecPolicyNames);\n      }\n    }\n\n    final XAttr ecXAttr;\n    DataOutputStream dOut \u003d null;\n    try {\n      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n      dOut \u003d new DataOutputStream(bOut);\n      WritableUtils.writeString(dOut, ecPolicy.getName());\n      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n          bOut.toByteArray());\n    } finally {\n      IOUtils.closeStream(dOut);\n    }\n    // check whether the directory already has an erasure coding policy\n    // directly on itself.\n    final Boolean hasEcXAttr \u003d\n        getErasureCodingPolicyXAttrForINode(fsn, inode) \u003d\u003d null ? false : true;\n    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n    xattrs.add(ecXAttr);\n    final EnumSet\u003cXAttrSetFlag\u003e flag \u003d hasEcXAttr ?\n        EnumSet.of(XAttrSetFlag.REPLACE) : EnumSet.of(XAttrSetFlag.CREATE);\n    FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs, flag);\n    return xattrs;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "f32e9fc8f7150f0e889c0774b3ad712af26fbd65": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10939. Reduce performance penalty of encryption zones. Contributed by Daryn sharp.\n",
      "commitDate": "06/10/16 1:11 PM",
      "commitName": "f32e9fc8f7150f0e889c0774b3ad712af26fbd65",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "17/08/16 1:53 PM",
      "commitNameOld": "869393643de23dcb010cc33091c8eb398de0fd6c",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 49.97,
      "commitsBetweenForRepo": 305,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n   static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n       final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     assert fsd.hasWriteLock();\n     Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n     String src \u003d srcIIP.getPath();\n     if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n         !srcIIP.getLastINode().isDirectory()) {\n       throw new IOException(\"Attempt to set an erasure coding policy \" +\n           \"for a file \" + src);\n     }\n     if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n       throw new IOException(\"Directory \" + src + \" already has an \" +\n           \"erasure coding policy.\");\n     }\n \n     // System default erasure coding policy will be used since no specified.\n     if (ecPolicy \u003d\u003d null) {\n       ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n     } else {\n       // If ecPolicy is specified check if it is one among active policies.\n       boolean validPolicy \u003d false;\n       ErasureCodingPolicy[] activePolicies \u003d\n           FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n       for (ErasureCodingPolicy activePolicy : activePolicies) {\n         if (activePolicy.equals(ecPolicy)) {\n           validPolicy \u003d true;\n           break;\n         }\n       }\n       if (!validPolicy) {\n         List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n         for (ErasureCodingPolicy activePolicy : activePolicies) {\n           ecPolicyNames.add(activePolicy.getName());\n         }\n         throw new HadoopIllegalArgumentException(\"Policy [ \" +\n             ecPolicy.getName()+ \" ] does not match any of the \" +\n             \"supported policies. Please select any one of \" + ecPolicyNames);\n       }\n     }\n \n     final XAttr ecXAttr;\n     DataOutputStream dOut \u003d null;\n     try {\n       ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n       dOut \u003d new DataOutputStream(bOut);\n       WritableUtils.writeString(dOut, ecPolicy.getName());\n       ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n           bOut.toByteArray());\n     } finally {\n       IOUtils.closeStream(dOut);\n     }\n     final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n     xattrs.add(ecXAttr);\n-    FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n+    FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs,\n         EnumSet.of(XAttrSetFlag.CREATE));\n     return xattrs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    assert fsd.hasWriteLock();\n    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n    String src \u003d srcIIP.getPath();\n    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n        !srcIIP.getLastINode().isDirectory()) {\n      throw new IOException(\"Attempt to set an erasure coding policy \" +\n          \"for a file \" + src);\n    }\n    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n      throw new IOException(\"Directory \" + src + \" already has an \" +\n          \"erasure coding policy.\");\n    }\n\n    // System default erasure coding policy will be used since no specified.\n    if (ecPolicy \u003d\u003d null) {\n      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n    } else {\n      // If ecPolicy is specified check if it is one among active policies.\n      boolean validPolicy \u003d false;\n      ErasureCodingPolicy[] activePolicies \u003d\n          FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n      for (ErasureCodingPolicy activePolicy : activePolicies) {\n        if (activePolicy.equals(ecPolicy)) {\n          validPolicy \u003d true;\n          break;\n        }\n      }\n      if (!validPolicy) {\n        List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n        for (ErasureCodingPolicy activePolicy : activePolicies) {\n          ecPolicyNames.add(activePolicy.getName());\n        }\n        throw new HadoopIllegalArgumentException(\"Policy [ \" +\n            ecPolicy.getName()+ \" ] does not match any of the \" +\n            \"supported policies. Please select any one of \" + ecPolicyNames);\n      }\n    }\n\n    final XAttr ecXAttr;\n    DataOutputStream dOut \u003d null;\n    try {\n      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n      dOut \u003d new DataOutputStream(bOut);\n      WritableUtils.writeString(dOut, ecPolicy.getName());\n      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n          bOut.toByteArray());\n    } finally {\n      IOUtils.closeStream(dOut);\n    }\n    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n    xattrs.add(ecXAttr);\n    FSDirXAttrOp.unprotectedSetXAttrs(fsd, srcIIP, xattrs,\n        EnumSet.of(XAttrSetFlag.CREATE));\n    return xattrs;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
      "extendedDetails": {}
    },
    "96d6b516b2468fce346490e0b95931d1759b3d33": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8853. Erasure Coding: Provide ECSchema validation when setting EC policy. Contributed by J.Andreina.\n\nChange-Id: I9211d9728480225a407d82e6c0bea1a928adfa11\n",
      "commitDate": "10/09/15 4:31 PM",
      "commitName": "96d6b516b2468fce346490e0b95931d1759b3d33",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "09/09/15 11:07 PM",
      "commitNameOld": "f62237bc2f02afe11ce185e13aa51a60b5960037",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.72,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,58 @@\n   static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n       final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     assert fsd.hasWriteLock();\n     Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n     String src \u003d srcIIP.getPath();\n     if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n         !srcIIP.getLastINode().isDirectory()) {\n       throw new IOException(\"Attempt to set an erasure coding policy \" +\n           \"for a file \" + src);\n     }\n     if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n       throw new IOException(\"Directory \" + src + \" already has an \" +\n           \"erasure coding policy.\");\n     }\n \n     // System default erasure coding policy will be used since no specified.\n     if (ecPolicy \u003d\u003d null) {\n       ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n+    } else {\n+      // If ecPolicy is specified check if it is one among active policies.\n+      boolean validPolicy \u003d false;\n+      ErasureCodingPolicy[] activePolicies \u003d\n+          FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n+      for (ErasureCodingPolicy activePolicy : activePolicies) {\n+        if (activePolicy.equals(ecPolicy)) {\n+          validPolicy \u003d true;\n+          break;\n+        }\n+      }\n+      if (!validPolicy) {\n+        List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n+        for (ErasureCodingPolicy activePolicy : activePolicies) {\n+          ecPolicyNames.add(activePolicy.getName());\n+        }\n+        throw new HadoopIllegalArgumentException(\"Policy [ \" +\n+            ecPolicy.getName()+ \" ] does not match any of the \" +\n+            \"supported policies. Please select any one of \" + ecPolicyNames);\n+      }\n     }\n \n     final XAttr ecXAttr;\n     DataOutputStream dOut \u003d null;\n     try {\n       ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n       dOut \u003d new DataOutputStream(bOut);\n       WritableUtils.writeString(dOut, ecPolicy.getName());\n       ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n           bOut.toByteArray());\n     } finally {\n       IOUtils.closeStream(dOut);\n     }\n     final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n     xattrs.add(ecXAttr);\n     FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n         EnumSet.of(XAttrSetFlag.CREATE));\n     return xattrs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    assert fsd.hasWriteLock();\n    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n    String src \u003d srcIIP.getPath();\n    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n        !srcIIP.getLastINode().isDirectory()) {\n      throw new IOException(\"Attempt to set an erasure coding policy \" +\n          \"for a file \" + src);\n    }\n    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n      throw new IOException(\"Directory \" + src + \" already has an \" +\n          \"erasure coding policy.\");\n    }\n\n    // System default erasure coding policy will be used since no specified.\n    if (ecPolicy \u003d\u003d null) {\n      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n    } else {\n      // If ecPolicy is specified check if it is one among active policies.\n      boolean validPolicy \u003d false;\n      ErasureCodingPolicy[] activePolicies \u003d\n          FSDirErasureCodingOp.getErasureCodingPolicies(fsd.getFSNamesystem());\n      for (ErasureCodingPolicy activePolicy : activePolicies) {\n        if (activePolicy.equals(ecPolicy)) {\n          validPolicy \u003d true;\n          break;\n        }\n      }\n      if (!validPolicy) {\n        List\u003cString\u003e ecPolicyNames \u003d new ArrayList\u003cString\u003e();\n        for (ErasureCodingPolicy activePolicy : activePolicies) {\n          ecPolicyNames.add(activePolicy.getName());\n        }\n        throw new HadoopIllegalArgumentException(\"Policy [ \" +\n            ecPolicy.getName()+ \" ] does not match any of the \" +\n            \"supported policies. Please select any one of \" + ecPolicyNames);\n      }\n    }\n\n    final XAttr ecXAttr;\n    DataOutputStream dOut \u003d null;\n    try {\n      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n      dOut \u003d new DataOutputStream(bOut);\n      WritableUtils.writeString(dOut, ecPolicy.getName());\n      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n          bOut.toByteArray());\n    } finally {\n      IOUtils.closeStream(dOut);\n    }\n    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n    xattrs.add(ecXAttr);\n    FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n        EnumSet.of(XAttrSetFlag.CREATE));\n    return xattrs;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
      "extendedDetails": {}
    },
    "f62237bc2f02afe11ce185e13aa51a60b5960037": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange,Yparametermetachange)",
      "commitMessage": "HDFS-8833. Erasure coding: store EC schema and cell size in INodeFile and eliminate notion of EC zones.\n",
      "commitDate": "09/09/15 11:07 PM",
      "commitName": "f62237bc2f02afe11ce185e13aa51a60b5960037",
      "commitAuthor": "Zhe Zhang",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-8833. Erasure coding: store EC schema and cell size in INodeFile and eliminate notion of EC zones.\n",
          "commitDate": "09/09/15 11:07 PM",
          "commitName": "f62237bc2f02afe11ce185e13aa51a60b5960037",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "13/08/15 10:04 AM",
          "commitNameOld": "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
          "commitAuthorOld": "Zhe Zhang",
          "daysBetweenCommits": 27.54,
          "commitsBetweenForRepo": 115,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,38 @@\n-  static HdfsFileStatus createErasureCodingZone(final FSNamesystem fsn,\n-      final String srcArg, final ErasureCodingPolicy ecPolicy,\n-      final boolean logRetryCache) throws IOException {\n-    assert fsn.hasWriteLock();\n-\n-    String src \u003d srcArg;\n-    FSPermissionChecker pc \u003d null;\n-    byte[][] pathComponents \u003d null;\n-    pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n-    pc \u003d fsn.getPermissionChecker();\n+  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n+      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n-    src \u003d fsd.resolvePath(pc, src, pathComponents);\n-    final INodesInPath iip;\n-    List\u003cXAttr\u003e xAttrs;\n-    fsd.writeLock();\n-    try {\n-      iip \u003d fsd.getINodesInPath4Write(src, false);\n-      xAttrs \u003d fsn.getErasureCodingZoneManager().createErasureCodingZone(\n-          iip, ecPolicy);\n-    } finally {\n-      fsd.writeUnlock();\n+    assert fsd.hasWriteLock();\n+    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n+    String src \u003d srcIIP.getPath();\n+    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n+        !srcIIP.getLastINode().isDirectory()) {\n+      throw new IOException(\"Attempt to set an erasure coding policy \" +\n+          \"for a file \" + src);\n     }\n-    fsn.getEditLog().logSetXAttrs(src, xAttrs, logRetryCache);\n-    return fsd.getAuditFileInfo(iip);\n+    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n+      throw new IOException(\"Directory \" + src + \" already has an \" +\n+          \"erasure coding policy.\");\n+    }\n+\n+    // System default erasure coding policy will be used since no specified.\n+    if (ecPolicy \u003d\u003d null) {\n+      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n+    }\n+\n+    final XAttr ecXAttr;\n+    DataOutputStream dOut \u003d null;\n+    try {\n+      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n+      dOut \u003d new DataOutputStream(bOut);\n+      WritableUtils.writeString(dOut, ecPolicy.getName());\n+      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n+          bOut.toByteArray());\n+    } finally {\n+      IOUtils.closeStream(dOut);\n+    }\n+    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n+    xattrs.add(ecXAttr);\n+    FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n+        EnumSet.of(XAttrSetFlag.CREATE));\n+    return xattrs;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    assert fsd.hasWriteLock();\n    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n    String src \u003d srcIIP.getPath();\n    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n        !srcIIP.getLastINode().isDirectory()) {\n      throw new IOException(\"Attempt to set an erasure coding policy \" +\n          \"for a file \" + src);\n    }\n    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n      throw new IOException(\"Directory \" + src + \" already has an \" +\n          \"erasure coding policy.\");\n    }\n\n    // System default erasure coding policy will be used since no specified.\n    if (ecPolicy \u003d\u003d null) {\n      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n    }\n\n    final XAttr ecXAttr;\n    DataOutputStream dOut \u003d null;\n    try {\n      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n      dOut \u003d new DataOutputStream(bOut);\n      WritableUtils.writeString(dOut, ecPolicy.getName());\n      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n          bOut.toByteArray());\n    } finally {\n      IOUtils.closeStream(dOut);\n    }\n    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n    xattrs.add(ecXAttr);\n    FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n        EnumSet.of(XAttrSetFlag.CREATE));\n    return xattrs;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
          "extendedDetails": {
            "oldValue": "createErasureCodingZone",
            "newValue": "createErasureCodingPolicyXAttr"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8833. Erasure coding: store EC schema and cell size in INodeFile and eliminate notion of EC zones.\n",
          "commitDate": "09/09/15 11:07 PM",
          "commitName": "f62237bc2f02afe11ce185e13aa51a60b5960037",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "13/08/15 10:04 AM",
          "commitNameOld": "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
          "commitAuthorOld": "Zhe Zhang",
          "daysBetweenCommits": 27.54,
          "commitsBetweenForRepo": 115,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,38 @@\n-  static HdfsFileStatus createErasureCodingZone(final FSNamesystem fsn,\n-      final String srcArg, final ErasureCodingPolicy ecPolicy,\n-      final boolean logRetryCache) throws IOException {\n-    assert fsn.hasWriteLock();\n-\n-    String src \u003d srcArg;\n-    FSPermissionChecker pc \u003d null;\n-    byte[][] pathComponents \u003d null;\n-    pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n-    pc \u003d fsn.getPermissionChecker();\n+  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n+      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n-    src \u003d fsd.resolvePath(pc, src, pathComponents);\n-    final INodesInPath iip;\n-    List\u003cXAttr\u003e xAttrs;\n-    fsd.writeLock();\n-    try {\n-      iip \u003d fsd.getINodesInPath4Write(src, false);\n-      xAttrs \u003d fsn.getErasureCodingZoneManager().createErasureCodingZone(\n-          iip, ecPolicy);\n-    } finally {\n-      fsd.writeUnlock();\n+    assert fsd.hasWriteLock();\n+    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n+    String src \u003d srcIIP.getPath();\n+    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n+        !srcIIP.getLastINode().isDirectory()) {\n+      throw new IOException(\"Attempt to set an erasure coding policy \" +\n+          \"for a file \" + src);\n     }\n-    fsn.getEditLog().logSetXAttrs(src, xAttrs, logRetryCache);\n-    return fsd.getAuditFileInfo(iip);\n+    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n+      throw new IOException(\"Directory \" + src + \" already has an \" +\n+          \"erasure coding policy.\");\n+    }\n+\n+    // System default erasure coding policy will be used since no specified.\n+    if (ecPolicy \u003d\u003d null) {\n+      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n+    }\n+\n+    final XAttr ecXAttr;\n+    DataOutputStream dOut \u003d null;\n+    try {\n+      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n+      dOut \u003d new DataOutputStream(bOut);\n+      WritableUtils.writeString(dOut, ecPolicy.getName());\n+      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n+          bOut.toByteArray());\n+    } finally {\n+      IOUtils.closeStream(dOut);\n+    }\n+    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n+    xattrs.add(ecXAttr);\n+    FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n+        EnumSet.of(XAttrSetFlag.CREATE));\n+    return xattrs;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    assert fsd.hasWriteLock();\n    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n    String src \u003d srcIIP.getPath();\n    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n        !srcIIP.getLastINode().isDirectory()) {\n      throw new IOException(\"Attempt to set an erasure coding policy \" +\n          \"for a file \" + src);\n    }\n    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n      throw new IOException(\"Directory \" + src + \" already has an \" +\n          \"erasure coding policy.\");\n    }\n\n    // System default erasure coding policy will be used since no specified.\n    if (ecPolicy \u003d\u003d null) {\n      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n    }\n\n    final XAttr ecXAttr;\n    DataOutputStream dOut \u003d null;\n    try {\n      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n      dOut \u003d new DataOutputStream(bOut);\n      WritableUtils.writeString(dOut, ecPolicy.getName());\n      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n          bOut.toByteArray());\n    } finally {\n      IOUtils.closeStream(dOut);\n    }\n    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n    xattrs.add(ecXAttr);\n    FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n        EnumSet.of(XAttrSetFlag.CREATE));\n    return xattrs;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
          "extendedDetails": {
            "oldValue": "[fsn-FSNamesystem(modifiers-final), srcArg-String(modifiers-final), ecPolicy-ErasureCodingPolicy(modifiers-final), logRetryCache-boolean(modifiers-final)]",
            "newValue": "[fsn-FSNamesystem(modifiers-final), srcIIP-INodesInPath(modifiers-final), ecPolicy-ErasureCodingPolicy]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-8833. Erasure coding: store EC schema and cell size in INodeFile and eliminate notion of EC zones.\n",
          "commitDate": "09/09/15 11:07 PM",
          "commitName": "f62237bc2f02afe11ce185e13aa51a60b5960037",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "13/08/15 10:04 AM",
          "commitNameOld": "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
          "commitAuthorOld": "Zhe Zhang",
          "daysBetweenCommits": 27.54,
          "commitsBetweenForRepo": 115,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,38 @@\n-  static HdfsFileStatus createErasureCodingZone(final FSNamesystem fsn,\n-      final String srcArg, final ErasureCodingPolicy ecPolicy,\n-      final boolean logRetryCache) throws IOException {\n-    assert fsn.hasWriteLock();\n-\n-    String src \u003d srcArg;\n-    FSPermissionChecker pc \u003d null;\n-    byte[][] pathComponents \u003d null;\n-    pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n-    pc \u003d fsn.getPermissionChecker();\n+  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n+      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n-    src \u003d fsd.resolvePath(pc, src, pathComponents);\n-    final INodesInPath iip;\n-    List\u003cXAttr\u003e xAttrs;\n-    fsd.writeLock();\n-    try {\n-      iip \u003d fsd.getINodesInPath4Write(src, false);\n-      xAttrs \u003d fsn.getErasureCodingZoneManager().createErasureCodingZone(\n-          iip, ecPolicy);\n-    } finally {\n-      fsd.writeUnlock();\n+    assert fsd.hasWriteLock();\n+    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n+    String src \u003d srcIIP.getPath();\n+    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n+        !srcIIP.getLastINode().isDirectory()) {\n+      throw new IOException(\"Attempt to set an erasure coding policy \" +\n+          \"for a file \" + src);\n     }\n-    fsn.getEditLog().logSetXAttrs(src, xAttrs, logRetryCache);\n-    return fsd.getAuditFileInfo(iip);\n+    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n+      throw new IOException(\"Directory \" + src + \" already has an \" +\n+          \"erasure coding policy.\");\n+    }\n+\n+    // System default erasure coding policy will be used since no specified.\n+    if (ecPolicy \u003d\u003d null) {\n+      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n+    }\n+\n+    final XAttr ecXAttr;\n+    DataOutputStream dOut \u003d null;\n+    try {\n+      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n+      dOut \u003d new DataOutputStream(bOut);\n+      WritableUtils.writeString(dOut, ecPolicy.getName());\n+      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n+          bOut.toByteArray());\n+    } finally {\n+      IOUtils.closeStream(dOut);\n+    }\n+    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n+    xattrs.add(ecXAttr);\n+    FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n+        EnumSet.of(XAttrSetFlag.CREATE));\n+    return xattrs;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    assert fsd.hasWriteLock();\n    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n    String src \u003d srcIIP.getPath();\n    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n        !srcIIP.getLastINode().isDirectory()) {\n      throw new IOException(\"Attempt to set an erasure coding policy \" +\n          \"for a file \" + src);\n    }\n    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n      throw new IOException(\"Directory \" + src + \" already has an \" +\n          \"erasure coding policy.\");\n    }\n\n    // System default erasure coding policy will be used since no specified.\n    if (ecPolicy \u003d\u003d null) {\n      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n    }\n\n    final XAttr ecXAttr;\n    DataOutputStream dOut \u003d null;\n    try {\n      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n      dOut \u003d new DataOutputStream(bOut);\n      WritableUtils.writeString(dOut, ecPolicy.getName());\n      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n          bOut.toByteArray());\n    } finally {\n      IOUtils.closeStream(dOut);\n    }\n    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n    xattrs.add(ecXAttr);\n    FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n        EnumSet.of(XAttrSetFlag.CREATE));\n    return xattrs;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
          "extendedDetails": {
            "oldValue": "HdfsFileStatus",
            "newValue": "List\u003cXAttr\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8833. Erasure coding: store EC schema and cell size in INodeFile and eliminate notion of EC zones.\n",
          "commitDate": "09/09/15 11:07 PM",
          "commitName": "f62237bc2f02afe11ce185e13aa51a60b5960037",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "13/08/15 10:04 AM",
          "commitNameOld": "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
          "commitAuthorOld": "Zhe Zhang",
          "daysBetweenCommits": 27.54,
          "commitsBetweenForRepo": 115,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,38 @@\n-  static HdfsFileStatus createErasureCodingZone(final FSNamesystem fsn,\n-      final String srcArg, final ErasureCodingPolicy ecPolicy,\n-      final boolean logRetryCache) throws IOException {\n-    assert fsn.hasWriteLock();\n-\n-    String src \u003d srcArg;\n-    FSPermissionChecker pc \u003d null;\n-    byte[][] pathComponents \u003d null;\n-    pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n-    pc \u003d fsn.getPermissionChecker();\n+  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n+      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n-    src \u003d fsd.resolvePath(pc, src, pathComponents);\n-    final INodesInPath iip;\n-    List\u003cXAttr\u003e xAttrs;\n-    fsd.writeLock();\n-    try {\n-      iip \u003d fsd.getINodesInPath4Write(src, false);\n-      xAttrs \u003d fsn.getErasureCodingZoneManager().createErasureCodingZone(\n-          iip, ecPolicy);\n-    } finally {\n-      fsd.writeUnlock();\n+    assert fsd.hasWriteLock();\n+    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n+    String src \u003d srcIIP.getPath();\n+    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n+        !srcIIP.getLastINode().isDirectory()) {\n+      throw new IOException(\"Attempt to set an erasure coding policy \" +\n+          \"for a file \" + src);\n     }\n-    fsn.getEditLog().logSetXAttrs(src, xAttrs, logRetryCache);\n-    return fsd.getAuditFileInfo(iip);\n+    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n+      throw new IOException(\"Directory \" + src + \" already has an \" +\n+          \"erasure coding policy.\");\n+    }\n+\n+    // System default erasure coding policy will be used since no specified.\n+    if (ecPolicy \u003d\u003d null) {\n+      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n+    }\n+\n+    final XAttr ecXAttr;\n+    DataOutputStream dOut \u003d null;\n+    try {\n+      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n+      dOut \u003d new DataOutputStream(bOut);\n+      WritableUtils.writeString(dOut, ecPolicy.getName());\n+      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n+          bOut.toByteArray());\n+    } finally {\n+      IOUtils.closeStream(dOut);\n+    }\n+    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n+    xattrs.add(ecXAttr);\n+    FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n+        EnumSet.of(XAttrSetFlag.CREATE));\n+    return xattrs;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    assert fsd.hasWriteLock();\n    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n    String src \u003d srcIIP.getPath();\n    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n        !srcIIP.getLastINode().isDirectory()) {\n      throw new IOException(\"Attempt to set an erasure coding policy \" +\n          \"for a file \" + src);\n    }\n    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n      throw new IOException(\"Directory \" + src + \" already has an \" +\n          \"erasure coding policy.\");\n    }\n\n    // System default erasure coding policy will be used since no specified.\n    if (ecPolicy \u003d\u003d null) {\n      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n    }\n\n    final XAttr ecXAttr;\n    DataOutputStream dOut \u003d null;\n    try {\n      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n      dOut \u003d new DataOutputStream(bOut);\n      WritableUtils.writeString(dOut, ecPolicy.getName());\n      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n          bOut.toByteArray());\n    } finally {\n      IOUtils.closeStream(dOut);\n    }\n    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n    xattrs.add(ecXAttr);\n    FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n        EnumSet.of(XAttrSetFlag.CREATE));\n    return xattrs;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HDFS-8833. Erasure coding: store EC schema and cell size in INodeFile and eliminate notion of EC zones.\n",
          "commitDate": "09/09/15 11:07 PM",
          "commitName": "f62237bc2f02afe11ce185e13aa51a60b5960037",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "13/08/15 10:04 AM",
          "commitNameOld": "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
          "commitAuthorOld": "Zhe Zhang",
          "daysBetweenCommits": 27.54,
          "commitsBetweenForRepo": 115,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,38 @@\n-  static HdfsFileStatus createErasureCodingZone(final FSNamesystem fsn,\n-      final String srcArg, final ErasureCodingPolicy ecPolicy,\n-      final boolean logRetryCache) throws IOException {\n-    assert fsn.hasWriteLock();\n-\n-    String src \u003d srcArg;\n-    FSPermissionChecker pc \u003d null;\n-    byte[][] pathComponents \u003d null;\n-    pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n-    pc \u003d fsn.getPermissionChecker();\n+  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n+      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n-    src \u003d fsd.resolvePath(pc, src, pathComponents);\n-    final INodesInPath iip;\n-    List\u003cXAttr\u003e xAttrs;\n-    fsd.writeLock();\n-    try {\n-      iip \u003d fsd.getINodesInPath4Write(src, false);\n-      xAttrs \u003d fsn.getErasureCodingZoneManager().createErasureCodingZone(\n-          iip, ecPolicy);\n-    } finally {\n-      fsd.writeUnlock();\n+    assert fsd.hasWriteLock();\n+    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n+    String src \u003d srcIIP.getPath();\n+    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n+        !srcIIP.getLastINode().isDirectory()) {\n+      throw new IOException(\"Attempt to set an erasure coding policy \" +\n+          \"for a file \" + src);\n     }\n-    fsn.getEditLog().logSetXAttrs(src, xAttrs, logRetryCache);\n-    return fsd.getAuditFileInfo(iip);\n+    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n+      throw new IOException(\"Directory \" + src + \" already has an \" +\n+          \"erasure coding policy.\");\n+    }\n+\n+    // System default erasure coding policy will be used since no specified.\n+    if (ecPolicy \u003d\u003d null) {\n+      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n+    }\n+\n+    final XAttr ecXAttr;\n+    DataOutputStream dOut \u003d null;\n+    try {\n+      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n+      dOut \u003d new DataOutputStream(bOut);\n+      WritableUtils.writeString(dOut, ecPolicy.getName());\n+      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n+          bOut.toByteArray());\n+    } finally {\n+      IOUtils.closeStream(dOut);\n+    }\n+    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n+    xattrs.add(ecXAttr);\n+    FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n+        EnumSet.of(XAttrSetFlag.CREATE));\n+    return xattrs;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static List\u003cXAttr\u003e createErasureCodingPolicyXAttr(final FSNamesystem fsn,\n      final INodesInPath srcIIP, ErasureCodingPolicy ecPolicy) throws IOException {\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    assert fsd.hasWriteLock();\n    Preconditions.checkNotNull(srcIIP, \"INodes cannot be null\");\n    String src \u003d srcIIP.getPath();\n    if (srcIIP.getLastINode() !\u003d null \u0026\u0026\n        !srcIIP.getLastINode().isDirectory()) {\n      throw new IOException(\"Attempt to set an erasure coding policy \" +\n          \"for a file \" + src);\n    }\n    if (getErasureCodingPolicyForPath(fsn, srcIIP) !\u003d null) {\n      throw new IOException(\"Directory \" + src + \" already has an \" +\n          \"erasure coding policy.\");\n    }\n\n    // System default erasure coding policy will be used since no specified.\n    if (ecPolicy \u003d\u003d null) {\n      ecPolicy \u003d ErasureCodingPolicyManager.getSystemDefaultPolicy();\n    }\n\n    final XAttr ecXAttr;\n    DataOutputStream dOut \u003d null;\n    try {\n      ByteArrayOutputStream bOut \u003d new ByteArrayOutputStream();\n      dOut \u003d new DataOutputStream(bOut);\n      WritableUtils.writeString(dOut, ecPolicy.getName());\n      ecXAttr \u003d XAttrHelper.buildXAttr(XATTR_ERASURECODING_POLICY,\n          bOut.toByteArray());\n    } finally {\n      IOUtils.closeStream(dOut);\n    }\n    final List\u003cXAttr\u003e xattrs \u003d Lists.newArrayListWithCapacity(1);\n    xattrs.add(ecXAttr);\n    FSDirXAttrOp.unprotectedSetXAttrs(fsd, src, xattrs,\n        EnumSet.of(XAttrSetFlag.CREATE));\n    return xattrs;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
          "extendedDetails": {
            "oldValue": "[fsn-FSNamesystem(modifiers-final), srcArg-String(modifiers-final), ecPolicy-ErasureCodingPolicy(modifiers-final), logRetryCache-boolean(modifiers-final)]",
            "newValue": "[fsn-FSNamesystem(modifiers-final), srcIIP-INodesInPath(modifiers-final), ecPolicy-ErasureCodingPolicy]"
          }
        }
      ]
    },
    "1d37a8812160bb030244a1e6b1c753f962d8d2ed": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-8854. Erasure coding: add ECPolicy to replace schema+cellSize in hadoop-hdfs. Contributed by Walter Su.\n",
      "commitDate": "13/08/15 10:04 AM",
      "commitName": "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
      "commitAuthor": "Zhe Zhang",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8854. Erasure coding: add ECPolicy to replace schema+cellSize in hadoop-hdfs. Contributed by Walter Su.\n",
          "commitDate": "13/08/15 10:04 AM",
          "commitName": "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "10/06/15 10:18 PM",
          "commitNameOld": "98d340745be682fb251677bb4830aca76119868f",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 63.49,
          "commitsBetweenForRepo": 37,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,25 @@\n   static HdfsFileStatus createErasureCodingZone(final FSNamesystem fsn,\n-      final String srcArg, final ECSchema schema, final int cellSize,\n+      final String srcArg, final ErasureCodingPolicy ecPolicy,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     String src \u003d srcArg;\n     FSPermissionChecker pc \u003d null;\n     byte[][] pathComponents \u003d null;\n     pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n     pc \u003d fsn.getPermissionChecker();\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     src \u003d fsd.resolvePath(pc, src, pathComponents);\n     final INodesInPath iip;\n     List\u003cXAttr\u003e xAttrs;\n     fsd.writeLock();\n     try {\n       iip \u003d fsd.getINodesInPath4Write(src, false);\n       xAttrs \u003d fsn.getErasureCodingZoneManager().createErasureCodingZone(\n-          iip, schema, cellSize);\n+          iip, ecPolicy);\n     } finally {\n       fsd.writeUnlock();\n     }\n     fsn.getEditLog().logSetXAttrs(src, xAttrs, logRetryCache);\n     return fsd.getAuditFileInfo(iip);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createErasureCodingZone(final FSNamesystem fsn,\n      final String srcArg, final ErasureCodingPolicy ecPolicy,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    String src \u003d srcArg;\n    FSPermissionChecker pc \u003d null;\n    byte[][] pathComponents \u003d null;\n    pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    pc \u003d fsn.getPermissionChecker();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    final INodesInPath iip;\n    List\u003cXAttr\u003e xAttrs;\n    fsd.writeLock();\n    try {\n      iip \u003d fsd.getINodesInPath4Write(src, false);\n      xAttrs \u003d fsn.getErasureCodingZoneManager().createErasureCodingZone(\n          iip, ecPolicy);\n    } finally {\n      fsd.writeUnlock();\n    }\n    fsn.getEditLog().logSetXAttrs(src, xAttrs, logRetryCache);\n    return fsd.getAuditFileInfo(iip);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
          "extendedDetails": {
            "oldValue": "[fsn-FSNamesystem(modifiers-final), srcArg-String(modifiers-final), schema-ECSchema(modifiers-final), cellSize-int(modifiers-final), logRetryCache-boolean(modifiers-final)]",
            "newValue": "[fsn-FSNamesystem(modifiers-final), srcArg-String(modifiers-final), ecPolicy-ErasureCodingPolicy(modifiers-final), logRetryCache-boolean(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8854. Erasure coding: add ECPolicy to replace schema+cellSize in hadoop-hdfs. Contributed by Walter Su.\n",
          "commitDate": "13/08/15 10:04 AM",
          "commitName": "1d37a8812160bb030244a1e6b1c753f962d8d2ed",
          "commitAuthor": "Zhe Zhang",
          "commitDateOld": "10/06/15 10:18 PM",
          "commitNameOld": "98d340745be682fb251677bb4830aca76119868f",
          "commitAuthorOld": "Vinayakumar B",
          "daysBetweenCommits": 63.49,
          "commitsBetweenForRepo": 37,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,25 @@\n   static HdfsFileStatus createErasureCodingZone(final FSNamesystem fsn,\n-      final String srcArg, final ECSchema schema, final int cellSize,\n+      final String srcArg, final ErasureCodingPolicy ecPolicy,\n       final boolean logRetryCache) throws IOException {\n     assert fsn.hasWriteLock();\n \n     String src \u003d srcArg;\n     FSPermissionChecker pc \u003d null;\n     byte[][] pathComponents \u003d null;\n     pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n     pc \u003d fsn.getPermissionChecker();\n     FSDirectory fsd \u003d fsn.getFSDirectory();\n     src \u003d fsd.resolvePath(pc, src, pathComponents);\n     final INodesInPath iip;\n     List\u003cXAttr\u003e xAttrs;\n     fsd.writeLock();\n     try {\n       iip \u003d fsd.getINodesInPath4Write(src, false);\n       xAttrs \u003d fsn.getErasureCodingZoneManager().createErasureCodingZone(\n-          iip, schema, cellSize);\n+          iip, ecPolicy);\n     } finally {\n       fsd.writeUnlock();\n     }\n     fsn.getEditLog().logSetXAttrs(src, xAttrs, logRetryCache);\n     return fsd.getAuditFileInfo(iip);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  static HdfsFileStatus createErasureCodingZone(final FSNamesystem fsn,\n      final String srcArg, final ErasureCodingPolicy ecPolicy,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    String src \u003d srcArg;\n    FSPermissionChecker pc \u003d null;\n    byte[][] pathComponents \u003d null;\n    pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    pc \u003d fsn.getPermissionChecker();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    final INodesInPath iip;\n    List\u003cXAttr\u003e xAttrs;\n    fsd.writeLock();\n    try {\n      iip \u003d fsd.getINodesInPath4Write(src, false);\n      xAttrs \u003d fsn.getErasureCodingZoneManager().createErasureCodingZone(\n          iip, ecPolicy);\n    } finally {\n      fsd.writeUnlock();\n    }\n    fsn.getEditLog().logSetXAttrs(src, xAttrs, logRetryCache);\n    return fsd.getAuditFileInfo(iip);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java",
          "extendedDetails": {}
        }
      ]
    },
    "98d340745be682fb251677bb4830aca76119868f": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-8450. Erasure Coding: Consolidate erasure coding zone related implementation into a single class (Contributed by Rakesh R)\n",
      "commitDate": "10/06/15 10:18 PM",
      "commitName": "98d340745be682fb251677bb4830aca76119868f",
      "commitAuthor": "Vinayakumar B",
      "diff": "@@ -0,0 +1,25 @@\n+  static HdfsFileStatus createErasureCodingZone(final FSNamesystem fsn,\n+      final String srcArg, final ECSchema schema, final int cellSize,\n+      final boolean logRetryCache) throws IOException {\n+    assert fsn.hasWriteLock();\n+\n+    String src \u003d srcArg;\n+    FSPermissionChecker pc \u003d null;\n+    byte[][] pathComponents \u003d null;\n+    pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n+    pc \u003d fsn.getPermissionChecker();\n+    FSDirectory fsd \u003d fsn.getFSDirectory();\n+    src \u003d fsd.resolvePath(pc, src, pathComponents);\n+    final INodesInPath iip;\n+    List\u003cXAttr\u003e xAttrs;\n+    fsd.writeLock();\n+    try {\n+      iip \u003d fsd.getINodesInPath4Write(src, false);\n+      xAttrs \u003d fsn.getErasureCodingZoneManager().createErasureCodingZone(\n+          iip, schema, cellSize);\n+    } finally {\n+      fsd.writeUnlock();\n+    }\n+    fsn.getEditLog().logSetXAttrs(src, xAttrs, logRetryCache);\n+    return fsd.getAuditFileInfo(iip);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  static HdfsFileStatus createErasureCodingZone(final FSNamesystem fsn,\n      final String srcArg, final ECSchema schema, final int cellSize,\n      final boolean logRetryCache) throws IOException {\n    assert fsn.hasWriteLock();\n\n    String src \u003d srcArg;\n    FSPermissionChecker pc \u003d null;\n    byte[][] pathComponents \u003d null;\n    pathComponents \u003d FSDirectory.getPathComponentsForReservedPath(src);\n    pc \u003d fsn.getPermissionChecker();\n    FSDirectory fsd \u003d fsn.getFSDirectory();\n    src \u003d fsd.resolvePath(pc, src, pathComponents);\n    final INodesInPath iip;\n    List\u003cXAttr\u003e xAttrs;\n    fsd.writeLock();\n    try {\n      iip \u003d fsd.getINodesInPath4Write(src, false);\n      xAttrs \u003d fsn.getErasureCodingZoneManager().createErasureCodingZone(\n          iip, schema, cellSize);\n    } finally {\n      fsd.writeUnlock();\n    }\n    fsn.getEditLog().logSetXAttrs(src, xAttrs, logRetryCache);\n    return fsd.getAuditFileInfo(iip);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirErasureCodingOp.java"
    }
  }
}