{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockPlacementPolicyDefault.java",
  "functionName": "chooseReplicasToDelete",
  "functionId": "chooseReplicasToDelete___availableReplicas-Collection__DatanodeStorageInfo____delCandidates-Collection__DatanodeStorageInfo____expectedNumOfReplicas-int__excessTypes-List__StorageType____addedNode-DatanodeDescriptor__delNodeHint-DatanodeDescriptor",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
  "functionStartLine": 1164,
  "functionEndLine": 1217,
  "numCommitsSeen": 231,
  "timeTaken": 6976,
  "changeHistory": [
    "f5ecc0bc080cb8a64c6d4632fc1c121f93d95c5e",
    "9dce9011ad211bf35fe2538ded0f19d68f5c16d2",
    "408f2c807bbaaaa37ce1b69a5dfa9d76ed427d6e",
    "0e54b164a8d8acf09aca8712116bf7a554cb4846",
    "ec414600ede8e305c584818565b50e055ea5d2b5",
    "d565480da2f646b40c3180e1ccb2935c9863dfef",
    "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498",
    "b7ded466b00db0fe273058b844d56d810e0f8cc2"
  ],
  "changeHistoryShort": {
    "f5ecc0bc080cb8a64c6d4632fc1c121f93d95c5e": "Ybodychange",
    "9dce9011ad211bf35fe2538ded0f19d68f5c16d2": "Ybodychange",
    "408f2c807bbaaaa37ce1b69a5dfa9d76ed427d6e": "Ymultichange(Yparameterchange,Ybodychange)",
    "0e54b164a8d8acf09aca8712116bf7a554cb4846": "Ybodychange",
    "ec414600ede8e305c584818565b50e055ea5d2b5": "Ybodychange",
    "d565480da2f646b40c3180e1ccb2935c9863dfef": "Ybodychange",
    "e27c2ae8bafc94f18eb38f5d839dcef5652d424e": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange,Yparametermetachange)",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": "Ybodychange",
    "b7ded466b00db0fe273058b844d56d810e0f8cc2": "Ybodychange"
  },
  "changeHistoryDetails": {
    "f5ecc0bc080cb8a64c6d4632fc1c121f93d95c5e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14103. Review Logging of BlockPlacementPolicyDefault. Contributed by David Mollitor.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "19/06/19 10:06 AM",
      "commitName": "f5ecc0bc080cb8a64c6d4632fc1c121f93d95c5e",
      "commitAuthor": "David Mollitor",
      "commitDateOld": "06/06/19 10:20 AM",
      "commitNameOld": "944adc61b1830388d520d4052fc7eb6c7ba2790d",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 12.99,
      "commitsBetweenForRepo": 103,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,54 @@\n   public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n       Collection\u003cDatanodeStorageInfo\u003e availableReplicas,\n       Collection\u003cDatanodeStorageInfo\u003e delCandidates,\n       int expectedNumOfReplicas,\n       List\u003cStorageType\u003e excessTypes,\n       DatanodeDescriptor addedNode,\n       DatanodeDescriptor delNodeHint) {\n \n     List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n \n     final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n \n     final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n     final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n \n     // split candidate nodes for deletion into two sets\n     // moreThanOne contains nodes on rack with more than one replica\n     // exactlyOne contains the remaining nodes\n     splitNodesWithRack(availableReplicas, delCandidates, rackMap, moreThanOne,\n         exactlyOne);\n \n     // pick one node to delete that favors the delete hint\n     // otherwise pick one with least space from priSet if it is not empty\n     // otherwise one node with least space from remains\n     boolean firstOne \u003d true;\n     final DatanodeStorageInfo delNodeHintStorage \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, delNodeHint);\n     final DatanodeStorageInfo addedNodeStorage \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, addedNode);\n \n     while (delCandidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n       final DatanodeStorageInfo cur;\n       if (firstOne \u0026\u0026 useDelHint(delNodeHintStorage, addedNodeStorage,\n           moreThanOne, exactlyOne, excessTypes)) {\n         cur \u003d delNodeHintStorage;\n       } else { // regular excessive replica removal\n         cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne,\n             excessTypes, rackMap);\n       }\n       firstOne \u003d false;\n       if (cur \u003d\u003d null) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"No excess replica can be found. excessTypes: {}.\" +\n-              \" moreThanOne: {}. exactlyOne: {}.\", excessTypes,\n-              moreThanOne, exactlyOne);\n-        }\n+        LOG.debug(\n+            \"No excess replica can be found. excessTypes: {}. \"\n+                + \"moreThanOne: {}. exactlyOne: {}.\",\n+            excessTypes, moreThanOne, exactlyOne);\n         break;\n       }\n \n       // adjust rackmap, moreThanOne, and exactlyOne\n       adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n       excessReplicas.add(cur);\n     }\n     return excessReplicas;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e availableReplicas,\n      Collection\u003cDatanodeStorageInfo\u003e delCandidates,\n      int expectedNumOfReplicas,\n      List\u003cStorageType\u003e excessTypes,\n      DatanodeDescriptor addedNode,\n      DatanodeDescriptor delNodeHint) {\n\n    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n\n    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n\n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n\n    // split candidate nodes for deletion into two sets\n    // moreThanOne contains nodes on rack with more than one replica\n    // exactlyOne contains the remaining nodes\n    splitNodesWithRack(availableReplicas, delCandidates, rackMap, moreThanOne,\n        exactlyOne);\n\n    // pick one node to delete that favors the delete hint\n    // otherwise pick one with least space from priSet if it is not empty\n    // otherwise one node with least space from remains\n    boolean firstOne \u003d true;\n    final DatanodeStorageInfo delNodeHintStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, delNodeHint);\n    final DatanodeStorageInfo addedNodeStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, addedNode);\n\n    while (delCandidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n      final DatanodeStorageInfo cur;\n      if (firstOne \u0026\u0026 useDelHint(delNodeHintStorage, addedNodeStorage,\n          moreThanOne, exactlyOne, excessTypes)) {\n        cur \u003d delNodeHintStorage;\n      } else { // regular excessive replica removal\n        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne,\n            excessTypes, rackMap);\n      }\n      firstOne \u003d false;\n      if (cur \u003d\u003d null) {\n        LOG.debug(\n            \"No excess replica can be found. excessTypes: {}. \"\n                + \"moreThanOne: {}. exactlyOne: {}.\",\n            excessTypes, moreThanOne, exactlyOne);\n        break;\n      }\n\n      // adjust rackmap, moreThanOne, and exactlyOne\n      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n      excessReplicas.add(cur);\n    }\n    return excessReplicas;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "9dce9011ad211bf35fe2538ded0f19d68f5c16d2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11054. Suppress verbose log message in BlockPlacementPolicyDefault. Contributed by Chen Liang.\n",
      "commitDate": "25/10/16 7:50 PM",
      "commitName": "9dce9011ad211bf35fe2538ded0f19d68f5c16d2",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "17/10/16 5:45 PM",
      "commitNameOld": "b61fb267b92b2736920b4bd0c673d31e7632ebb9",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 8.09,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,55 @@\n   public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n       Collection\u003cDatanodeStorageInfo\u003e availableReplicas,\n       Collection\u003cDatanodeStorageInfo\u003e delCandidates,\n       int expectedNumOfReplicas,\n       List\u003cStorageType\u003e excessTypes,\n       DatanodeDescriptor addedNode,\n       DatanodeDescriptor delNodeHint) {\n \n     List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n \n     final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n \n     final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n     final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n \n     // split candidate nodes for deletion into two sets\n     // moreThanOne contains nodes on rack with more than one replica\n     // exactlyOne contains the remaining nodes\n     splitNodesWithRack(availableReplicas, delCandidates, rackMap, moreThanOne,\n         exactlyOne);\n \n     // pick one node to delete that favors the delete hint\n     // otherwise pick one with least space from priSet if it is not empty\n     // otherwise one node with least space from remains\n     boolean firstOne \u003d true;\n     final DatanodeStorageInfo delNodeHintStorage \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, delNodeHint);\n     final DatanodeStorageInfo addedNodeStorage \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, addedNode);\n \n     while (delCandidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n       final DatanodeStorageInfo cur;\n       if (firstOne \u0026\u0026 useDelHint(delNodeHintStorage, addedNodeStorage,\n           moreThanOne, exactlyOne, excessTypes)) {\n         cur \u003d delNodeHintStorage;\n       } else { // regular excessive replica removal\n         cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne,\n             excessTypes, rackMap);\n       }\n       firstOne \u003d false;\n       if (cur \u003d\u003d null) {\n-        LOG.warn(\"No excess replica can be found. excessTypes: {}.\" +\n-            \" moreThanOne: {}. exactlyOne: {}.\", excessTypes, moreThanOne,\n-            exactlyOne);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"No excess replica can be found. excessTypes: {}.\" +\n+              \" moreThanOne: {}. exactlyOne: {}.\", excessTypes,\n+              moreThanOne, exactlyOne);\n+        }\n         break;\n       }\n \n       // adjust rackmap, moreThanOne, and exactlyOne\n       adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n       excessReplicas.add(cur);\n     }\n     return excessReplicas;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e availableReplicas,\n      Collection\u003cDatanodeStorageInfo\u003e delCandidates,\n      int expectedNumOfReplicas,\n      List\u003cStorageType\u003e excessTypes,\n      DatanodeDescriptor addedNode,\n      DatanodeDescriptor delNodeHint) {\n\n    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n\n    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n\n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n\n    // split candidate nodes for deletion into two sets\n    // moreThanOne contains nodes on rack with more than one replica\n    // exactlyOne contains the remaining nodes\n    splitNodesWithRack(availableReplicas, delCandidates, rackMap, moreThanOne,\n        exactlyOne);\n\n    // pick one node to delete that favors the delete hint\n    // otherwise pick one with least space from priSet if it is not empty\n    // otherwise one node with least space from remains\n    boolean firstOne \u003d true;\n    final DatanodeStorageInfo delNodeHintStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, delNodeHint);\n    final DatanodeStorageInfo addedNodeStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, addedNode);\n\n    while (delCandidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n      final DatanodeStorageInfo cur;\n      if (firstOne \u0026\u0026 useDelHint(delNodeHintStorage, addedNodeStorage,\n          moreThanOne, exactlyOne, excessTypes)) {\n        cur \u003d delNodeHintStorage;\n      } else { // regular excessive replica removal\n        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne,\n            excessTypes, rackMap);\n      }\n      firstOne \u003d false;\n      if (cur \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"No excess replica can be found. excessTypes: {}.\" +\n              \" moreThanOne: {}. exactlyOne: {}.\", excessTypes,\n              moreThanOne, exactlyOne);\n        }\n        break;\n      }\n\n      // adjust rackmap, moreThanOne, and exactlyOne\n      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n      excessReplicas.add(cur);\n    }\n    return excessReplicas;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "408f2c807bbaaaa37ce1b69a5dfa9d76ed427d6e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-9866. BlockManager#chooseExcessReplicasStriped may weaken rack fault tolerance. Contributed by Jing Zhao.\n",
      "commitDate": "28/02/16 2:54 PM",
      "commitName": "408f2c807bbaaaa37ce1b69a5dfa9d76ed427d6e",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-9866. BlockManager#chooseExcessReplicasStriped may weaken rack fault tolerance. Contributed by Jing Zhao.\n",
          "commitDate": "28/02/16 2:54 PM",
          "commitName": "408f2c807bbaaaa37ce1b69a5dfa9d76ed427d6e",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "19/02/16 7:02 PM",
          "commitNameOld": "e54cc2931262bf49682a8323da9811976218c03b",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 8.83,
          "commitsBetweenForRepo": 55,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,53 @@\n   public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n-      Collection\u003cDatanodeStorageInfo\u003e candidates,\n+      Collection\u003cDatanodeStorageInfo\u003e availableReplicas,\n+      Collection\u003cDatanodeStorageInfo\u003e delCandidates,\n       int expectedNumOfReplicas,\n       List\u003cStorageType\u003e excessTypes,\n       DatanodeDescriptor addedNode,\n       DatanodeDescriptor delNodeHint) {\n \n     List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n \n     final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n \n     final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n     final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n \n-    // split nodes into two sets\n+    // split candidate nodes for deletion into two sets\n     // moreThanOne contains nodes on rack with more than one replica\n     // exactlyOne contains the remaining nodes\n-    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n+    splitNodesWithRack(availableReplicas, delCandidates, rackMap, moreThanOne,\n+        exactlyOne);\n \n     // pick one node to delete that favors the delete hint\n     // otherwise pick one with least space from priSet if it is not empty\n     // otherwise one node with least space from remains\n     boolean firstOne \u003d true;\n     final DatanodeStorageInfo delNodeHintStorage \u003d\n-        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n+        DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, delNodeHint);\n     final DatanodeStorageInfo addedNodeStorage \u003d\n-        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n+        DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, addedNode);\n \n-    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n+    while (delCandidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n       final DatanodeStorageInfo cur;\n       if (firstOne \u0026\u0026 useDelHint(delNodeHintStorage, addedNodeStorage,\n           moreThanOne, exactlyOne, excessTypes)) {\n         cur \u003d delNodeHintStorage;\n       } else { // regular excessive replica removal\n-        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne, excessTypes,\n-            rackMap);\n+        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne,\n+            excessTypes, rackMap);\n       }\n       firstOne \u003d false;\n       if (cur \u003d\u003d null) {\n         LOG.warn(\"No excess replica can be found. excessTypes: {}.\" +\n             \" moreThanOne: {}. exactlyOne: {}.\", excessTypes, moreThanOne,\n             exactlyOne);\n         break;\n       }\n \n       // adjust rackmap, moreThanOne, and exactlyOne\n       adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n       excessReplicas.add(cur);\n     }\n     return excessReplicas;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e availableReplicas,\n      Collection\u003cDatanodeStorageInfo\u003e delCandidates,\n      int expectedNumOfReplicas,\n      List\u003cStorageType\u003e excessTypes,\n      DatanodeDescriptor addedNode,\n      DatanodeDescriptor delNodeHint) {\n\n    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n\n    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n\n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n\n    // split candidate nodes for deletion into two sets\n    // moreThanOne contains nodes on rack with more than one replica\n    // exactlyOne contains the remaining nodes\n    splitNodesWithRack(availableReplicas, delCandidates, rackMap, moreThanOne,\n        exactlyOne);\n\n    // pick one node to delete that favors the delete hint\n    // otherwise pick one with least space from priSet if it is not empty\n    // otherwise one node with least space from remains\n    boolean firstOne \u003d true;\n    final DatanodeStorageInfo delNodeHintStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, delNodeHint);\n    final DatanodeStorageInfo addedNodeStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, addedNode);\n\n    while (delCandidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n      final DatanodeStorageInfo cur;\n      if (firstOne \u0026\u0026 useDelHint(delNodeHintStorage, addedNodeStorage,\n          moreThanOne, exactlyOne, excessTypes)) {\n        cur \u003d delNodeHintStorage;\n      } else { // regular excessive replica removal\n        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne,\n            excessTypes, rackMap);\n      }\n      firstOne \u003d false;\n      if (cur \u003d\u003d null) {\n        LOG.warn(\"No excess replica can be found. excessTypes: {}.\" +\n            \" moreThanOne: {}. exactlyOne: {}.\", excessTypes, moreThanOne,\n            exactlyOne);\n        break;\n      }\n\n      // adjust rackmap, moreThanOne, and exactlyOne\n      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n      excessReplicas.add(cur);\n    }\n    return excessReplicas;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "[candidates-Collection\u003cDatanodeStorageInfo\u003e, expectedNumOfReplicas-int, excessTypes-List\u003cStorageType\u003e, addedNode-DatanodeDescriptor, delNodeHint-DatanodeDescriptor]",
            "newValue": "[availableReplicas-Collection\u003cDatanodeStorageInfo\u003e, delCandidates-Collection\u003cDatanodeStorageInfo\u003e, expectedNumOfReplicas-int, excessTypes-List\u003cStorageType\u003e, addedNode-DatanodeDescriptor, delNodeHint-DatanodeDescriptor]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-9866. BlockManager#chooseExcessReplicasStriped may weaken rack fault tolerance. Contributed by Jing Zhao.\n",
          "commitDate": "28/02/16 2:54 PM",
          "commitName": "408f2c807bbaaaa37ce1b69a5dfa9d76ed427d6e",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "19/02/16 7:02 PM",
          "commitNameOld": "e54cc2931262bf49682a8323da9811976218c03b",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 8.83,
          "commitsBetweenForRepo": 55,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,51 +1,53 @@\n   public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n-      Collection\u003cDatanodeStorageInfo\u003e candidates,\n+      Collection\u003cDatanodeStorageInfo\u003e availableReplicas,\n+      Collection\u003cDatanodeStorageInfo\u003e delCandidates,\n       int expectedNumOfReplicas,\n       List\u003cStorageType\u003e excessTypes,\n       DatanodeDescriptor addedNode,\n       DatanodeDescriptor delNodeHint) {\n \n     List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n \n     final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n \n     final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n     final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n \n-    // split nodes into two sets\n+    // split candidate nodes for deletion into two sets\n     // moreThanOne contains nodes on rack with more than one replica\n     // exactlyOne contains the remaining nodes\n-    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n+    splitNodesWithRack(availableReplicas, delCandidates, rackMap, moreThanOne,\n+        exactlyOne);\n \n     // pick one node to delete that favors the delete hint\n     // otherwise pick one with least space from priSet if it is not empty\n     // otherwise one node with least space from remains\n     boolean firstOne \u003d true;\n     final DatanodeStorageInfo delNodeHintStorage \u003d\n-        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n+        DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, delNodeHint);\n     final DatanodeStorageInfo addedNodeStorage \u003d\n-        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n+        DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, addedNode);\n \n-    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n+    while (delCandidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n       final DatanodeStorageInfo cur;\n       if (firstOne \u0026\u0026 useDelHint(delNodeHintStorage, addedNodeStorage,\n           moreThanOne, exactlyOne, excessTypes)) {\n         cur \u003d delNodeHintStorage;\n       } else { // regular excessive replica removal\n-        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne, excessTypes,\n-            rackMap);\n+        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne,\n+            excessTypes, rackMap);\n       }\n       firstOne \u003d false;\n       if (cur \u003d\u003d null) {\n         LOG.warn(\"No excess replica can be found. excessTypes: {}.\" +\n             \" moreThanOne: {}. exactlyOne: {}.\", excessTypes, moreThanOne,\n             exactlyOne);\n         break;\n       }\n \n       // adjust rackmap, moreThanOne, and exactlyOne\n       adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n       excessReplicas.add(cur);\n     }\n     return excessReplicas;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e availableReplicas,\n      Collection\u003cDatanodeStorageInfo\u003e delCandidates,\n      int expectedNumOfReplicas,\n      List\u003cStorageType\u003e excessTypes,\n      DatanodeDescriptor addedNode,\n      DatanodeDescriptor delNodeHint) {\n\n    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n\n    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n\n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n\n    // split candidate nodes for deletion into two sets\n    // moreThanOne contains nodes on rack with more than one replica\n    // exactlyOne contains the remaining nodes\n    splitNodesWithRack(availableReplicas, delCandidates, rackMap, moreThanOne,\n        exactlyOne);\n\n    // pick one node to delete that favors the delete hint\n    // otherwise pick one with least space from priSet if it is not empty\n    // otherwise one node with least space from remains\n    boolean firstOne \u003d true;\n    final DatanodeStorageInfo delNodeHintStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, delNodeHint);\n    final DatanodeStorageInfo addedNodeStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(delCandidates, addedNode);\n\n    while (delCandidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n      final DatanodeStorageInfo cur;\n      if (firstOne \u0026\u0026 useDelHint(delNodeHintStorage, addedNodeStorage,\n          moreThanOne, exactlyOne, excessTypes)) {\n        cur \u003d delNodeHintStorage;\n      } else { // regular excessive replica removal\n        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne,\n            excessTypes, rackMap);\n      }\n      firstOne \u003d false;\n      if (cur \u003d\u003d null) {\n        LOG.warn(\"No excess replica can be found. excessTypes: {}.\" +\n            \" moreThanOne: {}. exactlyOne: {}.\", excessTypes, moreThanOne,\n            exactlyOne);\n        break;\n      }\n\n      // adjust rackmap, moreThanOne, and exactlyOne\n      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n      excessReplicas.add(cur);\n    }\n    return excessReplicas;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {}
        }
      ]
    },
    "0e54b164a8d8acf09aca8712116bf7a554cb4846": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9314. Improve BlockPlacementPolicyDefault\u0027s picking of excess replicas. (Xiao Chen via mingma)\n",
      "commitDate": "24/11/15 10:30 AM",
      "commitName": "0e54b164a8d8acf09aca8712116bf7a554cb4846",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "06/11/15 11:30 AM",
      "commitNameOld": "bf6aa30a156b3c5cac5469014a5989e0dfdc7256",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 17.96,
      "commitsBetweenForRepo": 113,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,51 @@\n   public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n       Collection\u003cDatanodeStorageInfo\u003e candidates,\n       int expectedNumOfReplicas,\n       List\u003cStorageType\u003e excessTypes,\n       DatanodeDescriptor addedNode,\n       DatanodeDescriptor delNodeHint) {\n \n     List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n \n     final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n \n     final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n     final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n \n     // split nodes into two sets\n     // moreThanOne contains nodes on rack with more than one replica\n     // exactlyOne contains the remaining nodes\n     splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n \n     // pick one node to delete that favors the delete hint\n     // otherwise pick one with least space from priSet if it is not empty\n     // otherwise one node with least space from remains\n     boolean firstOne \u003d true;\n     final DatanodeStorageInfo delNodeHintStorage \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n     final DatanodeStorageInfo addedNodeStorage \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n \n     while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n       final DatanodeStorageInfo cur;\n       if (firstOne \u0026\u0026 useDelHint(delNodeHintStorage, addedNodeStorage,\n           moreThanOne, exactlyOne, excessTypes)) {\n         cur \u003d delNodeHintStorage;\n       } else { // regular excessive replica removal\n-        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne, excessTypes);\n+        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne, excessTypes,\n+            rackMap);\n       }\n       firstOne \u003d false;\n       if (cur \u003d\u003d null) {\n         LOG.warn(\"No excess replica can be found. excessTypes: {}.\" +\n             \" moreThanOne: {}. exactlyOne: {}.\", excessTypes, moreThanOne,\n             exactlyOne);\n         break;\n       }\n \n       // adjust rackmap, moreThanOne, and exactlyOne\n       adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n       excessReplicas.add(cur);\n     }\n     return excessReplicas;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e candidates,\n      int expectedNumOfReplicas,\n      List\u003cStorageType\u003e excessTypes,\n      DatanodeDescriptor addedNode,\n      DatanodeDescriptor delNodeHint) {\n\n    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n\n    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n\n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n\n    // split nodes into two sets\n    // moreThanOne contains nodes on rack with more than one replica\n    // exactlyOne contains the remaining nodes\n    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n\n    // pick one node to delete that favors the delete hint\n    // otherwise pick one with least space from priSet if it is not empty\n    // otherwise one node with least space from remains\n    boolean firstOne \u003d true;\n    final DatanodeStorageInfo delNodeHintStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n    final DatanodeStorageInfo addedNodeStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n\n    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n      final DatanodeStorageInfo cur;\n      if (firstOne \u0026\u0026 useDelHint(delNodeHintStorage, addedNodeStorage,\n          moreThanOne, exactlyOne, excessTypes)) {\n        cur \u003d delNodeHintStorage;\n      } else { // regular excessive replica removal\n        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne, excessTypes,\n            rackMap);\n      }\n      firstOne \u003d false;\n      if (cur \u003d\u003d null) {\n        LOG.warn(\"No excess replica can be found. excessTypes: {}.\" +\n            \" moreThanOne: {}. exactlyOne: {}.\", excessTypes, moreThanOne,\n            exactlyOne);\n        break;\n      }\n\n      // adjust rackmap, moreThanOne, and exactlyOne\n      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n      excessReplicas.add(cur);\n    }\n    return excessReplicas;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "ec414600ede8e305c584818565b50e055ea5d2b5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9007. Fix HDFS Balancer to honor upgrade domain policy. (Ming Ma via lei)\n",
      "commitDate": "04/11/15 10:22 AM",
      "commitName": "ec414600ede8e305c584818565b50e055ea5d2b5",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "02/11/15 7:36 PM",
      "commitNameOld": "d565480da2f646b40c3180e1ccb2935c9863dfef",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 1.62,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,50 @@\n   public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n       Collection\u003cDatanodeStorageInfo\u003e candidates,\n       int expectedNumOfReplicas,\n       List\u003cStorageType\u003e excessTypes,\n       DatanodeDescriptor addedNode,\n       DatanodeDescriptor delNodeHint) {\n \n     List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n \n     final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n \n     final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n     final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n \n     // split nodes into two sets\n     // moreThanOne contains nodes on rack with more than one replica\n     // exactlyOne contains the remaining nodes\n     splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n \n     // pick one node to delete that favors the delete hint\n     // otherwise pick one with least space from priSet if it is not empty\n     // otherwise one node with least space from remains\n     boolean firstOne \u003d true;\n     final DatanodeStorageInfo delNodeHintStorage \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n     final DatanodeStorageInfo addedNodeStorage \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n \n     while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n       final DatanodeStorageInfo cur;\n-      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n-          moreThanOne, excessTypes)) {\n+      if (firstOne \u0026\u0026 useDelHint(delNodeHintStorage, addedNodeStorage,\n+          moreThanOne, exactlyOne, excessTypes)) {\n         cur \u003d delNodeHintStorage;\n       } else { // regular excessive replica removal\n-        cur \u003d\n-            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n-                excessTypes);\n+        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne, excessTypes);\n       }\n       firstOne \u003d false;\n       if (cur \u003d\u003d null) {\n         LOG.warn(\"No excess replica can be found. excessTypes: {}.\" +\n             \" moreThanOne: {}. exactlyOne: {}.\", excessTypes, moreThanOne,\n             exactlyOne);\n         break;\n       }\n \n       // adjust rackmap, moreThanOne, and exactlyOne\n       adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n       excessReplicas.add(cur);\n     }\n     return excessReplicas;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e candidates,\n      int expectedNumOfReplicas,\n      List\u003cStorageType\u003e excessTypes,\n      DatanodeDescriptor addedNode,\n      DatanodeDescriptor delNodeHint) {\n\n    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n\n    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n\n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n\n    // split nodes into two sets\n    // moreThanOne contains nodes on rack with more than one replica\n    // exactlyOne contains the remaining nodes\n    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n\n    // pick one node to delete that favors the delete hint\n    // otherwise pick one with least space from priSet if it is not empty\n    // otherwise one node with least space from remains\n    boolean firstOne \u003d true;\n    final DatanodeStorageInfo delNodeHintStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n    final DatanodeStorageInfo addedNodeStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n\n    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n      final DatanodeStorageInfo cur;\n      if (firstOne \u0026\u0026 useDelHint(delNodeHintStorage, addedNodeStorage,\n          moreThanOne, exactlyOne, excessTypes)) {\n        cur \u003d delNodeHintStorage;\n      } else { // regular excessive replica removal\n        cur \u003d chooseReplicaToDelete(moreThanOne, exactlyOne, excessTypes);\n      }\n      firstOne \u003d false;\n      if (cur \u003d\u003d null) {\n        LOG.warn(\"No excess replica can be found. excessTypes: {}.\" +\n            \" moreThanOne: {}. exactlyOne: {}.\", excessTypes, moreThanOne,\n            exactlyOne);\n        break;\n      }\n\n      // adjust rackmap, moreThanOne, and exactlyOne\n      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n      excessReplicas.add(cur);\n    }\n    return excessReplicas;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "d565480da2f646b40c3180e1ccb2935c9863dfef": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9313. Possible NullPointerException in BlockManager if no excess replica can be chosen. (mingma)\n",
      "commitDate": "02/11/15 7:36 PM",
      "commitName": "d565480da2f646b40c3180e1ccb2935c9863dfef",
      "commitAuthor": "Ming Ma",
      "commitDateOld": "31/10/15 1:20 AM",
      "commitNameOld": "7fd6416759cbb202ed21b47d28c1587e04a5cdc6",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 2.8,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,52 @@\n   public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n       Collection\u003cDatanodeStorageInfo\u003e candidates,\n       int expectedNumOfReplicas,\n       List\u003cStorageType\u003e excessTypes,\n       DatanodeDescriptor addedNode,\n       DatanodeDescriptor delNodeHint) {\n \n     List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n \n     final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n \n     final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n     final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n \n     // split nodes into two sets\n     // moreThanOne contains nodes on rack with more than one replica\n     // exactlyOne contains the remaining nodes\n     splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n \n     // pick one node to delete that favors the delete hint\n     // otherwise pick one with least space from priSet if it is not empty\n     // otherwise one node with least space from remains\n     boolean firstOne \u003d true;\n     final DatanodeStorageInfo delNodeHintStorage \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n     final DatanodeStorageInfo addedNodeStorage \u003d\n         DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n \n     while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n       final DatanodeStorageInfo cur;\n       if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n           moreThanOne, excessTypes)) {\n         cur \u003d delNodeHintStorage;\n       } else { // regular excessive replica removal\n         cur \u003d\n             chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n                 excessTypes);\n       }\n       firstOne \u003d false;\n+      if (cur \u003d\u003d null) {\n+        LOG.warn(\"No excess replica can be found. excessTypes: {}.\" +\n+            \" moreThanOne: {}. exactlyOne: {}.\", excessTypes, moreThanOne,\n+            exactlyOne);\n+        break;\n+      }\n \n       // adjust rackmap, moreThanOne, and exactlyOne\n       adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n       excessReplicas.add(cur);\n     }\n     return excessReplicas;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e candidates,\n      int expectedNumOfReplicas,\n      List\u003cStorageType\u003e excessTypes,\n      DatanodeDescriptor addedNode,\n      DatanodeDescriptor delNodeHint) {\n\n    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n\n    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n\n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n\n    // split nodes into two sets\n    // moreThanOne contains nodes on rack with more than one replica\n    // exactlyOne contains the remaining nodes\n    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n\n    // pick one node to delete that favors the delete hint\n    // otherwise pick one with least space from priSet if it is not empty\n    // otherwise one node with least space from remains\n    boolean firstOne \u003d true;\n    final DatanodeStorageInfo delNodeHintStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n    final DatanodeStorageInfo addedNodeStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n\n    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n      final DatanodeStorageInfo cur;\n      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n          moreThanOne, excessTypes)) {\n        cur \u003d delNodeHintStorage;\n      } else { // regular excessive replica removal\n        cur \u003d\n            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n                excessTypes);\n      }\n      firstOne \u003d false;\n      if (cur \u003d\u003d null) {\n        LOG.warn(\"No excess replica can be found. excessTypes: {}.\" +\n            \" moreThanOne: {}. exactlyOne: {}.\", excessTypes, moreThanOne,\n            exactlyOne);\n        break;\n      }\n\n      // adjust rackmap, moreThanOne, and exactlyOne\n      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n      excessReplicas.add(cur);\n    }\n    return excessReplicas;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "e27c2ae8bafc94f18eb38f5d839dcef5652d424e": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ybodychange,Yparametermetachange)",
      "commitMessage": "HDFS-8647. Abstract BlockManager\u0027s rack policy into BlockPlacementPolicy. (Brahma Reddy Battula via mingma)\n",
      "commitDate": "21/10/15 8:06 AM",
      "commitName": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
      "commitAuthor": "Ming Ma",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-8647. Abstract BlockManager\u0027s rack policy into BlockPlacementPolicy. (Brahma Reddy Battula via mingma)\n",
          "commitDate": "21/10/15 8:06 AM",
          "commitName": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "12/10/15 4:24 PM",
          "commitNameOld": "0f5f9846edab3ea7e80f35000072136f998bcd46",
          "commitAuthorOld": "Lei Xu",
          "daysBetweenCommits": 8.65,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,46 @@\n-  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n-      Block block, short replicationFactor,\n-      Collection\u003cDatanodeStorageInfo\u003e first,\n-      Collection\u003cDatanodeStorageInfo\u003e second,\n-      final List\u003cStorageType\u003e excessTypes) {\n-    long oldestHeartbeat \u003d\n-      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n-    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n-    long minSpace \u003d Long.MAX_VALUE;\n-    DatanodeStorageInfo minSpaceStorage \u003d null;\n+  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n+      Collection\u003cDatanodeStorageInfo\u003e candidates,\n+      int expectedNumOfReplicas,\n+      List\u003cStorageType\u003e excessTypes,\n+      DatanodeDescriptor addedNode,\n+      DatanodeDescriptor delNodeHint) {\n \n-    // Pick the node with the oldest heartbeat or with the least free space,\n-    // if all hearbeats are within the tolerable heartbeat interval\n-    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n-      if (!excessTypes.contains(storage.getStorageType())) {\n-        continue;\n-      }\n+    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n \n-      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n-      long free \u003d node.getRemaining();\n-      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n-      if (lastHeartbeat \u003c oldestHeartbeat) {\n-        oldestHeartbeat \u003d lastHeartbeat;\n-        oldestHeartbeatStorage \u003d storage;\n+    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n+\n+    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n+\n+    // split nodes into two sets\n+    // moreThanOne contains nodes on rack with more than one replica\n+    // exactlyOne contains the remaining nodes\n+    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n+\n+    // pick one node to delete that favors the delete hint\n+    // otherwise pick one with least space from priSet if it is not empty\n+    // otherwise one node with least space from remains\n+    boolean firstOne \u003d true;\n+    final DatanodeStorageInfo delNodeHintStorage \u003d\n+        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n+    final DatanodeStorageInfo addedNodeStorage \u003d\n+        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n+\n+    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n+      final DatanodeStorageInfo cur;\n+      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n+          moreThanOne, excessTypes)) {\n+        cur \u003d delNodeHintStorage;\n+      } else { // regular excessive replica removal\n+        cur \u003d\n+            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n+                excessTypes);\n       }\n-      if (minSpace \u003e free) {\n-        minSpace \u003d free;\n-        minSpaceStorage \u003d storage;\n-      }\n+      firstOne \u003d false;\n+\n+      // adjust rackmap, moreThanOne, and exactlyOne\n+      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n+      excessReplicas.add(cur);\n     }\n-\n-    final DatanodeStorageInfo storage;\n-    if (oldestHeartbeatStorage !\u003d null) {\n-      storage \u003d oldestHeartbeatStorage;\n-    } else if (minSpaceStorage !\u003d null) {\n-      storage \u003d minSpaceStorage;\n-    } else {\n-      return null;\n-    }\n-    excessTypes.remove(storage.getStorageType());\n-    return storage;\n+    return excessReplicas;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e candidates,\n      int expectedNumOfReplicas,\n      List\u003cStorageType\u003e excessTypes,\n      DatanodeDescriptor addedNode,\n      DatanodeDescriptor delNodeHint) {\n\n    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n\n    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n\n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n\n    // split nodes into two sets\n    // moreThanOne contains nodes on rack with more than one replica\n    // exactlyOne contains the remaining nodes\n    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n\n    // pick one node to delete that favors the delete hint\n    // otherwise pick one with least space from priSet if it is not empty\n    // otherwise one node with least space from remains\n    boolean firstOne \u003d true;\n    final DatanodeStorageInfo delNodeHintStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n    final DatanodeStorageInfo addedNodeStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n\n    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n      final DatanodeStorageInfo cur;\n      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n          moreThanOne, excessTypes)) {\n        cur \u003d delNodeHintStorage;\n      } else { // regular excessive replica removal\n        cur \u003d\n            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n                excessTypes);\n      }\n      firstOne \u003d false;\n\n      // adjust rackmap, moreThanOne, and exactlyOne\n      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n      excessReplicas.add(cur);\n    }\n    return excessReplicas;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "chooseReplicaToDelete",
            "newValue": "chooseReplicasToDelete"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-8647. Abstract BlockManager\u0027s rack policy into BlockPlacementPolicy. (Brahma Reddy Battula via mingma)\n",
          "commitDate": "21/10/15 8:06 AM",
          "commitName": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "12/10/15 4:24 PM",
          "commitNameOld": "0f5f9846edab3ea7e80f35000072136f998bcd46",
          "commitAuthorOld": "Lei Xu",
          "daysBetweenCommits": 8.65,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,46 @@\n-  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n-      Block block, short replicationFactor,\n-      Collection\u003cDatanodeStorageInfo\u003e first,\n-      Collection\u003cDatanodeStorageInfo\u003e second,\n-      final List\u003cStorageType\u003e excessTypes) {\n-    long oldestHeartbeat \u003d\n-      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n-    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n-    long minSpace \u003d Long.MAX_VALUE;\n-    DatanodeStorageInfo minSpaceStorage \u003d null;\n+  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n+      Collection\u003cDatanodeStorageInfo\u003e candidates,\n+      int expectedNumOfReplicas,\n+      List\u003cStorageType\u003e excessTypes,\n+      DatanodeDescriptor addedNode,\n+      DatanodeDescriptor delNodeHint) {\n \n-    // Pick the node with the oldest heartbeat or with the least free space,\n-    // if all hearbeats are within the tolerable heartbeat interval\n-    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n-      if (!excessTypes.contains(storage.getStorageType())) {\n-        continue;\n-      }\n+    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n \n-      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n-      long free \u003d node.getRemaining();\n-      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n-      if (lastHeartbeat \u003c oldestHeartbeat) {\n-        oldestHeartbeat \u003d lastHeartbeat;\n-        oldestHeartbeatStorage \u003d storage;\n+    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n+\n+    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n+\n+    // split nodes into two sets\n+    // moreThanOne contains nodes on rack with more than one replica\n+    // exactlyOne contains the remaining nodes\n+    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n+\n+    // pick one node to delete that favors the delete hint\n+    // otherwise pick one with least space from priSet if it is not empty\n+    // otherwise one node with least space from remains\n+    boolean firstOne \u003d true;\n+    final DatanodeStorageInfo delNodeHintStorage \u003d\n+        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n+    final DatanodeStorageInfo addedNodeStorage \u003d\n+        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n+\n+    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n+      final DatanodeStorageInfo cur;\n+      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n+          moreThanOne, excessTypes)) {\n+        cur \u003d delNodeHintStorage;\n+      } else { // regular excessive replica removal\n+        cur \u003d\n+            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n+                excessTypes);\n       }\n-      if (minSpace \u003e free) {\n-        minSpace \u003d free;\n-        minSpaceStorage \u003d storage;\n-      }\n+      firstOne \u003d false;\n+\n+      // adjust rackmap, moreThanOne, and exactlyOne\n+      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n+      excessReplicas.add(cur);\n     }\n-\n-    final DatanodeStorageInfo storage;\n-    if (oldestHeartbeatStorage !\u003d null) {\n-      storage \u003d oldestHeartbeatStorage;\n-    } else if (minSpaceStorage !\u003d null) {\n-      storage \u003d minSpaceStorage;\n-    } else {\n-      return null;\n-    }\n-    excessTypes.remove(storage.getStorageType());\n-    return storage;\n+    return excessReplicas;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e candidates,\n      int expectedNumOfReplicas,\n      List\u003cStorageType\u003e excessTypes,\n      DatanodeDescriptor addedNode,\n      DatanodeDescriptor delNodeHint) {\n\n    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n\n    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n\n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n\n    // split nodes into two sets\n    // moreThanOne contains nodes on rack with more than one replica\n    // exactlyOne contains the remaining nodes\n    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n\n    // pick one node to delete that favors the delete hint\n    // otherwise pick one with least space from priSet if it is not empty\n    // otherwise one node with least space from remains\n    boolean firstOne \u003d true;\n    final DatanodeStorageInfo delNodeHintStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n    final DatanodeStorageInfo addedNodeStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n\n    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n      final DatanodeStorageInfo cur;\n      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n          moreThanOne, excessTypes)) {\n        cur \u003d delNodeHintStorage;\n      } else { // regular excessive replica removal\n        cur \u003d\n            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n                excessTypes);\n      }\n      firstOne \u003d false;\n\n      // adjust rackmap, moreThanOne, and exactlyOne\n      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n      excessReplicas.add(cur);\n    }\n    return excessReplicas;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "[bc-BlockCollection, block-Block, replicationFactor-short, first-Collection\u003cDatanodeStorageInfo\u003e, second-Collection\u003cDatanodeStorageInfo\u003e, excessTypes-List\u003cStorageType\u003e(modifiers-final)]",
            "newValue": "[candidates-Collection\u003cDatanodeStorageInfo\u003e, expectedNumOfReplicas-int, excessTypes-List\u003cStorageType\u003e, addedNode-DatanodeDescriptor, delNodeHint-DatanodeDescriptor]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-8647. Abstract BlockManager\u0027s rack policy into BlockPlacementPolicy. (Brahma Reddy Battula via mingma)\n",
          "commitDate": "21/10/15 8:06 AM",
          "commitName": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "12/10/15 4:24 PM",
          "commitNameOld": "0f5f9846edab3ea7e80f35000072136f998bcd46",
          "commitAuthorOld": "Lei Xu",
          "daysBetweenCommits": 8.65,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,46 @@\n-  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n-      Block block, short replicationFactor,\n-      Collection\u003cDatanodeStorageInfo\u003e first,\n-      Collection\u003cDatanodeStorageInfo\u003e second,\n-      final List\u003cStorageType\u003e excessTypes) {\n-    long oldestHeartbeat \u003d\n-      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n-    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n-    long minSpace \u003d Long.MAX_VALUE;\n-    DatanodeStorageInfo minSpaceStorage \u003d null;\n+  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n+      Collection\u003cDatanodeStorageInfo\u003e candidates,\n+      int expectedNumOfReplicas,\n+      List\u003cStorageType\u003e excessTypes,\n+      DatanodeDescriptor addedNode,\n+      DatanodeDescriptor delNodeHint) {\n \n-    // Pick the node with the oldest heartbeat or with the least free space,\n-    // if all hearbeats are within the tolerable heartbeat interval\n-    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n-      if (!excessTypes.contains(storage.getStorageType())) {\n-        continue;\n-      }\n+    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n \n-      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n-      long free \u003d node.getRemaining();\n-      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n-      if (lastHeartbeat \u003c oldestHeartbeat) {\n-        oldestHeartbeat \u003d lastHeartbeat;\n-        oldestHeartbeatStorage \u003d storage;\n+    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n+\n+    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n+\n+    // split nodes into two sets\n+    // moreThanOne contains nodes on rack with more than one replica\n+    // exactlyOne contains the remaining nodes\n+    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n+\n+    // pick one node to delete that favors the delete hint\n+    // otherwise pick one with least space from priSet if it is not empty\n+    // otherwise one node with least space from remains\n+    boolean firstOne \u003d true;\n+    final DatanodeStorageInfo delNodeHintStorage \u003d\n+        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n+    final DatanodeStorageInfo addedNodeStorage \u003d\n+        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n+\n+    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n+      final DatanodeStorageInfo cur;\n+      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n+          moreThanOne, excessTypes)) {\n+        cur \u003d delNodeHintStorage;\n+      } else { // regular excessive replica removal\n+        cur \u003d\n+            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n+                excessTypes);\n       }\n-      if (minSpace \u003e free) {\n-        minSpace \u003d free;\n-        minSpaceStorage \u003d storage;\n-      }\n+      firstOne \u003d false;\n+\n+      // adjust rackmap, moreThanOne, and exactlyOne\n+      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n+      excessReplicas.add(cur);\n     }\n-\n-    final DatanodeStorageInfo storage;\n-    if (oldestHeartbeatStorage !\u003d null) {\n-      storage \u003d oldestHeartbeatStorage;\n-    } else if (minSpaceStorage !\u003d null) {\n-      storage \u003d minSpaceStorage;\n-    } else {\n-      return null;\n-    }\n-    excessTypes.remove(storage.getStorageType());\n-    return storage;\n+    return excessReplicas;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e candidates,\n      int expectedNumOfReplicas,\n      List\u003cStorageType\u003e excessTypes,\n      DatanodeDescriptor addedNode,\n      DatanodeDescriptor delNodeHint) {\n\n    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n\n    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n\n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n\n    // split nodes into two sets\n    // moreThanOne contains nodes on rack with more than one replica\n    // exactlyOne contains the remaining nodes\n    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n\n    // pick one node to delete that favors the delete hint\n    // otherwise pick one with least space from priSet if it is not empty\n    // otherwise one node with least space from remains\n    boolean firstOne \u003d true;\n    final DatanodeStorageInfo delNodeHintStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n    final DatanodeStorageInfo addedNodeStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n\n    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n      final DatanodeStorageInfo cur;\n      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n          moreThanOne, excessTypes)) {\n        cur \u003d delNodeHintStorage;\n      } else { // regular excessive replica removal\n        cur \u003d\n            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n                excessTypes);\n      }\n      firstOne \u003d false;\n\n      // adjust rackmap, moreThanOne, and exactlyOne\n      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n      excessReplicas.add(cur);\n    }\n    return excessReplicas;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "DatanodeStorageInfo",
            "newValue": "List\u003cDatanodeStorageInfo\u003e"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-8647. Abstract BlockManager\u0027s rack policy into BlockPlacementPolicy. (Brahma Reddy Battula via mingma)\n",
          "commitDate": "21/10/15 8:06 AM",
          "commitName": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "12/10/15 4:24 PM",
          "commitNameOld": "0f5f9846edab3ea7e80f35000072136f998bcd46",
          "commitAuthorOld": "Lei Xu",
          "daysBetweenCommits": 8.65,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,46 @@\n-  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n-      Block block, short replicationFactor,\n-      Collection\u003cDatanodeStorageInfo\u003e first,\n-      Collection\u003cDatanodeStorageInfo\u003e second,\n-      final List\u003cStorageType\u003e excessTypes) {\n-    long oldestHeartbeat \u003d\n-      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n-    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n-    long minSpace \u003d Long.MAX_VALUE;\n-    DatanodeStorageInfo minSpaceStorage \u003d null;\n+  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n+      Collection\u003cDatanodeStorageInfo\u003e candidates,\n+      int expectedNumOfReplicas,\n+      List\u003cStorageType\u003e excessTypes,\n+      DatanodeDescriptor addedNode,\n+      DatanodeDescriptor delNodeHint) {\n \n-    // Pick the node with the oldest heartbeat or with the least free space,\n-    // if all hearbeats are within the tolerable heartbeat interval\n-    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n-      if (!excessTypes.contains(storage.getStorageType())) {\n-        continue;\n-      }\n+    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n \n-      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n-      long free \u003d node.getRemaining();\n-      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n-      if (lastHeartbeat \u003c oldestHeartbeat) {\n-        oldestHeartbeat \u003d lastHeartbeat;\n-        oldestHeartbeatStorage \u003d storage;\n+    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n+\n+    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n+\n+    // split nodes into two sets\n+    // moreThanOne contains nodes on rack with more than one replica\n+    // exactlyOne contains the remaining nodes\n+    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n+\n+    // pick one node to delete that favors the delete hint\n+    // otherwise pick one with least space from priSet if it is not empty\n+    // otherwise one node with least space from remains\n+    boolean firstOne \u003d true;\n+    final DatanodeStorageInfo delNodeHintStorage \u003d\n+        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n+    final DatanodeStorageInfo addedNodeStorage \u003d\n+        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n+\n+    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n+      final DatanodeStorageInfo cur;\n+      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n+          moreThanOne, excessTypes)) {\n+        cur \u003d delNodeHintStorage;\n+      } else { // regular excessive replica removal\n+        cur \u003d\n+            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n+                excessTypes);\n       }\n-      if (minSpace \u003e free) {\n-        minSpace \u003d free;\n-        minSpaceStorage \u003d storage;\n-      }\n+      firstOne \u003d false;\n+\n+      // adjust rackmap, moreThanOne, and exactlyOne\n+      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n+      excessReplicas.add(cur);\n     }\n-\n-    final DatanodeStorageInfo storage;\n-    if (oldestHeartbeatStorage !\u003d null) {\n-      storage \u003d oldestHeartbeatStorage;\n-    } else if (minSpaceStorage !\u003d null) {\n-      storage \u003d minSpaceStorage;\n-    } else {\n-      return null;\n-    }\n-    excessTypes.remove(storage.getStorageType());\n-    return storage;\n+    return excessReplicas;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e candidates,\n      int expectedNumOfReplicas,\n      List\u003cStorageType\u003e excessTypes,\n      DatanodeDescriptor addedNode,\n      DatanodeDescriptor delNodeHint) {\n\n    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n\n    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n\n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n\n    // split nodes into two sets\n    // moreThanOne contains nodes on rack with more than one replica\n    // exactlyOne contains the remaining nodes\n    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n\n    // pick one node to delete that favors the delete hint\n    // otherwise pick one with least space from priSet if it is not empty\n    // otherwise one node with least space from remains\n    boolean firstOne \u003d true;\n    final DatanodeStorageInfo delNodeHintStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n    final DatanodeStorageInfo addedNodeStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n\n    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n      final DatanodeStorageInfo cur;\n      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n          moreThanOne, excessTypes)) {\n        cur \u003d delNodeHintStorage;\n      } else { // regular excessive replica removal\n        cur \u003d\n            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n                excessTypes);\n      }\n      firstOne \u003d false;\n\n      // adjust rackmap, moreThanOne, and exactlyOne\n      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n      excessReplicas.add(cur);\n    }\n    return excessReplicas;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HDFS-8647. Abstract BlockManager\u0027s rack policy into BlockPlacementPolicy. (Brahma Reddy Battula via mingma)\n",
          "commitDate": "21/10/15 8:06 AM",
          "commitName": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "12/10/15 4:24 PM",
          "commitNameOld": "0f5f9846edab3ea7e80f35000072136f998bcd46",
          "commitAuthorOld": "Lei Xu",
          "daysBetweenCommits": 8.65,
          "commitsBetweenForRepo": 75,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,42 +1,46 @@\n-  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n-      Block block, short replicationFactor,\n-      Collection\u003cDatanodeStorageInfo\u003e first,\n-      Collection\u003cDatanodeStorageInfo\u003e second,\n-      final List\u003cStorageType\u003e excessTypes) {\n-    long oldestHeartbeat \u003d\n-      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n-    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n-    long minSpace \u003d Long.MAX_VALUE;\n-    DatanodeStorageInfo minSpaceStorage \u003d null;\n+  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n+      Collection\u003cDatanodeStorageInfo\u003e candidates,\n+      int expectedNumOfReplicas,\n+      List\u003cStorageType\u003e excessTypes,\n+      DatanodeDescriptor addedNode,\n+      DatanodeDescriptor delNodeHint) {\n \n-    // Pick the node with the oldest heartbeat or with the least free space,\n-    // if all hearbeats are within the tolerable heartbeat interval\n-    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n-      if (!excessTypes.contains(storage.getStorageType())) {\n-        continue;\n-      }\n+    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n \n-      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n-      long free \u003d node.getRemaining();\n-      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n-      if (lastHeartbeat \u003c oldestHeartbeat) {\n-        oldestHeartbeat \u003d lastHeartbeat;\n-        oldestHeartbeatStorage \u003d storage;\n+    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n+\n+    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n+    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n+\n+    // split nodes into two sets\n+    // moreThanOne contains nodes on rack with more than one replica\n+    // exactlyOne contains the remaining nodes\n+    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n+\n+    // pick one node to delete that favors the delete hint\n+    // otherwise pick one with least space from priSet if it is not empty\n+    // otherwise one node with least space from remains\n+    boolean firstOne \u003d true;\n+    final DatanodeStorageInfo delNodeHintStorage \u003d\n+        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n+    final DatanodeStorageInfo addedNodeStorage \u003d\n+        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n+\n+    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n+      final DatanodeStorageInfo cur;\n+      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n+          moreThanOne, excessTypes)) {\n+        cur \u003d delNodeHintStorage;\n+      } else { // regular excessive replica removal\n+        cur \u003d\n+            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n+                excessTypes);\n       }\n-      if (minSpace \u003e free) {\n-        minSpace \u003d free;\n-        minSpaceStorage \u003d storage;\n-      }\n+      firstOne \u003d false;\n+\n+      // adjust rackmap, moreThanOne, and exactlyOne\n+      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n+      excessReplicas.add(cur);\n     }\n-\n-    final DatanodeStorageInfo storage;\n-    if (oldestHeartbeatStorage !\u003d null) {\n-      storage \u003d oldestHeartbeatStorage;\n-    } else if (minSpaceStorage !\u003d null) {\n-      storage \u003d minSpaceStorage;\n-    } else {\n-      return null;\n-    }\n-    excessTypes.remove(storage.getStorageType());\n-    return storage;\n+    return excessReplicas;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public List\u003cDatanodeStorageInfo\u003e chooseReplicasToDelete(\n      Collection\u003cDatanodeStorageInfo\u003e candidates,\n      int expectedNumOfReplicas,\n      List\u003cStorageType\u003e excessTypes,\n      DatanodeDescriptor addedNode,\n      DatanodeDescriptor delNodeHint) {\n\n    List\u003cDatanodeStorageInfo\u003e excessReplicas \u003d new ArrayList\u003c\u003e();\n\n    final Map\u003cString, List\u003cDatanodeStorageInfo\u003e\u003e rackMap \u003d new HashMap\u003c\u003e();\n\n    final List\u003cDatanodeStorageInfo\u003e moreThanOne \u003d new ArrayList\u003c\u003e();\n    final List\u003cDatanodeStorageInfo\u003e exactlyOne \u003d new ArrayList\u003c\u003e();\n\n    // split nodes into two sets\n    // moreThanOne contains nodes on rack with more than one replica\n    // exactlyOne contains the remaining nodes\n    splitNodesWithRack(candidates, rackMap, moreThanOne, exactlyOne);\n\n    // pick one node to delete that favors the delete hint\n    // otherwise pick one with least space from priSet if it is not empty\n    // otherwise one node with least space from remains\n    boolean firstOne \u003d true;\n    final DatanodeStorageInfo delNodeHintStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, delNodeHint);\n    final DatanodeStorageInfo addedNodeStorage \u003d\n        DatanodeStorageInfo.getDatanodeStorageInfo(candidates, addedNode);\n\n    while (candidates.size() - expectedNumOfReplicas \u003e excessReplicas.size()) {\n      final DatanodeStorageInfo cur;\n      if (useDelHint(firstOne, delNodeHintStorage, addedNodeStorage,\n          moreThanOne, excessTypes)) {\n        cur \u003d delNodeHintStorage;\n      } else { // regular excessive replica removal\n        cur \u003d\n            chooseReplicaToDelete((short) expectedNumOfReplicas, moreThanOne, exactlyOne,\n                excessTypes);\n      }\n      firstOne \u003d false;\n\n      // adjust rackmap, moreThanOne, and exactlyOne\n      adjustSetsWithChosenReplica(rackMap, moreThanOne, exactlyOne, cur);\n      excessReplicas.add(cur);\n    }\n    return excessReplicas;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
          "extendedDetails": {
            "oldValue": "[bc-BlockCollection, block-Block, replicationFactor-short, first-Collection\u003cDatanodeStorageInfo\u003e, second-Collection\u003cDatanodeStorageInfo\u003e, excessTypes-List\u003cStorageType\u003e(modifiers-final)]",
            "newValue": "[candidates-Collection\u003cDatanodeStorageInfo\u003e, expectedNumOfReplicas-int, excessTypes-List\u003cStorageType\u003e, addedNode-DatanodeDescriptor, delNodeHint-DatanodeDescriptor]"
          }
        }
      ]
    },
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6841. Use Time.monotonicNow() wherever applicable instead of Time.now(). Contributed by Vinayakumar B\n",
      "commitDate": "20/03/15 12:02 PM",
      "commitName": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "21/02/15 3:38 PM",
      "commitNameOld": "8b465b4b8caed31ca9daeaae108f9a868a30a455",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 26.81,
      "commitsBetweenForRepo": 229,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n       Block block, short replicationFactor,\n       Collection\u003cDatanodeStorageInfo\u003e first,\n       Collection\u003cDatanodeStorageInfo\u003e second,\n       final List\u003cStorageType\u003e excessTypes) {\n     long oldestHeartbeat \u003d\n-      now() - heartbeatInterval * tolerateHeartbeatMultiplier;\n+      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n     DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n     long minSpace \u003d Long.MAX_VALUE;\n     DatanodeStorageInfo minSpaceStorage \u003d null;\n \n     // Pick the node with the oldest heartbeat or with the least free space,\n     // if all hearbeats are within the tolerable heartbeat interval\n     for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n       if (!excessTypes.contains(storage.getStorageType())) {\n         continue;\n       }\n \n       final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n       long free \u003d node.getRemaining();\n-      long lastHeartbeat \u003d node.getLastUpdate();\n-      if(lastHeartbeat \u003c oldestHeartbeat) {\n+      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n+      if (lastHeartbeat \u003c oldestHeartbeat) {\n         oldestHeartbeat \u003d lastHeartbeat;\n         oldestHeartbeatStorage \u003d storage;\n       }\n       if (minSpace \u003e free) {\n         minSpace \u003d free;\n         minSpaceStorage \u003d storage;\n       }\n     }\n \n     final DatanodeStorageInfo storage;\n     if (oldestHeartbeatStorage !\u003d null) {\n       storage \u003d oldestHeartbeatStorage;\n     } else if (minSpaceStorage !\u003d null) {\n       storage \u003d minSpaceStorage;\n     } else {\n       return null;\n     }\n     excessTypes.remove(storage.getStorageType());\n     return storage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n      Block block, short replicationFactor,\n      Collection\u003cDatanodeStorageInfo\u003e first,\n      Collection\u003cDatanodeStorageInfo\u003e second,\n      final List\u003cStorageType\u003e excessTypes) {\n    long oldestHeartbeat \u003d\n      monotonicNow() - heartbeatInterval * tolerateHeartbeatMultiplier;\n    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n    long minSpace \u003d Long.MAX_VALUE;\n    DatanodeStorageInfo minSpaceStorage \u003d null;\n\n    // Pick the node with the oldest heartbeat or with the least free space,\n    // if all hearbeats are within the tolerable heartbeat interval\n    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n      if (!excessTypes.contains(storage.getStorageType())) {\n        continue;\n      }\n\n      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n      long free \u003d node.getRemaining();\n      long lastHeartbeat \u003d node.getLastUpdateMonotonic();\n      if (lastHeartbeat \u003c oldestHeartbeat) {\n        oldestHeartbeat \u003d lastHeartbeat;\n        oldestHeartbeatStorage \u003d storage;\n      }\n      if (minSpace \u003e free) {\n        minSpace \u003d free;\n        minSpaceStorage \u003d storage;\n      }\n    }\n\n    final DatanodeStorageInfo storage;\n    if (oldestHeartbeatStorage !\u003d null) {\n      storage \u003d oldestHeartbeatStorage;\n    } else if (minSpaceStorage !\u003d null) {\n      storage \u003d minSpaceStorage;\n    } else {\n      return null;\n    }\n    excessTypes.remove(storage.getStorageType());\n    return storage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    },
    "b7ded466b00db0fe273058b844d56d810e0f8cc2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6920. Archival Storage: check the storage type of delNodeHintStorage when deleting a replica. Contributed by Tsz Wo Nicholas Sze.\n",
      "commitDate": "27/08/14 2:08 PM",
      "commitName": "b7ded466b00db0fe273058b844d56d810e0f8cc2",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "21/08/14 4:42 PM",
      "commitNameOld": "e69954d22cc97eb3818c8ee7c3f623a5d0497b54",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.89,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,42 @@\n   public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n       Block block, short replicationFactor,\n       Collection\u003cDatanodeStorageInfo\u003e first,\n       Collection\u003cDatanodeStorageInfo\u003e second,\n       final List\u003cStorageType\u003e excessTypes) {\n     long oldestHeartbeat \u003d\n       now() - heartbeatInterval * tolerateHeartbeatMultiplier;\n     DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n     long minSpace \u003d Long.MAX_VALUE;\n     DatanodeStorageInfo minSpaceStorage \u003d null;\n \n     // Pick the node with the oldest heartbeat or with the least free space,\n     // if all hearbeats are within the tolerable heartbeat interval\n     for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n       if (!excessTypes.contains(storage.getStorageType())) {\n         continue;\n       }\n \n       final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n       long free \u003d node.getRemaining();\n       long lastHeartbeat \u003d node.getLastUpdate();\n       if(lastHeartbeat \u003c oldestHeartbeat) {\n         oldestHeartbeat \u003d lastHeartbeat;\n         oldestHeartbeatStorage \u003d storage;\n       }\n       if (minSpace \u003e free) {\n         minSpace \u003d free;\n         minSpaceStorage \u003d storage;\n       }\n     }\n-    final DatanodeStorageInfo storage \u003d oldestHeartbeatStorage !\u003d null?\n-        oldestHeartbeatStorage : minSpaceStorage;\n+\n+    final DatanodeStorageInfo storage;\n+    if (oldestHeartbeatStorage !\u003d null) {\n+      storage \u003d oldestHeartbeatStorage;\n+    } else if (minSpaceStorage !\u003d null) {\n+      storage \u003d minSpaceStorage;\n+    } else {\n+      return null;\n+    }\n     excessTypes.remove(storage.getStorageType());\n     return storage;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public DatanodeStorageInfo chooseReplicaToDelete(BlockCollection bc,\n      Block block, short replicationFactor,\n      Collection\u003cDatanodeStorageInfo\u003e first,\n      Collection\u003cDatanodeStorageInfo\u003e second,\n      final List\u003cStorageType\u003e excessTypes) {\n    long oldestHeartbeat \u003d\n      now() - heartbeatInterval * tolerateHeartbeatMultiplier;\n    DatanodeStorageInfo oldestHeartbeatStorage \u003d null;\n    long minSpace \u003d Long.MAX_VALUE;\n    DatanodeStorageInfo minSpaceStorage \u003d null;\n\n    // Pick the node with the oldest heartbeat or with the least free space,\n    // if all hearbeats are within the tolerable heartbeat interval\n    for(DatanodeStorageInfo storage : pickupReplicaSet(first, second)) {\n      if (!excessTypes.contains(storage.getStorageType())) {\n        continue;\n      }\n\n      final DatanodeDescriptor node \u003d storage.getDatanodeDescriptor();\n      long free \u003d node.getRemaining();\n      long lastHeartbeat \u003d node.getLastUpdate();\n      if(lastHeartbeat \u003c oldestHeartbeat) {\n        oldestHeartbeat \u003d lastHeartbeat;\n        oldestHeartbeatStorage \u003d storage;\n      }\n      if (minSpace \u003e free) {\n        minSpace \u003d free;\n        minSpaceStorage \u003d storage;\n      }\n    }\n\n    final DatanodeStorageInfo storage;\n    if (oldestHeartbeatStorage !\u003d null) {\n      storage \u003d oldestHeartbeatStorage;\n    } else if (minSpaceStorage !\u003d null) {\n      storage \u003d minSpaceStorage;\n    } else {\n      return null;\n    }\n    excessTypes.remove(storage.getStorageType());\n    return storage;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockPlacementPolicyDefault.java",
      "extendedDetails": {}
    }
  }
}