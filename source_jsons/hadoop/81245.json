{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NetworkTopology.java",
  "functionName": "chooseRandom",
  "functionId": "chooseRandom___scope-String(modifiers-final)__excludedScope-String__excludedNodes-Collection__Node__(modifiers-final)",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
  "functionStartLine": 487,
  "functionEndLine": 543,
  "numCommitsSeen": 80,
  "timeTaken": 5143,
  "changeHistory": [
    "1189af4746919774035f5d64ccb4d2ce21905aaa",
    "f4e18242bd8117a5c506ec6d3f25c85011fa82d0",
    "57374c4737ab0fccf52dae3cea911fc6bd90e1b7",
    "dcc292d7ded200a4976f6d348952ecba10f01db2",
    "6b0933643835d7696ced011cfdb8b74f63022e8b",
    "b90fc70d671481564e468550c770c925f25d7db0",
    "1268cf5fbe4458fa75ad0662512d352f9e8d3470",
    "c6c3247dc0dcb8c72ea00f3fb14a0879fcf49c56",
    "02fcb6b6bae7c3fe2a10b00b2a563e4098ff225e",
    "df6e1ab4916e41810f092474a1f3abd9845d9956",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36"
  ],
  "changeHistoryShort": {
    "1189af4746919774035f5d64ccb4d2ce21905aaa": "Ybodychange",
    "f4e18242bd8117a5c506ec6d3f25c85011fa82d0": "Ybodychange",
    "57374c4737ab0fccf52dae3cea911fc6bd90e1b7": "Ybodychange",
    "dcc292d7ded200a4976f6d348952ecba10f01db2": "Ybodychange",
    "6b0933643835d7696ced011cfdb8b74f63022e8b": "Ymodifierchange",
    "b90fc70d671481564e468550c770c925f25d7db0": "Ybodychange",
    "1268cf5fbe4458fa75ad0662512d352f9e8d3470": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
    "c6c3247dc0dcb8c72ea00f3fb14a0879fcf49c56": "Ybodychange",
    "02fcb6b6bae7c3fe2a10b00b2a563e4098ff225e": "Ybodychange",
    "df6e1ab4916e41810f092474a1f3abd9845d9956": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": "Yintroduced"
  },
  "changeHistoryDetails": {
    "1189af4746919774035f5d64ccb4d2ce21905aaa": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15263. Fix the logic of scope and excluded scope in Network Topology. Contributed by Ayush Saxena.\n",
      "commitDate": "08/04/20 3:25 AM",
      "commitName": "1189af4746919774035f5d64ccb4d2ce21905aaa",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "17/02/20 11:13 AM",
      "commitNameOld": "84f763884021980c456e2ebc21c1a1c1b18fec6c",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 50.63,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,57 @@\n   protected Node chooseRandom(final String scope, String excludedScope,\n       final Collection\u003cNode\u003e excludedNodes) {\n     if (excludedScope !\u003d null) {\n-      if (scope.startsWith(excludedScope)) {\n+      if (isChildScope(scope, excludedScope)) {\n         return null;\n       }\n-      if (!excludedScope.startsWith(scope)) {\n+      if (!isChildScope(excludedScope, scope)) {\n         excludedScope \u003d null;\n       }\n     }\n     Node node \u003d getNode(scope);\n     if (!(node instanceof InnerNode)) {\n       return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n           null : node;\n     }\n     InnerNode innerNode \u003d (InnerNode)node;\n     int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n     if (excludedScope \u003d\u003d null) {\n       node \u003d null;\n     } else {\n       node \u003d getNode(excludedScope);\n       if (!(node instanceof InnerNode)) {\n         numOfDatanodes -\u003d 1;\n       } else {\n         numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n       }\n     }\n     if (numOfDatanodes \u003c\u003d 0) {\n       LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\"\n               + \" numOfDatanodes\u003d{}\",\n           scope, excludedScope, numOfDatanodes);\n       return null;\n     }\n     final int availableNodes;\n     if (excludedScope \u003d\u003d null) {\n       availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n     } else {\n       netlock.readLock().lock();\n       try {\n         availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes) -\n             countNumOfAvailableNodes(excludedScope, excludedNodes);\n       } finally {\n         netlock.readLock().unlock();\n       }\n     }\n     LOG.debug(\"Choosing random from {} available nodes on node {},\"\n         + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}. numOfDatanodes\u003d{}.\",\n         availableNodes, innerNode, scope, excludedScope, excludedNodes,\n         numOfDatanodes);\n     Node ret \u003d null;\n     if (availableNodes \u003e 0) {\n       ret \u003d chooseRandom(innerNode, node, excludedNodes, numOfDatanodes,\n           availableNodes);\n     }\n     LOG.debug(\"chooseRandom returning {}\", ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Node chooseRandom(final String scope, String excludedScope,\n      final Collection\u003cNode\u003e excludedNodes) {\n    if (excludedScope !\u003d null) {\n      if (isChildScope(scope, excludedScope)) {\n        return null;\n      }\n      if (!isChildScope(excludedScope, scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n          null : node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    if (numOfDatanodes \u003c\u003d 0) {\n      LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\"\n              + \" numOfDatanodes\u003d{}\",\n          scope, excludedScope, numOfDatanodes);\n      return null;\n    }\n    final int availableNodes;\n    if (excludedScope \u003d\u003d null) {\n      availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n    } else {\n      netlock.readLock().lock();\n      try {\n        availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes) -\n            countNumOfAvailableNodes(excludedScope, excludedNodes);\n      } finally {\n        netlock.readLock().unlock();\n      }\n    }\n    LOG.debug(\"Choosing random from {} available nodes on node {},\"\n        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}. numOfDatanodes\u003d{}.\",\n        availableNodes, innerNode, scope, excludedScope, excludedNodes,\n        numOfDatanodes);\n    Node ret \u003d null;\n    if (availableNodes \u003e 0) {\n      ret \u003d chooseRandom(innerNode, node, excludedNodes, numOfDatanodes,\n          availableNodes);\n    }\n    LOG.debug(\"chooseRandom returning {}\", ret);\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {}
    },
    "f4e18242bd8117a5c506ec6d3f25c85011fa82d0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16028. Fix NetworkTopology chooseRandom function to support excluded nodes. Contributed by Sihai Ke.\n",
      "commitDate": "04/01/19 9:56 AM",
      "commitName": "f4e18242bd8117a5c506ec6d3f25c85011fa82d0",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "10/10/18 9:51 PM",
      "commitNameOld": "7b57f2f71fbaa5af4897309597cca70a95b04edd",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 85.55,
      "commitsBetweenForRepo": 632,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,57 @@\n   protected Node chooseRandom(final String scope, String excludedScope,\n       final Collection\u003cNode\u003e excludedNodes) {\n     if (excludedScope !\u003d null) {\n       if (scope.startsWith(excludedScope)) {\n         return null;\n       }\n       if (!excludedScope.startsWith(scope)) {\n         excludedScope \u003d null;\n       }\n     }\n     Node node \u003d getNode(scope);\n     if (!(node instanceof InnerNode)) {\n       return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n           null : node;\n     }\n     InnerNode innerNode \u003d (InnerNode)node;\n     int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n     if (excludedScope \u003d\u003d null) {\n       node \u003d null;\n     } else {\n       node \u003d getNode(excludedScope);\n       if (!(node instanceof InnerNode)) {\n         numOfDatanodes -\u003d 1;\n       } else {\n         numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n       }\n     }\n     if (numOfDatanodes \u003c\u003d 0) {\n       LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\"\n               + \" numOfDatanodes\u003d{}\",\n           scope, excludedScope, numOfDatanodes);\n       return null;\n     }\n     final int availableNodes;\n     if (excludedScope \u003d\u003d null) {\n       availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n     } else {\n-      availableNodes \u003d\n-          countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n+      netlock.readLock().lock();\n+      try {\n+        availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes) -\n+            countNumOfAvailableNodes(excludedScope, excludedNodes);\n+      } finally {\n+        netlock.readLock().unlock();\n+      }\n     }\n     LOG.debug(\"Choosing random from {} available nodes on node {},\"\n         + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}. numOfDatanodes\u003d{}.\",\n         availableNodes, innerNode, scope, excludedScope, excludedNodes,\n         numOfDatanodes);\n     Node ret \u003d null;\n     if (availableNodes \u003e 0) {\n       ret \u003d chooseRandom(innerNode, node, excludedNodes, numOfDatanodes,\n           availableNodes);\n     }\n     LOG.debug(\"chooseRandom returning {}\", ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Node chooseRandom(final String scope, String excludedScope,\n      final Collection\u003cNode\u003e excludedNodes) {\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n          null : node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    if (numOfDatanodes \u003c\u003d 0) {\n      LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\"\n              + \" numOfDatanodes\u003d{}\",\n          scope, excludedScope, numOfDatanodes);\n      return null;\n    }\n    final int availableNodes;\n    if (excludedScope \u003d\u003d null) {\n      availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n    } else {\n      netlock.readLock().lock();\n      try {\n        availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes) -\n            countNumOfAvailableNodes(excludedScope, excludedNodes);\n      } finally {\n        netlock.readLock().unlock();\n      }\n    }\n    LOG.debug(\"Choosing random from {} available nodes on node {},\"\n        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}. numOfDatanodes\u003d{}.\",\n        availableNodes, innerNode, scope, excludedScope, excludedNodes,\n        numOfDatanodes);\n    Node ret \u003d null;\n    if (availableNodes \u003e 0) {\n      ret \u003d chooseRandom(innerNode, node, excludedNodes, numOfDatanodes,\n          availableNodes);\n    }\n    LOG.debug(\"chooseRandom returning {}\", ret);\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {}
    },
    "57374c4737ab0fccf52dae3cea911fc6bd90e1b7": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15317. Improve NetworkTopology chooseRandom\u0027s loop.\n",
      "commitDate": "02/04/18 10:48 PM",
      "commitName": "57374c4737ab0fccf52dae3cea911fc6bd90e1b7",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "29/06/17 12:28 PM",
      "commitNameOld": "5a75f73893567151f525950cc1a15b3f1bfeac26",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 277.43,
      "commitsBetweenForRepo": 2098,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,52 @@\n   protected Node chooseRandom(final String scope, String excludedScope,\n       final Collection\u003cNode\u003e excludedNodes) {\n     if (excludedScope !\u003d null) {\n       if (scope.startsWith(excludedScope)) {\n         return null;\n       }\n       if (!excludedScope.startsWith(scope)) {\n         excludedScope \u003d null;\n       }\n     }\n     Node node \u003d getNode(scope);\n     if (!(node instanceof InnerNode)) {\n       return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n           null : node;\n     }\n     InnerNode innerNode \u003d (InnerNode)node;\n     int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n     if (excludedScope \u003d\u003d null) {\n       node \u003d null;\n     } else {\n       node \u003d getNode(excludedScope);\n       if (!(node instanceof InnerNode)) {\n         numOfDatanodes -\u003d 1;\n       } else {\n         numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n       }\n     }\n-    if (numOfDatanodes \u003d\u003d 0) {\n-      LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n-          scope, excludedScope);\n+    if (numOfDatanodes \u003c\u003d 0) {\n+      LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\"\n+              + \" numOfDatanodes\u003d{}\",\n+          scope, excludedScope, numOfDatanodes);\n       return null;\n     }\n-    Node ret \u003d null;\n     final int availableNodes;\n     if (excludedScope \u003d\u003d null) {\n       availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n     } else {\n       availableNodes \u003d\n           countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n     }\n     LOG.debug(\"Choosing random from {} available nodes on node {},\"\n-        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n-        innerNode, scope, excludedScope, excludedNodes);\n+        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}. numOfDatanodes\u003d{}.\",\n+        availableNodes, innerNode, scope, excludedScope, excludedNodes,\n+        numOfDatanodes);\n+    Node ret \u003d null;\n     if (availableNodes \u003e 0) {\n-      do {\n-        int leaveIndex \u003d r.nextInt(numOfDatanodes);\n-        ret \u003d innerNode.getLeaf(leaveIndex, node);\n-        if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n-          break;\n-        } else {\n-          LOG.debug(\"Node {} is excluded, continuing.\", ret);\n-        }\n-        // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n-        // at least 1 satisfying node. Keep trying until we found it.\n-      } while (true);\n+      ret \u003d chooseRandom(innerNode, node, excludedNodes, numOfDatanodes,\n+          availableNodes);\n     }\n     LOG.debug(\"chooseRandom returning {}\", ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Node chooseRandom(final String scope, String excludedScope,\n      final Collection\u003cNode\u003e excludedNodes) {\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n          null : node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    if (numOfDatanodes \u003c\u003d 0) {\n      LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\"\n              + \" numOfDatanodes\u003d{}\",\n          scope, excludedScope, numOfDatanodes);\n      return null;\n    }\n    final int availableNodes;\n    if (excludedScope \u003d\u003d null) {\n      availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n    } else {\n      availableNodes \u003d\n          countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n    }\n    LOG.debug(\"Choosing random from {} available nodes on node {},\"\n        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}. numOfDatanodes\u003d{}.\",\n        availableNodes, innerNode, scope, excludedScope, excludedNodes,\n        numOfDatanodes);\n    Node ret \u003d null;\n    if (availableNodes \u003e 0) {\n      ret \u003d chooseRandom(innerNode, node, excludedNodes, numOfDatanodes,\n          availableNodes);\n    }\n    LOG.debug(\"chooseRandom returning {}\", ret);\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {}
    },
    "dcc292d7ded200a4976f6d348952ecba10f01db2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14369. NetworkTopology calls expensive toString() when logging. Contributed by Inigo Goiri.\n",
      "commitDate": "02/05/17 10:51 AM",
      "commitName": "dcc292d7ded200a4976f6d348952ecba10f01db2",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "28/03/17 8:02 AM",
      "commitNameOld": "6b0933643835d7696ced011cfdb8b74f63022e8b",
      "commitAuthorOld": "Yiqun Lin",
      "daysBetweenCommits": 35.12,
      "commitsBetweenForRepo": 202,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   protected Node chooseRandom(final String scope, String excludedScope,\n       final Collection\u003cNode\u003e excludedNodes) {\n     if (excludedScope !\u003d null) {\n       if (scope.startsWith(excludedScope)) {\n         return null;\n       }\n       if (!excludedScope.startsWith(scope)) {\n         excludedScope \u003d null;\n       }\n     }\n     Node node \u003d getNode(scope);\n     if (!(node instanceof InnerNode)) {\n       return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n           null : node;\n     }\n     InnerNode innerNode \u003d (InnerNode)node;\n     int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n     if (excludedScope \u003d\u003d null) {\n       node \u003d null;\n     } else {\n       node \u003d getNode(excludedScope);\n       if (!(node instanceof InnerNode)) {\n         numOfDatanodes -\u003d 1;\n       } else {\n         numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n       }\n     }\n     if (numOfDatanodes \u003d\u003d 0) {\n       LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n-          String.valueOf(scope), String.valueOf(excludedScope));\n+          scope, excludedScope);\n       return null;\n     }\n     Node ret \u003d null;\n     final int availableNodes;\n     if (excludedScope \u003d\u003d null) {\n       availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n     } else {\n       availableNodes \u003d\n           countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n     }\n     LOG.debug(\"Choosing random from {} available nodes on node {},\"\n         + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n-        innerNode.toString(), scope, excludedScope, excludedNodes);\n+        innerNode, scope, excludedScope, excludedNodes);\n     if (availableNodes \u003e 0) {\n       do {\n         int leaveIndex \u003d r.nextInt(numOfDatanodes);\n         ret \u003d innerNode.getLeaf(leaveIndex, node);\n         if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n           break;\n         } else {\n           LOG.debug(\"Node {} is excluded, continuing.\", ret);\n         }\n         // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n         // at least 1 satisfying node. Keep trying until we found it.\n       } while (true);\n     }\n     LOG.debug(\"chooseRandom returning {}\", ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Node chooseRandom(final String scope, String excludedScope,\n      final Collection\u003cNode\u003e excludedNodes) {\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n          null : node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    if (numOfDatanodes \u003d\u003d 0) {\n      LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n          scope, excludedScope);\n      return null;\n    }\n    Node ret \u003d null;\n    final int availableNodes;\n    if (excludedScope \u003d\u003d null) {\n      availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n    } else {\n      availableNodes \u003d\n          countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n    }\n    LOG.debug(\"Choosing random from {} available nodes on node {},\"\n        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n        innerNode, scope, excludedScope, excludedNodes);\n    if (availableNodes \u003e 0) {\n      do {\n        int leaveIndex \u003d r.nextInt(numOfDatanodes);\n        ret \u003d innerNode.getLeaf(leaveIndex, node);\n        if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n          break;\n        } else {\n          LOG.debug(\"Node {} is excluded, continuing.\", ret);\n        }\n        // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n        // at least 1 satisfying node. Keep trying until we found it.\n      } while (true);\n    }\n    LOG.debug(\"chooseRandom returning {}\", ret);\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {}
    },
    "6b0933643835d7696ced011cfdb8b74f63022e8b": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-11577. Combine the old and the new chooseRandom for better performance. Contributed by Chen Liang.\n",
      "commitDate": "28/03/17 8:02 AM",
      "commitName": "6b0933643835d7696ced011cfdb8b74f63022e8b",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "02/03/17 9:21 AM",
      "commitNameOld": "eeca8b0c4e2804b0fee5b012ea14b58383425ec3",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 25.9,
      "commitsBetweenForRepo": 159,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n-  private Node chooseRandom(final String scope, String excludedScope,\n+  protected Node chooseRandom(final String scope, String excludedScope,\n       final Collection\u003cNode\u003e excludedNodes) {\n     if (excludedScope !\u003d null) {\n       if (scope.startsWith(excludedScope)) {\n         return null;\n       }\n       if (!excludedScope.startsWith(scope)) {\n         excludedScope \u003d null;\n       }\n     }\n     Node node \u003d getNode(scope);\n     if (!(node instanceof InnerNode)) {\n       return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n           null : node;\n     }\n     InnerNode innerNode \u003d (InnerNode)node;\n     int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n     if (excludedScope \u003d\u003d null) {\n       node \u003d null;\n     } else {\n       node \u003d getNode(excludedScope);\n       if (!(node instanceof InnerNode)) {\n         numOfDatanodes -\u003d 1;\n       } else {\n         numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n       }\n     }\n     if (numOfDatanodes \u003d\u003d 0) {\n       LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n           String.valueOf(scope), String.valueOf(excludedScope));\n       return null;\n     }\n     Node ret \u003d null;\n     final int availableNodes;\n     if (excludedScope \u003d\u003d null) {\n       availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n     } else {\n       availableNodes \u003d\n           countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n     }\n     LOG.debug(\"Choosing random from {} available nodes on node {},\"\n         + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n         innerNode.toString(), scope, excludedScope, excludedNodes);\n     if (availableNodes \u003e 0) {\n       do {\n         int leaveIndex \u003d r.nextInt(numOfDatanodes);\n         ret \u003d innerNode.getLeaf(leaveIndex, node);\n         if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n           break;\n         } else {\n           LOG.debug(\"Node {} is excluded, continuing.\", ret);\n         }\n         // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n         // at least 1 satisfying node. Keep trying until we found it.\n       } while (true);\n     }\n     LOG.debug(\"chooseRandom returning {}\", ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected Node chooseRandom(final String scope, String excludedScope,\n      final Collection\u003cNode\u003e excludedNodes) {\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n          null : node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    if (numOfDatanodes \u003d\u003d 0) {\n      LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n          String.valueOf(scope), String.valueOf(excludedScope));\n      return null;\n    }\n    Node ret \u003d null;\n    final int availableNodes;\n    if (excludedScope \u003d\u003d null) {\n      availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n    } else {\n      availableNodes \u003d\n          countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n    }\n    LOG.debug(\"Choosing random from {} available nodes on node {},\"\n        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n        innerNode.toString(), scope, excludedScope, excludedNodes);\n    if (availableNodes \u003e 0) {\n      do {\n        int leaveIndex \u003d r.nextInt(numOfDatanodes);\n        ret \u003d innerNode.getLeaf(leaveIndex, node);\n        if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n          break;\n        } else {\n          LOG.debug(\"Node {} is excluded, continuing.\", ret);\n        }\n        // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n        // at least 1 satisfying node. Keep trying until we found it.\n      } while (true);\n    }\n    LOG.debug(\"chooseRandom returning {}\", ret);\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[protected]"
      }
    },
    "b90fc70d671481564e468550c770c925f25d7db0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10963. Reduce log level when network topology cannot find enough datanodes. Contributed by Xiao chen\n",
      "commitDate": "06/10/16 5:17 AM",
      "commitName": "b90fc70d671481564e468550c770c925f25d7db0",
      "commitAuthor": "Brahma Reddy Battula",
      "commitDateOld": "16/05/16 6:49 PM",
      "commitNameOld": "61f46be071e42f9eb49a54b1bd2e54feac59f808",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 142.44,
      "commitsBetweenForRepo": 1062,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   private Node chooseRandom(final String scope, String excludedScope,\n       final Collection\u003cNode\u003e excludedNodes) {\n     if (excludedScope !\u003d null) {\n       if (scope.startsWith(excludedScope)) {\n         return null;\n       }\n       if (!excludedScope.startsWith(scope)) {\n         excludedScope \u003d null;\n       }\n     }\n     Node node \u003d getNode(scope);\n     if (!(node instanceof InnerNode)) {\n       return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n           null : node;\n     }\n     InnerNode innerNode \u003d (InnerNode)node;\n     int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n     if (excludedScope \u003d\u003d null) {\n       node \u003d null;\n     } else {\n       node \u003d getNode(excludedScope);\n       if (!(node instanceof InnerNode)) {\n         numOfDatanodes -\u003d 1;\n       } else {\n         numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n       }\n     }\n     if (numOfDatanodes \u003d\u003d 0) {\n-      LOG.warn(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n+      LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n           String.valueOf(scope), String.valueOf(excludedScope));\n       return null;\n     }\n     Node ret \u003d null;\n     final int availableNodes;\n     if (excludedScope \u003d\u003d null) {\n       availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n     } else {\n       availableNodes \u003d\n           countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n     }\n     LOG.debug(\"Choosing random from {} available nodes on node {},\"\n         + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n         innerNode.toString(), scope, excludedScope, excludedNodes);\n     if (availableNodes \u003e 0) {\n       do {\n         int leaveIndex \u003d r.nextInt(numOfDatanodes);\n         ret \u003d innerNode.getLeaf(leaveIndex, node);\n         if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n           break;\n         } else {\n           LOG.debug(\"Node {} is excluded, continuing.\", ret);\n         }\n         // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n         // at least 1 satisfying node. Keep trying until we found it.\n       } while (true);\n     }\n     LOG.debug(\"chooseRandom returning {}\", ret);\n     return ret;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Node chooseRandom(final String scope, String excludedScope,\n      final Collection\u003cNode\u003e excludedNodes) {\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n          null : node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    if (numOfDatanodes \u003d\u003d 0) {\n      LOG.debug(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n          String.valueOf(scope), String.valueOf(excludedScope));\n      return null;\n    }\n    Node ret \u003d null;\n    final int availableNodes;\n    if (excludedScope \u003d\u003d null) {\n      availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n    } else {\n      availableNodes \u003d\n          countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n    }\n    LOG.debug(\"Choosing random from {} available nodes on node {},\"\n        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n        innerNode.toString(), scope, excludedScope, excludedNodes);\n    if (availableNodes \u003e 0) {\n      do {\n        int leaveIndex \u003d r.nextInt(numOfDatanodes);\n        ret \u003d innerNode.getLeaf(leaveIndex, node);\n        if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n          break;\n        } else {\n          LOG.debug(\"Node {} is excluded, continuing.\", ret);\n        }\n        // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n        // at least 1 satisfying node. Keep trying until we found it.\n      } while (true);\n    }\n    LOG.debug(\"chooseRandom returning {}\", ret);\n    return ret;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {}
    },
    "1268cf5fbe4458fa75ad0662512d352f9e8d3470": {
      "type": "Ymultichange(Yparameterchange,Ybodychange,Yparametermetachange)",
      "commitMessage": "HDFS-10320. Rack failures may result in NN terminate. (Xiao Chen via mingma)\n",
      "commitDate": "04/05/16 5:02 PM",
      "commitName": "1268cf5fbe4458fa75ad0662512d352f9e8d3470",
      "commitAuthor": "Ming Ma",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10320. Rack failures may result in NN terminate. (Xiao Chen via mingma)\n",
          "commitDate": "04/05/16 5:02 PM",
          "commitName": "1268cf5fbe4458fa75ad0662512d352f9e8d3470",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "19/03/16 2:02 PM",
          "commitNameOld": "cd8b6889a74a949e37f4b2eb664cdf3b59bfb93b",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 46.13,
          "commitsBetweenForRepo": 277,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,59 @@\n-  private Node chooseRandom(String scope, String excludedScope){\n+  private Node chooseRandom(final String scope, String excludedScope,\n+      final Collection\u003cNode\u003e excludedNodes) {\n     if (excludedScope !\u003d null) {\n       if (scope.startsWith(excludedScope)) {\n         return null;\n       }\n       if (!excludedScope.startsWith(scope)) {\n         excludedScope \u003d null;\n       }\n     }\n     Node node \u003d getNode(scope);\n     if (!(node instanceof InnerNode)) {\n-      return node;\n+      return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n+          null : node;\n     }\n     InnerNode innerNode \u003d (InnerNode)node;\n     int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n     if (excludedScope \u003d\u003d null) {\n       node \u003d null;\n     } else {\n       node \u003d getNode(excludedScope);\n       if (!(node instanceof InnerNode)) {\n         numOfDatanodes -\u003d 1;\n       } else {\n         numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n       }\n     }\n     if (numOfDatanodes \u003d\u003d 0) {\n-      throw new InvalidTopologyException(\n-          \"Failed to find datanode (scope\u003d\\\"\" + String.valueOf(scope) +\n-          \"\\\" excludedScope\u003d\\\"\" + String.valueOf(excludedScope) + \"\\\").\");\n+      LOG.warn(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n+          String.valueOf(scope), String.valueOf(excludedScope));\n+      return null;\n     }\n-    int leaveIndex \u003d r.nextInt(numOfDatanodes);\n-    return innerNode.getLeaf(leaveIndex, node);\n+    Node ret \u003d null;\n+    final int availableNodes;\n+    if (excludedScope \u003d\u003d null) {\n+      availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n+    } else {\n+      availableNodes \u003d\n+          countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n+    }\n+    LOG.debug(\"Choosing random from {} available nodes on node {},\"\n+        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n+        innerNode.toString(), scope, excludedScope, excludedNodes);\n+    if (availableNodes \u003e 0) {\n+      do {\n+        int leaveIndex \u003d r.nextInt(numOfDatanodes);\n+        ret \u003d innerNode.getLeaf(leaveIndex, node);\n+        if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n+          break;\n+        } else {\n+          LOG.debug(\"Node {} is excluded, continuing.\", ret);\n+        }\n+        // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n+        // at least 1 satisfying node. Keep trying until we found it.\n+      } while (true);\n+    }\n+    LOG.debug(\"chooseRandom returning {}\", ret);\n+    return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Node chooseRandom(final String scope, String excludedScope,\n      final Collection\u003cNode\u003e excludedNodes) {\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n          null : node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    if (numOfDatanodes \u003d\u003d 0) {\n      LOG.warn(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n          String.valueOf(scope), String.valueOf(excludedScope));\n      return null;\n    }\n    Node ret \u003d null;\n    final int availableNodes;\n    if (excludedScope \u003d\u003d null) {\n      availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n    } else {\n      availableNodes \u003d\n          countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n    }\n    LOG.debug(\"Choosing random from {} available nodes on node {},\"\n        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n        innerNode.toString(), scope, excludedScope, excludedNodes);\n    if (availableNodes \u003e 0) {\n      do {\n        int leaveIndex \u003d r.nextInt(numOfDatanodes);\n        ret \u003d innerNode.getLeaf(leaveIndex, node);\n        if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n          break;\n        } else {\n          LOG.debug(\"Node {} is excluded, continuing.\", ret);\n        }\n        // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n        // at least 1 satisfying node. Keep trying until we found it.\n      } while (true);\n    }\n    LOG.debug(\"chooseRandom returning {}\", ret);\n    return ret;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
          "extendedDetails": {
            "oldValue": "[scope-String, excludedScope-String]",
            "newValue": "[scope-String(modifiers-final), excludedScope-String, excludedNodes-Collection\u003cNode\u003e(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10320. Rack failures may result in NN terminate. (Xiao Chen via mingma)\n",
          "commitDate": "04/05/16 5:02 PM",
          "commitName": "1268cf5fbe4458fa75ad0662512d352f9e8d3470",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "19/03/16 2:02 PM",
          "commitNameOld": "cd8b6889a74a949e37f4b2eb664cdf3b59bfb93b",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 46.13,
          "commitsBetweenForRepo": 277,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,59 @@\n-  private Node chooseRandom(String scope, String excludedScope){\n+  private Node chooseRandom(final String scope, String excludedScope,\n+      final Collection\u003cNode\u003e excludedNodes) {\n     if (excludedScope !\u003d null) {\n       if (scope.startsWith(excludedScope)) {\n         return null;\n       }\n       if (!excludedScope.startsWith(scope)) {\n         excludedScope \u003d null;\n       }\n     }\n     Node node \u003d getNode(scope);\n     if (!(node instanceof InnerNode)) {\n-      return node;\n+      return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n+          null : node;\n     }\n     InnerNode innerNode \u003d (InnerNode)node;\n     int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n     if (excludedScope \u003d\u003d null) {\n       node \u003d null;\n     } else {\n       node \u003d getNode(excludedScope);\n       if (!(node instanceof InnerNode)) {\n         numOfDatanodes -\u003d 1;\n       } else {\n         numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n       }\n     }\n     if (numOfDatanodes \u003d\u003d 0) {\n-      throw new InvalidTopologyException(\n-          \"Failed to find datanode (scope\u003d\\\"\" + String.valueOf(scope) +\n-          \"\\\" excludedScope\u003d\\\"\" + String.valueOf(excludedScope) + \"\\\").\");\n+      LOG.warn(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n+          String.valueOf(scope), String.valueOf(excludedScope));\n+      return null;\n     }\n-    int leaveIndex \u003d r.nextInt(numOfDatanodes);\n-    return innerNode.getLeaf(leaveIndex, node);\n+    Node ret \u003d null;\n+    final int availableNodes;\n+    if (excludedScope \u003d\u003d null) {\n+      availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n+    } else {\n+      availableNodes \u003d\n+          countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n+    }\n+    LOG.debug(\"Choosing random from {} available nodes on node {},\"\n+        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n+        innerNode.toString(), scope, excludedScope, excludedNodes);\n+    if (availableNodes \u003e 0) {\n+      do {\n+        int leaveIndex \u003d r.nextInt(numOfDatanodes);\n+        ret \u003d innerNode.getLeaf(leaveIndex, node);\n+        if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n+          break;\n+        } else {\n+          LOG.debug(\"Node {} is excluded, continuing.\", ret);\n+        }\n+        // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n+        // at least 1 satisfying node. Keep trying until we found it.\n+      } while (true);\n+    }\n+    LOG.debug(\"chooseRandom returning {}\", ret);\n+    return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Node chooseRandom(final String scope, String excludedScope,\n      final Collection\u003cNode\u003e excludedNodes) {\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n          null : node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    if (numOfDatanodes \u003d\u003d 0) {\n      LOG.warn(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n          String.valueOf(scope), String.valueOf(excludedScope));\n      return null;\n    }\n    Node ret \u003d null;\n    final int availableNodes;\n    if (excludedScope \u003d\u003d null) {\n      availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n    } else {\n      availableNodes \u003d\n          countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n    }\n    LOG.debug(\"Choosing random from {} available nodes on node {},\"\n        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n        innerNode.toString(), scope, excludedScope, excludedNodes);\n    if (availableNodes \u003e 0) {\n      do {\n        int leaveIndex \u003d r.nextInt(numOfDatanodes);\n        ret \u003d innerNode.getLeaf(leaveIndex, node);\n        if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n          break;\n        } else {\n          LOG.debug(\"Node {} is excluded, continuing.\", ret);\n        }\n        // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n        // at least 1 satisfying node. Keep trying until we found it.\n      } while (true);\n    }\n    LOG.debug(\"chooseRandom returning {}\", ret);\n    return ret;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HDFS-10320. Rack failures may result in NN terminate. (Xiao Chen via mingma)\n",
          "commitDate": "04/05/16 5:02 PM",
          "commitName": "1268cf5fbe4458fa75ad0662512d352f9e8d3470",
          "commitAuthor": "Ming Ma",
          "commitDateOld": "19/03/16 2:02 PM",
          "commitNameOld": "cd8b6889a74a949e37f4b2eb664cdf3b59bfb93b",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 46.13,
          "commitsBetweenForRepo": 277,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,33 +1,59 @@\n-  private Node chooseRandom(String scope, String excludedScope){\n+  private Node chooseRandom(final String scope, String excludedScope,\n+      final Collection\u003cNode\u003e excludedNodes) {\n     if (excludedScope !\u003d null) {\n       if (scope.startsWith(excludedScope)) {\n         return null;\n       }\n       if (!excludedScope.startsWith(scope)) {\n         excludedScope \u003d null;\n       }\n     }\n     Node node \u003d getNode(scope);\n     if (!(node instanceof InnerNode)) {\n-      return node;\n+      return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n+          null : node;\n     }\n     InnerNode innerNode \u003d (InnerNode)node;\n     int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n     if (excludedScope \u003d\u003d null) {\n       node \u003d null;\n     } else {\n       node \u003d getNode(excludedScope);\n       if (!(node instanceof InnerNode)) {\n         numOfDatanodes -\u003d 1;\n       } else {\n         numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n       }\n     }\n     if (numOfDatanodes \u003d\u003d 0) {\n-      throw new InvalidTopologyException(\n-          \"Failed to find datanode (scope\u003d\\\"\" + String.valueOf(scope) +\n-          \"\\\" excludedScope\u003d\\\"\" + String.valueOf(excludedScope) + \"\\\").\");\n+      LOG.warn(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n+          String.valueOf(scope), String.valueOf(excludedScope));\n+      return null;\n     }\n-    int leaveIndex \u003d r.nextInt(numOfDatanodes);\n-    return innerNode.getLeaf(leaveIndex, node);\n+    Node ret \u003d null;\n+    final int availableNodes;\n+    if (excludedScope \u003d\u003d null) {\n+      availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n+    } else {\n+      availableNodes \u003d\n+          countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n+    }\n+    LOG.debug(\"Choosing random from {} available nodes on node {},\"\n+        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n+        innerNode.toString(), scope, excludedScope, excludedNodes);\n+    if (availableNodes \u003e 0) {\n+      do {\n+        int leaveIndex \u003d r.nextInt(numOfDatanodes);\n+        ret \u003d innerNode.getLeaf(leaveIndex, node);\n+        if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n+          break;\n+        } else {\n+          LOG.debug(\"Node {} is excluded, continuing.\", ret);\n+        }\n+        // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n+        // at least 1 satisfying node. Keep trying until we found it.\n+      } while (true);\n+    }\n+    LOG.debug(\"chooseRandom returning {}\", ret);\n+    return ret;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private Node chooseRandom(final String scope, String excludedScope,\n      final Collection\u003cNode\u003e excludedNodes) {\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return excludedNodes !\u003d null \u0026\u0026 excludedNodes.contains(node) ?\n          null : node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    if (numOfDatanodes \u003d\u003d 0) {\n      LOG.warn(\"Failed to find datanode (scope\u003d\\\"{}\\\" excludedScope\u003d\\\"{}\\\").\",\n          String.valueOf(scope), String.valueOf(excludedScope));\n      return null;\n    }\n    Node ret \u003d null;\n    final int availableNodes;\n    if (excludedScope \u003d\u003d null) {\n      availableNodes \u003d countNumOfAvailableNodes(scope, excludedNodes);\n    } else {\n      availableNodes \u003d\n          countNumOfAvailableNodes(\"~\" + excludedScope, excludedNodes);\n    }\n    LOG.debug(\"Choosing random from {} available nodes on node {},\"\n        + \" scope\u003d{}, excludedScope\u003d{}, excludeNodes\u003d{}\", availableNodes,\n        innerNode.toString(), scope, excludedScope, excludedNodes);\n    if (availableNodes \u003e 0) {\n      do {\n        int leaveIndex \u003d r.nextInt(numOfDatanodes);\n        ret \u003d innerNode.getLeaf(leaveIndex, node);\n        if (excludedNodes \u003d\u003d null || !excludedNodes.contains(ret)) {\n          break;\n        } else {\n          LOG.debug(\"Node {} is excluded, continuing.\", ret);\n        }\n        // We\u0027ve counted numOfAvailableNodes inside the lock, so there must be\n        // at least 1 satisfying node. Keep trying until we found it.\n      } while (true);\n    }\n    LOG.debug(\"chooseRandom returning {}\", ret);\n    return ret;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
          "extendedDetails": {
            "oldValue": "[scope-String, excludedScope-String]",
            "newValue": "[scope-String(modifiers-final), excludedScope-String, excludedNodes-Collection\u003cNode\u003e(modifiers-final)]"
          }
        }
      ]
    },
    "c6c3247dc0dcb8c72ea00f3fb14a0879fcf49c56": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7122. Use of ThreadLocal\u003cRandom\u003e results in poor block placement. (wang)\n",
      "commitDate": "29/09/14 3:00 PM",
      "commitName": "c6c3247dc0dcb8c72ea00f3fb14a0879fcf49c56",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "21/09/14 10:55 PM",
      "commitNameOld": "eab15af12c114eef4e9abd9af2ba03b0ab2cc441",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 7.67,
      "commitsBetweenForRepo": 83,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   private Node chooseRandom(String scope, String excludedScope){\n     if (excludedScope !\u003d null) {\n       if (scope.startsWith(excludedScope)) {\n         return null;\n       }\n       if (!excludedScope.startsWith(scope)) {\n         excludedScope \u003d null;\n       }\n     }\n     Node node \u003d getNode(scope);\n     if (!(node instanceof InnerNode)) {\n       return node;\n     }\n     InnerNode innerNode \u003d (InnerNode)node;\n     int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n     if (excludedScope \u003d\u003d null) {\n       node \u003d null;\n     } else {\n       node \u003d getNode(excludedScope);\n       if (!(node instanceof InnerNode)) {\n         numOfDatanodes -\u003d 1;\n       } else {\n         numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n       }\n     }\n     if (numOfDatanodes \u003d\u003d 0) {\n       throw new InvalidTopologyException(\n           \"Failed to find datanode (scope\u003d\\\"\" + String.valueOf(scope) +\n           \"\\\" excludedScope\u003d\\\"\" + String.valueOf(excludedScope) + \"\\\").\");\n     }\n-    int leaveIndex \u003d getRandom().nextInt(numOfDatanodes);\n+    int leaveIndex \u003d r.nextInt(numOfDatanodes);\n     return innerNode.getLeaf(leaveIndex, node);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Node chooseRandom(String scope, String excludedScope){\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    if (numOfDatanodes \u003d\u003d 0) {\n      throw new InvalidTopologyException(\n          \"Failed to find datanode (scope\u003d\\\"\" + String.valueOf(scope) +\n          \"\\\" excludedScope\u003d\\\"\" + String.valueOf(excludedScope) + \"\\\").\");\n    }\n    int leaveIndex \u003d r.nextInt(numOfDatanodes);\n    return innerNode.getLeaf(leaveIndex, node);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {}
    },
    "02fcb6b6bae7c3fe2a10b00b2a563e4098ff225e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6268. Better sorting in NetworkTopology#pseudoSortByDistance when no local node is found. (wang)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1599734 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/14 11:33 AM",
      "commitName": "02fcb6b6bae7c3fe2a10b00b2a563e4098ff225e",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "25/02/14 10:36 AM",
      "commitNameOld": "df6e1ab4916e41810f092474a1f3abd9845d9956",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 98.0,
      "commitsBetweenForRepo": 658,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   private Node chooseRandom(String scope, String excludedScope){\n     if (excludedScope !\u003d null) {\n       if (scope.startsWith(excludedScope)) {\n         return null;\n       }\n       if (!excludedScope.startsWith(scope)) {\n         excludedScope \u003d null;\n       }\n     }\n     Node node \u003d getNode(scope);\n     if (!(node instanceof InnerNode)) {\n       return node;\n     }\n     InnerNode innerNode \u003d (InnerNode)node;\n     int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n     if (excludedScope \u003d\u003d null) {\n       node \u003d null;\n     } else {\n       node \u003d getNode(excludedScope);\n       if (!(node instanceof InnerNode)) {\n         numOfDatanodes -\u003d 1;\n       } else {\n         numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n       }\n     }\n     if (numOfDatanodes \u003d\u003d 0) {\n       throw new InvalidTopologyException(\n           \"Failed to find datanode (scope\u003d\\\"\" + String.valueOf(scope) +\n           \"\\\" excludedScope\u003d\\\"\" + String.valueOf(excludedScope) + \"\\\").\");\n     }\n-    int leaveIndex \u003d r.nextInt(numOfDatanodes);\n+    int leaveIndex \u003d getRandom().nextInt(numOfDatanodes);\n     return innerNode.getLeaf(leaveIndex, node);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Node chooseRandom(String scope, String excludedScope){\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    if (numOfDatanodes \u003d\u003d 0) {\n      throw new InvalidTopologyException(\n          \"Failed to find datanode (scope\u003d\\\"\" + String.valueOf(scope) +\n          \"\\\" excludedScope\u003d\\\"\" + String.valueOf(excludedScope) + \"\\\").\");\n    }\n    int leaveIndex \u003d getRandom().nextInt(numOfDatanodes);\n    return innerNode.getLeaf(leaveIndex, node);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {}
    },
    "df6e1ab4916e41810f092474a1f3abd9845d9956": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5939. WebHdfs returns misleading error code and logs nothing if trying to create a file with no DNs in cluster. Contributed by Yongjun Zhang.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1571781 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/02/14 10:36 AM",
      "commitName": "df6e1ab4916e41810f092474a1f3abd9845d9956",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/06/13 6:22 PM",
      "commitNameOld": "b6c7de68bc850ee5fa144eb3ea8d304065dbf4ea",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 243.72,
      "commitsBetweenForRepo": 1541,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,28 +1,33 @@\n   private Node chooseRandom(String scope, String excludedScope){\n     if (excludedScope !\u003d null) {\n       if (scope.startsWith(excludedScope)) {\n         return null;\n       }\n       if (!excludedScope.startsWith(scope)) {\n         excludedScope \u003d null;\n       }\n     }\n     Node node \u003d getNode(scope);\n     if (!(node instanceof InnerNode)) {\n       return node;\n     }\n     InnerNode innerNode \u003d (InnerNode)node;\n     int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n     if (excludedScope \u003d\u003d null) {\n       node \u003d null;\n     } else {\n       node \u003d getNode(excludedScope);\n       if (!(node instanceof InnerNode)) {\n         numOfDatanodes -\u003d 1;\n       } else {\n         numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n       }\n     }\n+    if (numOfDatanodes \u003d\u003d 0) {\n+      throw new InvalidTopologyException(\n+          \"Failed to find datanode (scope\u003d\\\"\" + String.valueOf(scope) +\n+          \"\\\" excludedScope\u003d\\\"\" + String.valueOf(excludedScope) + \"\\\").\");\n+    }\n     int leaveIndex \u003d r.nextInt(numOfDatanodes);\n     return innerNode.getLeaf(leaveIndex, node);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private Node chooseRandom(String scope, String excludedScope){\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    if (numOfDatanodes \u003d\u003d 0) {\n      throw new InvalidTopologyException(\n          \"Failed to find datanode (scope\u003d\\\"\" + String.valueOf(scope) +\n          \"\\\" excludedScope\u003d\\\"\" + String.valueOf(excludedScope) + \"\\\").\");\n    }\n    int leaveIndex \u003d r.nextInt(numOfDatanodes);\n    return innerNode.getLeaf(leaveIndex, node);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private Node chooseRandom(String scope, String excludedScope){\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    int leaveIndex \u003d r.nextInt(numOfDatanodes);\n    return innerNode.getLeaf(leaveIndex, node);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private Node chooseRandom(String scope, String excludedScope){\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    int leaveIndex \u003d r.nextInt(numOfDatanodes);\n    return innerNode.getLeaf(leaveIndex, node);\n  }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/net/NetworkTopology.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/net/NetworkTopology.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private Node chooseRandom(String scope, String excludedScope){\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    int leaveIndex \u003d r.nextInt(numOfDatanodes);\n    return innerNode.getLeaf(leaveIndex, node);\n  }",
      "path": "common/src/java/org/apache/hadoop/net/NetworkTopology.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/net/NetworkTopology.java",
        "newPath": "common/src/java/org/apache/hadoop/net/NetworkTopology.java"
      }
    },
    "5128a9a453d64bfe1ed978cf9ffed27985eeef36": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-4687 Moving src directories on branch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/core/branches/HADOOP-4687/core@776174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/05/09 9:20 PM",
      "commitName": "5128a9a453d64bfe1ed978cf9ffed27985eeef36",
      "commitAuthor": "Owen O\u0027Malley",
      "diff": "@@ -0,0 +1,28 @@\n+  private Node chooseRandom(String scope, String excludedScope){\n+    if (excludedScope !\u003d null) {\n+      if (scope.startsWith(excludedScope)) {\n+        return null;\n+      }\n+      if (!excludedScope.startsWith(scope)) {\n+        excludedScope \u003d null;\n+      }\n+    }\n+    Node node \u003d getNode(scope);\n+    if (!(node instanceof InnerNode)) {\n+      return node;\n+    }\n+    InnerNode innerNode \u003d (InnerNode)node;\n+    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n+    if (excludedScope \u003d\u003d null) {\n+      node \u003d null;\n+    } else {\n+      node \u003d getNode(excludedScope);\n+      if (!(node instanceof InnerNode)) {\n+        numOfDatanodes -\u003d 1;\n+      } else {\n+        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n+      }\n+    }\n+    int leaveIndex \u003d r.nextInt(numOfDatanodes);\n+    return innerNode.getLeaf(leaveIndex, node);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private Node chooseRandom(String scope, String excludedScope){\n    if (excludedScope !\u003d null) {\n      if (scope.startsWith(excludedScope)) {\n        return null;\n      }\n      if (!excludedScope.startsWith(scope)) {\n        excludedScope \u003d null;\n      }\n    }\n    Node node \u003d getNode(scope);\n    if (!(node instanceof InnerNode)) {\n      return node;\n    }\n    InnerNode innerNode \u003d (InnerNode)node;\n    int numOfDatanodes \u003d innerNode.getNumOfLeaves();\n    if (excludedScope \u003d\u003d null) {\n      node \u003d null;\n    } else {\n      node \u003d getNode(excludedScope);\n      if (!(node instanceof InnerNode)) {\n        numOfDatanodes -\u003d 1;\n      } else {\n        numOfDatanodes -\u003d ((InnerNode)node).getNumOfLeaves();\n      }\n    }\n    int leaveIndex \u003d r.nextInt(numOfDatanodes);\n    return innerNode.getLeaf(leaveIndex, node);\n  }",
      "path": "src/java/org/apache/hadoop/net/NetworkTopology.java"
    }
  }
}