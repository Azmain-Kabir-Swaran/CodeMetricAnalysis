{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ValueQueue.java",
  "functionName": "getAtMost",
  "functionId": "getAtMost___keyName-String__num-int",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/ValueQueue.java",
  "functionStartLine": 351,
  "functionEndLine": 396,
  "numCommitsSeen": 12,
  "timeTaken": 1798,
  "changeHistory": [
    "dd0834696a694564af65a1355c9d13275f44df51",
    "2007e0cf2ad371e2dbf533c367f09c1f5acd1c0b",
    "99675e00df65e84dcc02082b795f1f93c90b794e",
    "0c1469ece38556cf02a0c7bd23761d6bf79d9a64"
  ],
  "changeHistoryShort": {
    "dd0834696a694564af65a1355c9d13275f44df51": "Ybodychange",
    "2007e0cf2ad371e2dbf533c367f09c1f5acd1c0b": "Ybodychange",
    "99675e00df65e84dcc02082b795f1f93c90b794e": "Ybodychange",
    "0c1469ece38556cf02a0c7bd23761d6bf79d9a64": "Yintroduced"
  },
  "changeHistoryDetails": {
    "dd0834696a694564af65a1355c9d13275f44df51": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16581. Revise ValueQueue to correctly replenish queues that go below the watermark (#1463)\n\nIn the existing implementation, the ValueQueue::getAtMost() method will only trigger a refill on a key queue if it has gone empty, instead of triggering a refill when it has gone below the watermark. Revise the test suite to correctly verify this behavior.",
      "commitDate": "20/09/19 9:55 AM",
      "commitName": "dd0834696a694564af65a1355c9d13275f44df51",
      "commitAuthor": "Yuval Degani",
      "commitDateOld": "10/10/18 9:51 PM",
      "commitNameOld": "7b57f2f71fbaa5af4897309597cca70a95b04edd",
      "commitAuthorOld": "Takanobu Asanuma",
      "daysBetweenCommits": 344.5,
      "commitsBetweenForRepo": 2643,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,46 @@\n   public List\u003cE\u003e getAtMost(String keyName, int num) throws IOException,\n       ExecutionException {\n     LinkedBlockingQueue\u003cE\u003e keyQueue \u003d keyQueues.get(keyName);\n     // Using poll to avoid race condition..\n     LinkedList\u003cE\u003e ekvs \u003d new LinkedList\u003cE\u003e();\n     try {\n       for (int i \u003d 0; i \u003c num; i++) {\n         readLock(keyName);\n         E val \u003d keyQueue.poll();\n         readUnlock(keyName);\n         // If queue is empty now, Based on the provided SyncGenerationPolicy,\n         // figure out how many new values need to be generated synchronously\n         if (val \u003d\u003d null) {\n           // Synchronous call to get remaining values\n           int numToFill \u003d 0;\n           switch (policy) {\n           case ATLEAST_ONE:\n             numToFill \u003d (ekvs.size() \u003c 1) ? 1 : 0;\n             break;\n           case LOW_WATERMARK:\n             numToFill \u003d\n                 Math.min(num, (int) (lowWatermark * numValues)) - ekvs.size();\n             break;\n           case ALL:\n             numToFill \u003d num - ekvs.size();\n             break;\n           }\n           // Synchronous fill if not enough values found\n           if (numToFill \u003e 0) {\n             refiller.fillQueueForKey(keyName, ekvs, numToFill);\n           }\n-          // Asynch task to fill \u003e lowWatermark\n-          if (i \u003c\u003d (int) (lowWatermark * numValues)) {\n-            submitRefillTask(keyName, keyQueue);\n-          }\n-          return ekvs;\n+\n+          break;\n+        } else {\n+          ekvs.add(val);\n         }\n-        ekvs.add(val);\n+      }\n+      // Schedule a refill task in case queue has gone below the watermark\n+      if (keyQueue.size() \u003c (int) (lowWatermark * numValues)) {\n+        submitRefillTask(keyName, keyQueue);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Exception while contacting value generator \", e);\n     }\n     return ekvs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cE\u003e getAtMost(String keyName, int num) throws IOException,\n      ExecutionException {\n    LinkedBlockingQueue\u003cE\u003e keyQueue \u003d keyQueues.get(keyName);\n    // Using poll to avoid race condition..\n    LinkedList\u003cE\u003e ekvs \u003d new LinkedList\u003cE\u003e();\n    try {\n      for (int i \u003d 0; i \u003c num; i++) {\n        readLock(keyName);\n        E val \u003d keyQueue.poll();\n        readUnlock(keyName);\n        // If queue is empty now, Based on the provided SyncGenerationPolicy,\n        // figure out how many new values need to be generated synchronously\n        if (val \u003d\u003d null) {\n          // Synchronous call to get remaining values\n          int numToFill \u003d 0;\n          switch (policy) {\n          case ATLEAST_ONE:\n            numToFill \u003d (ekvs.size() \u003c 1) ? 1 : 0;\n            break;\n          case LOW_WATERMARK:\n            numToFill \u003d\n                Math.min(num, (int) (lowWatermark * numValues)) - ekvs.size();\n            break;\n          case ALL:\n            numToFill \u003d num - ekvs.size();\n            break;\n          }\n          // Synchronous fill if not enough values found\n          if (numToFill \u003e 0) {\n            refiller.fillQueueForKey(keyName, ekvs, numToFill);\n          }\n\n          break;\n        } else {\n          ekvs.add(val);\n        }\n      }\n      // Schedule a refill task in case queue has gone below the watermark\n      if (keyQueue.size() \u003c (int) (lowWatermark * numValues)) {\n        submitRefillTask(keyName, keyQueue);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Exception while contacting value generator \", e);\n    }\n    return ekvs;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/ValueQueue.java",
      "extendedDetails": {}
    },
    "2007e0cf2ad371e2dbf533c367f09c1f5acd1c0b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11210. Enhance key rolling to guarantee new KeyVersion is returned from generateEncryptedKeys after a key is rolled.\n",
      "commitDate": "07/02/17 8:36 PM",
      "commitName": "2007e0cf2ad371e2dbf533c367f09c1f5acd1c0b",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "02/06/16 3:14 AM",
      "commitNameOld": "99675e00df65e84dcc02082b795f1f93c90b794e",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 250.76,
      "commitsBetweenForRepo": 1743,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,44 @@\n   public List\u003cE\u003e getAtMost(String keyName, int num) throws IOException,\n       ExecutionException {\n     LinkedBlockingQueue\u003cE\u003e keyQueue \u003d keyQueues.get(keyName);\n     // Using poll to avoid race condition..\n     LinkedList\u003cE\u003e ekvs \u003d new LinkedList\u003cE\u003e();\n     try {\n       for (int i \u003d 0; i \u003c num; i++) {\n+        readLock(keyName);\n         E val \u003d keyQueue.poll();\n+        readUnlock(keyName);\n         // If queue is empty now, Based on the provided SyncGenerationPolicy,\n         // figure out how many new values need to be generated synchronously\n         if (val \u003d\u003d null) {\n           // Synchronous call to get remaining values\n           int numToFill \u003d 0;\n           switch (policy) {\n           case ATLEAST_ONE:\n             numToFill \u003d (ekvs.size() \u003c 1) ? 1 : 0;\n             break;\n           case LOW_WATERMARK:\n             numToFill \u003d\n                 Math.min(num, (int) (lowWatermark * numValues)) - ekvs.size();\n             break;\n           case ALL:\n             numToFill \u003d num - ekvs.size();\n             break;\n           }\n           // Synchronous fill if not enough values found\n           if (numToFill \u003e 0) {\n             refiller.fillQueueForKey(keyName, ekvs, numToFill);\n           }\n           // Asynch task to fill \u003e lowWatermark\n           if (i \u003c\u003d (int) (lowWatermark * numValues)) {\n             submitRefillTask(keyName, keyQueue);\n           }\n           return ekvs;\n         }\n         ekvs.add(val);\n       }\n     } catch (Exception e) {\n       throw new IOException(\"Exception while contacting value generator \", e);\n     }\n     return ekvs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cE\u003e getAtMost(String keyName, int num) throws IOException,\n      ExecutionException {\n    LinkedBlockingQueue\u003cE\u003e keyQueue \u003d keyQueues.get(keyName);\n    // Using poll to avoid race condition..\n    LinkedList\u003cE\u003e ekvs \u003d new LinkedList\u003cE\u003e();\n    try {\n      for (int i \u003d 0; i \u003c num; i++) {\n        readLock(keyName);\n        E val \u003d keyQueue.poll();\n        readUnlock(keyName);\n        // If queue is empty now, Based on the provided SyncGenerationPolicy,\n        // figure out how many new values need to be generated synchronously\n        if (val \u003d\u003d null) {\n          // Synchronous call to get remaining values\n          int numToFill \u003d 0;\n          switch (policy) {\n          case ATLEAST_ONE:\n            numToFill \u003d (ekvs.size() \u003c 1) ? 1 : 0;\n            break;\n          case LOW_WATERMARK:\n            numToFill \u003d\n                Math.min(num, (int) (lowWatermark * numValues)) - ekvs.size();\n            break;\n          case ALL:\n            numToFill \u003d num - ekvs.size();\n            break;\n          }\n          // Synchronous fill if not enough values found\n          if (numToFill \u003e 0) {\n            refiller.fillQueueForKey(keyName, ekvs, numToFill);\n          }\n          // Asynch task to fill \u003e lowWatermark\n          if (i \u003c\u003d (int) (lowWatermark * numValues)) {\n            submitRefillTask(keyName, keyQueue);\n          }\n          return ekvs;\n        }\n        ekvs.add(val);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Exception while contacting value generator \", e);\n    }\n    return ekvs;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/ValueQueue.java",
      "extendedDetails": {}
    },
    "99675e00df65e84dcc02082b795f1f93c90b794e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13232. Typo in exception in ValueQueue.java. Contributed by Jiayi Zhou.\n",
      "commitDate": "02/06/16 3:14 AM",
      "commitName": "99675e00df65e84dcc02082b795f1f93c90b794e",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "21/03/16 11:39 AM",
      "commitNameOld": "e3bb38d62567eafe57d16b78deeba1b71c58e41c",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 72.65,
      "commitsBetweenForRepo": 467,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,42 @@\n   public List\u003cE\u003e getAtMost(String keyName, int num) throws IOException,\n       ExecutionException {\n     LinkedBlockingQueue\u003cE\u003e keyQueue \u003d keyQueues.get(keyName);\n     // Using poll to avoid race condition..\n     LinkedList\u003cE\u003e ekvs \u003d new LinkedList\u003cE\u003e();\n     try {\n       for (int i \u003d 0; i \u003c num; i++) {\n         E val \u003d keyQueue.poll();\n         // If queue is empty now, Based on the provided SyncGenerationPolicy,\n         // figure out how many new values need to be generated synchronously\n         if (val \u003d\u003d null) {\n           // Synchronous call to get remaining values\n           int numToFill \u003d 0;\n           switch (policy) {\n           case ATLEAST_ONE:\n             numToFill \u003d (ekvs.size() \u003c 1) ? 1 : 0;\n             break;\n           case LOW_WATERMARK:\n             numToFill \u003d\n                 Math.min(num, (int) (lowWatermark * numValues)) - ekvs.size();\n             break;\n           case ALL:\n             numToFill \u003d num - ekvs.size();\n             break;\n           }\n           // Synchronous fill if not enough values found\n           if (numToFill \u003e 0) {\n             refiller.fillQueueForKey(keyName, ekvs, numToFill);\n           }\n           // Asynch task to fill \u003e lowWatermark\n           if (i \u003c\u003d (int) (lowWatermark * numValues)) {\n             submitRefillTask(keyName, keyQueue);\n           }\n           return ekvs;\n         }\n         ekvs.add(val);\n       }\n     } catch (Exception e) {\n-      throw new IOException(\"Exeption while contacting value generator \", e);\n+      throw new IOException(\"Exception while contacting value generator \", e);\n     }\n     return ekvs;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cE\u003e getAtMost(String keyName, int num) throws IOException,\n      ExecutionException {\n    LinkedBlockingQueue\u003cE\u003e keyQueue \u003d keyQueues.get(keyName);\n    // Using poll to avoid race condition..\n    LinkedList\u003cE\u003e ekvs \u003d new LinkedList\u003cE\u003e();\n    try {\n      for (int i \u003d 0; i \u003c num; i++) {\n        E val \u003d keyQueue.poll();\n        // If queue is empty now, Based on the provided SyncGenerationPolicy,\n        // figure out how many new values need to be generated synchronously\n        if (val \u003d\u003d null) {\n          // Synchronous call to get remaining values\n          int numToFill \u003d 0;\n          switch (policy) {\n          case ATLEAST_ONE:\n            numToFill \u003d (ekvs.size() \u003c 1) ? 1 : 0;\n            break;\n          case LOW_WATERMARK:\n            numToFill \u003d\n                Math.min(num, (int) (lowWatermark * numValues)) - ekvs.size();\n            break;\n          case ALL:\n            numToFill \u003d num - ekvs.size();\n            break;\n          }\n          // Synchronous fill if not enough values found\n          if (numToFill \u003e 0) {\n            refiller.fillQueueForKey(keyName, ekvs, numToFill);\n          }\n          // Asynch task to fill \u003e lowWatermark\n          if (i \u003c\u003d (int) (lowWatermark * numValues)) {\n            submitRefillTask(keyName, keyQueue);\n          }\n          return ekvs;\n        }\n        ekvs.add(val);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Exception while contacting value generator \", e);\n    }\n    return ekvs;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/ValueQueue.java",
      "extendedDetails": {}
    },
    "0c1469ece38556cf02a0c7bd23761d6bf79d9a64": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10720. KMS: Implement generateEncryptedKey and decryptEncryptedKey in the REST API. (asuresh via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612399 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/07/14 1:55 PM",
      "commitName": "0c1469ece38556cf02a0c7bd23761d6bf79d9a64",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,42 @@\n+  public List\u003cE\u003e getAtMost(String keyName, int num) throws IOException,\n+      ExecutionException {\n+    LinkedBlockingQueue\u003cE\u003e keyQueue \u003d keyQueues.get(keyName);\n+    // Using poll to avoid race condition..\n+    LinkedList\u003cE\u003e ekvs \u003d new LinkedList\u003cE\u003e();\n+    try {\n+      for (int i \u003d 0; i \u003c num; i++) {\n+        E val \u003d keyQueue.poll();\n+        // If queue is empty now, Based on the provided SyncGenerationPolicy,\n+        // figure out how many new values need to be generated synchronously\n+        if (val \u003d\u003d null) {\n+          // Synchronous call to get remaining values\n+          int numToFill \u003d 0;\n+          switch (policy) {\n+          case ATLEAST_ONE:\n+            numToFill \u003d (ekvs.size() \u003c 1) ? 1 : 0;\n+            break;\n+          case LOW_WATERMARK:\n+            numToFill \u003d\n+                Math.min(num, (int) (lowWatermark * numValues)) - ekvs.size();\n+            break;\n+          case ALL:\n+            numToFill \u003d num - ekvs.size();\n+            break;\n+          }\n+          // Synchronous fill if not enough values found\n+          if (numToFill \u003e 0) {\n+            refiller.fillQueueForKey(keyName, ekvs, numToFill);\n+          }\n+          // Asynch task to fill \u003e lowWatermark\n+          if (i \u003c\u003d (int) (lowWatermark * numValues)) {\n+            submitRefillTask(keyName, keyQueue);\n+          }\n+          return ekvs;\n+        }\n+        ekvs.add(val);\n+      }\n+    } catch (Exception e) {\n+      throw new IOException(\"Exeption while contacting value generator \", e);\n+    }\n+    return ekvs;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public List\u003cE\u003e getAtMost(String keyName, int num) throws IOException,\n      ExecutionException {\n    LinkedBlockingQueue\u003cE\u003e keyQueue \u003d keyQueues.get(keyName);\n    // Using poll to avoid race condition..\n    LinkedList\u003cE\u003e ekvs \u003d new LinkedList\u003cE\u003e();\n    try {\n      for (int i \u003d 0; i \u003c num; i++) {\n        E val \u003d keyQueue.poll();\n        // If queue is empty now, Based on the provided SyncGenerationPolicy,\n        // figure out how many new values need to be generated synchronously\n        if (val \u003d\u003d null) {\n          // Synchronous call to get remaining values\n          int numToFill \u003d 0;\n          switch (policy) {\n          case ATLEAST_ONE:\n            numToFill \u003d (ekvs.size() \u003c 1) ? 1 : 0;\n            break;\n          case LOW_WATERMARK:\n            numToFill \u003d\n                Math.min(num, (int) (lowWatermark * numValues)) - ekvs.size();\n            break;\n          case ALL:\n            numToFill \u003d num - ekvs.size();\n            break;\n          }\n          // Synchronous fill if not enough values found\n          if (numToFill \u003e 0) {\n            refiller.fillQueueForKey(keyName, ekvs, numToFill);\n          }\n          // Asynch task to fill \u003e lowWatermark\n          if (i \u003c\u003d (int) (lowWatermark * numValues)) {\n            submitRefillTask(keyName, keyQueue);\n          }\n          return ekvs;\n        }\n        ekvs.add(val);\n      }\n    } catch (Exception e) {\n      throw new IOException(\"Exeption while contacting value generator \", e);\n    }\n    return ekvs;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/ValueQueue.java"
    }
  }
}