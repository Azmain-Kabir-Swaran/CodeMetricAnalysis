{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FederationInterceptor.java",
  "functionName": "recover",
  "functionId": "recover___recoveredDataMap-Map__String,byte[]__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
  "functionStartLine": 356,
  "functionEndLine": 495,
  "numCommitsSeen": 21,
  "timeTaken": 4578,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
    "3090922805699b8374a359e92323884a4177dc4e",
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
    "f1525825623a1307b5aa55c456b6afa3e0c61135",
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f",
    "670e8d4ec7e71fc3b054cd3b2826f869b649a788"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa": "Ybodychange",
    "3090922805699b8374a359e92323884a4177dc4e": "Ybodychange",
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09": "Ybodychange",
    "f1525825623a1307b5aa55c456b6afa3e0c61135": "Ybodychange",
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f": "Ybodychange",
    "670e8d4ec7e71fc3b054cd3b2826f869b649a788": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "22/12/18 12:41 PM",
      "commitNameOld": "657aa433e2098f28337175b6f81721739b3184b3",
      "commitAuthorOld": "Botong Huang",
      "daysBetweenCommits": 83.11,
      "commitsBetweenForRepo": 645,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,140 @@\n   public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n     super.recover(recoveredDataMap);\n     LOG.info(\"Recovering data for FederationInterceptor for {}\",\n         this.attemptId);\n     this.justRecovered \u003d true;\n \n     if (recoveredDataMap \u003d\u003d null) {\n       return;\n     }\n     try {\n       if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n         RegisterApplicationMasterRequestProto pb \u003d\n             RegisterApplicationMasterRequestProto\n                 .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n         this.amRegistrationRequest \u003d\n             new RegisterApplicationMasterRequestPBImpl(pb);\n         LOG.info(\"amRegistrationRequest recovered for {}\", this.attemptId);\n \n         // Give the register request to homeRMRelayer for future re-registration\n         this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);\n       }\n       if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n         RegisterApplicationMasterResponseProto pb \u003d\n             RegisterApplicationMasterResponseProto\n                 .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n         this.amRegistrationResponse \u003d\n             new RegisterApplicationMasterResponsePBImpl(pb);\n         LOG.info(\"amRegistrationResponse recovered for {}\", this.attemptId);\n       }\n \n       // Recover UAM amrmTokens from registry or NMSS\n       Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n       if (this.registryClient !\u003d null) {\n         uamMap \u003d this.registryClient\n             .loadStateFromRegistry(this.attemptId.getApplicationId());\n         LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n             uamMap.size(), this.attemptId.getApplicationId());\n       } else {\n         uamMap \u003d new HashMap\u003c\u003e();\n         for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n           if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n             // entry for subClusterId -\u003e UAM amrmToken\n             String scId \u003d\n                 entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n             Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n             amrmToken.decodeFromUrlString(\n                 new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n             uamMap.put(scId, amrmToken);\n-            LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n+            LOG.debug(\"Recovered UAM in {} from NMSS\", scId);\n           }\n         }\n         LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n             uamMap.size(), this.attemptId.getApplicationId());\n       }\n \n       // Re-attach the UAMs\n       int containers \u003d 0;\n       for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n           .entrySet()) {\n         SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n \n         // Create a config loaded with federation on and subclusterId\n         // for each UAM\n         YarnConfiguration config \u003d new YarnConfiguration(getConf());\n         FederationProxyProviderUtil.updateConfForFederation(config,\n             subClusterId.getId());\n \n         try {\n           this.uamPool.reAttachUAM(subClusterId.getId(), config,\n               this.attemptId.getApplicationId(),\n               this.amRegistrationResponse.getQueue(),\n               getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n               entry.getValue(), subClusterId.toString());\n \n           this.secondaryRelayers.put(subClusterId.getId(),\n               this.uamPool.getAMRMClientRelayer(subClusterId.getId()));\n \n           RegisterApplicationMasterResponse response \u003d\n               this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                   this.amRegistrationRequest);\n \n           // Set sub-cluster to be timed out initially\n           lastSCResponseTime.put(subClusterId,\n               clock.getTime() - subClusterTimeOut);\n \n           // Running containers from secondary RMs\n           for (Container container : response\n               .getContainersFromPreviousAttempts()) {\n             containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n             containers++;\n-            LOG.debug(\"  From subcluster \" + subClusterId\n-                + \" running container \" + container.getId());\n+            LOG.debug(\"  From subcluster {} running container {}\",\n+                subClusterId, container.getId());\n           }\n           LOG.info(\"Recovered {} running containers from UAM in {}\",\n               response.getContainersFromPreviousAttempts().size(),\n               subClusterId);\n \n         } catch (Exception e) {\n           LOG.error(\"Error reattaching UAM to \" + subClusterId + \" for \"\n               + this.attemptId, e);\n         }\n       }\n \n       // Get the running containers from home RM, note that we will also get the\n       // AM container itself from here. We don\u0027t need it, but no harm to put the\n       // map as well.\n       UserGroupInformation appSubmitter \u003d UserGroupInformation\n           .createRemoteUser(getApplicationContext().getUser());\n       ApplicationClientProtocol rmClient \u003d\n           createHomeRMProxy(getApplicationContext(),\n               ApplicationClientProtocol.class, appSubmitter);\n \n       GetContainersResponse response \u003d rmClient\n           .getContainers(GetContainersRequest.newInstance(this.attemptId));\n       for (ContainerReport container : response.getContainerList()) {\n         containerIdToSubClusterIdMap.put(container.getContainerId(),\n             this.homeSubClusterId);\n         containers++;\n-        LOG.debug(\"  From home RM \" + this.homeSubClusterId\n-            + \" running container \" + container.getContainerId());\n+        LOG.debug(\"  From home RM {} running container {}\",\n+            this.homeSubClusterId, container.getContainerId());\n       }\n       LOG.info(\"{} running containers including AM recovered from home RM {}\",\n           response.getContainerList().size(), this.homeSubClusterId);\n \n       LOG.info(\n           \"In all {} UAMs {} running containers including AM recovered for {}\",\n           uamMap.size(), containers, this.attemptId);\n \n       if (this.amRegistrationResponse !\u003d null) {\n         // Initialize the AMRMProxyPolicy\n         String queue \u003d this.amRegistrationResponse.getQueue();\n         this.policyInterpreter \u003d\n             FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                 getConf(), this.federationFacade, this.homeSubClusterId);\n       }\n     } catch (IOException | YarnException e) {\n       throw new YarnRuntimeException(e);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n    super.recover(recoveredDataMap);\n    LOG.info(\"Recovering data for FederationInterceptor for {}\",\n        this.attemptId);\n    this.justRecovered \u003d true;\n\n    if (recoveredDataMap \u003d\u003d null) {\n      return;\n    }\n    try {\n      if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n        RegisterApplicationMasterRequestProto pb \u003d\n            RegisterApplicationMasterRequestProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n        this.amRegistrationRequest \u003d\n            new RegisterApplicationMasterRequestPBImpl(pb);\n        LOG.info(\"amRegistrationRequest recovered for {}\", this.attemptId);\n\n        // Give the register request to homeRMRelayer for future re-registration\n        this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);\n      }\n      if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n        RegisterApplicationMasterResponseProto pb \u003d\n            RegisterApplicationMasterResponseProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n        this.amRegistrationResponse \u003d\n            new RegisterApplicationMasterResponsePBImpl(pb);\n        LOG.info(\"amRegistrationResponse recovered for {}\", this.attemptId);\n      }\n\n      // Recover UAM amrmTokens from registry or NMSS\n      Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n      if (this.registryClient !\u003d null) {\n        uamMap \u003d this.registryClient\n            .loadStateFromRegistry(this.attemptId.getApplicationId());\n        LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n            uamMap.size(), this.attemptId.getApplicationId());\n      } else {\n        uamMap \u003d new HashMap\u003c\u003e();\n        for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n          if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n            // entry for subClusterId -\u003e UAM amrmToken\n            String scId \u003d\n                entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n            Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n            amrmToken.decodeFromUrlString(\n                new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n            uamMap.put(scId, amrmToken);\n            LOG.debug(\"Recovered UAM in {} from NMSS\", scId);\n          }\n        }\n        LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n            uamMap.size(), this.attemptId.getApplicationId());\n      }\n\n      // Re-attach the UAMs\n      int containers \u003d 0;\n      for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n          .entrySet()) {\n        SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n\n        // Create a config loaded with federation on and subclusterId\n        // for each UAM\n        YarnConfiguration config \u003d new YarnConfiguration(getConf());\n        FederationProxyProviderUtil.updateConfForFederation(config,\n            subClusterId.getId());\n\n        try {\n          this.uamPool.reAttachUAM(subClusterId.getId(), config,\n              this.attemptId.getApplicationId(),\n              this.amRegistrationResponse.getQueue(),\n              getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n              entry.getValue(), subClusterId.toString());\n\n          this.secondaryRelayers.put(subClusterId.getId(),\n              this.uamPool.getAMRMClientRelayer(subClusterId.getId()));\n\n          RegisterApplicationMasterResponse response \u003d\n              this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                  this.amRegistrationRequest);\n\n          // Set sub-cluster to be timed out initially\n          lastSCResponseTime.put(subClusterId,\n              clock.getTime() - subClusterTimeOut);\n\n          // Running containers from secondary RMs\n          for (Container container : response\n              .getContainersFromPreviousAttempts()) {\n            containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n            containers++;\n            LOG.debug(\"  From subcluster {} running container {}\",\n                subClusterId, container.getId());\n          }\n          LOG.info(\"Recovered {} running containers from UAM in {}\",\n              response.getContainersFromPreviousAttempts().size(),\n              subClusterId);\n\n        } catch (Exception e) {\n          LOG.error(\"Error reattaching UAM to \" + subClusterId + \" for \"\n              + this.attemptId, e);\n        }\n      }\n\n      // Get the running containers from home RM, note that we will also get the\n      // AM container itself from here. We don\u0027t need it, but no harm to put the\n      // map as well.\n      UserGroupInformation appSubmitter \u003d UserGroupInformation\n          .createRemoteUser(getApplicationContext().getUser());\n      ApplicationClientProtocol rmClient \u003d\n          createHomeRMProxy(getApplicationContext(),\n              ApplicationClientProtocol.class, appSubmitter);\n\n      GetContainersResponse response \u003d rmClient\n          .getContainers(GetContainersRequest.newInstance(this.attemptId));\n      for (ContainerReport container : response.getContainerList()) {\n        containerIdToSubClusterIdMap.put(container.getContainerId(),\n            this.homeSubClusterId);\n        containers++;\n        LOG.debug(\"  From home RM {} running container {}\",\n            this.homeSubClusterId, container.getContainerId());\n      }\n      LOG.info(\"{} running containers including AM recovered from home RM {}\",\n          response.getContainerList().size(), this.homeSubClusterId);\n\n      LOG.info(\n          \"In all {} UAMs {} running containers including AM recovered for {}\",\n          uamMap.size(), containers, this.attemptId);\n\n      if (this.amRegistrationResponse !\u003d null) {\n        // Initialize the AMRMProxyPolicy\n        String queue \u003d this.amRegistrationResponse.getQueue();\n        this.policyInterpreter \u003d\n            FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                getConf(), this.federationFacade, this.homeSubClusterId);\n      }\n    } catch (IOException | YarnException e) {\n      throw new YarnRuntimeException(e);\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8933. [AMRMProxy] Fix potential empty fields in allocation response, move SubClusterTimeout to FederationInterceptor. Contributed by Botong Huang.\n",
      "commitDate": "11/11/18 11:12 AM",
      "commitName": "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
      "commitAuthor": "Botong Huang",
      "commitDateOld": "02/11/18 3:30 PM",
      "commitNameOld": "989715ec5066c6ac7868e25ad9234dc64723e61e",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 8.86,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,140 @@\n   public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n     super.recover(recoveredDataMap);\n     LOG.info(\"Recovering data for FederationInterceptor for {}\",\n         this.attemptId);\n     this.justRecovered \u003d true;\n \n     if (recoveredDataMap \u003d\u003d null) {\n       return;\n     }\n     try {\n       if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n         RegisterApplicationMasterRequestProto pb \u003d\n             RegisterApplicationMasterRequestProto\n                 .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n         this.amRegistrationRequest \u003d\n             new RegisterApplicationMasterRequestPBImpl(pb);\n         LOG.info(\"amRegistrationRequest recovered for {}\", this.attemptId);\n \n         // Give the register request to homeRMRelayer for future re-registration\n         this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);\n       }\n       if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n         RegisterApplicationMasterResponseProto pb \u003d\n             RegisterApplicationMasterResponseProto\n                 .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n         this.amRegistrationResponse \u003d\n             new RegisterApplicationMasterResponsePBImpl(pb);\n         LOG.info(\"amRegistrationResponse recovered for {}\", this.attemptId);\n       }\n \n       // Recover UAM amrmTokens from registry or NMSS\n       Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n       if (this.registryClient !\u003d null) {\n         uamMap \u003d this.registryClient\n             .loadStateFromRegistry(this.attemptId.getApplicationId());\n         LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n             uamMap.size(), this.attemptId.getApplicationId());\n       } else {\n         uamMap \u003d new HashMap\u003c\u003e();\n         for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n           if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n             // entry for subClusterId -\u003e UAM amrmToken\n             String scId \u003d\n                 entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n             Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n             amrmToken.decodeFromUrlString(\n                 new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n             uamMap.put(scId, amrmToken);\n             LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n           }\n         }\n         LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n             uamMap.size(), this.attemptId.getApplicationId());\n       }\n \n       // Re-attach the UAMs\n       int containers \u003d 0;\n       for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n           .entrySet()) {\n         SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n \n         // Create a config loaded with federation on and subclusterId\n         // for each UAM\n         YarnConfiguration config \u003d new YarnConfiguration(getConf());\n         FederationProxyProviderUtil.updateConfForFederation(config,\n             subClusterId.getId());\n \n         try {\n           this.uamPool.reAttachUAM(subClusterId.getId(), config,\n               this.attemptId.getApplicationId(),\n               this.amRegistrationResponse.getQueue(),\n               getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n               entry.getValue(), subClusterId.toString());\n \n           this.secondaryRelayers.put(subClusterId.getId(),\n               this.uamPool.getAMRMClientRelayer(subClusterId.getId()));\n \n           RegisterApplicationMasterResponse response \u003d\n               this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                   this.amRegistrationRequest);\n \n+          // Set sub-cluster to be timed out initially\n+          lastSCResponseTime.put(subClusterId,\n+              clock.getTime() - subClusterTimeOut);\n+\n           // Running containers from secondary RMs\n           for (Container container : response\n               .getContainersFromPreviousAttempts()) {\n             containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n             containers++;\n             LOG.debug(\"  From subcluster \" + subClusterId\n                 + \" running container \" + container.getId());\n           }\n           LOG.info(\"Recovered {} running containers from UAM in {}\",\n               response.getContainersFromPreviousAttempts().size(),\n               subClusterId);\n \n         } catch (Exception e) {\n           LOG.error(\"Error reattaching UAM to \" + subClusterId + \" for \"\n               + this.attemptId, e);\n         }\n       }\n \n       // Get the running containers from home RM, note that we will also get the\n       // AM container itself from here. We don\u0027t need it, but no harm to put the\n       // map as well.\n       UserGroupInformation appSubmitter \u003d UserGroupInformation\n           .createRemoteUser(getApplicationContext().getUser());\n       ApplicationClientProtocol rmClient \u003d\n           createHomeRMProxy(getApplicationContext(),\n               ApplicationClientProtocol.class, appSubmitter);\n \n       GetContainersResponse response \u003d rmClient\n           .getContainers(GetContainersRequest.newInstance(this.attemptId));\n       for (ContainerReport container : response.getContainerList()) {\n         containerIdToSubClusterIdMap.put(container.getContainerId(),\n             this.homeSubClusterId);\n         containers++;\n         LOG.debug(\"  From home RM \" + this.homeSubClusterId\n             + \" running container \" + container.getContainerId());\n       }\n       LOG.info(\"{} running containers including AM recovered from home RM {}\",\n           response.getContainerList().size(), this.homeSubClusterId);\n \n       LOG.info(\n           \"In all {} UAMs {} running containers including AM recovered for {}\",\n           uamMap.size(), containers, this.attemptId);\n \n       if (this.amRegistrationResponse !\u003d null) {\n         // Initialize the AMRMProxyPolicy\n         String queue \u003d this.amRegistrationResponse.getQueue();\n         this.policyInterpreter \u003d\n             FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                 getConf(), this.federationFacade, this.homeSubClusterId);\n       }\n     } catch (IOException | YarnException e) {\n       throw new YarnRuntimeException(e);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n    super.recover(recoveredDataMap);\n    LOG.info(\"Recovering data for FederationInterceptor for {}\",\n        this.attemptId);\n    this.justRecovered \u003d true;\n\n    if (recoveredDataMap \u003d\u003d null) {\n      return;\n    }\n    try {\n      if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n        RegisterApplicationMasterRequestProto pb \u003d\n            RegisterApplicationMasterRequestProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n        this.amRegistrationRequest \u003d\n            new RegisterApplicationMasterRequestPBImpl(pb);\n        LOG.info(\"amRegistrationRequest recovered for {}\", this.attemptId);\n\n        // Give the register request to homeRMRelayer for future re-registration\n        this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);\n      }\n      if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n        RegisterApplicationMasterResponseProto pb \u003d\n            RegisterApplicationMasterResponseProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n        this.amRegistrationResponse \u003d\n            new RegisterApplicationMasterResponsePBImpl(pb);\n        LOG.info(\"amRegistrationResponse recovered for {}\", this.attemptId);\n      }\n\n      // Recover UAM amrmTokens from registry or NMSS\n      Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n      if (this.registryClient !\u003d null) {\n        uamMap \u003d this.registryClient\n            .loadStateFromRegistry(this.attemptId.getApplicationId());\n        LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n            uamMap.size(), this.attemptId.getApplicationId());\n      } else {\n        uamMap \u003d new HashMap\u003c\u003e();\n        for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n          if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n            // entry for subClusterId -\u003e UAM amrmToken\n            String scId \u003d\n                entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n            Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n            amrmToken.decodeFromUrlString(\n                new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n            uamMap.put(scId, amrmToken);\n            LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n          }\n        }\n        LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n            uamMap.size(), this.attemptId.getApplicationId());\n      }\n\n      // Re-attach the UAMs\n      int containers \u003d 0;\n      for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n          .entrySet()) {\n        SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n\n        // Create a config loaded with federation on and subclusterId\n        // for each UAM\n        YarnConfiguration config \u003d new YarnConfiguration(getConf());\n        FederationProxyProviderUtil.updateConfForFederation(config,\n            subClusterId.getId());\n\n        try {\n          this.uamPool.reAttachUAM(subClusterId.getId(), config,\n              this.attemptId.getApplicationId(),\n              this.amRegistrationResponse.getQueue(),\n              getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n              entry.getValue(), subClusterId.toString());\n\n          this.secondaryRelayers.put(subClusterId.getId(),\n              this.uamPool.getAMRMClientRelayer(subClusterId.getId()));\n\n          RegisterApplicationMasterResponse response \u003d\n              this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                  this.amRegistrationRequest);\n\n          // Set sub-cluster to be timed out initially\n          lastSCResponseTime.put(subClusterId,\n              clock.getTime() - subClusterTimeOut);\n\n          // Running containers from secondary RMs\n          for (Container container : response\n              .getContainersFromPreviousAttempts()) {\n            containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n            containers++;\n            LOG.debug(\"  From subcluster \" + subClusterId\n                + \" running container \" + container.getId());\n          }\n          LOG.info(\"Recovered {} running containers from UAM in {}\",\n              response.getContainersFromPreviousAttempts().size(),\n              subClusterId);\n\n        } catch (Exception e) {\n          LOG.error(\"Error reattaching UAM to \" + subClusterId + \" for \"\n              + this.attemptId, e);\n        }\n      }\n\n      // Get the running containers from home RM, note that we will also get the\n      // AM container itself from here. We don\u0027t need it, but no harm to put the\n      // map as well.\n      UserGroupInformation appSubmitter \u003d UserGroupInformation\n          .createRemoteUser(getApplicationContext().getUser());\n      ApplicationClientProtocol rmClient \u003d\n          createHomeRMProxy(getApplicationContext(),\n              ApplicationClientProtocol.class, appSubmitter);\n\n      GetContainersResponse response \u003d rmClient\n          .getContainers(GetContainersRequest.newInstance(this.attemptId));\n      for (ContainerReport container : response.getContainerList()) {\n        containerIdToSubClusterIdMap.put(container.getContainerId(),\n            this.homeSubClusterId);\n        containers++;\n        LOG.debug(\"  From home RM \" + this.homeSubClusterId\n            + \" running container \" + container.getContainerId());\n      }\n      LOG.info(\"{} running containers including AM recovered from home RM {}\",\n          response.getContainerList().size(), this.homeSubClusterId);\n\n      LOG.info(\n          \"In all {} UAMs {} running containers including AM recovered for {}\",\n          uamMap.size(), containers, this.attemptId);\n\n      if (this.amRegistrationResponse !\u003d null) {\n        // Initialize the AMRMProxyPolicy\n        String queue \u003d this.amRegistrationResponse.getQueue();\n        this.policyInterpreter \u003d\n            FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                getConf(), this.federationFacade, this.homeSubClusterId);\n      }\n    } catch (IOException | YarnException e) {\n      throw new YarnRuntimeException(e);\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "3090922805699b8374a359e92323884a4177dc4e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8696. [AMRMProxy] FederationInterceptor upgrade: home sub-cluster heartbeat async. Contributed by Botong Huang.\n",
      "commitDate": "24/09/18 11:37 AM",
      "commitName": "3090922805699b8374a359e92323884a4177dc4e",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "12/09/18 11:46 AM",
      "commitNameOld": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 11.99,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,136 @@\n   public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n     super.recover(recoveredDataMap);\n     LOG.info(\"Recovering data for FederationInterceptor for {}\",\n         this.attemptId);\n+    this.justRecovered \u003d true;\n+\n     if (recoveredDataMap \u003d\u003d null) {\n       return;\n     }\n     try {\n       if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n         RegisterApplicationMasterRequestProto pb \u003d\n             RegisterApplicationMasterRequestProto\n                 .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n         this.amRegistrationRequest \u003d\n             new RegisterApplicationMasterRequestPBImpl(pb);\n         LOG.info(\"amRegistrationRequest recovered for {}\", this.attemptId);\n \n         // Give the register request to homeRMRelayer for future re-registration\n         this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);\n       }\n       if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n         RegisterApplicationMasterResponseProto pb \u003d\n             RegisterApplicationMasterResponseProto\n                 .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n         this.amRegistrationResponse \u003d\n             new RegisterApplicationMasterResponsePBImpl(pb);\n         LOG.info(\"amRegistrationResponse recovered for {}\", this.attemptId);\n-        // Trigger re-register and full pending re-send only if we have a\n-        // saved register response. This should always be true though.\n-        this.justRecovered \u003d true;\n       }\n \n       // Recover UAM amrmTokens from registry or NMSS\n       Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n       if (this.registryClient !\u003d null) {\n         uamMap \u003d this.registryClient\n             .loadStateFromRegistry(this.attemptId.getApplicationId());\n         LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n             uamMap.size(), this.attemptId.getApplicationId());\n       } else {\n         uamMap \u003d new HashMap\u003c\u003e();\n         for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n           if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n             // entry for subClusterId -\u003e UAM amrmToken\n             String scId \u003d\n                 entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n             Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n             amrmToken.decodeFromUrlString(\n                 new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n             uamMap.put(scId, amrmToken);\n             LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n           }\n         }\n         LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n             uamMap.size(), this.attemptId.getApplicationId());\n       }\n \n       // Re-attach the UAMs\n       int containers \u003d 0;\n       for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n           .entrySet()) {\n         SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n \n         // Create a config loaded with federation on and subclusterId\n         // for each UAM\n         YarnConfiguration config \u003d new YarnConfiguration(getConf());\n         FederationProxyProviderUtil.updateConfForFederation(config,\n             subClusterId.getId());\n \n         try {\n           this.uamPool.reAttachUAM(subClusterId.getId(), config,\n               this.attemptId.getApplicationId(),\n               this.amRegistrationResponse.getQueue(),\n               getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n               entry.getValue(), subClusterId.toString());\n \n           this.secondaryRelayers.put(subClusterId.getId(),\n               this.uamPool.getAMRMClientRelayer(subClusterId.getId()));\n \n           RegisterApplicationMasterResponse response \u003d\n               this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                   this.amRegistrationRequest);\n \n           // Running containers from secondary RMs\n           for (Container container : response\n               .getContainersFromPreviousAttempts()) {\n             containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n             containers++;\n+            LOG.debug(\"  From subcluster \" + subClusterId\n+                + \" running container \" + container.getId());\n           }\n           LOG.info(\"Recovered {} running containers from UAM in {}\",\n               response.getContainersFromPreviousAttempts().size(),\n               subClusterId);\n \n         } catch (Exception e) {\n           LOG.error(\"Error reattaching UAM to \" + subClusterId + \" for \"\n               + this.attemptId, e);\n         }\n       }\n \n       // Get the running containers from home RM, note that we will also get the\n       // AM container itself from here. We don\u0027t need it, but no harm to put the\n       // map as well.\n       UserGroupInformation appSubmitter \u003d UserGroupInformation\n           .createRemoteUser(getApplicationContext().getUser());\n       ApplicationClientProtocol rmClient \u003d\n           createHomeRMProxy(getApplicationContext(),\n               ApplicationClientProtocol.class, appSubmitter);\n \n       GetContainersResponse response \u003d rmClient\n           .getContainers(GetContainersRequest.newInstance(this.attemptId));\n       for (ContainerReport container : response.getContainerList()) {\n         containerIdToSubClusterIdMap.put(container.getContainerId(),\n             this.homeSubClusterId);\n         containers++;\n         LOG.debug(\"  From home RM \" + this.homeSubClusterId\n             + \" running container \" + container.getContainerId());\n       }\n-      LOG.info(\"{} running containers including AM recovered from home RM \",\n+      LOG.info(\"{} running containers including AM recovered from home RM {}\",\n           response.getContainerList().size(), this.homeSubClusterId);\n \n       LOG.info(\n           \"In all {} UAMs {} running containers including AM recovered for {}\",\n           uamMap.size(), containers, this.attemptId);\n \n       if (this.amRegistrationResponse !\u003d null) {\n         // Initialize the AMRMProxyPolicy\n         String queue \u003d this.amRegistrationResponse.getQueue();\n         this.policyInterpreter \u003d\n             FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                 getConf(), this.federationFacade, this.homeSubClusterId);\n       }\n     } catch (IOException | YarnException e) {\n       throw new YarnRuntimeException(e);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n    super.recover(recoveredDataMap);\n    LOG.info(\"Recovering data for FederationInterceptor for {}\",\n        this.attemptId);\n    this.justRecovered \u003d true;\n\n    if (recoveredDataMap \u003d\u003d null) {\n      return;\n    }\n    try {\n      if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n        RegisterApplicationMasterRequestProto pb \u003d\n            RegisterApplicationMasterRequestProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n        this.amRegistrationRequest \u003d\n            new RegisterApplicationMasterRequestPBImpl(pb);\n        LOG.info(\"amRegistrationRequest recovered for {}\", this.attemptId);\n\n        // Give the register request to homeRMRelayer for future re-registration\n        this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);\n      }\n      if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n        RegisterApplicationMasterResponseProto pb \u003d\n            RegisterApplicationMasterResponseProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n        this.amRegistrationResponse \u003d\n            new RegisterApplicationMasterResponsePBImpl(pb);\n        LOG.info(\"amRegistrationResponse recovered for {}\", this.attemptId);\n      }\n\n      // Recover UAM amrmTokens from registry or NMSS\n      Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n      if (this.registryClient !\u003d null) {\n        uamMap \u003d this.registryClient\n            .loadStateFromRegistry(this.attemptId.getApplicationId());\n        LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n            uamMap.size(), this.attemptId.getApplicationId());\n      } else {\n        uamMap \u003d new HashMap\u003c\u003e();\n        for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n          if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n            // entry for subClusterId -\u003e UAM amrmToken\n            String scId \u003d\n                entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n            Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n            amrmToken.decodeFromUrlString(\n                new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n            uamMap.put(scId, amrmToken);\n            LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n          }\n        }\n        LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n            uamMap.size(), this.attemptId.getApplicationId());\n      }\n\n      // Re-attach the UAMs\n      int containers \u003d 0;\n      for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n          .entrySet()) {\n        SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n\n        // Create a config loaded with federation on and subclusterId\n        // for each UAM\n        YarnConfiguration config \u003d new YarnConfiguration(getConf());\n        FederationProxyProviderUtil.updateConfForFederation(config,\n            subClusterId.getId());\n\n        try {\n          this.uamPool.reAttachUAM(subClusterId.getId(), config,\n              this.attemptId.getApplicationId(),\n              this.amRegistrationResponse.getQueue(),\n              getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n              entry.getValue(), subClusterId.toString());\n\n          this.secondaryRelayers.put(subClusterId.getId(),\n              this.uamPool.getAMRMClientRelayer(subClusterId.getId()));\n\n          RegisterApplicationMasterResponse response \u003d\n              this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                  this.amRegistrationRequest);\n\n          // Running containers from secondary RMs\n          for (Container container : response\n              .getContainersFromPreviousAttempts()) {\n            containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n            containers++;\n            LOG.debug(\"  From subcluster \" + subClusterId\n                + \" running container \" + container.getId());\n          }\n          LOG.info(\"Recovered {} running containers from UAM in {}\",\n              response.getContainersFromPreviousAttempts().size(),\n              subClusterId);\n\n        } catch (Exception e) {\n          LOG.error(\"Error reattaching UAM to \" + subClusterId + \" for \"\n              + this.attemptId, e);\n        }\n      }\n\n      // Get the running containers from home RM, note that we will also get the\n      // AM container itself from here. We don\u0027t need it, but no harm to put the\n      // map as well.\n      UserGroupInformation appSubmitter \u003d UserGroupInformation\n          .createRemoteUser(getApplicationContext().getUser());\n      ApplicationClientProtocol rmClient \u003d\n          createHomeRMProxy(getApplicationContext(),\n              ApplicationClientProtocol.class, appSubmitter);\n\n      GetContainersResponse response \u003d rmClient\n          .getContainers(GetContainersRequest.newInstance(this.attemptId));\n      for (ContainerReport container : response.getContainerList()) {\n        containerIdToSubClusterIdMap.put(container.getContainerId(),\n            this.homeSubClusterId);\n        containers++;\n        LOG.debug(\"  From home RM \" + this.homeSubClusterId\n            + \" running container \" + container.getContainerId());\n      }\n      LOG.info(\"{} running containers including AM recovered from home RM {}\",\n          response.getContainerList().size(), this.homeSubClusterId);\n\n      LOG.info(\n          \"In all {} UAMs {} running containers including AM recovered for {}\",\n          uamMap.size(), containers, this.attemptId);\n\n      if (this.amRegistrationResponse !\u003d null) {\n        // Initialize the AMRMProxyPolicy\n        String queue \u003d this.amRegistrationResponse.getQueue();\n        this.policyInterpreter \u003d\n            FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                getConf(), this.federationFacade, this.homeSubClusterId);\n      }\n    } catch (IOException | YarnException e) {\n      throw new YarnRuntimeException(e);\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8658. [AMRMProxy] Metrics for AMRMClientRelayer inside FederationInterceptor. Contributed by Young Chen.\n",
      "commitDate": "12/09/18 11:46 AM",
      "commitName": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "27/08/18 10:32 AM",
      "commitNameOld": "f1525825623a1307b5aa55c456b6afa3e0c61135",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 16.05,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,135 @@\n   public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n     super.recover(recoveredDataMap);\n     LOG.info(\"Recovering data for FederationInterceptor for {}\",\n         this.attemptId);\n     if (recoveredDataMap \u003d\u003d null) {\n       return;\n     }\n     try {\n       if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n         RegisterApplicationMasterRequestProto pb \u003d\n             RegisterApplicationMasterRequestProto\n                 .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n         this.amRegistrationRequest \u003d\n             new RegisterApplicationMasterRequestPBImpl(pb);\n         LOG.info(\"amRegistrationRequest recovered for {}\", this.attemptId);\n \n         // Give the register request to homeRMRelayer for future re-registration\n         this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);\n       }\n       if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n         RegisterApplicationMasterResponseProto pb \u003d\n             RegisterApplicationMasterResponseProto\n                 .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n         this.amRegistrationResponse \u003d\n             new RegisterApplicationMasterResponsePBImpl(pb);\n         LOG.info(\"amRegistrationResponse recovered for {}\", this.attemptId);\n         // Trigger re-register and full pending re-send only if we have a\n         // saved register response. This should always be true though.\n         this.justRecovered \u003d true;\n       }\n \n       // Recover UAM amrmTokens from registry or NMSS\n       Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n       if (this.registryClient !\u003d null) {\n         uamMap \u003d this.registryClient\n             .loadStateFromRegistry(this.attemptId.getApplicationId());\n         LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n             uamMap.size(), this.attemptId.getApplicationId());\n       } else {\n         uamMap \u003d new HashMap\u003c\u003e();\n         for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n           if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n             // entry for subClusterId -\u003e UAM amrmToken\n             String scId \u003d\n                 entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n             Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n             amrmToken.decodeFromUrlString(\n                 new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n             uamMap.put(scId, amrmToken);\n             LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n           }\n         }\n         LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n             uamMap.size(), this.attemptId.getApplicationId());\n       }\n \n       // Re-attach the UAMs\n       int containers \u003d 0;\n       for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n           .entrySet()) {\n         SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n \n         // Create a config loaded with federation on and subclusterId\n         // for each UAM\n         YarnConfiguration config \u003d new YarnConfiguration(getConf());\n         FederationProxyProviderUtil.updateConfForFederation(config,\n             subClusterId.getId());\n \n         try {\n           this.uamPool.reAttachUAM(subClusterId.getId(), config,\n               this.attemptId.getApplicationId(),\n               this.amRegistrationResponse.getQueue(),\n               getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n-              entry.getValue());\n+              entry.getValue(), subClusterId.toString());\n \n           this.secondaryRelayers.put(subClusterId.getId(),\n               this.uamPool.getAMRMClientRelayer(subClusterId.getId()));\n \n           RegisterApplicationMasterResponse response \u003d\n               this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                   this.amRegistrationRequest);\n \n           // Running containers from secondary RMs\n           for (Container container : response\n               .getContainersFromPreviousAttempts()) {\n             containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n             containers++;\n           }\n           LOG.info(\"Recovered {} running containers from UAM in {}\",\n               response.getContainersFromPreviousAttempts().size(),\n               subClusterId);\n \n         } catch (Exception e) {\n           LOG.error(\"Error reattaching UAM to \" + subClusterId + \" for \"\n               + this.attemptId, e);\n         }\n       }\n \n       // Get the running containers from home RM, note that we will also get the\n       // AM container itself from here. We don\u0027t need it, but no harm to put the\n       // map as well.\n       UserGroupInformation appSubmitter \u003d UserGroupInformation\n           .createRemoteUser(getApplicationContext().getUser());\n       ApplicationClientProtocol rmClient \u003d\n           createHomeRMProxy(getApplicationContext(),\n               ApplicationClientProtocol.class, appSubmitter);\n \n       GetContainersResponse response \u003d rmClient\n           .getContainers(GetContainersRequest.newInstance(this.attemptId));\n       for (ContainerReport container : response.getContainerList()) {\n         containerIdToSubClusterIdMap.put(container.getContainerId(),\n             this.homeSubClusterId);\n         containers++;\n         LOG.debug(\"  From home RM \" + this.homeSubClusterId\n             + \" running container \" + container.getContainerId());\n       }\n       LOG.info(\"{} running containers including AM recovered from home RM \",\n           response.getContainerList().size(), this.homeSubClusterId);\n \n       LOG.info(\n           \"In all {} UAMs {} running containers including AM recovered for {}\",\n           uamMap.size(), containers, this.attemptId);\n \n       if (this.amRegistrationResponse !\u003d null) {\n         // Initialize the AMRMProxyPolicy\n         String queue \u003d this.amRegistrationResponse.getQueue();\n         this.policyInterpreter \u003d\n             FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                 getConf(), this.federationFacade, this.homeSubClusterId);\n       }\n     } catch (IOException | YarnException e) {\n       throw new YarnRuntimeException(e);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n    super.recover(recoveredDataMap);\n    LOG.info(\"Recovering data for FederationInterceptor for {}\",\n        this.attemptId);\n    if (recoveredDataMap \u003d\u003d null) {\n      return;\n    }\n    try {\n      if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n        RegisterApplicationMasterRequestProto pb \u003d\n            RegisterApplicationMasterRequestProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n        this.amRegistrationRequest \u003d\n            new RegisterApplicationMasterRequestPBImpl(pb);\n        LOG.info(\"amRegistrationRequest recovered for {}\", this.attemptId);\n\n        // Give the register request to homeRMRelayer for future re-registration\n        this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);\n      }\n      if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n        RegisterApplicationMasterResponseProto pb \u003d\n            RegisterApplicationMasterResponseProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n        this.amRegistrationResponse \u003d\n            new RegisterApplicationMasterResponsePBImpl(pb);\n        LOG.info(\"amRegistrationResponse recovered for {}\", this.attemptId);\n        // Trigger re-register and full pending re-send only if we have a\n        // saved register response. This should always be true though.\n        this.justRecovered \u003d true;\n      }\n\n      // Recover UAM amrmTokens from registry or NMSS\n      Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n      if (this.registryClient !\u003d null) {\n        uamMap \u003d this.registryClient\n            .loadStateFromRegistry(this.attemptId.getApplicationId());\n        LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n            uamMap.size(), this.attemptId.getApplicationId());\n      } else {\n        uamMap \u003d new HashMap\u003c\u003e();\n        for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n          if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n            // entry for subClusterId -\u003e UAM amrmToken\n            String scId \u003d\n                entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n            Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n            amrmToken.decodeFromUrlString(\n                new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n            uamMap.put(scId, amrmToken);\n            LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n          }\n        }\n        LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n            uamMap.size(), this.attemptId.getApplicationId());\n      }\n\n      // Re-attach the UAMs\n      int containers \u003d 0;\n      for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n          .entrySet()) {\n        SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n\n        // Create a config loaded with federation on and subclusterId\n        // for each UAM\n        YarnConfiguration config \u003d new YarnConfiguration(getConf());\n        FederationProxyProviderUtil.updateConfForFederation(config,\n            subClusterId.getId());\n\n        try {\n          this.uamPool.reAttachUAM(subClusterId.getId(), config,\n              this.attemptId.getApplicationId(),\n              this.amRegistrationResponse.getQueue(),\n              getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n              entry.getValue(), subClusterId.toString());\n\n          this.secondaryRelayers.put(subClusterId.getId(),\n              this.uamPool.getAMRMClientRelayer(subClusterId.getId()));\n\n          RegisterApplicationMasterResponse response \u003d\n              this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                  this.amRegistrationRequest);\n\n          // Running containers from secondary RMs\n          for (Container container : response\n              .getContainersFromPreviousAttempts()) {\n            containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n            containers++;\n          }\n          LOG.info(\"Recovered {} running containers from UAM in {}\",\n              response.getContainersFromPreviousAttempts().size(),\n              subClusterId);\n\n        } catch (Exception e) {\n          LOG.error(\"Error reattaching UAM to \" + subClusterId + \" for \"\n              + this.attemptId, e);\n        }\n      }\n\n      // Get the running containers from home RM, note that we will also get the\n      // AM container itself from here. We don\u0027t need it, but no harm to put the\n      // map as well.\n      UserGroupInformation appSubmitter \u003d UserGroupInformation\n          .createRemoteUser(getApplicationContext().getUser());\n      ApplicationClientProtocol rmClient \u003d\n          createHomeRMProxy(getApplicationContext(),\n              ApplicationClientProtocol.class, appSubmitter);\n\n      GetContainersResponse response \u003d rmClient\n          .getContainers(GetContainersRequest.newInstance(this.attemptId));\n      for (ContainerReport container : response.getContainerList()) {\n        containerIdToSubClusterIdMap.put(container.getContainerId(),\n            this.homeSubClusterId);\n        containers++;\n        LOG.debug(\"  From home RM \" + this.homeSubClusterId\n            + \" running container \" + container.getContainerId());\n      }\n      LOG.info(\"{} running containers including AM recovered from home RM \",\n          response.getContainerList().size(), this.homeSubClusterId);\n\n      LOG.info(\n          \"In all {} UAMs {} running containers including AM recovered for {}\",\n          uamMap.size(), containers, this.attemptId);\n\n      if (this.amRegistrationResponse !\u003d null) {\n        // Initialize the AMRMProxyPolicy\n        String queue \u003d this.amRegistrationResponse.getQueue();\n        this.policyInterpreter \u003d\n            FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                getConf(), this.federationFacade, this.homeSubClusterId);\n      }\n    } catch (IOException | YarnException e) {\n      throw new YarnRuntimeException(e);\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "f1525825623a1307b5aa55c456b6afa3e0c61135": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8705. Refactor the UAM heartbeat thread in preparation for YARN-8696. Contributed by Botong Huang.\n",
      "commitDate": "27/08/18 10:32 AM",
      "commitName": "f1525825623a1307b5aa55c456b6afa3e0c61135",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "20/08/18 12:22 PM",
      "commitNameOld": "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 6.92,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,135 @@\n   public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n     super.recover(recoveredDataMap);\n-    ApplicationAttemptId attemptId \u003d\n-        getApplicationContext().getApplicationAttemptId();\n-    LOG.info(\"Recovering data for FederationInterceptor for {}\", attemptId);\n+    LOG.info(\"Recovering data for FederationInterceptor for {}\",\n+        this.attemptId);\n     if (recoveredDataMap \u003d\u003d null) {\n       return;\n     }\n     try {\n       if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n         RegisterApplicationMasterRequestProto pb \u003d\n             RegisterApplicationMasterRequestProto\n                 .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n         this.amRegistrationRequest \u003d\n             new RegisterApplicationMasterRequestPBImpl(pb);\n-        LOG.info(\"amRegistrationRequest recovered for {}\", attemptId);\n+        LOG.info(\"amRegistrationRequest recovered for {}\", this.attemptId);\n \n         // Give the register request to homeRMRelayer for future re-registration\n         this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);\n       }\n       if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n         RegisterApplicationMasterResponseProto pb \u003d\n             RegisterApplicationMasterResponseProto\n                 .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n         this.amRegistrationResponse \u003d\n             new RegisterApplicationMasterResponsePBImpl(pb);\n-        LOG.info(\"amRegistrationResponse recovered for {}\", attemptId);\n+        LOG.info(\"amRegistrationResponse recovered for {}\", this.attemptId);\n         // Trigger re-register and full pending re-send only if we have a\n         // saved register response. This should always be true though.\n         this.justRecovered \u003d true;\n       }\n \n       // Recover UAM amrmTokens from registry or NMSS\n       Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n       if (this.registryClient !\u003d null) {\n         uamMap \u003d this.registryClient\n-            .loadStateFromRegistry(attemptId.getApplicationId());\n+            .loadStateFromRegistry(this.attemptId.getApplicationId());\n         LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n-            uamMap.size(), attemptId.getApplicationId());\n+            uamMap.size(), this.attemptId.getApplicationId());\n       } else {\n         uamMap \u003d new HashMap\u003c\u003e();\n         for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n           if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n             // entry for subClusterId -\u003e UAM amrmToken\n             String scId \u003d\n                 entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n             Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n             amrmToken.decodeFromUrlString(\n                 new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n             uamMap.put(scId, amrmToken);\n             LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n           }\n         }\n         LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n-            uamMap.size(), attemptId.getApplicationId());\n+            uamMap.size(), this.attemptId.getApplicationId());\n       }\n \n       // Re-attach the UAMs\n       int containers \u003d 0;\n       for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n           .entrySet()) {\n         SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n \n         // Create a config loaded with federation on and subclusterId\n         // for each UAM\n         YarnConfiguration config \u003d new YarnConfiguration(getConf());\n         FederationProxyProviderUtil.updateConfForFederation(config,\n             subClusterId.getId());\n \n         try {\n           this.uamPool.reAttachUAM(subClusterId.getId(), config,\n-              attemptId.getApplicationId(),\n+              this.attemptId.getApplicationId(),\n               this.amRegistrationResponse.getQueue(),\n               getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n               entry.getValue());\n \n           this.secondaryRelayers.put(subClusterId.getId(),\n               this.uamPool.getAMRMClientRelayer(subClusterId.getId()));\n \n           RegisterApplicationMasterResponse response \u003d\n               this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                   this.amRegistrationRequest);\n \n           // Running containers from secondary RMs\n           for (Container container : response\n               .getContainersFromPreviousAttempts()) {\n             containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n             containers++;\n           }\n           LOG.info(\"Recovered {} running containers from UAM in {}\",\n               response.getContainersFromPreviousAttempts().size(),\n               subClusterId);\n \n         } catch (Exception e) {\n-          LOG.error(\n-              \"Error reattaching UAM to \" + subClusterId + \" for \" + attemptId,\n-              e);\n+          LOG.error(\"Error reattaching UAM to \" + subClusterId + \" for \"\n+              + this.attemptId, e);\n         }\n       }\n \n       // Get the running containers from home RM, note that we will also get the\n       // AM container itself from here. We don\u0027t need it, but no harm to put the\n       // map as well.\n       UserGroupInformation appSubmitter \u003d UserGroupInformation\n           .createRemoteUser(getApplicationContext().getUser());\n       ApplicationClientProtocol rmClient \u003d\n           createHomeRMProxy(getApplicationContext(),\n               ApplicationClientProtocol.class, appSubmitter);\n \n-      GetContainersResponse response \u003d\n-          rmClient.getContainers(GetContainersRequest.newInstance(attemptId));\n+      GetContainersResponse response \u003d rmClient\n+          .getContainers(GetContainersRequest.newInstance(this.attemptId));\n       for (ContainerReport container : response.getContainerList()) {\n         containerIdToSubClusterIdMap.put(container.getContainerId(),\n             this.homeSubClusterId);\n         containers++;\n         LOG.debug(\"  From home RM \" + this.homeSubClusterId\n             + \" running container \" + container.getContainerId());\n       }\n       LOG.info(\"{} running containers including AM recovered from home RM \",\n           response.getContainerList().size(), this.homeSubClusterId);\n \n       LOG.info(\n           \"In all {} UAMs {} running containers including AM recovered for {}\",\n-          uamMap.size(), containers, attemptId);\n+          uamMap.size(), containers, this.attemptId);\n \n       if (this.amRegistrationResponse !\u003d null) {\n         // Initialize the AMRMProxyPolicy\n         String queue \u003d this.amRegistrationResponse.getQueue();\n         this.policyInterpreter \u003d\n             FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                 getConf(), this.federationFacade, this.homeSubClusterId);\n       }\n     } catch (IOException | YarnException e) {\n       throw new YarnRuntimeException(e);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n    super.recover(recoveredDataMap);\n    LOG.info(\"Recovering data for FederationInterceptor for {}\",\n        this.attemptId);\n    if (recoveredDataMap \u003d\u003d null) {\n      return;\n    }\n    try {\n      if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n        RegisterApplicationMasterRequestProto pb \u003d\n            RegisterApplicationMasterRequestProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n        this.amRegistrationRequest \u003d\n            new RegisterApplicationMasterRequestPBImpl(pb);\n        LOG.info(\"amRegistrationRequest recovered for {}\", this.attemptId);\n\n        // Give the register request to homeRMRelayer for future re-registration\n        this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);\n      }\n      if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n        RegisterApplicationMasterResponseProto pb \u003d\n            RegisterApplicationMasterResponseProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n        this.amRegistrationResponse \u003d\n            new RegisterApplicationMasterResponsePBImpl(pb);\n        LOG.info(\"amRegistrationResponse recovered for {}\", this.attemptId);\n        // Trigger re-register and full pending re-send only if we have a\n        // saved register response. This should always be true though.\n        this.justRecovered \u003d true;\n      }\n\n      // Recover UAM amrmTokens from registry or NMSS\n      Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n      if (this.registryClient !\u003d null) {\n        uamMap \u003d this.registryClient\n            .loadStateFromRegistry(this.attemptId.getApplicationId());\n        LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n            uamMap.size(), this.attemptId.getApplicationId());\n      } else {\n        uamMap \u003d new HashMap\u003c\u003e();\n        for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n          if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n            // entry for subClusterId -\u003e UAM amrmToken\n            String scId \u003d\n                entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n            Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n            amrmToken.decodeFromUrlString(\n                new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n            uamMap.put(scId, amrmToken);\n            LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n          }\n        }\n        LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n            uamMap.size(), this.attemptId.getApplicationId());\n      }\n\n      // Re-attach the UAMs\n      int containers \u003d 0;\n      for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n          .entrySet()) {\n        SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n\n        // Create a config loaded with federation on and subclusterId\n        // for each UAM\n        YarnConfiguration config \u003d new YarnConfiguration(getConf());\n        FederationProxyProviderUtil.updateConfForFederation(config,\n            subClusterId.getId());\n\n        try {\n          this.uamPool.reAttachUAM(subClusterId.getId(), config,\n              this.attemptId.getApplicationId(),\n              this.amRegistrationResponse.getQueue(),\n              getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n              entry.getValue());\n\n          this.secondaryRelayers.put(subClusterId.getId(),\n              this.uamPool.getAMRMClientRelayer(subClusterId.getId()));\n\n          RegisterApplicationMasterResponse response \u003d\n              this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                  this.amRegistrationRequest);\n\n          // Running containers from secondary RMs\n          for (Container container : response\n              .getContainersFromPreviousAttempts()) {\n            containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n            containers++;\n          }\n          LOG.info(\"Recovered {} running containers from UAM in {}\",\n              response.getContainersFromPreviousAttempts().size(),\n              subClusterId);\n\n        } catch (Exception e) {\n          LOG.error(\"Error reattaching UAM to \" + subClusterId + \" for \"\n              + this.attemptId, e);\n        }\n      }\n\n      // Get the running containers from home RM, note that we will also get the\n      // AM container itself from here. We don\u0027t need it, but no harm to put the\n      // map as well.\n      UserGroupInformation appSubmitter \u003d UserGroupInformation\n          .createRemoteUser(getApplicationContext().getUser());\n      ApplicationClientProtocol rmClient \u003d\n          createHomeRMProxy(getApplicationContext(),\n              ApplicationClientProtocol.class, appSubmitter);\n\n      GetContainersResponse response \u003d rmClient\n          .getContainers(GetContainersRequest.newInstance(this.attemptId));\n      for (ContainerReport container : response.getContainerList()) {\n        containerIdToSubClusterIdMap.put(container.getContainerId(),\n            this.homeSubClusterId);\n        containers++;\n        LOG.debug(\"  From home RM \" + this.homeSubClusterId\n            + \" running container \" + container.getContainerId());\n      }\n      LOG.info(\"{} running containers including AM recovered from home RM \",\n          response.getContainerList().size(), this.homeSubClusterId);\n\n      LOG.info(\n          \"In all {} UAMs {} running containers including AM recovered for {}\",\n          uamMap.size(), containers, this.attemptId);\n\n      if (this.amRegistrationResponse !\u003d null) {\n        // Initialize the AMRMProxyPolicy\n        String queue \u003d this.amRegistrationResponse.getQueue();\n        this.policyInterpreter \u003d\n            FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                getConf(), this.federationFacade, this.homeSubClusterId);\n      }\n    } catch (IOException | YarnException e) {\n      throw new YarnRuntimeException(e);\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7899. [AMRMProxy] Stateful FederationInterceptor for pending requests. Contributed by Botong Huang.\n",
      "commitDate": "09/07/18 12:27 PM",
      "commitName": "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "17/05/18 8:00 PM",
      "commitNameOld": "3159bffce23abf35754da2d7d51de7d8c2631ae3",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 52.69,
      "commitsBetweenForRepo": 338,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,129 +1,137 @@\n   public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n     super.recover(recoveredDataMap);\n-    LOG.info(\"Recovering data for FederationInterceptor\");\n+    ApplicationAttemptId attemptId \u003d\n+        getApplicationContext().getApplicationAttemptId();\n+    LOG.info(\"Recovering data for FederationInterceptor for {}\", attemptId);\n     if (recoveredDataMap \u003d\u003d null) {\n       return;\n     }\n-\n-    ApplicationAttemptId attemptId \u003d\n-        getApplicationContext().getApplicationAttemptId();\n     try {\n       if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n         RegisterApplicationMasterRequestProto pb \u003d\n             RegisterApplicationMasterRequestProto\n                 .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n         this.amRegistrationRequest \u003d\n             new RegisterApplicationMasterRequestPBImpl(pb);\n         LOG.info(\"amRegistrationRequest recovered for {}\", attemptId);\n+\n+        // Give the register request to homeRMRelayer for future re-registration\n+        this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);\n       }\n       if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n         RegisterApplicationMasterResponseProto pb \u003d\n             RegisterApplicationMasterResponseProto\n                 .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n         this.amRegistrationResponse \u003d\n             new RegisterApplicationMasterResponsePBImpl(pb);\n         LOG.info(\"amRegistrationResponse recovered for {}\", attemptId);\n+        // Trigger re-register and full pending re-send only if we have a\n+        // saved register response. This should always be true though.\n+        this.justRecovered \u003d true;\n       }\n \n       // Recover UAM amrmTokens from registry or NMSS\n       Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n       if (this.registryClient !\u003d null) {\n         uamMap \u003d this.registryClient\n             .loadStateFromRegistry(attemptId.getApplicationId());\n         LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n             uamMap.size(), attemptId.getApplicationId());\n       } else {\n         uamMap \u003d new HashMap\u003c\u003e();\n         for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n           if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n             // entry for subClusterId -\u003e UAM amrmToken\n             String scId \u003d\n                 entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n             Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n             amrmToken.decodeFromUrlString(\n                 new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n             uamMap.put(scId, amrmToken);\n             LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n           }\n         }\n         LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n             uamMap.size(), attemptId.getApplicationId());\n       }\n \n       // Re-attach the UAMs\n       int containers \u003d 0;\n       for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n           .entrySet()) {\n         SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n \n         // Create a config loaded with federation on and subclusterId\n         // for each UAM\n         YarnConfiguration config \u003d new YarnConfiguration(getConf());\n         FederationProxyProviderUtil.updateConfForFederation(config,\n             subClusterId.getId());\n \n         try {\n           this.uamPool.reAttachUAM(subClusterId.getId(), config,\n               attemptId.getApplicationId(),\n               this.amRegistrationResponse.getQueue(),\n               getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n               entry.getValue());\n \n+          this.secondaryRelayers.put(subClusterId.getId(),\n+              this.uamPool.getAMRMClientRelayer(subClusterId.getId()));\n+\n           RegisterApplicationMasterResponse response \u003d\n               this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                   this.amRegistrationRequest);\n \n           // Running containers from secondary RMs\n           for (Container container : response\n               .getContainersFromPreviousAttempts()) {\n             containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n             containers++;\n           }\n           LOG.info(\"Recovered {} running containers from UAM in {}\",\n               response.getContainersFromPreviousAttempts().size(),\n               subClusterId);\n \n         } catch (Exception e) {\n           LOG.error(\n               \"Error reattaching UAM to \" + subClusterId + \" for \" + attemptId,\n               e);\n         }\n       }\n \n       // Get the running containers from home RM, note that we will also get the\n       // AM container itself from here. We don\u0027t need it, but no harm to put the\n       // map as well.\n       UserGroupInformation appSubmitter \u003d UserGroupInformation\n           .createRemoteUser(getApplicationContext().getUser());\n       ApplicationClientProtocol rmClient \u003d\n           createHomeRMProxy(getApplicationContext(),\n               ApplicationClientProtocol.class, appSubmitter);\n \n       GetContainersResponse response \u003d\n           rmClient.getContainers(GetContainersRequest.newInstance(attemptId));\n       for (ContainerReport container : response.getContainerList()) {\n         containerIdToSubClusterIdMap.put(container.getContainerId(),\n             this.homeSubClusterId);\n         containers++;\n         LOG.debug(\"  From home RM \" + this.homeSubClusterId\n             + \" running container \" + container.getContainerId());\n       }\n       LOG.info(\"{} running containers including AM recovered from home RM \",\n           response.getContainerList().size(), this.homeSubClusterId);\n \n       LOG.info(\n           \"In all {} UAMs {} running containers including AM recovered for {}\",\n           uamMap.size(), containers, attemptId);\n \n       if (this.amRegistrationResponse !\u003d null) {\n         // Initialize the AMRMProxyPolicy\n         String queue \u003d this.amRegistrationResponse.getQueue();\n         this.policyInterpreter \u003d\n             FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                 getConf(), this.federationFacade, this.homeSubClusterId);\n       }\n     } catch (IOException | YarnException e) {\n       throw new YarnRuntimeException(e);\n     }\n \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n    super.recover(recoveredDataMap);\n    ApplicationAttemptId attemptId \u003d\n        getApplicationContext().getApplicationAttemptId();\n    LOG.info(\"Recovering data for FederationInterceptor for {}\", attemptId);\n    if (recoveredDataMap \u003d\u003d null) {\n      return;\n    }\n    try {\n      if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n        RegisterApplicationMasterRequestProto pb \u003d\n            RegisterApplicationMasterRequestProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n        this.amRegistrationRequest \u003d\n            new RegisterApplicationMasterRequestPBImpl(pb);\n        LOG.info(\"amRegistrationRequest recovered for {}\", attemptId);\n\n        // Give the register request to homeRMRelayer for future re-registration\n        this.homeRMRelayer.setAMRegistrationRequest(this.amRegistrationRequest);\n      }\n      if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n        RegisterApplicationMasterResponseProto pb \u003d\n            RegisterApplicationMasterResponseProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n        this.amRegistrationResponse \u003d\n            new RegisterApplicationMasterResponsePBImpl(pb);\n        LOG.info(\"amRegistrationResponse recovered for {}\", attemptId);\n        // Trigger re-register and full pending re-send only if we have a\n        // saved register response. This should always be true though.\n        this.justRecovered \u003d true;\n      }\n\n      // Recover UAM amrmTokens from registry or NMSS\n      Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n      if (this.registryClient !\u003d null) {\n        uamMap \u003d this.registryClient\n            .loadStateFromRegistry(attemptId.getApplicationId());\n        LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n            uamMap.size(), attemptId.getApplicationId());\n      } else {\n        uamMap \u003d new HashMap\u003c\u003e();\n        for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n          if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n            // entry for subClusterId -\u003e UAM amrmToken\n            String scId \u003d\n                entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n            Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n            amrmToken.decodeFromUrlString(\n                new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n            uamMap.put(scId, amrmToken);\n            LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n          }\n        }\n        LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n            uamMap.size(), attemptId.getApplicationId());\n      }\n\n      // Re-attach the UAMs\n      int containers \u003d 0;\n      for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n          .entrySet()) {\n        SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n\n        // Create a config loaded with federation on and subclusterId\n        // for each UAM\n        YarnConfiguration config \u003d new YarnConfiguration(getConf());\n        FederationProxyProviderUtil.updateConfForFederation(config,\n            subClusterId.getId());\n\n        try {\n          this.uamPool.reAttachUAM(subClusterId.getId(), config,\n              attemptId.getApplicationId(),\n              this.amRegistrationResponse.getQueue(),\n              getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n              entry.getValue());\n\n          this.secondaryRelayers.put(subClusterId.getId(),\n              this.uamPool.getAMRMClientRelayer(subClusterId.getId()));\n\n          RegisterApplicationMasterResponse response \u003d\n              this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                  this.amRegistrationRequest);\n\n          // Running containers from secondary RMs\n          for (Container container : response\n              .getContainersFromPreviousAttempts()) {\n            containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n            containers++;\n          }\n          LOG.info(\"Recovered {} running containers from UAM in {}\",\n              response.getContainersFromPreviousAttempts().size(),\n              subClusterId);\n\n        } catch (Exception e) {\n          LOG.error(\n              \"Error reattaching UAM to \" + subClusterId + \" for \" + attemptId,\n              e);\n        }\n      }\n\n      // Get the running containers from home RM, note that we will also get the\n      // AM container itself from here. We don\u0027t need it, but no harm to put the\n      // map as well.\n      UserGroupInformation appSubmitter \u003d UserGroupInformation\n          .createRemoteUser(getApplicationContext().getUser());\n      ApplicationClientProtocol rmClient \u003d\n          createHomeRMProxy(getApplicationContext(),\n              ApplicationClientProtocol.class, appSubmitter);\n\n      GetContainersResponse response \u003d\n          rmClient.getContainers(GetContainersRequest.newInstance(attemptId));\n      for (ContainerReport container : response.getContainerList()) {\n        containerIdToSubClusterIdMap.put(container.getContainerId(),\n            this.homeSubClusterId);\n        containers++;\n        LOG.debug(\"  From home RM \" + this.homeSubClusterId\n            + \" running container \" + container.getContainerId());\n      }\n      LOG.info(\"{} running containers including AM recovered from home RM \",\n          response.getContainerList().size(), this.homeSubClusterId);\n\n      LOG.info(\n          \"In all {} UAMs {} running containers including AM recovered for {}\",\n          uamMap.size(), containers, attemptId);\n\n      if (this.amRegistrationResponse !\u003d null) {\n        // Initialize the AMRMProxyPolicy\n        String queue \u003d this.amRegistrationResponse.getQueue();\n        this.policyInterpreter \u003d\n            FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                getConf(), this.federationFacade, this.homeSubClusterId);\n      }\n    } catch (IOException | YarnException e) {\n      throw new YarnRuntimeException(e);\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "670e8d4ec7e71fc3b054cd3b2826f869b649a788": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6704. Add support for work preserving NM restart when FederationInterceptor is enabled in AMRMProxyService. (Botong Huang via Subru).\n",
      "commitDate": "08/12/17 3:39 PM",
      "commitName": "670e8d4ec7e71fc3b054cd3b2826f869b649a788",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,129 @@\n+  public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n+    super.recover(recoveredDataMap);\n+    LOG.info(\"Recovering data for FederationInterceptor\");\n+    if (recoveredDataMap \u003d\u003d null) {\n+      return;\n+    }\n+\n+    ApplicationAttemptId attemptId \u003d\n+        getApplicationContext().getApplicationAttemptId();\n+    try {\n+      if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n+        RegisterApplicationMasterRequestProto pb \u003d\n+            RegisterApplicationMasterRequestProto\n+                .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n+        this.amRegistrationRequest \u003d\n+            new RegisterApplicationMasterRequestPBImpl(pb);\n+        LOG.info(\"amRegistrationRequest recovered for {}\", attemptId);\n+      }\n+      if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n+        RegisterApplicationMasterResponseProto pb \u003d\n+            RegisterApplicationMasterResponseProto\n+                .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n+        this.amRegistrationResponse \u003d\n+            new RegisterApplicationMasterResponsePBImpl(pb);\n+        LOG.info(\"amRegistrationResponse recovered for {}\", attemptId);\n+      }\n+\n+      // Recover UAM amrmTokens from registry or NMSS\n+      Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n+      if (this.registryClient !\u003d null) {\n+        uamMap \u003d this.registryClient\n+            .loadStateFromRegistry(attemptId.getApplicationId());\n+        LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n+            uamMap.size(), attemptId.getApplicationId());\n+      } else {\n+        uamMap \u003d new HashMap\u003c\u003e();\n+        for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n+          if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n+            // entry for subClusterId -\u003e UAM amrmToken\n+            String scId \u003d\n+                entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n+            Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n+            amrmToken.decodeFromUrlString(\n+                new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n+            uamMap.put(scId, amrmToken);\n+            LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n+          }\n+        }\n+        LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n+            uamMap.size(), attemptId.getApplicationId());\n+      }\n+\n+      // Re-attach the UAMs\n+      int containers \u003d 0;\n+      for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n+          .entrySet()) {\n+        SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n+\n+        // Create a config loaded with federation on and subclusterId\n+        // for each UAM\n+        YarnConfiguration config \u003d new YarnConfiguration(getConf());\n+        FederationProxyProviderUtil.updateConfForFederation(config,\n+            subClusterId.getId());\n+\n+        try {\n+          this.uamPool.reAttachUAM(subClusterId.getId(), config,\n+              attemptId.getApplicationId(),\n+              this.amRegistrationResponse.getQueue(),\n+              getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n+              entry.getValue());\n+\n+          RegisterApplicationMasterResponse response \u003d\n+              this.uamPool.registerApplicationMaster(subClusterId.getId(),\n+                  this.amRegistrationRequest);\n+\n+          // Running containers from secondary RMs\n+          for (Container container : response\n+              .getContainersFromPreviousAttempts()) {\n+            containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n+            containers++;\n+          }\n+          LOG.info(\"Recovered {} running containers from UAM in {}\",\n+              response.getContainersFromPreviousAttempts().size(),\n+              subClusterId);\n+\n+        } catch (Exception e) {\n+          LOG.error(\n+              \"Error reattaching UAM to \" + subClusterId + \" for \" + attemptId,\n+              e);\n+        }\n+      }\n+\n+      // Get the running containers from home RM, note that we will also get the\n+      // AM container itself from here. We don\u0027t need it, but no harm to put the\n+      // map as well.\n+      UserGroupInformation appSubmitter \u003d UserGroupInformation\n+          .createRemoteUser(getApplicationContext().getUser());\n+      ApplicationClientProtocol rmClient \u003d\n+          createHomeRMProxy(getApplicationContext(),\n+              ApplicationClientProtocol.class, appSubmitter);\n+\n+      GetContainersResponse response \u003d\n+          rmClient.getContainers(GetContainersRequest.newInstance(attemptId));\n+      for (ContainerReport container : response.getContainerList()) {\n+        containerIdToSubClusterIdMap.put(container.getContainerId(),\n+            this.homeSubClusterId);\n+        containers++;\n+        LOG.debug(\"  From home RM \" + this.homeSubClusterId\n+            + \" running container \" + container.getContainerId());\n+      }\n+      LOG.info(\"{} running containers including AM recovered from home RM \",\n+          response.getContainerList().size(), this.homeSubClusterId);\n+\n+      LOG.info(\n+          \"In all {} UAMs {} running containers including AM recovered for {}\",\n+          uamMap.size(), containers, attemptId);\n+\n+      if (this.amRegistrationResponse !\u003d null) {\n+        // Initialize the AMRMProxyPolicy\n+        String queue \u003d this.amRegistrationResponse.getQueue();\n+        this.policyInterpreter \u003d\n+            FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n+                getConf(), this.federationFacade, this.homeSubClusterId);\n+      }\n+    } catch (IOException | YarnException e) {\n+      throw new YarnRuntimeException(e);\n+    }\n+\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void recover(Map\u003cString, byte[]\u003e recoveredDataMap) {\n    super.recover(recoveredDataMap);\n    LOG.info(\"Recovering data for FederationInterceptor\");\n    if (recoveredDataMap \u003d\u003d null) {\n      return;\n    }\n\n    ApplicationAttemptId attemptId \u003d\n        getApplicationContext().getApplicationAttemptId();\n    try {\n      if (recoveredDataMap.containsKey(NMSS_REG_REQUEST_KEY)) {\n        RegisterApplicationMasterRequestProto pb \u003d\n            RegisterApplicationMasterRequestProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_REQUEST_KEY));\n        this.amRegistrationRequest \u003d\n            new RegisterApplicationMasterRequestPBImpl(pb);\n        LOG.info(\"amRegistrationRequest recovered for {}\", attemptId);\n      }\n      if (recoveredDataMap.containsKey(NMSS_REG_RESPONSE_KEY)) {\n        RegisterApplicationMasterResponseProto pb \u003d\n            RegisterApplicationMasterResponseProto\n                .parseFrom(recoveredDataMap.get(NMSS_REG_RESPONSE_KEY));\n        this.amRegistrationResponse \u003d\n            new RegisterApplicationMasterResponsePBImpl(pb);\n        LOG.info(\"amRegistrationResponse recovered for {}\", attemptId);\n      }\n\n      // Recover UAM amrmTokens from registry or NMSS\n      Map\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e uamMap;\n      if (this.registryClient !\u003d null) {\n        uamMap \u003d this.registryClient\n            .loadStateFromRegistry(attemptId.getApplicationId());\n        LOG.info(\"Found {} existing UAMs for application {} in Yarn Registry\",\n            uamMap.size(), attemptId.getApplicationId());\n      } else {\n        uamMap \u003d new HashMap\u003c\u003e();\n        for (Entry\u003cString, byte[]\u003e entry : recoveredDataMap.entrySet()) {\n          if (entry.getKey().startsWith(NMSS_SECONDARY_SC_PREFIX)) {\n            // entry for subClusterId -\u003e UAM amrmToken\n            String scId \u003d\n                entry.getKey().substring(NMSS_SECONDARY_SC_PREFIX.length());\n            Token\u003cAMRMTokenIdentifier\u003e amrmToken \u003d new Token\u003c\u003e();\n            amrmToken.decodeFromUrlString(\n                new String(entry.getValue(), STRING_TO_BYTE_FORMAT));\n            uamMap.put(scId, amrmToken);\n            LOG.debug(\"Recovered UAM in \" + scId + \" from NMSS\");\n          }\n        }\n        LOG.info(\"Found {} existing UAMs for application {} in NMStateStore\",\n            uamMap.size(), attemptId.getApplicationId());\n      }\n\n      // Re-attach the UAMs\n      int containers \u003d 0;\n      for (Map.Entry\u003cString, Token\u003cAMRMTokenIdentifier\u003e\u003e entry : uamMap\n          .entrySet()) {\n        SubClusterId subClusterId \u003d SubClusterId.newInstance(entry.getKey());\n\n        // Create a config loaded with federation on and subclusterId\n        // for each UAM\n        YarnConfiguration config \u003d new YarnConfiguration(getConf());\n        FederationProxyProviderUtil.updateConfForFederation(config,\n            subClusterId.getId());\n\n        try {\n          this.uamPool.reAttachUAM(subClusterId.getId(), config,\n              attemptId.getApplicationId(),\n              this.amRegistrationResponse.getQueue(),\n              getApplicationContext().getUser(), this.homeSubClusterId.getId(),\n              entry.getValue());\n\n          RegisterApplicationMasterResponse response \u003d\n              this.uamPool.registerApplicationMaster(subClusterId.getId(),\n                  this.amRegistrationRequest);\n\n          // Running containers from secondary RMs\n          for (Container container : response\n              .getContainersFromPreviousAttempts()) {\n            containerIdToSubClusterIdMap.put(container.getId(), subClusterId);\n            containers++;\n          }\n          LOG.info(\"Recovered {} running containers from UAM in {}\",\n              response.getContainersFromPreviousAttempts().size(),\n              subClusterId);\n\n        } catch (Exception e) {\n          LOG.error(\n              \"Error reattaching UAM to \" + subClusterId + \" for \" + attemptId,\n              e);\n        }\n      }\n\n      // Get the running containers from home RM, note that we will also get the\n      // AM container itself from here. We don\u0027t need it, but no harm to put the\n      // map as well.\n      UserGroupInformation appSubmitter \u003d UserGroupInformation\n          .createRemoteUser(getApplicationContext().getUser());\n      ApplicationClientProtocol rmClient \u003d\n          createHomeRMProxy(getApplicationContext(),\n              ApplicationClientProtocol.class, appSubmitter);\n\n      GetContainersResponse response \u003d\n          rmClient.getContainers(GetContainersRequest.newInstance(attemptId));\n      for (ContainerReport container : response.getContainerList()) {\n        containerIdToSubClusterIdMap.put(container.getContainerId(),\n            this.homeSubClusterId);\n        containers++;\n        LOG.debug(\"  From home RM \" + this.homeSubClusterId\n            + \" running container \" + container.getContainerId());\n      }\n      LOG.info(\"{} running containers including AM recovered from home RM \",\n          response.getContainerList().size(), this.homeSubClusterId);\n\n      LOG.info(\n          \"In all {} UAMs {} running containers including AM recovered for {}\",\n          uamMap.size(), containers, attemptId);\n\n      if (this.amRegistrationResponse !\u003d null) {\n        // Initialize the AMRMProxyPolicy\n        String queue \u003d this.amRegistrationResponse.getQueue();\n        this.policyInterpreter \u003d\n            FederationPolicyUtils.loadAMRMPolicy(queue, this.policyInterpreter,\n                getConf(), this.federationFacade, this.homeSubClusterId);\n      }\n    } catch (IOException | YarnException e) {\n      throw new YarnRuntimeException(e);\n    }\n\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java"
    }
  }
}