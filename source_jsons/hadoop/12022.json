{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FsDatasetImpl.java",
  "functionName": "checkAndUpdate",
  "functionId": "checkAndUpdate___bpid-String__scanInfo-ScanInfo",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
  "functionStartLine": 2441,
  "functionEndLine": 2645,
  "numCommitsSeen": 428,
  "timeTaken": 17730,
  "changeHistory": [
    "d3b595157256e198c4340d555e14ad6144f2eaa1",
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
    "b668eb91556b8c85c2b4925808ccb1f769031c20",
    "abdea26280136587a47aea075ada6122d40d706e",
    "ac5ae0065a127ac150a887fa6c6f3cffd86ef733",
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389",
    "96b12662ea76e3ded4ef13944fc8df206cfb4613",
    "86c9862bec0248d671e657aa56094a2919b8ac14",
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
    "da6f1b88dd47e22b24d44f6fc8bbee73e85746f7",
    "e453989a5722e653bd97e3e54f9bbdffc9454fba",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "76e7264e8d6407f527bd877009aca11f7bb63bd7",
    "6e62a1a6728b1f782f64065424f92b292c3f163a",
    "c0af72c7f74b6925786e24543cac433b906dd6d3",
    "b2d5ed36bcb80e2581191dcdc3976e825c959142",
    "9f22fb8c9a10952225e15c7b67b5f77fa44b155d",
    "eb448e14399e17f11b9e523e4050de245b9b0408",
    "fba994ffe20d387e8ed875e727fc3d93f7097101",
    "f39f8c57344ede533ca4363c98230f3a0c401a76",
    "46099ce7f1a1d5aab85d9408dc1454fcbe54f7e8",
    "bc13dfb1426944ce45293cb8f444239a7406762c",
    "662b1887af4e39f3eadd7dda4953c7f2529b43bc",
    "501a283986d7bc4dff7bba12610576ffe982c34d",
    "b6ffb08a467f1b5bc89e5114c462c3117b337be6",
    "b7cd8c0f865e88e40eee75fd2690b1fdc4155071",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "d3b595157256e198c4340d555e14ad6144f2eaa1": "Ybodychange",
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8": "Ybodychange",
    "b668eb91556b8c85c2b4925808ccb1f769031c20": "Ymultichange(Yparameterchange,Ybodychange)",
    "abdea26280136587a47aea075ada6122d40d706e": "Ybodychange",
    "ac5ae0065a127ac150a887fa6c6f3cffd86ef733": "Ybodychange",
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389": "Ybodychange",
    "96b12662ea76e3ded4ef13944fc8df206cfb4613": "Ybodychange",
    "86c9862bec0248d671e657aa56094a2919b8ac14": "Ybodychange",
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c": "Ybodychange",
    "da6f1b88dd47e22b24d44f6fc8bbee73e85746f7": "Ybodychange",
    "e453989a5722e653bd97e3e54f9bbdffc9454fba": "Ybodychange",
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "76e7264e8d6407f527bd877009aca11f7bb63bd7": "Ybodychange",
    "6e62a1a6728b1f782f64065424f92b292c3f163a": "Ybodychange",
    "c0af72c7f74b6925786e24543cac433b906dd6d3": "Ybodychange",
    "b2d5ed36bcb80e2581191dcdc3976e825c959142": "Ybodychange",
    "9f22fb8c9a10952225e15c7b67b5f77fa44b155d": "Ybodychange",
    "eb448e14399e17f11b9e523e4050de245b9b0408": "Ymultichange(Yexceptionschange,Ybodychange)",
    "fba994ffe20d387e8ed875e727fc3d93f7097101": "Ybodychange",
    "f39f8c57344ede533ca4363c98230f3a0c401a76": "Ybodychange",
    "46099ce7f1a1d5aab85d9408dc1454fcbe54f7e8": "Ybodychange",
    "bc13dfb1426944ce45293cb8f444239a7406762c": "Ymultichange(Ymovefromfile,Ybodychange)",
    "662b1887af4e39f3eadd7dda4953c7f2529b43bc": "Yparameterchange",
    "501a283986d7bc4dff7bba12610576ffe982c34d": "Ybodychange",
    "b6ffb08a467f1b5bc89e5114c462c3117b337be6": "Ymultichange(Yparameterchange,Ybodychange)",
    "b7cd8c0f865e88e40eee75fd2690b1fdc4155071": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d3b595157256e198c4340d555e14ad6144f2eaa1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15242. Add metrics for operations hold lock times of FsDatasetImpl. Contributed by Xiaoqiao He.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\nReviewed-by: Inigo Goiri \u003cinigoiri@apache.org\u003e\n",
      "commitDate": "01/04/20 4:36 PM",
      "commitName": "d3b595157256e198c4340d555e14ad6144f2eaa1",
      "commitAuthor": "He Xiaoqiao",
      "commitDateOld": "11/02/20 8:00 AM",
      "commitNameOld": "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
      "commitAuthorOld": "Stephen O\u0027Donnell",
      "daysBetweenCommits": 50.32,
      "commitsBetweenForRepo": 174,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,199 +1,205 @@\n   public void checkAndUpdate(String bpid, ScanInfo scanInfo)\n       throws IOException {\n \n     long blockId \u003d scanInfo.getBlockId();\n     File diskFile \u003d scanInfo.getBlockFile();\n     File diskMetaFile \u003d scanInfo.getMetaFile();\n     FsVolumeSpi vol \u003d scanInfo.getVolume();\n \n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n+    long startTimeMs \u003d Time.monotonicNow();\n     try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026\n           memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n       final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n           fileIoProvider.exists(vol, diskMetaFile);\n       final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n           fileIoProvider.exists(vol, diskFile);\n \n       final long diskGS \u003d diskMetaFileExists ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n           HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n       if (vol.getStorageType() \u003d\u003d StorageType.PROVIDED) {\n         if (memBlockInfo \u003d\u003d null) {\n           // replica exists on provided store but not in memory\n           ReplicaInfo diskBlockInfo \u003d\n               new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setFileRegion(scanInfo.getFileRegion())\n               .setFsVolume(vol)\n               .setConf(conf)\n               .build();\n \n           volumeMap.add(bpid, diskBlockInfo);\n           LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         } else {\n           // replica exists in memory but not in the provided store\n           volumeMap.remove(bpid, blockId);\n           LOG.warn(\"Deleting missing provided block \" + memBlockInfo);\n         }\n         return;\n       }\n \n       if (!diskFileExists) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.blockDataExists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n             .setBlockId(blockId)\n             .setLength(diskFile.length())\n             .setGenerationStamp(diskGS)\n             .setFsVolume(vol)\n             .setDirectoryToUse(diskFile.getParentFile())\n             .build();\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           long lockedBytesReserved \u003d\n               cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                   diskBlockInfo.getNumBytes() : 0;\n           ramDiskReplicaTracker.addReplica(\n               bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       if (memBlockInfo.blockDataExists()) {\n         if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n           if (diskMetaFileExists) {\n             if (memBlockInfo.metadataExists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d\n                   new ReplicaBuilder(ReplicaState.FINALIZED)\n                     .setBlockId(blockId)\n                     .setLength(diskFile.length())\n                     .setGenerationStamp(diskGS)\n                     .setFsVolume(vol)\n                     .setDirectoryToUse(diskFile.getParentFile())\n                     .build();\n               ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!fileIoProvider.delete(vol, diskFile)) {\n               LOG.warn(\"Failed to delete \" + diskFile);\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in replica \"\n             + memBlockInfo.getBlockURI()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.updateWithReplica(\n             StorageLocation.parse(diskFile.toString()));\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (fileIoProvider.exists(vol, memMetaFile)) {\n           String warningPrefix \u003d \"Metadata file in memory \"\n               + memMetaFile.getAbsolutePath()\n               + \" does not match file found by scan \";\n           if (!diskMetaFileExists) {\n             LOG.warn(warningPrefix + \"null\");\n           } else if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           try {\n             File memFile \u003d new File(memBlockInfo.getBlockURI());\n             long gs \u003d diskMetaFileExists \u0026\u0026\n                 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                 : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n             LOG.warn(\"Updating generation stamp for block \" + blockId\n                 + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n             memBlockInfo.setGenerationStamp(gs);\n           } catch (IllegalArgumentException e) {\n             //exception arises because the URI cannot be converted to a file\n             LOG.warn(\"Block URI could not be resolved to a file\", e);\n           }\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \"\n             + memBlockInfo.getBlockDataLength());\n         memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n       }\n+    } finally {\n+      if (dataNodeMetrics !\u003d null) {\n+        long checkAndUpdateTimeMs \u003d Time.monotonicNow() - startTimeMs;\n+        dataNodeMetrics.addCheckAndUpdateOp(checkAndUpdateTimeMs);\n+      }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n             memBlockInfo.getVolume());\n       } catch (IOException e) {\n         LOG.warn(\"Failed to report bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, ScanInfo scanInfo)\n      throws IOException {\n\n    long blockId \u003d scanInfo.getBlockId();\n    File diskFile \u003d scanInfo.getBlockFile();\n    File diskMetaFile \u003d scanInfo.getMetaFile();\n    FsVolumeSpi vol \u003d scanInfo.getVolume();\n\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    long startTimeMs \u003d Time.monotonicNow();\n    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026\n          memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n      final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskMetaFile);\n      final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskFile);\n\n      final long diskGS \u003d diskMetaFileExists ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n          HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (vol.getStorageType() \u003d\u003d StorageType.PROVIDED) {\n        if (memBlockInfo \u003d\u003d null) {\n          // replica exists on provided store but not in memory\n          ReplicaInfo diskBlockInfo \u003d\n              new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setFileRegion(scanInfo.getFileRegion())\n              .setFsVolume(vol)\n              .setConf(conf)\n              .build();\n\n          volumeMap.add(bpid, diskBlockInfo);\n          LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        } else {\n          // replica exists in memory but not in the provided store\n          volumeMap.remove(bpid, blockId);\n          LOG.warn(\"Deleting missing provided block \" + memBlockInfo);\n        }\n        return;\n      }\n\n      if (!diskFileExists) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.blockDataExists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n            .setBlockId(blockId)\n            .setLength(diskFile.length())\n            .setGenerationStamp(diskGS)\n            .setFsVolume(vol)\n            .setDirectoryToUse(diskFile.getParentFile())\n            .build();\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          long lockedBytesReserved \u003d\n              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                  diskBlockInfo.getNumBytes() : 0;\n          ramDiskReplicaTracker.addReplica(\n              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      if (memBlockInfo.blockDataExists()) {\n        if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n          if (diskMetaFileExists) {\n            if (memBlockInfo.metadataExists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d\n                  new ReplicaBuilder(ReplicaState.FINALIZED)\n                    .setBlockId(blockId)\n                    .setLength(diskFile.length())\n                    .setGenerationStamp(diskGS)\n                    .setFsVolume(vol)\n                    .setDirectoryToUse(diskFile.getParentFile())\n                    .build();\n              ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!fileIoProvider.delete(vol, diskFile)) {\n              LOG.warn(\"Failed to delete \" + diskFile);\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in replica \"\n            + memBlockInfo.getBlockURI()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.updateWithReplica(\n            StorageLocation.parse(diskFile.toString()));\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (fileIoProvider.exists(vol, memMetaFile)) {\n          String warningPrefix \u003d \"Metadata file in memory \"\n              + memMetaFile.getAbsolutePath()\n              + \" does not match file found by scan \";\n          if (!diskMetaFileExists) {\n            LOG.warn(warningPrefix + \"null\");\n          } else if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          try {\n            File memFile \u003d new File(memBlockInfo.getBlockURI());\n            long gs \u003d diskMetaFileExists \u0026\u0026\n                diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n            LOG.warn(\"Updating generation stamp for block \" + blockId\n                + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n            memBlockInfo.setGenerationStamp(gs);\n          } catch (IllegalArgumentException e) {\n            //exception arises because the URI cannot be converted to a file\n            LOG.warn(\"Block URI could not be resolved to a file\", e);\n          }\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \"\n            + memBlockInfo.getBlockDataLength());\n        memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n      }\n    } finally {\n      if (dataNodeMetrics !\u003d null) {\n        long checkAndUpdateTimeMs \u003d Time.monotonicNow() - startTimeMs;\n        dataNodeMetrics.addCheckAndUpdateOp(checkAndUpdateTimeMs);\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n            memBlockInfo.getVolume());\n      } catch (IOException e) {\n        LOG.warn(\"Failed to report bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15150. Introduce read write lock to Datanode. Contributed Stephen O\u0027Donnell.\n\nSigned-off-by: Wei-Chiu Chuang \u003cweichiu@apache.org\u003e\n",
      "commitDate": "11/02/20 8:00 AM",
      "commitName": "d7c136b9ed6d99e1b03f5b89723b3a20df359ba8",
      "commitAuthor": "Stephen O\u0027Donnell",
      "commitDateOld": "28/01/20 10:10 AM",
      "commitNameOld": "1839c467f60cbb8592d446694ec3d7710cda5142",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 13.91,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,199 +1,199 @@\n   public void checkAndUpdate(String bpid, ScanInfo scanInfo)\n       throws IOException {\n \n     long blockId \u003d scanInfo.getBlockId();\n     File diskFile \u003d scanInfo.getBlockFile();\n     File diskMetaFile \u003d scanInfo.getMetaFile();\n     FsVolumeSpi vol \u003d scanInfo.getVolume();\n \n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n-    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n+    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026\n           memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n       final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n           fileIoProvider.exists(vol, diskMetaFile);\n       final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n           fileIoProvider.exists(vol, diskFile);\n \n       final long diskGS \u003d diskMetaFileExists ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n           HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n       if (vol.getStorageType() \u003d\u003d StorageType.PROVIDED) {\n         if (memBlockInfo \u003d\u003d null) {\n           // replica exists on provided store but not in memory\n           ReplicaInfo diskBlockInfo \u003d\n               new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setFileRegion(scanInfo.getFileRegion())\n               .setFsVolume(vol)\n               .setConf(conf)\n               .build();\n \n           volumeMap.add(bpid, diskBlockInfo);\n           LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         } else {\n           // replica exists in memory but not in the provided store\n           volumeMap.remove(bpid, blockId);\n           LOG.warn(\"Deleting missing provided block \" + memBlockInfo);\n         }\n         return;\n       }\n \n       if (!diskFileExists) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.blockDataExists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n             .setBlockId(blockId)\n             .setLength(diskFile.length())\n             .setGenerationStamp(diskGS)\n             .setFsVolume(vol)\n             .setDirectoryToUse(diskFile.getParentFile())\n             .build();\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           long lockedBytesReserved \u003d\n               cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                   diskBlockInfo.getNumBytes() : 0;\n           ramDiskReplicaTracker.addReplica(\n               bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       if (memBlockInfo.blockDataExists()) {\n         if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n           if (diskMetaFileExists) {\n             if (memBlockInfo.metadataExists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d\n                   new ReplicaBuilder(ReplicaState.FINALIZED)\n                     .setBlockId(blockId)\n                     .setLength(diskFile.length())\n                     .setGenerationStamp(diskGS)\n                     .setFsVolume(vol)\n                     .setDirectoryToUse(diskFile.getParentFile())\n                     .build();\n               ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!fileIoProvider.delete(vol, diskFile)) {\n               LOG.warn(\"Failed to delete \" + diskFile);\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in replica \"\n             + memBlockInfo.getBlockURI()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.updateWithReplica(\n             StorageLocation.parse(diskFile.toString()));\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (fileIoProvider.exists(vol, memMetaFile)) {\n           String warningPrefix \u003d \"Metadata file in memory \"\n               + memMetaFile.getAbsolutePath()\n               + \" does not match file found by scan \";\n           if (!diskMetaFileExists) {\n             LOG.warn(warningPrefix + \"null\");\n           } else if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           try {\n             File memFile \u003d new File(memBlockInfo.getBlockURI());\n             long gs \u003d diskMetaFileExists \u0026\u0026\n                 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                 : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n             LOG.warn(\"Updating generation stamp for block \" + blockId\n                 + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n             memBlockInfo.setGenerationStamp(gs);\n           } catch (IllegalArgumentException e) {\n             //exception arises because the URI cannot be converted to a file\n             LOG.warn(\"Block URI could not be resolved to a file\", e);\n           }\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \"\n             + memBlockInfo.getBlockDataLength());\n         memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n             memBlockInfo.getVolume());\n       } catch (IOException e) {\n         LOG.warn(\"Failed to report bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, ScanInfo scanInfo)\n      throws IOException {\n\n    long blockId \u003d scanInfo.getBlockId();\n    File diskFile \u003d scanInfo.getBlockFile();\n    File diskMetaFile \u003d scanInfo.getMetaFile();\n    FsVolumeSpi vol \u003d scanInfo.getVolume();\n\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    try (AutoCloseableLock lock \u003d datasetWriteLock.acquire()) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026\n          memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n      final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskMetaFile);\n      final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskFile);\n\n      final long diskGS \u003d diskMetaFileExists ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n          HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (vol.getStorageType() \u003d\u003d StorageType.PROVIDED) {\n        if (memBlockInfo \u003d\u003d null) {\n          // replica exists on provided store but not in memory\n          ReplicaInfo diskBlockInfo \u003d\n              new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setFileRegion(scanInfo.getFileRegion())\n              .setFsVolume(vol)\n              .setConf(conf)\n              .build();\n\n          volumeMap.add(bpid, diskBlockInfo);\n          LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        } else {\n          // replica exists in memory but not in the provided store\n          volumeMap.remove(bpid, blockId);\n          LOG.warn(\"Deleting missing provided block \" + memBlockInfo);\n        }\n        return;\n      }\n\n      if (!diskFileExists) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.blockDataExists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n            .setBlockId(blockId)\n            .setLength(diskFile.length())\n            .setGenerationStamp(diskGS)\n            .setFsVolume(vol)\n            .setDirectoryToUse(diskFile.getParentFile())\n            .build();\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          long lockedBytesReserved \u003d\n              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                  diskBlockInfo.getNumBytes() : 0;\n          ramDiskReplicaTracker.addReplica(\n              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      if (memBlockInfo.blockDataExists()) {\n        if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n          if (diskMetaFileExists) {\n            if (memBlockInfo.metadataExists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d\n                  new ReplicaBuilder(ReplicaState.FINALIZED)\n                    .setBlockId(blockId)\n                    .setLength(diskFile.length())\n                    .setGenerationStamp(diskGS)\n                    .setFsVolume(vol)\n                    .setDirectoryToUse(diskFile.getParentFile())\n                    .build();\n              ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!fileIoProvider.delete(vol, diskFile)) {\n              LOG.warn(\"Failed to delete \" + diskFile);\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in replica \"\n            + memBlockInfo.getBlockURI()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.updateWithReplica(\n            StorageLocation.parse(diskFile.toString()));\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (fileIoProvider.exists(vol, memMetaFile)) {\n          String warningPrefix \u003d \"Metadata file in memory \"\n              + memMetaFile.getAbsolutePath()\n              + \" does not match file found by scan \";\n          if (!diskMetaFileExists) {\n            LOG.warn(warningPrefix + \"null\");\n          } else if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          try {\n            File memFile \u003d new File(memBlockInfo.getBlockURI());\n            long gs \u003d diskMetaFileExists \u0026\u0026\n                diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n            LOG.warn(\"Updating generation stamp for block \" + blockId\n                + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n            memBlockInfo.setGenerationStamp(gs);\n          } catch (IllegalArgumentException e) {\n            //exception arises because the URI cannot be converted to a file\n            LOG.warn(\"Block URI could not be resolved to a file\", e);\n          }\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \"\n            + memBlockInfo.getBlockDataLength());\n        memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n            memBlockInfo.getVolume());\n      } catch (IOException e) {\n        LOG.warn(\"Failed to report bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "b668eb91556b8c85c2b4925808ccb1f769031c20": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-10675. Datanode support to read from external stores.\n",
      "commitDate": "15/12/17 5:51 PM",
      "commitName": "b668eb91556b8c85c2b4925808ccb1f769031c20",
      "commitAuthor": "Virajith Jalaparti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-10675. Datanode support to read from external stores.\n",
          "commitDate": "15/12/17 5:51 PM",
          "commitName": "b668eb91556b8c85c2b4925808ccb1f769031c20",
          "commitAuthor": "Virajith Jalaparti",
          "commitDateOld": "14/12/17 7:45 AM",
          "commitNameOld": "80db744ee57c52a1dc306c576c663ccc76cced4c",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 1.42,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,172 +1,199 @@\n-  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n-      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n+  public void checkAndUpdate(String bpid, ScanInfo scanInfo)\n+      throws IOException {\n+\n+    long blockId \u003d scanInfo.getBlockId();\n+    File diskFile \u003d scanInfo.getBlockFile();\n+    File diskMetaFile \u003d scanInfo.getMetaFile();\n+    FsVolumeSpi vol \u003d scanInfo.getVolume();\n+\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n-      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n+      if (memBlockInfo !\u003d null \u0026\u0026\n+          memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n       final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n           fileIoProvider.exists(vol, diskMetaFile);\n       final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n           fileIoProvider.exists(vol, diskFile);\n \n       final long diskGS \u003d diskMetaFileExists ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n           HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n+      if (vol.getStorageType() \u003d\u003d StorageType.PROVIDED) {\n+        if (memBlockInfo \u003d\u003d null) {\n+          //replica exists on provided store but not in memory\n+          ReplicaInfo diskBlockInfo \u003d\n+              new ReplicaBuilder(ReplicaState.FINALIZED)\n+              .setFileRegion(scanInfo.getFileRegion())\n+              .setFsVolume(vol)\n+              .setConf(conf)\n+              .build();\n+\n+          volumeMap.add(bpid, diskBlockInfo);\n+          LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n+        } else {\n+          //replica exists in memory but not in the provided store\n+          volumeMap.remove(bpid, blockId);\n+          LOG.warn(\"Deleting missing provided block \" + memBlockInfo);\n+        }\n+        return;\n+      }\n+\n       if (!diskFileExists) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.blockDataExists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n             .setBlockId(blockId)\n             .setLength(diskFile.length())\n             .setGenerationStamp(diskGS)\n             .setFsVolume(vol)\n             .setDirectoryToUse(diskFile.getParentFile())\n             .build();\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           long lockedBytesReserved \u003d\n               cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                   diskBlockInfo.getNumBytes() : 0;\n           ramDiskReplicaTracker.addReplica(\n               bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       if (memBlockInfo.blockDataExists()) {\n         if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n           if (diskMetaFileExists) {\n             if (memBlockInfo.metadataExists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d\n                   new ReplicaBuilder(ReplicaState.FINALIZED)\n                     .setBlockId(blockId)\n                     .setLength(diskFile.length())\n                     .setGenerationStamp(diskGS)\n                     .setFsVolume(vol)\n                     .setDirectoryToUse(diskFile.getParentFile())\n                     .build();\n               ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!fileIoProvider.delete(vol, diskFile)) {\n               LOG.warn(\"Failed to delete \" + diskFile);\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in replica \"\n             + memBlockInfo.getBlockURI()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.updateWithReplica(\n             StorageLocation.parse(diskFile.toString()));\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (fileIoProvider.exists(vol, memMetaFile)) {\n           String warningPrefix \u003d \"Metadata file in memory \"\n               + memMetaFile.getAbsolutePath()\n               + \" does not match file found by scan \";\n           if (!diskMetaFileExists) {\n             LOG.warn(warningPrefix + \"null\");\n           } else if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           try {\n             File memFile \u003d new File(memBlockInfo.getBlockURI());\n             long gs \u003d diskMetaFileExists \u0026\u0026\n                 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                 : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n             LOG.warn(\"Updating generation stamp for block \" + blockId\n                 + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n             memBlockInfo.setGenerationStamp(gs);\n           } catch (IllegalArgumentException e) {\n             //exception arises because the URI cannot be converted to a file\n             LOG.warn(\"Block URI could not be resolved to a file\", e);\n           }\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \"\n             + memBlockInfo.getBlockDataLength());\n         memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n             memBlockInfo.getVolume());\n       } catch (IOException e) {\n         LOG.warn(\"Failed to report bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkAndUpdate(String bpid, ScanInfo scanInfo)\n      throws IOException {\n\n    long blockId \u003d scanInfo.getBlockId();\n    File diskFile \u003d scanInfo.getBlockFile();\n    File diskMetaFile \u003d scanInfo.getMetaFile();\n    FsVolumeSpi vol \u003d scanInfo.getVolume();\n\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026\n          memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n      final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskMetaFile);\n      final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskFile);\n\n      final long diskGS \u003d diskMetaFileExists ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n          HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (vol.getStorageType() \u003d\u003d StorageType.PROVIDED) {\n        if (memBlockInfo \u003d\u003d null) {\n          //replica exists on provided store but not in memory\n          ReplicaInfo diskBlockInfo \u003d\n              new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setFileRegion(scanInfo.getFileRegion())\n              .setFsVolume(vol)\n              .setConf(conf)\n              .build();\n\n          volumeMap.add(bpid, diskBlockInfo);\n          LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        } else {\n          //replica exists in memory but not in the provided store\n          volumeMap.remove(bpid, blockId);\n          LOG.warn(\"Deleting missing provided block \" + memBlockInfo);\n        }\n        return;\n      }\n\n      if (!diskFileExists) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.blockDataExists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n            .setBlockId(blockId)\n            .setLength(diskFile.length())\n            .setGenerationStamp(diskGS)\n            .setFsVolume(vol)\n            .setDirectoryToUse(diskFile.getParentFile())\n            .build();\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          long lockedBytesReserved \u003d\n              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                  diskBlockInfo.getNumBytes() : 0;\n          ramDiskReplicaTracker.addReplica(\n              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      if (memBlockInfo.blockDataExists()) {\n        if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n          if (diskMetaFileExists) {\n            if (memBlockInfo.metadataExists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d\n                  new ReplicaBuilder(ReplicaState.FINALIZED)\n                    .setBlockId(blockId)\n                    .setLength(diskFile.length())\n                    .setGenerationStamp(diskGS)\n                    .setFsVolume(vol)\n                    .setDirectoryToUse(diskFile.getParentFile())\n                    .build();\n              ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!fileIoProvider.delete(vol, diskFile)) {\n              LOG.warn(\"Failed to delete \" + diskFile);\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in replica \"\n            + memBlockInfo.getBlockURI()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.updateWithReplica(\n            StorageLocation.parse(diskFile.toString()));\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (fileIoProvider.exists(vol, memMetaFile)) {\n          String warningPrefix \u003d \"Metadata file in memory \"\n              + memMetaFile.getAbsolutePath()\n              + \" does not match file found by scan \";\n          if (!diskMetaFileExists) {\n            LOG.warn(warningPrefix + \"null\");\n          } else if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          try {\n            File memFile \u003d new File(memBlockInfo.getBlockURI());\n            long gs \u003d diskMetaFileExists \u0026\u0026\n                diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n            LOG.warn(\"Updating generation stamp for block \" + blockId\n                + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n            memBlockInfo.setGenerationStamp(gs);\n          } catch (IllegalArgumentException e) {\n            //exception arises because the URI cannot be converted to a file\n            LOG.warn(\"Block URI could not be resolved to a file\", e);\n          }\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \"\n            + memBlockInfo.getBlockDataLength());\n        memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n            memBlockInfo.getVolume());\n      } catch (IOException e) {\n        LOG.warn(\"Failed to report bad block \" + corruptBlock, e);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldValue": "[bpid-String, blockId-long, diskFile-File, diskMetaFile-File, vol-FsVolumeSpi]",
            "newValue": "[bpid-String, scanInfo-ScanInfo]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10675. Datanode support to read from external stores.\n",
          "commitDate": "15/12/17 5:51 PM",
          "commitName": "b668eb91556b8c85c2b4925808ccb1f769031c20",
          "commitAuthor": "Virajith Jalaparti",
          "commitDateOld": "14/12/17 7:45 AM",
          "commitNameOld": "80db744ee57c52a1dc306c576c663ccc76cced4c",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 1.42,
          "commitsBetweenForRepo": 17,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,172 +1,199 @@\n-  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n-      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n+  public void checkAndUpdate(String bpid, ScanInfo scanInfo)\n+      throws IOException {\n+\n+    long blockId \u003d scanInfo.getBlockId();\n+    File diskFile \u003d scanInfo.getBlockFile();\n+    File diskMetaFile \u003d scanInfo.getMetaFile();\n+    FsVolumeSpi vol \u003d scanInfo.getVolume();\n+\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n-      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n+      if (memBlockInfo !\u003d null \u0026\u0026\n+          memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n       final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n           fileIoProvider.exists(vol, diskMetaFile);\n       final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n           fileIoProvider.exists(vol, diskFile);\n \n       final long diskGS \u003d diskMetaFileExists ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n           HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n+      if (vol.getStorageType() \u003d\u003d StorageType.PROVIDED) {\n+        if (memBlockInfo \u003d\u003d null) {\n+          //replica exists on provided store but not in memory\n+          ReplicaInfo diskBlockInfo \u003d\n+              new ReplicaBuilder(ReplicaState.FINALIZED)\n+              .setFileRegion(scanInfo.getFileRegion())\n+              .setFsVolume(vol)\n+              .setConf(conf)\n+              .build();\n+\n+          volumeMap.add(bpid, diskBlockInfo);\n+          LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n+        } else {\n+          //replica exists in memory but not in the provided store\n+          volumeMap.remove(bpid, blockId);\n+          LOG.warn(\"Deleting missing provided block \" + memBlockInfo);\n+        }\n+        return;\n+      }\n+\n       if (!diskFileExists) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.blockDataExists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n             .setBlockId(blockId)\n             .setLength(diskFile.length())\n             .setGenerationStamp(diskGS)\n             .setFsVolume(vol)\n             .setDirectoryToUse(diskFile.getParentFile())\n             .build();\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           long lockedBytesReserved \u003d\n               cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                   diskBlockInfo.getNumBytes() : 0;\n           ramDiskReplicaTracker.addReplica(\n               bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       if (memBlockInfo.blockDataExists()) {\n         if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n           if (diskMetaFileExists) {\n             if (memBlockInfo.metadataExists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d\n                   new ReplicaBuilder(ReplicaState.FINALIZED)\n                     .setBlockId(blockId)\n                     .setLength(diskFile.length())\n                     .setGenerationStamp(diskGS)\n                     .setFsVolume(vol)\n                     .setDirectoryToUse(diskFile.getParentFile())\n                     .build();\n               ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!fileIoProvider.delete(vol, diskFile)) {\n               LOG.warn(\"Failed to delete \" + diskFile);\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in replica \"\n             + memBlockInfo.getBlockURI()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.updateWithReplica(\n             StorageLocation.parse(diskFile.toString()));\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (fileIoProvider.exists(vol, memMetaFile)) {\n           String warningPrefix \u003d \"Metadata file in memory \"\n               + memMetaFile.getAbsolutePath()\n               + \" does not match file found by scan \";\n           if (!diskMetaFileExists) {\n             LOG.warn(warningPrefix + \"null\");\n           } else if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           try {\n             File memFile \u003d new File(memBlockInfo.getBlockURI());\n             long gs \u003d diskMetaFileExists \u0026\u0026\n                 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                 : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n             LOG.warn(\"Updating generation stamp for block \" + blockId\n                 + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n             memBlockInfo.setGenerationStamp(gs);\n           } catch (IllegalArgumentException e) {\n             //exception arises because the URI cannot be converted to a file\n             LOG.warn(\"Block URI could not be resolved to a file\", e);\n           }\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \"\n             + memBlockInfo.getBlockDataLength());\n         memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n             memBlockInfo.getVolume());\n       } catch (IOException e) {\n         LOG.warn(\"Failed to report bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkAndUpdate(String bpid, ScanInfo scanInfo)\n      throws IOException {\n\n    long blockId \u003d scanInfo.getBlockId();\n    File diskFile \u003d scanInfo.getBlockFile();\n    File diskMetaFile \u003d scanInfo.getMetaFile();\n    FsVolumeSpi vol \u003d scanInfo.getVolume();\n\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026\n          memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n      final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskMetaFile);\n      final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskFile);\n\n      final long diskGS \u003d diskMetaFileExists ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n          HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (vol.getStorageType() \u003d\u003d StorageType.PROVIDED) {\n        if (memBlockInfo \u003d\u003d null) {\n          //replica exists on provided store but not in memory\n          ReplicaInfo diskBlockInfo \u003d\n              new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setFileRegion(scanInfo.getFileRegion())\n              .setFsVolume(vol)\n              .setConf(conf)\n              .build();\n\n          volumeMap.add(bpid, diskBlockInfo);\n          LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        } else {\n          //replica exists in memory but not in the provided store\n          volumeMap.remove(bpid, blockId);\n          LOG.warn(\"Deleting missing provided block \" + memBlockInfo);\n        }\n        return;\n      }\n\n      if (!diskFileExists) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.blockDataExists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n            .setBlockId(blockId)\n            .setLength(diskFile.length())\n            .setGenerationStamp(diskGS)\n            .setFsVolume(vol)\n            .setDirectoryToUse(diskFile.getParentFile())\n            .build();\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          long lockedBytesReserved \u003d\n              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                  diskBlockInfo.getNumBytes() : 0;\n          ramDiskReplicaTracker.addReplica(\n              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      if (memBlockInfo.blockDataExists()) {\n        if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n          if (diskMetaFileExists) {\n            if (memBlockInfo.metadataExists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d\n                  new ReplicaBuilder(ReplicaState.FINALIZED)\n                    .setBlockId(blockId)\n                    .setLength(diskFile.length())\n                    .setGenerationStamp(diskGS)\n                    .setFsVolume(vol)\n                    .setDirectoryToUse(diskFile.getParentFile())\n                    .build();\n              ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!fileIoProvider.delete(vol, diskFile)) {\n              LOG.warn(\"Failed to delete \" + diskFile);\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in replica \"\n            + memBlockInfo.getBlockURI()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.updateWithReplica(\n            StorageLocation.parse(diskFile.toString()));\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (fileIoProvider.exists(vol, memMetaFile)) {\n          String warningPrefix \u003d \"Metadata file in memory \"\n              + memMetaFile.getAbsolutePath()\n              + \" does not match file found by scan \";\n          if (!diskMetaFileExists) {\n            LOG.warn(warningPrefix + \"null\");\n          } else if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          try {\n            File memFile \u003d new File(memBlockInfo.getBlockURI());\n            long gs \u003d diskMetaFileExists \u0026\u0026\n                diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n            LOG.warn(\"Updating generation stamp for block \" + blockId\n                + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n            memBlockInfo.setGenerationStamp(gs);\n          } catch (IllegalArgumentException e) {\n            //exception arises because the URI cannot be converted to a file\n            LOG.warn(\"Block URI could not be resolved to a file\", e);\n          }\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \"\n            + memBlockInfo.getBlockDataLength());\n        memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n            memBlockInfo.getVolume());\n      } catch (IOException e) {\n        LOG.warn(\"Failed to report bad block \" + corruptBlock, e);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "abdea26280136587a47aea075ada6122d40d706e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12024. Fix typo\u0027s in FsDatasetImpl.java. Contributed by Yasen liu.\n",
      "commitDate": "23/06/17 7:56 AM",
      "commitName": "abdea26280136587a47aea075ada6122d40d706e",
      "commitAuthor": "Brahma Reddy Battula",
      "commitDateOld": "20/06/17 7:19 PM",
      "commitNameOld": "1a598479a9faec787706bcf924dfbd88a80e1b82",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 2.53,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,172 +1,172 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n       final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n           fileIoProvider.exists(vol, diskMetaFile);\n       final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n           fileIoProvider.exists(vol, diskFile);\n \n       final long diskGS \u003d diskMetaFileExists ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n           HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n       if (!diskFileExists) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.blockDataExists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n             .setBlockId(blockId)\n             .setLength(diskFile.length())\n             .setGenerationStamp(diskGS)\n             .setFsVolume(vol)\n             .setDirectoryToUse(diskFile.getParentFile())\n             .build();\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           long lockedBytesReserved \u003d\n               cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                   diskBlockInfo.getNumBytes() : 0;\n           ramDiskReplicaTracker.addReplica(\n               bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       if (memBlockInfo.blockDataExists()) {\n         if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n           if (diskMetaFileExists) {\n             if (memBlockInfo.metadataExists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d\n                   new ReplicaBuilder(ReplicaState.FINALIZED)\n                     .setBlockId(blockId)\n                     .setLength(diskFile.length())\n                     .setGenerationStamp(diskGS)\n                     .setFsVolume(vol)\n                     .setDirectoryToUse(diskFile.getParentFile())\n                     .build();\n               ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!fileIoProvider.delete(vol, diskFile)) {\n               LOG.warn(\"Failed to delete \" + diskFile);\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in replica \"\n             + memBlockInfo.getBlockURI()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.updateWithReplica(\n             StorageLocation.parse(diskFile.toString()));\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (fileIoProvider.exists(vol, memMetaFile)) {\n           String warningPrefix \u003d \"Metadata file in memory \"\n               + memMetaFile.getAbsolutePath()\n               + \" does not match file found by scan \";\n           if (!diskMetaFileExists) {\n             LOG.warn(warningPrefix + \"null\");\n           } else if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           try {\n             File memFile \u003d new File(memBlockInfo.getBlockURI());\n             long gs \u003d diskMetaFileExists \u0026\u0026\n                 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                 : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n             LOG.warn(\"Updating generation stamp for block \" + blockId\n                 + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n             memBlockInfo.setGenerationStamp(gs);\n           } catch (IllegalArgumentException e) {\n             //exception arises because the URI cannot be converted to a file\n             LOG.warn(\"Block URI could not be resolved to a file\", e);\n           }\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \"\n             + memBlockInfo.getBlockDataLength());\n         memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n             memBlockInfo.getVolume());\n       } catch (IOException e) {\n-        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n+        LOG.warn(\"Failed to report bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n      final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskMetaFile);\n      final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskFile);\n\n      final long diskGS \u003d diskMetaFileExists ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n          HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (!diskFileExists) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.blockDataExists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n            .setBlockId(blockId)\n            .setLength(diskFile.length())\n            .setGenerationStamp(diskGS)\n            .setFsVolume(vol)\n            .setDirectoryToUse(diskFile.getParentFile())\n            .build();\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          long lockedBytesReserved \u003d\n              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                  diskBlockInfo.getNumBytes() : 0;\n          ramDiskReplicaTracker.addReplica(\n              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      if (memBlockInfo.blockDataExists()) {\n        if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n          if (diskMetaFileExists) {\n            if (memBlockInfo.metadataExists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d\n                  new ReplicaBuilder(ReplicaState.FINALIZED)\n                    .setBlockId(blockId)\n                    .setLength(diskFile.length())\n                    .setGenerationStamp(diskGS)\n                    .setFsVolume(vol)\n                    .setDirectoryToUse(diskFile.getParentFile())\n                    .build();\n              ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!fileIoProvider.delete(vol, diskFile)) {\n              LOG.warn(\"Failed to delete \" + diskFile);\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in replica \"\n            + memBlockInfo.getBlockURI()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.updateWithReplica(\n            StorageLocation.parse(diskFile.toString()));\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (fileIoProvider.exists(vol, memMetaFile)) {\n          String warningPrefix \u003d \"Metadata file in memory \"\n              + memMetaFile.getAbsolutePath()\n              + \" does not match file found by scan \";\n          if (!diskMetaFileExists) {\n            LOG.warn(warningPrefix + \"null\");\n          } else if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          try {\n            File memFile \u003d new File(memBlockInfo.getBlockURI());\n            long gs \u003d diskMetaFileExists \u0026\u0026\n                diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n            LOG.warn(\"Updating generation stamp for block \" + blockId\n                + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n            memBlockInfo.setGenerationStamp(gs);\n          } catch (IllegalArgumentException e) {\n            //exception arises because the URI cannot be converted to a file\n            LOG.warn(\"Block URI could not be resolved to a file\", e);\n          }\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \"\n            + memBlockInfo.getBlockDataLength());\n        memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n            memBlockInfo.getVolume());\n      } catch (IOException e) {\n        LOG.warn(\"Failed to report bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "ac5ae0065a127ac150a887fa6c6f3cffd86ef733": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11476. Fix NPE in FsDatasetImpl#checkAndUpdate. Contributed by Xiaobing Zhou.\n",
      "commitDate": "03/03/17 1:31 PM",
      "commitName": "ac5ae0065a127ac150a887fa6c6f3cffd86ef733",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "15/02/17 11:37 AM",
      "commitNameOld": "0741dd3b9abdeb65bb783c1a8b01f078c4bdba17",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 16.08,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,170 +1,172 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n       final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n           fileIoProvider.exists(vol, diskMetaFile);\n       final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n           fileIoProvider.exists(vol, diskFile);\n \n       final long diskGS \u003d diskMetaFileExists ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n           HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n       if (!diskFileExists) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.blockDataExists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n             .setBlockId(blockId)\n             .setLength(diskFile.length())\n             .setGenerationStamp(diskGS)\n             .setFsVolume(vol)\n             .setDirectoryToUse(diskFile.getParentFile())\n             .build();\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           long lockedBytesReserved \u003d\n               cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                   diskBlockInfo.getNumBytes() : 0;\n           ramDiskReplicaTracker.addReplica(\n               bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       if (memBlockInfo.blockDataExists()) {\n         if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n           if (diskMetaFileExists) {\n             if (memBlockInfo.metadataExists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d\n                   new ReplicaBuilder(ReplicaState.FINALIZED)\n                     .setBlockId(blockId)\n                     .setLength(diskFile.length())\n                     .setGenerationStamp(diskGS)\n                     .setFsVolume(vol)\n                     .setDirectoryToUse(diskFile.getParentFile())\n                     .build();\n               ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!fileIoProvider.delete(vol, diskFile)) {\n               LOG.warn(\"Failed to delete \" + diskFile);\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in replica \"\n             + memBlockInfo.getBlockURI()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.updateWithReplica(\n             StorageLocation.parse(diskFile.toString()));\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n-        if (memMetaFile.exists()) {\n-          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n-            LOG.warn(\"Metadata file in memory \"\n-                + memMetaFile.getAbsolutePath()\n-                + \" does not match file found by scan \"\n-                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n+        if (fileIoProvider.exists(vol, memMetaFile)) {\n+          String warningPrefix \u003d \"Metadata file in memory \"\n+              + memMetaFile.getAbsolutePath()\n+              + \" does not match file found by scan \";\n+          if (!diskMetaFileExists) {\n+            LOG.warn(warningPrefix + \"null\");\n+          } else if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n+            LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           try {\n             File memFile \u003d new File(memBlockInfo.getBlockURI());\n             long gs \u003d diskMetaFileExists \u0026\u0026\n                 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                 : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n             LOG.warn(\"Updating generation stamp for block \" + blockId\n                 + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n             memBlockInfo.setGenerationStamp(gs);\n           } catch (IllegalArgumentException e) {\n             //exception arises because the URI cannot be converted to a file\n             LOG.warn(\"Block URI could not be resolved to a file\", e);\n           }\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \"\n             + memBlockInfo.getBlockDataLength());\n         memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n             memBlockInfo.getVolume());\n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n      final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskMetaFile);\n      final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskFile);\n\n      final long diskGS \u003d diskMetaFileExists ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n          HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (!diskFileExists) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.blockDataExists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n            .setBlockId(blockId)\n            .setLength(diskFile.length())\n            .setGenerationStamp(diskGS)\n            .setFsVolume(vol)\n            .setDirectoryToUse(diskFile.getParentFile())\n            .build();\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          long lockedBytesReserved \u003d\n              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                  diskBlockInfo.getNumBytes() : 0;\n          ramDiskReplicaTracker.addReplica(\n              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      if (memBlockInfo.blockDataExists()) {\n        if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n          if (diskMetaFileExists) {\n            if (memBlockInfo.metadataExists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d\n                  new ReplicaBuilder(ReplicaState.FINALIZED)\n                    .setBlockId(blockId)\n                    .setLength(diskFile.length())\n                    .setGenerationStamp(diskGS)\n                    .setFsVolume(vol)\n                    .setDirectoryToUse(diskFile.getParentFile())\n                    .build();\n              ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!fileIoProvider.delete(vol, diskFile)) {\n              LOG.warn(\"Failed to delete \" + diskFile);\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in replica \"\n            + memBlockInfo.getBlockURI()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.updateWithReplica(\n            StorageLocation.parse(diskFile.toString()));\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (fileIoProvider.exists(vol, memMetaFile)) {\n          String warningPrefix \u003d \"Metadata file in memory \"\n              + memMetaFile.getAbsolutePath()\n              + \" does not match file found by scan \";\n          if (!diskMetaFileExists) {\n            LOG.warn(warningPrefix + \"null\");\n          } else if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          try {\n            File memFile \u003d new File(memBlockInfo.getBlockURI());\n            long gs \u003d diskMetaFileExists \u0026\u0026\n                diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n            LOG.warn(\"Updating generation stamp for block \" + blockId\n                + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n            memBlockInfo.setGenerationStamp(gs);\n          } catch (IllegalArgumentException e) {\n            //exception arises because the URI cannot be converted to a file\n            LOG.warn(\"Block URI could not be resolved to a file\", e);\n          }\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \"\n            + memBlockInfo.getBlockDataLength());\n        memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n            memBlockInfo.getVolume());\n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "6ba9587d370fbf39c129c08c00ebbb894ccc1389": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10958. Add instrumentation hooks around Datanode disk IO.\n",
      "commitDate": "14/12/16 11:18 AM",
      "commitName": "6ba9587d370fbf39c129c08c00ebbb894ccc1389",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "06/12/16 11:05 AM",
      "commitNameOld": "df983b524ab68ea0c70cee9033bfff2d28052cbf",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 8.01,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,166 +1,170 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n-      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n-          Block.getGenerationStamp(diskMetaFile.getName()) :\n-            HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n+      final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n+      final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n+          fileIoProvider.exists(vol, diskMetaFile);\n+      final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n+          fileIoProvider.exists(vol, diskFile);\n \n-      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n+      final long diskGS \u003d diskMetaFileExists ?\n+          Block.getGenerationStamp(diskMetaFile.getName()) :\n+          HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n+\n+      if (!diskFileExists) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n-          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n-              \u0026\u0026 diskMetaFile.delete()) {\n+          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.blockDataExists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n-          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n-              \u0026\u0026 diskMetaFile.delete()) {\n+          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n             .setBlockId(blockId)\n             .setLength(diskFile.length())\n             .setGenerationStamp(diskGS)\n             .setFsVolume(vol)\n             .setDirectoryToUse(diskFile.getParentFile())\n             .build();\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           long lockedBytesReserved \u003d\n               cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                   diskBlockInfo.getNumBytes() : 0;\n           ramDiskReplicaTracker.addReplica(\n               bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       if (memBlockInfo.blockDataExists()) {\n         if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n-          if (diskMetaFile.exists()) {\n+          if (diskMetaFileExists) {\n             if (memBlockInfo.metadataExists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d\n                   new ReplicaBuilder(ReplicaState.FINALIZED)\n                     .setBlockId(blockId)\n                     .setLength(diskFile.length())\n                     .setGenerationStamp(diskGS)\n                     .setFsVolume(vol)\n                     .setDirectoryToUse(diskFile.getParentFile())\n                     .build();\n               ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n-            if (!diskFile.delete()) {\n+            if (!fileIoProvider.delete(vol, diskFile)) {\n               LOG.warn(\"Failed to delete \" + diskFile);\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in replica \"\n             + memBlockInfo.getBlockURI()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.updateWithReplica(\n             StorageLocation.parse(diskFile.toString()));\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           try {\n             File memFile \u003d new File(memBlockInfo.getBlockURI());\n-            long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n-                \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n+            long gs \u003d diskMetaFileExists \u0026\u0026\n+                diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                 : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n             LOG.warn(\"Updating generation stamp for block \" + blockId\n                 + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n             memBlockInfo.setGenerationStamp(gs);\n           } catch (IllegalArgumentException e) {\n             //exception arises because the URI cannot be converted to a file\n             LOG.warn(\"Block URI could not be resolved to a file\", e);\n           }\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \"\n             + memBlockInfo.getBlockDataLength());\n         memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n             memBlockInfo.getVolume());\n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final FileIoProvider fileIoProvider \u003d datanode.getFileIoProvider();\n      final boolean diskMetaFileExists \u003d diskMetaFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskMetaFile);\n      final boolean diskFileExists \u003d diskFile !\u003d null \u0026\u0026\n          fileIoProvider.exists(vol, diskFile);\n\n      final long diskGS \u003d diskMetaFileExists ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n          HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (!diskFileExists) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.blockDataExists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFileExists \u0026\u0026 fileIoProvider.delete(vol, diskMetaFile)) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n            .setBlockId(blockId)\n            .setLength(diskFile.length())\n            .setGenerationStamp(diskGS)\n            .setFsVolume(vol)\n            .setDirectoryToUse(diskFile.getParentFile())\n            .build();\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          long lockedBytesReserved \u003d\n              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                  diskBlockInfo.getNumBytes() : 0;\n          ramDiskReplicaTracker.addReplica(\n              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      if (memBlockInfo.blockDataExists()) {\n        if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n          if (diskMetaFileExists) {\n            if (memBlockInfo.metadataExists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d\n                  new ReplicaBuilder(ReplicaState.FINALIZED)\n                    .setBlockId(blockId)\n                    .setLength(diskFile.length())\n                    .setGenerationStamp(diskGS)\n                    .setFsVolume(vol)\n                    .setDirectoryToUse(diskFile.getParentFile())\n                    .build();\n              ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!fileIoProvider.delete(vol, diskFile)) {\n              LOG.warn(\"Failed to delete \" + diskFile);\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in replica \"\n            + memBlockInfo.getBlockURI()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.updateWithReplica(\n            StorageLocation.parse(diskFile.toString()));\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          try {\n            File memFile \u003d new File(memBlockInfo.getBlockURI());\n            long gs \u003d diskMetaFileExists \u0026\u0026\n                diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n            LOG.warn(\"Updating generation stamp for block \" + blockId\n                + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n            memBlockInfo.setGenerationStamp(gs);\n          } catch (IllegalArgumentException e) {\n            //exception arises because the URI cannot be converted to a file\n            LOG.warn(\"Block URI could not be resolved to a file\", e);\n          }\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \"\n            + memBlockInfo.getBlockDataLength());\n        memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n            memBlockInfo.getVolume());\n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "96b12662ea76e3ded4ef13944fc8df206cfb4613": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10637. Modifications to remove the assumption that FsVolumes are backed by java.io.File. (Virajith Jalaparti via lei)\n",
      "commitDate": "10/10/16 3:30 PM",
      "commitName": "96b12662ea76e3ded4ef13944fc8df206cfb4613",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "30/09/16 11:11 PM",
      "commitNameOld": "fe9ebe20ab113567f0777c11cb48ce0d3ce587a8",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 9.68,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,167 +1,166 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.blockDataExists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n             .setBlockId(blockId)\n             .setLength(diskFile.length())\n             .setGenerationStamp(diskGS)\n             .setFsVolume(vol)\n             .setDirectoryToUse(diskFile.getParentFile())\n             .build();\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           long lockedBytesReserved \u003d\n               cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                   diskBlockInfo.getNumBytes() : 0;\n           ramDiskReplicaTracker.addReplica(\n               bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       if (memBlockInfo.blockDataExists()) {\n         if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n           if (diskMetaFile.exists()) {\n             if (memBlockInfo.metadataExists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d\n                   new ReplicaBuilder(ReplicaState.FINALIZED)\n                     .setBlockId(blockId)\n                     .setLength(diskFile.length())\n                     .setGenerationStamp(diskGS)\n                     .setFsVolume(vol)\n                     .setDirectoryToUse(diskFile.getParentFile())\n                     .build();\n-              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid)\n-                  .resolveDuplicateReplicas(\n-                      memBlockInfo, diskBlockInfo, volumeMap);\n+              ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n+                  memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!diskFile.delete()) {\n               LOG.warn(\"Failed to delete \" + diskFile);\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in replica \"\n             + memBlockInfo.getBlockURI()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.updateWithReplica(\n             StorageLocation.parse(diskFile.toString()));\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           try {\n             File memFile \u003d new File(memBlockInfo.getBlockURI());\n             long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n                 \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                 : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n             LOG.warn(\"Updating generation stamp for block \" + blockId\n                 + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n             memBlockInfo.setGenerationStamp(gs);\n           } catch (IllegalArgumentException e) {\n             //exception arises because the URI cannot be converted to a file\n             LOG.warn(\"Block URI could not be resolved to a file\", e);\n           }\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \"\n             + memBlockInfo.getBlockDataLength());\n         memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n             memBlockInfo.getVolume());\n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.blockDataExists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n            .setBlockId(blockId)\n            .setLength(diskFile.length())\n            .setGenerationStamp(diskGS)\n            .setFsVolume(vol)\n            .setDirectoryToUse(diskFile.getParentFile())\n            .build();\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          long lockedBytesReserved \u003d\n              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                  diskBlockInfo.getNumBytes() : 0;\n          ramDiskReplicaTracker.addReplica(\n              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      if (memBlockInfo.blockDataExists()) {\n        if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n          if (diskMetaFile.exists()) {\n            if (memBlockInfo.metadataExists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d\n                  new ReplicaBuilder(ReplicaState.FINALIZED)\n                    .setBlockId(blockId)\n                    .setLength(diskFile.length())\n                    .setGenerationStamp(diskGS)\n                    .setFsVolume(vol)\n                    .setDirectoryToUse(diskFile.getParentFile())\n                    .build();\n              ((FsVolumeImpl) vol).resolveDuplicateReplicas(bpid,\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!diskFile.delete()) {\n              LOG.warn(\"Failed to delete \" + diskFile);\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in replica \"\n            + memBlockInfo.getBlockURI()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.updateWithReplica(\n            StorageLocation.parse(diskFile.toString()));\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          try {\n            File memFile \u003d new File(memBlockInfo.getBlockURI());\n            long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n                \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n            LOG.warn(\"Updating generation stamp for block \" + blockId\n                + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n            memBlockInfo.setGenerationStamp(gs);\n          } catch (IllegalArgumentException e) {\n            //exception arises because the URI cannot be converted to a file\n            LOG.warn(\"Block URI could not be resolved to a file\", e);\n          }\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \"\n            + memBlockInfo.getBlockDataLength());\n        memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n            memBlockInfo.getVolume());\n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "86c9862bec0248d671e657aa56094a2919b8ac14": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10636. Modify ReplicaInfo to remove the assumption that replica metadata and data are stored in java.io.File. (Virajith Jalaparti via lei)\n",
      "commitDate": "13/09/16 12:54 PM",
      "commitName": "86c9862bec0248d671e657aa56094a2919b8ac14",
      "commitAuthor": "Lei Xu",
      "commitDateOld": "10/09/16 6:22 PM",
      "commitNameOld": "a99bf26a0899bcc4307c3a242c8414eaef555aa7",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 2.77,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,167 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n-        if (!memBlockInfo.getBlockFile().exists()) {\n+        if (!memBlockInfo.blockDataExists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n-        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n-            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n+        ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n+            .setBlockId(blockId)\n+            .setLength(diskFile.length())\n+            .setGenerationStamp(diskGS)\n+            .setFsVolume(vol)\n+            .setDirectoryToUse(diskFile.getParentFile())\n+            .build();\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           long lockedBytesReserved \u003d\n               cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                   diskBlockInfo.getNumBytes() : 0;\n           ramDiskReplicaTracker.addReplica(\n               bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n-      File memFile \u003d memBlockInfo.getBlockFile();\n-      if (memFile.exists()) {\n-        if (memFile.compareTo(diskFile) !\u003d 0) {\n+      if (memBlockInfo.blockDataExists()) {\n+        if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n           if (diskMetaFile.exists()) {\n-            if (memBlockInfo.getMetaFile().exists()) {\n+            if (memBlockInfo.metadataExists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n-              ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n-                  blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n-              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n-                  memBlockInfo, diskBlockInfo, volumeMap);\n+              ReplicaInfo diskBlockInfo \u003d\n+                  new ReplicaBuilder(ReplicaState.FINALIZED)\n+                    .setBlockId(blockId)\n+                    .setLength(diskFile.length())\n+                    .setGenerationStamp(diskGS)\n+                    .setFsVolume(vol)\n+                    .setDirectoryToUse(diskFile.getParentFile())\n+                    .build();\n+              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid)\n+                  .resolveDuplicateReplicas(\n+                      memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!diskFile.delete()) {\n-              LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n+              LOG.warn(\"Failed to delete \" + diskFile);\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n-        LOG.warn(\"Block file in volumeMap \"\n-            + memFile.getAbsolutePath()\n+        LOG.warn(\"Block file in replica \"\n+            + memBlockInfo.getBlockURI()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n-        memBlockInfo.setDir(diskFile.getParentFile());\n-        memFile \u003d diskFile;\n+        memBlockInfo.updateWithReplica(\n+            StorageLocation.parse(diskFile.toString()));\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n-          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n-              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n-              : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n+          try {\n+            File memFile \u003d new File(memBlockInfo.getBlockURI());\n+            long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n+                \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n+                : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n-          LOG.warn(\"Updating generation stamp for block \" + blockId\n-              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n+            LOG.warn(\"Updating generation stamp for block \" + blockId\n+                + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n-          memBlockInfo.setGenerationStamp(gs);\n+            memBlockInfo.setGenerationStamp(gs);\n+          } catch (IllegalArgumentException e) {\n+            //exception arises because the URI cannot be converted to a file\n+            LOG.warn(\"Block URI could not be resolved to a file\", e);\n+          }\n         }\n       }\n \n       // Compare block size\n-      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n+      if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n-            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n-        memBlockInfo.setNumBytes(memFile.length());\n+            + memBlockInfo.getNumBytes() + \" to \"\n+            + memBlockInfo.getBlockDataLength());\n+        memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n             memBlockInfo.getVolume());\n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.blockDataExists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n            .setBlockId(blockId)\n            .setLength(diskFile.length())\n            .setGenerationStamp(diskGS)\n            .setFsVolume(vol)\n            .setDirectoryToUse(diskFile.getParentFile())\n            .build();\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          long lockedBytesReserved \u003d\n              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                  diskBlockInfo.getNumBytes() : 0;\n          ramDiskReplicaTracker.addReplica(\n              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      if (memBlockInfo.blockDataExists()) {\n        if (memBlockInfo.getBlockURI().compareTo(diskFile.toURI()) !\u003d 0) {\n          if (diskMetaFile.exists()) {\n            if (memBlockInfo.metadataExists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d\n                  new ReplicaBuilder(ReplicaState.FINALIZED)\n                    .setBlockId(blockId)\n                    .setLength(diskFile.length())\n                    .setGenerationStamp(diskGS)\n                    .setFsVolume(vol)\n                    .setDirectoryToUse(diskFile.getParentFile())\n                    .build();\n              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid)\n                  .resolveDuplicateReplicas(\n                      memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!diskFile.delete()) {\n              LOG.warn(\"Failed to delete \" + diskFile);\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in replica \"\n            + memBlockInfo.getBlockURI()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.updateWithReplica(\n            StorageLocation.parse(diskFile.toString()));\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          try {\n            File memFile \u003d new File(memBlockInfo.getBlockURI());\n            long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n                \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n                : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n            LOG.warn(\"Updating generation stamp for block \" + blockId\n                + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n            memBlockInfo.setGenerationStamp(gs);\n          } catch (IllegalArgumentException e) {\n            //exception arises because the URI cannot be converted to a file\n            LOG.warn(\"Block URI could not be resolved to a file\", e);\n          }\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memBlockInfo.getBlockDataLength()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \"\n            + memBlockInfo.getBlockDataLength());\n        memBlockInfo.setNumBytes(memBlockInfo.getBlockDataLength());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n            memBlockInfo.getVolume());\n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10682. Replace FsDatasetImpl object lock with a separate lock object. (Chen Liang)\n",
      "commitDate": "08/08/16 12:02 PM",
      "commitName": "8c0638471f8f1dd47667b2d6727d4d2d54e4b48c",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "08/07/16 7:40 PM",
      "commitNameOld": "da6f1b88dd47e22b24d44f6fc8bbee73e85746f7",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 30.68,
      "commitsBetweenForRepo": 320,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,149 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n-    synchronized (this) {\n+    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           long lockedBytesReserved \u003d\n               cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                   diskBlockInfo.getNumBytes() : 0;\n           ramDiskReplicaTracker.addReplica(\n               bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           if (diskMetaFile.exists()) {\n             if (memBlockInfo.getMetaFile().exists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                   blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n               ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!diskFile.delete()) {\n               LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n             memBlockInfo.getVolume());\n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    try (AutoCloseableLock lock \u003d datasetLock.acquire()) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          long lockedBytesReserved \u003d\n              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                  diskBlockInfo.getNumBytes() : 0;\n          ramDiskReplicaTracker.addReplica(\n              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          if (diskMetaFile.exists()) {\n            if (memBlockInfo.getMetaFile().exists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                  blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!diskFile.delete()) {\n              LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n            memBlockInfo.getVolume());\n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "da6f1b88dd47e22b24d44f6fc8bbee73e85746f7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10512. VolumeScanner may terminate due to NPE in DataNode.reportBadBlocks. Contributed by Wei-Chiu Chuang and Yiqun Lin.\n",
      "commitDate": "08/07/16 7:40 PM",
      "commitName": "da6f1b88dd47e22b24d44f6fc8bbee73e85746f7",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "23/06/16 6:20 PM",
      "commitNameOld": "7820737cfa178d9de1bcbb1e99b9677d70901914",
      "commitAuthorOld": "Anu Engineer",
      "daysBetweenCommits": 15.06,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,149 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           long lockedBytesReserved \u003d\n               cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                   diskBlockInfo.getNumBytes() : 0;\n           ramDiskReplicaTracker.addReplica(\n               bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           if (diskMetaFile.exists()) {\n             if (memBlockInfo.getMetaFile().exists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                   blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n               ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!diskFile.delete()) {\n               LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n-        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n+        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n+            memBlockInfo.getVolume());\n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          long lockedBytesReserved \u003d\n              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                  diskBlockInfo.getNumBytes() : 0;\n          ramDiskReplicaTracker.addReplica(\n              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          if (diskMetaFile.exists()) {\n            if (memBlockInfo.getMetaFile().exists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                  blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!diskFile.delete()) {\n              LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock),\n            memBlockInfo.getVolume());\n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "e453989a5722e653bd97e3e54f9bbdffc9454fba": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8157. Writes to RAM DISK reserve locked memory for block files. (Arpit Agarwal)\n",
      "commitDate": "16/05/15 9:05 AM",
      "commitName": "e453989a5722e653bd97e3e54f9bbdffc9454fba",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "06/05/15 9:11 PM",
      "commitNameOld": "6633a8474d7e92fa028ede8fd6c6e41b6c5887f5",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 9.5,
      "commitsBetweenForRepo": 157,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,148 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n-          ramDiskReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n+          long lockedBytesReserved \u003d\n+              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n+                  diskBlockInfo.getNumBytes() : 0;\n+          ramDiskReplicaTracker.addReplica(\n+              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           if (diskMetaFile.exists()) {\n             if (memBlockInfo.getMetaFile().exists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                   blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n               ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!diskFile.delete()) {\n               LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          long lockedBytesReserved \u003d\n              cacheManager.reserve(diskBlockInfo.getNumBytes()) \u003e 0 ?\n                  diskBlockInfo.getNumBytes() : 0;\n          ramDiskReplicaTracker.addReplica(\n              bpid, blockId, (FsVolumeImpl) vol, lockedBytesReserved);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          if (diskMetaFile.exists()) {\n            if (memBlockInfo.getMetaFile().exists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                  blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!diskFile.delete()) {\n              LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "27/04/15 4:48 PM",
      "commitNameOld": "feb68cb5470dc3e6c16b6bc1549141613e360601",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 4.72,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n-            HdfsConstantsClient.GRANDFATHER_GENERATION_STAMP;\n+            HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           ramDiskReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           if (diskMetaFile.exists()) {\n             if (memBlockInfo.getMetaFile().exists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                   blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n               ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!diskFile.delete()) {\n               LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n-              : HdfsConstantsClient.GRANDFATHER_GENERATION_STAMP;\n+              : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          ramDiskReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          if (diskMetaFile.exists()) {\n            if (memBlockInfo.getMetaFile().exists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                  blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!diskFile.delete()) {\n              LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : HdfsConstants.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "76e7264e8d6407f527bd877009aca11f7bb63bd7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8165. Move GRANDFATHER_GENERATION_STAMP and GRANDFATER_INODE_ID to hdfs-client. Contributed by Haohui Mai.\n",
      "commitDate": "16/04/15 10:49 PM",
      "commitName": "76e7264e8d6407f527bd877009aca11f7bb63bd7",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "07/04/15 7:31 PM",
      "commitNameOld": "66763bb06f107f0e072c773a5feb25903c688ddc",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 9.14,
      "commitsBetweenForRepo": 84,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n-            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n+            HdfsConstantsClient.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         if (vol.isTransientStorage()) {\n           ramDiskReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           if (diskMetaFile.exists()) {\n             if (memBlockInfo.getMetaFile().exists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                   blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n               ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!diskFile.delete()) {\n               LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n-              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n+              : HdfsConstantsClient.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            HdfsConstantsClient.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          ramDiskReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          if (diskMetaFile.exists()) {\n            if (memBlockInfo.getMetaFile().exists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                  blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!diskFile.delete()) {\n              LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : HdfsConstantsClient.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "6e62a1a6728b1f782f64065424f92b292c3f163a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7430. Refactor the BlockScanner to use O(1) memory and use multiple threads (cmccabe)\n",
      "commitDate": "21/01/15 7:00 PM",
      "commitName": "6e62a1a6728b1f782f64065424f92b292c3f163a",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "21/01/15 12:41 PM",
      "commitNameOld": "c0af72c7f74b6925786e24543cac433b906dd6d3",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.26,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,153 +1,144 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n-          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n-          if (blockScanner !\u003d null) {\n-            blockScanner.deleteBlock(bpid, new Block(blockId));\n-          }\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n-        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n-        if (!vol.isTransientStorage()) {\n-          if (blockScanner !\u003d null) {\n-            blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo), false);\n-          }\n-        } else {\n+        if (vol.isTransientStorage()) {\n           ramDiskReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           if (diskMetaFile.exists()) {\n             if (memBlockInfo.getMetaFile().exists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                   blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n               ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!diskFile.delete()) {\n               LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (vol.isTransientStorage()) {\n          ramDiskReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          if (diskMetaFile.exists()) {\n            if (memBlockInfo.getMetaFile().exists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                  blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!diskFile.delete()) {\n              LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "c0af72c7f74b6925786e24543cac433b906dd6d3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7548. Corrupt block reporting delayed until datablock scanner thread detects it. Contributed by Rushabh Shah.\n",
      "commitDate": "21/01/15 12:41 PM",
      "commitName": "c0af72c7f74b6925786e24543cac433b906dd6d3",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "20/01/15 8:11 PM",
      "commitNameOld": "a17584936cc5141e3f5612ac3ecf35e27968e439",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 0.69,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,153 +1,153 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n           if (blockScanner !\u003d null) {\n             blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n           if (vol.isTransientStorage()) {\n             ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n         if (!vol.isTransientStorage()) {\n           if (blockScanner !\u003d null) {\n-            blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n+            blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo), false);\n           }\n         } else {\n           ramDiskReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           if (diskMetaFile.exists()) {\n             if (memBlockInfo.getMetaFile().exists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                   blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n               ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!diskFile.delete()) {\n               LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n          if (blockScanner !\u003d null) {\n            blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n        if (!vol.isTransientStorage()) {\n          if (blockScanner !\u003d null) {\n            blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo), false);\n          }\n        } else {\n          ramDiskReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          if (diskMetaFile.exists()) {\n            if (memBlockInfo.getMetaFile().exists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                  blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!diskFile.delete()) {\n              LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "b2d5ed36bcb80e2581191dcdc3976e825c959142": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7100. Make eviction scheme pluggable. (Arpit Agarwal)\n",
      "commitDate": "20/09/14 1:25 PM",
      "commitName": "b2d5ed36bcb80e2581191dcdc3976e825c959142",
      "commitAuthor": "arp",
      "commitDateOld": "19/09/14 10:02 AM",
      "commitNameOld": "222bf0fe6706ee43964fd39b8315c1a339fbc84a",
      "commitAuthorOld": "",
      "daysBetweenCommits": 1.14,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,152 +1,153 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n           if (blockScanner !\u003d null) {\n             blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n           if (vol.isTransientStorage()) {\n-            lazyWriteReplicaTracker.discardReplica(bpid, blockId, true);\n+            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n-        if (blockScanner !\u003d null) {\n-          blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n-        }\n-        if (vol.isTransientStorage()) {\n-          lazyWriteReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n+        if (!vol.isTransientStorage()) {\n+          if (blockScanner !\u003d null) {\n+            blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n+          }\n+        } else {\n+          ramDiskReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           if (diskMetaFile.exists()) {\n             if (memBlockInfo.getMetaFile().exists()) {\n               // We have two sets of block+meta files. Decide which one to\n               // keep.\n               ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                   blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n               ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                   memBlockInfo, diskBlockInfo, volumeMap);\n             }\n           } else {\n             if (!diskFile.delete()) {\n               LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n             }\n           }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n          if (blockScanner !\u003d null) {\n            blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          if (vol.isTransientStorage()) {\n            ramDiskReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n        if (!vol.isTransientStorage()) {\n          if (blockScanner !\u003d null) {\n            blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n          }\n        } else {\n          ramDiskReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          if (diskMetaFile.exists()) {\n            if (memBlockInfo.getMetaFile().exists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                  blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!diskFile.delete()) {\n              LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "9f22fb8c9a10952225e15c7b67b5f77fa44b155d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6978. Directory scanner should correctly reconcile blocks on RAM disk. (Arpit Agarwal)\n",
      "commitDate": "12/09/14 10:13 PM",
      "commitName": "9f22fb8c9a10952225e15c7b67b5f77fa44b155d",
      "commitAuthor": "arp",
      "commitDateOld": "08/09/14 10:44 PM",
      "commitNameOld": "61ccd503624457035759e8b605d93dacb6135fce",
      "commitAuthorOld": "",
      "daysBetweenCommits": 3.98,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,142 +1,152 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n           if (blockScanner !\u003d null) {\n             blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n           if (vol.isTransientStorage()) {\n             lazyWriteReplicaTracker.discardReplica(bpid, blockId, true);\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n         if (blockScanner !\u003d null) {\n           blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n         if (vol.isTransientStorage()) {\n           lazyWriteReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n-          LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n-              + \" does not match file found by scan \"\n-              + diskFile.getAbsolutePath());\n-          // TODO: Should the diskFile be deleted?\n+          if (diskMetaFile.exists()) {\n+            if (memBlockInfo.getMetaFile().exists()) {\n+              // We have two sets of block+meta files. Decide which one to\n+              // keep.\n+              ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n+                  blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n+              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n+                  memBlockInfo, diskBlockInfo, volumeMap);\n+            }\n+          } else {\n+            if (!diskFile.delete()) {\n+              LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n+            }\n+          }\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n          if (blockScanner !\u003d null) {\n            blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          if (vol.isTransientStorage()) {\n            lazyWriteReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n        if (blockScanner !\u003d null) {\n          blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        if (vol.isTransientStorage()) {\n          lazyWriteReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          if (diskMetaFile.exists()) {\n            if (memBlockInfo.getMetaFile().exists()) {\n              // We have two sets of block+meta files. Decide which one to\n              // keep.\n              ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(\n                  blockId, diskFile.length(), diskGS, vol, diskFile.getParentFile());\n              ((FsVolumeImpl) vol).getBlockPoolSlice(bpid).resolveDuplicateReplicas(\n                  memBlockInfo, diskBlockInfo, volumeMap);\n            }\n          } else {\n            if (!diskFile.delete()) {\n              LOG.warn(\"Failed to delete \" + diskFile + \". Will retry on next scan\");\n            }\n          }\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "eb448e14399e17f11b9e523e4050de245b9b0408": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "HDFS-6926. DN support for saving replicas to persistent storage and evicting in-memory replicas. (Arpit Agarwal)\n",
      "commitDate": "27/08/14 9:47 PM",
      "commitName": "eb448e14399e17f11b9e523e4050de245b9b0408",
      "commitAuthor": "arp",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "HDFS-6926. DN support for saving replicas to persistent storage and evicting in-memory replicas. (Arpit Agarwal)\n",
          "commitDate": "27/08/14 9:47 PM",
          "commitName": "eb448e14399e17f11b9e523e4050de245b9b0408",
          "commitAuthor": "arp",
          "commitDateOld": "27/08/14 9:47 PM",
          "commitNameOld": "a317bd7b02c37bd57743bfad59593ec12f53f4ed",
          "commitAuthorOld": "arp",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,136 +1,142 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n-      File diskMetaFile, FsVolumeSpi vol) {\n+      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n           if (blockScanner !\u003d null) {\n             blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n+          if (vol.isTransientStorage()) {\n+            lazyWriteReplicaTracker.discardReplica(bpid, blockId, true);\n+          }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n         if (blockScanner !\u003d null) {\n           blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n+        if (vol.isTransientStorage()) {\n+          lazyWriteReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n+        }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n          if (blockScanner !\u003d null) {\n            blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          if (vol.isTransientStorage()) {\n            lazyWriteReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n        if (blockScanner !\u003d null) {\n          blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        if (vol.isTransientStorage()) {\n          lazyWriteReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[IOException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6926. DN support for saving replicas to persistent storage and evicting in-memory replicas. (Arpit Agarwal)\n",
          "commitDate": "27/08/14 9:47 PM",
          "commitName": "eb448e14399e17f11b9e523e4050de245b9b0408",
          "commitAuthor": "arp",
          "commitDateOld": "27/08/14 9:47 PM",
          "commitNameOld": "a317bd7b02c37bd57743bfad59593ec12f53f4ed",
          "commitAuthorOld": "arp",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,136 +1,142 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n-      File diskMetaFile, FsVolumeSpi vol) {\n+      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n           if (blockScanner !\u003d null) {\n             blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n+          if (vol.isTransientStorage()) {\n+            lazyWriteReplicaTracker.discardReplica(bpid, blockId, true);\n+          }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n         if (blockScanner !\u003d null) {\n           blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n+        if (vol.isTransientStorage()) {\n+          lazyWriteReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n+        }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) throws IOException {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n          if (blockScanner !\u003d null) {\n            blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          if (vol.isTransientStorage()) {\n            lazyWriteReplicaTracker.discardReplica(bpid, blockId, true);\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n        if (blockScanner !\u003d null) {\n          blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        if (vol.isTransientStorage()) {\n          lazyWriteReplicaTracker.addReplica(bpid, blockId, (FsVolumeImpl) vol);\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "fba994ffe20d387e8ed875e727fc3d93f7097101": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5648. Get rid of FsDatasetImpl#perVolumeReplicaMap.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1550357 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/12/13 11:01 PM",
      "commitName": "fba994ffe20d387e8ed875e727fc3d93f7097101",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "03/12/13 8:30 AM",
      "commitNameOld": "a1aa1836fb6831c25efe326cdfdc014370cf5957",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 8.6,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,139 +1,136 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n-          perVolumeReplicaMap.get(vol.getStorageID()).remove(bpid, blockId);\n           final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n           if (blockScanner !\u003d null) {\n             blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n-        perVolumeReplicaMap.get(vol.getStorageID())\n-            .remove(bpid, diskBlockInfo);\n         final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n         if (blockScanner !\u003d null) {\n           blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n          if (blockScanner !\u003d null) {\n            blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n        if (blockScanner !\u003d null) {\n          blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "f39f8c57344ede533ca4363c98230f3a0c401a76": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5401. Fix NPE in Directory Scanner.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1535158 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/10/13 1:28 PM",
      "commitName": "f39f8c57344ede533ca4363c98230f3a0c401a76",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "22/10/13 6:28 PM",
      "commitNameOld": "01f37e42f050207b7659bf74e2484cf8bdae2d89",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,139 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n-          perVolumeReplicaMap.get((FsVolumeImpl) memBlockInfo.getVolume())\n-              .remove(bpid, blockId);\n+          perVolumeReplicaMap.get(vol.getStorageID()).remove(bpid, blockId);\n           final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n           if (blockScanner !\u003d null) {\n             blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n-        perVolumeReplicaMap.get((FsVolumeImpl) memBlockInfo.getVolume()).\n-            remove(bpid, diskBlockInfo);\n+        perVolumeReplicaMap.get(vol.getStorageID())\n+            .remove(bpid, diskBlockInfo);\n         final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n         if (blockScanner !\u003d null) {\n           blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          perVolumeReplicaMap.get(vol.getStorageID()).remove(bpid, blockId);\n          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n          if (blockScanner !\u003d null) {\n            blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        perVolumeReplicaMap.get(vol.getStorageID())\n            .remove(bpid, diskBlockInfo);\n        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n        if (blockScanner !\u003d null) {\n          blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "46099ce7f1a1d5aab85d9408dc1454fcbe54f7e8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4988. Datanode must support all the volumes as individual storages.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-2832@1526969 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/09/13 9:05 AM",
      "commitName": "46099ce7f1a1d5aab85d9408dc1454fcbe54f7e8",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "10/09/13 11:30 PM",
      "commitNameOld": "b2976af14034c6e2a7e9964535b9f363bfc31150",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 16.4,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,136 +1,140 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n+          perVolumeReplicaMap.get((FsVolumeImpl) memBlockInfo.getVolume())\n+              .remove(bpid, blockId);\n           final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n           if (blockScanner !\u003d null) {\n             blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n           LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n+        perVolumeReplicaMap.get((FsVolumeImpl) memBlockInfo.getVolume()).\n+            remove(bpid, diskBlockInfo);\n         final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n         if (blockScanner !\u003d null) {\n           blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n         LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          perVolumeReplicaMap.get((FsVolumeImpl) memBlockInfo.getVolume())\n              .remove(bpid, blockId);\n          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n          if (blockScanner !\u003d null) {\n            blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        perVolumeReplicaMap.get((FsVolumeImpl) memBlockInfo.getVolume()).\n            remove(bpid, diskBlockInfo);\n        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n        if (blockScanner !\u003d null) {\n          blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
      "extendedDetails": {}
    },
    "bc13dfb1426944ce45293cb8f444239a7406762c": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "HDFS-3130. Move fsdataset implementation to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308437 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/04/12 10:38 AM",
      "commitName": "bc13dfb1426944ce45293cb8f444239a7406762c",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-3130. Move fsdataset implementation to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308437 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/04/12 10:38 AM",
          "commitName": "bc13dfb1426944ce45293cb8f444239a7406762c",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "01/04/12 8:48 PM",
          "commitNameOld": "a4ccb8f504e79802f1b3c69acbcbb00b2343c529",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.58,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,134 +1,136 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n-            DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n+            LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n-          if (datanode.blockScanner !\u003d null) {\n-            datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n+          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n+          if (blockScanner !\u003d null) {\n+            blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n-          DataNode.LOG.warn(\"Removed block \" + blockId\n+          LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n-            DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n+            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n-        if (datanode.blockScanner !\u003d null) {\n-          datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n+        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n+        if (blockScanner !\u003d null) {\n+          blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n-        DataNode.LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n+        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n-          DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n+          LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n-        DataNode.LOG.warn(\"Block file in volumeMap \"\n+        LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n-        DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n+        LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n-        File memMetaFile \u003d DatanodeUtil.getMetaFile(diskFile, \n+        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n-            DataNode.LOG.warn(\"Metadata file in memory \"\n+            LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n-          DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n+          LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n-        DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n+        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n-      DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n+      LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n-        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n+        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n          if (blockScanner !\u003d null) {\n            blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n        if (blockScanner !\u003d null) {\n          blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
            "oldMethodName": "checkAndUpdate",
            "newMethodName": "checkAndUpdate"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-3130. Move fsdataset implementation to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1308437 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/04/12 10:38 AM",
          "commitName": "bc13dfb1426944ce45293cb8f444239a7406762c",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "01/04/12 8:48 PM",
          "commitNameOld": "a4ccb8f504e79802f1b3c69acbcbb00b2343c529",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.58,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,134 +1,136 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FsVolumeSpi vol) {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n-            DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n+            LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n-          if (datanode.blockScanner !\u003d null) {\n-            datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n+          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n+          if (blockScanner !\u003d null) {\n+            blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n-          DataNode.LOG.warn(\"Removed block \" + blockId\n+          LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n-            DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n+            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n-        if (datanode.blockScanner !\u003d null) {\n-          datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n+        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n+        if (blockScanner !\u003d null) {\n+          blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n-        DataNode.LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n+        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n-          DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n+          LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n-        DataNode.LOG.warn(\"Block file in volumeMap \"\n+        LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n-        DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n+        LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n-        File memMetaFile \u003d DatanodeUtil.getMetaFile(diskFile, \n+        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n-            DataNode.LOG.warn(\"Metadata file in memory \"\n+            LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n-          DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n+          LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n-        DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n+        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n-      DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n+      LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n-        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n+        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n          if (blockScanner !\u003d null) {\n            blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        final DataBlockScanner blockScanner \u003d datanode.getBlockScanner();\n        if (blockScanner !\u003d null) {\n          blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d FsDatasetUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/FsDatasetImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "662b1887af4e39f3eadd7dda4953c7f2529b43bc": {
      "type": "Yparameterchange",
      "commitMessage": "HDFS-3088. Move FSDatasetInterface inner classes to a package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1301661 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/03/12 10:32 AM",
      "commitName": "662b1887af4e39f3eadd7dda4953c7f2529b43bc",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "15/03/12 11:24 AM",
      "commitNameOld": "1177d4edc29f839b8df1038c4fbf37f56f56a2a0",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.96,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,134 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n-      File diskMetaFile, FSVolumeInterface vol) {\n+      File diskMetaFile, FsVolumeSpi vol) {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (datanode.blockScanner !\u003d null) {\n             datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n           DataNode.LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         if (datanode.blockScanner !\u003d null) {\n           datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n         DataNode.LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         DataNode.LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d DatanodeUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             DataNode.LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FsVolumeSpi vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (datanode.blockScanner !\u003d null) {\n            datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          DataNode.LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (datanode.blockScanner !\u003d null) {\n          datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        DataNode.LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        DataNode.LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d DatanodeUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            DataNode.LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {
        "oldValue": "[bpid-String, blockId-long, diskFile-File, diskMetaFile-File, vol-FSVolumeInterface]",
        "newValue": "[bpid-String, blockId-long, diskFile-File, diskMetaFile-File, vol-FsVolumeSpi]"
      }
    },
    "501a283986d7bc4dff7bba12610576ffe982c34d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3056.  Add a new interface RollingLogs for DataBlockScanner logging.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1299139 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/03/12 5:52 PM",
      "commitName": "501a283986d7bc4dff7bba12610576ffe982c34d",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "01/03/12 1:58 PM",
      "commitNameOld": "9e31bf675dd92183a9a74a66b7caf1a080581d65",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 8.16,
      "commitsBetweenForRepo": 55,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,134 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FSVolumeInterface vol) {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (datanode.blockScanner !\u003d null) {\n             datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n           DataNode.LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         if (datanode.blockScanner !\u003d null) {\n           datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n         DataNode.LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         DataNode.LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d DatanodeUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             DataNode.LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n-                + diskMetaFile.getAbsolutePath());\n+                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FSVolumeInterface vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (datanode.blockScanner !\u003d null) {\n            datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          DataNode.LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (datanode.blockScanner !\u003d null) {\n          datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        DataNode.LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        DataNode.LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d DatanodeUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            DataNode.LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + (diskMetaFile \u003d\u003d null? null: diskMetaFile.getAbsolutePath()));\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {}
    },
    "b6ffb08a467f1b5bc89e5114c462c3117b337be6": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-2887. FSVolume, is a part of FSDatasetInterface implementation, should not be referred outside FSDataset.  A new FSVolumeInterface is defined.  The BlockVolumeChoosingPolicy.chooseVolume(..) method signature is also updated.  (szetszwo)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1242087 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/02/12 12:58 PM",
      "commitName": "b6ffb08a467f1b5bc89e5114c462c3117b337be6",
      "commitAuthor": "Tsz-wo Sze",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-2887. FSVolume, is a part of FSDatasetInterface implementation, should not be referred outside FSDataset.  A new FSVolumeInterface is defined.  The BlockVolumeChoosingPolicy.chooseVolume(..) method signature is also updated.  (szetszwo)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1242087 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/02/12 12:58 PM",
          "commitName": "b6ffb08a467f1b5bc89e5114c462c3117b337be6",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "02/02/12 11:26 PM",
          "commitNameOld": "38ad4b503686a0d18cb2d42ffdecf06f0ba7b98f",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 5.56,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,134 +1,134 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n-      File diskMetaFile, FSVolume vol) {\n+      File diskMetaFile, FSVolumeInterface vol) {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (datanode.blockScanner !\u003d null) {\n             datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n           DataNode.LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         if (datanode.blockScanner !\u003d null) {\n           datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n         DataNode.LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         DataNode.LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n-        File memMetaFile \u003d getMetaFile(diskFile, \n+        File memMetaFile \u003d DatanodeUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             DataNode.LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FSVolumeInterface vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (datanode.blockScanner !\u003d null) {\n            datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          DataNode.LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (datanode.blockScanner !\u003d null) {\n          datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        DataNode.LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        DataNode.LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d DatanodeUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            DataNode.LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
          "extendedDetails": {
            "oldValue": "[bpid-String, blockId-long, diskFile-File, diskMetaFile-File, vol-FSVolume]",
            "newValue": "[bpid-String, blockId-long, diskFile-File, diskMetaFile-File, vol-FSVolumeInterface]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2887. FSVolume, is a part of FSDatasetInterface implementation, should not be referred outside FSDataset.  A new FSVolumeInterface is defined.  The BlockVolumeChoosingPolicy.chooseVolume(..) method signature is also updated.  (szetszwo)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1242087 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/02/12 12:58 PM",
          "commitName": "b6ffb08a467f1b5bc89e5114c462c3117b337be6",
          "commitAuthor": "Tsz-wo Sze",
          "commitDateOld": "02/02/12 11:26 PM",
          "commitNameOld": "38ad4b503686a0d18cb2d42ffdecf06f0ba7b98f",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 5.56,
          "commitsBetweenForRepo": 61,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,134 +1,134 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n-      File diskMetaFile, FSVolume vol) {\n+      File diskMetaFile, FSVolumeInterface vol) {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (datanode.blockScanner !\u003d null) {\n             datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n           DataNode.LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         if (datanode.blockScanner !\u003d null) {\n           datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n         DataNode.LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         DataNode.LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n-        File memMetaFile \u003d getMetaFile(diskFile, \n+        File memMetaFile \u003d DatanodeUtil.getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             DataNode.LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FSVolumeInterface vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (datanode.blockScanner !\u003d null) {\n            datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          DataNode.LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (datanode.blockScanner !\u003d null) {\n          datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        DataNode.LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        DataNode.LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d DatanodeUtil.getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            DataNode.LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
          "extendedDetails": {}
        }
      ]
    },
    "b7cd8c0f865e88e40eee75fd2690b1fdc4155071": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2564. Cleanup unnecessary exceptions thrown and unnecessary casts. Contributed by Hari Mankude\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1203950 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/11 6:34 PM",
      "commitName": "b7cd8c0f865e88e40eee75fd2690b1fdc4155071",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "02/11/11 6:00 PM",
      "commitNameOld": "11cf658d0a8c3fb0f0822c9fc60f18f2ae5bf629",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 16.07,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,134 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FSVolume vol) {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (datanode.blockScanner !\u003d null) {\n             datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n           DataNode.LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         if (datanode.blockScanner !\u003d null) {\n           datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n-        DataNode.LOG.warn(\"Added missing block to memory \" + (Block)diskBlockInfo);\n+        DataNode.LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         DataNode.LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             DataNode.LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n         DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FSVolume vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (datanode.blockScanner !\u003d null) {\n            datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          DataNode.LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (datanode.blockScanner !\u003d null) {\n          datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        DataNode.LOG.warn(\"Added missing block to memory \" + diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        DataNode.LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            DataNode.LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FSVolume vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (datanode.blockScanner !\u003d null) {\n            datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          DataNode.LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (datanode.blockScanner !\u003d null) {\n          datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        DataNode.LOG.warn(\"Added missing block to memory \" + (Block)diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        DataNode.LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            DataNode.LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FSVolume vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (datanode.blockScanner !\u003d null) {\n            datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          DataNode.LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (datanode.blockScanner !\u003d null) {\n          datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        DataNode.LOG.warn(\"Added missing block to memory \" + (Block)diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        DataNode.LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            DataNode.LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java"
      }
    },
    "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1977. Stop using StringUtils.stringifyException(). Contributed by Bharath Mundlapudi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1145834 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/11 6:11 PM",
      "commitName": "2c5dd549e31aa5d3377ff2619ede8e92b8dc5d0f",
      "commitAuthor": "Jitendra Nath Pandey",
      "commitDateOld": "30/06/11 1:56 PM",
      "commitNameOld": "3af51887b40df8de7482040cf8a90600a2c4305f",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 12.18,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,134 @@\n   public void checkAndUpdate(String bpid, long blockId, File diskFile,\n       File diskMetaFile, FSVolume vol) {\n     Block corruptBlock \u003d null;\n     ReplicaInfo memBlockInfo;\n     synchronized (this) {\n       memBlockInfo \u003d volumeMap.get(bpid, blockId);\n       if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n         // Block is not finalized - ignore the difference\n         return;\n       }\n \n       final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n           Block.getGenerationStamp(diskMetaFile.getName()) :\n             GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n       if (diskFile \u003d\u003d null || !diskFile.exists()) {\n         if (memBlockInfo \u003d\u003d null) {\n           // Block file does not exist and block does not exist in memory\n           // If metadata file exists then delete it\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n           return;\n         }\n         if (!memBlockInfo.getBlockFile().exists()) {\n           // Block is in memory and not on the disk\n           // Remove the block from volumeMap\n           volumeMap.remove(bpid, blockId);\n           if (datanode.blockScanner !\u003d null) {\n             datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n           }\n           DataNode.LOG.warn(\"Removed block \" + blockId\n               + \" from memory with missing block file on the disk\");\n           // Finally remove the metadata file\n           if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.delete()) {\n             DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         }\n         return;\n       }\n       /*\n        * Block file exists on the disk\n        */\n       if (memBlockInfo \u003d\u003d null) {\n         // Block is missing in memory - add the block to volumeMap\n         ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n             diskFile.length(), diskGS, vol, diskFile.getParentFile());\n         volumeMap.add(bpid, diskBlockInfo);\n         if (datanode.blockScanner !\u003d null) {\n           datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n         }\n         DataNode.LOG.warn(\"Added missing block to memory \" + (Block)diskBlockInfo);\n         return;\n       }\n       /*\n        * Block exists in volumeMap and the block file exists on the disk\n        */\n       // Compare block files\n       File memFile \u003d memBlockInfo.getBlockFile();\n       if (memFile.exists()) {\n         if (memFile.compareTo(diskFile) !\u003d 0) {\n           DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n               + \" does not match file found by scan \"\n               + diskFile.getAbsolutePath());\n           // TODO: Should the diskFile be deleted?\n         }\n       } else {\n         // Block refers to a block file that does not exist.\n         // Update the block with the file found on the disk. Since the block\n         // file and metadata file are found as a pair on the disk, update\n         // the block based on the metadata file found on the disk\n         DataNode.LOG.warn(\"Block file in volumeMap \"\n             + memFile.getAbsolutePath()\n             + \" does not exist. Updating it to the file found during scan \"\n             + diskFile.getAbsolutePath());\n         memBlockInfo.setDir(diskFile.getParentFile());\n         memFile \u003d diskFile;\n \n         DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n             + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n         memBlockInfo.setGenerationStamp(diskGS);\n       }\n \n       // Compare generation stamp\n       if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n         File memMetaFile \u003d getMetaFile(diskFile, \n             memBlockInfo.getGenerationStamp());\n         if (memMetaFile.exists()) {\n           if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n             DataNode.LOG.warn(\"Metadata file in memory \"\n                 + memMetaFile.getAbsolutePath()\n                 + \" does not match file found by scan \"\n                 + diskMetaFile.getAbsolutePath());\n           }\n         } else {\n           // Metadata file corresponding to block in memory is missing\n           // If metadata file found during the scan is on the same directory\n           // as the block file, then use the generation stamp from it\n           long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n               \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n               : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n \n           DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n               + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n \n           memBlockInfo.setGenerationStamp(gs);\n         }\n       }\n \n       // Compare block size\n       if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n         // Update the length based on the block file\n         corruptBlock \u003d new Block(memBlockInfo);\n         DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n             + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n         memBlockInfo.setNumBytes(memFile.length());\n       }\n     }\n \n     // Send corrupt block report outside the lock\n     if (corruptBlock !\u003d null) {\n       DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n           + \" as corrupt due to length mismatch\");\n       try {\n         datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n       } catch (IOException e) {\n-        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock\n-            + \"Exception:\" + StringUtils.stringifyException(e));\n+        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FSVolume vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (datanode.blockScanner !\u003d null) {\n            datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          DataNode.LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (datanode.blockScanner !\u003d null) {\n          datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        DataNode.LOG.warn(\"Added missing block to memory \" + (Block)diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        DataNode.LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            DataNode.LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock, e);\n      }\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,135 @@\n+  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n+      File diskMetaFile, FSVolume vol) {\n+    Block corruptBlock \u003d null;\n+    ReplicaInfo memBlockInfo;\n+    synchronized (this) {\n+      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n+      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n+        // Block is not finalized - ignore the difference\n+        return;\n+      }\n+\n+      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n+          Block.getGenerationStamp(diskMetaFile.getName()) :\n+            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n+\n+      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n+        if (memBlockInfo \u003d\u003d null) {\n+          // Block file does not exist and block does not exist in memory\n+          // If metadata file exists then delete it\n+          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n+              \u0026\u0026 diskMetaFile.delete()) {\n+            DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n+                + diskMetaFile.getAbsolutePath());\n+          }\n+          return;\n+        }\n+        if (!memBlockInfo.getBlockFile().exists()) {\n+          // Block is in memory and not on the disk\n+          // Remove the block from volumeMap\n+          volumeMap.remove(bpid, blockId);\n+          if (datanode.blockScanner !\u003d null) {\n+            datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n+          }\n+          DataNode.LOG.warn(\"Removed block \" + blockId\n+              + \" from memory with missing block file on the disk\");\n+          // Finally remove the metadata file\n+          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n+              \u0026\u0026 diskMetaFile.delete()) {\n+            DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n+                + diskMetaFile.getAbsolutePath());\n+          }\n+        }\n+        return;\n+      }\n+      /*\n+       * Block file exists on the disk\n+       */\n+      if (memBlockInfo \u003d\u003d null) {\n+        // Block is missing in memory - add the block to volumeMap\n+        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n+            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n+        volumeMap.add(bpid, diskBlockInfo);\n+        if (datanode.blockScanner !\u003d null) {\n+          datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n+        }\n+        DataNode.LOG.warn(\"Added missing block to memory \" + (Block)diskBlockInfo);\n+        return;\n+      }\n+      /*\n+       * Block exists in volumeMap and the block file exists on the disk\n+       */\n+      // Compare block files\n+      File memFile \u003d memBlockInfo.getBlockFile();\n+      if (memFile.exists()) {\n+        if (memFile.compareTo(diskFile) !\u003d 0) {\n+          DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n+              + \" does not match file found by scan \"\n+              + diskFile.getAbsolutePath());\n+          // TODO: Should the diskFile be deleted?\n+        }\n+      } else {\n+        // Block refers to a block file that does not exist.\n+        // Update the block with the file found on the disk. Since the block\n+        // file and metadata file are found as a pair on the disk, update\n+        // the block based on the metadata file found on the disk\n+        DataNode.LOG.warn(\"Block file in volumeMap \"\n+            + memFile.getAbsolutePath()\n+            + \" does not exist. Updating it to the file found during scan \"\n+            + diskFile.getAbsolutePath());\n+        memBlockInfo.setDir(diskFile.getParentFile());\n+        memFile \u003d diskFile;\n+\n+        DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n+            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n+        memBlockInfo.setGenerationStamp(diskGS);\n+      }\n+\n+      // Compare generation stamp\n+      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n+        File memMetaFile \u003d getMetaFile(diskFile, \n+            memBlockInfo.getGenerationStamp());\n+        if (memMetaFile.exists()) {\n+          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n+            DataNode.LOG.warn(\"Metadata file in memory \"\n+                + memMetaFile.getAbsolutePath()\n+                + \" does not match file found by scan \"\n+                + diskMetaFile.getAbsolutePath());\n+          }\n+        } else {\n+          // Metadata file corresponding to block in memory is missing\n+          // If metadata file found during the scan is on the same directory\n+          // as the block file, then use the generation stamp from it\n+          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n+              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n+              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n+\n+          DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n+              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n+\n+          memBlockInfo.setGenerationStamp(gs);\n+        }\n+      }\n+\n+      // Compare block size\n+      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n+        // Update the length based on the block file\n+        corruptBlock \u003d new Block(memBlockInfo);\n+        DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n+            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n+        memBlockInfo.setNumBytes(memFile.length());\n+      }\n+    }\n+\n+    // Send corrupt block report outside the lock\n+    if (corruptBlock !\u003d null) {\n+      DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n+          + \" as corrupt due to length mismatch\");\n+      try {\n+        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n+      } catch (IOException e) {\n+        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock\n+            + \"Exception:\" + StringUtils.stringifyException(e));\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void checkAndUpdate(String bpid, long blockId, File diskFile,\n      File diskMetaFile, FSVolume vol) {\n    Block corruptBlock \u003d null;\n    ReplicaInfo memBlockInfo;\n    synchronized (this) {\n      memBlockInfo \u003d volumeMap.get(bpid, blockId);\n      if (memBlockInfo !\u003d null \u0026\u0026 memBlockInfo.getState() !\u003d ReplicaState.FINALIZED) {\n        // Block is not finalized - ignore the difference\n        return;\n      }\n\n      final long diskGS \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists() ?\n          Block.getGenerationStamp(diskMetaFile.getName()) :\n            GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n      if (diskFile \u003d\u003d null || !diskFile.exists()) {\n        if (memBlockInfo \u003d\u003d null) {\n          // Block file does not exist and block does not exist in memory\n          // If metadata file exists then delete it\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file without a block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n          return;\n        }\n        if (!memBlockInfo.getBlockFile().exists()) {\n          // Block is in memory and not on the disk\n          // Remove the block from volumeMap\n          volumeMap.remove(bpid, blockId);\n          if (datanode.blockScanner !\u003d null) {\n            datanode.blockScanner.deleteBlock(bpid, new Block(blockId));\n          }\n          DataNode.LOG.warn(\"Removed block \" + blockId\n              + \" from memory with missing block file on the disk\");\n          // Finally remove the metadata file\n          if (diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.delete()) {\n            DataNode.LOG.warn(\"Deleted a metadata file for the deleted block \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        }\n        return;\n      }\n      /*\n       * Block file exists on the disk\n       */\n      if (memBlockInfo \u003d\u003d null) {\n        // Block is missing in memory - add the block to volumeMap\n        ReplicaInfo diskBlockInfo \u003d new FinalizedReplica(blockId, \n            diskFile.length(), diskGS, vol, diskFile.getParentFile());\n        volumeMap.add(bpid, diskBlockInfo);\n        if (datanode.blockScanner !\u003d null) {\n          datanode.blockScanner.addBlock(new ExtendedBlock(bpid, diskBlockInfo));\n        }\n        DataNode.LOG.warn(\"Added missing block to memory \" + (Block)diskBlockInfo);\n        return;\n      }\n      /*\n       * Block exists in volumeMap and the block file exists on the disk\n       */\n      // Compare block files\n      File memFile \u003d memBlockInfo.getBlockFile();\n      if (memFile.exists()) {\n        if (memFile.compareTo(diskFile) !\u003d 0) {\n          DataNode.LOG.warn(\"Block file \" + memFile.getAbsolutePath()\n              + \" does not match file found by scan \"\n              + diskFile.getAbsolutePath());\n          // TODO: Should the diskFile be deleted?\n        }\n      } else {\n        // Block refers to a block file that does not exist.\n        // Update the block with the file found on the disk. Since the block\n        // file and metadata file are found as a pair on the disk, update\n        // the block based on the metadata file found on the disk\n        DataNode.LOG.warn(\"Block file in volumeMap \"\n            + memFile.getAbsolutePath()\n            + \" does not exist. Updating it to the file found during scan \"\n            + diskFile.getAbsolutePath());\n        memBlockInfo.setDir(diskFile.getParentFile());\n        memFile \u003d diskFile;\n\n        DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n            + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + diskGS);\n        memBlockInfo.setGenerationStamp(diskGS);\n      }\n\n      // Compare generation stamp\n      if (memBlockInfo.getGenerationStamp() !\u003d diskGS) {\n        File memMetaFile \u003d getMetaFile(diskFile, \n            memBlockInfo.getGenerationStamp());\n        if (memMetaFile.exists()) {\n          if (memMetaFile.compareTo(diskMetaFile) !\u003d 0) {\n            DataNode.LOG.warn(\"Metadata file in memory \"\n                + memMetaFile.getAbsolutePath()\n                + \" does not match file found by scan \"\n                + diskMetaFile.getAbsolutePath());\n          }\n        } else {\n          // Metadata file corresponding to block in memory is missing\n          // If metadata file found during the scan is on the same directory\n          // as the block file, then use the generation stamp from it\n          long gs \u003d diskMetaFile !\u003d null \u0026\u0026 diskMetaFile.exists()\n              \u0026\u0026 diskMetaFile.getParent().equals(memFile.getParent()) ? diskGS\n              : GenerationStamp.GRANDFATHER_GENERATION_STAMP;\n\n          DataNode.LOG.warn(\"Updating generation stamp for block \" + blockId\n              + \" from \" + memBlockInfo.getGenerationStamp() + \" to \" + gs);\n\n          memBlockInfo.setGenerationStamp(gs);\n        }\n      }\n\n      // Compare block size\n      if (memBlockInfo.getNumBytes() !\u003d memFile.length()) {\n        // Update the length based on the block file\n        corruptBlock \u003d new Block(memBlockInfo);\n        DataNode.LOG.warn(\"Updating size of block \" + blockId + \" from \"\n            + memBlockInfo.getNumBytes() + \" to \" + memFile.length());\n        memBlockInfo.setNumBytes(memFile.length());\n      }\n    }\n\n    // Send corrupt block report outside the lock\n    if (corruptBlock !\u003d null) {\n      DataNode.LOG.warn(\"Reporting the block \" + corruptBlock\n          + \" as corrupt due to length mismatch\");\n      try {\n        datanode.reportBadBlocks(new ExtendedBlock(bpid, corruptBlock));  \n      } catch (IOException e) {\n        DataNode.LOG.warn(\"Failed to repot bad block \" + corruptBlock\n            + \"Exception:\" + StringUtils.stringifyException(e));\n      }\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/datanode/FSDataset.java"
    }
  }
}