{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ShortCircuitCache.java",
  "functionName": "unref",
  "functionId": "unref___replica-ShortCircuitReplica",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/shortcircuit/ShortCircuitCache.java",
  "functionStartLine": 446,
  "functionEndLine": 508,
  "numCommitsSeen": 31,
  "timeTaken": 3589,
  "changeHistory": [
    "39285e6a1978ea5e53bdc1b0aef62421382124a8",
    "6ee0539ede78b640f01c5eac18ded161182a7835",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
    "c992bcf9c136d3df686655a80e636bb7bb0664da",
    "ed72daa5df97669906234e8ac9a406d78136b206",
    "7caa3bc98e6880f98c5c32c486a0c539f9fd3f5f",
    "8d9e8cec9fd10fbeafa4ff38217f3984538b187a",
    "f93d99990a9a02ce693cd74466c2e5f127c1f560",
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be"
  ],
  "changeHistoryShort": {
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": "Ybodychange",
    "6ee0539ede78b640f01c5eac18ded161182a7835": "Ybodychange",
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": "Ybodychange",
    "c992bcf9c136d3df686655a80e636bb7bb0664da": "Yfilerename",
    "ed72daa5df97669906234e8ac9a406d78136b206": "Ybodychange",
    "7caa3bc98e6880f98c5c32c486a0c539f9fd3f5f": "Ybodychange",
    "8d9e8cec9fd10fbeafa4ff38217f3984538b187a": "Ybodychange",
    "f93d99990a9a02ce693cd74466c2e5f127c1f560": "Yfilerename",
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": "Ybodychange",
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39285e6a1978ea5e53bdc1b0aef62421382124a8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8971. Remove guards when calling LOG.debug() and LOG.trace() in client package. Contributed by Mingliang Liu.\n",
      "commitDate": "29/09/15 5:52 PM",
      "commitName": "39285e6a1978ea5e53bdc1b0aef62421382124a8",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:51 PM",
      "commitNameOld": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,63 @@\n   void unref(ShortCircuitReplica replica) {\n     lock.lock();\n     try {\n       // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n       // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n       // that we could put a stale or unusable one into the cache.\n       if (!replica.purged) {\n         String purgeReason \u003d null;\n         if (!replica.getDataStream().getChannel().isOpen()) {\n           purgeReason \u003d \"purging replica because its data channel is closed.\";\n         } else if (!replica.getMetaStream().getChannel().isOpen()) {\n           purgeReason \u003d \"purging replica because its meta channel is closed.\";\n         } else if (replica.isStale()) {\n           purgeReason \u003d \"purging replica because it is stale.\";\n         }\n         if (purgeReason !\u003d null) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(this + \": \" + purgeReason);\n-          }\n+          LOG.debug(\"{}: {}\", this, purgeReason);\n           purge(replica);\n         }\n       }\n       String addedString \u003d \"\";\n       boolean shouldTrimEvictionMaps \u003d false;\n       int newRefCount \u003d --replica.refCount;\n       if (newRefCount \u003d\u003d 0) {\n         // Close replica, since there are no remaining references to it.\n         Preconditions.checkArgument(replica.purged,\n           \"Replica %s reached a refCount of 0 without being purged\", replica);\n         replica.close();\n       } else if (newRefCount \u003d\u003d 1) {\n         Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n             \"Replica %s had a refCount higher than 1, \" +\n               \"but was still evictable (evictableTimeNs \u003d %d)\",\n               replica, replica.getEvictableTimeNs());\n         if (!replica.purged) {\n           // Add the replica to the end of an eviction list.\n           // Eviction lists are sorted by time.\n           if (replica.hasMmap()) {\n             insertEvictable(System.nanoTime(), replica, evictableMmapped);\n             addedString \u003d \"added to evictableMmapped, \";\n           } else {\n             insertEvictable(System.nanoTime(), replica, evictable);\n             addedString \u003d \"added to evictable, \";\n           }\n           shouldTrimEvictionMaps \u003d true;\n         }\n       } else {\n         Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n             \"replica\u0027s refCount went negative (refCount \u003d %d\" +\n             \" for %s)\", replica.refCount, replica);\n       }\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": unref replica \" + replica +\n             \": \" + addedString + \" refCount \" +\n             (newRefCount + 1) + \" -\u003e \" + newRefCount +\n             StringUtils.getStackTrace(Thread.currentThread()));\n       }\n       if (shouldTrimEvictionMaps) {\n         trimEvictionMaps();\n       }\n     } finally {\n       lock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void unref(ShortCircuitReplica replica) {\n    lock.lock();\n    try {\n      // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n      // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n      // that we could put a stale or unusable one into the cache.\n      if (!replica.purged) {\n        String purgeReason \u003d null;\n        if (!replica.getDataStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its data channel is closed.\";\n        } else if (!replica.getMetaStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its meta channel is closed.\";\n        } else if (replica.isStale()) {\n          purgeReason \u003d \"purging replica because it is stale.\";\n        }\n        if (purgeReason !\u003d null) {\n          LOG.debug(\"{}: {}\", this, purgeReason);\n          purge(replica);\n        }\n      }\n      String addedString \u003d \"\";\n      boolean shouldTrimEvictionMaps \u003d false;\n      int newRefCount \u003d --replica.refCount;\n      if (newRefCount \u003d\u003d 0) {\n        // Close replica, since there are no remaining references to it.\n        Preconditions.checkArgument(replica.purged,\n          \"Replica %s reached a refCount of 0 without being purged\", replica);\n        replica.close();\n      } else if (newRefCount \u003d\u003d 1) {\n        Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n            \"Replica %s had a refCount higher than 1, \" +\n              \"but was still evictable (evictableTimeNs \u003d %d)\",\n              replica, replica.getEvictableTimeNs());\n        if (!replica.purged) {\n          // Add the replica to the end of an eviction list.\n          // Eviction lists are sorted by time.\n          if (replica.hasMmap()) {\n            insertEvictable(System.nanoTime(), replica, evictableMmapped);\n            addedString \u003d \"added to evictableMmapped, \";\n          } else {\n            insertEvictable(System.nanoTime(), replica, evictable);\n            addedString \u003d \"added to evictable, \";\n          }\n          shouldTrimEvictionMaps \u003d true;\n        }\n      } else {\n        Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n            \"replica\u0027s refCount went negative (refCount \u003d %d\" +\n            \" for %s)\", replica.refCount, replica);\n      }\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": unref replica \" + replica +\n            \": \" + addedString + \" refCount \" +\n            (newRefCount + 1) + \" -\u003e \" + newRefCount +\n            StringUtils.getStackTrace(Thread.currentThread()));\n      }\n      if (shouldTrimEvictionMaps) {\n        trimEvictionMaps();\n      }\n    } finally {\n      lock.unlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/shortcircuit/ShortCircuitCache.java",
      "extendedDetails": {}
    },
    "6ee0539ede78b640f01c5eac18ded161182a7835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\"\n\nThis reverts commit d5a9a3daa0224249221ffa7b8bd5751ab2feca56.\n",
      "commitDate": "29/09/15 5:51 PM",
      "commitName": "6ee0539ede78b640f01c5eac18ded161182a7835",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "29/09/15 5:48 PM",
      "commitNameOld": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,65 @@\n   void unref(ShortCircuitReplica replica) {\n     lock.lock();\n     try {\n       // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n       // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n       // that we could put a stale or unusable one into the cache.\n       if (!replica.purged) {\n         String purgeReason \u003d null;\n         if (!replica.getDataStream().getChannel().isOpen()) {\n           purgeReason \u003d \"purging replica because its data channel is closed.\";\n         } else if (!replica.getMetaStream().getChannel().isOpen()) {\n           purgeReason \u003d \"purging replica because its meta channel is closed.\";\n         } else if (replica.isStale()) {\n           purgeReason \u003d \"purging replica because it is stale.\";\n         }\n         if (purgeReason !\u003d null) {\n-          LOG.debug(\"{}: {}\", this, purgeReason);\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(this + \": \" + purgeReason);\n+          }\n           purge(replica);\n         }\n       }\n       String addedString \u003d \"\";\n       boolean shouldTrimEvictionMaps \u003d false;\n       int newRefCount \u003d --replica.refCount;\n       if (newRefCount \u003d\u003d 0) {\n         // Close replica, since there are no remaining references to it.\n         Preconditions.checkArgument(replica.purged,\n           \"Replica %s reached a refCount of 0 without being purged\", replica);\n         replica.close();\n       } else if (newRefCount \u003d\u003d 1) {\n         Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n             \"Replica %s had a refCount higher than 1, \" +\n               \"but was still evictable (evictableTimeNs \u003d %d)\",\n               replica, replica.getEvictableTimeNs());\n         if (!replica.purged) {\n           // Add the replica to the end of an eviction list.\n           // Eviction lists are sorted by time.\n           if (replica.hasMmap()) {\n             insertEvictable(System.nanoTime(), replica, evictableMmapped);\n             addedString \u003d \"added to evictableMmapped, \";\n           } else {\n             insertEvictable(System.nanoTime(), replica, evictable);\n             addedString \u003d \"added to evictable, \";\n           }\n           shouldTrimEvictionMaps \u003d true;\n         }\n       } else {\n         Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n             \"replica\u0027s refCount went negative (refCount \u003d %d\" +\n             \" for %s)\", replica.refCount, replica);\n       }\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": unref replica \" + replica +\n             \": \" + addedString + \" refCount \" +\n             (newRefCount + 1) + \" -\u003e \" + newRefCount +\n             StringUtils.getStackTrace(Thread.currentThread()));\n       }\n       if (shouldTrimEvictionMaps) {\n         trimEvictionMaps();\n       }\n     } finally {\n       lock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void unref(ShortCircuitReplica replica) {\n    lock.lock();\n    try {\n      // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n      // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n      // that we could put a stale or unusable one into the cache.\n      if (!replica.purged) {\n        String purgeReason \u003d null;\n        if (!replica.getDataStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its data channel is closed.\";\n        } else if (!replica.getMetaStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its meta channel is closed.\";\n        } else if (replica.isStale()) {\n          purgeReason \u003d \"purging replica because it is stale.\";\n        }\n        if (purgeReason !\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(this + \": \" + purgeReason);\n          }\n          purge(replica);\n        }\n      }\n      String addedString \u003d \"\";\n      boolean shouldTrimEvictionMaps \u003d false;\n      int newRefCount \u003d --replica.refCount;\n      if (newRefCount \u003d\u003d 0) {\n        // Close replica, since there are no remaining references to it.\n        Preconditions.checkArgument(replica.purged,\n          \"Replica %s reached a refCount of 0 without being purged\", replica);\n        replica.close();\n      } else if (newRefCount \u003d\u003d 1) {\n        Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n            \"Replica %s had a refCount higher than 1, \" +\n              \"but was still evictable (evictableTimeNs \u003d %d)\",\n              replica, replica.getEvictableTimeNs());\n        if (!replica.purged) {\n          // Add the replica to the end of an eviction list.\n          // Eviction lists are sorted by time.\n          if (replica.hasMmap()) {\n            insertEvictable(System.nanoTime(), replica, evictableMmapped);\n            addedString \u003d \"added to evictableMmapped, \";\n          } else {\n            insertEvictable(System.nanoTime(), replica, evictable);\n            addedString \u003d \"added to evictable, \";\n          }\n          shouldTrimEvictionMaps \u003d true;\n        }\n      } else {\n        Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n            \"replica\u0027s refCount went negative (refCount \u003d %d\" +\n            \" for %s)\", replica.refCount, replica);\n      }\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": unref replica \" + replica +\n            \": \" + addedString + \" refCount \" +\n            (newRefCount + 1) + \" -\u003e \" + newRefCount +\n            StringUtils.getStackTrace(Thread.currentThread()));\n      }\n      if (shouldTrimEvictionMaps) {\n        trimEvictionMaps();\n      }\n    } finally {\n      lock.unlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/shortcircuit/ShortCircuitCache.java",
      "extendedDetails": {}
    },
    "d5a9a3daa0224249221ffa7b8bd5751ab2feca56": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9170. Move libhdfs / fuse-dfs / libwebhdfs to hdfs-client. Contributed by Haohui Mai.\n",
      "commitDate": "29/09/15 5:48 PM",
      "commitName": "d5a9a3daa0224249221ffa7b8bd5751ab2feca56",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "26/08/15 2:02 PM",
      "commitNameOld": "c992bcf9c136d3df686655a80e636bb7bb0664da",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 34.16,
      "commitsBetweenForRepo": 233,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,63 @@\n   void unref(ShortCircuitReplica replica) {\n     lock.lock();\n     try {\n       // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n       // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n       // that we could put a stale or unusable one into the cache.\n       if (!replica.purged) {\n         String purgeReason \u003d null;\n         if (!replica.getDataStream().getChannel().isOpen()) {\n           purgeReason \u003d \"purging replica because its data channel is closed.\";\n         } else if (!replica.getMetaStream().getChannel().isOpen()) {\n           purgeReason \u003d \"purging replica because its meta channel is closed.\";\n         } else if (replica.isStale()) {\n           purgeReason \u003d \"purging replica because it is stale.\";\n         }\n         if (purgeReason !\u003d null) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(this + \": \" + purgeReason);\n-          }\n+          LOG.debug(\"{}: {}\", this, purgeReason);\n           purge(replica);\n         }\n       }\n       String addedString \u003d \"\";\n       boolean shouldTrimEvictionMaps \u003d false;\n       int newRefCount \u003d --replica.refCount;\n       if (newRefCount \u003d\u003d 0) {\n         // Close replica, since there are no remaining references to it.\n         Preconditions.checkArgument(replica.purged,\n           \"Replica %s reached a refCount of 0 without being purged\", replica);\n         replica.close();\n       } else if (newRefCount \u003d\u003d 1) {\n         Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n             \"Replica %s had a refCount higher than 1, \" +\n               \"but was still evictable (evictableTimeNs \u003d %d)\",\n               replica, replica.getEvictableTimeNs());\n         if (!replica.purged) {\n           // Add the replica to the end of an eviction list.\n           // Eviction lists are sorted by time.\n           if (replica.hasMmap()) {\n             insertEvictable(System.nanoTime(), replica, evictableMmapped);\n             addedString \u003d \"added to evictableMmapped, \";\n           } else {\n             insertEvictable(System.nanoTime(), replica, evictable);\n             addedString \u003d \"added to evictable, \";\n           }\n           shouldTrimEvictionMaps \u003d true;\n         }\n       } else {\n         Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n             \"replica\u0027s refCount went negative (refCount \u003d %d\" +\n             \" for %s)\", replica.refCount, replica);\n       }\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": unref replica \" + replica +\n             \": \" + addedString + \" refCount \" +\n             (newRefCount + 1) + \" -\u003e \" + newRefCount +\n             StringUtils.getStackTrace(Thread.currentThread()));\n       }\n       if (shouldTrimEvictionMaps) {\n         trimEvictionMaps();\n       }\n     } finally {\n       lock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void unref(ShortCircuitReplica replica) {\n    lock.lock();\n    try {\n      // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n      // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n      // that we could put a stale or unusable one into the cache.\n      if (!replica.purged) {\n        String purgeReason \u003d null;\n        if (!replica.getDataStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its data channel is closed.\";\n        } else if (!replica.getMetaStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its meta channel is closed.\";\n        } else if (replica.isStale()) {\n          purgeReason \u003d \"purging replica because it is stale.\";\n        }\n        if (purgeReason !\u003d null) {\n          LOG.debug(\"{}: {}\", this, purgeReason);\n          purge(replica);\n        }\n      }\n      String addedString \u003d \"\";\n      boolean shouldTrimEvictionMaps \u003d false;\n      int newRefCount \u003d --replica.refCount;\n      if (newRefCount \u003d\u003d 0) {\n        // Close replica, since there are no remaining references to it.\n        Preconditions.checkArgument(replica.purged,\n          \"Replica %s reached a refCount of 0 without being purged\", replica);\n        replica.close();\n      } else if (newRefCount \u003d\u003d 1) {\n        Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n            \"Replica %s had a refCount higher than 1, \" +\n              \"but was still evictable (evictableTimeNs \u003d %d)\",\n              replica, replica.getEvictableTimeNs());\n        if (!replica.purged) {\n          // Add the replica to the end of an eviction list.\n          // Eviction lists are sorted by time.\n          if (replica.hasMmap()) {\n            insertEvictable(System.nanoTime(), replica, evictableMmapped);\n            addedString \u003d \"added to evictableMmapped, \";\n          } else {\n            insertEvictable(System.nanoTime(), replica, evictable);\n            addedString \u003d \"added to evictable, \";\n          }\n          shouldTrimEvictionMaps \u003d true;\n        }\n      } else {\n        Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n            \"replica\u0027s refCount went negative (refCount \u003d %d\" +\n            \" for %s)\", replica.refCount, replica);\n      }\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": unref replica \" + replica +\n            \": \" + addedString + \" refCount \" +\n            (newRefCount + 1) + \" -\u003e \" + newRefCount +\n            StringUtils.getStackTrace(Thread.currentThread()));\n      }\n      if (shouldTrimEvictionMaps) {\n        trimEvictionMaps();\n      }\n    } finally {\n      lock.unlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/shortcircuit/ShortCircuitCache.java",
      "extendedDetails": {}
    },
    "c992bcf9c136d3df686655a80e636bb7bb0664da": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-8951. Move the shortcircuit package to hdfs-client. Contributed by Mingliang Liu.\n",
      "commitDate": "26/08/15 2:02 PM",
      "commitName": "c992bcf9c136d3df686655a80e636bb7bb0664da",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "25/08/15 2:29 PM",
      "commitNameOld": "a4d9acc51d1a977bc333da17780c00c72e8546f1",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 0.98,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  void unref(ShortCircuitReplica replica) {\n    lock.lock();\n    try {\n      // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n      // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n      // that we could put a stale or unusable one into the cache.\n      if (!replica.purged) {\n        String purgeReason \u003d null;\n        if (!replica.getDataStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its data channel is closed.\";\n        } else if (!replica.getMetaStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its meta channel is closed.\";\n        } else if (replica.isStale()) {\n          purgeReason \u003d \"purging replica because it is stale.\";\n        }\n        if (purgeReason !\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(this + \": \" + purgeReason);\n          }\n          purge(replica);\n        }\n      }\n      String addedString \u003d \"\";\n      boolean shouldTrimEvictionMaps \u003d false;\n      int newRefCount \u003d --replica.refCount;\n      if (newRefCount \u003d\u003d 0) {\n        // Close replica, since there are no remaining references to it.\n        Preconditions.checkArgument(replica.purged,\n          \"Replica %s reached a refCount of 0 without being purged\", replica);\n        replica.close();\n      } else if (newRefCount \u003d\u003d 1) {\n        Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n            \"Replica %s had a refCount higher than 1, \" +\n              \"but was still evictable (evictableTimeNs \u003d %d)\",\n              replica, replica.getEvictableTimeNs());\n        if (!replica.purged) {\n          // Add the replica to the end of an eviction list.\n          // Eviction lists are sorted by time.\n          if (replica.hasMmap()) {\n            insertEvictable(System.nanoTime(), replica, evictableMmapped);\n            addedString \u003d \"added to evictableMmapped, \";\n          } else {\n            insertEvictable(System.nanoTime(), replica, evictable);\n            addedString \u003d \"added to evictable, \";\n          }\n          shouldTrimEvictionMaps \u003d true;\n        }\n      } else {\n        Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n            \"replica\u0027s refCount went negative (refCount \u003d %d\" +\n            \" for %s)\", replica.refCount, replica);\n      }\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": unref replica \" + replica +\n            \": \" + addedString + \" refCount \" +\n            (newRefCount + 1) + \" -\u003e \" + newRefCount +\n            StringUtils.getStackTrace(Thread.currentThread()));\n      }\n      if (shouldTrimEvictionMaps) {\n        trimEvictionMaps();\n      }\n    } finally {\n      lock.unlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/shortcircuit/ShortCircuitCache.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/shortcircuit/ShortCircuitCache.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/shortcircuit/ShortCircuitCache.java"
      }
    },
    "ed72daa5df97669906234e8ac9a406d78136b206": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7978. Add LOG.isDebugEnabled() guard for some LOG.debug(..). Contributed by Walter Su.\n",
      "commitDate": "01/04/15 12:54 PM",
      "commitName": "ed72daa5df97669906234e8ac9a406d78136b206",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "02/12/14 8:57 PM",
      "commitNameOld": "7caa3bc98e6880f98c5c32c486a0c539f9fd3f5f",
      "commitAuthorOld": "stack",
      "daysBetweenCommits": 119.62,
      "commitsBetweenForRepo": 951,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,65 @@\n   void unref(ShortCircuitReplica replica) {\n     lock.lock();\n     try {\n       // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n       // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n       // that we could put a stale or unusable one into the cache.\n       if (!replica.purged) {\n         String purgeReason \u003d null;\n         if (!replica.getDataStream().getChannel().isOpen()) {\n           purgeReason \u003d \"purging replica because its data channel is closed.\";\n         } else if (!replica.getMetaStream().getChannel().isOpen()) {\n           purgeReason \u003d \"purging replica because its meta channel is closed.\";\n         } else if (replica.isStale()) {\n           purgeReason \u003d \"purging replica because it is stale.\";\n         }\n         if (purgeReason !\u003d null) {\n-          LOG.debug(this + \": \" + purgeReason);\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(this + \": \" + purgeReason);\n+          }\n           purge(replica);\n         }\n       }\n       String addedString \u003d \"\";\n       boolean shouldTrimEvictionMaps \u003d false;\n       int newRefCount \u003d --replica.refCount;\n       if (newRefCount \u003d\u003d 0) {\n         // Close replica, since there are no remaining references to it.\n         Preconditions.checkArgument(replica.purged,\n           \"Replica %s reached a refCount of 0 without being purged\", replica);\n         replica.close();\n       } else if (newRefCount \u003d\u003d 1) {\n         Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n             \"Replica %s had a refCount higher than 1, \" +\n               \"but was still evictable (evictableTimeNs \u003d %d)\",\n               replica, replica.getEvictableTimeNs());\n         if (!replica.purged) {\n           // Add the replica to the end of an eviction list.\n           // Eviction lists are sorted by time.\n           if (replica.hasMmap()) {\n             insertEvictable(System.nanoTime(), replica, evictableMmapped);\n             addedString \u003d \"added to evictableMmapped, \";\n           } else {\n             insertEvictable(System.nanoTime(), replica, evictable);\n             addedString \u003d \"added to evictable, \";\n           }\n           shouldTrimEvictionMaps \u003d true;\n         }\n       } else {\n         Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n             \"replica\u0027s refCount went negative (refCount \u003d %d\" +\n             \" for %s)\", replica.refCount, replica);\n       }\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": unref replica \" + replica +\n             \": \" + addedString + \" refCount \" +\n             (newRefCount + 1) + \" -\u003e \" + newRefCount +\n             StringUtils.getStackTrace(Thread.currentThread()));\n       }\n       if (shouldTrimEvictionMaps) {\n         trimEvictionMaps();\n       }\n     } finally {\n       lock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void unref(ShortCircuitReplica replica) {\n    lock.lock();\n    try {\n      // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n      // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n      // that we could put a stale or unusable one into the cache.\n      if (!replica.purged) {\n        String purgeReason \u003d null;\n        if (!replica.getDataStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its data channel is closed.\";\n        } else if (!replica.getMetaStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its meta channel is closed.\";\n        } else if (replica.isStale()) {\n          purgeReason \u003d \"purging replica because it is stale.\";\n        }\n        if (purgeReason !\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(this + \": \" + purgeReason);\n          }\n          purge(replica);\n        }\n      }\n      String addedString \u003d \"\";\n      boolean shouldTrimEvictionMaps \u003d false;\n      int newRefCount \u003d --replica.refCount;\n      if (newRefCount \u003d\u003d 0) {\n        // Close replica, since there are no remaining references to it.\n        Preconditions.checkArgument(replica.purged,\n          \"Replica %s reached a refCount of 0 without being purged\", replica);\n        replica.close();\n      } else if (newRefCount \u003d\u003d 1) {\n        Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n            \"Replica %s had a refCount higher than 1, \" +\n              \"but was still evictable (evictableTimeNs \u003d %d)\",\n              replica, replica.getEvictableTimeNs());\n        if (!replica.purged) {\n          // Add the replica to the end of an eviction list.\n          // Eviction lists are sorted by time.\n          if (replica.hasMmap()) {\n            insertEvictable(System.nanoTime(), replica, evictableMmapped);\n            addedString \u003d \"added to evictableMmapped, \";\n          } else {\n            insertEvictable(System.nanoTime(), replica, evictable);\n            addedString \u003d \"added to evictable, \";\n          }\n          shouldTrimEvictionMaps \u003d true;\n        }\n      } else {\n        Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n            \"replica\u0027s refCount went negative (refCount \u003d %d\" +\n            \" for %s)\", replica.refCount, replica);\n      }\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": unref replica \" + replica +\n            \": \" + addedString + \" refCount \" +\n            (newRefCount + 1) + \" -\u003e \" + newRefCount +\n            StringUtils.getStackTrace(Thread.currentThread()));\n      }\n      if (shouldTrimEvictionMaps) {\n        trimEvictionMaps();\n      }\n    } finally {\n      lock.unlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/shortcircuit/ShortCircuitCache.java",
      "extendedDetails": {}
    },
    "7caa3bc98e6880f98c5c32c486a0c539f9fd3f5f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6735. A minor optimization to avoid pread() be blocked by read() inside the same DFSInputStream (Lars Hofhansl via stack)\n",
      "commitDate": "02/12/14 8:57 PM",
      "commitName": "7caa3bc98e6880f98c5c32c486a0c539f9fd3f5f",
      "commitAuthor": "stack",
      "commitDateOld": "16/11/14 9:20 PM",
      "commitNameOld": "26d3b7e6ae867596bbced0bfddde22d3c0d976bb",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 15.98,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,63 @@\n   void unref(ShortCircuitReplica replica) {\n     lock.lock();\n     try {\n       // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n       // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n       // that we could put a stale or unusable one into the cache.\n       if (!replica.purged) {\n         String purgeReason \u003d null;\n         if (!replica.getDataStream().getChannel().isOpen()) {\n           purgeReason \u003d \"purging replica because its data channel is closed.\";\n         } else if (!replica.getMetaStream().getChannel().isOpen()) {\n           purgeReason \u003d \"purging replica because its meta channel is closed.\";\n         } else if (replica.isStale()) {\n           purgeReason \u003d \"purging replica because it is stale.\";\n         }\n         if (purgeReason !\u003d null) {\n           LOG.debug(this + \": \" + purgeReason);\n           purge(replica);\n         }\n       }\n       String addedString \u003d \"\";\n       boolean shouldTrimEvictionMaps \u003d false;\n       int newRefCount \u003d --replica.refCount;\n       if (newRefCount \u003d\u003d 0) {\n         // Close replica, since there are no remaining references to it.\n         Preconditions.checkArgument(replica.purged,\n-            \"Replica \" + replica + \" reached a refCount of 0 without \" +\n-            \"being purged\");\n+          \"Replica %s reached a refCount of 0 without being purged\", replica);\n         replica.close();\n       } else if (newRefCount \u003d\u003d 1) {\n         Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n-            \"Replica \" + replica + \" had a refCount higher than 1, \" +\n-              \"but was still evictable (evictableTimeNs \u003d \" +\n-                replica.getEvictableTimeNs() + \")\");\n+            \"Replica %s had a refCount higher than 1, \" +\n+              \"but was still evictable (evictableTimeNs \u003d %d)\",\n+              replica, replica.getEvictableTimeNs());\n         if (!replica.purged) {\n           // Add the replica to the end of an eviction list.\n           // Eviction lists are sorted by time.\n           if (replica.hasMmap()) {\n             insertEvictable(System.nanoTime(), replica, evictableMmapped);\n             addedString \u003d \"added to evictableMmapped, \";\n           } else {\n             insertEvictable(System.nanoTime(), replica, evictable);\n             addedString \u003d \"added to evictable, \";\n           }\n           shouldTrimEvictionMaps \u003d true;\n         }\n       } else {\n         Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n-            \"replica\u0027s refCount went negative (refCount \u003d \" +\n-            replica.refCount + \" for \" + replica + \")\");\n+            \"replica\u0027s refCount went negative (refCount \u003d %d\" +\n+            \" for %s)\", replica.refCount, replica);\n       }\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": unref replica \" + replica +\n             \": \" + addedString + \" refCount \" +\n             (newRefCount + 1) + \" -\u003e \" + newRefCount +\n             StringUtils.getStackTrace(Thread.currentThread()));\n       }\n       if (shouldTrimEvictionMaps) {\n         trimEvictionMaps();\n       }\n     } finally {\n       lock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void unref(ShortCircuitReplica replica) {\n    lock.lock();\n    try {\n      // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n      // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n      // that we could put a stale or unusable one into the cache.\n      if (!replica.purged) {\n        String purgeReason \u003d null;\n        if (!replica.getDataStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its data channel is closed.\";\n        } else if (!replica.getMetaStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its meta channel is closed.\";\n        } else if (replica.isStale()) {\n          purgeReason \u003d \"purging replica because it is stale.\";\n        }\n        if (purgeReason !\u003d null) {\n          LOG.debug(this + \": \" + purgeReason);\n          purge(replica);\n        }\n      }\n      String addedString \u003d \"\";\n      boolean shouldTrimEvictionMaps \u003d false;\n      int newRefCount \u003d --replica.refCount;\n      if (newRefCount \u003d\u003d 0) {\n        // Close replica, since there are no remaining references to it.\n        Preconditions.checkArgument(replica.purged,\n          \"Replica %s reached a refCount of 0 without being purged\", replica);\n        replica.close();\n      } else if (newRefCount \u003d\u003d 1) {\n        Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n            \"Replica %s had a refCount higher than 1, \" +\n              \"but was still evictable (evictableTimeNs \u003d %d)\",\n              replica, replica.getEvictableTimeNs());\n        if (!replica.purged) {\n          // Add the replica to the end of an eviction list.\n          // Eviction lists are sorted by time.\n          if (replica.hasMmap()) {\n            insertEvictable(System.nanoTime(), replica, evictableMmapped);\n            addedString \u003d \"added to evictableMmapped, \";\n          } else {\n            insertEvictable(System.nanoTime(), replica, evictable);\n            addedString \u003d \"added to evictable, \";\n          }\n          shouldTrimEvictionMaps \u003d true;\n        }\n      } else {\n        Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n            \"replica\u0027s refCount went negative (refCount \u003d %d\" +\n            \" for %s)\", replica.refCount, replica);\n      }\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": unref replica \" + replica +\n            \": \" + addedString + \" refCount \" +\n            (newRefCount + 1) + \" -\u003e \" + newRefCount +\n            StringUtils.getStackTrace(Thread.currentThread()));\n      }\n      if (shouldTrimEvictionMaps) {\n        trimEvictionMaps();\n      }\n    } finally {\n      lock.unlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/shortcircuit/ShortCircuitCache.java",
      "extendedDetails": {}
    },
    "8d9e8cec9fd10fbeafa4ff38217f3984538b187a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6227. ShortCircuitCache#unref should purge ShortCircuitReplicas whose streams have been closed by java interrupts. Contributed by Colin Patrick McCabe.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1597829 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/05/14 10:21 AM",
      "commitName": "8d9e8cec9fd10fbeafa4ff38217f3984538b187a",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "01/04/14 10:09 PM",
      "commitNameOld": "f93d99990a9a02ce693cd74466c2e5f127c1f560",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 55.51,
      "commitsBetweenForRepo": 311,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,64 @@\n   void unref(ShortCircuitReplica replica) {\n     lock.lock();\n     try {\n-      // If the replica is stale, but we haven\u0027t purged it yet, let\u0027s do that.\n-      // It would be a shame to evict a non-stale replica so that we could put\n-      // a stale one into the cache.\n-      if ((!replica.purged) \u0026\u0026 replica.isStale()) {\n-        purge(replica);\n+      // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n+      // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n+      // that we could put a stale or unusable one into the cache.\n+      if (!replica.purged) {\n+        String purgeReason \u003d null;\n+        if (!replica.getDataStream().getChannel().isOpen()) {\n+          purgeReason \u003d \"purging replica because its data channel is closed.\";\n+        } else if (!replica.getMetaStream().getChannel().isOpen()) {\n+          purgeReason \u003d \"purging replica because its meta channel is closed.\";\n+        } else if (replica.isStale()) {\n+          purgeReason \u003d \"purging replica because it is stale.\";\n+        }\n+        if (purgeReason !\u003d null) {\n+          LOG.debug(this + \": \" + purgeReason);\n+          purge(replica);\n+        }\n       }\n       String addedString \u003d \"\";\n       boolean shouldTrimEvictionMaps \u003d false;\n       int newRefCount \u003d --replica.refCount;\n       if (newRefCount \u003d\u003d 0) {\n         // Close replica, since there are no remaining references to it.\n         Preconditions.checkArgument(replica.purged,\n             \"Replica \" + replica + \" reached a refCount of 0 without \" +\n             \"being purged\");\n         replica.close();\n       } else if (newRefCount \u003d\u003d 1) {\n         Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n             \"Replica \" + replica + \" had a refCount higher than 1, \" +\n               \"but was still evictable (evictableTimeNs \u003d \" +\n                 replica.getEvictableTimeNs() + \")\");\n         if (!replica.purged) {\n           // Add the replica to the end of an eviction list.\n           // Eviction lists are sorted by time.\n           if (replica.hasMmap()) {\n             insertEvictable(System.nanoTime(), replica, evictableMmapped);\n             addedString \u003d \"added to evictableMmapped, \";\n           } else {\n             insertEvictable(System.nanoTime(), replica, evictable);\n             addedString \u003d \"added to evictable, \";\n           }\n           shouldTrimEvictionMaps \u003d true;\n         }\n       } else {\n         Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n             \"replica\u0027s refCount went negative (refCount \u003d \" +\n             replica.refCount + \" for \" + replica + \")\");\n       }\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": unref replica \" + replica +\n             \": \" + addedString + \" refCount \" +\n             (newRefCount + 1) + \" -\u003e \" + newRefCount +\n             StringUtils.getStackTrace(Thread.currentThread()));\n       }\n       if (shouldTrimEvictionMaps) {\n         trimEvictionMaps();\n       }\n     } finally {\n       lock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void unref(ShortCircuitReplica replica) {\n    lock.lock();\n    try {\n      // If the replica is stale or unusable, but we haven\u0027t purged it yet,\n      // let\u0027s do that.  It would be a shame to evict a non-stale replica so\n      // that we could put a stale or unusable one into the cache.\n      if (!replica.purged) {\n        String purgeReason \u003d null;\n        if (!replica.getDataStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its data channel is closed.\";\n        } else if (!replica.getMetaStream().getChannel().isOpen()) {\n          purgeReason \u003d \"purging replica because its meta channel is closed.\";\n        } else if (replica.isStale()) {\n          purgeReason \u003d \"purging replica because it is stale.\";\n        }\n        if (purgeReason !\u003d null) {\n          LOG.debug(this + \": \" + purgeReason);\n          purge(replica);\n        }\n      }\n      String addedString \u003d \"\";\n      boolean shouldTrimEvictionMaps \u003d false;\n      int newRefCount \u003d --replica.refCount;\n      if (newRefCount \u003d\u003d 0) {\n        // Close replica, since there are no remaining references to it.\n        Preconditions.checkArgument(replica.purged,\n            \"Replica \" + replica + \" reached a refCount of 0 without \" +\n            \"being purged\");\n        replica.close();\n      } else if (newRefCount \u003d\u003d 1) {\n        Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n            \"Replica \" + replica + \" had a refCount higher than 1, \" +\n              \"but was still evictable (evictableTimeNs \u003d \" +\n                replica.getEvictableTimeNs() + \")\");\n        if (!replica.purged) {\n          // Add the replica to the end of an eviction list.\n          // Eviction lists are sorted by time.\n          if (replica.hasMmap()) {\n            insertEvictable(System.nanoTime(), replica, evictableMmapped);\n            addedString \u003d \"added to evictableMmapped, \";\n          } else {\n            insertEvictable(System.nanoTime(), replica, evictable);\n            addedString \u003d \"added to evictable, \";\n          }\n          shouldTrimEvictionMaps \u003d true;\n        }\n      } else {\n        Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n            \"replica\u0027s refCount went negative (refCount \u003d \" +\n            replica.refCount + \" for \" + replica + \")\");\n      }\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": unref replica \" + replica +\n            \": \" + addedString + \" refCount \" +\n            (newRefCount + 1) + \" -\u003e \" + newRefCount +\n            StringUtils.getStackTrace(Thread.currentThread()));\n      }\n      if (shouldTrimEvictionMaps) {\n        trimEvictionMaps();\n      }\n    } finally {\n      lock.unlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/shortcircuit/ShortCircuitCache.java",
      "extendedDetails": {}
    },
    "f93d99990a9a02ce693cd74466c2e5f127c1f560": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-6167. Relocate the non-public API classes in the hdfs.client package.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1583878 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/04/14 10:09 PM",
      "commitName": "f93d99990a9a02ce693cd74466c2e5f127c1f560",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "01/04/14 6:00 PM",
      "commitNameOld": "5c7cb51775bd3d4a6e3e1bd501b3a8d747733fe3",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 0.17,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  void unref(ShortCircuitReplica replica) {\n    lock.lock();\n    try {\n      // If the replica is stale, but we haven\u0027t purged it yet, let\u0027s do that.\n      // It would be a shame to evict a non-stale replica so that we could put\n      // a stale one into the cache.\n      if ((!replica.purged) \u0026\u0026 replica.isStale()) {\n        purge(replica);\n      }\n      String addedString \u003d \"\";\n      boolean shouldTrimEvictionMaps \u003d false;\n      int newRefCount \u003d --replica.refCount;\n      if (newRefCount \u003d\u003d 0) {\n        // Close replica, since there are no remaining references to it.\n        Preconditions.checkArgument(replica.purged,\n            \"Replica \" + replica + \" reached a refCount of 0 without \" +\n            \"being purged\");\n        replica.close();\n      } else if (newRefCount \u003d\u003d 1) {\n        Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n            \"Replica \" + replica + \" had a refCount higher than 1, \" +\n              \"but was still evictable (evictableTimeNs \u003d \" +\n                replica.getEvictableTimeNs() + \")\");\n        if (!replica.purged) {\n          // Add the replica to the end of an eviction list.\n          // Eviction lists are sorted by time.\n          if (replica.hasMmap()) {\n            insertEvictable(System.nanoTime(), replica, evictableMmapped);\n            addedString \u003d \"added to evictableMmapped, \";\n          } else {\n            insertEvictable(System.nanoTime(), replica, evictable);\n            addedString \u003d \"added to evictable, \";\n          }\n          shouldTrimEvictionMaps \u003d true;\n        }\n      } else {\n        Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n            \"replica\u0027s refCount went negative (refCount \u003d \" +\n            replica.refCount + \" for \" + replica + \")\");\n      }\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": unref replica \" + replica +\n            \": \" + addedString + \" refCount \" +\n            (newRefCount + 1) + \" -\u003e \" + newRefCount +\n            StringUtils.getStackTrace(Thread.currentThread()));\n      }\n      if (shouldTrimEvictionMaps) {\n        trimEvictionMaps();\n      }\n    } finally {\n      lock.unlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/shortcircuit/ShortCircuitCache.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/client/ShortCircuitCache.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/shortcircuit/ShortCircuitCache.java"
      }
    },
    "dd049a2f6097da189ccce2f5890a2b9bc77fa73f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5950. The DFSClient and DataNode should use shared memory segments to communicate short-circuit information (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1573433 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/03/14 7:58 PM",
      "commitName": "dd049a2f6097da189ccce2f5890a2b9bc77fa73f",
      "commitAuthor": "Colin McCabe",
      "commitDateOld": "12/02/14 7:10 PM",
      "commitNameOld": "f0d64a078da7e932b9509734f75170e3e525e68c",
      "commitAuthorOld": "Colin McCabe",
      "daysBetweenCommits": 18.03,
      "commitsBetweenForRepo": 129,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,53 @@\n   void unref(ShortCircuitReplica replica) {\n     lock.lock();\n     try {\n+      // If the replica is stale, but we haven\u0027t purged it yet, let\u0027s do that.\n+      // It would be a shame to evict a non-stale replica so that we could put\n+      // a stale one into the cache.\n+      if ((!replica.purged) \u0026\u0026 replica.isStale()) {\n+        purge(replica);\n+      }\n       String addedString \u003d \"\";\n+      boolean shouldTrimEvictionMaps \u003d false;\n       int newRefCount \u003d --replica.refCount;\n       if (newRefCount \u003d\u003d 0) {\n         // Close replica, since there are no remaining references to it.\n         Preconditions.checkArgument(replica.purged,\n             \"Replica \" + replica + \" reached a refCount of 0 without \" +\n             \"being purged\");\n         replica.close();\n       } else if (newRefCount \u003d\u003d 1) {\n         Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n             \"Replica \" + replica + \" had a refCount higher than 1, \" +\n               \"but was still evictable (evictableTimeNs \u003d \" +\n                 replica.getEvictableTimeNs() + \")\");\n         if (!replica.purged) {\n           // Add the replica to the end of an eviction list.\n           // Eviction lists are sorted by time.\n           if (replica.hasMmap()) {\n             insertEvictable(System.nanoTime(), replica, evictableMmapped);\n             addedString \u003d \"added to evictableMmapped, \";\n           } else {\n             insertEvictable(System.nanoTime(), replica, evictable);\n             addedString \u003d \"added to evictable, \";\n           }\n-          trimEvictionMaps();\n+          shouldTrimEvictionMaps \u003d true;\n         }\n       } else {\n         Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n             \"replica\u0027s refCount went negative (refCount \u003d \" +\n             replica.refCount + \" for \" + replica + \")\");\n       }\n       if (LOG.isTraceEnabled()) {\n         LOG.trace(this + \": unref replica \" + replica +\n             \": \" + addedString + \" refCount \" +\n             (newRefCount + 1) + \" -\u003e \" + newRefCount +\n             StringUtils.getStackTrace(Thread.currentThread()));\n       }\n+      if (shouldTrimEvictionMaps) {\n+        trimEvictionMaps();\n+      }\n     } finally {\n       lock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void unref(ShortCircuitReplica replica) {\n    lock.lock();\n    try {\n      // If the replica is stale, but we haven\u0027t purged it yet, let\u0027s do that.\n      // It would be a shame to evict a non-stale replica so that we could put\n      // a stale one into the cache.\n      if ((!replica.purged) \u0026\u0026 replica.isStale()) {\n        purge(replica);\n      }\n      String addedString \u003d \"\";\n      boolean shouldTrimEvictionMaps \u003d false;\n      int newRefCount \u003d --replica.refCount;\n      if (newRefCount \u003d\u003d 0) {\n        // Close replica, since there are no remaining references to it.\n        Preconditions.checkArgument(replica.purged,\n            \"Replica \" + replica + \" reached a refCount of 0 without \" +\n            \"being purged\");\n        replica.close();\n      } else if (newRefCount \u003d\u003d 1) {\n        Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n            \"Replica \" + replica + \" had a refCount higher than 1, \" +\n              \"but was still evictable (evictableTimeNs \u003d \" +\n                replica.getEvictableTimeNs() + \")\");\n        if (!replica.purged) {\n          // Add the replica to the end of an eviction list.\n          // Eviction lists are sorted by time.\n          if (replica.hasMmap()) {\n            insertEvictable(System.nanoTime(), replica, evictableMmapped);\n            addedString \u003d \"added to evictableMmapped, \";\n          } else {\n            insertEvictable(System.nanoTime(), replica, evictable);\n            addedString \u003d \"added to evictable, \";\n          }\n          shouldTrimEvictionMaps \u003d true;\n        }\n      } else {\n        Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n            \"replica\u0027s refCount went negative (refCount \u003d \" +\n            replica.refCount + \" for \" + replica + \")\");\n      }\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": unref replica \" + replica +\n            \": \" + addedString + \" refCount \" +\n            (newRefCount + 1) + \" -\u003e \" + newRefCount +\n            StringUtils.getStackTrace(Thread.currentThread()));\n      }\n      if (shouldTrimEvictionMaps) {\n        trimEvictionMaps();\n      }\n    } finally {\n      lock.unlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/client/ShortCircuitCache.java",
      "extendedDetails": {}
    },
    "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-5810. Unify mmap cache and short-circuit file descriptor cache (cmccabe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1567720 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/02/14 11:08 AM",
      "commitName": "beb0d25d2a7ba5004c6aabd105546ba9a9fec9be",
      "commitAuthor": "Colin McCabe",
      "diff": "@@ -0,0 +1,43 @@\n+  void unref(ShortCircuitReplica replica) {\n+    lock.lock();\n+    try {\n+      String addedString \u003d \"\";\n+      int newRefCount \u003d --replica.refCount;\n+      if (newRefCount \u003d\u003d 0) {\n+        // Close replica, since there are no remaining references to it.\n+        Preconditions.checkArgument(replica.purged,\n+            \"Replica \" + replica + \" reached a refCount of 0 without \" +\n+            \"being purged\");\n+        replica.close();\n+      } else if (newRefCount \u003d\u003d 1) {\n+        Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n+            \"Replica \" + replica + \" had a refCount higher than 1, \" +\n+              \"but was still evictable (evictableTimeNs \u003d \" +\n+                replica.getEvictableTimeNs() + \")\");\n+        if (!replica.purged) {\n+          // Add the replica to the end of an eviction list.\n+          // Eviction lists are sorted by time.\n+          if (replica.hasMmap()) {\n+            insertEvictable(System.nanoTime(), replica, evictableMmapped);\n+            addedString \u003d \"added to evictableMmapped, \";\n+          } else {\n+            insertEvictable(System.nanoTime(), replica, evictable);\n+            addedString \u003d \"added to evictable, \";\n+          }\n+          trimEvictionMaps();\n+        }\n+      } else {\n+        Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n+            \"replica\u0027s refCount went negative (refCount \u003d \" +\n+            replica.refCount + \" for \" + replica + \")\");\n+      }\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(this + \": unref replica \" + replica +\n+            \": \" + addedString + \" refCount \" +\n+            (newRefCount + 1) + \" -\u003e \" + newRefCount +\n+            StringUtils.getStackTrace(Thread.currentThread()));\n+      }\n+    } finally {\n+      lock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void unref(ShortCircuitReplica replica) {\n    lock.lock();\n    try {\n      String addedString \u003d \"\";\n      int newRefCount \u003d --replica.refCount;\n      if (newRefCount \u003d\u003d 0) {\n        // Close replica, since there are no remaining references to it.\n        Preconditions.checkArgument(replica.purged,\n            \"Replica \" + replica + \" reached a refCount of 0 without \" +\n            \"being purged\");\n        replica.close();\n      } else if (newRefCount \u003d\u003d 1) {\n        Preconditions.checkState(null \u003d\u003d replica.getEvictableTimeNs(),\n            \"Replica \" + replica + \" had a refCount higher than 1, \" +\n              \"but was still evictable (evictableTimeNs \u003d \" +\n                replica.getEvictableTimeNs() + \")\");\n        if (!replica.purged) {\n          // Add the replica to the end of an eviction list.\n          // Eviction lists are sorted by time.\n          if (replica.hasMmap()) {\n            insertEvictable(System.nanoTime(), replica, evictableMmapped);\n            addedString \u003d \"added to evictableMmapped, \";\n          } else {\n            insertEvictable(System.nanoTime(), replica, evictable);\n            addedString \u003d \"added to evictable, \";\n          }\n          trimEvictionMaps();\n        }\n      } else {\n        Preconditions.checkArgument(replica.refCount \u003e\u003d 0,\n            \"replica\u0027s refCount went negative (refCount \u003d \" +\n            replica.refCount + \" for \" + replica + \")\");\n      }\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(this + \": unref replica \" + replica +\n            \": \" + addedString + \" refCount \" +\n            (newRefCount + 1) + \" -\u003e \" + newRefCount +\n            StringUtils.getStackTrace(Thread.currentThread()));\n      }\n    } finally {\n      lock.unlock();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/client/ShortCircuitCache.java"
    }
  }
}