{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacityScheduler.java",
  "functionName": "preValidateMoveApplication",
  "functionId": "preValidateMoveApplication___appId-ApplicationId__newQueue-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
  "functionStartLine": 2525,
  "functionEndLine": 2556,
  "numCommitsSeen": 239,
  "timeTaken": 5520,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "1eb81867032b016a59662043cbae50daa52dafa9",
    "563480dccd0136d82730f4228f1df44449ed5822"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "1eb81867032b016a59662043cbae50daa52dafa9": "Ybodychange",
    "563480dccd0136d82730f4228f1df44449ed5822": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "19/03/20 12:25 AM",
      "commitNameOld": "f2d3ac2a3f27a849e00f529c5c2df6ef0bd82911",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 6.16,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,32 @@\n   public void preValidateMoveApplication(ApplicationId appId,\n       String newQueue) throws YarnException {\n     writeLock.lock();\n     try {\n       SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d\n           applications.get(appId);\n       if (application \u003d\u003d null) {\n         throw new YarnException(\"App to be moved \" + appId + \" not found.\");\n       }\n-      String sourceQueueName \u003d application.getQueue().getQueueName();\n+      Queue queue \u003d application.getQueue();\n+      String sourceQueueName \u003d queue instanceof CSQueue ?\n+          ((CSQueue) queue).getQueuePath() : queue.getQueueName();\n       this.queueManager.getAndCheckLeafQueue(sourceQueueName);\n       String destQueueName \u003d handleMoveToPlanQueue(newQueue);\n       LeafQueue dest \u003d this.queueManager.getAndCheckLeafQueue(destQueueName);\n       // Validation check - ACLs, submission limits for user \u0026 queue\n       String user \u003d application.getUser();\n       // Check active partition only when attempt is available\n       FiCaSchedulerApp appAttempt \u003d\n           getApplicationAttempt(ApplicationAttemptId.newInstance(appId, 0));\n       if (null !\u003d appAttempt) {\n         checkQueuePartition(appAttempt, dest);\n       }\n       try {\n         dest.validateSubmitApplication(appId, user, destQueueName);\n       } catch (AccessControlException e) {\n         throw new YarnException(e);\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void preValidateMoveApplication(ApplicationId appId,\n      String newQueue) throws YarnException {\n    writeLock.lock();\n    try {\n      SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d\n          applications.get(appId);\n      if (application \u003d\u003d null) {\n        throw new YarnException(\"App to be moved \" + appId + \" not found.\");\n      }\n      Queue queue \u003d application.getQueue();\n      String sourceQueueName \u003d queue instanceof CSQueue ?\n          ((CSQueue) queue).getQueuePath() : queue.getQueueName();\n      this.queueManager.getAndCheckLeafQueue(sourceQueueName);\n      String destQueueName \u003d handleMoveToPlanQueue(newQueue);\n      LeafQueue dest \u003d this.queueManager.getAndCheckLeafQueue(destQueueName);\n      // Validation check - ACLs, submission limits for user \u0026 queue\n      String user \u003d application.getUser();\n      // Check active partition only when attempt is available\n      FiCaSchedulerApp appAttempt \u003d\n          getApplicationAttempt(ApplicationAttemptId.newInstance(appId, 0));\n      if (null !\u003d appAttempt) {\n        checkQueuePartition(appAttempt, dest);\n      }\n      try {\n        dest.validateSubmitApplication(appId, user, destQueueName);\n      } catch (AccessControlException e) {\n        throw new YarnException(e);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n   public void preValidateMoveApplication(ApplicationId appId,\n       String newQueue) throws YarnException {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d\n           applications.get(appId);\n       if (application \u003d\u003d null) {\n         throw new YarnException(\"App to be moved \" + appId + \" not found.\");\n       }\n       String sourceQueueName \u003d application.getQueue().getQueueName();\n       this.queueManager.getAndCheckLeafQueue(sourceQueueName);\n       String destQueueName \u003d handleMoveToPlanQueue(newQueue);\n       LeafQueue dest \u003d this.queueManager.getAndCheckLeafQueue(destQueueName);\n       // Validation check - ACLs, submission limits for user \u0026 queue\n       String user \u003d application.getUser();\n       // Check active partition only when attempt is available\n       FiCaSchedulerApp appAttempt \u003d\n           getApplicationAttempt(ApplicationAttemptId.newInstance(appId, 0));\n       if (null !\u003d appAttempt) {\n         checkQueuePartition(appAttempt, dest);\n       }\n       try {\n         dest.validateSubmitApplication(appId, user, destQueueName);\n       } catch (AccessControlException e) {\n         throw new YarnException(e);\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void preValidateMoveApplication(ApplicationId appId,\n      String newQueue) throws YarnException {\n    writeLock.lock();\n    try {\n      SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d\n          applications.get(appId);\n      if (application \u003d\u003d null) {\n        throw new YarnException(\"App to be moved \" + appId + \" not found.\");\n      }\n      String sourceQueueName \u003d application.getQueue().getQueueName();\n      this.queueManager.getAndCheckLeafQueue(sourceQueueName);\n      String destQueueName \u003d handleMoveToPlanQueue(newQueue);\n      LeafQueue dest \u003d this.queueManager.getAndCheckLeafQueue(destQueueName);\n      // Validation check - ACLs, submission limits for user \u0026 queue\n      String user \u003d application.getUser();\n      // Check active partition only when attempt is available\n      FiCaSchedulerApp appAttempt \u003d\n          getApplicationAttempt(ApplicationAttemptId.newInstance(appId, 0));\n      if (null !\u003d appAttempt) {\n        checkQueuePartition(appAttempt, dest);\n      }\n      try {\n        dest.validateSubmitApplication(appId, user, destQueueName);\n      } catch (AccessControlException e) {\n        throw new YarnException(e);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "1eb81867032b016a59662043cbae50daa52dafa9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6207. Move application across queues should handle delayed event processing. Contributed by Bibin A Chundatt.\n",
      "commitDate": "07/03/17 10:34 PM",
      "commitName": "1eb81867032b016a59662043cbae50daa52dafa9",
      "commitAuthor": "Sunil G",
      "commitDateOld": "28/02/17 10:35 AM",
      "commitNameOld": "eac6b4c35c50e555c2f1b5f913bb2c4d839f1ff4",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 7.5,
      "commitsBetweenForRepo": 51,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,30 @@\n   public void preValidateMoveApplication(ApplicationId appId,\n       String newQueue) throws YarnException {\n     try {\n       writeLock.lock();\n-      FiCaSchedulerApp app \u003d getApplicationAttempt(\n-          ApplicationAttemptId.newInstance(appId, 0));\n-      String sourceQueueName \u003d app.getQueue().getQueueName();\n+      SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d\n+          applications.get(appId);\n+      if (application \u003d\u003d null) {\n+        throw new YarnException(\"App to be moved \" + appId + \" not found.\");\n+      }\n+      String sourceQueueName \u003d application.getQueue().getQueueName();\n       this.queueManager.getAndCheckLeafQueue(sourceQueueName);\n       String destQueueName \u003d handleMoveToPlanQueue(newQueue);\n       LeafQueue dest \u003d this.queueManager.getAndCheckLeafQueue(destQueueName);\n       // Validation check - ACLs, submission limits for user \u0026 queue\n-      String user \u003d app.getUser();\n-      checkQueuePartition(app, dest);\n+      String user \u003d application.getUser();\n+      // Check active partition only when attempt is available\n+      FiCaSchedulerApp appAttempt \u003d\n+          getApplicationAttempt(ApplicationAttemptId.newInstance(appId, 0));\n+      if (null !\u003d appAttempt) {\n+        checkQueuePartition(appAttempt, dest);\n+      }\n       try {\n         dest.validateSubmitApplication(appId, user, destQueueName);\n       } catch (AccessControlException e) {\n         throw new YarnException(e);\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void preValidateMoveApplication(ApplicationId appId,\n      String newQueue) throws YarnException {\n    try {\n      writeLock.lock();\n      SchedulerApplication\u003cFiCaSchedulerApp\u003e application \u003d\n          applications.get(appId);\n      if (application \u003d\u003d null) {\n        throw new YarnException(\"App to be moved \" + appId + \" not found.\");\n      }\n      String sourceQueueName \u003d application.getQueue().getQueueName();\n      this.queueManager.getAndCheckLeafQueue(sourceQueueName);\n      String destQueueName \u003d handleMoveToPlanQueue(newQueue);\n      LeafQueue dest \u003d this.queueManager.getAndCheckLeafQueue(destQueueName);\n      // Validation check - ACLs, submission limits for user \u0026 queue\n      String user \u003d application.getUser();\n      // Check active partition only when attempt is available\n      FiCaSchedulerApp appAttempt \u003d\n          getApplicationAttempt(ApplicationAttemptId.newInstance(appId, 0));\n      if (null !\u003d appAttempt) {\n        checkQueuePartition(appAttempt, dest);\n      }\n      try {\n        dest.validateSubmitApplication(appId, user, destQueueName);\n      } catch (AccessControlException e) {\n        throw new YarnException(e);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "563480dccd0136d82730f4228f1df44449ed5822": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5932. Retrospect moveApplicationToQueue in align with YARN-5611. Contributed by Sunil G.\n",
      "commitDate": "06/12/16 9:09 PM",
      "commitName": "563480dccd0136d82730f4228f1df44449ed5822",
      "commitAuthor": "Rohith Sharma K S",
      "diff": "@@ -0,0 +1,22 @@\n+  public void preValidateMoveApplication(ApplicationId appId,\n+      String newQueue) throws YarnException {\n+    try {\n+      writeLock.lock();\n+      FiCaSchedulerApp app \u003d getApplicationAttempt(\n+          ApplicationAttemptId.newInstance(appId, 0));\n+      String sourceQueueName \u003d app.getQueue().getQueueName();\n+      this.queueManager.getAndCheckLeafQueue(sourceQueueName);\n+      String destQueueName \u003d handleMoveToPlanQueue(newQueue);\n+      LeafQueue dest \u003d this.queueManager.getAndCheckLeafQueue(destQueueName);\n+      // Validation check - ACLs, submission limits for user \u0026 queue\n+      String user \u003d app.getUser();\n+      checkQueuePartition(app, dest);\n+      try {\n+        dest.validateSubmitApplication(appId, user, destQueueName);\n+      } catch (AccessControlException e) {\n+        throw new YarnException(e);\n+      }\n+    } finally {\n+      writeLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void preValidateMoveApplication(ApplicationId appId,\n      String newQueue) throws YarnException {\n    try {\n      writeLock.lock();\n      FiCaSchedulerApp app \u003d getApplicationAttempt(\n          ApplicationAttemptId.newInstance(appId, 0));\n      String sourceQueueName \u003d app.getQueue().getQueueName();\n      this.queueManager.getAndCheckLeafQueue(sourceQueueName);\n      String destQueueName \u003d handleMoveToPlanQueue(newQueue);\n      LeafQueue dest \u003d this.queueManager.getAndCheckLeafQueue(destQueueName);\n      // Validation check - ACLs, submission limits for user \u0026 queue\n      String user \u003d app.getUser();\n      checkQueuePartition(app, dest);\n      try {\n        dest.validateSubmitApplication(appId, user, destQueueName);\n      } catch (AccessControlException e) {\n        throw new YarnException(e);\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}