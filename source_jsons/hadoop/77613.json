{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RetryInvocationHandler.java",
  "functionName": "handleException",
  "functionId": "handleException___method-Method(modifiers-final)__callId-int(modifiers-final)__policy-RetryPolicy(modifiers-final)__counters-Counters(modifiers-final)__expectFailoverCount-long(modifiers-final)__e-Exception(modifiers-final)",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
  "functionStartLine": 369,
  "functionEndLine": 389,
  "numCommitsSeen": 72,
  "timeTaken": 2844,
  "changeHistory": [
    "55796a0946f80a35055701a34379e374399009c5",
    "92d8f371553b88e5b3a9d3354e93f75d60d81368",
    "d328e667067743f723e332d92154da8e84e65742",
    "0bbb4ddd793063c87927035969884a34f60f2076",
    "a9a8297cad4122961b34265c0a31d87134a4a028"
  ],
  "changeHistoryShort": {
    "55796a0946f80a35055701a34379e374399009c5": "Ybodychange",
    "92d8f371553b88e5b3a9d3354e93f75d60d81368": "Ybodychange",
    "d328e667067743f723e332d92154da8e84e65742": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "0bbb4ddd793063c87927035969884a34f60f2076": "Ybodychange",
    "a9a8297cad4122961b34265c0a31d87134a4a028": "Yintroduced"
  },
  "changeHistoryDetails": {
    "55796a0946f80a35055701a34379e374399009c5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11395. RequestHedgingProxyProvider#RequestHedgingInvocationHandler hides the Exception thrown from NameNode. Contributed by Nandakumar.\n",
      "commitDate": "13/03/17 2:24 PM",
      "commitName": "55796a0946f80a35055701a34379e374399009c5",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "08/02/17 2:11 AM",
      "commitNameOld": "eec52e158b7bc14b2d3d53512323ba05e15e09e3",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 33.47,
      "commitsBetweenForRepo": 200,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,21 +1,21 @@\n   private RetryInfo handleException(final Method method, final int callId,\n       final RetryPolicy policy, final Counters counters,\n       final long expectFailoverCount, final Exception e) throws Exception {\n     final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, e,\n         counters, proxyDescriptor.idempotentOrAtMostOnce(method),\n         expectFailoverCount);\n     if (retryInfo.isFail()) {\n       // fail.\n       if (retryInfo.action.reason !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Exception while invoking call #\" + callId + \" \"\n               + proxyDescriptor.getProxyInfo().getString(method.getName())\n               + \". Not retrying because \" + retryInfo.action.reason, e);\n         }\n       }\n-      throw e;\n+      throw retryInfo.getFailException();\n     }\n \n     log(method, retryInfo.isFailover(), counters.failovers, retryInfo.delay, e);\n     return retryInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RetryInfo handleException(final Method method, final int callId,\n      final RetryPolicy policy, final Counters counters,\n      final long expectFailoverCount, final Exception e) throws Exception {\n    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, e,\n        counters, proxyDescriptor.idempotentOrAtMostOnce(method),\n        expectFailoverCount);\n    if (retryInfo.isFail()) {\n      // fail.\n      if (retryInfo.action.reason !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Exception while invoking call #\" + callId + \" \"\n              + proxyDescriptor.getProxyInfo().getString(method.getName())\n              + \". Not retrying because \" + retryInfo.action.reason, e);\n        }\n      }\n      throw retryInfo.getFailException();\n    }\n\n    log(method, retryInfo.isFailover(), counters.failovers, retryInfo.delay, e);\n    return retryInfo;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "92d8f371553b88e5b3a9d3354e93f75d60d81368": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13552. RetryInvocationHandler logs all remote exceptions. Contributed by Jason Lowe\n",
      "commitDate": "29/08/16 8:55 AM",
      "commitName": "92d8f371553b88e5b3a9d3354e93f75d60d81368",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "25/06/16 12:45 AM",
      "commitNameOld": "d328e667067743f723e332d92154da8e84e65742",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 65.34,
      "commitsBetweenForRepo": 526,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,21 @@\n   private RetryInfo handleException(final Method method, final int callId,\n       final RetryPolicy policy, final Counters counters,\n       final long expectFailoverCount, final Exception e) throws Exception {\n     final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, e,\n         counters, proxyDescriptor.idempotentOrAtMostOnce(method),\n         expectFailoverCount);\n     if (retryInfo.isFail()) {\n       // fail.\n       if (retryInfo.action.reason !\u003d null) {\n-        LOG.warn(\"Exception while invoking call #\" + callId + \" \"\n-            + proxyDescriptor.getProxyInfo().getString(method.getName())\n-            + \". Not retrying because \" + retryInfo.action.reason, e);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Exception while invoking call #\" + callId + \" \"\n+              + proxyDescriptor.getProxyInfo().getString(method.getName())\n+              + \". Not retrying because \" + retryInfo.action.reason, e);\n+        }\n       }\n       throw e;\n     }\n \n     log(method, retryInfo.isFailover(), counters.failovers, retryInfo.delay, e);\n     return retryInfo;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private RetryInfo handleException(final Method method, final int callId,\n      final RetryPolicy policy, final Counters counters,\n      final long expectFailoverCount, final Exception e) throws Exception {\n    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, e,\n        counters, proxyDescriptor.idempotentOrAtMostOnce(method),\n        expectFailoverCount);\n    if (retryInfo.isFail()) {\n      // fail.\n      if (retryInfo.action.reason !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Exception while invoking call #\" + callId + \" \"\n              + proxyDescriptor.getProxyInfo().getString(method.getName())\n              + \". Not retrying because \" + retryInfo.action.reason, e);\n        }\n      }\n      throw e;\n    }\n\n    log(method, retryInfo.isFailover(), counters.failovers, retryInfo.delay, e);\n    return retryInfo;\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "d328e667067743f723e332d92154da8e84e65742": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HADOOP-13227. AsyncCallHandler should use an event driven architecture to handle async calls.\n",
      "commitDate": "25/06/16 12:45 AM",
      "commitName": "d328e667067743f723e332d92154da8e84e65742",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-13227. AsyncCallHandler should use an event driven architecture to handle async calls.\n",
          "commitDate": "25/06/16 12:45 AM",
          "commitName": "d328e667067743f723e332d92154da8e84e65742",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "10/06/16 10:38 AM",
          "commitNameOld": "0bbb4ddd793063c87927035969884a34f60f2076",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 14.59,
          "commitsBetweenForRepo": 130,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,19 @@\n-  private void handleException(final Method method, final RetryPolicy policy,\n-      final long expectedFailoverCount, final Counters counters,\n-      final Exception ex) throws Exception {\n-    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, ex, counters,\n-        proxyDescriptor.idempotentOrAtMostOnce(method));\n-    counters.retries++;\n-\n-    if (retryInfo.fail !\u003d null) {\n+  private RetryInfo handleException(final Method method, final int callId,\n+      final RetryPolicy policy, final Counters counters,\n+      final long expectFailoverCount, final Exception e) throws Exception {\n+    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, e,\n+        counters, proxyDescriptor.idempotentOrAtMostOnce(method),\n+        expectFailoverCount);\n+    if (retryInfo.isFail()) {\n       // fail.\n-      if (retryInfo.fail.reason !\u003d null) {\n-        LOG.warn(\"Exception while invoking \"\n+      if (retryInfo.action.reason !\u003d null) {\n+        LOG.warn(\"Exception while invoking call #\" + callId + \" \"\n             + proxyDescriptor.getProxyInfo().getString(method.getName())\n-            + \". Not retrying because \" + retryInfo.fail.reason, ex);\n+            + \". Not retrying because \" + retryInfo.action.reason, e);\n       }\n-      throw ex;\n+      throw e;\n     }\n \n-    // retry\n-    final boolean isFailover \u003d retryInfo.failover !\u003d null;\n-\n-    log(method, isFailover, counters.failovers, retryInfo.delay, ex);\n-\n-    if (retryInfo.delay \u003e 0) {\n-      try {\n-        Thread.sleep(retryInfo.delay);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-        LOG.warn(\"Interrupted while waiting to retry\", e);\n-        InterruptedIOException intIOE \u003d new InterruptedIOException(\n-            \"Retry interrupted\");\n-        intIOE.initCause(e);\n-        throw intIOE;\n-      }\n-    }\n-\n-    if (isFailover) {\n-      proxyDescriptor.failover(expectedFailoverCount, method);\n-      counters.failovers++;\n-    }\n+    log(method, retryInfo.isFailover(), counters.failovers, retryInfo.delay, e);\n+    return retryInfo;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RetryInfo handleException(final Method method, final int callId,\n      final RetryPolicy policy, final Counters counters,\n      final long expectFailoverCount, final Exception e) throws Exception {\n    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, e,\n        counters, proxyDescriptor.idempotentOrAtMostOnce(method),\n        expectFailoverCount);\n    if (retryInfo.isFail()) {\n      // fail.\n      if (retryInfo.action.reason !\u003d null) {\n        LOG.warn(\"Exception while invoking call #\" + callId + \" \"\n            + proxyDescriptor.getProxyInfo().getString(method.getName())\n            + \". Not retrying because \" + retryInfo.action.reason, e);\n      }\n      throw e;\n    }\n\n    log(method, retryInfo.isFailover(), counters.failovers, retryInfo.delay, e);\n    return retryInfo;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
          "extendedDetails": {
            "oldValue": "[method-Method(modifiers-final), policy-RetryPolicy(modifiers-final), expectedFailoverCount-long(modifiers-final), counters-Counters(modifiers-final), ex-Exception(modifiers-final)]",
            "newValue": "[method-Method(modifiers-final), callId-int(modifiers-final), policy-RetryPolicy(modifiers-final), counters-Counters(modifiers-final), expectFailoverCount-long(modifiers-final), e-Exception(modifiers-final)]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HADOOP-13227. AsyncCallHandler should use an event driven architecture to handle async calls.\n",
          "commitDate": "25/06/16 12:45 AM",
          "commitName": "d328e667067743f723e332d92154da8e84e65742",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "10/06/16 10:38 AM",
          "commitNameOld": "0bbb4ddd793063c87927035969884a34f60f2076",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 14.59,
          "commitsBetweenForRepo": 130,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,19 @@\n-  private void handleException(final Method method, final RetryPolicy policy,\n-      final long expectedFailoverCount, final Counters counters,\n-      final Exception ex) throws Exception {\n-    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, ex, counters,\n-        proxyDescriptor.idempotentOrAtMostOnce(method));\n-    counters.retries++;\n-\n-    if (retryInfo.fail !\u003d null) {\n+  private RetryInfo handleException(final Method method, final int callId,\n+      final RetryPolicy policy, final Counters counters,\n+      final long expectFailoverCount, final Exception e) throws Exception {\n+    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, e,\n+        counters, proxyDescriptor.idempotentOrAtMostOnce(method),\n+        expectFailoverCount);\n+    if (retryInfo.isFail()) {\n       // fail.\n-      if (retryInfo.fail.reason !\u003d null) {\n-        LOG.warn(\"Exception while invoking \"\n+      if (retryInfo.action.reason !\u003d null) {\n+        LOG.warn(\"Exception while invoking call #\" + callId + \" \"\n             + proxyDescriptor.getProxyInfo().getString(method.getName())\n-            + \". Not retrying because \" + retryInfo.fail.reason, ex);\n+            + \". Not retrying because \" + retryInfo.action.reason, e);\n       }\n-      throw ex;\n+      throw e;\n     }\n \n-    // retry\n-    final boolean isFailover \u003d retryInfo.failover !\u003d null;\n-\n-    log(method, isFailover, counters.failovers, retryInfo.delay, ex);\n-\n-    if (retryInfo.delay \u003e 0) {\n-      try {\n-        Thread.sleep(retryInfo.delay);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-        LOG.warn(\"Interrupted while waiting to retry\", e);\n-        InterruptedIOException intIOE \u003d new InterruptedIOException(\n-            \"Retry interrupted\");\n-        intIOE.initCause(e);\n-        throw intIOE;\n-      }\n-    }\n-\n-    if (isFailover) {\n-      proxyDescriptor.failover(expectedFailoverCount, method);\n-      counters.failovers++;\n-    }\n+    log(method, retryInfo.isFailover(), counters.failovers, retryInfo.delay, e);\n+    return retryInfo;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RetryInfo handleException(final Method method, final int callId,\n      final RetryPolicy policy, final Counters counters,\n      final long expectFailoverCount, final Exception e) throws Exception {\n    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, e,\n        counters, proxyDescriptor.idempotentOrAtMostOnce(method),\n        expectFailoverCount);\n    if (retryInfo.isFail()) {\n      // fail.\n      if (retryInfo.action.reason !\u003d null) {\n        LOG.warn(\"Exception while invoking call #\" + callId + \" \"\n            + proxyDescriptor.getProxyInfo().getString(method.getName())\n            + \". Not retrying because \" + retryInfo.action.reason, e);\n      }\n      throw e;\n    }\n\n    log(method, retryInfo.isFailover(), counters.failovers, retryInfo.delay, e);\n    return retryInfo;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "RetryInfo"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-13227. AsyncCallHandler should use an event driven architecture to handle async calls.\n",
          "commitDate": "25/06/16 12:45 AM",
          "commitName": "d328e667067743f723e332d92154da8e84e65742",
          "commitAuthor": "Tsz-Wo Nicholas Sze",
          "commitDateOld": "10/06/16 10:38 AM",
          "commitNameOld": "0bbb4ddd793063c87927035969884a34f60f2076",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 14.59,
          "commitsBetweenForRepo": 130,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,19 @@\n-  private void handleException(final Method method, final RetryPolicy policy,\n-      final long expectedFailoverCount, final Counters counters,\n-      final Exception ex) throws Exception {\n-    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, ex, counters,\n-        proxyDescriptor.idempotentOrAtMostOnce(method));\n-    counters.retries++;\n-\n-    if (retryInfo.fail !\u003d null) {\n+  private RetryInfo handleException(final Method method, final int callId,\n+      final RetryPolicy policy, final Counters counters,\n+      final long expectFailoverCount, final Exception e) throws Exception {\n+    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, e,\n+        counters, proxyDescriptor.idempotentOrAtMostOnce(method),\n+        expectFailoverCount);\n+    if (retryInfo.isFail()) {\n       // fail.\n-      if (retryInfo.fail.reason !\u003d null) {\n-        LOG.warn(\"Exception while invoking \"\n+      if (retryInfo.action.reason !\u003d null) {\n+        LOG.warn(\"Exception while invoking call #\" + callId + \" \"\n             + proxyDescriptor.getProxyInfo().getString(method.getName())\n-            + \". Not retrying because \" + retryInfo.fail.reason, ex);\n+            + \". Not retrying because \" + retryInfo.action.reason, e);\n       }\n-      throw ex;\n+      throw e;\n     }\n \n-    // retry\n-    final boolean isFailover \u003d retryInfo.failover !\u003d null;\n-\n-    log(method, isFailover, counters.failovers, retryInfo.delay, ex);\n-\n-    if (retryInfo.delay \u003e 0) {\n-      try {\n-        Thread.sleep(retryInfo.delay);\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-        LOG.warn(\"Interrupted while waiting to retry\", e);\n-        InterruptedIOException intIOE \u003d new InterruptedIOException(\n-            \"Retry interrupted\");\n-        intIOE.initCause(e);\n-        throw intIOE;\n-      }\n-    }\n-\n-    if (isFailover) {\n-      proxyDescriptor.failover(expectedFailoverCount, method);\n-      counters.failovers++;\n-    }\n+    log(method, retryInfo.isFailover(), counters.failovers, retryInfo.delay, e);\n+    return retryInfo;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private RetryInfo handleException(final Method method, final int callId,\n      final RetryPolicy policy, final Counters counters,\n      final long expectFailoverCount, final Exception e) throws Exception {\n    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, e,\n        counters, proxyDescriptor.idempotentOrAtMostOnce(method),\n        expectFailoverCount);\n    if (retryInfo.isFail()) {\n      // fail.\n      if (retryInfo.action.reason !\u003d null) {\n        LOG.warn(\"Exception while invoking call #\" + callId + \" \"\n            + proxyDescriptor.getProxyInfo().getString(method.getName())\n            + \". Not retrying because \" + retryInfo.action.reason, e);\n      }\n      throw e;\n    }\n\n    log(method, retryInfo.isFailover(), counters.failovers, retryInfo.delay, e);\n    return retryInfo;\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
          "extendedDetails": {}
        }
      ]
    },
    "0bbb4ddd793063c87927035969884a34f60f2076": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13249. RetryInvocationHandler need wrap InterruptedException in IOException when call Thread.sleep. Contributed by Zhihai Xu.\n",
      "commitDate": "10/06/16 10:38 AM",
      "commitName": "0bbb4ddd793063c87927035969884a34f60f2076",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "06/06/16 1:31 AM",
      "commitNameOld": "35f255b03b1bb5c94063ec1818af1d253ceee991",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 4.38,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,40 @@\n   private void handleException(final Method method, final RetryPolicy policy,\n       final long expectedFailoverCount, final Counters counters,\n       final Exception ex) throws Exception {\n     final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, ex, counters,\n         proxyDescriptor.idempotentOrAtMostOnce(method));\n     counters.retries++;\n \n     if (retryInfo.fail !\u003d null) {\n       // fail.\n       if (retryInfo.fail.reason !\u003d null) {\n         LOG.warn(\"Exception while invoking \"\n             + proxyDescriptor.getProxyInfo().getString(method.getName())\n             + \". Not retrying because \" + retryInfo.fail.reason, ex);\n       }\n       throw ex;\n     }\n \n     // retry\n     final boolean isFailover \u003d retryInfo.failover !\u003d null;\n \n     log(method, isFailover, counters.failovers, retryInfo.delay, ex);\n \n     if (retryInfo.delay \u003e 0) {\n-      Thread.sleep(retryInfo.delay);\n+      try {\n+        Thread.sleep(retryInfo.delay);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        LOG.warn(\"Interrupted while waiting to retry\", e);\n+        InterruptedIOException intIOE \u003d new InterruptedIOException(\n+            \"Retry interrupted\");\n+        intIOE.initCause(e);\n+        throw intIOE;\n+      }\n     }\n \n     if (isFailover) {\n       proxyDescriptor.failover(expectedFailoverCount, method);\n       counters.failovers++;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleException(final Method method, final RetryPolicy policy,\n      final long expectedFailoverCount, final Counters counters,\n      final Exception ex) throws Exception {\n    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, ex, counters,\n        proxyDescriptor.idempotentOrAtMostOnce(method));\n    counters.retries++;\n\n    if (retryInfo.fail !\u003d null) {\n      // fail.\n      if (retryInfo.fail.reason !\u003d null) {\n        LOG.warn(\"Exception while invoking \"\n            + proxyDescriptor.getProxyInfo().getString(method.getName())\n            + \". Not retrying because \" + retryInfo.fail.reason, ex);\n      }\n      throw ex;\n    }\n\n    // retry\n    final boolean isFailover \u003d retryInfo.failover !\u003d null;\n\n    log(method, isFailover, counters.failovers, retryInfo.delay, ex);\n\n    if (retryInfo.delay \u003e 0) {\n      try {\n        Thread.sleep(retryInfo.delay);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        LOG.warn(\"Interrupted while waiting to retry\", e);\n        InterruptedIOException intIOE \u003d new InterruptedIOException(\n            \"Retry interrupted\");\n        intIOE.initCause(e);\n        throw intIOE;\n      }\n    }\n\n    if (isFailover) {\n      proxyDescriptor.failover(expectedFailoverCount, method);\n      counters.failovers++;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java",
      "extendedDetails": {}
    },
    "a9a8297cad4122961b34265c0a31d87134a4a028": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-13146. Refactor RetryInvocationHandler. Contributed by Tsz Wo Nicholas Sze.\n",
      "commitDate": "16/05/16 3:23 PM",
      "commitName": "a9a8297cad4122961b34265c0a31d87134a4a028",
      "commitAuthor": "Jing Zhao",
      "diff": "@@ -0,0 +1,31 @@\n+  private void handleException(final Method method, final RetryPolicy policy,\n+      final long expectedFailoverCount, final Counters counters,\n+      final Exception ex) throws Exception {\n+    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, ex, counters,\n+        proxyDescriptor.idempotentOrAtMostOnce(method));\n+    counters.retries++;\n+\n+    if (retryInfo.fail !\u003d null) {\n+      // fail.\n+      if (retryInfo.fail.reason !\u003d null) {\n+        LOG.warn(\"Exception while invoking \"\n+            + proxyDescriptor.getProxyInfo().getString(method.getName())\n+            + \". Not retrying because \" + retryInfo.fail.reason, ex);\n+      }\n+      throw ex;\n+    }\n+\n+    // retry\n+    final boolean isFailover \u003d retryInfo.failover !\u003d null;\n+\n+    log(method, isFailover, counters.failovers, retryInfo.delay, ex);\n+\n+    if (retryInfo.delay \u003e 0) {\n+      Thread.sleep(retryInfo.delay);\n+    }\n+\n+    if (isFailover) {\n+      proxyDescriptor.failover(expectedFailoverCount, method);\n+      counters.failovers++;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void handleException(final Method method, final RetryPolicy policy,\n      final long expectedFailoverCount, final Counters counters,\n      final Exception ex) throws Exception {\n    final RetryInfo retryInfo \u003d RetryInfo.newRetryInfo(policy, ex, counters,\n        proxyDescriptor.idempotentOrAtMostOnce(method));\n    counters.retries++;\n\n    if (retryInfo.fail !\u003d null) {\n      // fail.\n      if (retryInfo.fail.reason !\u003d null) {\n        LOG.warn(\"Exception while invoking \"\n            + proxyDescriptor.getProxyInfo().getString(method.getName())\n            + \". Not retrying because \" + retryInfo.fail.reason, ex);\n      }\n      throw ex;\n    }\n\n    // retry\n    final boolean isFailover \u003d retryInfo.failover !\u003d null;\n\n    log(method, isFailover, counters.failovers, retryInfo.delay, ex);\n\n    if (retryInfo.delay \u003e 0) {\n      Thread.sleep(retryInfo.delay);\n    }\n\n    if (isFailover) {\n      proxyDescriptor.failover(expectedFailoverCount, method);\n      counters.failovers++;\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/io/retry/RetryInvocationHandler.java"
    }
  }
}