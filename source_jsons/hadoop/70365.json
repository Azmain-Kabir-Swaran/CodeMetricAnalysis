{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NativeAzureFileSystem.java",
  "functionName": "delete",
  "functionId": "delete___f-Path__recursive-boolean__skipParentFolderLastModifiedTimeUpdate-boolean",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
  "functionStartLine": 2434,
  "functionEndLine": 2444,
  "numCommitsSeen": 107,
  "timeTaken": 7197,
  "changeHistory": [
    "a530e7ab3b3f5bd71143a91266b46787962ac532",
    "c6b4e656b76b68cc1d0dbcc15a5aa5ea23335b7b",
    "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4",
    "0cab57223e3f54be17a5f27cefdb6d1da1b073e5",
    "686823529be09bea2a6cecb3503ef722017475bc",
    "52d7d5aa1a303cf70519a61487641211f4267c6f",
    "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f",
    "15dd1f3381069c5fdc6690e3ab1907a133ba14bf",
    "2ed58c40e5dcbf5c5303c00e85096085b1055f85",
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9",
    "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
    "5f6edb30c2bb648d5564c951edc25645e17e6636",
    "460e98f7b3ec84f3c5afcb2aad4f4e7031d16e3a",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
    "0d91576ec31f63402f2db6107a04155368e2632d",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82"
  ],
  "changeHistoryShort": {
    "a530e7ab3b3f5bd71143a91266b46787962ac532": "Ybodychange",
    "c6b4e656b76b68cc1d0dbcc15a5aa5ea23335b7b": "Ybodychange",
    "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4": "Ybodychange",
    "0cab57223e3f54be17a5f27cefdb6d1da1b073e5": "Ymultichange(Yparameterchange,Ybodychange)",
    "686823529be09bea2a6cecb3503ef722017475bc": "Ybodychange",
    "52d7d5aa1a303cf70519a61487641211f4267c6f": "Ybodychange",
    "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f": "Ybodychange",
    "15dd1f3381069c5fdc6690e3ab1907a133ba14bf": "Ybodychange",
    "2ed58c40e5dcbf5c5303c00e85096085b1055f85": "Ybodychange",
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9": "Ybodychange",
    "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79": "Ybodychange",
    "5f6edb30c2bb648d5564c951edc25645e17e6636": "Ybodychange",
    "460e98f7b3ec84f3c5afcb2aad4f4e7031d16e3a": "Ybodychange",
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": "Ymultichange(Yparameterchange,Ybodychange)",
    "0d91576ec31f63402f2db6107a04155368e2632d": "Ybodychange",
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a530e7ab3b3f5bd71143a91266b46787962ac532": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14768. Honoring sticky bit during Deletion when authorization is enabled in WASB\nContributed by Varada Hemeswari\n",
      "commitDate": "28/09/17 11:52 AM",
      "commitName": "a530e7ab3b3f5bd71143a91266b46787962ac532",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "07/09/17 10:35 AM",
      "commitNameOld": "13eda5000304099d1145631f9be13ce8a00b600d",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 21.05,
      "commitsBetweenForRepo": 217,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,261 +1,11 @@\n   public boolean delete(Path f, boolean recursive,\n       boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n \n-    LOG.debug(\"Deleting file: {}\", f.toString());\n-\n-    Path absolutePath \u003d makeAbsolute(f);\n-    Path parentPath \u003d absolutePath.getParent();\n-\n-    performAuthCheck(parentPath, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n-\n-    String key \u003d pathToKey(absolutePath);\n-\n-    // Capture the metadata for the path.\n-    //\n-    FileMetadata metaFile \u003d null;\n-    try {\n-      metaFile \u003d store.retrieveMetadata(key);\n-    } catch (IOException e) {\n-\n-      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n-\n-      if (innerException instanceof StorageException\n-          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n-\n-        return false;\n-      }\n-      throw e;\n-    }\n-\n-    if (null \u003d\u003d metaFile) {\n-      // The path to be deleted does not exist.\n-      return false;\n-    }\n-\n-    // The path exists, determine if it is a folder containing objects,\n-    // an empty folder, or a simple file and take the appropriate actions.\n-    if (!metaFile.isDir()) {\n-      // The path specifies a file. We need to check the parent path\n-      // to make sure it\u0027s a proper materialized directory before we\n-      // delete the file. Otherwise we may get into a situation where\n-      // the file we were deleting was the last one in an implicit directory\n-      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n-      // corresponding directory blob a) and that would implicitly delete\n-      // the directory as well, which is not correct.\n-\n-      if (parentPath.getParent() !\u003d null) {// Not root\n-        String parentKey \u003d pathToKey(parentPath);\n-\n-        FileMetadata parentMetadata \u003d null;\n-        try {\n-          parentMetadata \u003d store.retrieveMetadata(parentKey);\n-        } catch (IOException e) {\n-\n-          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n-\n-          if (innerException instanceof StorageException) {\n-            // Invalid State.\n-            // A FileNotFoundException is not thrown here as the API returns false\n-            // if the file not present. But not retrieving metadata here is an\n-            // unrecoverable state and can only happen if there is a race condition\n-            // hence throwing a IOException\n-            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n-              throw new IOException(\"File \" + f + \" has a parent directory \"\n-                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n-            }\n-          }\n-          throw e;\n-        }\n-\n-        // Invalid State.\n-        // A FileNotFoundException is not thrown here as the API returns false\n-        // if the file not present. But not retrieving metadata here is an\n-        // unrecoverable state and can only happen if there is a race condition\n-        // hence throwing a IOException\n-        if (parentMetadata \u003d\u003d null) {\n-          throw new IOException(\"File \" + f + \" has a parent directory \"\n-              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n-        }\n-\n-        if (!parentMetadata.isDir()) {\n-          // Invalid state: the parent path is actually a file. Throw.\n-          throw new AzureException(\"File \" + f + \" has a parent directory \"\n-              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n-        }\n-\n-        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n-          LOG.debug(\"Found an implicit parent directory while trying to\"\n-              + \" delete the file {}. Creating the directory blob for\"\n-              + \" it in {}.\", f, parentKey);\n-\n-          store.storeEmptyFolder(parentKey,\n-              createPermissionStatus(FsPermission.getDefault()));\n-        } else {\n-          if (!skipParentFolderLastModifiedTimeUpdate) {\n-            updateParentFolderLastModifiedTime(key);\n-          }\n-        }\n-      }\n-\n-      try {\n-        if (store.delete(key)) {\n-          instrumentation.fileDeleted();\n-        } else {\n-          return false;\n-        }\n-      } catch(IOException e) {\n-\n-        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n-\n-        if (innerException instanceof StorageException\n-            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n-          return false;\n-        }\n-\n-       throw e;\n-      }\n+    if (this.azureAuthorization) {\n+      return deleteWithAuthEnabled(f, recursive,\n+        skipParentFolderLastModifiedTimeUpdate);\n     } else {\n-      // The path specifies a folder. Recursively delete all entries under the\n-      // folder.\n-      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n-      if (parentPath.getParent() !\u003d null) {\n-        String parentKey \u003d pathToKey(parentPath);\n-        FileMetadata parentMetadata \u003d null;\n-\n-        try {\n-          parentMetadata \u003d store.retrieveMetadata(parentKey);\n-        } catch (IOException e) {\n-\n-          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n-\n-          if (innerException instanceof StorageException) {\n-            // Invalid State.\n-            // A FileNotFoundException is not thrown here as the API returns false\n-            // if the file not present. But not retrieving metadata here is an\n-            // unrecoverable state and can only happen if there is a race condition\n-            // hence throwing a IOException\n-            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n-              throw new IOException(\"File \" + f + \" has a parent directory \"\n-                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n-            }\n-          }\n-          throw e;\n-        }\n-\n-        // Invalid State.\n-        // A FileNotFoundException is not thrown here as the API returns false\n-        // if the file not present. But not retrieving metadata here is an\n-        // unrecoverable state and can only happen if there is a race condition\n-        // hence throwing a IOException\n-        if (parentMetadata \u003d\u003d null) {\n-          throw new IOException(\"File \" + f + \" has a parent directory \"\n-              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n-        }\n-\n-        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n-          LOG.debug(\"Found an implicit parent directory while trying to\"\n-              + \" delete the directory {}. Creating the directory blob for\"\n-              + \" it in {}. \", f, parentKey);\n-\n-          store.storeEmptyFolder(parentKey,\n-              createPermissionStatus(FsPermission.getDefault()));\n-        }\n-      }\n-\n-      // List all the blobs in the current folder.\n-      String priorLastKey \u003d null;\n-\n-      // Start time for list operation\n-      long start \u003d Time.monotonicNow();\n-      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n-\n-      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n-      do {\n-        try {\n-          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n-            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n-          for(FileMetadata file : listing.getFiles()) {\n-            fileMetadataList.add(file);\n-          }\n-          priorLastKey \u003d listing.getPriorLastKey();\n-        } catch (IOException e) {\n-          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n-\n-          if (innerException instanceof StorageException\n-              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n-            return false;\n-          }\n-\n-          throw e;\n-        }\n-      } while (priorLastKey !\u003d null);\n-\n-      long end \u003d Time.monotonicNow();\n-      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n-\n-      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n-\n-      if (contents.length \u003e 0) {\n-        if (!recursive) {\n-          // The folder is non-empty and recursive delete was not specified.\n-          // Throw an exception indicating that a non-recursive delete was\n-          // specified for a non-empty folder.\n-          throw new IOException(\"Non-recursive delete of non-empty directory \"\n-              + f.toString());\n-        }\n-        else {\n-          // Check write-permissions on sub-tree including current folder\n-          // NOTE: Ideally the subtree needs read-write-execute access check.\n-          // But we will simplify it to write-access check.\n-          if (metaFile.isDir()) { // the absolute-path\n-            performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n-          }\n-          for (FileMetadata meta : contents) {\n-            if (meta.isDir()) {\n-              Path subTreeDir \u003d keyToPath(meta.getKey());\n-              performAuthCheck(subTreeDir, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n-            }\n-          }\n-        }\n-      }\n-\n-      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n-      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n-        @Override\n-        public boolean execute(FileMetadata file) throws IOException{\n-          if (!deleteFile(file.getKey(), file.isDir())) {\n-            LOG.warn(\"Attempt to delete non-existent {} {}\",\n-                file.isDir() ? \"directory\" : \"file\",\n-                file.getKey());\n-          }\n-          return true;\n-        }\n-      };\n-\n-      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n-          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n-\n-      if (!executor.executeParallel(contents, task)) {\n-        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n-        return false;\n-      }\n-\n-      // Delete the current directory\n-      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n-        LOG.error(\"Failed delete directory {}\", f.toString());\n-        return false;\n-      }\n-\n-      // Update parent directory last modified time\n-      Path parent \u003d absolutePath.getParent();\n-      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n-        if (!skipParentFolderLastModifiedTimeUpdate) {\n-          updateParentFolderLastModifiedTime(key);\n-        }\n-      }\n+      return deleteWithoutAuth(f, recursive,\n+        skipParentFolderLastModifiedTimeUpdate);\n     }\n-\n-    // File or directory was successfully deleted.\n-    LOG.debug(\"Delete Successful for : {}\", f.toString());\n-    return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n\n    if (this.azureAuthorization) {\n      return deleteWithAuthEnabled(f, recursive,\n        skipParentFolderLastModifiedTimeUpdate);\n    } else {\n      return deleteWithoutAuth(f, recursive,\n        skipParentFolderLastModifiedTimeUpdate);\n    }\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "c6b4e656b76b68cc1d0dbcc15a5aa5ea23335b7b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14769. WASB: delete recursive should not fail if a file is deleted.\nContributed by Thomas Marquardt\n",
      "commitDate": "18/08/17 6:13 AM",
      "commitName": "c6b4e656b76b68cc1d0dbcc15a5aa5ea23335b7b",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "19/07/17 12:13 AM",
      "commitNameOld": "2843c688bcc21c65eb3538ffb3caeaffe440eda8",
      "commitAuthorOld": "Jitendra Pandey",
      "daysBetweenCommits": 30.25,
      "commitsBetweenForRepo": 241,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,256 +1,261 @@\n   public boolean delete(Path f, boolean recursive,\n       boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n \n     LOG.debug(\"Deleting file: {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n     Path parentPath \u003d absolutePath.getParent();\n \n     performAuthCheck(parentPath, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n \n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d null;\n     try {\n       metaFile \u003d store.retrieveMetadata(key);\n     } catch (IOException e) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         return false;\n       }\n       throw e;\n     }\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n \n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n \n         FileMetadata parentMetadata \u003d null;\n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the file {}. Creating the directory blob for\"\n               + \" it in {}.\", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           if (!skipParentFolderLastModifiedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n \n       try {\n         if (store.delete(key)) {\n           instrumentation.fileDeleted();\n         } else {\n           return false;\n         }\n       } catch(IOException e) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n        throw e;\n       }\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d null;\n \n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the directory {}. Creating the directory blob for\"\n               + \" it in {}. \", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n \n       // Start time for list operation\n       long start \u003d Time.monotonicNow();\n       ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n \n       // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n       do {\n         try {\n           PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n             AZURE_UNBOUNDED_DEPTH, priorLastKey);\n           for(FileMetadata file : listing.getFiles()) {\n             fileMetadataList.add(file);\n           }\n           priorLastKey \u003d listing.getPriorLastKey();\n         } catch (IOException e) {\n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException\n               \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n             return false;\n           }\n \n           throw e;\n         }\n       } while (priorLastKey !\u003d null);\n \n       long end \u003d Time.monotonicNow();\n       LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n \n       final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n \n       if (contents.length \u003e 0) {\n         if (!recursive) {\n           // The folder is non-empty and recursive delete was not specified.\n           // Throw an exception indicating that a non-recursive delete was\n           // specified for a non-empty folder.\n           throw new IOException(\"Non-recursive delete of non-empty directory \"\n               + f.toString());\n         }\n         else {\n           // Check write-permissions on sub-tree including current folder\n           // NOTE: Ideally the subtree needs read-write-execute access check.\n           // But we will simplify it to write-access check.\n           if (metaFile.isDir()) { // the absolute-path\n             performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n           }\n           for (FileMetadata meta : contents) {\n             if (meta.isDir()) {\n               Path subTreeDir \u003d keyToPath(meta.getKey());\n               performAuthCheck(subTreeDir, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n             }\n           }\n         }\n       }\n \n       // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n       AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n         @Override\n         public boolean execute(FileMetadata file) throws IOException{\n-          return deleteFile(file.getKey(), file.isDir());\n+          if (!deleteFile(file.getKey(), file.isDir())) {\n+            LOG.warn(\"Attempt to delete non-existent {} {}\",\n+                file.isDir() ? \"directory\" : \"file\",\n+                file.getKey());\n+          }\n+          return true;\n         }\n       };\n \n       AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n           \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n \n       if (!executor.executeParallel(contents, task)) {\n         LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n         return false;\n       }\n \n       // Delete the current directory\n       if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n         LOG.error(\"Failed delete directory {}\", f.toString());\n         return false;\n       }\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         if (!skipParentFolderLastModifiedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n     }\n \n     // File or directory was successfully deleted.\n     LOG.debug(\"Delete Successful for : {}\", f.toString());\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    Path parentPath \u003d absolutePath.getParent();\n\n    performAuthCheck(parentPath, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifiedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        if (store.delete(key)) {\n          instrumentation.fileDeleted();\n        } else {\n          return false;\n        }\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n\n      // Start time for list operation\n      long start \u003d Time.monotonicNow();\n      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n\n      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n      do {\n        try {\n          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n          for(FileMetadata file : listing.getFiles()) {\n            fileMetadataList.add(file);\n          }\n          priorLastKey \u003d listing.getPriorLastKey();\n        } catch (IOException e) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n            return false;\n          }\n\n          throw e;\n        }\n      } while (priorLastKey !\u003d null);\n\n      long end \u003d Time.monotonicNow();\n      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n\n      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n\n      if (contents.length \u003e 0) {\n        if (!recursive) {\n          // The folder is non-empty and recursive delete was not specified.\n          // Throw an exception indicating that a non-recursive delete was\n          // specified for a non-empty folder.\n          throw new IOException(\"Non-recursive delete of non-empty directory \"\n              + f.toString());\n        }\n        else {\n          // Check write-permissions on sub-tree including current folder\n          // NOTE: Ideally the subtree needs read-write-execute access check.\n          // But we will simplify it to write-access check.\n          if (metaFile.isDir()) { // the absolute-path\n            performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n          }\n          for (FileMetadata meta : contents) {\n            if (meta.isDir()) {\n              Path subTreeDir \u003d keyToPath(meta.getKey());\n              performAuthCheck(subTreeDir, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n            }\n          }\n        }\n      }\n\n      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n        @Override\n        public boolean execute(FileMetadata file) throws IOException{\n          if (!deleteFile(file.getKey(), file.isDir())) {\n            LOG.warn(\"Attempt to delete non-existent {} {}\",\n                file.isDir() ? \"directory\" : \"file\",\n                file.getKey());\n          }\n          return true;\n        }\n      };\n\n      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n\n      if (!executor.executeParallel(contents, task)) {\n        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n        return false;\n      }\n\n      // Delete the current directory\n      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n        LOG.error(\"Failed delete directory {}\", f.toString());\n        return false;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifiedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f.toString());\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14416. Path starting with \u0027wasb:///\u0027 not resolved correctly while authorizing with WASB-Ranger. Contributed by Sivaguru Sankaridurg\n",
      "commitDate": "16/05/17 11:22 AM",
      "commitName": "b415c6fe743242acf1d1d3eb7ea7091d90d2c0d4",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "10/05/17 3:05 PM",
      "commitNameOld": "eed731496f63537350206274af09d2118b116a17",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 5.85,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,258 +1,256 @@\n   public boolean delete(Path f, boolean recursive,\n       boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n \n     LOG.debug(\"Deleting file: {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n     Path parentPath \u003d absolutePath.getParent();\n \n-    performAuthCheck(parentPath.toString(), WasbAuthorizationOperations.WRITE, \"delete\", absolutePath.toString());\n+    performAuthCheck(parentPath, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n \n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d null;\n     try {\n       metaFile \u003d store.retrieveMetadata(key);\n     } catch (IOException e) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         return false;\n       }\n       throw e;\n     }\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n \n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n \n         FileMetadata parentMetadata \u003d null;\n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the file {}. Creating the directory blob for\"\n               + \" it in {}.\", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           if (!skipParentFolderLastModifiedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n \n       try {\n         if (store.delete(key)) {\n           instrumentation.fileDeleted();\n         } else {\n           return false;\n         }\n       } catch(IOException e) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n        throw e;\n       }\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d null;\n \n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the directory {}. Creating the directory blob for\"\n               + \" it in {}. \", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n \n       // Start time for list operation\n       long start \u003d Time.monotonicNow();\n       ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n \n       // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n       do {\n         try {\n           PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n             AZURE_UNBOUNDED_DEPTH, priorLastKey);\n           for(FileMetadata file : listing.getFiles()) {\n             fileMetadataList.add(file);\n           }\n           priorLastKey \u003d listing.getPriorLastKey();\n         } catch (IOException e) {\n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException\n               \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n             return false;\n           }\n \n           throw e;\n         }\n       } while (priorLastKey !\u003d null);\n \n       long end \u003d Time.monotonicNow();\n       LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n \n       final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n \n       if (contents.length \u003e 0) {\n         if (!recursive) {\n           // The folder is non-empty and recursive delete was not specified.\n           // Throw an exception indicating that a non-recursive delete was\n           // specified for a non-empty folder.\n           throw new IOException(\"Non-recursive delete of non-empty directory \"\n               + f.toString());\n         }\n         else {\n           // Check write-permissions on sub-tree including current folder\n           // NOTE: Ideally the subtree needs read-write-execute access check.\n           // But we will simplify it to write-access check.\n           if (metaFile.isDir()) { // the absolute-path\n-            performAuthCheck(absolutePath.toString(), WasbAuthorizationOperations.WRITE, \"delete\",\n-                absolutePath.toString());\n+            performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n           }\n           for (FileMetadata meta : contents) {\n             if (meta.isDir()) {\n               Path subTreeDir \u003d keyToPath(meta.getKey());\n-              performAuthCheck(subTreeDir.toString(), WasbAuthorizationOperations.WRITE, \"delete\",\n-                  absolutePath.toString());\n+              performAuthCheck(subTreeDir, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n             }\n           }\n         }\n       }\n \n       // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n       AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n         @Override\n         public boolean execute(FileMetadata file) throws IOException{\n           return deleteFile(file.getKey(), file.isDir());\n         }\n       };\n \n       AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n           \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n \n       if (!executor.executeParallel(contents, task)) {\n         LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n         return false;\n       }\n \n       // Delete the current directory\n       if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n         LOG.error(\"Failed delete directory {}\", f.toString());\n         return false;\n       }\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         if (!skipParentFolderLastModifiedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n     }\n \n     // File or directory was successfully deleted.\n     LOG.debug(\"Delete Successful for : {}\", f.toString());\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    Path parentPath \u003d absolutePath.getParent();\n\n    performAuthCheck(parentPath, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifiedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        if (store.delete(key)) {\n          instrumentation.fileDeleted();\n        } else {\n          return false;\n        }\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n\n      // Start time for list operation\n      long start \u003d Time.monotonicNow();\n      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n\n      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n      do {\n        try {\n          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n          for(FileMetadata file : listing.getFiles()) {\n            fileMetadataList.add(file);\n          }\n          priorLastKey \u003d listing.getPriorLastKey();\n        } catch (IOException e) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n            return false;\n          }\n\n          throw e;\n        }\n      } while (priorLastKey !\u003d null);\n\n      long end \u003d Time.monotonicNow();\n      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n\n      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n\n      if (contents.length \u003e 0) {\n        if (!recursive) {\n          // The folder is non-empty and recursive delete was not specified.\n          // Throw an exception indicating that a non-recursive delete was\n          // specified for a non-empty folder.\n          throw new IOException(\"Non-recursive delete of non-empty directory \"\n              + f.toString());\n        }\n        else {\n          // Check write-permissions on sub-tree including current folder\n          // NOTE: Ideally the subtree needs read-write-execute access check.\n          // But we will simplify it to write-access check.\n          if (metaFile.isDir()) { // the absolute-path\n            performAuthCheck(absolutePath, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n          }\n          for (FileMetadata meta : contents) {\n            if (meta.isDir()) {\n              Path subTreeDir \u003d keyToPath(meta.getKey());\n              performAuthCheck(subTreeDir, WasbAuthorizationOperations.WRITE, \"delete\", absolutePath);\n            }\n          }\n        }\n      }\n\n      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n        @Override\n        public boolean execute(FileMetadata file) throws IOException{\n          return deleteFile(file.getKey(), file.isDir());\n        }\n      };\n\n      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n\n      if (!executor.executeParallel(contents, task)) {\n        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n        return false;\n      }\n\n      // Delete the current directory\n      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n        LOG.error(\"Failed delete directory {}\", f.toString());\n        return false;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifiedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f.toString());\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "0cab57223e3f54be17a5f27cefdb6d1da1b073e5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-14274. Azure: Simplify Ranger-WASB policy model. Contributed by Sivaguru Sankaridurg\n",
      "commitDate": "12/04/17 4:07 PM",
      "commitName": "0cab57223e3f54be17a5f27cefdb6d1da1b073e5",
      "commitAuthor": "Mingliang Liu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-14274. Azure: Simplify Ranger-WASB policy model. Contributed by Sivaguru Sankaridurg\n",
          "commitDate": "12/04/17 4:07 PM",
          "commitName": "0cab57223e3f54be17a5f27cefdb6d1da1b073e5",
          "commitAuthor": "Mingliang Liu",
          "commitDateOld": "04/04/17 11:10 AM",
          "commitNameOld": "56ab02eed9b61e1c80605104dfc4c87fc6abac96",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 8.21,
          "commitsBetweenForRepo": 67,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,241 +1,258 @@\n   public boolean delete(Path f, boolean recursive,\n-      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n+      boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n \n     LOG.debug(\"Deleting file: {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n+    Path parentPath \u003d absolutePath.getParent();\n \n-    performAuthCheck(absolutePath.toString(),\n-        WasbAuthorizationOperations.EXECUTE.toString(), \"delete\");\n+    performAuthCheck(parentPath.toString(), WasbAuthorizationOperations.WRITE, \"delete\", absolutePath.toString());\n \n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d null;\n     try {\n       metaFile \u003d store.retrieveMetadata(key);\n     } catch (IOException e) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         return false;\n       }\n       throw e;\n     }\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n-      Path parentPath \u003d absolutePath.getParent();\n+\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n \n         FileMetadata parentMetadata \u003d null;\n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the file {}. Creating the directory blob for\"\n               + \" it in {}.\", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n-          if (!skipParentFolderLastModifidedTimeUpdate) {\n+          if (!skipParentFolderLastModifiedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n \n       try {\n         if (store.delete(key)) {\n           instrumentation.fileDeleted();\n         } else {\n           return false;\n         }\n       } catch(IOException e) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n        throw e;\n       }\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n-      Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d null;\n \n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the directory {}. Creating the directory blob for\"\n               + \" it in {}. \", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n \n       // Start time for list operation\n       long start \u003d Time.monotonicNow();\n       ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n \n       // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n       do {\n         try {\n           PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n             AZURE_UNBOUNDED_DEPTH, priorLastKey);\n           for(FileMetadata file : listing.getFiles()) {\n             fileMetadataList.add(file);\n           }\n           priorLastKey \u003d listing.getPriorLastKey();\n         } catch (IOException e) {\n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException\n               \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n             return false;\n           }\n \n           throw e;\n         }\n       } while (priorLastKey !\u003d null);\n \n       long end \u003d Time.monotonicNow();\n       LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n \n       final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n \n-      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n+      if (contents.length \u003e 0) {\n+        if (!recursive) {\n           // The folder is non-empty and recursive delete was not specified.\n           // Throw an exception indicating that a non-recursive delete was\n           // specified for a non-empty folder.\n           throw new IOException(\"Non-recursive delete of non-empty directory \"\n               + f.toString());\n+        }\n+        else {\n+          // Check write-permissions on sub-tree including current folder\n+          // NOTE: Ideally the subtree needs read-write-execute access check.\n+          // But we will simplify it to write-access check.\n+          if (metaFile.isDir()) { // the absolute-path\n+            performAuthCheck(absolutePath.toString(), WasbAuthorizationOperations.WRITE, \"delete\",\n+                absolutePath.toString());\n+          }\n+          for (FileMetadata meta : contents) {\n+            if (meta.isDir()) {\n+              Path subTreeDir \u003d keyToPath(meta.getKey());\n+              performAuthCheck(subTreeDir.toString(), WasbAuthorizationOperations.WRITE, \"delete\",\n+                  absolutePath.toString());\n+            }\n+          }\n+        }\n       }\n \n       // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n       AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n         @Override\n         public boolean execute(FileMetadata file) throws IOException{\n           return deleteFile(file.getKey(), file.isDir());\n         }\n       };\n \n       AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n           \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n \n       if (!executor.executeParallel(contents, task)) {\n         LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n         return false;\n       }\n \n       // Delete the current directory\n       if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n         LOG.error(\"Failed delete directory {}\", f.toString());\n         return false;\n       }\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n-        if (!skipParentFolderLastModifidedTimeUpdate) {\n+        if (!skipParentFolderLastModifiedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n     }\n \n     // File or directory was successfully deleted.\n     LOG.debug(\"Delete Successful for : {}\", f.toString());\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    Path parentPath \u003d absolutePath.getParent();\n\n    performAuthCheck(parentPath.toString(), WasbAuthorizationOperations.WRITE, \"delete\", absolutePath.toString());\n\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifiedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        if (store.delete(key)) {\n          instrumentation.fileDeleted();\n        } else {\n          return false;\n        }\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n\n      // Start time for list operation\n      long start \u003d Time.monotonicNow();\n      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n\n      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n      do {\n        try {\n          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n          for(FileMetadata file : listing.getFiles()) {\n            fileMetadataList.add(file);\n          }\n          priorLastKey \u003d listing.getPriorLastKey();\n        } catch (IOException e) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n            return false;\n          }\n\n          throw e;\n        }\n      } while (priorLastKey !\u003d null);\n\n      long end \u003d Time.monotonicNow();\n      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n\n      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n\n      if (contents.length \u003e 0) {\n        if (!recursive) {\n          // The folder is non-empty and recursive delete was not specified.\n          // Throw an exception indicating that a non-recursive delete was\n          // specified for a non-empty folder.\n          throw new IOException(\"Non-recursive delete of non-empty directory \"\n              + f.toString());\n        }\n        else {\n          // Check write-permissions on sub-tree including current folder\n          // NOTE: Ideally the subtree needs read-write-execute access check.\n          // But we will simplify it to write-access check.\n          if (metaFile.isDir()) { // the absolute-path\n            performAuthCheck(absolutePath.toString(), WasbAuthorizationOperations.WRITE, \"delete\",\n                absolutePath.toString());\n          }\n          for (FileMetadata meta : contents) {\n            if (meta.isDir()) {\n              Path subTreeDir \u003d keyToPath(meta.getKey());\n              performAuthCheck(subTreeDir.toString(), WasbAuthorizationOperations.WRITE, \"delete\",\n                  absolutePath.toString());\n            }\n          }\n        }\n      }\n\n      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n        @Override\n        public boolean execute(FileMetadata file) throws IOException{\n          return deleteFile(file.getKey(), file.isDir());\n        }\n      };\n\n      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n\n      if (!executor.executeParallel(contents, task)) {\n        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n        return false;\n      }\n\n      // Delete the current directory\n      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n        LOG.error(\"Failed delete directory {}\", f.toString());\n        return false;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifiedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f.toString());\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
          "extendedDetails": {
            "oldValue": "[f-Path, recursive-boolean, skipParentFolderLastModifidedTimeUpdate-boolean]",
            "newValue": "[f-Path, recursive-boolean, skipParentFolderLastModifiedTimeUpdate-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14274. Azure: Simplify Ranger-WASB policy model. Contributed by Sivaguru Sankaridurg\n",
          "commitDate": "12/04/17 4:07 PM",
          "commitName": "0cab57223e3f54be17a5f27cefdb6d1da1b073e5",
          "commitAuthor": "Mingliang Liu",
          "commitDateOld": "04/04/17 11:10 AM",
          "commitNameOld": "56ab02eed9b61e1c80605104dfc4c87fc6abac96",
          "commitAuthorOld": "Mingliang Liu",
          "daysBetweenCommits": 8.21,
          "commitsBetweenForRepo": 67,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,241 +1,258 @@\n   public boolean delete(Path f, boolean recursive,\n-      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n+      boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n \n     LOG.debug(\"Deleting file: {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n+    Path parentPath \u003d absolutePath.getParent();\n \n-    performAuthCheck(absolutePath.toString(),\n-        WasbAuthorizationOperations.EXECUTE.toString(), \"delete\");\n+    performAuthCheck(parentPath.toString(), WasbAuthorizationOperations.WRITE, \"delete\", absolutePath.toString());\n \n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d null;\n     try {\n       metaFile \u003d store.retrieveMetadata(key);\n     } catch (IOException e) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         return false;\n       }\n       throw e;\n     }\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n-      Path parentPath \u003d absolutePath.getParent();\n+\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n \n         FileMetadata parentMetadata \u003d null;\n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the file {}. Creating the directory blob for\"\n               + \" it in {}.\", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n-          if (!skipParentFolderLastModifidedTimeUpdate) {\n+          if (!skipParentFolderLastModifiedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n \n       try {\n         if (store.delete(key)) {\n           instrumentation.fileDeleted();\n         } else {\n           return false;\n         }\n       } catch(IOException e) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n        throw e;\n       }\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n-      Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d null;\n \n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the directory {}. Creating the directory blob for\"\n               + \" it in {}. \", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n \n       // Start time for list operation\n       long start \u003d Time.monotonicNow();\n       ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n \n       // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n       do {\n         try {\n           PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n             AZURE_UNBOUNDED_DEPTH, priorLastKey);\n           for(FileMetadata file : listing.getFiles()) {\n             fileMetadataList.add(file);\n           }\n           priorLastKey \u003d listing.getPriorLastKey();\n         } catch (IOException e) {\n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException\n               \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n             return false;\n           }\n \n           throw e;\n         }\n       } while (priorLastKey !\u003d null);\n \n       long end \u003d Time.monotonicNow();\n       LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n \n       final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n \n-      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n+      if (contents.length \u003e 0) {\n+        if (!recursive) {\n           // The folder is non-empty and recursive delete was not specified.\n           // Throw an exception indicating that a non-recursive delete was\n           // specified for a non-empty folder.\n           throw new IOException(\"Non-recursive delete of non-empty directory \"\n               + f.toString());\n+        }\n+        else {\n+          // Check write-permissions on sub-tree including current folder\n+          // NOTE: Ideally the subtree needs read-write-execute access check.\n+          // But we will simplify it to write-access check.\n+          if (metaFile.isDir()) { // the absolute-path\n+            performAuthCheck(absolutePath.toString(), WasbAuthorizationOperations.WRITE, \"delete\",\n+                absolutePath.toString());\n+          }\n+          for (FileMetadata meta : contents) {\n+            if (meta.isDir()) {\n+              Path subTreeDir \u003d keyToPath(meta.getKey());\n+              performAuthCheck(subTreeDir.toString(), WasbAuthorizationOperations.WRITE, \"delete\",\n+                  absolutePath.toString());\n+            }\n+          }\n+        }\n       }\n \n       // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n       AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n         @Override\n         public boolean execute(FileMetadata file) throws IOException{\n           return deleteFile(file.getKey(), file.isDir());\n         }\n       };\n \n       AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n           \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n \n       if (!executor.executeParallel(contents, task)) {\n         LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n         return false;\n       }\n \n       // Delete the current directory\n       if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n         LOG.error(\"Failed delete directory {}\", f.toString());\n         return false;\n       }\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n-        if (!skipParentFolderLastModifidedTimeUpdate) {\n+        if (!skipParentFolderLastModifiedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n     }\n \n     // File or directory was successfully deleted.\n     LOG.debug(\"Delete Successful for : {}\", f.toString());\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifiedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    Path parentPath \u003d absolutePath.getParent();\n\n    performAuthCheck(parentPath.toString(), WasbAuthorizationOperations.WRITE, \"delete\", absolutePath.toString());\n\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifiedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        if (store.delete(key)) {\n          instrumentation.fileDeleted();\n        } else {\n          return false;\n        }\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n\n      // Start time for list operation\n      long start \u003d Time.monotonicNow();\n      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n\n      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n      do {\n        try {\n          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n          for(FileMetadata file : listing.getFiles()) {\n            fileMetadataList.add(file);\n          }\n          priorLastKey \u003d listing.getPriorLastKey();\n        } catch (IOException e) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n            return false;\n          }\n\n          throw e;\n        }\n      } while (priorLastKey !\u003d null);\n\n      long end \u003d Time.monotonicNow();\n      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n\n      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n\n      if (contents.length \u003e 0) {\n        if (!recursive) {\n          // The folder is non-empty and recursive delete was not specified.\n          // Throw an exception indicating that a non-recursive delete was\n          // specified for a non-empty folder.\n          throw new IOException(\"Non-recursive delete of non-empty directory \"\n              + f.toString());\n        }\n        else {\n          // Check write-permissions on sub-tree including current folder\n          // NOTE: Ideally the subtree needs read-write-execute access check.\n          // But we will simplify it to write-access check.\n          if (metaFile.isDir()) { // the absolute-path\n            performAuthCheck(absolutePath.toString(), WasbAuthorizationOperations.WRITE, \"delete\",\n                absolutePath.toString());\n          }\n          for (FileMetadata meta : contents) {\n            if (meta.isDir()) {\n              Path subTreeDir \u003d keyToPath(meta.getKey());\n              performAuthCheck(subTreeDir.toString(), WasbAuthorizationOperations.WRITE, \"delete\",\n                  absolutePath.toString());\n            }\n          }\n        }\n      }\n\n      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n        @Override\n        public boolean execute(FileMetadata file) throws IOException{\n          return deleteFile(file.getKey(), file.isDir());\n        }\n      };\n\n      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n\n      if (!executor.executeParallel(contents, task)) {\n        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n        return false;\n      }\n\n      // Delete the current directory\n      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n        LOG.error(\"Failed delete directory {}\", f.toString());\n        return false;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifiedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f.toString());\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "686823529be09bea2a6cecb3503ef722017475bc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13930. Azure: Add Authorization support to WASB. Contributed by Sivaguru Sankaridurg and Dushyanth\n",
      "commitDate": "06/03/17 5:16 PM",
      "commitName": "686823529be09bea2a6cecb3503ef722017475bc",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "06/03/17 5:10 PM",
      "commitNameOld": "52d7d5aa1a303cf70519a61487641211f4267c6f",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,237 +1,241 @@\n   public boolean delete(Path f, boolean recursive,\n       boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n \n     LOG.debug(\"Deleting file: {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n+\n+    performAuthCheck(absolutePath.toString(),\n+        WasbAuthorizationOperations.EXECUTE.toString(), \"delete\");\n+\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d null;\n     try {\n       metaFile \u003d store.retrieveMetadata(key);\n     } catch (IOException e) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         return false;\n       }\n       throw e;\n     }\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n \n         FileMetadata parentMetadata \u003d null;\n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the file {}. Creating the directory blob for\"\n               + \" it in {}.\", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           if (!skipParentFolderLastModifidedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n \n       try {\n         if (store.delete(key)) {\n           instrumentation.fileDeleted();\n         } else {\n           return false;\n         }\n       } catch(IOException e) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n        throw e;\n       }\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d null;\n \n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the directory {}. Creating the directory blob for\"\n               + \" it in {}. \", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n \n       // Start time for list operation\n       long start \u003d Time.monotonicNow();\n       ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n \n       // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n       do {\n         try {\n           PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n             AZURE_UNBOUNDED_DEPTH, priorLastKey);\n           for(FileMetadata file : listing.getFiles()) {\n             fileMetadataList.add(file);\n           }\n           priorLastKey \u003d listing.getPriorLastKey();\n         } catch (IOException e) {\n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException\n               \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n             return false;\n           }\n \n           throw e;\n         }\n       } while (priorLastKey !\u003d null);\n \n       long end \u003d Time.monotonicNow();\n       LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n \n       final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n \n       if (!recursive \u0026\u0026 contents.length \u003e 0) {\n           // The folder is non-empty and recursive delete was not specified.\n           // Throw an exception indicating that a non-recursive delete was\n           // specified for a non-empty folder.\n           throw new IOException(\"Non-recursive delete of non-empty directory \"\n               + f.toString());\n       }\n \n       // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n       AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n         @Override\n         public boolean execute(FileMetadata file) throws IOException{\n           return deleteFile(file.getKey(), file.isDir());\n         }\n       };\n \n       AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n           \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n \n       if (!executor.executeParallel(contents, task)) {\n         LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n         return false;\n       }\n \n       // Delete the current directory\n       if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n         LOG.error(\"Failed delete directory {}\", f.toString());\n         return false;\n       }\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         if (!skipParentFolderLastModifidedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n     }\n \n     // File or directory was successfully deleted.\n     LOG.debug(\"Delete Successful for : {}\", f.toString());\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n\n    performAuthCheck(absolutePath.toString(),\n        WasbAuthorizationOperations.EXECUTE.toString(), \"delete\");\n\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifidedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        if (store.delete(key)) {\n          instrumentation.fileDeleted();\n        } else {\n          return false;\n        }\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n\n      // Start time for list operation\n      long start \u003d Time.monotonicNow();\n      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n\n      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n      do {\n        try {\n          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n          for(FileMetadata file : listing.getFiles()) {\n            fileMetadataList.add(file);\n          }\n          priorLastKey \u003d listing.getPriorLastKey();\n        } catch (IOException e) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n            return false;\n          }\n\n          throw e;\n        }\n      } while (priorLastKey !\u003d null);\n\n      long end \u003d Time.monotonicNow();\n      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n\n      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n          // The folder is non-empty and recursive delete was not specified.\n          // Throw an exception indicating that a non-recursive delete was\n          // specified for a non-empty folder.\n          throw new IOException(\"Non-recursive delete of non-empty directory \"\n              + f.toString());\n      }\n\n      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n        @Override\n        public boolean execute(FileMetadata file) throws IOException{\n          return deleteFile(file.getKey(), file.isDir());\n        }\n      };\n\n      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n\n      if (!executor.executeParallel(contents, task)) {\n        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n        return false;\n      }\n\n      // Delete the current directory\n      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n        LOG.error(\"Failed delete directory {}\", f.toString());\n        return false;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifidedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f.toString());\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "52d7d5aa1a303cf70519a61487641211f4267c6f": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13930. Azure: Add Authorization support to WASB. Contributed by Sivaguru Sankaridurg and Dushyanth\"\n\nThis reverts commit 6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f.\n",
      "commitDate": "06/03/17 5:10 PM",
      "commitName": "52d7d5aa1a303cf70519a61487641211f4267c6f",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "06/03/17 5:00 PM",
      "commitNameOld": "c571cda5c7d929477961dfff4176d7de4944d874",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,241 +1,237 @@\n   public boolean delete(Path f, boolean recursive,\n       boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n \n     LOG.debug(\"Deleting file: {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n-\n-    performAuthCheck(absolutePath.toString(),\n-        WasbAuthorizationOperations.EXECUTE.toString(), \"delete\");\n-\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d null;\n     try {\n       metaFile \u003d store.retrieveMetadata(key);\n     } catch (IOException e) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         return false;\n       }\n       throw e;\n     }\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n \n         FileMetadata parentMetadata \u003d null;\n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the file {}. Creating the directory blob for\"\n               + \" it in {}.\", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           if (!skipParentFolderLastModifidedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n \n       try {\n         if (store.delete(key)) {\n           instrumentation.fileDeleted();\n         } else {\n           return false;\n         }\n       } catch(IOException e) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n        throw e;\n       }\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d null;\n \n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the directory {}. Creating the directory blob for\"\n               + \" it in {}. \", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n \n       // Start time for list operation\n       long start \u003d Time.monotonicNow();\n       ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n \n       // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n       do {\n         try {\n           PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n             AZURE_UNBOUNDED_DEPTH, priorLastKey);\n           for(FileMetadata file : listing.getFiles()) {\n             fileMetadataList.add(file);\n           }\n           priorLastKey \u003d listing.getPriorLastKey();\n         } catch (IOException e) {\n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException\n               \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n             return false;\n           }\n \n           throw e;\n         }\n       } while (priorLastKey !\u003d null);\n \n       long end \u003d Time.monotonicNow();\n       LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n \n       final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n \n       if (!recursive \u0026\u0026 contents.length \u003e 0) {\n           // The folder is non-empty and recursive delete was not specified.\n           // Throw an exception indicating that a non-recursive delete was\n           // specified for a non-empty folder.\n           throw new IOException(\"Non-recursive delete of non-empty directory \"\n               + f.toString());\n       }\n \n       // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n       AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n         @Override\n         public boolean execute(FileMetadata file) throws IOException{\n           return deleteFile(file.getKey(), file.isDir());\n         }\n       };\n \n       AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n           \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n \n       if (!executor.executeParallel(contents, task)) {\n         LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n         return false;\n       }\n \n       // Delete the current directory\n       if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n         LOG.error(\"Failed delete directory {}\", f.toString());\n         return false;\n       }\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         if (!skipParentFolderLastModifidedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n     }\n \n     // File or directory was successfully deleted.\n     LOG.debug(\"Delete Successful for : {}\", f.toString());\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifidedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        if (store.delete(key)) {\n          instrumentation.fileDeleted();\n        } else {\n          return false;\n        }\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n\n      // Start time for list operation\n      long start \u003d Time.monotonicNow();\n      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n\n      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n      do {\n        try {\n          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n          for(FileMetadata file : listing.getFiles()) {\n            fileMetadataList.add(file);\n          }\n          priorLastKey \u003d listing.getPriorLastKey();\n        } catch (IOException e) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n            return false;\n          }\n\n          throw e;\n        }\n      } while (priorLastKey !\u003d null);\n\n      long end \u003d Time.monotonicNow();\n      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n\n      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n          // The folder is non-empty and recursive delete was not specified.\n          // Throw an exception indicating that a non-recursive delete was\n          // specified for a non-empty folder.\n          throw new IOException(\"Non-recursive delete of non-empty directory \"\n              + f.toString());\n      }\n\n      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n        @Override\n        public boolean execute(FileMetadata file) throws IOException{\n          return deleteFile(file.getKey(), file.isDir());\n        }\n      };\n\n      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n\n      if (!executor.executeParallel(contents, task)) {\n        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n        return false;\n      }\n\n      // Delete the current directory\n      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n        LOG.error(\"Failed delete directory {}\", f.toString());\n        return false;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifidedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f.toString());\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13930. Azure: Add Authorization support to WASB. Contributed by Sivaguru Sankaridurg and Dushyanth\n",
      "commitDate": "03/03/17 5:09 PM",
      "commitName": "6b7cd62b8cf12616b13142f2eb2cfc2f25796f0f",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "29/12/16 4:24 PM",
      "commitNameOld": "c6a5b689db573046819f0e9193cb042e6c7298f4",
      "commitAuthorOld": "Mingliang Liu",
      "daysBetweenCommits": 64.03,
      "commitsBetweenForRepo": 324,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,237 +1,241 @@\n   public boolean delete(Path f, boolean recursive,\n       boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n \n     LOG.debug(\"Deleting file: {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n+\n+    performAuthCheck(absolutePath.toString(),\n+        WasbAuthorizationOperations.EXECUTE.toString(), \"delete\");\n+\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d null;\n     try {\n       metaFile \u003d store.retrieveMetadata(key);\n     } catch (IOException e) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         return false;\n       }\n       throw e;\n     }\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n \n         FileMetadata parentMetadata \u003d null;\n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the file {}. Creating the directory blob for\"\n               + \" it in {}.\", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           if (!skipParentFolderLastModifidedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n \n       try {\n         if (store.delete(key)) {\n           instrumentation.fileDeleted();\n         } else {\n           return false;\n         }\n       } catch(IOException e) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n        throw e;\n       }\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d null;\n \n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the directory {}. Creating the directory blob for\"\n               + \" it in {}. \", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n \n       // Start time for list operation\n       long start \u003d Time.monotonicNow();\n       ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n \n       // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n       do {\n         try {\n           PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n             AZURE_UNBOUNDED_DEPTH, priorLastKey);\n           for(FileMetadata file : listing.getFiles()) {\n             fileMetadataList.add(file);\n           }\n           priorLastKey \u003d listing.getPriorLastKey();\n         } catch (IOException e) {\n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException\n               \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n             return false;\n           }\n \n           throw e;\n         }\n       } while (priorLastKey !\u003d null);\n \n       long end \u003d Time.monotonicNow();\n       LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n \n       final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n \n       if (!recursive \u0026\u0026 contents.length \u003e 0) {\n           // The folder is non-empty and recursive delete was not specified.\n           // Throw an exception indicating that a non-recursive delete was\n           // specified for a non-empty folder.\n           throw new IOException(\"Non-recursive delete of non-empty directory \"\n               + f.toString());\n       }\n \n       // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n       AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n         @Override\n         public boolean execute(FileMetadata file) throws IOException{\n           return deleteFile(file.getKey(), file.isDir());\n         }\n       };\n \n       AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n           \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n \n       if (!executor.executeParallel(contents, task)) {\n         LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n         return false;\n       }\n \n       // Delete the current directory\n       if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n         LOG.error(\"Failed delete directory {}\", f.toString());\n         return false;\n       }\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         if (!skipParentFolderLastModifidedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n     }\n \n     // File or directory was successfully deleted.\n     LOG.debug(\"Delete Successful for : {}\", f.toString());\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n\n    performAuthCheck(absolutePath.toString(),\n        WasbAuthorizationOperations.EXECUTE.toString(), \"delete\");\n\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifidedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        if (store.delete(key)) {\n          instrumentation.fileDeleted();\n        } else {\n          return false;\n        }\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n\n      // Start time for list operation\n      long start \u003d Time.monotonicNow();\n      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n\n      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n      do {\n        try {\n          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n          for(FileMetadata file : listing.getFiles()) {\n            fileMetadataList.add(file);\n          }\n          priorLastKey \u003d listing.getPriorLastKey();\n        } catch (IOException e) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n            return false;\n          }\n\n          throw e;\n        }\n      } while (priorLastKey !\u003d null);\n\n      long end \u003d Time.monotonicNow();\n      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n\n      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n          // The folder is non-empty and recursive delete was not specified.\n          // Throw an exception indicating that a non-recursive delete was\n          // specified for a non-empty folder.\n          throw new IOException(\"Non-recursive delete of non-empty directory \"\n              + f.toString());\n      }\n\n      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n        @Override\n        public boolean execute(FileMetadata file) throws IOException{\n          return deleteFile(file.getKey(), file.isDir());\n        }\n      };\n\n      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n\n      if (!executor.executeParallel(contents, task)) {\n        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n        return false;\n      }\n\n      // Delete the current directory\n      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n        LOG.error(\"Failed delete directory {}\", f.toString());\n        return false;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifidedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f.toString());\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "15dd1f3381069c5fdc6690e3ab1907a133ba14bf": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13675. Bug in return value for delete() calls in WASB. Contributed by Dushyanth\n",
      "commitDate": "05/12/16 12:04 PM",
      "commitName": "15dd1f3381069c5fdc6690e3ab1907a133ba14bf",
      "commitAuthor": "Mingliang Liu",
      "commitDateOld": "06/10/16 8:31 AM",
      "commitNameOld": "2cc841f16ec9aa5336495fc20ee781a1276fddc5",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 60.19,
      "commitsBetweenForRepo": 477,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,234 +1,237 @@\n   public boolean delete(Path f, boolean recursive,\n       boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n \n     LOG.debug(\"Deleting file: {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d null;\n     try {\n       metaFile \u003d store.retrieveMetadata(key);\n     } catch (IOException e) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         return false;\n       }\n       throw e;\n     }\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n \n         FileMetadata parentMetadata \u003d null;\n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the file {}. Creating the directory blob for\"\n               + \" it in {}.\", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           if (!skipParentFolderLastModifidedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n \n       try {\n-        store.delete(key);\n-        instrumentation.fileDeleted();\n+        if (store.delete(key)) {\n+          instrumentation.fileDeleted();\n+        } else {\n+          return false;\n+        }\n       } catch(IOException e) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n        throw e;\n       }\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d null;\n \n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the directory {}. Creating the directory blob for\"\n               + \" it in {}. \", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n \n       // Start time for list operation\n       long start \u003d Time.monotonicNow();\n       ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n \n       // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n       do {\n         try {\n           PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n             AZURE_UNBOUNDED_DEPTH, priorLastKey);\n           for(FileMetadata file : listing.getFiles()) {\n             fileMetadataList.add(file);\n           }\n           priorLastKey \u003d listing.getPriorLastKey();\n         } catch (IOException e) {\n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException\n               \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n             return false;\n           }\n \n           throw e;\n         }\n       } while (priorLastKey !\u003d null);\n \n       long end \u003d Time.monotonicNow();\n       LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n \n       final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n \n       if (!recursive \u0026\u0026 contents.length \u003e 0) {\n           // The folder is non-empty and recursive delete was not specified.\n           // Throw an exception indicating that a non-recursive delete was\n           // specified for a non-empty folder.\n           throw new IOException(\"Non-recursive delete of non-empty directory \"\n               + f.toString());\n       }\n \n       // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n       AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n         @Override\n         public boolean execute(FileMetadata file) throws IOException{\n           return deleteFile(file.getKey(), file.isDir());\n         }\n       };\n \n       AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n           \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n \n       if (!executor.executeParallel(contents, task)) {\n         LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n         return false;\n       }\n \n       // Delete the current directory\n-      if (!deleteFile(metaFile.getKey(), metaFile.isDir())) {\n+      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n         LOG.error(\"Failed delete directory {}\", f.toString());\n         return false;\n       }\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         if (!skipParentFolderLastModifidedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n     }\n \n     // File or directory was successfully deleted.\n     LOG.debug(\"Delete Successful for : {}\", f.toString());\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifidedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        if (store.delete(key)) {\n          instrumentation.fileDeleted();\n        } else {\n          return false;\n        }\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n\n      // Start time for list operation\n      long start \u003d Time.monotonicNow();\n      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n\n      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n      do {\n        try {\n          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n          for(FileMetadata file : listing.getFiles()) {\n            fileMetadataList.add(file);\n          }\n          priorLastKey \u003d listing.getPriorLastKey();\n        } catch (IOException e) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n            return false;\n          }\n\n          throw e;\n        }\n      } while (priorLastKey !\u003d null);\n\n      long end \u003d Time.monotonicNow();\n      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n\n      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n          // The folder is non-empty and recursive delete was not specified.\n          // Throw an exception indicating that a non-recursive delete was\n          // specified for a non-empty folder.\n          throw new IOException(\"Non-recursive delete of non-empty directory \"\n              + f.toString());\n      }\n\n      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n        @Override\n        public boolean execute(FileMetadata file) throws IOException{\n          return deleteFile(file.getKey(), file.isDir());\n        }\n      };\n\n      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n\n      if (!executor.executeParallel(contents, task)) {\n        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n        return false;\n      }\n\n      // Delete the current directory\n      if (store.retrieveMetadata(metaFile.getKey()) !\u003d null \u0026\u0026 !deleteFile(metaFile.getKey(), metaFile.isDir())) {\n        LOG.error(\"Failed delete directory {}\", f.toString());\n        return false;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifidedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f.toString());\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "2ed58c40e5dcbf5c5303c00e85096085b1055f85": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13403. AzureNativeFileSystem rename/delete performance improvements. Contributed by Subramanyam Pattipaka.\n",
      "commitDate": "08/08/16 12:28 PM",
      "commitName": "2ed58c40e5dcbf5c5303c00e85096085b1055f85",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "08/04/16 1:36 PM",
      "commitNameOld": "843ee8d59d8bacbca0d87ccf0790772e39d16138",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 121.95,
      "commitsBetweenForRepo": 924,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,247 +1,234 @@\n   public boolean delete(Path f, boolean recursive,\n       boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n \n     LOG.debug(\"Deleting file: {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d null;\n     try {\n       metaFile \u003d store.retrieveMetadata(key);\n     } catch (IOException e) {\n \n       Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n       if (innerException instanceof StorageException\n           \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         return false;\n       }\n       throw e;\n     }\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n \n         FileMetadata parentMetadata \u003d null;\n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the file {}. Creating the directory blob for\"\n               + \" it in {}.\", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           if (!skipParentFolderLastModifidedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n \n       try {\n         store.delete(key);\n         instrumentation.fileDeleted();\n       } catch(IOException e) {\n \n         Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n             \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n        throw e;\n       }\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d null;\n \n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n           Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n             if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the directory {}. Creating the directory blob for\"\n               + \" it in {}. \", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n-      PartialListing listing \u003d null;\n-      try {\n-        listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n-            priorLastKey);\n-      } catch(IOException e) {\n \n-        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n+      // Start time for list operation\n+      long start \u003d Time.monotonicNow();\n+      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n \n-        if (innerException instanceof StorageException\n-            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n-          return false;\n+      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n+      do {\n+        try {\n+          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n+            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n+          for(FileMetadata file : listing.getFiles()) {\n+            fileMetadataList.add(file);\n+          }\n+          priorLastKey \u003d listing.getPriorLastKey();\n+        } catch (IOException e) {\n+          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n+\n+          if (innerException instanceof StorageException\n+              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n+            return false;\n+          }\n+\n+          throw e;\n         }\n+      } while (priorLastKey !\u003d null);\n \n-        throw e;\n+      long end \u003d Time.monotonicNow();\n+      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n+\n+      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n+\n+      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n+          // The folder is non-empty and recursive delete was not specified.\n+          // Throw an exception indicating that a non-recursive delete was\n+          // specified for a non-empty folder.\n+          throw new IOException(\"Non-recursive delete of non-empty directory \"\n+              + f.toString());\n       }\n \n-      if (listing \u003d\u003d null) {\n+      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n+      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n+        @Override\n+        public boolean execute(FileMetadata file) throws IOException{\n+          return deleteFile(file.getKey(), file.isDir());\n+        }\n+      };\n+\n+      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n+          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n+\n+      if (!executor.executeParallel(contents, task)) {\n+        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n         return false;\n       }\n \n-      FileMetadata[] contents \u003d listing.getFiles();\n-      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n-        // The folder is non-empty and recursive delete was not specified.\n-        // Throw an exception indicating that a non-recursive delete was\n-        // specified for a non-empty folder.\n-        throw new IOException(\"Non-recursive delete of non-empty directory \"\n-            + f.toString());\n-      }\n-\n-      // Delete all the files in the folder.\n-      for (FileMetadata p : contents) {\n-        // Tag on the directory name found as the suffix of the suffix of the\n-        // parent directory to get the new absolute path.\n-        String suffix \u003d p.getKey().substring(\n-            p.getKey().lastIndexOf(PATH_DELIMITER));\n-        if (!p.isDir()) {\n-          try {\n-            store.delete(key + suffix);\n-            instrumentation.fileDeleted();\n-          } catch(IOException e) {\n-\n-            Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n-\n-            if (innerException instanceof StorageException\n-                \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n-              return false;\n-            }\n-\n-            throw e;\n-          }\n-        } else {\n-          // Recursively delete contents of the sub-folders. Notice this also\n-          // deletes the blob for the directory.\n-          if (!delete(new Path(f.toString() + suffix), true)) {\n-            return false;\n-          }\n-        }\n-      }\n-\n-      try {\n-        store.delete(key);\n-      } catch(IOException e) {\n-\n-        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n-\n-        if (innerException instanceof StorageException\n-            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n-          return false;\n-        }\n-\n-        throw e;\n+      // Delete the current directory\n+      if (!deleteFile(metaFile.getKey(), metaFile.isDir())) {\n+        LOG.error(\"Failed delete directory {}\", f.toString());\n+        return false;\n       }\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         if (!skipParentFolderLastModifidedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n-      instrumentation.directoryDeleted();\n     }\n \n     // File or directory was successfully deleted.\n     LOG.debug(\"Delete Successful for : {}\", f.toString());\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifidedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        store.delete(key);\n        instrumentation.fileDeleted();\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n\n      // Start time for list operation\n      long start \u003d Time.monotonicNow();\n      ArrayList\u003cFileMetadata\u003e fileMetadataList \u003d new ArrayList\u003cFileMetadata\u003e();\n\n      // List all the files in the folder with AZURE_UNBOUNDED_DEPTH depth.\n      do {\n        try {\n          PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL,\n            AZURE_UNBOUNDED_DEPTH, priorLastKey);\n          for(FileMetadata file : listing.getFiles()) {\n            fileMetadataList.add(file);\n          }\n          priorLastKey \u003d listing.getPriorLastKey();\n        } catch (IOException e) {\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException\n              \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n            return false;\n          }\n\n          throw e;\n        }\n      } while (priorLastKey !\u003d null);\n\n      long end \u003d Time.monotonicNow();\n      LOG.debug(\"Time taken to list {} blobs for delete operation: {} ms\", fileMetadataList.size(), (end - start));\n\n      final FileMetadata[] contents \u003d fileMetadataList.toArray(new FileMetadata[fileMetadataList.size()]);\n\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n          // The folder is non-empty and recursive delete was not specified.\n          // Throw an exception indicating that a non-recursive delete was\n          // specified for a non-empty folder.\n          throw new IOException(\"Non-recursive delete of non-empty directory \"\n              + f.toString());\n      }\n\n      // Delete all files / folders in current directory stored as list in \u0027contents\u0027.\n      AzureFileSystemThreadTask task \u003d new AzureFileSystemThreadTask() {\n        @Override\n        public boolean execute(FileMetadata file) throws IOException{\n          return deleteFile(file.getKey(), file.isDir());\n        }\n      };\n\n      AzureFileSystemThreadPoolExecutor executor \u003d getThreadPoolExecutor(this.deleteThreadCount,\n          \"AzureBlobDeleteThread\", \"Delete\", key, AZURE_DELETE_THREADS);\n\n      if (!executor.executeParallel(contents, task)) {\n        LOG.error(\"Failed to delete files / subfolders in blob {}\", key);\n        return false;\n      }\n\n      // Delete the current directory\n      if (!deleteFile(metaFile.getKey(), metaFile.isDir())) {\n        LOG.error(\"Failed delete directory {}\", f.toString());\n        return false;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifidedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f.toString());\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12635. Adding Append API support for WASB. Contributed by Dushyanth.\n",
      "commitDate": "18/01/16 9:08 AM",
      "commitName": "8bc93db2e7c64830b6a662f28c8917a9eef4e7c9",
      "commitAuthor": "cnauroth",
      "commitDateOld": "09/01/16 10:18 PM",
      "commitNameOld": "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 8.45,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,247 +1,247 @@\n   public boolean delete(Path f, boolean recursive,\n       boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n \n     LOG.debug(\"Deleting file: {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d null;\n     try {\n       metaFile \u003d store.retrieveMetadata(key);\n     } catch (IOException e) {\n \n-      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n       if (innerException instanceof StorageException\n-          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n \n         return false;\n       }\n       throw e;\n     }\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n \n         FileMetadata parentMetadata \u003d null;\n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n-          Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n-            if (NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the file {}. Creating the directory blob for\"\n               + \" it in {}.\", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           if (!skipParentFolderLastModifidedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n \n       try {\n         store.delete(key);\n         instrumentation.fileDeleted();\n       } catch(IOException e) {\n \n-        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n-            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n        throw e;\n       }\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d null;\n \n         try {\n           parentMetadata \u003d store.retrieveMetadata(parentKey);\n         } catch (IOException e) {\n \n-          Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n           if (innerException instanceof StorageException) {\n             // Invalid State.\n             // A FileNotFoundException is not thrown here as the API returns false\n             // if the file not present. But not retrieving metadata here is an\n             // unrecoverable state and can only happen if there is a race condition\n             // hence throwing a IOException\n-            if (NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               throw new IOException(\"File \" + f + \" has a parent directory \"\n                   + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n             }\n           }\n           throw e;\n         }\n \n         // Invalid State.\n         // A FileNotFoundException is not thrown here as the API returns false\n         // if the file not present. But not retrieving metadata here is an\n         // unrecoverable state and can only happen if there is a race condition\n         // hence throwing a IOException\n         if (parentMetadata \u003d\u003d null) {\n           throw new IOException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n         }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the directory {}. Creating the directory blob for\"\n               + \" it in {}. \", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n       PartialListing listing \u003d null;\n       try {\n         listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n             priorLastKey);\n       } catch(IOException e) {\n \n-        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n-            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n         throw e;\n       }\n \n       if (listing \u003d\u003d null) {\n         return false;\n       }\n \n       FileMetadata[] contents \u003d listing.getFiles();\n       if (!recursive \u0026\u0026 contents.length \u003e 0) {\n         // The folder is non-empty and recursive delete was not specified.\n         // Throw an exception indicating that a non-recursive delete was\n         // specified for a non-empty folder.\n         throw new IOException(\"Non-recursive delete of non-empty directory \"\n             + f.toString());\n       }\n \n       // Delete all the files in the folder.\n       for (FileMetadata p : contents) {\n         // Tag on the directory name found as the suffix of the suffix of the\n         // parent directory to get the new absolute path.\n         String suffix \u003d p.getKey().substring(\n             p.getKey().lastIndexOf(PATH_DELIMITER));\n         if (!p.isDir()) {\n           try {\n             store.delete(key + suffix);\n             instrumentation.fileDeleted();\n           } catch(IOException e) {\n \n-            Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+            Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n             if (innerException instanceof StorageException\n-                \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+                \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n               return false;\n             }\n \n             throw e;\n           }\n         } else {\n           // Recursively delete contents of the sub-folders. Notice this also\n           // deletes the blob for the directory.\n           if (!delete(new Path(f.toString() + suffix), true)) {\n             return false;\n           }\n         }\n       }\n \n       try {\n         store.delete(key);\n       } catch(IOException e) {\n \n-        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n \n         if (innerException instanceof StorageException\n-            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n           return false;\n         }\n \n         throw e;\n       }\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         if (!skipParentFolderLastModifidedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n       instrumentation.directoryDeleted();\n     }\n \n     // File or directory was successfully deleted.\n     LOG.debug(\"Delete Successful for : {}\", f.toString());\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifidedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        store.delete(key);\n        instrumentation.fileDeleted();\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n      PartialListing listing \u003d null;\n      try {\n        listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n            priorLastKey);\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n        throw e;\n      }\n\n      if (listing \u003d\u003d null) {\n        return false;\n      }\n\n      FileMetadata[] contents \u003d listing.getFiles();\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n        // The folder is non-empty and recursive delete was not specified.\n        // Throw an exception indicating that a non-recursive delete was\n        // specified for a non-empty folder.\n        throw new IOException(\"Non-recursive delete of non-empty directory \"\n            + f.toString());\n      }\n\n      // Delete all the files in the folder.\n      for (FileMetadata p : contents) {\n        // Tag on the directory name found as the suffix of the suffix of the\n        // parent directory to get the new absolute path.\n        String suffix \u003d p.getKey().substring(\n            p.getKey().lastIndexOf(PATH_DELIMITER));\n        if (!p.isDir()) {\n          try {\n            store.delete(key + suffix);\n            instrumentation.fileDeleted();\n          } catch(IOException e) {\n\n            Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n            if (innerException instanceof StorageException\n                \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n              return false;\n            }\n\n            throw e;\n          }\n        } else {\n          // Recursively delete contents of the sub-folders. Notice this also\n          // deletes the blob for the directory.\n          if (!delete(new Path(f.toString() + suffix), true)) {\n            return false;\n          }\n        }\n      }\n\n      try {\n        store.delete(key);\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystemHelper.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystemHelper.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n        throw e;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifidedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n      instrumentation.directoryDeleted();\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f.toString());\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12551. Introduce FileNotFoundException for WASB FileSystem API. Contributed by Dushyanth.\n",
      "commitDate": "09/01/16 10:18 PM",
      "commitName": "0e76f1fceaaaeb66bdb4818f43b9a55fc092bf79",
      "commitAuthor": "cnauroth",
      "commitDateOld": "08/01/16 8:18 PM",
      "commitNameOld": "f0fa6d869b9abb5a900ea1c9eb4eb19ec9831dc4",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 1.08,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,116 +1,247 @@\n   public boolean delete(Path f, boolean recursive,\n       boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n \n     LOG.debug(\"Deleting file: {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n-    FileMetadata metaFile \u003d store.retrieveMetadata(key);\n+    FileMetadata metaFile \u003d null;\n+    try {\n+      metaFile \u003d store.retrieveMetadata(key);\n+    } catch (IOException e) {\n+\n+      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+\n+      if (innerException instanceof StorageException\n+          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+\n+        return false;\n+      }\n+      throw e;\n+    }\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n-        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n+\n+        FileMetadata parentMetadata \u003d null;\n+        try {\n+          parentMetadata \u003d store.retrieveMetadata(parentKey);\n+        } catch (IOException e) {\n+\n+          Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+\n+          if (innerException instanceof StorageException) {\n+            // Invalid State.\n+            // A FileNotFoundException is not thrown here as the API returns false\n+            // if the file not present. But not retrieving metadata here is an\n+            // unrecoverable state and can only happen if there is a race condition\n+            // hence throwing a IOException\n+            if (NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+              throw new IOException(\"File \" + f + \" has a parent directory \"\n+                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n+            }\n+          }\n+          throw e;\n+        }\n+\n+        // Invalid State.\n+        // A FileNotFoundException is not thrown here as the API returns false\n+        // if the file not present. But not retrieving metadata here is an\n+        // unrecoverable state and can only happen if there is a race condition\n+        // hence throwing a IOException\n+        if (parentMetadata \u003d\u003d null) {\n+          throw new IOException(\"File \" + f + \" has a parent directory \"\n+              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n+        }\n+\n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n+\n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the file {}. Creating the directory blob for\"\n               + \" it in {}.\", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           if (!skipParentFolderLastModifidedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n-      store.delete(key);\n-      instrumentation.fileDeleted();\n+\n+      try {\n+        store.delete(key);\n+        instrumentation.fileDeleted();\n+      } catch(IOException e) {\n+\n+        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+\n+        if (innerException instanceof StorageException\n+            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+          return false;\n+        }\n+\n+       throw e;\n+      }\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n-        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n+        FileMetadata parentMetadata \u003d null;\n+\n+        try {\n+          parentMetadata \u003d store.retrieveMetadata(parentKey);\n+        } catch (IOException e) {\n+\n+          Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+\n+          if (innerException instanceof StorageException) {\n+            // Invalid State.\n+            // A FileNotFoundException is not thrown here as the API returns false\n+            // if the file not present. But not retrieving metadata here is an\n+            // unrecoverable state and can only happen if there is a race condition\n+            // hence throwing a IOException\n+            if (NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+              throw new IOException(\"File \" + f + \" has a parent directory \"\n+                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n+            }\n+          }\n+          throw e;\n+        }\n+\n+        // Invalid State.\n+        // A FileNotFoundException is not thrown here as the API returns false\n+        // if the file not present. But not retrieving metadata here is an\n+        // unrecoverable state and can only happen if there is a race condition\n+        // hence throwing a IOException\n+        if (parentMetadata \u003d\u003d null) {\n+          throw new IOException(\"File \" + f + \" has a parent directory \"\n+              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n+        }\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           LOG.debug(\"Found an implicit parent directory while trying to\"\n               + \" delete the directory {}. Creating the directory blob for\"\n               + \" it in {}. \", f, parentKey);\n \n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n-      PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n-          priorLastKey);\n+      PartialListing listing \u003d null;\n+      try {\n+        listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n+            priorLastKey);\n+      } catch(IOException e) {\n+\n+        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+\n+        if (innerException instanceof StorageException\n+            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+          return false;\n+        }\n+\n+        throw e;\n+      }\n+\n+      if (listing \u003d\u003d null) {\n+        return false;\n+      }\n+\n       FileMetadata[] contents \u003d listing.getFiles();\n       if (!recursive \u0026\u0026 contents.length \u003e 0) {\n         // The folder is non-empty and recursive delete was not specified.\n         // Throw an exception indicating that a non-recursive delete was\n         // specified for a non-empty folder.\n         throw new IOException(\"Non-recursive delete of non-empty directory \"\n             + f.toString());\n       }\n \n       // Delete all the files in the folder.\n       for (FileMetadata p : contents) {\n         // Tag on the directory name found as the suffix of the suffix of the\n         // parent directory to get the new absolute path.\n         String suffix \u003d p.getKey().substring(\n             p.getKey().lastIndexOf(PATH_DELIMITER));\n         if (!p.isDir()) {\n-          store.delete(key + suffix);\n-          instrumentation.fileDeleted();\n+          try {\n+            store.delete(key + suffix);\n+            instrumentation.fileDeleted();\n+          } catch(IOException e) {\n+\n+            Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+\n+            if (innerException instanceof StorageException\n+                \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+              return false;\n+            }\n+\n+            throw e;\n+          }\n         } else {\n           // Recursively delete contents of the sub-folders. Notice this also\n           // deletes the blob for the directory.\n           if (!delete(new Path(f.toString() + suffix), true)) {\n             return false;\n           }\n         }\n       }\n-      store.delete(key);\n+\n+      try {\n+        store.delete(key);\n+      } catch(IOException e) {\n+\n+        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n+\n+        if (innerException instanceof StorageException\n+            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n+          return false;\n+        }\n+\n+        throw e;\n+      }\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         if (!skipParentFolderLastModifidedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n       instrumentation.directoryDeleted();\n     }\n \n     // File or directory was successfully deleted.\n     LOG.debug(\"Delete Successful for : {}\", f.toString());\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d null;\n    try {\n      metaFile \u003d store.retrieveMetadata(key);\n    } catch (IOException e) {\n\n      Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n\n      if (innerException instanceof StorageException\n          \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n\n        return false;\n      }\n      throw e;\n    }\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n\n        FileMetadata parentMetadata \u003d null;\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifidedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n\n      try {\n        store.delete(key);\n        instrumentation.fileDeleted();\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n       throw e;\n      }\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d null;\n\n        try {\n          parentMetadata \u003d store.retrieveMetadata(parentKey);\n        } catch (IOException e) {\n\n          Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n\n          if (innerException instanceof StorageException) {\n            // Invalid State.\n            // A FileNotFoundException is not thrown here as the API returns false\n            // if the file not present. But not retrieving metadata here is an\n            // unrecoverable state and can only happen if there is a race condition\n            // hence throwing a IOException\n            if (NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n              throw new IOException(\"File \" + f + \" has a parent directory \"\n                  + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n            }\n          }\n          throw e;\n        }\n\n        // Invalid State.\n        // A FileNotFoundException is not thrown here as the API returns false\n        // if the file not present. But not retrieving metadata here is an\n        // unrecoverable state and can only happen if there is a race condition\n        // hence throwing a IOException\n        if (parentMetadata \u003d\u003d null) {\n          throw new IOException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" whose metadata cannot be retrieved. Can\u0027t resolve\");\n        }\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n      PartialListing listing \u003d null;\n      try {\n        listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n            priorLastKey);\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n        throw e;\n      }\n\n      if (listing \u003d\u003d null) {\n        return false;\n      }\n\n      FileMetadata[] contents \u003d listing.getFiles();\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n        // The folder is non-empty and recursive delete was not specified.\n        // Throw an exception indicating that a non-recursive delete was\n        // specified for a non-empty folder.\n        throw new IOException(\"Non-recursive delete of non-empty directory \"\n            + f.toString());\n      }\n\n      // Delete all the files in the folder.\n      for (FileMetadata p : contents) {\n        // Tag on the directory name found as the suffix of the suffix of the\n        // parent directory to get the new absolute path.\n        String suffix \u003d p.getKey().substring(\n            p.getKey().lastIndexOf(PATH_DELIMITER));\n        if (!p.isDir()) {\n          try {\n            store.delete(key + suffix);\n            instrumentation.fileDeleted();\n          } catch(IOException e) {\n\n            Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n\n            if (innerException instanceof StorageException\n                \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n              return false;\n            }\n\n            throw e;\n          }\n        } else {\n          // Recursively delete contents of the sub-folders. Notice this also\n          // deletes the blob for the directory.\n          if (!delete(new Path(f.toString() + suffix), true)) {\n            return false;\n          }\n        }\n      }\n\n      try {\n        store.delete(key);\n      } catch(IOException e) {\n\n        Throwable innerException \u003d NativeAzureFileSystem.checkForAzureStorageException(e);\n\n        if (innerException instanceof StorageException\n            \u0026\u0026 NativeAzureFileSystem.isFileNotFoundException((StorageException) innerException)) {\n          return false;\n        }\n\n        throw e;\n      }\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifidedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n      instrumentation.directoryDeleted();\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f.toString());\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "5f6edb30c2bb648d5564c951edc25645e17e6636": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12350. WASB Logging: Improve WASB Logging around deletes, reads and writes. Contributed by Dushyanth.\n",
      "commitDate": "05/10/15 8:11 PM",
      "commitName": "5f6edb30c2bb648d5564c951edc25645e17e6636",
      "commitAuthor": "cnauroth",
      "commitDateOld": "28/09/15 3:31 PM",
      "commitNameOld": "3abbdc929bde05f8819f5410cef1eaeb8940203f",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 7.19,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,119 +1,116 @@\n   public boolean delete(Path f, boolean recursive,\n       boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n \n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"Deleting file: \" + f.toString());\n-    }\n+    LOG.debug(\"Deleting file: {}\", f.toString());\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d store.retrieveMetadata(key);\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Found an implicit parent directory while trying to\"\n-                + \" delete the file \" + f + \". Creating the directory blob for\"\n-                + \" it in \" + parentKey + \".\");\n-          }\n+          LOG.debug(\"Found an implicit parent directory while trying to\"\n+              + \" delete the file {}. Creating the directory blob for\"\n+              + \" it in {}.\", f, parentKey);\n+\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           if (!skipParentFolderLastModifidedTimeUpdate) {\n             updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n       store.delete(key);\n       instrumentation.fileDeleted();\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n+      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Found an implicit parent directory while trying to\"\n-                + \" delete the directory \" + f\n-                + \". Creating the directory blob for\" + \" it in \" + parentKey\n-                + \".\");\n-          }\n+          LOG.debug(\"Found an implicit parent directory while trying to\"\n+              + \" delete the directory {}. Creating the directory blob for\"\n+              + \" it in {}. \", f, parentKey);\n+\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n       PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n           priorLastKey);\n       FileMetadata[] contents \u003d listing.getFiles();\n       if (!recursive \u0026\u0026 contents.length \u003e 0) {\n         // The folder is non-empty and recursive delete was not specified.\n         // Throw an exception indicating that a non-recursive delete was\n         // specified for a non-empty folder.\n         throw new IOException(\"Non-recursive delete of non-empty directory \"\n             + f.toString());\n       }\n \n       // Delete all the files in the folder.\n       for (FileMetadata p : contents) {\n         // Tag on the directory name found as the suffix of the suffix of the\n         // parent directory to get the new absolute path.\n         String suffix \u003d p.getKey().substring(\n             p.getKey().lastIndexOf(PATH_DELIMITER));\n         if (!p.isDir()) {\n           store.delete(key + suffix);\n           instrumentation.fileDeleted();\n         } else {\n           // Recursively delete contents of the sub-folders. Notice this also\n           // deletes the blob for the directory.\n           if (!delete(new Path(f.toString() + suffix), true)) {\n             return false;\n           }\n         }\n       }\n       store.delete(key);\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         if (!skipParentFolderLastModifidedTimeUpdate) {\n           updateParentFolderLastModifiedTime(key);\n         }\n       }\n       instrumentation.directoryDeleted();\n     }\n \n     // File or directory was successfully deleted.\n+    LOG.debug(\"Delete Successful for : {}\", f.toString());\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n\n    LOG.debug(\"Deleting file: {}\", f.toString());\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d store.retrieveMetadata(key);\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the file {}. Creating the directory blob for\"\n              + \" it in {}.\", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifidedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n      store.delete(key);\n      instrumentation.fileDeleted();\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      LOG.debug(\"Directory Delete encountered: {}\", f.toString());\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          LOG.debug(\"Found an implicit parent directory while trying to\"\n              + \" delete the directory {}. Creating the directory blob for\"\n              + \" it in {}. \", f, parentKey);\n\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n      PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n          priorLastKey);\n      FileMetadata[] contents \u003d listing.getFiles();\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n        // The folder is non-empty and recursive delete was not specified.\n        // Throw an exception indicating that a non-recursive delete was\n        // specified for a non-empty folder.\n        throw new IOException(\"Non-recursive delete of non-empty directory \"\n            + f.toString());\n      }\n\n      // Delete all the files in the folder.\n      for (FileMetadata p : contents) {\n        // Tag on the directory name found as the suffix of the suffix of the\n        // parent directory to get the new absolute path.\n        String suffix \u003d p.getKey().substring(\n            p.getKey().lastIndexOf(PATH_DELIMITER));\n        if (!p.isDir()) {\n          store.delete(key + suffix);\n          instrumentation.fileDeleted();\n        } else {\n          // Recursively delete contents of the sub-folders. Notice this also\n          // deletes the blob for the directory.\n          if (!delete(new Path(f.toString() + suffix), true)) {\n            return false;\n          }\n        }\n      }\n      store.delete(key);\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifidedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n      instrumentation.directoryDeleted();\n    }\n\n    // File or directory was successfully deleted.\n    LOG.debug(\"Delete Successful for : {}\", f.toString());\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "460e98f7b3ec84f3c5afcb2aad4f4e7031d16e3a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12089. StorageException complaining \" no lease ID\" when updating FolderLastModifiedTime in WASB. Contributed by Duo Xu.\n",
      "commitDate": "29/06/15 1:48 PM",
      "commitName": "460e98f7b3ec84f3c5afcb2aad4f4e7031d16e3a",
      "commitAuthor": "cnauroth",
      "commitDateOld": "17/03/15 12:09 AM",
      "commitNameOld": "ef9946cd52d54200c658987c1dbc3e6fce133f77",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 104.57,
      "commitsBetweenForRepo": 928,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,119 @@\n   public boolean delete(Path f, boolean recursive,\n       boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Deleting file: \" + f.toString());\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d store.retrieveMetadata(key);\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found an implicit parent directory while trying to\"\n                 + \" delete the file \" + f + \". Creating the directory blob for\"\n                 + \" it in \" + parentKey + \".\");\n           }\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           if (!skipParentFolderLastModifidedTimeUpdate) {\n-            store.updateFolderLastModifiedTime(parentKey, null);\n+            updateParentFolderLastModifiedTime(key);\n           }\n         }\n       }\n       store.delete(key);\n       instrumentation.fileDeleted();\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found an implicit parent directory while trying to\"\n                 + \" delete the directory \" + f\n                 + \". Creating the directory blob for\" + \" it in \" + parentKey\n                 + \".\");\n           }\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n       PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n           priorLastKey);\n       FileMetadata[] contents \u003d listing.getFiles();\n       if (!recursive \u0026\u0026 contents.length \u003e 0) {\n         // The folder is non-empty and recursive delete was not specified.\n         // Throw an exception indicating that a non-recursive delete was\n         // specified for a non-empty folder.\n         throw new IOException(\"Non-recursive delete of non-empty directory \"\n             + f.toString());\n       }\n \n       // Delete all the files in the folder.\n       for (FileMetadata p : contents) {\n         // Tag on the directory name found as the suffix of the suffix of the\n         // parent directory to get the new absolute path.\n         String suffix \u003d p.getKey().substring(\n             p.getKey().lastIndexOf(PATH_DELIMITER));\n         if (!p.isDir()) {\n           store.delete(key + suffix);\n           instrumentation.fileDeleted();\n         } else {\n           // Recursively delete contents of the sub-folders. Notice this also\n           // deletes the blob for the directory.\n           if (!delete(new Path(f.toString() + suffix), true)) {\n             return false;\n           }\n         }\n       }\n       store.delete(key);\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n-        String parentKey \u003d pathToKey(parent);\n         if (!skipParentFolderLastModifidedTimeUpdate) {\n-          store.updateFolderLastModifiedTime(parentKey, null);\n+          updateParentFolderLastModifiedTime(key);\n         }\n       }\n       instrumentation.directoryDeleted();\n     }\n \n     // File or directory was successfully deleted.\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Deleting file: \" + f.toString());\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d store.retrieveMetadata(key);\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the file \" + f + \". Creating the directory blob for\"\n                + \" it in \" + parentKey + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifidedTimeUpdate) {\n            updateParentFolderLastModifiedTime(key);\n          }\n        }\n      }\n      store.delete(key);\n      instrumentation.fileDeleted();\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the directory \" + f\n                + \". Creating the directory blob for\" + \" it in \" + parentKey\n                + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n      PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n          priorLastKey);\n      FileMetadata[] contents \u003d listing.getFiles();\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n        // The folder is non-empty and recursive delete was not specified.\n        // Throw an exception indicating that a non-recursive delete was\n        // specified for a non-empty folder.\n        throw new IOException(\"Non-recursive delete of non-empty directory \"\n            + f.toString());\n      }\n\n      // Delete all the files in the folder.\n      for (FileMetadata p : contents) {\n        // Tag on the directory name found as the suffix of the suffix of the\n        // parent directory to get the new absolute path.\n        String suffix \u003d p.getKey().substring(\n            p.getKey().lastIndexOf(PATH_DELIMITER));\n        if (!p.isDir()) {\n          store.delete(key + suffix);\n          instrumentation.fileDeleted();\n        } else {\n          // Recursively delete contents of the sub-folders. Notice this also\n          // deletes the blob for the directory.\n          if (!delete(new Path(f.toString() + suffix), true)) {\n            return false;\n          }\n        }\n      }\n      store.delete(key);\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        if (!skipParentFolderLastModifidedTimeUpdate) {\n          updateParentFolderLastModifiedTime(key);\n        }\n      }\n      instrumentation.directoryDeleted();\n    }\n\n    // File or directory was successfully deleted.\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "2217e2f8ff418b88eac6ad36cafe3a9795a11f40": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
      "commitDate": "08/10/14 2:20 PM",
      "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
      "commitAuthor": "cnauroth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
          "commitDate": "08/10/14 2:20 PM",
          "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
          "commitAuthor": "cnauroth",
          "commitDateOld": "19/09/14 11:33 AM",
          "commitNameOld": "9f03a7c018bb2c497cd0ef758f1a3e08e8163d06",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 19.12,
          "commitsBetweenForRepo": 199,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,115 +1,120 @@\n-  public boolean delete(Path f, boolean recursive) throws IOException {\n+  public boolean delete(Path f, boolean recursive,\n+      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Deleting file: \" + f.toString());\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d store.retrieveMetadata(key);\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found an implicit parent directory while trying to\"\n                 + \" delete the file \" + f + \". Creating the directory blob for\"\n                 + \" it in \" + parentKey + \".\");\n           }\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n-          store.updateFolderLastModifiedTime(parentKey);\n+          if (!skipParentFolderLastModifidedTimeUpdate) {\n+            store.updateFolderLastModifiedTime(parentKey, null);\n+          }\n         }\n       }\n-      instrumentation.fileDeleted();\n       store.delete(key);\n+      instrumentation.fileDeleted();\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found an implicit parent directory while trying to\"\n                 + \" delete the directory \" + f\n                 + \". Creating the directory blob for\" + \" it in \" + parentKey\n                 + \".\");\n           }\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n       PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n           priorLastKey);\n       FileMetadata[] contents \u003d listing.getFiles();\n       if (!recursive \u0026\u0026 contents.length \u003e 0) {\n         // The folder is non-empty and recursive delete was not specified.\n         // Throw an exception indicating that a non-recursive delete was\n         // specified for a non-empty folder.\n         throw new IOException(\"Non-recursive delete of non-empty directory \"\n             + f.toString());\n       }\n \n       // Delete all the files in the folder.\n       for (FileMetadata p : contents) {\n         // Tag on the directory name found as the suffix of the suffix of the\n         // parent directory to get the new absolute path.\n         String suffix \u003d p.getKey().substring(\n             p.getKey().lastIndexOf(PATH_DELIMITER));\n         if (!p.isDir()) {\n           store.delete(key + suffix);\n           instrumentation.fileDeleted();\n         } else {\n           // Recursively delete contents of the sub-folders. Notice this also\n           // deletes the blob for the directory.\n           if (!delete(new Path(f.toString() + suffix), true)) {\n             return false;\n           }\n         }\n       }\n       store.delete(key);\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         String parentKey \u003d pathToKey(parent);\n-        store.updateFolderLastModifiedTime(parentKey);\n+        if (!skipParentFolderLastModifidedTimeUpdate) {\n+          store.updateFolderLastModifiedTime(parentKey, null);\n+        }\n       }\n       instrumentation.directoryDeleted();\n     }\n \n     // File or directory was successfully deleted.\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Deleting file: \" + f.toString());\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d store.retrieveMetadata(key);\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the file \" + f + \". Creating the directory blob for\"\n                + \" it in \" + parentKey + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifidedTimeUpdate) {\n            store.updateFolderLastModifiedTime(parentKey, null);\n          }\n        }\n      }\n      store.delete(key);\n      instrumentation.fileDeleted();\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the directory \" + f\n                + \". Creating the directory blob for\" + \" it in \" + parentKey\n                + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n      PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n          priorLastKey);\n      FileMetadata[] contents \u003d listing.getFiles();\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n        // The folder is non-empty and recursive delete was not specified.\n        // Throw an exception indicating that a non-recursive delete was\n        // specified for a non-empty folder.\n        throw new IOException(\"Non-recursive delete of non-empty directory \"\n            + f.toString());\n      }\n\n      // Delete all the files in the folder.\n      for (FileMetadata p : contents) {\n        // Tag on the directory name found as the suffix of the suffix of the\n        // parent directory to get the new absolute path.\n        String suffix \u003d p.getKey().substring(\n            p.getKey().lastIndexOf(PATH_DELIMITER));\n        if (!p.isDir()) {\n          store.delete(key + suffix);\n          instrumentation.fileDeleted();\n        } else {\n          // Recursively delete contents of the sub-folders. Notice this also\n          // deletes the blob for the directory.\n          if (!delete(new Path(f.toString() + suffix), true)) {\n            return false;\n          }\n        }\n      }\n      store.delete(key);\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        String parentKey \u003d pathToKey(parent);\n        if (!skipParentFolderLastModifidedTimeUpdate) {\n          store.updateFolderLastModifiedTime(parentKey, null);\n        }\n      }\n      instrumentation.directoryDeleted();\n    }\n\n    // File or directory was successfully deleted.\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
          "extendedDetails": {
            "oldValue": "[f-Path, recursive-boolean]",
            "newValue": "[f-Path, recursive-boolean, skipParentFolderLastModifidedTimeUpdate-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-10809. hadoop-azure: page blob support. Contributed by Dexter Bradshaw, Mostafa Elhemali, Eric Hanson, and Mike Liddell.\n",
          "commitDate": "08/10/14 2:20 PM",
          "commitName": "2217e2f8ff418b88eac6ad36cafe3a9795a11f40",
          "commitAuthor": "cnauroth",
          "commitDateOld": "19/09/14 11:33 AM",
          "commitNameOld": "9f03a7c018bb2c497cd0ef758f1a3e08e8163d06",
          "commitAuthorOld": "Allen Wittenauer",
          "daysBetweenCommits": 19.12,
          "commitsBetweenForRepo": 199,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,115 +1,120 @@\n-  public boolean delete(Path f, boolean recursive) throws IOException {\n+  public boolean delete(Path f, boolean recursive,\n+      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Deleting file: \" + f.toString());\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d store.retrieveMetadata(key);\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found an implicit parent directory while trying to\"\n                 + \" delete the file \" + f + \". Creating the directory blob for\"\n                 + \" it in \" + parentKey + \".\");\n           }\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n-          store.updateFolderLastModifiedTime(parentKey);\n+          if (!skipParentFolderLastModifidedTimeUpdate) {\n+            store.updateFolderLastModifiedTime(parentKey, null);\n+          }\n         }\n       }\n-      instrumentation.fileDeleted();\n       store.delete(key);\n+      instrumentation.fileDeleted();\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found an implicit parent directory while trying to\"\n                 + \" delete the directory \" + f\n                 + \". Creating the directory blob for\" + \" it in \" + parentKey\n                 + \".\");\n           }\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n       PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n           priorLastKey);\n       FileMetadata[] contents \u003d listing.getFiles();\n       if (!recursive \u0026\u0026 contents.length \u003e 0) {\n         // The folder is non-empty and recursive delete was not specified.\n         // Throw an exception indicating that a non-recursive delete was\n         // specified for a non-empty folder.\n         throw new IOException(\"Non-recursive delete of non-empty directory \"\n             + f.toString());\n       }\n \n       // Delete all the files in the folder.\n       for (FileMetadata p : contents) {\n         // Tag on the directory name found as the suffix of the suffix of the\n         // parent directory to get the new absolute path.\n         String suffix \u003d p.getKey().substring(\n             p.getKey().lastIndexOf(PATH_DELIMITER));\n         if (!p.isDir()) {\n           store.delete(key + suffix);\n           instrumentation.fileDeleted();\n         } else {\n           // Recursively delete contents of the sub-folders. Notice this also\n           // deletes the blob for the directory.\n           if (!delete(new Path(f.toString() + suffix), true)) {\n             return false;\n           }\n         }\n       }\n       store.delete(key);\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         String parentKey \u003d pathToKey(parent);\n-        store.updateFolderLastModifiedTime(parentKey);\n+        if (!skipParentFolderLastModifidedTimeUpdate) {\n+          store.updateFolderLastModifiedTime(parentKey, null);\n+        }\n       }\n       instrumentation.directoryDeleted();\n     }\n \n     // File or directory was successfully deleted.\n     return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean delete(Path f, boolean recursive,\n      boolean skipParentFolderLastModifidedTimeUpdate) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Deleting file: \" + f.toString());\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d store.retrieveMetadata(key);\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the file \" + f + \". Creating the directory blob for\"\n                + \" it in \" + parentKey + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          if (!skipParentFolderLastModifidedTimeUpdate) {\n            store.updateFolderLastModifiedTime(parentKey, null);\n          }\n        }\n      }\n      store.delete(key);\n      instrumentation.fileDeleted();\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the directory \" + f\n                + \". Creating the directory blob for\" + \" it in \" + parentKey\n                + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n      PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n          priorLastKey);\n      FileMetadata[] contents \u003d listing.getFiles();\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n        // The folder is non-empty and recursive delete was not specified.\n        // Throw an exception indicating that a non-recursive delete was\n        // specified for a non-empty folder.\n        throw new IOException(\"Non-recursive delete of non-empty directory \"\n            + f.toString());\n      }\n\n      // Delete all the files in the folder.\n      for (FileMetadata p : contents) {\n        // Tag on the directory name found as the suffix of the suffix of the\n        // parent directory to get the new absolute path.\n        String suffix \u003d p.getKey().substring(\n            p.getKey().lastIndexOf(PATH_DELIMITER));\n        if (!p.isDir()) {\n          store.delete(key + suffix);\n          instrumentation.fileDeleted();\n        } else {\n          // Recursively delete contents of the sub-folders. Notice this also\n          // deletes the blob for the directory.\n          if (!delete(new Path(f.toString() + suffix), true)) {\n            return false;\n          }\n        }\n      }\n      store.delete(key);\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        String parentKey \u003d pathToKey(parent);\n        if (!skipParentFolderLastModifidedTimeUpdate) {\n          store.updateFolderLastModifiedTime(parentKey, null);\n        }\n      }\n      instrumentation.directoryDeleted();\n    }\n\n    // File or directory was successfully deleted.\n    return true;\n  }",
          "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
          "extendedDetails": {}
        }
      ]
    },
    "0d91576ec31f63402f2db6107a04155368e2632d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10728. Metrics system for Windows Azure Storage Filesystem. Contributed by Dexter Bradshaw, Mostafa Elhemali, Xi Fang, Johannes Klein, David Lao, Mike Liddell, Chuan Liu, Lengning Liu, Ivan Mitic, Michael Rys, Alexander Stojanovic, Brian Swan, and Min Wei.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605187 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/06/14 1:52 PM",
      "commitName": "0d91576ec31f63402f2db6107a04155368e2632d",
      "commitAuthor": "Chris Nauroth",
      "commitDateOld": "20/06/14 11:36 AM",
      "commitNameOld": "61bf9f779919206296d2ce84a8a6b2d912709a59",
      "commitAuthorOld": "Chris Nauroth",
      "daysBetweenCommits": 4.09,
      "commitsBetweenForRepo": 30,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,115 @@\n   public boolean delete(Path f, boolean recursive) throws IOException {\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"Deleting file: \" + f.toString());\n     }\n \n     Path absolutePath \u003d makeAbsolute(f);\n     String key \u003d pathToKey(absolutePath);\n \n     // Capture the metadata for the path.\n     //\n     FileMetadata metaFile \u003d store.retrieveMetadata(key);\n \n     if (null \u003d\u003d metaFile) {\n       // The path to be deleted does not exist.\n       return false;\n     }\n \n     // The path exists, determine if it is a folder containing objects,\n     // an empty folder, or a simple file and take the appropriate actions.\n     if (!metaFile.isDir()) {\n       // The path specifies a file. We need to check the parent path\n       // to make sure it\u0027s a proper materialized directory before we\n       // delete the file. Otherwise we may get into a situation where\n       // the file we were deleting was the last one in an implicit directory\n       // (e.g. the blob store only contains the blob a/b and there\u0027s no\n       // corresponding directory blob a) and that would implicitly delete\n       // the directory as well, which is not correct.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {// Not root\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n         if (!parentMetadata.isDir()) {\n           // Invalid state: the parent path is actually a file. Throw.\n           throw new AzureException(\"File \" + f + \" has a parent directory \"\n               + parentPath + \" which is also a file. Can\u0027t resolve.\");\n         }\n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found an implicit parent directory while trying to\"\n                 + \" delete the file \" + f + \". Creating the directory blob for\"\n                 + \" it in \" + parentKey + \".\");\n           }\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         } else {\n           store.updateFolderLastModifiedTime(parentKey);\n         }\n       }\n+      instrumentation.fileDeleted();\n       store.delete(key);\n     } else {\n       // The path specifies a folder. Recursively delete all entries under the\n       // folder.\n       Path parentPath \u003d absolutePath.getParent();\n       if (parentPath.getParent() !\u003d null) {\n         String parentKey \u003d pathToKey(parentPath);\n         FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n \n         if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Found an implicit parent directory while trying to\"\n                 + \" delete the directory \" + f\n                 + \". Creating the directory blob for\" + \" it in \" + parentKey\n                 + \".\");\n           }\n           store.storeEmptyFolder(parentKey,\n               createPermissionStatus(FsPermission.getDefault()));\n         }\n       }\n \n       // List all the blobs in the current folder.\n       String priorLastKey \u003d null;\n       PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n           priorLastKey);\n       FileMetadata[] contents \u003d listing.getFiles();\n       if (!recursive \u0026\u0026 contents.length \u003e 0) {\n         // The folder is non-empty and recursive delete was not specified.\n         // Throw an exception indicating that a non-recursive delete was\n         // specified for a non-empty folder.\n         throw new IOException(\"Non-recursive delete of non-empty directory \"\n             + f.toString());\n       }\n \n       // Delete all the files in the folder.\n       for (FileMetadata p : contents) {\n         // Tag on the directory name found as the suffix of the suffix of the\n         // parent directory to get the new absolute path.\n         String suffix \u003d p.getKey().substring(\n             p.getKey().lastIndexOf(PATH_DELIMITER));\n         if (!p.isDir()) {\n           store.delete(key + suffix);\n+          instrumentation.fileDeleted();\n         } else {\n           // Recursively delete contents of the sub-folders. Notice this also\n           // deletes the blob for the directory.\n           if (!delete(new Path(f.toString() + suffix), true)) {\n             return false;\n           }\n         }\n       }\n       store.delete(key);\n \n       // Update parent directory last modified time\n       Path parent \u003d absolutePath.getParent();\n       if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n         String parentKey \u003d pathToKey(parent);\n         store.updateFolderLastModifiedTime(parentKey);\n       }\n+      instrumentation.directoryDeleted();\n     }\n \n     // File or directory was successfully deleted.\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Deleting file: \" + f.toString());\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d store.retrieveMetadata(key);\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the file \" + f + \". Creating the directory blob for\"\n                + \" it in \" + parentKey + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          store.updateFolderLastModifiedTime(parentKey);\n        }\n      }\n      instrumentation.fileDeleted();\n      store.delete(key);\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the directory \" + f\n                + \". Creating the directory blob for\" + \" it in \" + parentKey\n                + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n      PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n          priorLastKey);\n      FileMetadata[] contents \u003d listing.getFiles();\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n        // The folder is non-empty and recursive delete was not specified.\n        // Throw an exception indicating that a non-recursive delete was\n        // specified for a non-empty folder.\n        throw new IOException(\"Non-recursive delete of non-empty directory \"\n            + f.toString());\n      }\n\n      // Delete all the files in the folder.\n      for (FileMetadata p : contents) {\n        // Tag on the directory name found as the suffix of the suffix of the\n        // parent directory to get the new absolute path.\n        String suffix \u003d p.getKey().substring(\n            p.getKey().lastIndexOf(PATH_DELIMITER));\n        if (!p.isDir()) {\n          store.delete(key + suffix);\n          instrumentation.fileDeleted();\n        } else {\n          // Recursively delete contents of the sub-folders. Notice this also\n          // deletes the blob for the directory.\n          if (!delete(new Path(f.toString() + suffix), true)) {\n            return false;\n          }\n        }\n      }\n      store.delete(key);\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        String parentKey \u003d pathToKey(parent);\n        store.updateFolderLastModifiedTime(parentKey);\n      }\n      instrumentation.directoryDeleted();\n    }\n\n    // File or directory was successfully deleted.\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java",
      "extendedDetails": {}
    },
    "81bc395deb3ba00567dc067d6ca71bacf9e3bc82": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-9629. Support Windows Azure Storage - Blob as a file system in Hadoop. Contributed by Dexter Bradshaw, Mostafa Elhemali, Xi Fang, Johannes Klein, David Lao, Mike Liddell, Chuan Liu, Lengning Liu, Ivan Mitic, Michael Rys, Alexander Stojanovic, Brian Swan, and Min Wei.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1601781 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/06/14 3:26 PM",
      "commitName": "81bc395deb3ba00567dc067d6ca71bacf9e3bc82",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,112 @@\n+  public boolean delete(Path f, boolean recursive) throws IOException {\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Deleting file: \" + f.toString());\n+    }\n+\n+    Path absolutePath \u003d makeAbsolute(f);\n+    String key \u003d pathToKey(absolutePath);\n+\n+    // Capture the metadata for the path.\n+    //\n+    FileMetadata metaFile \u003d store.retrieveMetadata(key);\n+\n+    if (null \u003d\u003d metaFile) {\n+      // The path to be deleted does not exist.\n+      return false;\n+    }\n+\n+    // The path exists, determine if it is a folder containing objects,\n+    // an empty folder, or a simple file and take the appropriate actions.\n+    if (!metaFile.isDir()) {\n+      // The path specifies a file. We need to check the parent path\n+      // to make sure it\u0027s a proper materialized directory before we\n+      // delete the file. Otherwise we may get into a situation where\n+      // the file we were deleting was the last one in an implicit directory\n+      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n+      // corresponding directory blob a) and that would implicitly delete\n+      // the directory as well, which is not correct.\n+      Path parentPath \u003d absolutePath.getParent();\n+      if (parentPath.getParent() !\u003d null) {// Not root\n+        String parentKey \u003d pathToKey(parentPath);\n+        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n+        if (!parentMetadata.isDir()) {\n+          // Invalid state: the parent path is actually a file. Throw.\n+          throw new AzureException(\"File \" + f + \" has a parent directory \"\n+              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n+        }\n+        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Found an implicit parent directory while trying to\"\n+                + \" delete the file \" + f + \". Creating the directory blob for\"\n+                + \" it in \" + parentKey + \".\");\n+          }\n+          store.storeEmptyFolder(parentKey,\n+              createPermissionStatus(FsPermission.getDefault()));\n+        } else {\n+          store.updateFolderLastModifiedTime(parentKey);\n+        }\n+      }\n+      store.delete(key);\n+    } else {\n+      // The path specifies a folder. Recursively delete all entries under the\n+      // folder.\n+      Path parentPath \u003d absolutePath.getParent();\n+      if (parentPath.getParent() !\u003d null) {\n+        String parentKey \u003d pathToKey(parentPath);\n+        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n+\n+        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Found an implicit parent directory while trying to\"\n+                + \" delete the directory \" + f\n+                + \". Creating the directory blob for\" + \" it in \" + parentKey\n+                + \".\");\n+          }\n+          store.storeEmptyFolder(parentKey,\n+              createPermissionStatus(FsPermission.getDefault()));\n+        }\n+      }\n+\n+      // List all the blobs in the current folder.\n+      String priorLastKey \u003d null;\n+      PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n+          priorLastKey);\n+      FileMetadata[] contents \u003d listing.getFiles();\n+      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n+        // The folder is non-empty and recursive delete was not specified.\n+        // Throw an exception indicating that a non-recursive delete was\n+        // specified for a non-empty folder.\n+        throw new IOException(\"Non-recursive delete of non-empty directory \"\n+            + f.toString());\n+      }\n+\n+      // Delete all the files in the folder.\n+      for (FileMetadata p : contents) {\n+        // Tag on the directory name found as the suffix of the suffix of the\n+        // parent directory to get the new absolute path.\n+        String suffix \u003d p.getKey().substring(\n+            p.getKey().lastIndexOf(PATH_DELIMITER));\n+        if (!p.isDir()) {\n+          store.delete(key + suffix);\n+        } else {\n+          // Recursively delete contents of the sub-folders. Notice this also\n+          // deletes the blob for the directory.\n+          if (!delete(new Path(f.toString() + suffix), true)) {\n+            return false;\n+          }\n+        }\n+      }\n+      store.delete(key);\n+\n+      // Update parent directory last modified time\n+      Path parent \u003d absolutePath.getParent();\n+      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n+        String parentKey \u003d pathToKey(parent);\n+        store.updateFolderLastModifiedTime(parentKey);\n+      }\n+    }\n+\n+    // File or directory was successfully deleted.\n+    return true;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean delete(Path f, boolean recursive) throws IOException {\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Deleting file: \" + f.toString());\n    }\n\n    Path absolutePath \u003d makeAbsolute(f);\n    String key \u003d pathToKey(absolutePath);\n\n    // Capture the metadata for the path.\n    //\n    FileMetadata metaFile \u003d store.retrieveMetadata(key);\n\n    if (null \u003d\u003d metaFile) {\n      // The path to be deleted does not exist.\n      return false;\n    }\n\n    // The path exists, determine if it is a folder containing objects,\n    // an empty folder, or a simple file and take the appropriate actions.\n    if (!metaFile.isDir()) {\n      // The path specifies a file. We need to check the parent path\n      // to make sure it\u0027s a proper materialized directory before we\n      // delete the file. Otherwise we may get into a situation where\n      // the file we were deleting was the last one in an implicit directory\n      // (e.g. the blob store only contains the blob a/b and there\u0027s no\n      // corresponding directory blob a) and that would implicitly delete\n      // the directory as well, which is not correct.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {// Not root\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n        if (!parentMetadata.isDir()) {\n          // Invalid state: the parent path is actually a file. Throw.\n          throw new AzureException(\"File \" + f + \" has a parent directory \"\n              + parentPath + \" which is also a file. Can\u0027t resolve.\");\n        }\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the file \" + f + \". Creating the directory blob for\"\n                + \" it in \" + parentKey + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        } else {\n          store.updateFolderLastModifiedTime(parentKey);\n        }\n      }\n      store.delete(key);\n    } else {\n      // The path specifies a folder. Recursively delete all entries under the\n      // folder.\n      Path parentPath \u003d absolutePath.getParent();\n      if (parentPath.getParent() !\u003d null) {\n        String parentKey \u003d pathToKey(parentPath);\n        FileMetadata parentMetadata \u003d store.retrieveMetadata(parentKey);\n\n        if (parentMetadata.getBlobMaterialization() \u003d\u003d BlobMaterialization.Implicit) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Found an implicit parent directory while trying to\"\n                + \" delete the directory \" + f\n                + \". Creating the directory blob for\" + \" it in \" + parentKey\n                + \".\");\n          }\n          store.storeEmptyFolder(parentKey,\n              createPermissionStatus(FsPermission.getDefault()));\n        }\n      }\n\n      // List all the blobs in the current folder.\n      String priorLastKey \u003d null;\n      PartialListing listing \u003d store.listAll(key, AZURE_LIST_ALL, 1,\n          priorLastKey);\n      FileMetadata[] contents \u003d listing.getFiles();\n      if (!recursive \u0026\u0026 contents.length \u003e 0) {\n        // The folder is non-empty and recursive delete was not specified.\n        // Throw an exception indicating that a non-recursive delete was\n        // specified for a non-empty folder.\n        throw new IOException(\"Non-recursive delete of non-empty directory \"\n            + f.toString());\n      }\n\n      // Delete all the files in the folder.\n      for (FileMetadata p : contents) {\n        // Tag on the directory name found as the suffix of the suffix of the\n        // parent directory to get the new absolute path.\n        String suffix \u003d p.getKey().substring(\n            p.getKey().lastIndexOf(PATH_DELIMITER));\n        if (!p.isDir()) {\n          store.delete(key + suffix);\n        } else {\n          // Recursively delete contents of the sub-folders. Notice this also\n          // deletes the blob for the directory.\n          if (!delete(new Path(f.toString() + suffix), true)) {\n            return false;\n          }\n        }\n      }\n      store.delete(key);\n\n      // Update parent directory last modified time\n      Path parent \u003d absolutePath.getParent();\n      if (parent !\u003d null \u0026\u0026 parent.getParent() !\u003d null) { // not root\n        String parentKey \u003d pathToKey(parent);\n        store.updateFolderLastModifiedTime(parentKey);\n      }\n    }\n\n    // File or directory was successfully deleted.\n    return true;\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/NativeAzureFileSystem.java"
    }
  }
}