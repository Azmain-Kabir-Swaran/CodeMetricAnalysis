{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BlockManager.java",
  "functionName": "processFirstBlockReport",
  "functionId": "processFirstBlockReport___storageInfo-DatanodeStorageInfo(modifiers-final)__report-BlockListAsLongs(modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
  "functionStartLine": 2986,
  "functionEndLine": 3052,
  "numCommitsSeen": 617,
  "timeTaken": 19559,
  "changeHistory": [
    "d65df0f27395792c6e25f5e03b6ba1765e2ba925",
    "a7f085d6bf499edf23e650a4f7211c53a442da0e",
    "c304890c8c7782d835896859f5b7f60b96c306c0",
    "67c9780609f707c11626f05028ddfd28f1b878f1",
    "132478e805ba0f955345217b8ad87c2d17cccb2d",
    "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
    "86c92227fc56b6e06d879d250728e8dc8cbe98fe",
    "164cbe643988f878f0f4100a4de51783e5b6738e",
    "e535e0f05b5fbd087c93238deb888cc985254b4c",
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
    "c17439c2ddd921b63b1635e6f1cba634b8da8557",
    "4928f5473394981829e5ffd4b16ea0801baf5c45",
    "51ea117f883f9c049de58987dc66e07e71a68ee4",
    "46dac3595fa2e2c14290154c3c12ea799ee5043d",
    "9f2f583f401189c3f4a2687795a9e3e0b288322b",
    "ba9371492036983a9899398907ab41fe548f29b3",
    "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8",
    "281d47a96937bc329b1b4051ffcb8f5fcac98354",
    "f9427f1760cce7e0befc3e066cebd0912652a411",
    "d324164a51a43d72c02567248bd9f0f12b244a40",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
    "45db4d204b796eee6dd0e39d3cc94b70c47028d4"
  ],
  "changeHistoryShort": {
    "d65df0f27395792c6e25f5e03b6ba1765e2ba925": "Ymodifierchange",
    "a7f085d6bf499edf23e650a4f7211c53a442da0e": "Ybodychange",
    "c304890c8c7782d835896859f5b7f60b96c306c0": "Ybodychange",
    "67c9780609f707c11626f05028ddfd28f1b878f1": "Ybodychange",
    "132478e805ba0f955345217b8ad87c2d17cccb2d": "Ybodychange",
    "a49cc74b4c72195dee1dfb6f9548e5e411dff553": "Ybodychange",
    "86c92227fc56b6e06d879d250728e8dc8cbe98fe": "Ybodychange",
    "164cbe643988f878f0f4100a4de51783e5b6738e": "Ybodychange",
    "e535e0f05b5fbd087c93238deb888cc985254b4c": "Ybodychange",
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835": "Ybodychange",
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046": "Ybodychange",
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5": "Ybodychange",
    "c17439c2ddd921b63b1635e6f1cba634b8da8557": "Ybodychange",
    "4928f5473394981829e5ffd4b16ea0801baf5c45": "Ybodychange",
    "51ea117f883f9c049de58987dc66e07e71a68ee4": "Ybodychange",
    "46dac3595fa2e2c14290154c3c12ea799ee5043d": "Ybodychange",
    "9f2f583f401189c3f4a2687795a9e3e0b288322b": "Ybodychange",
    "ba9371492036983a9899398907ab41fe548f29b3": "Ybodychange",
    "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8": "Ybodychange",
    "281d47a96937bc329b1b4051ffcb8f5fcac98354": "Ybodychange",
    "f9427f1760cce7e0befc3e066cebd0912652a411": "Ybodychange",
    "d324164a51a43d72c02567248bd9f0f12b244a40": "Ybodychange",
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": "Ybodychange",
    "45db4d204b796eee6dd0e39d3cc94b70c47028d4": "Ymultichange(Yparameterchange,Ybodychange)"
  },
  "changeHistoryDetails": {
    "d65df0f27395792c6e25f5e03b6ba1765e2ba925": {
      "type": "Ymodifierchange",
      "commitMessage": "HDFS-11190. [READ] Namenode support for data stored in external stores.\n",
      "commitDate": "15/12/17 5:51 PM",
      "commitName": "d65df0f27395792c6e25f5e03b6ba1765e2ba925",
      "commitAuthor": "Virajith Jalaparti",
      "commitDateOld": "05/12/17 8:48 PM",
      "commitNameOld": "56b1ff80dd9fbcde8d21a604eff0babb3a16418f",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 9.88,
      "commitsBetweenForRepo": 75,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,67 @@\n-  private void processFirstBlockReport(\n+  void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block {} on {} size {} replicaState \u003d {}\",\n             iblk.getBlockName(), storageInfo.getDatanodeDescriptor(),\n             iblk.getNumBytes(), reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026 isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n \n       BlockInfo storedBlock \u003d getStoredBlock(iblk);\n \n       // If block does not belong to any file, we check if it violates\n       // an integrity assumption of Name node\n       if (storedBlock \u003d\u003d null) {\n         bmSafeMode.checkBlocksWithFutureGS(iblk);\n         continue;\n       }\n \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         storedBlock.getUnderConstructionFeature()\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         if (namesystem.isInSnapshot(storedBlock.getBlockCollectionId())) {\n           int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n               .getNumExpectedLocations();\n           bmSafeMode.incrementSafeBlockCount(numOfReplicas, storedBlock);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block {} on {} size {} replicaState \u003d {}\",\n            iblk.getBlockName(), storageInfo.getDatanodeDescriptor(),\n            iblk.getNumBytes(), reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026 isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n\n      // If block does not belong to any file, we check if it violates\n      // an integrity assumption of Name node\n      if (storedBlock \u003d\u003d null) {\n        bmSafeMode.checkBlocksWithFutureGS(iblk);\n        continue;\n      }\n\n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        storedBlock.getUnderConstructionFeature()\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        if (namesystem.isInSnapshot(storedBlock.getBlockCollectionId())) {\n          int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n              .getNumExpectedLocations();\n          bmSafeMode.incrementSafeBlockCount(numOfReplicas, storedBlock);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {
        "oldValue": "[private]",
        "newValue": "[]"
      }
    },
    "a7f085d6bf499edf23e650a4f7211c53a442da0e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11832. Switch leftover logs to slf4j format in BlockManager.java. Contributed by Hui Xu and Chen Liang.\n",
      "commitDate": "29/05/17 1:30 AM",
      "commitName": "a7f085d6bf499edf23e650a4f7211c53a442da0e",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "25/05/17 7:35 AM",
      "commitNameOld": "2e41f8803dd46d1bab16c1b206c71be72ea260a1",
      "commitAuthorOld": "Brahma Reddy Battula",
      "daysBetweenCommits": 3.75,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,67 +1,67 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n-            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n-            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n+        LOG.debug(\"Initial report of block {} on {} size {} replicaState \u003d {}\",\n+            iblk.getBlockName(), storageInfo.getDatanodeDescriptor(),\n+            iblk.getNumBytes(), reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026 isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n \n       BlockInfo storedBlock \u003d getStoredBlock(iblk);\n \n       // If block does not belong to any file, we check if it violates\n       // an integrity assumption of Name node\n       if (storedBlock \u003d\u003d null) {\n         bmSafeMode.checkBlocksWithFutureGS(iblk);\n         continue;\n       }\n \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         storedBlock.getUnderConstructionFeature()\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         if (namesystem.isInSnapshot(storedBlock.getBlockCollectionId())) {\n           int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n               .getNumExpectedLocations();\n           bmSafeMode.incrementSafeBlockCount(numOfReplicas, storedBlock);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block {} on {} size {} replicaState \u003d {}\",\n            iblk.getBlockName(), storageInfo.getDatanodeDescriptor(),\n            iblk.getNumBytes(), reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026 isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n\n      // If block does not belong to any file, we check if it violates\n      // an integrity assumption of Name node\n      if (storedBlock \u003d\u003d null) {\n        bmSafeMode.checkBlocksWithFutureGS(iblk);\n        continue;\n      }\n\n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        storedBlock.getUnderConstructionFeature()\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        if (namesystem.isInSnapshot(storedBlock.getBlockCollectionId())) {\n          int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n              .getNumExpectedLocations();\n          bmSafeMode.incrementSafeBlockCount(numOfReplicas, storedBlock);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "c304890c8c7782d835896859f5b7f60b96c306c0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9542. Move BlockIdManager from FSNamesystem to BlockManager. Contributed by Jing Zhao.\n",
      "commitDate": "21/01/16 11:13 AM",
      "commitName": "c304890c8c7782d835896859f5b7f60b96c306c0",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "06/01/16 9:57 PM",
      "commitNameOld": "34cd7cd76505d01ec251e30837c94ab03319a0c1",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 14.55,
      "commitsBetweenForRepo": 109,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,67 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n-      if (shouldPostponeBlocksFromFuture \u0026\u0026\n-          namesystem.isGenStampInFuture(iblk)) {\n+      if (shouldPostponeBlocksFromFuture \u0026\u0026 isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n \n       BlockInfo storedBlock \u003d getStoredBlock(iblk);\n \n       // If block does not belong to any file, we check if it violates\n       // an integrity assumption of Name node\n       if (storedBlock \u003d\u003d null) {\n         bmSafeMode.checkBlocksWithFutureGS(iblk);\n         continue;\n       }\n \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         storedBlock.getUnderConstructionFeature()\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         if (namesystem.isInSnapshot(storedBlock.getBlockCollectionId())) {\n           int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n               .getNumExpectedLocations();\n           bmSafeMode.incrementSafeBlockCount(numOfReplicas, storedBlock);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026 isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n\n      // If block does not belong to any file, we check if it violates\n      // an integrity assumption of Name node\n      if (storedBlock \u003d\u003d null) {\n        bmSafeMode.checkBlocksWithFutureGS(iblk);\n        continue;\n      }\n\n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        storedBlock.getUnderConstructionFeature()\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        if (namesystem.isInSnapshot(storedBlock.getBlockCollectionId())) {\n          int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n              .getNumExpectedLocations();\n          bmSafeMode.incrementSafeBlockCount(numOfReplicas, storedBlock);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "67c9780609f707c11626f05028ddfd28f1b878f1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9498. Move code that tracks blocks with future generation stamps to BlockManagerSafeMode. (Contributed by Mingliang Liu)\n",
      "commitDate": "06/01/16 10:30 AM",
      "commitName": "67c9780609f707c11626f05028ddfd28f1b878f1",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "21/12/15 10:47 PM",
      "commitNameOld": "70d6f201260086a3f12beaa317fede2a99639fef",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 15.49,
      "commitsBetweenForRepo": 48,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,68 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n \n       BlockInfo storedBlock \u003d getStoredBlock(iblk);\n \n       // If block does not belong to any file, we check if it violates\n       // an integrity assumption of Name node\n       if (storedBlock \u003d\u003d null) {\n-        if (namesystem.isInStartupSafeMode()\n-            \u0026\u0026 !shouldPostponeBlocksFromFuture\n-            \u0026\u0026 !inRollBack\n-            \u0026\u0026 namesystem.isGenStampInFuture(iblk)) {\n-          numberOfBytesInFutureBlocks.addAndGet(iblk.getBytesOnDisk());\n-        }\n+        bmSafeMode.checkBlocksWithFutureGS(iblk);\n         continue;\n       }\n \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         storedBlock.getUnderConstructionFeature()\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         if (namesystem.isInSnapshot(storedBlock.getBlockCollectionId())) {\n           int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n               .getNumExpectedLocations();\n           bmSafeMode.incrementSafeBlockCount(numOfReplicas, storedBlock);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n\n      // If block does not belong to any file, we check if it violates\n      // an integrity assumption of Name node\n      if (storedBlock \u003d\u003d null) {\n        bmSafeMode.checkBlocksWithFutureGS(iblk);\n        continue;\n      }\n\n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        storedBlock.getUnderConstructionFeature()\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        if (namesystem.isInSnapshot(storedBlock.getBlockCollectionId())) {\n          int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n              .getNumExpectedLocations();\n          bmSafeMode.incrementSafeBlockCount(numOfReplicas, storedBlock);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "132478e805ba0f955345217b8ad87c2d17cccb2d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9527. The return type of FSNamesystem.getBlockCollection should be changed to INodeFile.\n",
      "commitDate": "09/12/15 5:55 PM",
      "commitName": "132478e805ba0f955345217b8ad87c2d17cccb2d",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "01/12/15 4:09 PM",
      "commitNameOld": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 8.07,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n \n       BlockInfo storedBlock \u003d getStoredBlock(iblk);\n \n       // If block does not belong to any file, we check if it violates\n       // an integrity assumption of Name node\n       if (storedBlock \u003d\u003d null) {\n         if (namesystem.isInStartupSafeMode()\n             \u0026\u0026 !shouldPostponeBlocksFromFuture\n             \u0026\u0026 !inRollBack\n             \u0026\u0026 namesystem.isGenStampInFuture(iblk)) {\n           numberOfBytesInFutureBlocks.addAndGet(iblk.getBytesOnDisk());\n         }\n         continue;\n       }\n \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         storedBlock.getUnderConstructionFeature()\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n-        if (namesystem.isInSnapshot(storedBlock)) {\n+        if (namesystem.isInSnapshot(storedBlock.getBlockCollectionId())) {\n           int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n               .getNumExpectedLocations();\n           bmSafeMode.incrementSafeBlockCount(numOfReplicas, storedBlock);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n\n      // If block does not belong to any file, we check if it violates\n      // an integrity assumption of Name node\n      if (storedBlock \u003d\u003d null) {\n        if (namesystem.isInStartupSafeMode()\n            \u0026\u0026 !shouldPostponeBlocksFromFuture\n            \u0026\u0026 !inRollBack\n            \u0026\u0026 namesystem.isGenStampInFuture(iblk)) {\n          numberOfBytesInFutureBlocks.addAndGet(iblk.getBytesOnDisk());\n        }\n        continue;\n      }\n\n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        storedBlock.getUnderConstructionFeature()\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        if (namesystem.isInSnapshot(storedBlock.getBlockCollectionId())) {\n          int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n              .getNumExpectedLocations();\n          bmSafeMode.incrementSafeBlockCount(numOfReplicas, storedBlock);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "a49cc74b4c72195dee1dfb6f9548e5e411dff553": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9129. Move the safemode block count into BlockManager. Contributed by Mingliang Liu.\n",
      "commitDate": "01/12/15 4:09 PM",
      "commitName": "a49cc74b4c72195dee1dfb6f9548e5e411dff553",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "01/12/15 1:05 PM",
      "commitNameOld": "830eb252aaa4fec7ef2ec38cb66f669e8e1ecaa5",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.13,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n \n       BlockInfo storedBlock \u003d getStoredBlock(iblk);\n \n       // If block does not belong to any file, we check if it violates\n       // an integrity assumption of Name node\n       if (storedBlock \u003d\u003d null) {\n         if (namesystem.isInStartupSafeMode()\n             \u0026\u0026 !shouldPostponeBlocksFromFuture\n             \u0026\u0026 !inRollBack\n             \u0026\u0026 namesystem.isGenStampInFuture(iblk)) {\n           numberOfBytesInFutureBlocks.addAndGet(iblk.getBytesOnDisk());\n         }\n         continue;\n       }\n \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         storedBlock.getUnderConstructionFeature()\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         if (namesystem.isInSnapshot(storedBlock)) {\n           int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n               .getNumExpectedLocations();\n-          namesystem.incrementSafeBlockCount(numOfReplicas, storedBlock);\n+          bmSafeMode.incrementSafeBlockCount(numOfReplicas, storedBlock);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n\n      // If block does not belong to any file, we check if it violates\n      // an integrity assumption of Name node\n      if (storedBlock \u003d\u003d null) {\n        if (namesystem.isInStartupSafeMode()\n            \u0026\u0026 !shouldPostponeBlocksFromFuture\n            \u0026\u0026 !inRollBack\n            \u0026\u0026 namesystem.isGenStampInFuture(iblk)) {\n          numberOfBytesInFutureBlocks.addAndGet(iblk.getBytesOnDisk());\n        }\n        continue;\n      }\n\n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        storedBlock.getUnderConstructionFeature()\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        if (namesystem.isInSnapshot(storedBlock)) {\n          int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n              .getNumExpectedLocations();\n          bmSafeMode.incrementSafeBlockCount(numOfReplicas, storedBlock);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "86c92227fc56b6e06d879d250728e8dc8cbe98fe": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4015. Safemode should count and report orphaned blocks. (Contributed by Anu Engineer)\n",
      "commitDate": "23/10/15 6:07 PM",
      "commitName": "86c92227fc56b6e06d879d250728e8dc8cbe98fe",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "21/10/15 8:06 AM",
      "commitNameOld": "e27c2ae8bafc94f18eb38f5d839dcef5652d424e",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 2.42,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,73 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n \n       BlockInfo storedBlock \u003d getStoredBlock(iblk);\n-      // If block does not belong to any file, we are done.\n-      if (storedBlock \u003d\u003d null) continue;\n-      \n+\n+      // If block does not belong to any file, we check if it violates\n+      // an integrity assumption of Name node\n+      if (storedBlock \u003d\u003d null) {\n+        if (namesystem.isInStartupSafeMode()\n+            \u0026\u0026 !shouldPostponeBlocksFromFuture\n+            \u0026\u0026 !inRollBack\n+            \u0026\u0026 namesystem.isGenStampInFuture(iblk)) {\n+          numberOfBytesInFutureBlocks.addAndGet(iblk.getBytesOnDisk());\n+        }\n+        continue;\n+      }\n+\n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         storedBlock.getUnderConstructionFeature()\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         if (namesystem.isInSnapshot(storedBlock)) {\n           int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n               .getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas, storedBlock);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n\n      // If block does not belong to any file, we check if it violates\n      // an integrity assumption of Name node\n      if (storedBlock \u003d\u003d null) {\n        if (namesystem.isInStartupSafeMode()\n            \u0026\u0026 !shouldPostponeBlocksFromFuture\n            \u0026\u0026 !inRollBack\n            \u0026\u0026 namesystem.isGenStampInFuture(iblk)) {\n          numberOfBytesInFutureBlocks.addAndGet(iblk.getBytesOnDisk());\n        }\n        continue;\n      }\n\n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        storedBlock.getUnderConstructionFeature()\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        if (namesystem.isInSnapshot(storedBlock)) {\n          int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n              .getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas, storedBlock);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "164cbe643988f878f0f4100a4de51783e5b6738e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8909. Erasure coding: update BlockInfoContiguousUC and BlockInfoStripedUC to use BlockUnderConstructionFeature. Contributed by Jing Zhao.\n",
      "commitDate": "27/08/15 1:02 AM",
      "commitName": "164cbe643988f878f0f4100a4de51783e5b6738e",
      "commitAuthor": "Walter Su",
      "commitDateOld": "24/08/15 12:59 PM",
      "commitNameOld": "6b6a63bbbda920315d3d24b61ed3344a78a981b6",
      "commitAuthorOld": "",
      "daysBetweenCommits": 2.5,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,63 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n \n       BlockInfo storedBlock \u003d getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n-        final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)storedBlock;\n-        uc.addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n+        storedBlock.getUnderConstructionFeature()\n+            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         if (namesystem.isInSnapshot(storedBlock.getBlockCollection())) {\n-          int numOfReplicas \u003d uc.getNumExpectedLocations();\n+          int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n+              .getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas, storedBlock);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n\n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        storedBlock.getUnderConstructionFeature()\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        if (namesystem.isInSnapshot(storedBlock.getBlockCollection())) {\n          int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n              .getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas, storedBlock);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "e535e0f05b5fbd087c93238deb888cc985254b4c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8801. Convert BlockInfoUnderConstruction as a feature. Contributed by Jing Zhao.\n",
      "commitDate": "17/08/15 11:28 AM",
      "commitName": "e535e0f05b5fbd087c93238deb888cc985254b4c",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "06/08/15 10:21 AM",
      "commitNameOld": "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 11.05,
      "commitsBetweenForRepo": 46,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,63 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n       BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n-        ((BlockInfoContiguousUnderConstruction)storedBlock)\n+        storedBlock.getUnderConstructionFeature()\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n-        BlockInfoContiguousUnderConstruction blockUC \u003d\n-            (BlockInfoContiguousUnderConstruction) storedBlock;\n-        if (namesystem.isInSnapshot(blockUC)) {\n-          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n+        if (namesystem.isInSnapshot(storedBlock)) {\n+          int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n+              .getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        storedBlock.getUnderConstructionFeature()\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        if (namesystem.isInSnapshot(storedBlock)) {\n          int numOfReplicas \u003d storedBlock.getUnderConstructionFeature()\n              .getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "f4c523b69ba55b1fd35e8995c3011a9f546ac835": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang.\"\n\nThis reverts commit c17439c2ddd921b63b1635e6f1cba634b8da8557.\n",
      "commitDate": "06/08/15 10:21 AM",
      "commitName": "f4c523b69ba55b1fd35e8995c3011a9f546ac835",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "06/08/15 10:21 AM",
      "commitNameOld": "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n       BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n-        ((BlockInfoUnderConstruction)storedBlock)\n+        ((BlockInfoContiguousUnderConstruction)storedBlock)\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n-        BlockInfoUnderConstruction blockUC \u003d\n-            (BlockInfoUnderConstruction) storedBlock;\n+        BlockInfoContiguousUnderConstruction blockUC \u003d\n+            (BlockInfoContiguousUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoContiguousUnderConstruction)storedBlock)\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoContiguousUnderConstruction blockUC \u003d\n            (BlockInfoContiguousUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "663eba0ab1c73b45f98e46ffc87ad8fd91584046": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-8623. Refactor NameNode handling of invalid, corrupt, and under-recovery blocks. Contributed by Zhe Zhang.\"\n\nThis reverts commit de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5.\n",
      "commitDate": "06/08/15 10:21 AM",
      "commitName": "663eba0ab1c73b45f98e46ffc87ad8fd91584046",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "31/07/15 4:15 PM",
      "commitNameOld": "d311a38a6b32bbb210bd8748cfb65463e9c0740e",
      "commitAuthorOld": "Xiaoyu Yao",
      "daysBetweenCommits": 5.75,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n-      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n+      BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         ((BlockInfoUnderConstruction)storedBlock)\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         BlockInfoUnderConstruction blockUC \u003d\n             (BlockInfoUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n-        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n+        addStoredBlockImmediate(storedBlock, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoUnderConstruction)storedBlock)\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoUnderConstruction blockUC \u003d\n            (BlockInfoUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8623. Refactor NameNode handling of invalid, corrupt, and under-recovery blocks. Contributed by Zhe Zhang.\n",
      "commitDate": "26/06/15 10:49 AM",
      "commitName": "de480d6c8945bd8b5b00e8657b7a72ce8dd9b6b5",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "24/06/15 2:42 PM",
      "commitNameOld": "afe9ea3c12e1f5a71922400eadb642960bc87ca1",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 1.84,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n-      BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n+      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         ((BlockInfoUnderConstruction)storedBlock)\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         BlockInfoUnderConstruction blockUC \u003d\n             (BlockInfoUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n-        addStoredBlockImmediate(storedBlock, storageInfo);\n+        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoUnderConstruction)storedBlock)\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoUnderConstruction blockUC \u003d\n            (BlockInfoUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "c17439c2ddd921b63b1635e6f1cba634b8da8557": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8499. Refactor BlockInfo class hierarchy with static helper class. Contributed by Zhe Zhang.\n",
      "commitDate": "12/06/15 11:38 AM",
      "commitName": "c17439c2ddd921b63b1635e6f1cba634b8da8557",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "12/06/15 11:17 AM",
      "commitNameOld": "12b5b06c063d93e6c683c9b6fac9a96912f59e59",
      "commitAuthorOld": "Colin Patrick Mccabe",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n       BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n-        ((BlockInfoContiguousUnderConstruction)storedBlock)\n+        ((BlockInfoUnderConstruction)storedBlock)\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n-        BlockInfoContiguousUnderConstruction blockUC \u003d\n-            (BlockInfoContiguousUnderConstruction) storedBlock;\n+        BlockInfoUnderConstruction blockUC \u003d\n+            (BlockInfoUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoUnderConstruction)storedBlock)\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoUnderConstruction blockUC \u003d\n            (BlockInfoUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "4928f5473394981829e5ffd4b16ea0801baf5c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8482. Rename BlockInfoContiguous to BlockInfo. Contributed by Zhe Zhang.\n",
      "commitDate": "27/05/15 3:42 PM",
      "commitName": "4928f5473394981829e5ffd4b16ea0801baf5c45",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "19/05/15 11:05 AM",
      "commitNameOld": "8860e352c394372e4eb3ebdf82ea899567f34e4e",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 8.19,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n-      BlockInfoContiguous storedBlock \u003d blocksMap.getStoredBlock(iblk);\n+      BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         ((BlockInfoContiguousUnderConstruction)storedBlock)\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         BlockInfoContiguousUnderConstruction blockUC \u003d\n             (BlockInfoContiguousUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoContiguousUnderConstruction)storedBlock)\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoContiguousUnderConstruction blockUC \u003d\n            (BlockInfoContiguousUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "51ea117f883f9c049de58987dc66e07e71a68ee4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8355. Erasure Coding: Refactor BlockInfo and BlockInfoUnderConstruction. Contributed by Tsz Wo Nicholas Sze.\n",
      "commitDate": "26/05/15 12:01 PM",
      "commitName": "51ea117f883f9c049de58987dc66e07e71a68ee4",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:59 AM",
      "commitNameOld": "436c14855aef58a551d5cab91eba6e88775c6797",
      "commitAuthorOld": "Uma Maheswara Rao G",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,62 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n       BlockInfo storedBlock \u003d getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n-        BlockInfo.addReplica(storedBlock, storageInfo, iblk, reportedState);\n+        final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)storedBlock;\n+        uc.addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         if (namesystem.isInSnapshot(storedBlock.getBlockCollection())) {\n-          int numOfReplicas \u003d BlockInfo.getNumExpectedLocations(storedBlock);\n+          int numOfReplicas \u003d uc.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas, storedBlock);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        final BlockInfoUnderConstruction uc \u003d (BlockInfoUnderConstruction)storedBlock;\n        uc.addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        if (namesystem.isInSnapshot(storedBlock.getBlockCollection())) {\n          int numOfReplicas \u003d uc.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas, storedBlock);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "46dac3595fa2e2c14290154c3c12ea799ee5043d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7864. Erasure Coding: Update safemode calculation for striped blocks. Contributed by GAO Rui.\n",
      "commitDate": "26/05/15 11:43 AM",
      "commitName": "46dac3595fa2e2c14290154c3c12ea799ee5043d",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:43 AM",
      "commitNameOld": "544f75d6512fefd0e36f24a35e6b7472ca7bf301",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n       BlockInfo storedBlock \u003d getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         BlockInfo.addReplica(storedBlock, storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         if (namesystem.isInSnapshot(storedBlock.getBlockCollection())) {\n           int numOfReplicas \u003d BlockInfo.getNumExpectedLocations(storedBlock);\n-          namesystem.incrementSafeBlockCount(numOfReplicas);\n+          namesystem.incrementSafeBlockCount(numOfReplicas, storedBlock);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        BlockInfo.addReplica(storedBlock, storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        if (namesystem.isInSnapshot(storedBlock.getBlockCollection())) {\n          int numOfReplicas \u003d BlockInfo.getNumExpectedLocations(storedBlock);\n          namesystem.incrementSafeBlockCount(numOfReplicas, storedBlock);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "9f2f583f401189c3f4a2687795a9e3e0b288322b": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7749. Erasure Coding: Add striped block support in INodeFile. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:07 AM",
      "commitName": "9f2f583f401189c3f4a2687795a9e3e0b288322b",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:07 AM",
      "commitNameOld": "ba9371492036983a9899398907ab41fe548f29b3",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,61 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n       BlockInfo storedBlock \u003d getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n-        ((BlockInfoContiguousUnderConstruction) storedBlock)\n-            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n+        BlockInfo.addReplica(storedBlock, storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n-        BlockInfoContiguousUnderConstruction blockUC \u003d\n-            (BlockInfoContiguousUnderConstruction) storedBlock;\n-        if (namesystem.isInSnapshot(blockUC)) {\n-          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n+        if (namesystem.isInSnapshot(storedBlock.getBlockCollection())) {\n+          int numOfReplicas \u003d BlockInfo.getNumExpectedLocations(storedBlock);\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        BlockInfo.addReplica(storedBlock, storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        if (namesystem.isInSnapshot(storedBlock.getBlockCollection())) {\n          int numOfReplicas \u003d BlockInfo.getNumExpectedLocations(storedBlock);\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "ba9371492036983a9899398907ab41fe548f29b3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7716. Erasure Coding: extend BlockInfo to handle EC info. Contributed by Jing Zhao.\n",
      "commitDate": "26/05/15 11:07 AM",
      "commitName": "ba9371492036983a9899398907ab41fe548f29b3",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "26/05/15 11:03 AM",
      "commitNameOld": "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n-      BlockInfoContiguous storedBlock \u003d getStoredBlock(iblk);\n+      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n-        ((BlockInfoContiguousUnderConstruction)storedBlock)\n+        ((BlockInfoContiguousUnderConstruction) storedBlock)\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         BlockInfoContiguousUnderConstruction blockUC \u003d\n             (BlockInfoContiguousUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n-        addStoredBlockImmediate(storedBlock, storageInfo);\n+        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfo storedBlock \u003d getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoContiguousUnderConstruction) storedBlock)\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoContiguousUnderConstruction blockUC \u003d\n            (BlockInfoContiguousUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, iblk, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7652. Process block reports for erasure coded blocks. Contributed by Zhe Zhang\n",
      "commitDate": "26/05/15 11:03 AM",
      "commitName": "0c1da5a0300f015a7e39f2b40a73fb06c65a78c8",
      "commitAuthor": "Zhe Zhang",
      "commitDateOld": "19/05/15 11:05 AM",
      "commitNameOld": "8860e352c394372e4eb3ebdf82ea899567f34e4e",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 7.0,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n             + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n             iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n       }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n-      BlockInfoContiguous storedBlock \u003d blocksMap.getStoredBlock(iblk);\n+      BlockInfoContiguous storedBlock \u003d getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         ((BlockInfoContiguousUnderConstruction)storedBlock)\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         BlockInfoContiguousUnderConstruction blockUC \u003d\n             (BlockInfoContiguousUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfoContiguous storedBlock \u003d getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoContiguousUnderConstruction)storedBlock)\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoContiguousUnderConstruction blockUC \u003d\n            (BlockInfoContiguousUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "281d47a96937bc329b1b4051ffcb8f5fcac98354": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8380. Always call addStoredBlock on blocks which have been shifted from one storage to another (cmccabe)\n",
      "commitDate": "13/05/15 2:29 PM",
      "commitName": "281d47a96937bc329b1b4051ffcb8f5fcac98354",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "12/05/15 6:29 AM",
      "commitNameOld": "6d5da9484185ca9f585195d6da069b9cd5be4044",
      "commitAuthorOld": "yliu",
      "daysBetweenCommits": 1.33,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,64 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n-      \n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n+            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n+            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n+      }\n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n       BlockInfoContiguous storedBlock \u003d blocksMap.getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         ((BlockInfoContiguousUnderConstruction)storedBlock)\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         BlockInfoContiguousUnderConstruction blockUC \u003d\n             (BlockInfoContiguousUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Initial report of block \" + iblk.getBlockName()\n            + \" on \" + storageInfo.getDatanodeDescriptor() + \" size \" +\n            iblk.getNumBytes() + \" replicaState \u003d \" + reportedState);\n      }\n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfoContiguous storedBlock \u003d blocksMap.getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoContiguousUnderConstruction)storedBlock)\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoContiguousUnderConstruction blockUC \u003d\n            (BlockInfoContiguousUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "f9427f1760cce7e0befc3e066cebd0912652a411": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7980. Incremental BlockReport will dramatically slow down namenode startup.  Contributed by Walter Su\n",
      "commitDate": "07/05/15 11:36 AM",
      "commitName": "f9427f1760cce7e0befc3e066cebd0912652a411",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "01/05/15 8:42 AM",
      "commitNameOld": "279958b772c25e0633bd967828b7d27d5c0a6a56",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 6.12,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n-    assert (storageInfo.numBlocks() \u003d\u003d 0);\n+    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n \n     for (BlockReportReplica iblk : report) {\n       ReplicaState reportedState \u003d iblk.getState();\n       \n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n       BlockInfoContiguous storedBlock \u003d blocksMap.getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         ((BlockInfoContiguousUnderConstruction)storedBlock)\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         BlockInfoContiguousUnderConstruction blockUC \u003d\n             (BlockInfoContiguousUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.getBlockReportCount() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n      \n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfoContiguous storedBlock \u003d blocksMap.getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoContiguousUnderConstruction)storedBlock)\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoContiguousUnderConstruction blockUC \u003d\n            (BlockInfoContiguousUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "d324164a51a43d72c02567248bd9f0f12b244a40": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7435. PB encoding of block reports is very inefficient. Contributed by Daryn Sharp.\n",
      "commitDate": "13/03/15 12:23 PM",
      "commitName": "d324164a51a43d72c02567248bd9f0f12b244a40",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "08/03/15 6:31 PM",
      "commitNameOld": "6ee0d32b98bc3aa5ed42859f1325d5a14fd1722a",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 4.74,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,59 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.numBlocks() \u003d\u003d 0);\n-    BlockReportIterator itBR \u003d report.getBlockReportIterator();\n \n-    while(itBR.hasNext()) {\n-      Block iblk \u003d itBR.next();\n-      ReplicaState reportedState \u003d itBR.getCurrentReplicaState();\n+    for (BlockReportReplica iblk : report) {\n+      ReplicaState reportedState \u003d iblk.getState();\n       \n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n       BlockInfoContiguous storedBlock \u003d blocksMap.getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         ((BlockInfoContiguousUnderConstruction)storedBlock)\n             .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         BlockInfoContiguousUnderConstruction blockUC \u003d\n             (BlockInfoContiguousUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.numBlocks() \u003d\u003d 0);\n\n    for (BlockReportReplica iblk : report) {\n      ReplicaState reportedState \u003d iblk.getState();\n      \n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfoContiguous storedBlock \u003d blocksMap.getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoContiguousUnderConstruction)storedBlock)\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoContiguousUnderConstruction blockUC \u003d\n            (BlockInfoContiguousUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "1382ae525c67bf95d8f3a436b547dbc72cfbb177": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7743. Code cleanup of BlockInfo and rename BlockInfo to BlockInfoContiguous. Contributed by Jing Zhao.\n",
      "commitDate": "08/02/15 11:51 AM",
      "commitName": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "04/02/15 11:31 AM",
      "commitNameOld": "9175105eeaecf0a1d60b57989b73ce45cee4689b",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 4.01,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,61 @@\n   private void processFirstBlockReport(\n       final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n     assert (storageInfo.numBlocks() \u003d\u003d 0);\n     BlockReportIterator itBR \u003d report.getBlockReportIterator();\n \n     while(itBR.hasNext()) {\n       Block iblk \u003d itBR.next();\n       ReplicaState reportedState \u003d itBR.getCurrentReplicaState();\n       \n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n         queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n-      BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n+      BlockInfoContiguous storedBlock \u003d blocksMap.getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n           iblk, reportedState, storedBlock, ucState,\n           storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n           queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n           markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n-        ((BlockInfoUnderConstruction)storedBlock).addReplicaIfNotPresent(\n-            storageInfo, iblk, reportedState);\n+        ((BlockInfoContiguousUnderConstruction)storedBlock)\n+            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n-        BlockInfoUnderConstruction blockUC \u003d (BlockInfoUnderConstruction) storedBlock;\n+        BlockInfoContiguousUnderConstruction blockUC \u003d\n+            (BlockInfoContiguousUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n         addStoredBlockImmediate(storedBlock, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.numBlocks() \u003d\u003d 0);\n    BlockReportIterator itBR \u003d report.getBlockReportIterator();\n\n    while(itBR.hasNext()) {\n      Block iblk \u003d itBR.next();\n      ReplicaState reportedState \u003d itBR.getCurrentReplicaState();\n      \n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfoContiguous storedBlock \u003d blocksMap.getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoContiguousUnderConstruction)storedBlock)\n            .addReplicaIfNotPresent(storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoContiguousUnderConstruction blockUC \u003d\n            (BlockInfoContiguousUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, storageInfo);\n      }\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
      "extendedDetails": {}
    },
    "45db4d204b796eee6dd0e39d3cc94b70c47028d4": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-6794. Update BlockManager methods to use DatanodeStorageInfo where possible. (Arpit Agarwal)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615169 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/08/14 9:58 AM",
      "commitName": "45db4d204b796eee6dd0e39d3cc94b70c47028d4",
      "commitAuthor": "Arpit Agarwal",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6794. Update BlockManager methods to use DatanodeStorageInfo where possible. (Arpit Agarwal)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615169 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "01/08/14 9:58 AM",
          "commitName": "45db4d204b796eee6dd0e39d3cc94b70c47028d4",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "31/07/14 6:05 PM",
          "commitNameOld": "b8597e6a10b2e8df1bee4e8ce0c8be345f7e007d",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 0.66,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,60 @@\n-  private void processFirstBlockReport(final DatanodeDescriptor node,\n-      final String storageID,\n+  private void processFirstBlockReport(\n+      final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n-    assert (node.getStorageInfo(storageID).numBlocks() \u003d\u003d 0);\n+    assert (storageInfo.numBlocks() \u003d\u003d 0);\n     BlockReportIterator itBR \u003d report.getBlockReportIterator();\n \n     while(itBR.hasNext()) {\n       Block iblk \u003d itBR.next();\n       ReplicaState reportedState \u003d itBR.getCurrentReplicaState();\n       \n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n-        queueReportedBlock(node, storageID, iblk, reportedState,\n+        queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n       BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n-          iblk, reportedState, storedBlock, ucState, node);\n+          iblk, reportedState, storedBlock, ucState,\n+          storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n-          queueReportedBlock(node, storageID, iblk, reportedState,\n+          queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n-          markBlockAsCorrupt(c, node, storageID);\n+          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         ((BlockInfoUnderConstruction)storedBlock).addReplicaIfNotPresent(\n-            node.getStorageInfo(storageID), iblk, reportedState);\n+            storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         BlockInfoUnderConstruction blockUC \u003d (BlockInfoUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n-        addStoredBlockImmediate(storedBlock, node, storageID);\n+        addStoredBlockImmediate(storedBlock, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.numBlocks() \u003d\u003d 0);\n    BlockReportIterator itBR \u003d report.getBlockReportIterator();\n\n    while(itBR.hasNext()) {\n      Block iblk \u003d itBR.next();\n      ReplicaState reportedState \u003d itBR.getCurrentReplicaState();\n      \n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoUnderConstruction)storedBlock).addReplicaIfNotPresent(\n            storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoUnderConstruction blockUC \u003d (BlockInfoUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, storageInfo);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {
            "oldValue": "[node-DatanodeDescriptor(modifiers-final), storageID-String(modifiers-final), report-BlockListAsLongs(modifiers-final)]",
            "newValue": "[storageInfo-DatanodeStorageInfo(modifiers-final), report-BlockListAsLongs(modifiers-final)]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6794. Update BlockManager methods to use DatanodeStorageInfo where possible. (Arpit Agarwal)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615169 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "01/08/14 9:58 AM",
          "commitName": "45db4d204b796eee6dd0e39d3cc94b70c47028d4",
          "commitAuthor": "Arpit Agarwal",
          "commitDateOld": "31/07/14 6:05 PM",
          "commitNameOld": "b8597e6a10b2e8df1bee4e8ce0c8be345f7e007d",
          "commitAuthorOld": "Tsz-wo Sze",
          "daysBetweenCommits": 0.66,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,60 @@\n-  private void processFirstBlockReport(final DatanodeDescriptor node,\n-      final String storageID,\n+  private void processFirstBlockReport(\n+      final DatanodeStorageInfo storageInfo,\n       final BlockListAsLongs report) throws IOException {\n     if (report \u003d\u003d null) return;\n     assert (namesystem.hasWriteLock());\n-    assert (node.getStorageInfo(storageID).numBlocks() \u003d\u003d 0);\n+    assert (storageInfo.numBlocks() \u003d\u003d 0);\n     BlockReportIterator itBR \u003d report.getBlockReportIterator();\n \n     while(itBR.hasNext()) {\n       Block iblk \u003d itBR.next();\n       ReplicaState reportedState \u003d itBR.getCurrentReplicaState();\n       \n       if (shouldPostponeBlocksFromFuture \u0026\u0026\n           namesystem.isGenStampInFuture(iblk)) {\n-        queueReportedBlock(node, storageID, iblk, reportedState,\n+        queueReportedBlock(storageInfo, iblk, reportedState,\n             QUEUE_REASON_FUTURE_GENSTAMP);\n         continue;\n       }\n       \n       BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n       // If block does not belong to any file, we are done.\n       if (storedBlock \u003d\u003d null) continue;\n       \n       // If block is corrupt, mark it and continue to next block.\n       BlockUCState ucState \u003d storedBlock.getBlockUCState();\n       BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n-          iblk, reportedState, storedBlock, ucState, node);\n+          iblk, reportedState, storedBlock, ucState,\n+          storageInfo.getDatanodeDescriptor());\n       if (c !\u003d null) {\n         if (shouldPostponeBlocksFromFuture) {\n           // In the Standby, we may receive a block report for a file that we\n           // just have an out-of-date gen-stamp or state for, for example.\n-          queueReportedBlock(node, storageID, iblk, reportedState,\n+          queueReportedBlock(storageInfo, iblk, reportedState,\n               QUEUE_REASON_CORRUPT_STATE);\n         } else {\n-          markBlockAsCorrupt(c, node, storageID);\n+          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n         }\n         continue;\n       }\n       \n       // If block is under construction, add this replica to its list\n       if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n         ((BlockInfoUnderConstruction)storedBlock).addReplicaIfNotPresent(\n-            node.getStorageInfo(storageID), iblk, reportedState);\n+            storageInfo, iblk, reportedState);\n         // OpenFileBlocks only inside snapshots also will be added to safemode\n         // threshold. So we need to update such blocks to safemode\n         // refer HDFS-5283\n         BlockInfoUnderConstruction blockUC \u003d (BlockInfoUnderConstruction) storedBlock;\n         if (namesystem.isInSnapshot(blockUC)) {\n           int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n           namesystem.incrementSafeBlockCount(numOfReplicas);\n         }\n         //and fall through to next clause\n       }      \n       //add replica if appropriate\n       if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n-        addStoredBlockImmediate(storedBlock, node, storageID);\n+        addStoredBlockImmediate(storedBlock, storageInfo);\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void processFirstBlockReport(\n      final DatanodeStorageInfo storageInfo,\n      final BlockListAsLongs report) throws IOException {\n    if (report \u003d\u003d null) return;\n    assert (namesystem.hasWriteLock());\n    assert (storageInfo.numBlocks() \u003d\u003d 0);\n    BlockReportIterator itBR \u003d report.getBlockReportIterator();\n\n    while(itBR.hasNext()) {\n      Block iblk \u003d itBR.next();\n      ReplicaState reportedState \u003d itBR.getCurrentReplicaState();\n      \n      if (shouldPostponeBlocksFromFuture \u0026\u0026\n          namesystem.isGenStampInFuture(iblk)) {\n        queueReportedBlock(storageInfo, iblk, reportedState,\n            QUEUE_REASON_FUTURE_GENSTAMP);\n        continue;\n      }\n      \n      BlockInfo storedBlock \u003d blocksMap.getStoredBlock(iblk);\n      // If block does not belong to any file, we are done.\n      if (storedBlock \u003d\u003d null) continue;\n      \n      // If block is corrupt, mark it and continue to next block.\n      BlockUCState ucState \u003d storedBlock.getBlockUCState();\n      BlockToMarkCorrupt c \u003d checkReplicaCorrupt(\n          iblk, reportedState, storedBlock, ucState,\n          storageInfo.getDatanodeDescriptor());\n      if (c !\u003d null) {\n        if (shouldPostponeBlocksFromFuture) {\n          // In the Standby, we may receive a block report for a file that we\n          // just have an out-of-date gen-stamp or state for, for example.\n          queueReportedBlock(storageInfo, iblk, reportedState,\n              QUEUE_REASON_CORRUPT_STATE);\n        } else {\n          markBlockAsCorrupt(c, storageInfo, storageInfo.getDatanodeDescriptor());\n        }\n        continue;\n      }\n      \n      // If block is under construction, add this replica to its list\n      if (isBlockUnderConstruction(storedBlock, ucState, reportedState)) {\n        ((BlockInfoUnderConstruction)storedBlock).addReplicaIfNotPresent(\n            storageInfo, iblk, reportedState);\n        // OpenFileBlocks only inside snapshots also will be added to safemode\n        // threshold. So we need to update such blocks to safemode\n        // refer HDFS-5283\n        BlockInfoUnderConstruction blockUC \u003d (BlockInfoUnderConstruction) storedBlock;\n        if (namesystem.isInSnapshot(blockUC)) {\n          int numOfReplicas \u003d blockUC.getNumExpectedLocations();\n          namesystem.incrementSafeBlockCount(numOfReplicas);\n        }\n        //and fall through to next clause\n      }      \n      //add replica if appropriate\n      if (reportedState \u003d\u003d ReplicaState.FINALIZED) {\n        addStoredBlockImmediate(storedBlock, storageInfo);\n      }\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/blockmanagement/BlockManager.java",
          "extendedDetails": {}
        }
      ]
    }
  }
}