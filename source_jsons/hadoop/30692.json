{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RollingLevelDBTimelineStore.java",
  "functionName": "serviceInit",
  "functionId": "serviceInit___conf-Configuration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
  "functionStartLine": 245,
  "functionEndLine": 348,
  "numCommitsSeen": 12,
  "timeTaken": 1436,
  "changeHistory": [
    "01aca54a22c8586d232a8f79fe9977aeb8d09b83",
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f"
  ],
  "changeHistoryShort": {
    "01aca54a22c8586d232a8f79fe9977aeb8d09b83": "Ybodychange",
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "01aca54a22c8586d232a8f79fe9977aeb8d09b83": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5368. Memory leak in timeline server (Jonathan Eagles via Varun Saxena)\n",
      "commitDate": "28/03/17 1:23 PM",
      "commitName": "01aca54a22c8586d232a8f79fe9977aeb8d09b83",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "20/07/16 8:36 AM",
      "commitNameOld": "1c9d2ab503ea5a3f16757351af9603041059b390",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 251.2,
      "commitsBetweenForRepo": 1583,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,104 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     Preconditions\n         .checkArgument(conf.getLong(TIMELINE_SERVICE_TTL_MS,\n             DEFAULT_TIMELINE_SERVICE_TTL_MS) \u003e 0,\n             \"%s property value should be greater than zero\",\n             TIMELINE_SERVICE_TTL_MS);\n     Preconditions.checkArgument(conf.getLong(\n         TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS,\n         DEFAULT_TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS) \u003e 0,\n         \"%s property value should be greater than zero\",\n         TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS);\n     Preconditions.checkArgument(conf.getLong(\n         TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE,\n         DEFAULT_TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE) \u003e\u003d 0,\n         \"%s property value should be greater than or equal to zero\",\n         TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE);\n     Preconditions.checkArgument(conf.getLong(\n         TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE,\n         DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE) \u003e 0,\n         \" %s property value should be greater than zero\",\n         TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE);\n     Preconditions.checkArgument(conf.getLong(\n         TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE,\n         DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE) \u003e 0,\n         \"%s property value should be greater than zero\",\n         TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE);\n     Preconditions.checkArgument(conf.getLong(\n         TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES,\n         DEFAULT_TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES) \u003e 0,\n         \"%s property value should be greater than zero\",\n         TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES);\n     Preconditions.checkArgument(conf.getLong(\n         TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE,\n         DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE) \u003e 0,\n         \"%s property value should be greater than zero\",\n         TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE);\n \n     Options options \u003d new Options();\n     options.createIfMissing(true);\n     options.cacheSize(conf.getLong(\n         TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE,\n         DEFAULT_TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE));\n     JniDBFactory factory \u003d new JniDBFactory();\n     Path dbPath \u003d new Path(\n         conf.get(TIMELINE_SERVICE_LEVELDB_PATH), FILENAME);\n     Path domainDBPath \u003d new Path(dbPath, DOMAIN);\n     Path starttimeDBPath \u003d new Path(dbPath, STARTTIME);\n     Path ownerDBPath \u003d new Path(dbPath, OWNER);\n-    FileSystem localFS \u003d null;\n-    try {\n-      localFS \u003d FileSystem.getLocal(conf);\n+    try (FileSystem localFS \u003d FileSystem.getLocal(conf)) {\n       if (!localFS.exists(dbPath)) {\n         if (!localFS.mkdirs(dbPath)) {\n           throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n               + \"timeline store \" + dbPath);\n         }\n         localFS.setPermission(dbPath, LEVELDB_DIR_UMASK);\n       }\n       if (!localFS.exists(domainDBPath)) {\n         if (!localFS.mkdirs(domainDBPath)) {\n           throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n               + \"timeline store \" + domainDBPath);\n         }\n         localFS.setPermission(domainDBPath, LEVELDB_DIR_UMASK);\n       }\n       if (!localFS.exists(starttimeDBPath)) {\n         if (!localFS.mkdirs(starttimeDBPath)) {\n           throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n               + \"timeline store \" + starttimeDBPath);\n         }\n         localFS.setPermission(starttimeDBPath, LEVELDB_DIR_UMASK);\n       }\n       if (!localFS.exists(ownerDBPath)) {\n         if (!localFS.mkdirs(ownerDBPath)) {\n           throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n               + \"timeline store \" + ownerDBPath);\n         }\n         localFS.setPermission(ownerDBPath, LEVELDB_DIR_UMASK);\n       }\n-    } finally {\n-      IOUtils.cleanup(LOG, localFS);\n     }\n     options.maxOpenFiles(conf.getInt(\n         TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES,\n         DEFAULT_TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES));\n     options.writeBufferSize(conf.getInt(\n         TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE,\n         DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE));\n     LOG.info(\"Using leveldb path \" + dbPath);\n     domaindb \u003d factory.open(new File(domainDBPath.toString()), options);\n     entitydb \u003d new RollingLevelDB(ENTITY);\n     entitydb.init(conf);\n     indexdb \u003d new RollingLevelDB(INDEX);\n     indexdb.init(conf);\n     starttimedb \u003d factory.open(new File(starttimeDBPath.toString()), options);\n     ownerdb \u003d factory.open(new File(ownerDBPath.toString()), options);\n     checkVersion();\n     startTimeWriteCache \u003d Collections.synchronizedMap(new LRUMap(\n         getStartTimeWriteCacheSize(conf)));\n     startTimeReadCache \u003d Collections.synchronizedMap(new LRUMap(\n         getStartTimeReadCacheSize(conf)));\n \n     writeBatchSize \u003d conf.getInt(\n         TIMELINE_SERVICE_LEVELDB_WRITE_BATCH_SIZE,\n         DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BATCH_SIZE);\n \n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    Preconditions\n        .checkArgument(conf.getLong(TIMELINE_SERVICE_TTL_MS,\n            DEFAULT_TIMELINE_SERVICE_TTL_MS) \u003e 0,\n            \"%s property value should be greater than zero\",\n            TIMELINE_SERVICE_TTL_MS);\n    Preconditions.checkArgument(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS) \u003e 0,\n        \"%s property value should be greater than zero\",\n        TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS);\n    Preconditions.checkArgument(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE) \u003e\u003d 0,\n        \"%s property value should be greater than or equal to zero\",\n        TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE);\n    Preconditions.checkArgument(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE) \u003e 0,\n        \" %s property value should be greater than zero\",\n        TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE);\n    Preconditions.checkArgument(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE) \u003e 0,\n        \"%s property value should be greater than zero\",\n        TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE);\n    Preconditions.checkArgument(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES) \u003e 0,\n        \"%s property value should be greater than zero\",\n        TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES);\n    Preconditions.checkArgument(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE) \u003e 0,\n        \"%s property value should be greater than zero\",\n        TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE);\n\n    Options options \u003d new Options();\n    options.createIfMissing(true);\n    options.cacheSize(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE));\n    JniDBFactory factory \u003d new JniDBFactory();\n    Path dbPath \u003d new Path(\n        conf.get(TIMELINE_SERVICE_LEVELDB_PATH), FILENAME);\n    Path domainDBPath \u003d new Path(dbPath, DOMAIN);\n    Path starttimeDBPath \u003d new Path(dbPath, STARTTIME);\n    Path ownerDBPath \u003d new Path(dbPath, OWNER);\n    try (FileSystem localFS \u003d FileSystem.getLocal(conf)) {\n      if (!localFS.exists(dbPath)) {\n        if (!localFS.mkdirs(dbPath)) {\n          throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n              + \"timeline store \" + dbPath);\n        }\n        localFS.setPermission(dbPath, LEVELDB_DIR_UMASK);\n      }\n      if (!localFS.exists(domainDBPath)) {\n        if (!localFS.mkdirs(domainDBPath)) {\n          throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n              + \"timeline store \" + domainDBPath);\n        }\n        localFS.setPermission(domainDBPath, LEVELDB_DIR_UMASK);\n      }\n      if (!localFS.exists(starttimeDBPath)) {\n        if (!localFS.mkdirs(starttimeDBPath)) {\n          throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n              + \"timeline store \" + starttimeDBPath);\n        }\n        localFS.setPermission(starttimeDBPath, LEVELDB_DIR_UMASK);\n      }\n      if (!localFS.exists(ownerDBPath)) {\n        if (!localFS.mkdirs(ownerDBPath)) {\n          throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n              + \"timeline store \" + ownerDBPath);\n        }\n        localFS.setPermission(ownerDBPath, LEVELDB_DIR_UMASK);\n      }\n    }\n    options.maxOpenFiles(conf.getInt(\n        TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES));\n    options.writeBufferSize(conf.getInt(\n        TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE));\n    LOG.info(\"Using leveldb path \" + dbPath);\n    domaindb \u003d factory.open(new File(domainDBPath.toString()), options);\n    entitydb \u003d new RollingLevelDB(ENTITY);\n    entitydb.init(conf);\n    indexdb \u003d new RollingLevelDB(INDEX);\n    indexdb.init(conf);\n    starttimedb \u003d factory.open(new File(starttimeDBPath.toString()), options);\n    ownerdb \u003d factory.open(new File(ownerDBPath.toString()), options);\n    checkVersion();\n    startTimeWriteCache \u003d Collections.synchronizedMap(new LRUMap(\n        getStartTimeWriteCacheSize(conf)));\n    startTimeReadCache \u003d Collections.synchronizedMap(new LRUMap(\n        getStartTimeReadCacheSize(conf)));\n\n    writeBatchSize \u003d conf.getInt(\n        TIMELINE_SERVICE_LEVELDB_WRITE_BATCH_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BATCH_SIZE);\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java",
      "extendedDetails": {}
    },
    "daf3e4ef8bf73cbe4a799d51b4765809cd81089f": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3448. Added a rolling time-to-live LevelDB timeline store implementation. Contributed by Jonathan Eagles.\n",
      "commitDate": "07/05/15 10:01 AM",
      "commitName": "daf3e4ef8bf73cbe4a799d51b4765809cd81089f",
      "commitAuthor": "Zhijie Shen",
      "diff": "@@ -0,0 +1,108 @@\n+  protected void serviceInit(Configuration conf) throws Exception {\n+    Preconditions\n+        .checkArgument(conf.getLong(TIMELINE_SERVICE_TTL_MS,\n+            DEFAULT_TIMELINE_SERVICE_TTL_MS) \u003e 0,\n+            \"%s property value should be greater than zero\",\n+            TIMELINE_SERVICE_TTL_MS);\n+    Preconditions.checkArgument(conf.getLong(\n+        TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS,\n+        DEFAULT_TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS) \u003e 0,\n+        \"%s property value should be greater than zero\",\n+        TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS);\n+    Preconditions.checkArgument(conf.getLong(\n+        TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE,\n+        DEFAULT_TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE) \u003e\u003d 0,\n+        \"%s property value should be greater than or equal to zero\",\n+        TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE);\n+    Preconditions.checkArgument(conf.getLong(\n+        TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE,\n+        DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE) \u003e 0,\n+        \" %s property value should be greater than zero\",\n+        TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE);\n+    Preconditions.checkArgument(conf.getLong(\n+        TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE,\n+        DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE) \u003e 0,\n+        \"%s property value should be greater than zero\",\n+        TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE);\n+    Preconditions.checkArgument(conf.getLong(\n+        TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES,\n+        DEFAULT_TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES) \u003e 0,\n+        \"%s property value should be greater than zero\",\n+        TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES);\n+    Preconditions.checkArgument(conf.getLong(\n+        TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE,\n+        DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE) \u003e 0,\n+        \"%s property value should be greater than zero\",\n+        TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE);\n+\n+    Options options \u003d new Options();\n+    options.createIfMissing(true);\n+    options.cacheSize(conf.getLong(\n+        TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE,\n+        DEFAULT_TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE));\n+    JniDBFactory factory \u003d new JniDBFactory();\n+    Path dbPath \u003d new Path(\n+        conf.get(TIMELINE_SERVICE_LEVELDB_PATH), FILENAME);\n+    Path domainDBPath \u003d new Path(dbPath, DOMAIN);\n+    Path starttimeDBPath \u003d new Path(dbPath, STARTTIME);\n+    Path ownerDBPath \u003d new Path(dbPath, OWNER);\n+    FileSystem localFS \u003d null;\n+    try {\n+      localFS \u003d FileSystem.getLocal(conf);\n+      if (!localFS.exists(dbPath)) {\n+        if (!localFS.mkdirs(dbPath)) {\n+          throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n+              + \"timeline store \" + dbPath);\n+        }\n+        localFS.setPermission(dbPath, LEVELDB_DIR_UMASK);\n+      }\n+      if (!localFS.exists(domainDBPath)) {\n+        if (!localFS.mkdirs(domainDBPath)) {\n+          throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n+              + \"timeline store \" + domainDBPath);\n+        }\n+        localFS.setPermission(domainDBPath, LEVELDB_DIR_UMASK);\n+      }\n+      if (!localFS.exists(starttimeDBPath)) {\n+        if (!localFS.mkdirs(starttimeDBPath)) {\n+          throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n+              + \"timeline store \" + starttimeDBPath);\n+        }\n+        localFS.setPermission(starttimeDBPath, LEVELDB_DIR_UMASK);\n+      }\n+      if (!localFS.exists(ownerDBPath)) {\n+        if (!localFS.mkdirs(ownerDBPath)) {\n+          throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n+              + \"timeline store \" + ownerDBPath);\n+        }\n+        localFS.setPermission(ownerDBPath, LEVELDB_DIR_UMASK);\n+      }\n+    } finally {\n+      IOUtils.cleanup(LOG, localFS);\n+    }\n+    options.maxOpenFiles(conf.getInt(\n+        TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES,\n+        DEFAULT_TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES));\n+    options.writeBufferSize(conf.getInt(\n+        TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE,\n+        DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE));\n+    LOG.info(\"Using leveldb path \" + dbPath);\n+    domaindb \u003d factory.open(new File(domainDBPath.toString()), options);\n+    entitydb \u003d new RollingLevelDB(ENTITY);\n+    entitydb.init(conf);\n+    indexdb \u003d new RollingLevelDB(INDEX);\n+    indexdb.init(conf);\n+    starttimedb \u003d factory.open(new File(starttimeDBPath.toString()), options);\n+    ownerdb \u003d factory.open(new File(ownerDBPath.toString()), options);\n+    checkVersion();\n+    startTimeWriteCache \u003d Collections.synchronizedMap(new LRUMap(\n+        getStartTimeWriteCacheSize(conf)));\n+    startTimeReadCache \u003d Collections.synchronizedMap(new LRUMap(\n+        getStartTimeReadCacheSize(conf)));\n+\n+    writeBatchSize \u003d conf.getInt(\n+        TIMELINE_SERVICE_LEVELDB_WRITE_BATCH_SIZE,\n+        DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BATCH_SIZE);\n+\n+    super.serviceInit(conf);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    Preconditions\n        .checkArgument(conf.getLong(TIMELINE_SERVICE_TTL_MS,\n            DEFAULT_TIMELINE_SERVICE_TTL_MS) \u003e 0,\n            \"%s property value should be greater than zero\",\n            TIMELINE_SERVICE_TTL_MS);\n    Preconditions.checkArgument(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS) \u003e 0,\n        \"%s property value should be greater than zero\",\n        TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS);\n    Preconditions.checkArgument(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE) \u003e\u003d 0,\n        \"%s property value should be greater than or equal to zero\",\n        TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE);\n    Preconditions.checkArgument(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE) \u003e 0,\n        \" %s property value should be greater than zero\",\n        TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE);\n    Preconditions.checkArgument(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE) \u003e 0,\n        \"%s property value should be greater than zero\",\n        TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE);\n    Preconditions.checkArgument(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES) \u003e 0,\n        \"%s property value should be greater than zero\",\n        TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES);\n    Preconditions.checkArgument(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE) \u003e 0,\n        \"%s property value should be greater than zero\",\n        TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE);\n\n    Options options \u003d new Options();\n    options.createIfMissing(true);\n    options.cacheSize(conf.getLong(\n        TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE));\n    JniDBFactory factory \u003d new JniDBFactory();\n    Path dbPath \u003d new Path(\n        conf.get(TIMELINE_SERVICE_LEVELDB_PATH), FILENAME);\n    Path domainDBPath \u003d new Path(dbPath, DOMAIN);\n    Path starttimeDBPath \u003d new Path(dbPath, STARTTIME);\n    Path ownerDBPath \u003d new Path(dbPath, OWNER);\n    FileSystem localFS \u003d null;\n    try {\n      localFS \u003d FileSystem.getLocal(conf);\n      if (!localFS.exists(dbPath)) {\n        if (!localFS.mkdirs(dbPath)) {\n          throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n              + \"timeline store \" + dbPath);\n        }\n        localFS.setPermission(dbPath, LEVELDB_DIR_UMASK);\n      }\n      if (!localFS.exists(domainDBPath)) {\n        if (!localFS.mkdirs(domainDBPath)) {\n          throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n              + \"timeline store \" + domainDBPath);\n        }\n        localFS.setPermission(domainDBPath, LEVELDB_DIR_UMASK);\n      }\n      if (!localFS.exists(starttimeDBPath)) {\n        if (!localFS.mkdirs(starttimeDBPath)) {\n          throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n              + \"timeline store \" + starttimeDBPath);\n        }\n        localFS.setPermission(starttimeDBPath, LEVELDB_DIR_UMASK);\n      }\n      if (!localFS.exists(ownerDBPath)) {\n        if (!localFS.mkdirs(ownerDBPath)) {\n          throw new IOException(\"Couldn\u0027t create directory for leveldb \"\n              + \"timeline store \" + ownerDBPath);\n        }\n        localFS.setPermission(ownerDBPath, LEVELDB_DIR_UMASK);\n      }\n    } finally {\n      IOUtils.cleanup(LOG, localFS);\n    }\n    options.maxOpenFiles(conf.getInt(\n        TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES));\n    options.writeBufferSize(conf.getInt(\n        TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE));\n    LOG.info(\"Using leveldb path \" + dbPath);\n    domaindb \u003d factory.open(new File(domainDBPath.toString()), options);\n    entitydb \u003d new RollingLevelDB(ENTITY);\n    entitydb.init(conf);\n    indexdb \u003d new RollingLevelDB(INDEX);\n    indexdb.init(conf);\n    starttimedb \u003d factory.open(new File(starttimeDBPath.toString()), options);\n    ownerdb \u003d factory.open(new File(ownerDBPath.toString()), options);\n    checkVersion();\n    startTimeWriteCache \u003d Collections.synchronizedMap(new LRUMap(\n        getStartTimeWriteCacheSize(conf)));\n    startTimeReadCache \u003d Collections.synchronizedMap(new LRUMap(\n        getStartTimeReadCacheSize(conf)));\n\n    writeBatchSize \u003d conf.getInt(\n        TIMELINE_SERVICE_LEVELDB_WRITE_BATCH_SIZE,\n        DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BATCH_SIZE);\n\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/timeline/RollingLevelDBTimelineStore.java"
    }
  }
}