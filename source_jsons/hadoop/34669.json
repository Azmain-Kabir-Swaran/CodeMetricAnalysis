{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerManagerImpl.java",
  "functionName": "startContainerInternal",
  "functionId": "startContainerInternal___containerTokenIdentifier-ContainerTokenIdentifier__request-StartContainerRequest__remoteUser-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
  "functionStartLine": 1077,
  "functionEndLine": 1198,
  "numCommitsSeen": 391,
  "timeTaken": 21220,
  "changeHistory": [
    "32fe351bb654e684f127f47ab808c497e0d3f258",
    "7f1d3d0e9dbe328fae0d43421665e0b6907b33fe",
    "092fead5d9875fb3760206bcdd76cdafec5e9481",
    "c8df3668ecc37c2d58cad35520a762eaec3c8539",
    "47474fffac085e0e5ea46336bf80ccd0677017a3",
    "e8071aa249c7b21b1de084ee5a9ca2a44efd3bf0",
    "de3a5f8d08f64d0c2021a84b40e63e716da2321c",
    "d6d9cff21b7b6141ed88359652cf22e8973c0661",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1",
    "8d9476ec5f64795e2bdd60bea4d643eaafed2c50",
    "477a30f536277bf95d7181bf1b2fdda52d83bf51",
    "d275677e240cca469a4cec3dc7238e3f18b3f7e9",
    "47f35a30bb4d99349593e9d6e1c9e76e71341c40",
    "d67c9bdb4db2b075484a779802ecf3296bad5cd4",
    "d971bf252f36e902a0fe446cb11201835ad16bcb",
    "c8172f5f143d2fefafa5a412899ab7cd081b406d",
    "d284e187b8db43056236032ebc2114ee462c27f6",
    "ffd820c27a4f8cf4676ad8758696ed89fde80218",
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02",
    "5391919b09ce9549d13c897aa89bb0a0536760fe",
    "c86674a3a4d99aa56bb8ed3f6df51e3fef215eba",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b",
    "b8f151231ba37247b9daa23ecce1211fdca0e49f",
    "d3841bd4997a77855ab2abd9cc294eae7d795a5b",
    "8ebf37f3691dee523f7d800bc82c7423c3e262e9",
    "a759abcd898224c3481c55aa7e424bc286f60b15",
    "3ca3137179ef093e42cde06587c9ea785b10f32c",
    "243bcd367ff3130d74676280233041f88aca62a5",
    "f4d80e91ae314d316100baa7770b9d73ea853d9c",
    "c6c41abf683be17c3917a7f94953b55347aaa69f",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "a2c42330047bf955a6a585dcddf798920d4c8640",
    "2692675fc3b5046d2ec88542c30203c87e135b70",
    "b16c5638b5190c56f9d854d873589cb5c11c8b32",
    "259edf8dca44de54033e96f7eb65a83aaa6096f2",
    "ca8024673178fa1c80224b390dfba932921693d9",
    "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1",
    "9eb53b9c841233538a51e4e854b261536c0b85d4",
    "fbb55784d93e1a819daf55d936e864d344579cbf",
    "8e1c2823fc014a5a045c86760c61111d0bb59d2f",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "4e5818698778bff9d2b1ba14297d8393e49927c7",
    "7f4dc277572df6ba25fa961073b99a5bdb086c00",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449",
    "237154982bd5853c6a374cb265520e0602adc52f",
    "df2991c0cbc3f35c2640b93680667507c4f810dd",
    "e3bb120e9fefb21168edd7cd06f0cbfb92a5e02b",
    "11b9dd4e844c762f8c53e5fafa25f29eece1bc87",
    "02a81203bd0ff6116e3c68d376b3af3838231986",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
    "cdfabf5ae289836968b3d296668593b9500b6f26",
    "ade0f0560f729e50382c6992f713f29e2dd5b270",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "32fe351bb654e684f127f47ab808c497e0d3f258": "Ymultichange(Yparameterchange,Ybodychange)",
    "7f1d3d0e9dbe328fae0d43421665e0b6907b33fe": "Ybodychange",
    "092fead5d9875fb3760206bcdd76cdafec5e9481": "Ybodychange",
    "c8df3668ecc37c2d58cad35520a762eaec3c8539": "Ybodychange",
    "47474fffac085e0e5ea46336bf80ccd0677017a3": "Ybodychange",
    "e8071aa249c7b21b1de084ee5a9ca2a44efd3bf0": "Ybodychange",
    "de3a5f8d08f64d0c2021a84b40e63e716da2321c": "Ybodychange",
    "d6d9cff21b7b6141ed88359652cf22e8973c0661": "Ybodychange",
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": "Ybodychange",
    "8d9476ec5f64795e2bdd60bea4d643eaafed2c50": "Ybodychange",
    "477a30f536277bf95d7181bf1b2fdda52d83bf51": "Ybodychange",
    "d275677e240cca469a4cec3dc7238e3f18b3f7e9": "Ybodychange",
    "47f35a30bb4d99349593e9d6e1c9e76e71341c40": "Ybodychange",
    "d67c9bdb4db2b075484a779802ecf3296bad5cd4": "Ybodychange",
    "d971bf252f36e902a0fe446cb11201835ad16bcb": "Yparameterchange",
    "c8172f5f143d2fefafa5a412899ab7cd081b406d": "Ymultichange(Ymodifierchange,Ybodychange)",
    "d284e187b8db43056236032ebc2114ee462c27f6": "Ybodychange",
    "ffd820c27a4f8cf4676ad8758696ed89fde80218": "Ybodychange",
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02": "Ybodychange",
    "5391919b09ce9549d13c897aa89bb0a0536760fe": "Ybodychange",
    "c86674a3a4d99aa56bb8ed3f6df51e3fef215eba": "Ybodychange",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": "Ybodychange",
    "b8f151231ba37247b9daa23ecce1211fdca0e49f": "Ybodychange",
    "d3841bd4997a77855ab2abd9cc294eae7d795a5b": "Ybodychange",
    "8ebf37f3691dee523f7d800bc82c7423c3e262e9": "Ybodychange",
    "a759abcd898224c3481c55aa7e424bc286f60b15": "Ybodychange",
    "3ca3137179ef093e42cde06587c9ea785b10f32c": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
    "243bcd367ff3130d74676280233041f88aca62a5": "Ybodychange",
    "f4d80e91ae314d316100baa7770b9d73ea853d9c": "Ybodychange",
    "c6c41abf683be17c3917a7f94953b55347aaa69f": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Yexceptionschange",
    "a2c42330047bf955a6a585dcddf798920d4c8640": "Ybodychange",
    "2692675fc3b5046d2ec88542c30203c87e135b70": "Ybodychange",
    "b16c5638b5190c56f9d854d873589cb5c11c8b32": "Ybodychange",
    "259edf8dca44de54033e96f7eb65a83aaa6096f2": "Ybodychange",
    "ca8024673178fa1c80224b390dfba932921693d9": "Ybodychange",
    "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1": "Ybodychange",
    "9eb53b9c841233538a51e4e854b261536c0b85d4": "Yexceptionschange",
    "fbb55784d93e1a819daf55d936e864d344579cbf": "Ybodychange",
    "8e1c2823fc014a5a045c86760c61111d0bb59d2f": "Ybodychange",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": "Ybodychange",
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "4e5818698778bff9d2b1ba14297d8393e49927c7": "Ybodychange",
    "7f4dc277572df6ba25fa961073b99a5bdb086c00": "Ybodychange",
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": "Ybodychange",
    "237154982bd5853c6a374cb265520e0602adc52f": "Ybodychange",
    "df2991c0cbc3f35c2640b93680667507c4f810dd": "Ybodychange",
    "e3bb120e9fefb21168edd7cd06f0cbfb92a5e02b": "Ybodychange",
    "11b9dd4e844c762f8c53e5fafa25f29eece1bc87": "Ybodychange",
    "02a81203bd0ff6116e3c68d376b3af3838231986": "Ybodychange",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": "Ybodychange",
    "cdfabf5ae289836968b3d296668593b9500b6f26": "Ybodychange",
    "ade0f0560f729e50382c6992f713f29e2dd5b270": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "32fe351bb654e684f127f47ab808c497e0d3f258": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-8864. NM incorrectly logs container user as the user who sent a start/stop container request in its audit log. (Contributed by Wilfred Spiegelenburg)\n",
      "commitDate": "18/10/18 8:28 AM",
      "commitName": "32fe351bb654e684f127f47ab808c497e0d3f258",
      "commitAuthor": "Haibo Chen",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-8864. NM incorrectly logs container user as the user who sent a start/stop container request in its audit log. (Contributed by Wilfred Spiegelenburg)\n",
          "commitDate": "18/10/18 8:28 AM",
          "commitName": "32fe351bb654e684f127f47ab808c497e0d3f258",
          "commitAuthor": "Haibo Chen",
          "commitDateOld": "26/09/18 11:51 AM",
          "commitNameOld": "913f87dada27776c539dfb352400ecf8d40e7943",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 21.86,
          "commitsBetweenForRepo": 222,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,121 +1,122 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n-      StartContainerRequest request) throws YarnException, IOException {\n+      StartContainerRequest request, String remoteUser)\n+      throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n-    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n+    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + remoteUser);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     // Sanity check for local resources\n     for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n         .getLocalResources().entrySet()) {\n       if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n-        throw new YarnException(\n-            \"Null resource URL for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n+        throw new YarnException(\"Null resource URL for local resource \"\n+            + rsrc.getKey() + \" : \" + rsrc.getValue());\n       } else if (rsrc.getValue().getType() \u003d\u003d null) {\n-        throw new YarnException(\n-            \"Null resource type for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n+        throw new YarnException(\"Null resource type for local resource \"\n+            + rsrc.getKey() + \" : \" + rsrc.getValue());\n       } else if (rsrc.getValue().getVisibility() \u003d\u003d null) {\n-        throw new YarnException(\n-            \"Null resource visibility for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n+        throw new YarnException(\"Null resource visibility for local resource \"\n+            + rsrc.getKey() + \" : \" + rsrc.getValue());\n       }\n     }\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     long containerStartTime \u003d SystemClock.getInstance().getTime();\n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context, containerStartTime);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n-      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n+      NMAuditLogger.logFailure(remoteUser, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         if (!context.getApplications().containsKey(applicationID)) {\n           // Create the application\n           // populate the flow context from the launch context if the timeline\n           // service v.2 is enabled\n           FlowContext flowContext \u003d\n               getFlowContext(launchContext, applicationID);\n \n           Application application \u003d\n               new ApplicationImpl(dispatcher, user, flowContext,\n                   applicationID, credentials, context);\n           if (context.getApplications().putIfAbsent(applicationID,\n               application) \u003d\u003d null) {\n             LOG.info(\"Creating a new application reference for app \"\n                 + applicationID);\n             LogAggregationContext logAggregationContext \u003d\n                 containerTokenIdentifier.getLogAggregationContext();\n             Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                 container.getLaunchContext().getApplicationACLs();\n             context.getNMStateStore().storeApplication(applicationID,\n                 buildAppProto(applicationID, user, credentials, appAcls,\n                     logAggregationContext, flowContext));\n             dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                 applicationID, appAcls, logAggregationContext));\n           }\n         } else if (containerTokenIdentifier.getContainerType()\n             \u003d\u003d ContainerType.APPLICATION_MASTER) {\n           FlowContext flowContext \u003d\n               getFlowContext(launchContext, applicationID);\n           if (flowContext !\u003d null) {\n             ApplicationImpl application \u003d\n                 (ApplicationImpl) context.getApplications().get(applicationID);\n \n             // update flowContext reference in ApplicationImpl\n             application.setFlowContext(flowContext);\n \n             // Required to update state store for recovery.\n             context.getNMStateStore().storeApplication(applicationID,\n                 buildAppProto(applicationID, user, credentials,\n                     container.getLaunchContext().getApplicationACLs(),\n                     containerTokenIdentifier.getLogAggregationContext(),\n                     flowContext));\n \n             LOG.info(\n                 \"Updated application reference with flowContext \" + flowContext\n                     + \" for app \" + applicationID);\n           } else {\n             LOG.info(\"TimelineService V2.0 is not enabled. Skipping updating \"\n                 + \"flowContext for application \" + applicationID);\n           }\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId,\n             containerTokenIdentifier.getVersion(), containerStartTime, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n-        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n+        NMAuditLogger.logSuccess(remoteUser, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request, String remoteUser)\n      throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + remoteUser);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    // Sanity check for local resources\n    for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n        .getLocalResources().entrySet()) {\n      if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n        throw new YarnException(\"Null resource URL for local resource \"\n            + rsrc.getKey() + \" : \" + rsrc.getValue());\n      } else if (rsrc.getValue().getType() \u003d\u003d null) {\n        throw new YarnException(\"Null resource type for local resource \"\n            + rsrc.getKey() + \" : \" + rsrc.getValue());\n      } else if (rsrc.getValue().getVisibility() \u003d\u003d null) {\n        throw new YarnException(\"Null resource visibility for local resource \"\n            + rsrc.getKey() + \" : \" + rsrc.getValue());\n      }\n    }\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    long containerStartTime \u003d SystemClock.getInstance().getTime();\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context, containerStartTime);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(remoteUser, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        if (!context.getApplications().containsKey(applicationID)) {\n          // Create the application\n          // populate the flow context from the launch context if the timeline\n          // service v.2 is enabled\n          FlowContext flowContext \u003d\n              getFlowContext(launchContext, applicationID);\n\n          Application application \u003d\n              new ApplicationImpl(dispatcher, user, flowContext,\n                  applicationID, credentials, context);\n          if (context.getApplications().putIfAbsent(applicationID,\n              application) \u003d\u003d null) {\n            LOG.info(\"Creating a new application reference for app \"\n                + applicationID);\n            LogAggregationContext logAggregationContext \u003d\n                containerTokenIdentifier.getLogAggregationContext();\n            Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                container.getLaunchContext().getApplicationACLs();\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials, appAcls,\n                    logAggregationContext, flowContext));\n            dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                applicationID, appAcls, logAggregationContext));\n          }\n        } else if (containerTokenIdentifier.getContainerType()\n            \u003d\u003d ContainerType.APPLICATION_MASTER) {\n          FlowContext flowContext \u003d\n              getFlowContext(launchContext, applicationID);\n          if (flowContext !\u003d null) {\n            ApplicationImpl application \u003d\n                (ApplicationImpl) context.getApplications().get(applicationID);\n\n            // update flowContext reference in ApplicationImpl\n            application.setFlowContext(flowContext);\n\n            // Required to update state store for recovery.\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials,\n                    container.getLaunchContext().getApplicationACLs(),\n                    containerTokenIdentifier.getLogAggregationContext(),\n                    flowContext));\n\n            LOG.info(\n                \"Updated application reference with flowContext \" + flowContext\n                    + \" for app \" + applicationID);\n          } else {\n            LOG.info(\"TimelineService V2.0 is not enabled. Skipping updating \"\n                + \"flowContext for application \" + applicationID);\n          }\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId,\n            containerTokenIdentifier.getVersion(), containerStartTime, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(remoteUser, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {
            "oldValue": "[containerTokenIdentifier-ContainerTokenIdentifier, request-StartContainerRequest]",
            "newValue": "[containerTokenIdentifier-ContainerTokenIdentifier, request-StartContainerRequest, remoteUser-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-8864. NM incorrectly logs container user as the user who sent a start/stop container request in its audit log. (Contributed by Wilfred Spiegelenburg)\n",
          "commitDate": "18/10/18 8:28 AM",
          "commitName": "32fe351bb654e684f127f47ab808c497e0d3f258",
          "commitAuthor": "Haibo Chen",
          "commitDateOld": "26/09/18 11:51 AM",
          "commitNameOld": "913f87dada27776c539dfb352400ecf8d40e7943",
          "commitAuthorOld": "Eric Yang",
          "daysBetweenCommits": 21.86,
          "commitsBetweenForRepo": 222,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,121 +1,122 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n-      StartContainerRequest request) throws YarnException, IOException {\n+      StartContainerRequest request, String remoteUser)\n+      throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n-    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n+    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + remoteUser);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     // Sanity check for local resources\n     for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n         .getLocalResources().entrySet()) {\n       if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n-        throw new YarnException(\n-            \"Null resource URL for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n+        throw new YarnException(\"Null resource URL for local resource \"\n+            + rsrc.getKey() + \" : \" + rsrc.getValue());\n       } else if (rsrc.getValue().getType() \u003d\u003d null) {\n-        throw new YarnException(\n-            \"Null resource type for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n+        throw new YarnException(\"Null resource type for local resource \"\n+            + rsrc.getKey() + \" : \" + rsrc.getValue());\n       } else if (rsrc.getValue().getVisibility() \u003d\u003d null) {\n-        throw new YarnException(\n-            \"Null resource visibility for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n+        throw new YarnException(\"Null resource visibility for local resource \"\n+            + rsrc.getKey() + \" : \" + rsrc.getValue());\n       }\n     }\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     long containerStartTime \u003d SystemClock.getInstance().getTime();\n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context, containerStartTime);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n-      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n+      NMAuditLogger.logFailure(remoteUser, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         if (!context.getApplications().containsKey(applicationID)) {\n           // Create the application\n           // populate the flow context from the launch context if the timeline\n           // service v.2 is enabled\n           FlowContext flowContext \u003d\n               getFlowContext(launchContext, applicationID);\n \n           Application application \u003d\n               new ApplicationImpl(dispatcher, user, flowContext,\n                   applicationID, credentials, context);\n           if (context.getApplications().putIfAbsent(applicationID,\n               application) \u003d\u003d null) {\n             LOG.info(\"Creating a new application reference for app \"\n                 + applicationID);\n             LogAggregationContext logAggregationContext \u003d\n                 containerTokenIdentifier.getLogAggregationContext();\n             Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                 container.getLaunchContext().getApplicationACLs();\n             context.getNMStateStore().storeApplication(applicationID,\n                 buildAppProto(applicationID, user, credentials, appAcls,\n                     logAggregationContext, flowContext));\n             dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                 applicationID, appAcls, logAggregationContext));\n           }\n         } else if (containerTokenIdentifier.getContainerType()\n             \u003d\u003d ContainerType.APPLICATION_MASTER) {\n           FlowContext flowContext \u003d\n               getFlowContext(launchContext, applicationID);\n           if (flowContext !\u003d null) {\n             ApplicationImpl application \u003d\n                 (ApplicationImpl) context.getApplications().get(applicationID);\n \n             // update flowContext reference in ApplicationImpl\n             application.setFlowContext(flowContext);\n \n             // Required to update state store for recovery.\n             context.getNMStateStore().storeApplication(applicationID,\n                 buildAppProto(applicationID, user, credentials,\n                     container.getLaunchContext().getApplicationACLs(),\n                     containerTokenIdentifier.getLogAggregationContext(),\n                     flowContext));\n \n             LOG.info(\n                 \"Updated application reference with flowContext \" + flowContext\n                     + \" for app \" + applicationID);\n           } else {\n             LOG.info(\"TimelineService V2.0 is not enabled. Skipping updating \"\n                 + \"flowContext for application \" + applicationID);\n           }\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId,\n             containerTokenIdentifier.getVersion(), containerStartTime, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n-        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n+        NMAuditLogger.logSuccess(remoteUser, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request, String remoteUser)\n      throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + remoteUser);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    // Sanity check for local resources\n    for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n        .getLocalResources().entrySet()) {\n      if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n        throw new YarnException(\"Null resource URL for local resource \"\n            + rsrc.getKey() + \" : \" + rsrc.getValue());\n      } else if (rsrc.getValue().getType() \u003d\u003d null) {\n        throw new YarnException(\"Null resource type for local resource \"\n            + rsrc.getKey() + \" : \" + rsrc.getValue());\n      } else if (rsrc.getValue().getVisibility() \u003d\u003d null) {\n        throw new YarnException(\"Null resource visibility for local resource \"\n            + rsrc.getKey() + \" : \" + rsrc.getValue());\n      }\n    }\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    long containerStartTime \u003d SystemClock.getInstance().getTime();\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context, containerStartTime);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(remoteUser, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        if (!context.getApplications().containsKey(applicationID)) {\n          // Create the application\n          // populate the flow context from the launch context if the timeline\n          // service v.2 is enabled\n          FlowContext flowContext \u003d\n              getFlowContext(launchContext, applicationID);\n\n          Application application \u003d\n              new ApplicationImpl(dispatcher, user, flowContext,\n                  applicationID, credentials, context);\n          if (context.getApplications().putIfAbsent(applicationID,\n              application) \u003d\u003d null) {\n            LOG.info(\"Creating a new application reference for app \"\n                + applicationID);\n            LogAggregationContext logAggregationContext \u003d\n                containerTokenIdentifier.getLogAggregationContext();\n            Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                container.getLaunchContext().getApplicationACLs();\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials, appAcls,\n                    logAggregationContext, flowContext));\n            dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                applicationID, appAcls, logAggregationContext));\n          }\n        } else if (containerTokenIdentifier.getContainerType()\n            \u003d\u003d ContainerType.APPLICATION_MASTER) {\n          FlowContext flowContext \u003d\n              getFlowContext(launchContext, applicationID);\n          if (flowContext !\u003d null) {\n            ApplicationImpl application \u003d\n                (ApplicationImpl) context.getApplications().get(applicationID);\n\n            // update flowContext reference in ApplicationImpl\n            application.setFlowContext(flowContext);\n\n            // Required to update state store for recovery.\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials,\n                    container.getLaunchContext().getApplicationACLs(),\n                    containerTokenIdentifier.getLogAggregationContext(),\n                    flowContext));\n\n            LOG.info(\n                \"Updated application reference with flowContext \" + flowContext\n                    + \" for app \" + applicationID);\n          } else {\n            LOG.info(\"TimelineService V2.0 is not enabled. Skipping updating \"\n                + \"flowContext for application \" + applicationID);\n          }\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId,\n            containerTokenIdentifier.getVersion(), containerStartTime, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(remoteUser, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "7f1d3d0e9dbe328fae0d43421665e0b6907b33fe": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8512. ATSv2 entities are not published to HBase from second attempt onwards. Contributed by Rohith Sharma K S.\n",
      "commitDate": "10/07/18 11:56 PM",
      "commitName": "7f1d3d0e9dbe328fae0d43421665e0b6907b33fe",
      "commitAuthor": "Sunil G",
      "commitDateOld": "06/04/18 9:25 PM",
      "commitNameOld": "00ebec89f101347a5da44657e388b30c57ed9deb",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 95.1,
      "commitsBetweenForRepo": 1192,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,121 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     // Sanity check for local resources\n     for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n         .getLocalResources().entrySet()) {\n       if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n         throw new YarnException(\n             \"Null resource URL for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n       } else if (rsrc.getValue().getType() \u003d\u003d null) {\n         throw new YarnException(\n             \"Null resource type for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n       } else if (rsrc.getValue().getVisibility() \u003d\u003d null) {\n         throw new YarnException(\n             \"Null resource visibility for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n       }\n     }\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     long containerStartTime \u003d SystemClock.getInstance().getTime();\n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context, containerStartTime);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         if (!context.getApplications().containsKey(applicationID)) {\n           // Create the application\n           // populate the flow context from the launch context if the timeline\n           // service v.2 is enabled\n-          FlowContext flowContext \u003d null;\n-          if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n-            String flowName \u003d launchContext.getEnvironment()\n-                .get(TimelineUtils.FLOW_NAME_TAG_PREFIX);\n-            String flowVersion \u003d launchContext.getEnvironment()\n-                .get(TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n-            String flowRunIdStr \u003d launchContext.getEnvironment()\n-                .get(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n-            long flowRunId \u003d 0L;\n-            if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n-              flowRunId \u003d Long.parseLong(flowRunIdStr);\n-            }\n-            flowContext \u003d new FlowContext(flowName, flowVersion, flowRunId);\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Flow context: \" + flowContext\n-                  + \" created for an application \" + applicationID);\n-            }\n-          }\n+          FlowContext flowContext \u003d\n+              getFlowContext(launchContext, applicationID);\n \n           Application application \u003d\n               new ApplicationImpl(dispatcher, user, flowContext,\n                   applicationID, credentials, context);\n           if (context.getApplications().putIfAbsent(applicationID,\n               application) \u003d\u003d null) {\n             LOG.info(\"Creating a new application reference for app \"\n                 + applicationID);\n             LogAggregationContext logAggregationContext \u003d\n                 containerTokenIdentifier.getLogAggregationContext();\n             Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                 container.getLaunchContext().getApplicationACLs();\n             context.getNMStateStore().storeApplication(applicationID,\n                 buildAppProto(applicationID, user, credentials, appAcls,\n                     logAggregationContext, flowContext));\n             dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                 applicationID, appAcls, logAggregationContext));\n           }\n+        } else if (containerTokenIdentifier.getContainerType()\n+            \u003d\u003d ContainerType.APPLICATION_MASTER) {\n+          FlowContext flowContext \u003d\n+              getFlowContext(launchContext, applicationID);\n+          if (flowContext !\u003d null) {\n+            ApplicationImpl application \u003d\n+                (ApplicationImpl) context.getApplications().get(applicationID);\n+\n+            // update flowContext reference in ApplicationImpl\n+            application.setFlowContext(flowContext);\n+\n+            // Required to update state store for recovery.\n+            context.getNMStateStore().storeApplication(applicationID,\n+                buildAppProto(applicationID, user, credentials,\n+                    container.getLaunchContext().getApplicationACLs(),\n+                    containerTokenIdentifier.getLogAggregationContext(),\n+                    flowContext));\n+\n+            LOG.info(\n+                \"Updated application reference with flowContext \" + flowContext\n+                    + \" for app \" + applicationID);\n+          } else {\n+            LOG.info(\"TimelineService V2.0 is not enabled. Skipping updating \"\n+                + \"flowContext for application \" + applicationID);\n+          }\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId,\n             containerTokenIdentifier.getVersion(), containerStartTime, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    // Sanity check for local resources\n    for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n        .getLocalResources().entrySet()) {\n      if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n        throw new YarnException(\n            \"Null resource URL for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n      } else if (rsrc.getValue().getType() \u003d\u003d null) {\n        throw new YarnException(\n            \"Null resource type for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n      } else if (rsrc.getValue().getVisibility() \u003d\u003d null) {\n        throw new YarnException(\n            \"Null resource visibility for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n      }\n    }\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    long containerStartTime \u003d SystemClock.getInstance().getTime();\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context, containerStartTime);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        if (!context.getApplications().containsKey(applicationID)) {\n          // Create the application\n          // populate the flow context from the launch context if the timeline\n          // service v.2 is enabled\n          FlowContext flowContext \u003d\n              getFlowContext(launchContext, applicationID);\n\n          Application application \u003d\n              new ApplicationImpl(dispatcher, user, flowContext,\n                  applicationID, credentials, context);\n          if (context.getApplications().putIfAbsent(applicationID,\n              application) \u003d\u003d null) {\n            LOG.info(\"Creating a new application reference for app \"\n                + applicationID);\n            LogAggregationContext logAggregationContext \u003d\n                containerTokenIdentifier.getLogAggregationContext();\n            Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                container.getLaunchContext().getApplicationACLs();\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials, appAcls,\n                    logAggregationContext, flowContext));\n            dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                applicationID, appAcls, logAggregationContext));\n          }\n        } else if (containerTokenIdentifier.getContainerType()\n            \u003d\u003d ContainerType.APPLICATION_MASTER) {\n          FlowContext flowContext \u003d\n              getFlowContext(launchContext, applicationID);\n          if (flowContext !\u003d null) {\n            ApplicationImpl application \u003d\n                (ApplicationImpl) context.getApplications().get(applicationID);\n\n            // update flowContext reference in ApplicationImpl\n            application.setFlowContext(flowContext);\n\n            // Required to update state store for recovery.\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials,\n                    container.getLaunchContext().getApplicationACLs(),\n                    containerTokenIdentifier.getLogAggregationContext(),\n                    flowContext));\n\n            LOG.info(\n                \"Updated application reference with flowContext \" + flowContext\n                    + \" for app \" + applicationID);\n          } else {\n            LOG.info(\"TimelineService V2.0 is not enabled. Skipping updating \"\n                + \"flowContext for application \" + applicationID);\n          }\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId,\n            containerTokenIdentifier.getVersion(), containerStartTime, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "092fead5d9875fb3760206bcdd76cdafec5e9481": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5792. Adopt the id prefix for YARN, MR, and DS entities. Contributed by Varun Saxena.\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "092fead5d9875fb3760206bcdd76cdafec5e9481",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "22/08/17 1:14 AM",
      "commitNameOld": "d5ff57a08fac983f8b5d201064ce07945f0f216e",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 7.91,
      "commitsBetweenForRepo": 57,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,112 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     // Sanity check for local resources\n     for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n         .getLocalResources().entrySet()) {\n       if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n         throw new YarnException(\n             \"Null resource URL for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n       } else if (rsrc.getValue().getType() \u003d\u003d null) {\n         throw new YarnException(\n             \"Null resource type for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n       } else if (rsrc.getValue().getVisibility() \u003d\u003d null) {\n         throw new YarnException(\n             \"Null resource visibility for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n       }\n     }\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n+    long containerStartTime \u003d SystemClock.getInstance().getTime();\n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n-            context);\n+            context, containerStartTime);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         if (!context.getApplications().containsKey(applicationID)) {\n           // Create the application\n           // populate the flow context from the launch context if the timeline\n           // service v.2 is enabled\n           FlowContext flowContext \u003d null;\n           if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n             String flowName \u003d launchContext.getEnvironment()\n                 .get(TimelineUtils.FLOW_NAME_TAG_PREFIX);\n             String flowVersion \u003d launchContext.getEnvironment()\n                 .get(TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n             String flowRunIdStr \u003d launchContext.getEnvironment()\n                 .get(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n             long flowRunId \u003d 0L;\n             if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n               flowRunId \u003d Long.parseLong(flowRunIdStr);\n             }\n             flowContext \u003d new FlowContext(flowName, flowVersion, flowRunId);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Flow context: \" + flowContext\n                   + \" created for an application \" + applicationID);\n             }\n           }\n \n           Application application \u003d\n               new ApplicationImpl(dispatcher, user, flowContext,\n                   applicationID, credentials, context);\n           if (context.getApplications().putIfAbsent(applicationID,\n               application) \u003d\u003d null) {\n             LOG.info(\"Creating a new application reference for app \"\n                 + applicationID);\n             LogAggregationContext logAggregationContext \u003d\n                 containerTokenIdentifier.getLogAggregationContext();\n             Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                 container.getLaunchContext().getApplicationACLs();\n             context.getNMStateStore().storeApplication(applicationID,\n                 buildAppProto(applicationID, user, credentials, appAcls,\n                     logAggregationContext, flowContext));\n             dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                 applicationID, appAcls, logAggregationContext));\n           }\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId,\n-            containerTokenIdentifier.getVersion(), request);\n+            containerTokenIdentifier.getVersion(), containerStartTime, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    // Sanity check for local resources\n    for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n        .getLocalResources().entrySet()) {\n      if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n        throw new YarnException(\n            \"Null resource URL for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n      } else if (rsrc.getValue().getType() \u003d\u003d null) {\n        throw new YarnException(\n            \"Null resource type for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n      } else if (rsrc.getValue().getVisibility() \u003d\u003d null) {\n        throw new YarnException(\n            \"Null resource visibility for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n      }\n    }\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    long containerStartTime \u003d SystemClock.getInstance().getTime();\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context, containerStartTime);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        if (!context.getApplications().containsKey(applicationID)) {\n          // Create the application\n          // populate the flow context from the launch context if the timeline\n          // service v.2 is enabled\n          FlowContext flowContext \u003d null;\n          if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n            String flowName \u003d launchContext.getEnvironment()\n                .get(TimelineUtils.FLOW_NAME_TAG_PREFIX);\n            String flowVersion \u003d launchContext.getEnvironment()\n                .get(TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n            String flowRunIdStr \u003d launchContext.getEnvironment()\n                .get(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n            long flowRunId \u003d 0L;\n            if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n              flowRunId \u003d Long.parseLong(flowRunIdStr);\n            }\n            flowContext \u003d new FlowContext(flowName, flowVersion, flowRunId);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Flow context: \" + flowContext\n                  + \" created for an application \" + applicationID);\n            }\n          }\n\n          Application application \u003d\n              new ApplicationImpl(dispatcher, user, flowContext,\n                  applicationID, credentials, context);\n          if (context.getApplications().putIfAbsent(applicationID,\n              application) \u003d\u003d null) {\n            LOG.info(\"Creating a new application reference for app \"\n                + applicationID);\n            LogAggregationContext logAggregationContext \u003d\n                containerTokenIdentifier.getLogAggregationContext();\n            Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                container.getLaunchContext().getApplicationACLs();\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials, appAcls,\n                    logAggregationContext, flowContext));\n            dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                applicationID, appAcls, logAggregationContext));\n          }\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId,\n            containerTokenIdentifier.getVersion(), containerStartTime, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "c8df3668ecc37c2d58cad35520a762eaec3c8539": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6837. Null LocalResource visibility or resource type can crash the nodemanager. Contributed by Jinjiang Ling\n",
      "commitDate": "20/07/17 9:03 AM",
      "commitName": "c8df3668ecc37c2d58cad35520a762eaec3c8539",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "22/06/17 11:27 AM",
      "commitNameOld": "49aa60e50d20f8c18ed6f00fa8966244536fe7da",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 27.9,
      "commitsBetweenForRepo": 134,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,105 +1,111 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     // Sanity check for local resources\n     for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n         .getLocalResources().entrySet()) {\n       if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n         throw new YarnException(\n             \"Null resource URL for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n+      } else if (rsrc.getValue().getType() \u003d\u003d null) {\n+        throw new YarnException(\n+            \"Null resource type for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n+      } else if (rsrc.getValue().getVisibility() \u003d\u003d null) {\n+        throw new YarnException(\n+            \"Null resource visibility for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n       }\n     }\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         if (!context.getApplications().containsKey(applicationID)) {\n           // Create the application\n           // populate the flow context from the launch context if the timeline\n           // service v.2 is enabled\n           FlowContext flowContext \u003d null;\n           if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n             String flowName \u003d launchContext.getEnvironment()\n                 .get(TimelineUtils.FLOW_NAME_TAG_PREFIX);\n             String flowVersion \u003d launchContext.getEnvironment()\n                 .get(TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n             String flowRunIdStr \u003d launchContext.getEnvironment()\n                 .get(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n             long flowRunId \u003d 0L;\n             if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n               flowRunId \u003d Long.parseLong(flowRunIdStr);\n             }\n             flowContext \u003d new FlowContext(flowName, flowVersion, flowRunId);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Flow context: \" + flowContext\n                   + \" created for an application \" + applicationID);\n             }\n           }\n \n           Application application \u003d\n               new ApplicationImpl(dispatcher, user, flowContext,\n                   applicationID, credentials, context);\n           if (context.getApplications().putIfAbsent(applicationID,\n               application) \u003d\u003d null) {\n             LOG.info(\"Creating a new application reference for app \"\n                 + applicationID);\n             LogAggregationContext logAggregationContext \u003d\n                 containerTokenIdentifier.getLogAggregationContext();\n             Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                 container.getLaunchContext().getApplicationACLs();\n             context.getNMStateStore().storeApplication(applicationID,\n                 buildAppProto(applicationID, user, credentials, appAcls,\n                     logAggregationContext, flowContext));\n             dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                 applicationID, appAcls, logAggregationContext));\n           }\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId,\n             containerTokenIdentifier.getVersion(), request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    // Sanity check for local resources\n    for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n        .getLocalResources().entrySet()) {\n      if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n        throw new YarnException(\n            \"Null resource URL for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n      } else if (rsrc.getValue().getType() \u003d\u003d null) {\n        throw new YarnException(\n            \"Null resource type for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n      } else if (rsrc.getValue().getVisibility() \u003d\u003d null) {\n        throw new YarnException(\n            \"Null resource visibility for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n      }\n    }\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        if (!context.getApplications().containsKey(applicationID)) {\n          // Create the application\n          // populate the flow context from the launch context if the timeline\n          // service v.2 is enabled\n          FlowContext flowContext \u003d null;\n          if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n            String flowName \u003d launchContext.getEnvironment()\n                .get(TimelineUtils.FLOW_NAME_TAG_PREFIX);\n            String flowVersion \u003d launchContext.getEnvironment()\n                .get(TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n            String flowRunIdStr \u003d launchContext.getEnvironment()\n                .get(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n            long flowRunId \u003d 0L;\n            if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n              flowRunId \u003d Long.parseLong(flowRunIdStr);\n            }\n            flowContext \u003d new FlowContext(flowName, flowVersion, flowRunId);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Flow context: \" + flowContext\n                  + \" created for an application \" + applicationID);\n            }\n          }\n\n          Application application \u003d\n              new ApplicationImpl(dispatcher, user, flowContext,\n                  applicationID, credentials, context);\n          if (context.getApplications().putIfAbsent(applicationID,\n              application) \u003d\u003d null) {\n            LOG.info(\"Creating a new application reference for app \"\n                + applicationID);\n            LogAggregationContext logAggregationContext \u003d\n                containerTokenIdentifier.getLogAggregationContext();\n            Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                container.getLaunchContext().getApplicationACLs();\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials, appAcls,\n                    logAggregationContext, flowContext));\n            dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                applicationID, appAcls, logAggregationContext));\n          }\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId,\n            containerTokenIdentifier.getVersion(), request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "47474fffac085e0e5ea46336bf80ccd0677017a3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6555. Store application flow context in NM state store for work-preserving restart. (Rohith Sharma K S via Haibo Chen)\n",
      "commitDate": "25/05/17 9:15 PM",
      "commitName": "47474fffac085e0e5ea46336bf80ccd0677017a3",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "08/05/17 3:14 PM",
      "commitNameOld": "424887ecb7d11a72837f2757ed3ff9e0fe8c5b5d",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 17.25,
      "commitsBetweenForRepo": 105,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,105 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     // Sanity check for local resources\n     for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n         .getLocalResources().entrySet()) {\n       if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n         throw new YarnException(\n             \"Null resource URL for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n       }\n     }\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n-        // Create the application\n-        // populate the flow context from the launch context if the timeline\n-        // service v.2 is enabled\n-        FlowContext flowContext \u003d null;\n-        if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n-          String flowName \u003d launchContext.getEnvironment().get(\n-              TimelineUtils.FLOW_NAME_TAG_PREFIX);\n-          String flowVersion \u003d launchContext.getEnvironment().get(\n-              TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n-          String flowRunIdStr \u003d launchContext.getEnvironment().get(\n-              TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n-          long flowRunId \u003d 0L;\n-          if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n-            flowRunId \u003d Long.parseLong(flowRunIdStr);\n-          }\n-          flowContext \u003d\n-              new FlowContext(flowName, flowVersion, flowRunId);\n-        }\n         if (!context.getApplications().containsKey(applicationID)) {\n+          // Create the application\n+          // populate the flow context from the launch context if the timeline\n+          // service v.2 is enabled\n+          FlowContext flowContext \u003d null;\n+          if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n+            String flowName \u003d launchContext.getEnvironment()\n+                .get(TimelineUtils.FLOW_NAME_TAG_PREFIX);\n+            String flowVersion \u003d launchContext.getEnvironment()\n+                .get(TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n+            String flowRunIdStr \u003d launchContext.getEnvironment()\n+                .get(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n+            long flowRunId \u003d 0L;\n+            if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n+              flowRunId \u003d Long.parseLong(flowRunIdStr);\n+            }\n+            flowContext \u003d new FlowContext(flowName, flowVersion, flowRunId);\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Flow context: \" + flowContext\n+                  + \" created for an application \" + applicationID);\n+            }\n+          }\n+\n           Application application \u003d\n               new ApplicationImpl(dispatcher, user, flowContext,\n                   applicationID, credentials, context);\n           if (context.getApplications().putIfAbsent(applicationID,\n               application) \u003d\u003d null) {\n             LOG.info(\"Creating a new application reference for app \"\n                 + applicationID);\n             LogAggregationContext logAggregationContext \u003d\n                 containerTokenIdentifier.getLogAggregationContext();\n             Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                 container.getLaunchContext().getApplicationACLs();\n             context.getNMStateStore().storeApplication(applicationID,\n                 buildAppProto(applicationID, user, credentials, appAcls,\n-                    logAggregationContext));\n+                    logAggregationContext, flowContext));\n             dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                 applicationID, appAcls, logAggregationContext));\n           }\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId,\n             containerTokenIdentifier.getVersion(), request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    // Sanity check for local resources\n    for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n        .getLocalResources().entrySet()) {\n      if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n        throw new YarnException(\n            \"Null resource URL for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n      }\n    }\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        if (!context.getApplications().containsKey(applicationID)) {\n          // Create the application\n          // populate the flow context from the launch context if the timeline\n          // service v.2 is enabled\n          FlowContext flowContext \u003d null;\n          if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n            String flowName \u003d launchContext.getEnvironment()\n                .get(TimelineUtils.FLOW_NAME_TAG_PREFIX);\n            String flowVersion \u003d launchContext.getEnvironment()\n                .get(TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n            String flowRunIdStr \u003d launchContext.getEnvironment()\n                .get(TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n            long flowRunId \u003d 0L;\n            if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n              flowRunId \u003d Long.parseLong(flowRunIdStr);\n            }\n            flowContext \u003d new FlowContext(flowName, flowVersion, flowRunId);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Flow context: \" + flowContext\n                  + \" created for an application \" + applicationID);\n            }\n          }\n\n          Application application \u003d\n              new ApplicationImpl(dispatcher, user, flowContext,\n                  applicationID, credentials, context);\n          if (context.getApplications().putIfAbsent(applicationID,\n              application) \u003d\u003d null) {\n            LOG.info(\"Creating a new application reference for app \"\n                + applicationID);\n            LogAggregationContext logAggregationContext \u003d\n                containerTokenIdentifier.getLogAggregationContext();\n            Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                container.getLaunchContext().getApplicationACLs();\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials, appAcls,\n                    logAggregationContext, flowContext));\n            dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                applicationID, appAcls, logAggregationContext));\n          }\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId,\n            containerTokenIdentifier.getVersion(), request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "e8071aa249c7b21b1de084ee5a9ca2a44efd3bf0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6403. Invalid local resource request can raise NPE and make NM exit. Contributed by Tao Yang\n",
      "commitDate": "05/04/17 10:30 AM",
      "commitName": "e8071aa249c7b21b1de084ee5a9ca2a44efd3bf0",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "16/03/17 7:30 AM",
      "commitNameOld": "7114baddb627628a54cdab77f68504332a5a0e28",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 20.13,
      "commitsBetweenForRepo": 116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,101 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n+    // Sanity check for local resources\n+    for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n+        .getLocalResources().entrySet()) {\n+      if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n+        throw new YarnException(\n+            \"Null resource URL for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n+      }\n+    }\n+\n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         // Create the application\n         // populate the flow context from the launch context if the timeline\n         // service v.2 is enabled\n         FlowContext flowContext \u003d null;\n         if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n           String flowName \u003d launchContext.getEnvironment().get(\n               TimelineUtils.FLOW_NAME_TAG_PREFIX);\n           String flowVersion \u003d launchContext.getEnvironment().get(\n               TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n           String flowRunIdStr \u003d launchContext.getEnvironment().get(\n               TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n           long flowRunId \u003d 0L;\n           if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n             flowRunId \u003d Long.parseLong(flowRunIdStr);\n           }\n           flowContext \u003d\n               new FlowContext(flowName, flowVersion, flowRunId);\n         }\n         if (!context.getApplications().containsKey(applicationID)) {\n           Application application \u003d\n               new ApplicationImpl(dispatcher, user, flowContext,\n                   applicationID, credentials, context);\n           if (context.getApplications().putIfAbsent(applicationID,\n               application) \u003d\u003d null) {\n             LOG.info(\"Creating a new application reference for app \"\n                 + applicationID);\n             LogAggregationContext logAggregationContext \u003d\n                 containerTokenIdentifier.getLogAggregationContext();\n             Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                 container.getLaunchContext().getApplicationACLs();\n             context.getNMStateStore().storeApplication(applicationID,\n                 buildAppProto(applicationID, user, credentials, appAcls,\n                     logAggregationContext));\n             dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                 applicationID, appAcls, logAggregationContext));\n           }\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId,\n             containerTokenIdentifier.getVersion(), request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    // Sanity check for local resources\n    for (Map.Entry\u003cString, LocalResource\u003e rsrc : launchContext\n        .getLocalResources().entrySet()) {\n      if (rsrc.getValue() \u003d\u003d null || rsrc.getValue().getResource() \u003d\u003d null) {\n        throw new YarnException(\n            \"Null resource URL for local resource \" + rsrc.getKey() + \" : \" + rsrc.getValue());\n      }\n    }\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        // Create the application\n        // populate the flow context from the launch context if the timeline\n        // service v.2 is enabled\n        FlowContext flowContext \u003d null;\n        if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n          String flowName \u003d launchContext.getEnvironment().get(\n              TimelineUtils.FLOW_NAME_TAG_PREFIX);\n          String flowVersion \u003d launchContext.getEnvironment().get(\n              TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n          String flowRunIdStr \u003d launchContext.getEnvironment().get(\n              TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n          long flowRunId \u003d 0L;\n          if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n            flowRunId \u003d Long.parseLong(flowRunIdStr);\n          }\n          flowContext \u003d\n              new FlowContext(flowName, flowVersion, flowRunId);\n        }\n        if (!context.getApplications().containsKey(applicationID)) {\n          Application application \u003d\n              new ApplicationImpl(dispatcher, user, flowContext,\n                  applicationID, credentials, context);\n          if (context.getApplications().putIfAbsent(applicationID,\n              application) \u003d\u003d null) {\n            LOG.info(\"Creating a new application reference for app \"\n                + applicationID);\n            LogAggregationContext logAggregationContext \u003d\n                containerTokenIdentifier.getLogAggregationContext();\n            Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                container.getLaunchContext().getApplicationACLs();\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials, appAcls,\n                    logAggregationContext));\n            dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                applicationID, appAcls, logAggregationContext));\n          }\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId,\n            containerTokenIdentifier.getVersion(), request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "de3a5f8d08f64d0c2021a84b40e63e716da2321c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5856. Unnecessary duplicate start container request sent to NM State store. Contributed by Varun Saxena.\n",
      "commitDate": "09/11/16 4:12 PM",
      "commitName": "de3a5f8d08f64d0c2021a84b40e63e716da2321c",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "09/11/16 12:11 AM",
      "commitNameOld": "283fa33febe043bd7b4fa87546be26c9c5a8f8b5",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 0.67,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,92 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         // Create the application\n         // populate the flow context from the launch context if the timeline\n         // service v.2 is enabled\n         FlowContext flowContext \u003d null;\n         if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n           String flowName \u003d launchContext.getEnvironment().get(\n               TimelineUtils.FLOW_NAME_TAG_PREFIX);\n           String flowVersion \u003d launchContext.getEnvironment().get(\n               TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n           String flowRunIdStr \u003d launchContext.getEnvironment().get(\n               TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n           long flowRunId \u003d 0L;\n           if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n             flowRunId \u003d Long.parseLong(flowRunIdStr);\n           }\n           flowContext \u003d\n               new FlowContext(flowName, flowVersion, flowRunId);\n         }\n         if (!context.getApplications().containsKey(applicationID)) {\n           Application application \u003d\n               new ApplicationImpl(dispatcher, user, flowContext,\n                   applicationID, credentials, context);\n           if (context.getApplications().putIfAbsent(applicationID,\n               application) \u003d\u003d null) {\n             LOG.info(\"Creating a new application reference for app \"\n                 + applicationID);\n             LogAggregationContext logAggregationContext \u003d\n                 containerTokenIdentifier.getLogAggregationContext();\n             Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                 container.getLaunchContext().getApplicationACLs();\n             context.getNMStateStore().storeApplication(applicationID,\n                 buildAppProto(applicationID, user, credentials, appAcls,\n                     logAggregationContext));\n             dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                 applicationID, appAcls, logAggregationContext));\n           }\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId,\n             containerTokenIdentifier.getVersion(), request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n-        this.context.getNMStateStore().storeContainer(containerId,\n-            containerTokenIdentifier.getVersion(), request);\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        // Create the application\n        // populate the flow context from the launch context if the timeline\n        // service v.2 is enabled\n        FlowContext flowContext \u003d null;\n        if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n          String flowName \u003d launchContext.getEnvironment().get(\n              TimelineUtils.FLOW_NAME_TAG_PREFIX);\n          String flowVersion \u003d launchContext.getEnvironment().get(\n              TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n          String flowRunIdStr \u003d launchContext.getEnvironment().get(\n              TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n          long flowRunId \u003d 0L;\n          if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n            flowRunId \u003d Long.parseLong(flowRunIdStr);\n          }\n          flowContext \u003d\n              new FlowContext(flowName, flowVersion, flowRunId);\n        }\n        if (!context.getApplications().containsKey(applicationID)) {\n          Application application \u003d\n              new ApplicationImpl(dispatcher, user, flowContext,\n                  applicationID, credentials, context);\n          if (context.getApplications().putIfAbsent(applicationID,\n              application) \u003d\u003d null) {\n            LOG.info(\"Creating a new application reference for app \"\n                + applicationID);\n            LogAggregationContext logAggregationContext \u003d\n                containerTokenIdentifier.getLogAggregationContext();\n            Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                container.getLaunchContext().getApplicationACLs();\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials, appAcls,\n                    logAggregationContext));\n            dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                applicationID, appAcls, logAggregationContext));\n          }\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId,\n            containerTokenIdentifier.getVersion(), request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "d6d9cff21b7b6141ed88359652cf22e8973c0661": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5221. Expose UpdateResourceRequest API to allow AM to request for change in container properties. (asuresh)\n",
      "commitDate": "30/08/16 3:52 PM",
      "commitName": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "26/08/16 9:04 AM",
      "commitNameOld": "9ef632f3b0b0e0808116cd1c7482a205b7ebef7d",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 4.28,
      "commitsBetweenForRepo": 24,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,94 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         // Create the application\n         // populate the flow context from the launch context if the timeline\n         // service v.2 is enabled\n         FlowContext flowContext \u003d null;\n         if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n           String flowName \u003d launchContext.getEnvironment().get(\n               TimelineUtils.FLOW_NAME_TAG_PREFIX);\n           String flowVersion \u003d launchContext.getEnvironment().get(\n               TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n           String flowRunIdStr \u003d launchContext.getEnvironment().get(\n               TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n           long flowRunId \u003d 0L;\n           if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n             flowRunId \u003d Long.parseLong(flowRunIdStr);\n           }\n           flowContext \u003d\n               new FlowContext(flowName, flowVersion, flowRunId);\n         }\n         if (!context.getApplications().containsKey(applicationID)) {\n           Application application \u003d\n               new ApplicationImpl(dispatcher, user, flowContext,\n                   applicationID, credentials, context);\n           if (context.getApplications().putIfAbsent(applicationID,\n               application) \u003d\u003d null) {\n             LOG.info(\"Creating a new application reference for app \"\n                 + applicationID);\n             LogAggregationContext logAggregationContext \u003d\n                 containerTokenIdentifier.getLogAggregationContext();\n             Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                 container.getLaunchContext().getApplicationACLs();\n             context.getNMStateStore().storeApplication(applicationID,\n                 buildAppProto(applicationID, user, credentials, appAcls,\n                     logAggregationContext));\n             dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                 applicationID, appAcls, logAggregationContext));\n           }\n         }\n \n+        this.context.getNMStateStore().storeContainer(containerId,\n+            containerTokenIdentifier.getVersion(), request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n-        this.context.getNMStateStore().storeContainer(containerId, request);\n+        this.context.getNMStateStore().storeContainer(containerId,\n+            containerTokenIdentifier.getVersion(), request);\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        // Create the application\n        // populate the flow context from the launch context if the timeline\n        // service v.2 is enabled\n        FlowContext flowContext \u003d null;\n        if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n          String flowName \u003d launchContext.getEnvironment().get(\n              TimelineUtils.FLOW_NAME_TAG_PREFIX);\n          String flowVersion \u003d launchContext.getEnvironment().get(\n              TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n          String flowRunIdStr \u003d launchContext.getEnvironment().get(\n              TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n          long flowRunId \u003d 0L;\n          if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n            flowRunId \u003d Long.parseLong(flowRunIdStr);\n          }\n          flowContext \u003d\n              new FlowContext(flowName, flowVersion, flowRunId);\n        }\n        if (!context.getApplications().containsKey(applicationID)) {\n          Application application \u003d\n              new ApplicationImpl(dispatcher, user, flowContext,\n                  applicationID, credentials, context);\n          if (context.getApplications().putIfAbsent(applicationID,\n              application) \u003d\u003d null) {\n            LOG.info(\"Creating a new application reference for app \"\n                + applicationID);\n            LogAggregationContext logAggregationContext \u003d\n                containerTokenIdentifier.getLogAggregationContext();\n            Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                container.getLaunchContext().getApplicationACLs();\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials, appAcls,\n                    logAggregationContext));\n            dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                applicationID, appAcls, logAggregationContext));\n          }\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId,\n            containerTokenIdentifier.getVersion(), request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n        this.context.getNMStateStore().storeContainer(containerId,\n            containerTokenIdentifier.getVersion(), request);\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "89e5c44f9e891a3579384c3fa3766937cd4970f1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4356. Ensure the timeline service v.2 is disabled cleanly and has no\nimpact when it\u0027s turned off. Contributed by Sangjin Lee.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "8d9476ec5f64795e2bdd60bea4d643eaafed2c50",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,91 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         // Create the application\n-        String flowName \u003d launchContext.getEnvironment().get(\n-            TimelineUtils.FLOW_NAME_TAG_PREFIX);\n-        String flowVersion \u003d launchContext.getEnvironment().get(\n-            TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n-        String flowRunIdStr \u003d launchContext.getEnvironment().get(\n-            TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n-        long flowRunId \u003d 0L;\n-        if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n-          flowRunId \u003d Long.parseLong(flowRunIdStr);\n+        // populate the flow context from the launch context if the timeline\n+        // service v.2 is enabled\n+        FlowContext flowContext \u003d null;\n+        if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n+          String flowName \u003d launchContext.getEnvironment().get(\n+              TimelineUtils.FLOW_NAME_TAG_PREFIX);\n+          String flowVersion \u003d launchContext.getEnvironment().get(\n+              TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n+          String flowRunIdStr \u003d launchContext.getEnvironment().get(\n+              TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n+          long flowRunId \u003d 0L;\n+          if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n+            flowRunId \u003d Long.parseLong(flowRunIdStr);\n+          }\n+          flowContext \u003d\n+              new FlowContext(flowName, flowVersion, flowRunId);\n         }\n         if (!context.getApplications().containsKey(applicationID)) {\n           Application application \u003d\n-              new ApplicationImpl(dispatcher, user, flowName, flowVersion,\n-                  flowRunId, applicationID, credentials, context);\n+              new ApplicationImpl(dispatcher, user, flowContext,\n+                  applicationID, credentials, context);\n           if (context.getApplications().putIfAbsent(applicationID,\n               application) \u003d\u003d null) {\n             LOG.info(\"Creating a new application reference for app \"\n                 + applicationID);\n             LogAggregationContext logAggregationContext \u003d\n                 containerTokenIdentifier.getLogAggregationContext();\n             Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                 container.getLaunchContext().getApplicationACLs();\n             context.getNMStateStore().storeApplication(applicationID,\n                 buildAppProto(applicationID, user, credentials, appAcls,\n                     logAggregationContext));\n             dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                 applicationID, appAcls, logAggregationContext));\n           }\n         }\n \n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n         this.context.getNMStateStore().storeContainer(containerId, request);\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        // Create the application\n        // populate the flow context from the launch context if the timeline\n        // service v.2 is enabled\n        FlowContext flowContext \u003d null;\n        if (YarnConfiguration.timelineServiceV2Enabled(getConfig())) {\n          String flowName \u003d launchContext.getEnvironment().get(\n              TimelineUtils.FLOW_NAME_TAG_PREFIX);\n          String flowVersion \u003d launchContext.getEnvironment().get(\n              TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n          String flowRunIdStr \u003d launchContext.getEnvironment().get(\n              TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n          long flowRunId \u003d 0L;\n          if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n            flowRunId \u003d Long.parseLong(flowRunIdStr);\n          }\n          flowContext \u003d\n              new FlowContext(flowName, flowVersion, flowRunId);\n        }\n        if (!context.getApplications().containsKey(applicationID)) {\n          Application application \u003d\n              new ApplicationImpl(dispatcher, user, flowContext,\n                  applicationID, credentials, context);\n          if (context.getApplications().putIfAbsent(applicationID,\n              application) \u003d\u003d null) {\n            LOG.info(\"Creating a new application reference for app \"\n                + applicationID);\n            LogAggregationContext logAggregationContext \u003d\n                containerTokenIdentifier.getLogAggregationContext();\n            Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                container.getLaunchContext().getApplicationACLs();\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials, appAcls,\n                    logAggregationContext));\n            dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                applicationID, appAcls, logAggregationContext));\n          }\n        }\n\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n        this.context.getNMStateStore().storeContainer(containerId, request);\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "8d9476ec5f64795e2bdd60bea4d643eaafed2c50": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4058. Miscellaneous issues in NodeManager project (Naganarasimha G R via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "8d9476ec5f64795e2bdd60bea4d643eaafed2c50",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "477a30f536277bf95d7181bf1b2fdda52d83bf51",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,84 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         // Create the application\n         String flowName \u003d launchContext.getEnvironment().get(\n             TimelineUtils.FLOW_NAME_TAG_PREFIX);\n         String flowVersion \u003d launchContext.getEnvironment().get(\n             TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n         String flowRunIdStr \u003d launchContext.getEnvironment().get(\n             TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n         long flowRunId \u003d 0L;\n         if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n           flowRunId \u003d Long.parseLong(flowRunIdStr);\n         }\n-        Application application \u003d new ApplicationImpl(dispatcher, user,\n-            flowName, flowVersion, flowRunId, applicationID, credentials, context);\n-        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n-          application)) {\n-          LOG.info(\"Creating a new application reference for app \"\n-              + applicationID);\n-          LogAggregationContext logAggregationContext \u003d\n-              containerTokenIdentifier.getLogAggregationContext();\n-          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n-              container.getLaunchContext().getApplicationACLs();\n-          context.getNMStateStore().storeApplication(applicationID,\n-              buildAppProto(applicationID, user, credentials, appAcls,\n-                logAggregationContext));\n-          dispatcher.getEventHandler().handle(\n-            new ApplicationInitEvent(applicationID, appAcls,\n-              logAggregationContext));\n+        if (!context.getApplications().containsKey(applicationID)) {\n+          Application application \u003d\n+              new ApplicationImpl(dispatcher, user, flowName, flowVersion,\n+                  flowRunId, applicationID, credentials, context);\n+          if (context.getApplications().putIfAbsent(applicationID,\n+              application) \u003d\u003d null) {\n+            LOG.info(\"Creating a new application reference for app \"\n+                + applicationID);\n+            LogAggregationContext logAggregationContext \u003d\n+                containerTokenIdentifier.getLogAggregationContext();\n+            Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n+                container.getLaunchContext().getApplicationACLs();\n+            context.getNMStateStore().storeApplication(applicationID,\n+                buildAppProto(applicationID, user, credentials, appAcls,\n+                    logAggregationContext));\n+            dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n+                applicationID, appAcls, logAggregationContext));\n+          }\n         }\n \n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n         this.context.getNMStateStore().storeContainer(containerId, request);\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        // Create the application\n        String flowName \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_NAME_TAG_PREFIX);\n        String flowVersion \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n        String flowRunIdStr \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n        long flowRunId \u003d 0L;\n        if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n          flowRunId \u003d Long.parseLong(flowRunIdStr);\n        }\n        if (!context.getApplications().containsKey(applicationID)) {\n          Application application \u003d\n              new ApplicationImpl(dispatcher, user, flowName, flowVersion,\n                  flowRunId, applicationID, credentials, context);\n          if (context.getApplications().putIfAbsent(applicationID,\n              application) \u003d\u003d null) {\n            LOG.info(\"Creating a new application reference for app \"\n                + applicationID);\n            LogAggregationContext logAggregationContext \u003d\n                containerTokenIdentifier.getLogAggregationContext();\n            Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n                container.getLaunchContext().getApplicationACLs();\n            context.getNMStateStore().storeApplication(applicationID,\n                buildAppProto(applicationID, user, credentials, appAcls,\n                    logAggregationContext));\n            dispatcher.getEventHandler().handle(new ApplicationInitEvent(\n                applicationID, appAcls, logAggregationContext));\n          }\n        }\n\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n        this.context.getNMStateStore().storeContainer(containerId, request);\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "477a30f536277bf95d7181bf1b2fdda52d83bf51": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3045. Implement NM writing container lifecycle events to Timeline Service v2. Contributed by Naganarasimha G R.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "477a30f536277bf95d7181bf1b2fdda52d83bf51",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "d275677e240cca469a4cec3dc7238e3f18b3f7e9",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         // Create the application\n         String flowName \u003d launchContext.getEnvironment().get(\n             TimelineUtils.FLOW_NAME_TAG_PREFIX);\n         String flowVersion \u003d launchContext.getEnvironment().get(\n             TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n         String flowRunIdStr \u003d launchContext.getEnvironment().get(\n             TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n         long flowRunId \u003d 0L;\n         if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n           flowRunId \u003d Long.parseLong(flowRunIdStr);\n         }\n         Application application \u003d new ApplicationImpl(dispatcher, user,\n             flowName, flowVersion, flowRunId, applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n           LOG.info(\"Creating a new application reference for app \"\n               + applicationID);\n           LogAggregationContext logAggregationContext \u003d\n               containerTokenIdentifier.getLogAggregationContext();\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n               buildAppProto(applicationID, user, credentials, appAcls,\n                 logAggregationContext));\n           dispatcher.getEventHandler().handle(\n             new ApplicationInitEvent(applicationID, appAcls,\n               logAggregationContext));\n         }\n \n-        this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n+        this.context.getNMStateStore().storeContainer(containerId, request);\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        // Create the application\n        String flowName \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_NAME_TAG_PREFIX);\n        String flowVersion \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n        String flowRunIdStr \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n        long flowRunId \u003d 0L;\n        if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n          flowRunId \u003d Long.parseLong(flowRunIdStr);\n        }\n        Application application \u003d new ApplicationImpl(dispatcher, user,\n            flowName, flowVersion, flowRunId, applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \"\n              + applicationID);\n          LogAggregationContext logAggregationContext \u003d\n              containerTokenIdentifier.getLogAggregationContext();\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls,\n                logAggregationContext));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls,\n              logAggregationContext));\n        }\n\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n        this.context.getNMStateStore().storeContainer(containerId, request);\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "d275677e240cca469a4cec3dc7238e3f18b3f7e9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3634. TestMRTimelineEventHandling and TestApplication are broken. Contributed by Sangjin Lee.\n\n(cherry picked from commit b059dd4882fd759e4762cc11c019be4b68fb74c1)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "d275677e240cca469a4cec3dc7238e3f18b3f7e9",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "47f35a30bb4d99349593e9d6e1c9e76e71341c40",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,82 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         // Create the application\n         String flowName \u003d launchContext.getEnvironment().get(\n             TimelineUtils.FLOW_NAME_TAG_PREFIX);\n         String flowVersion \u003d launchContext.getEnvironment().get(\n             TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n         String flowRunIdStr \u003d launchContext.getEnvironment().get(\n             TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n         long flowRunId \u003d 0L;\n         if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n-          flowRunId \u003d Long.valueOf(flowRunIdStr);\n+          flowRunId \u003d Long.parseLong(flowRunIdStr);\n         }\n         Application application \u003d new ApplicationImpl(dispatcher, user,\n             flowName, flowVersion, flowRunId, applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n           LOG.info(\"Creating a new application reference for app \"\n               + applicationID);\n           LogAggregationContext logAggregationContext \u003d\n               containerTokenIdentifier.getLogAggregationContext();\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n               buildAppProto(applicationID, user, credentials, appAcls,\n                 logAggregationContext));\n           dispatcher.getEventHandler().handle(\n             new ApplicationInitEvent(applicationID, appAcls,\n               logAggregationContext));\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        // Create the application\n        String flowName \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_NAME_TAG_PREFIX);\n        String flowVersion \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n        String flowRunIdStr \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n        long flowRunId \u003d 0L;\n        if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n          flowRunId \u003d Long.parseLong(flowRunIdStr);\n        }\n        Application application \u003d new ApplicationImpl(dispatcher, user,\n            flowName, flowVersion, flowRunId, applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \"\n              + applicationID);\n          LogAggregationContext logAggregationContext \u003d\n              containerTokenIdentifier.getLogAggregationContext();\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls,\n                logAggregationContext));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls,\n              logAggregationContext));\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "47f35a30bb4d99349593e9d6e1c9e76e71341c40": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3391. Clearly define flow ID/ flow run / flow version in API and storage. Contributed by Zhijie Shen\n\n(cherry picked from commit 68c6232f8423e55b4d152ef3d1d66aeb2d6a555e)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "47f35a30bb4d99349593e9d6e1c9e76e71341c40",
      "commitAuthor": "Junping Du",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "d67c9bdb4db2b075484a779802ecf3296bad5cd4",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,82 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         // Create the application\n-        String flowId \u003d launchContext.getEnvironment().get(\n-            TimelineUtils.FLOW_ID_TAG_PREFIX);\n-        String flowRunId \u003d launchContext.getEnvironment().get(\n+        String flowName \u003d launchContext.getEnvironment().get(\n+            TimelineUtils.FLOW_NAME_TAG_PREFIX);\n+        String flowVersion \u003d launchContext.getEnvironment().get(\n+            TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n+        String flowRunIdStr \u003d launchContext.getEnvironment().get(\n             TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n-        Application application \u003d new ApplicationImpl(\n-            dispatcher, user, flowId, flowRunId, applicationID, credentials, context);\n+        long flowRunId \u003d 0L;\n+        if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n+          flowRunId \u003d Long.valueOf(flowRunIdStr);\n+        }\n+        Application application \u003d new ApplicationImpl(dispatcher, user,\n+            flowName, flowVersion, flowRunId, applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n           LOG.info(\"Creating a new application reference for app \"\n               + applicationID);\n           LogAggregationContext logAggregationContext \u003d\n               containerTokenIdentifier.getLogAggregationContext();\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n               buildAppProto(applicationID, user, credentials, appAcls,\n                 logAggregationContext));\n           dispatcher.getEventHandler().handle(\n             new ApplicationInitEvent(applicationID, appAcls,\n               logAggregationContext));\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        // Create the application\n        String flowName \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_NAME_TAG_PREFIX);\n        String flowVersion \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_VERSION_TAG_PREFIX);\n        String flowRunIdStr \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n        long flowRunId \u003d 0L;\n        if (flowRunIdStr !\u003d null \u0026\u0026 !flowRunIdStr.isEmpty()) {\n          flowRunId \u003d Long.valueOf(flowRunIdStr);\n        }\n        Application application \u003d new ApplicationImpl(dispatcher, user,\n            flowName, flowVersion, flowRunId, applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \"\n              + applicationID);\n          LogAggregationContext logAggregationContext \u003d\n              containerTokenIdentifier.getLogAggregationContext();\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls,\n                logAggregationContext));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls,\n              logAggregationContext));\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "d67c9bdb4db2b075484a779802ecf3296bad5cd4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3040. Make putEntities operation be aware of the app\u0027s context. Contributed by Zhijie Shen\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "d67c9bdb4db2b075484a779802ecf3296bad5cd4",
      "commitAuthor": "Junping Du",
      "commitDateOld": "06/06/16 2:30 PM",
      "commitNameOld": "4a1cedc010d3fa1d8ef3f2773ca12acadfee5ba5",
      "commitAuthorOld": "Ming Ma",
      "daysBetweenCommits": 33.76,
      "commitsBetweenForRepo": 236,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,76 @@\n   protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         // Create the application\n-        Application application \u003d new ApplicationImpl(dispatcher, user,\n-            applicationID, credentials, context);\n+        String flowId \u003d launchContext.getEnvironment().get(\n+            TimelineUtils.FLOW_ID_TAG_PREFIX);\n+        String flowRunId \u003d launchContext.getEnvironment().get(\n+            TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n+        Application application \u003d new ApplicationImpl(\n+            dispatcher, user, flowId, flowRunId, applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n           LOG.info(\"Creating a new application reference for app \"\n               + applicationID);\n           LogAggregationContext logAggregationContext \u003d\n               containerTokenIdentifier.getLogAggregationContext();\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n               buildAppProto(applicationID, user, credentials, appAcls,\n                 logAggregationContext));\n           dispatcher.getEventHandler().handle(\n             new ApplicationInitEvent(applicationID, appAcls,\n               logAggregationContext));\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        // Create the application\n        String flowId \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_ID_TAG_PREFIX);\n        String flowRunId \u003d launchContext.getEnvironment().get(\n            TimelineUtils.FLOW_RUN_ID_TAG_PREFIX);\n        Application application \u003d new ApplicationImpl(\n            dispatcher, user, flowId, flowRunId, applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \"\n              + applicationID);\n          LogAggregationContext logAggregationContext \u003d\n              containerTokenIdentifier.getLogAggregationContext();\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls,\n                logAggregationContext));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls,\n              logAggregationContext));\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "d971bf252f36e902a0fe446cb11201835ad16bcb": {
      "type": "Yparameterchange",
      "commitMessage": "YARN-5073. Refactor startContainerInternal() in ContainerManager to remove unused parameter. (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "10/05/16 10:31 PM",
      "commitName": "d971bf252f36e902a0fe446cb11201835ad16bcb",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "29/04/16 3:39 AM",
      "commitNameOld": "0f25a1bb52bc56661fd020a6ba82df99f8c6ef1f",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 11.79,
      "commitsBetweenForRepo": 65,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n-  protected void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n+  protected void startContainerInternal(\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!isServiceStopped()) {\n         // Create the application\n         Application application \u003d new ApplicationImpl(dispatcher, user,\n             applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n           LOG.info(\"Creating a new application reference for app \"\n               + applicationID);\n           LogAggregationContext logAggregationContext \u003d\n               containerTokenIdentifier.getLogAggregationContext();\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n               buildAppProto(applicationID, user, credentials, appAcls,\n                 logAggregationContext));\n           dispatcher.getEventHandler().handle(\n             new ApplicationInitEvent(applicationID, appAcls,\n               logAggregationContext));\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void startContainerInternal(\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        // Create the application\n        Application application \u003d new ApplicationImpl(dispatcher, user,\n            applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \"\n              + applicationID);\n          LogAggregationContext logAggregationContext \u003d\n              containerTokenIdentifier.getLogAggregationContext();\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls,\n                logAggregationContext));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls,\n              logAggregationContext));\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {
        "oldValue": "[nmTokenIdentifier-NMTokenIdentifier, containerTokenIdentifier-ContainerTokenIdentifier, request-StartContainerRequest]",
        "newValue": "[containerTokenIdentifier-ContainerTokenIdentifier, request-StartContainerRequest]"
      }
    },
    "c8172f5f143d2fefafa5a412899ab7cd081b406d": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-2883. Queuing of container requests in the NM. (Konstantinos Karanasos and Arun Suresh via kasha)\n",
      "commitDate": "20/04/16 9:55 AM",
      "commitName": "c8172f5f143d2fefafa5a412899ab7cd081b406d",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-2883. Queuing of container requests in the NM. (Konstantinos Karanasos and Arun Suresh via kasha)\n",
          "commitDate": "20/04/16 9:55 AM",
          "commitName": "c8172f5f143d2fefafa5a412899ab7cd081b406d",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "14/04/16 12:17 PM",
          "commitNameOld": "3150ae8108a1fc40a67926be6254824c1e37cb38",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 5.9,
          "commitsBetweenForRepo": 24,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,72 @@\n-  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n+  protected void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n-    /*\n-     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n-     * here instead of RPC layer because at the time of opening/authenticating\n-     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n-     * Also new NMToken is issued only at startContainer (once it gets renewed).\n-     * \n-     * 2) It should validate containerToken. Need to check below things. a) It\n-     * is signed by correct master key (part of retrieve password). b) It\n-     * belongs to correct Node Manager (part of retrieve password). c) It has\n-     * correct RMIdentifier. d) It is not expired.\n-     */\n-    authorizeStartAndResourceIncreaseRequest(\n-        nmTokenIdentifier, containerTokenIdentifier, true);\n-    // update NMToken\n-    updateNMTokenIdentifier(nmTokenIdentifier);\n-\n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n-    Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n-    if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n-        !launchContext.getServiceData().isEmpty()) {\n-      for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n-          .entrySet()) {\n-        if (null \u003d\u003d serviceData.get(meta.getKey())) {\n-          throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n-              + \" does not exist\");\n-        }\n-      }\n-    }\n-\n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n-      if (!serviceStopped) {\n+      if (!isServiceStopped()) {\n         // Create the application\n-        Application application \u003d\n-            new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n+        Application application \u003d new ApplicationImpl(dispatcher, user,\n+            applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n-          LOG.info(\"Creating a new application reference for app \" + applicationID);\n+          LOG.info(\"Creating a new application reference for app \"\n+              + applicationID);\n           LogAggregationContext logAggregationContext \u003d\n               containerTokenIdentifier.getLogAggregationContext();\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n               buildAppProto(applicationID, user, credentials, appAcls,\n                 logAggregationContext));\n           dispatcher.getEventHandler().handle(\n             new ApplicationInitEvent(applicationID, appAcls,\n               logAggregationContext));\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        // Create the application\n        Application application \u003d new ApplicationImpl(dispatcher, user,\n            applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \"\n              + applicationID);\n          LogAggregationContext logAggregationContext \u003d\n              containerTokenIdentifier.getLogAggregationContext();\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls,\n                logAggregationContext));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls,\n              logAggregationContext));\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2883. Queuing of container requests in the NM. (Konstantinos Karanasos and Arun Suresh via kasha)\n",
          "commitDate": "20/04/16 9:55 AM",
          "commitName": "c8172f5f143d2fefafa5a412899ab7cd081b406d",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "14/04/16 12:17 PM",
          "commitNameOld": "3150ae8108a1fc40a67926be6254824c1e37cb38",
          "commitAuthorOld": "Jason Lowe",
          "daysBetweenCommits": 5.9,
          "commitsBetweenForRepo": 24,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,99 +1,72 @@\n-  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n+  protected void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n-    /*\n-     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n-     * here instead of RPC layer because at the time of opening/authenticating\n-     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n-     * Also new NMToken is issued only at startContainer (once it gets renewed).\n-     * \n-     * 2) It should validate containerToken. Need to check below things. a) It\n-     * is signed by correct master key (part of retrieve password). b) It\n-     * belongs to correct Node Manager (part of retrieve password). c) It has\n-     * correct RMIdentifier. d) It is not expired.\n-     */\n-    authorizeStartAndResourceIncreaseRequest(\n-        nmTokenIdentifier, containerTokenIdentifier, true);\n-    // update NMToken\n-    updateNMTokenIdentifier(nmTokenIdentifier);\n-\n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n-    Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n-    if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n-        !launchContext.getServiceData().isEmpty()) {\n-      for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n-          .entrySet()) {\n-        if (null \u003d\u003d serviceData.get(meta.getKey())) {\n-          throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n-              + \" does not exist\");\n-        }\n-      }\n-    }\n-\n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             launchContext, credentials, metrics, containerTokenIdentifier,\n             context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n-      if (!serviceStopped) {\n+      if (!isServiceStopped()) {\n         // Create the application\n-        Application application \u003d\n-            new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n+        Application application \u003d new ApplicationImpl(dispatcher, user,\n+            applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n-          LOG.info(\"Creating a new application reference for app \" + applicationID);\n+          LOG.info(\"Creating a new application reference for app \"\n+              + applicationID);\n           LogAggregationContext logAggregationContext \u003d\n               containerTokenIdentifier.getLogAggregationContext();\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n               buildAppProto(applicationID, user, credentials, appAcls,\n                 logAggregationContext));\n           dispatcher.getEventHandler().handle(\n             new ApplicationInitEvent(applicationID, appAcls,\n               logAggregationContext));\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!isServiceStopped()) {\n        // Create the application\n        Application application \u003d new ApplicationImpl(dispatcher, user,\n            applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \"\n              + applicationID);\n          LogAggregationContext logAggregationContext \u003d\n              containerTokenIdentifier.getLogAggregationContext();\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls,\n                logAggregationContext));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls,\n              logAggregationContext));\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "d284e187b8db43056236032ebc2114ee462c27f6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2046. Out of band heartbeats are sent only on container kill and possibly too early. Contributed by Ming Ma\n",
      "commitDate": "23/02/16 12:49 PM",
      "commitName": "d284e187b8db43056236032ebc2114ee462c27f6",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "01/02/16 7:55 PM",
      "commitNameOld": "1cd55e0c171f7c4dec6f843931285557d59cd5ea",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 21.7,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,99 @@\n   private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n     authorizeStartAndResourceIncreaseRequest(\n         nmTokenIdentifier, containerTokenIdentifier, true);\n     // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n     if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n         !launchContext.getServiceData().isEmpty()) {\n       for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n           .entrySet()) {\n         if (null \u003d\u003d serviceData.get(meta.getKey())) {\n           throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n               + \" does not exist\");\n         }\n       }\n     }\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n-            context.getNMStateStore(), launchContext,\n-          credentials, metrics, containerTokenIdentifier);\n+            launchContext, credentials, metrics, containerTokenIdentifier,\n+            context);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!serviceStopped) {\n         // Create the application\n         Application application \u003d\n             new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n           LOG.info(\"Creating a new application reference for app \" + applicationID);\n           LogAggregationContext logAggregationContext \u003d\n               containerTokenIdentifier.getLogAggregationContext();\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n               buildAppProto(applicationID, user, credentials, appAcls,\n                 logAggregationContext));\n           dispatcher.getEventHandler().handle(\n             new ApplicationInitEvent(applicationID, appAcls,\n               logAggregationContext));\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartAndResourceIncreaseRequest(\n        nmTokenIdentifier, containerTokenIdentifier, true);\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n    if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n        !launchContext.getServiceData().isEmpty()) {\n      for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n          .entrySet()) {\n        if (null \u003d\u003d serviceData.get(meta.getKey())) {\n          throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n              + \" does not exist\");\n        }\n      }\n    }\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            launchContext, credentials, metrics, containerTokenIdentifier,\n            context);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!serviceStopped) {\n        // Create the application\n        Application application \u003d\n            new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \" + applicationID);\n          LogAggregationContext logAggregationContext \u003d\n              containerTokenIdentifier.getLogAggregationContext();\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls,\n                logAggregationContext));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls,\n              logAggregationContext));\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "ffd820c27a4f8cf4676ad8758696ed89fde80218": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1645. ContainerManager implementation to support container resizing. Contributed by Meng Ding \u0026 Wangda Tan\n",
      "commitDate": "23/09/15 1:29 PM",
      "commitName": "ffd820c27a4f8cf4676ad8758696ed89fde80218",
      "commitAuthor": "Jian He",
      "commitDateOld": "23/09/15 1:29 PM",
      "commitNameOld": "83a18add10ee937a04e833a66e0a4642e776e510",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,107 +1,99 @@\n   private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n-    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n- \n-    if (containerTokenIdentifier.getRMIdentifier() !\u003d nodeStatusUpdater\n-        .getRMIdentifier()) {\n-        // Is the container coming from unknown RM\n-        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n-        sb.append(containerTokenIdentifier.getContainerID().toString())\n-          .append(\" rejected as it is allocated by a previous RM\");\n-        throw new InvalidContainerException(sb.toString());\n-    }\n+    authorizeStartAndResourceIncreaseRequest(\n+        nmTokenIdentifier, containerTokenIdentifier, true);\n     // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n     if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n         !launchContext.getServiceData().isEmpty()) {\n       for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n           .entrySet()) {\n         if (null \u003d\u003d serviceData.get(meta.getKey())) {\n           throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n               + \" does not exist\");\n         }\n       }\n     }\n \n     Credentials credentials \u003d\n         YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             context.getNMStateStore(), launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!serviceStopped) {\n         // Create the application\n         Application application \u003d\n             new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n           LOG.info(\"Creating a new application reference for app \" + applicationID);\n           LogAggregationContext logAggregationContext \u003d\n               containerTokenIdentifier.getLogAggregationContext();\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n               buildAppProto(applicationID, user, credentials, appAcls,\n                 logAggregationContext));\n           dispatcher.getEventHandler().handle(\n             new ApplicationInitEvent(applicationID, appAcls,\n               logAggregationContext));\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartAndResourceIncreaseRequest(\n        nmTokenIdentifier, containerTokenIdentifier, true);\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n    if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n        !launchContext.getServiceData().isEmpty()) {\n      for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n          .entrySet()) {\n        if (null \u003d\u003d serviceData.get(meta.getKey())) {\n          throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n              + \" does not exist\");\n        }\n      }\n    }\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            context.getNMStateStore(), launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!serviceStopped) {\n        // Create the application\n        Application application \u003d\n            new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \" + applicationID);\n          LogAggregationContext logAggregationContext \u003d\n              containerTokenIdentifier.getLogAggregationContext();\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls,\n                logAggregationContext));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls,\n              logAggregationContext));\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2884. Added a proxy service in NM to proxy the the communication between AM and RM. Contributed by Kishore Chaliparambil\n",
      "commitDate": "07/09/15 6:35 PM",
      "commitName": "6f72f1e6003ab11679bebeb96f27f1f62b3b3e02",
      "commitAuthor": "Jian He",
      "commitDateOld": "02/09/15 1:43 AM",
      "commitNameOld": "095ab9ab5fa5f415fba41fee81b6008cf0455af8",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 5.7,
      "commitsBetweenForRepo": 29,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,107 @@\n   private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n     authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n  \n     if (containerTokenIdentifier.getRMIdentifier() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n     // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n     if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n         !launchContext.getServiceData().isEmpty()) {\n       for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n           .entrySet()) {\n         if (null \u003d\u003d serviceData.get(meta.getKey())) {\n           throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n               + \" does not exist\");\n         }\n       }\n     }\n \n-    Credentials credentials \u003d parseCredentials(launchContext);\n+    Credentials credentials \u003d\n+        YarnServerSecurityUtils.parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             context.getNMStateStore(), launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!serviceStopped) {\n         // Create the application\n         Application application \u003d\n             new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n           LOG.info(\"Creating a new application reference for app \" + applicationID);\n           LogAggregationContext logAggregationContext \u003d\n               containerTokenIdentifier.getLogAggregationContext();\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n               buildAppProto(applicationID, user, credentials, appAcls,\n                 logAggregationContext));\n           dispatcher.getEventHandler().handle(\n             new ApplicationInitEvent(applicationID, appAcls,\n               logAggregationContext));\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifier() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n    if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n        !launchContext.getServiceData().isEmpty()) {\n      for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n          .entrySet()) {\n        if (null \u003d\u003d serviceData.get(meta.getKey())) {\n          throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n              + \" does not exist\");\n        }\n      }\n    }\n\n    Credentials credentials \u003d\n        YarnServerSecurityUtils.parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            context.getNMStateStore(), launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!serviceStopped) {\n        // Create the application\n        Application application \u003d\n            new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \" + applicationID);\n          LogAggregationContext logAggregationContext \u003d\n              containerTokenIdentifier.getLogAggregationContext();\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls,\n                logAggregationContext));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls,\n              logAggregationContext));\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "5391919b09ce9549d13c897aa89bb0a0536760fe": {
      "type": "Ybodychange",
      "commitMessage": "YARN-668. Changed NMTokenIdentifier/AMRMTokenIdentifier/ContainerTokenIdentifier to use protobuf object as the payload. Contributed by Junping Du.\n",
      "commitDate": "26/09/14 5:48 PM",
      "commitName": "5391919b09ce9549d13c897aa89bb0a0536760fe",
      "commitAuthor": "Jian He",
      "commitDateOld": "24/09/14 5:50 PM",
      "commitNameOld": "c86674a3a4d99aa56bb8ed3f6df51e3fef215eba",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 2.0,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,106 +1,106 @@\n   private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n     authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n  \n-    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n+    if (containerTokenIdentifier.getRMIdentifier() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n     // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n     if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n         !launchContext.getServiceData().isEmpty()) {\n       for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n           .entrySet()) {\n         if (null \u003d\u003d serviceData.get(meta.getKey())) {\n           throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n               + \" does not exist\");\n         }\n       }\n     }\n \n     Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             context.getNMStateStore(), launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!serviceStopped) {\n         // Create the application\n         Application application \u003d\n             new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n           LOG.info(\"Creating a new application reference for app \" + applicationID);\n           LogAggregationContext logAggregationContext \u003d\n               containerTokenIdentifier.getLogAggregationContext();\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n               buildAppProto(applicationID, user, credentials, appAcls,\n                 logAggregationContext));\n           dispatcher.getEventHandler().handle(\n             new ApplicationInitEvent(applicationID, appAcls,\n               logAggregationContext));\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifier() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n    if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n        !launchContext.getServiceData().isEmpty()) {\n      for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n          .entrySet()) {\n        if (null \u003d\u003d serviceData.get(meta.getKey())) {\n          throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n              + \" does not exist\");\n        }\n      }\n    }\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            context.getNMStateStore(), launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!serviceStopped) {\n        // Create the application\n        Application application \u003d\n            new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \" + applicationID);\n          LogAggregationContext logAggregationContext \u003d\n              containerTokenIdentifier.getLogAggregationContext();\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls,\n                logAggregationContext));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls,\n              logAggregationContext));\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "c86674a3a4d99aa56bb8ed3f6df51e3fef215eba": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2581. Passed LogAggregationContext to NM via ContainerTokenIdentifier. Contributed by Xuan Gong.\n",
      "commitDate": "24/09/14 5:50 PM",
      "commitName": "c86674a3a4d99aa56bb8ed3f6df51e3fef215eba",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "12/08/14 3:56 AM",
      "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 43.58,
      "commitsBetweenForRepo": 426,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,106 @@\n   private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n     authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n  \n     if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n     // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n     if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n         !launchContext.getServiceData().isEmpty()) {\n       for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n           .entrySet()) {\n         if (null \u003d\u003d serviceData.get(meta.getKey())) {\n           throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n               + \" does not exist\");\n         }\n       }\n     }\n \n     Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher,\n             context.getNMStateStore(), launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!serviceStopped) {\n         // Create the application\n         Application application \u003d\n             new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n           LOG.info(\"Creating a new application reference for app \" + applicationID);\n+          LogAggregationContext logAggregationContext \u003d\n+              containerTokenIdentifier.getLogAggregationContext();\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n-              buildAppProto(applicationID, user, credentials, appAcls));\n+              buildAppProto(applicationID, user, credentials, appAcls,\n+                logAggregationContext));\n           dispatcher.getEventHandler().handle(\n-            new ApplicationInitEvent(applicationID, appAcls));\n+            new ApplicationInitEvent(applicationID, appAcls,\n+              logAggregationContext));\n         }\n \n         this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n    if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n        !launchContext.getServiceData().isEmpty()) {\n      for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n          .entrySet()) {\n        if (null \u003d\u003d serviceData.get(meta.getKey())) {\n          throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n              + \" does not exist\");\n        }\n      }\n    }\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            context.getNMStateStore(), launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!serviceStopped) {\n        // Create the application\n        Application application \u003d\n            new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \" + applicationID);\n          LogAggregationContext logAggregationContext \u003d\n              containerTokenIdentifier.getLogAggregationContext();\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls,\n                logAggregationContext));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls,\n              logAggregationContext));\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1337. Recover containers upon nodemanager restart. (Contributed by Jason Lowe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617448 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 3:56 AM",
      "commitName": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthor": "Junping Du",
      "commitDateOld": "04/08/14 6:25 AM",
      "commitNameOld": "b8f151231ba37247b9daa23ecce1211fdca0e49f",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 7.9,
      "commitsBetweenForRepo": 64,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,102 @@\n   private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n     authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n  \n     if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n     // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n     if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n         !launchContext.getServiceData().isEmpty()) {\n       for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n           .entrySet()) {\n         if (null \u003d\u003d serviceData.get(meta.getKey())) {\n           throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n               + \" does not exist\");\n         }\n       }\n     }\n \n     Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n-        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n+        new ContainerImpl(getConfig(), this.dispatcher,\n+            context.getNMStateStore(), launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!serviceStopped) {\n         // Create the application\n         Application application \u003d\n             new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n           LOG.info(\"Creating a new application reference for app \" + applicationID);\n           Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n               container.getLaunchContext().getApplicationACLs();\n           context.getNMStateStore().storeApplication(applicationID,\n               buildAppProto(applicationID, user, credentials, appAcls));\n           dispatcher.getEventHandler().handle(\n             new ApplicationInitEvent(applicationID, appAcls));\n         }\n \n+        this.context.getNMStateStore().storeContainer(containerId, request);\n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n    if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n        !launchContext.getServiceData().isEmpty()) {\n      for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n          .entrySet()) {\n        if (null \u003d\u003d serviceData.get(meta.getKey())) {\n          throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n              + \" does not exist\");\n        }\n      }\n    }\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher,\n            context.getNMStateStore(), launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!serviceStopped) {\n        // Create the application\n        Application application \u003d\n            new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \" + applicationID);\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls));\n        }\n\n        this.context.getNMStateStore().storeContainer(containerId, request);\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "b8f151231ba37247b9daa23ecce1211fdca0e49f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1354. Recover applications upon nodemanager restart. (Contributed by Jason Lowe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1615550 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/08/14 6:25 AM",
      "commitName": "b8f151231ba37247b9daa23ecce1211fdca0e49f",
      "commitAuthor": "Junping Du",
      "commitDateOld": "01/08/14 4:44 PM",
      "commitNameOld": "a41c314373bf92669e35ddfcbec1114826c437e7",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 2.57,
      "commitsBetweenForRepo": 7,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,98 +1,100 @@\n   private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n     authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n  \n     if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n     // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n     if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n         !launchContext.getServiceData().isEmpty()) {\n       for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n           .entrySet()) {\n         if (null \u003d\u003d serviceData.get(meta.getKey())) {\n           throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n               + \" does not exist\");\n         }\n       }\n     }\n \n     Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     this.readLock.lock();\n     try {\n       if (!serviceStopped) {\n         // Create the application\n         Application application \u003d\n             new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n         if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n           application)) {\n           LOG.info(\"Creating a new application reference for app \" + applicationID);\n-\n+          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n+              container.getLaunchContext().getApplicationACLs();\n+          context.getNMStateStore().storeApplication(applicationID,\n+              buildAppProto(applicationID, user, credentials, appAcls));\n           dispatcher.getEventHandler().handle(\n-            new ApplicationInitEvent(applicationID, container.getLaunchContext()\n-              .getApplicationACLs()));\n+            new ApplicationInitEvent(applicationID, appAcls));\n         }\n \n         dispatcher.getEventHandler().handle(\n           new ApplicationContainerInitEvent(container));\n \n         this.context.getContainerTokenSecretManager().startContainerSuccessful(\n           containerTokenIdentifier);\n         NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n           \"ContainerManageImpl\", applicationID, containerId);\n         // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n         // launch. A finished Application will not launch containers.\n         metrics.launchedContainer();\n         metrics.allocateContainer(containerTokenIdentifier.getResource());\n       } else {\n         throw new YarnException(\n             \"Container start failed as the NodeManager is \" +\n             \"in the process of shutting down\");\n       }\n     } finally {\n       this.readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n    if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n        !launchContext.getServiceData().isEmpty()) {\n      for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n          .entrySet()) {\n        if (null \u003d\u003d serviceData.get(meta.getKey())) {\n          throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n              + \" does not exist\");\n        }\n      }\n    }\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!serviceStopped) {\n        // Create the application\n        Application application \u003d\n            new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \" + applicationID);\n          Map\u003cApplicationAccessType, String\u003e appAcls \u003d\n              container.getLaunchContext().getApplicationACLs();\n          context.getNMStateStore().storeApplication(applicationID,\n              buildAppProto(applicationID, user, credentials, appAcls));\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, appAcls));\n        }\n\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "d3841bd4997a77855ab2abd9cc294eae7d795a5b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1149. NM throws InvalidStateTransitonException: Invalid event: APPLICATION_LOG_HANDLING_FINISHED at RUNNING. Contributed by Xuan Gong.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529043 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/10/13 5:43 PM",
      "commitName": "d3841bd4997a77855ab2abd9cc294eae7d795a5b",
      "commitAuthor": "Hitesh Shah",
      "commitDateOld": "03/10/13 5:23 PM",
      "commitNameOld": "8ebf37f3691dee523f7d800bc82c7423c3e262e9",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,87 +1,98 @@\n   private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n     authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n  \n     if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n     // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n     if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n         !launchContext.getServiceData().isEmpty()) {\n       for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n           .entrySet()) {\n         if (null \u003d\u003d serviceData.get(meta.getKey())) {\n           throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n               + \" does not exist\");\n         }\n       }\n     }\n \n     Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n-    // Create the application\n-    Application application \u003d\n-        new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n-    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n-      application)) {\n-      LOG.info(\"Creating a new application reference for app \" + applicationID);\n+    this.readLock.lock();\n+    try {\n+      if (!serviceStopped) {\n+        // Create the application\n+        Application application \u003d\n+            new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n+        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n+          application)) {\n+          LOG.info(\"Creating a new application reference for app \" + applicationID);\n \n-      dispatcher.getEventHandler().handle(\n-        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n-          .getApplicationACLs()));\n+          dispatcher.getEventHandler().handle(\n+            new ApplicationInitEvent(applicationID, container.getLaunchContext()\n+              .getApplicationACLs()));\n+        }\n+\n+        dispatcher.getEventHandler().handle(\n+          new ApplicationContainerInitEvent(container));\n+\n+        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n+          containerTokenIdentifier);\n+        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n+          \"ContainerManageImpl\", applicationID, containerId);\n+        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n+        // launch. A finished Application will not launch containers.\n+        metrics.launchedContainer();\n+        metrics.allocateContainer(containerTokenIdentifier.getResource());\n+      } else {\n+        throw new YarnException(\n+            \"Container start failed as the NodeManager is \" +\n+            \"in the process of shutting down\");\n+      }\n+    } finally {\n+      this.readLock.unlock();\n     }\n-\n-    dispatcher.getEventHandler().handle(\n-      new ApplicationContainerInitEvent(container));\n-\n-    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n-      containerTokenIdentifier);\n-    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n-      \"ContainerManageImpl\", applicationID, containerId);\n-    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n-    // launch. A finished Application will not launch containers.\n-    metrics.launchedContainer();\n-    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n    if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n        !launchContext.getServiceData().isEmpty()) {\n      for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n          .entrySet()) {\n        if (null \u003d\u003d serviceData.get(meta.getKey())) {\n          throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n              + \" does not exist\");\n        }\n      }\n    }\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    this.readLock.lock();\n    try {\n      if (!serviceStopped) {\n        // Create the application\n        Application application \u003d\n            new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n        if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n          application)) {\n          LOG.info(\"Creating a new application reference for app \" + applicationID);\n\n          dispatcher.getEventHandler().handle(\n            new ApplicationInitEvent(applicationID, container.getLaunchContext()\n              .getApplicationACLs()));\n        }\n\n        dispatcher.getEventHandler().handle(\n          new ApplicationContainerInitEvent(container));\n\n        this.context.getContainerTokenSecretManager().startContainerSuccessful(\n          containerTokenIdentifier);\n        NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n          \"ContainerManageImpl\", applicationID, containerId);\n        // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n        // launch. A finished Application will not launch containers.\n        metrics.launchedContainer();\n        metrics.allocateContainer(containerTokenIdentifier.getResource());\n      } else {\n        throw new YarnException(\n            \"Container start failed as the NodeManager is \" +\n            \"in the process of shutting down\");\n      }\n    } finally {\n      this.readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "8ebf37f3691dee523f7d800bc82c7423c3e262e9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1256. NM silently ignores non-existent service in StartContainerRequest (Xuan Gong via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529039 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/10/13 5:23 PM",
      "commitName": "8ebf37f3691dee523f7d800bc82c7423c3e262e9",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "04/09/13 1:42 PM",
      "commitNameOld": "49afc64cd469bc3a775c18e0458661e39270b7a5",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 29.15,
      "commitsBetweenForRepo": 177,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,87 @@\n   private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n     authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n  \n     if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n     // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n+    Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n+    if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n+        !launchContext.getServiceData().isEmpty()) {\n+      for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n+          .entrySet()) {\n+        if (null \u003d\u003d serviceData.get(meta.getKey())) {\n+          throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n+              + \" does not exist\");\n+        }\n+      }\n+    }\n+\n     Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n     if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n       application)) {\n       LOG.info(\"Creating a new application reference for app \" + applicationID);\n \n       dispatcher.getEventHandler().handle(\n         new ApplicationInitEvent(applicationID, container.getLaunchContext()\n           .getApplicationACLs()));\n     }\n \n     dispatcher.getEventHandler().handle(\n       new ApplicationContainerInitEvent(container));\n \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       containerTokenIdentifier);\n     NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n       \"ContainerManageImpl\", applicationID, containerId);\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(containerTokenIdentifier.getResource()); \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Map\u003cString, ByteBuffer\u003e serviceData \u003d getAuxServiceMetaData();\n    if (launchContext.getServiceData()!\u003dnull \u0026\u0026 \n        !launchContext.getServiceData().isEmpty()) {\n      for (Map.Entry\u003cString, ByteBuffer\u003e meta : launchContext.getServiceData()\n          .entrySet()) {\n        if (null \u003d\u003d serviceData.get(meta.getKey())) {\n          throw new InvalidAuxServiceException(\"The auxService:\" + meta.getKey()\n              + \" does not exist\");\n        }\n      }\n    }\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n      application)) {\n      LOG.info(\"Creating a new application reference for app \" + applicationID);\n\n      dispatcher.getEventHandler().handle(\n        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n          .getApplicationACLs()));\n    }\n\n    dispatcher.getEventHandler().handle(\n      new ApplicationContainerInitEvent(container));\n\n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      containerTokenIdentifier);\n    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n      \"ContainerManageImpl\", applicationID, containerId);\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "a759abcd898224c3481c55aa7e424bc286f60b15": {
      "type": "Ybodychange",
      "commitMessage": "YARN-649. Added a new NM web-service to serve container logs in plain text over HTTP. Contributed by Sandy Ryza.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1519326 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/09/13 5:09 PM",
      "commitName": "a759abcd898224c3481c55aa7e424bc286f60b15",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "30/08/13 7:09 PM",
      "commitNameOld": "236b8530bd05015d3b8a8131b111454c54c9e55d",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 1.92,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,76 +1,75 @@\n   private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n       ContainerTokenIdentifier containerTokenIdentifier,\n       StartContainerRequest request) throws YarnException, IOException {\n \n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n     authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n  \n     if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n     // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n \n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n-        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n-          credentials, context);\n+        new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n     if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n       application)) {\n       LOG.info(\"Creating a new application reference for app \" + applicationID);\n \n       dispatcher.getEventHandler().handle(\n         new ApplicationInitEvent(applicationID, container.getLaunchContext()\n           .getApplicationACLs()));\n     }\n \n     dispatcher.getEventHandler().handle(\n       new ApplicationContainerInitEvent(container));\n \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       containerTokenIdentifier);\n     NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n       \"ContainerManageImpl\", applicationID, containerId);\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(containerTokenIdentifier.getResource()); \n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, user, applicationID, credentials, context);\n    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n      application)) {\n      LOG.info(\"Creating a new application reference for app \" + applicationID);\n\n      dispatcher.getEventHandler().handle(\n        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n          .getApplicationACLs()));\n    }\n\n    dispatcher.getEventHandler().handle(\n      new ApplicationContainerInitEvent(container));\n\n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      containerTokenIdentifier);\n    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n      \"ContainerManageImpl\", applicationID, containerId);\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "3ca3137179ef093e42cde06587c9ea785b10f32c": {
      "type": "Ymultichange(Yrename,Yparameterchange,Yreturntypechange,Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-926. Modified ContainerManagerProtcol APIs to take in requests for multiple containers. Contributed by Jian He.\nMAPREDUCE-5412. Update MR app to use multiple containers API of ContainerManager after YARN-926. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506391 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/07/13 8:41 PM",
      "commitName": "3ca3137179ef093e42cde06587c9ea785b10f32c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "YARN-926. Modified ContainerManagerProtcol APIs to take in requests for multiple containers. Contributed by Jian He.\nMAPREDUCE-5412. Update MR app to use multiple containers API of ContainerManager after YARN-926. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/07/13 8:41 PM",
          "commitName": "3ca3137179ef093e42cde06587c9ea785b10f32c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/07/13 12:31 AM",
          "commitNameOld": "c6facfb10db3f7791e35dd02d11990924a89711f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 6.84,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,76 @@\n-  public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnException, IOException {\n+  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n+      ContainerTokenIdentifier containerTokenIdentifier,\n+      StartContainerRequest request) throws YarnException, IOException {\n \n-    if (blockNewContainerRequests.get()) {\n-      throw new NMNotYetReadyException(\n-        \"Rejecting new containers as NodeManager has not\"\n-            + \" yet connected with ResourceManager\");\n-    }\n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n-    // update NMToken\n-\n-    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n-    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n-    \n-    // Validate containerToken\n-    ContainerTokenIdentifier containerTokenIdentifier \u003d\n-        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n-\n-    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n-      remoteUgi);\n-\n+    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n+ \n     if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n-    \n+    // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n-    \n+\n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n           credentials, context);\n     if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n       application)) {\n       LOG.info(\"Creating a new application reference for app \" + applicationID);\n \n       dispatcher.getEventHandler().handle(\n         new ApplicationInitEvent(applicationID, container.getLaunchContext()\n           .getApplicationACLs()));\n     }\n \n     dispatcher.getEventHandler().handle(\n       new ApplicationContainerInitEvent(container));\n \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       containerTokenIdentifier);\n     NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n       \"ContainerManageImpl\", applicationID, containerId);\n-    StartContainerResponse response \u003d\n-        recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n-    metrics.allocateContainer(containerTokenIdentifier.getResource());\n-    return response;\n+    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n          credentials, context);\n    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n      application)) {\n      LOG.info(\"Creating a new application reference for app \" + applicationID);\n\n      dispatcher.getEventHandler().handle(\n        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n          .getApplicationACLs()));\n    }\n\n    dispatcher.getEventHandler().handle(\n      new ApplicationContainerInitEvent(container));\n\n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      containerTokenIdentifier);\n    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n      \"ContainerManageImpl\", applicationID, containerId);\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {
            "oldValue": "startContainer",
            "newValue": "startContainerInternal"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-926. Modified ContainerManagerProtcol APIs to take in requests for multiple containers. Contributed by Jian He.\nMAPREDUCE-5412. Update MR app to use multiple containers API of ContainerManager after YARN-926. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/07/13 8:41 PM",
          "commitName": "3ca3137179ef093e42cde06587c9ea785b10f32c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/07/13 12:31 AM",
          "commitNameOld": "c6facfb10db3f7791e35dd02d11990924a89711f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 6.84,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,76 @@\n-  public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnException, IOException {\n+  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n+      ContainerTokenIdentifier containerTokenIdentifier,\n+      StartContainerRequest request) throws YarnException, IOException {\n \n-    if (blockNewContainerRequests.get()) {\n-      throw new NMNotYetReadyException(\n-        \"Rejecting new containers as NodeManager has not\"\n-            + \" yet connected with ResourceManager\");\n-    }\n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n-    // update NMToken\n-\n-    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n-    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n-    \n-    // Validate containerToken\n-    ContainerTokenIdentifier containerTokenIdentifier \u003d\n-        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n-\n-    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n-      remoteUgi);\n-\n+    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n+ \n     if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n-    \n+    // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n-    \n+\n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n           credentials, context);\n     if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n       application)) {\n       LOG.info(\"Creating a new application reference for app \" + applicationID);\n \n       dispatcher.getEventHandler().handle(\n         new ApplicationInitEvent(applicationID, container.getLaunchContext()\n           .getApplicationACLs()));\n     }\n \n     dispatcher.getEventHandler().handle(\n       new ApplicationContainerInitEvent(container));\n \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       containerTokenIdentifier);\n     NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n       \"ContainerManageImpl\", applicationID, containerId);\n-    StartContainerResponse response \u003d\n-        recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n-    metrics.allocateContainer(containerTokenIdentifier.getResource());\n-    return response;\n+    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n          credentials, context);\n    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n      application)) {\n      LOG.info(\"Creating a new application reference for app \" + applicationID);\n\n      dispatcher.getEventHandler().handle(\n        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n          .getApplicationACLs()));\n    }\n\n    dispatcher.getEventHandler().handle(\n      new ApplicationContainerInitEvent(container));\n\n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      containerTokenIdentifier);\n    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n      \"ContainerManageImpl\", applicationID, containerId);\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {
            "oldValue": "[request-StartContainerRequest]",
            "newValue": "[nmTokenIdentifier-NMTokenIdentifier, containerTokenIdentifier-ContainerTokenIdentifier, request-StartContainerRequest]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-926. Modified ContainerManagerProtcol APIs to take in requests for multiple containers. Contributed by Jian He.\nMAPREDUCE-5412. Update MR app to use multiple containers API of ContainerManager after YARN-926. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/07/13 8:41 PM",
          "commitName": "3ca3137179ef093e42cde06587c9ea785b10f32c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/07/13 12:31 AM",
          "commitNameOld": "c6facfb10db3f7791e35dd02d11990924a89711f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 6.84,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,76 @@\n-  public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnException, IOException {\n+  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n+      ContainerTokenIdentifier containerTokenIdentifier,\n+      StartContainerRequest request) throws YarnException, IOException {\n \n-    if (blockNewContainerRequests.get()) {\n-      throw new NMNotYetReadyException(\n-        \"Rejecting new containers as NodeManager has not\"\n-            + \" yet connected with ResourceManager\");\n-    }\n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n-    // update NMToken\n-\n-    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n-    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n-    \n-    // Validate containerToken\n-    ContainerTokenIdentifier containerTokenIdentifier \u003d\n-        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n-\n-    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n-      remoteUgi);\n-\n+    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n+ \n     if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n-    \n+    // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n-    \n+\n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n           credentials, context);\n     if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n       application)) {\n       LOG.info(\"Creating a new application reference for app \" + applicationID);\n \n       dispatcher.getEventHandler().handle(\n         new ApplicationInitEvent(applicationID, container.getLaunchContext()\n           .getApplicationACLs()));\n     }\n \n     dispatcher.getEventHandler().handle(\n       new ApplicationContainerInitEvent(container));\n \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       containerTokenIdentifier);\n     NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n       \"ContainerManageImpl\", applicationID, containerId);\n-    StartContainerResponse response \u003d\n-        recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n-    metrics.allocateContainer(containerTokenIdentifier.getResource());\n-    return response;\n+    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n          credentials, context);\n    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n      application)) {\n      LOG.info(\"Creating a new application reference for app \" + applicationID);\n\n      dispatcher.getEventHandler().handle(\n        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n          .getApplicationACLs()));\n    }\n\n    dispatcher.getEventHandler().handle(\n      new ApplicationContainerInitEvent(container));\n\n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      containerTokenIdentifier);\n    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n      \"ContainerManageImpl\", applicationID, containerId);\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {
            "oldValue": "StartContainerResponse",
            "newValue": "void"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-926. Modified ContainerManagerProtcol APIs to take in requests for multiple containers. Contributed by Jian He.\nMAPREDUCE-5412. Update MR app to use multiple containers API of ContainerManager after YARN-926. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/07/13 8:41 PM",
          "commitName": "3ca3137179ef093e42cde06587c9ea785b10f32c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/07/13 12:31 AM",
          "commitNameOld": "c6facfb10db3f7791e35dd02d11990924a89711f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 6.84,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,76 @@\n-  public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnException, IOException {\n+  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n+      ContainerTokenIdentifier containerTokenIdentifier,\n+      StartContainerRequest request) throws YarnException, IOException {\n \n-    if (blockNewContainerRequests.get()) {\n-      throw new NMNotYetReadyException(\n-        \"Rejecting new containers as NodeManager has not\"\n-            + \" yet connected with ResourceManager\");\n-    }\n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n-    // update NMToken\n-\n-    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n-    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n-    \n-    // Validate containerToken\n-    ContainerTokenIdentifier containerTokenIdentifier \u003d\n-        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n-\n-    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n-      remoteUgi);\n-\n+    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n+ \n     if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n-    \n+    // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n-    \n+\n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n           credentials, context);\n     if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n       application)) {\n       LOG.info(\"Creating a new application reference for app \" + applicationID);\n \n       dispatcher.getEventHandler().handle(\n         new ApplicationInitEvent(applicationID, container.getLaunchContext()\n           .getApplicationACLs()));\n     }\n \n     dispatcher.getEventHandler().handle(\n       new ApplicationContainerInitEvent(container));\n \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       containerTokenIdentifier);\n     NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n       \"ContainerManageImpl\", applicationID, containerId);\n-    StartContainerResponse response \u003d\n-        recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n-    metrics.allocateContainer(containerTokenIdentifier.getResource());\n-    return response;\n+    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n          credentials, context);\n    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n      application)) {\n      LOG.info(\"Creating a new application reference for app \" + applicationID);\n\n      dispatcher.getEventHandler().handle(\n        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n          .getApplicationACLs()));\n    }\n\n    dispatcher.getEventHandler().handle(\n      new ApplicationContainerInitEvent(container));\n\n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      containerTokenIdentifier);\n    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n      \"ContainerManageImpl\", applicationID, containerId);\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[private]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-926. Modified ContainerManagerProtcol APIs to take in requests for multiple containers. Contributed by Jian He.\nMAPREDUCE-5412. Update MR app to use multiple containers API of ContainerManager after YARN-926. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1506391 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/07/13 8:41 PM",
          "commitName": "3ca3137179ef093e42cde06587c9ea785b10f32c",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "17/07/13 12:31 AM",
          "commitNameOld": "c6facfb10db3f7791e35dd02d11990924a89711f",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 6.84,
          "commitsBetweenForRepo": 39,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,94 +1,76 @@\n-  public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnException, IOException {\n+  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n+      ContainerTokenIdentifier containerTokenIdentifier,\n+      StartContainerRequest request) throws YarnException, IOException {\n \n-    if (blockNewContainerRequests.get()) {\n-      throw new NMNotYetReadyException(\n-        \"Rejecting new containers as NodeManager has not\"\n-            + \" yet connected with ResourceManager\");\n-    }\n     /*\n      * 1) It should save the NMToken into NMTokenSecretManager. This is done\n      * here instead of RPC layer because at the time of opening/authenticating\n      * the connection it doesn\u0027t know what all RPC calls user will make on it.\n      * Also new NMToken is issued only at startContainer (once it gets renewed).\n      * \n      * 2) It should validate containerToken. Need to check below things. a) It\n      * is signed by correct master key (part of retrieve password). b) It\n      * belongs to correct Node Manager (part of retrieve password). c) It has\n      * correct RMIdentifier. d) It is not expired.\n      */\n-    // update NMToken\n-\n-    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n-    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n-    \n-    // Validate containerToken\n-    ContainerTokenIdentifier containerTokenIdentifier \u003d\n-        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n-\n-    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n-      remoteUgi);\n-\n+    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n+ \n     if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n         .getRMIdentifier()) {\n         // Is the container coming from unknown RM\n         StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n         sb.append(containerTokenIdentifier.getContainerID().toString())\n           .append(\" rejected as it is allocated by a previous RM\");\n         throw new InvalidContainerException(sb.toString());\n     }\n-    \n+    // update NMToken\n     updateNMTokenIdentifier(nmTokenIdentifier);\n-    \n+\n     ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n     String containerIdStr \u003d containerId.toString();\n     String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n     LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, containerTokenIdentifier);\n     ApplicationId applicationID \u003d\n         containerId.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n         \"ContainerManagerImpl\", \"Container already running on this node!\",\n         applicationID, containerId);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n           credentials, context);\n     if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n       application)) {\n       LOG.info(\"Creating a new application reference for app \" + applicationID);\n \n       dispatcher.getEventHandler().handle(\n         new ApplicationInitEvent(applicationID, container.getLaunchContext()\n           .getApplicationACLs()));\n     }\n \n     dispatcher.getEventHandler().handle(\n       new ApplicationContainerInitEvent(container));\n \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       containerTokenIdentifier);\n     NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n       \"ContainerManageImpl\", applicationID, containerId);\n-    StartContainerResponse response \u003d\n-        recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n-    metrics.allocateContainer(containerTokenIdentifier.getResource());\n-    return response;\n+    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void startContainerInternal(NMTokenIdentifier nmTokenIdentifier,\n      ContainerTokenIdentifier containerTokenIdentifier,\n      StartContainerRequest request) throws YarnException, IOException {\n\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier);\n \n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    // update NMToken\n    updateNMTokenIdentifier(nmTokenIdentifier);\n\n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n          credentials, context);\n    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n      application)) {\n      LOG.info(\"Creating a new application reference for app \" + applicationID);\n\n      dispatcher.getEventHandler().handle(\n        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n          .getApplicationACLs()));\n    }\n\n    dispatcher.getEventHandler().handle(\n      new ApplicationContainerInitEvent(container));\n\n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      containerTokenIdentifier);\n    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n      \"ContainerManageImpl\", applicationID, containerId);\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(containerTokenIdentifier.getResource()); \n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "243bcd367ff3130d74676280233041f88aca62a5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-694. Starting to use NMTokens to authenticate all communication with NodeManagers. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494369 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/06/13 4:19 PM",
      "commitName": "243bcd367ff3130d74676280233041f88aca62a5",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "17/06/13 11:20 PM",
      "commitNameOld": "f4d80e91ae314d316100baa7770b9d73ea853d9c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.71,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,108 +1,94 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n-          \"Rejecting new containers as NodeManager has not\" +\n-          \" yet connected with ResourceManager\");\n+        \"Rejecting new containers as NodeManager has not\"\n+            + \" yet connected with ResourceManager\");\n     }\n-\n-    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n-    org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n-\n-    ContainerTokenIdentifier tokenIdentifier \u003d null;\n-    try {\n-      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n-    } catch (IOException e) {\n-      throw RPCUtil.getRemoteException(e);\n-    }\n+    /*\n+     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n+     * here instead of RPC layer because at the time of opening/authenticating\n+     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n+     * Also new NMToken is issued only at startContainer (once it gets renewed).\n+     * \n+     * 2) It should validate containerToken. Need to check below things. a) It\n+     * is signed by correct master key (part of retrieve password). b) It\n+     * belongs to correct Node Manager (part of retrieve password). c) It has\n+     * correct RMIdentifier. d) It is not expired.\n+     */\n+    // update NMToken\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n-    ContainerTokenIdentifier tokenId \u003d \n-        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n+    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n+    \n+    // Validate containerToken\n+    ContainerTokenIdentifier containerTokenIdentifier \u003d\n+        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n \n-    ContainerId containerID \u003d tokenId.getContainerID();\n-    String containerIDStr \u003d containerID.toString();\n+    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n+      remoteUgi);\n \n-    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n-\n-    // Is the container coming from unknown RM\n-    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n-      .getRMIdentifier()) {\n-      String msg \u003d \"\\nContainer \"+ containerIDStr\n-          + \" rejected as it is allocated by a previous RM\";\n-      LOG.error(msg);\n-      throw new InvalidContainerException(msg);\n+    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n+        .getRMIdentifier()) {\n+        // Is the container coming from unknown RM\n+        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n+        sb.append(containerTokenIdentifier.getContainerID().toString())\n+          .append(\" rejected as it is allocated by a previous RM\");\n+        throw new InvalidContainerException(sb.toString());\n     }\n+    \n+    updateNMTokenIdentifier(nmTokenIdentifier);\n+    \n+    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n+    String containerIdStr \u003d containerId.toString();\n+    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n \n-    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n-        + tokenId.getApplicationSubmitter());\n+    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n \n-    // //////////// Parse credentials\n-    ByteBuffer tokens \u003d launchContext.getTokens();\n-    Credentials credentials \u003d new Credentials();\n-    if (tokens !\u003d null) {\n-      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n-      tokens.rewind();\n-      buf.reset(tokens);\n-      try {\n-        credentials.readTokenStorageStream(buf);\n-        if (LOG.isDebugEnabled()) {\n-          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n-              .getAllTokens()) {\n-            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n-          }\n-        }\n-      } catch (IOException e) {\n-        throw RPCUtil.getRemoteException(e);\n-      }\n-    }\n-    // //////////// End of parsing credentials\n-    String user \u003d tokenId.getApplicationSubmitter();\n+    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n+\n+    Credentials credentials \u003d parseCredentials(launchContext);\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n-          credentials, metrics, tokenId);\n-    ApplicationId applicationID \u003d \n-        containerID.getApplicationAttemptId().getApplicationId();\n-    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n-      NMAuditLogger.logFailure(user, \n-          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n-          \"Container already running on this node!\",\n-          applicationID, containerID);\n-      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n+          credentials, metrics, containerTokenIdentifier);\n+    ApplicationId applicationID \u003d\n+        containerId.getApplicationAttemptId().getApplicationId();\n+    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n+      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n+        \"ContainerManagerImpl\", \"Container already running on this node!\",\n+        applicationID, containerId);\n+      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n-        new ApplicationImpl(dispatcher, this.aclsManager,\n-          user, applicationID, credentials,\n-          context);\n-    if (null \u003d\u003d\n-        context.getApplications().putIfAbsent(applicationID, application)) {\n-      LOG.info(\"Creating a new application reference for app \"\n-          + applicationID);\n+        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n+          credentials, context);\n+    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n+      application)) {\n+      LOG.info(\"Creating a new application reference for app \" + applicationID);\n+\n       dispatcher.getEventHandler().handle(\n-          new ApplicationInitEvent(applicationID, container\n-              .getLaunchContext().getApplicationACLs()));\n+        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n+          .getApplicationACLs()));\n     }\n \n-    // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n-        new ApplicationContainerInitEvent(container));\n-    \n-    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n-      tokenId);\n-    NMAuditLogger.logSuccess(user, \n-        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n-        applicationID, containerID);\n+      new ApplicationContainerInitEvent(container));\n \n+    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n+      containerTokenIdentifier);\n+    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n+      \"ContainerManageImpl\", applicationID, containerId);\n     StartContainerResponse response \u003d\n-        StartContainerResponse.newInstance(auxiliaryServices.getMetaData());\n+        recordFactory.newRecordInstance(StartContainerResponse.class);\n+    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n-    metrics.allocateContainer(tokenId.getResource());\n+    metrics.allocateContainer(containerTokenIdentifier.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n        \"Rejecting new containers as NodeManager has not\"\n            + \" yet connected with ResourceManager\");\n    }\n    /*\n     * 1) It should save the NMToken into NMTokenSecretManager. This is done\n     * here instead of RPC layer because at the time of opening/authenticating\n     * the connection it doesn\u0027t know what all RPC calls user will make on it.\n     * Also new NMToken is issued only at startContainer (once it gets renewed).\n     * \n     * 2) It should validate containerToken. Need to check below things. a) It\n     * is signed by correct master key (part of retrieve password). b) It\n     * belongs to correct Node Manager (part of retrieve password). c) It has\n     * correct RMIdentifier. d) It is not expired.\n     */\n    // update NMToken\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    NMTokenIdentifier nmTokenIdentifier \u003d selectNMTokenIdentifier(remoteUgi);\n    \n    // Validate containerToken\n    ContainerTokenIdentifier containerTokenIdentifier \u003d\n        verifyAndGetContainerTokenIdentifier(request.getContainerToken());\n\n    authorizeStartRequest(nmTokenIdentifier, containerTokenIdentifier,\n      remoteUgi);\n\n    if (containerTokenIdentifier.getRMIdentifer() !\u003d nodeStatusUpdater\n        .getRMIdentifier()) {\n        // Is the container coming from unknown RM\n        StringBuilder sb \u003d new StringBuilder(\"\\nContainer \");\n        sb.append(containerTokenIdentifier.getContainerID().toString())\n          .append(\" rejected as it is allocated by a previous RM\");\n        throw new InvalidContainerException(sb.toString());\n    }\n    \n    updateNMTokenIdentifier(nmTokenIdentifier);\n    \n    ContainerId containerId \u003d containerTokenIdentifier.getContainerID();\n    String containerIdStr \u003d containerId.toString();\n    String user \u003d containerTokenIdentifier.getApplicationSubmitter();\n\n    LOG.info(\"Start request for \" + containerIdStr + \" by user \" + user);\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    Credentials credentials \u003d parseCredentials(launchContext);\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, containerTokenIdentifier);\n    ApplicationId applicationID \u003d\n        containerId.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerId, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, AuditConstants.START_CONTAINER,\n        \"ContainerManagerImpl\", \"Container already running on this node!\",\n        applicationID, containerId);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIdStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager, user, applicationID,\n          credentials, context);\n    if (null \u003d\u003d context.getApplications().putIfAbsent(applicationID,\n      application)) {\n      LOG.info(\"Creating a new application reference for app \" + applicationID);\n\n      dispatcher.getEventHandler().handle(\n        new ApplicationInitEvent(applicationID, container.getLaunchContext()\n          .getApplicationACLs()));\n    }\n\n    dispatcher.getEventHandler().handle(\n      new ApplicationContainerInitEvent(container));\n\n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      containerTokenIdentifier);\n    NMAuditLogger.logSuccess(user, AuditConstants.START_CONTAINER,\n      \"ContainerManageImpl\", applicationID, containerId);\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServicesMetaData(auxiliaryServices.getMetaData());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(containerTokenIdentifier.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "f4d80e91ae314d316100baa7770b9d73ea853d9c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-841. Move Auxiliary service to yarn-api, annotate and document it. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494031 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 11:20 PM",
      "commitName": "f4d80e91ae314d316100baa7770b9d73ea853d9c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/06/13 11:39 PM",
      "commitNameOld": "b9efe6bd4a1277b4067ecde715a7713a85968886",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.99,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,108 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\");\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n \n     ContainerTokenIdentifier tokenIdentifier \u003d null;\n     try {\n       tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n     } catch (IOException e) {\n       throw RPCUtil.getRemoteException(e);\n     }\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     ContainerTokenIdentifier tokenId \u003d \n         getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n \n     ContainerId containerID \u003d tokenId.getContainerID();\n     String containerIDStr \u003d containerID.toString();\n \n     authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n \n     // Is the container coming from unknown RM\n     if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw new InvalidContainerException(msg);\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n     String user \u003d tokenId.getApplicationSubmitter();\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           user, applicationID, credentials,\n           context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n     NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n-        recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.setAllServiceResponse(auxiliaryServices.getMeta());\n+        StartContainerResponse.newInstance(auxiliaryServices.getMetaData());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(tokenId.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\");\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n\n    ContainerTokenIdentifier tokenIdentifier \u003d null;\n    try {\n      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n    } catch (IOException e) {\n      throw RPCUtil.getRemoteException(e);\n    }\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n\n    ContainerId containerID \u003d tokenId.getContainerID();\n    String containerIDStr \u003d containerID.toString();\n\n    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n\n    // Is the container coming from unknown RM\n    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw new InvalidContainerException(msg);\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        StartContainerResponse.newInstance(auxiliaryServices.getMetaData());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(tokenId.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "c6c41abf683be17c3917a7f94953b55347aaa69f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-737. Throw some specific exceptions directly instead of wrapping them in YarnException. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1491896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/13 11:47 AM",
      "commitName": "c6c41abf683be17c3917a7f94953b55347aaa69f",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "03/06/13 9:05 PM",
      "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.61,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,109 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n-      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n+      throw new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n-          \" yet connected with ResourceManager\"));\n+          \" yet connected with ResourceManager\");\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n \n     ContainerTokenIdentifier tokenIdentifier \u003d null;\n     try {\n       tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n     } catch (IOException e) {\n       throw RPCUtil.getRemoteException(e);\n     }\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     ContainerTokenIdentifier tokenId \u003d \n         getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n \n     ContainerId containerID \u003d tokenId.getContainerID();\n     String containerIDStr \u003d containerID.toString();\n \n     authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n \n     // Is the container coming from unknown RM\n     if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n-      throw RPCUtil\n-        .getRemoteException(new InvalidContainerException(msg));\n+      throw new InvalidContainerException(msg);\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n     String user \u003d tokenId.getApplicationSubmitter();\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           user, applicationID, credentials,\n           context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n     NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(tokenId.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\");\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n\n    ContainerTokenIdentifier tokenIdentifier \u003d null;\n    try {\n      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n    } catch (IOException e) {\n      throw RPCUtil.getRemoteException(e);\n    }\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n\n    ContainerId containerID \u003d tokenId.getContainerID();\n    String containerIDStr \u003d containerID.toString();\n\n    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n\n    // Is the container coming from unknown RM\n    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw new InvalidContainerException(msg);\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(tokenId.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/06/13 5:34 PM",
      "commitNameOld": "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnRemoteException, IOException {\n+      throws YarnException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n \n     ContainerTokenIdentifier tokenIdentifier \u003d null;\n     try {\n       tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n     } catch (IOException e) {\n       throw RPCUtil.getRemoteException(e);\n     }\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     ContainerTokenIdentifier tokenId \u003d \n         getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n \n     ContainerId containerID \u003d tokenId.getContainerID();\n     String containerIDStr \u003d containerID.toString();\n \n     authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n \n     // Is the container coming from unknown RM\n     if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n     String user \u003d tokenId.getApplicationSubmitter();\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           user, applicationID, credentials,\n           context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n     NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(tokenId.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n\n    ContainerTokenIdentifier tokenIdentifier \u003d null;\n    try {\n      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n    } catch (IOException e) {\n      throw RPCUtil.getRemoteException(e);\n    }\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n\n    ContainerId containerID \u003d tokenId.getContainerID();\n    String containerIDStr \u003d containerID.toString();\n\n    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n\n    // Is the container coming from unknown RM\n    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(tokenId.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException, IOException]",
        "newValue": "[YarnException, IOException]"
      }
    },
    "a2c42330047bf955a6a585dcddf798920d4c8640": {
      "type": "Ybodychange",
      "commitMessage": "YARN-717. Put object creation factories for Token in the class itself and remove useless derivations for specific tokens. Contributed by Jian He.\nMAPREDUCE-5289. Updated MR App to use Token directly after YARN-717. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488616 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "01/06/13 2:43 PM",
      "commitName": "a2c42330047bf955a6a585dcddf798920d4c8640",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "31/05/13 5:14 PM",
      "commitNameOld": "39f019f41392d9e46ea1dc86ddd5563aabbeda1e",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 0.89,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,110 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n-    ContainerToken token \u003d request.getContainerToken();\n+    org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n \n     ContainerTokenIdentifier tokenIdentifier \u003d null;\n     try {\n       tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n     } catch (IOException e) {\n       throw RPCUtil.getRemoteException(e);\n     }\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi();\n     ContainerTokenIdentifier tokenId \u003d \n         getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n \n     ContainerId containerID \u003d tokenId.getContainerID();\n     String containerIDStr \u003d containerID.toString();\n \n     authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n \n     // Is the container coming from unknown RM\n     if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n     String user \u003d tokenId.getApplicationSubmitter();\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n           credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           user, applicationID, credentials,\n           context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n     NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(tokenId.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Token token \u003d request.getContainerToken();\n\n    ContainerTokenIdentifier tokenIdentifier \u003d null;\n    try {\n      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n    } catch (IOException e) {\n      throw RPCUtil.getRemoteException(e);\n    }\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n\n    ContainerId containerID \u003d tokenId.getContainerID();\n    String containerIDStr \u003d containerID.toString();\n\n    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n\n    // Is the container coming from unknown RM\n    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(tokenId.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "2692675fc3b5046d2ec88542c30203c87e135b70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-684. ContainerManager.startContainer should use ContainerTokenIdentifier instead of the entire Container. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488085 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/05/13 9:13 PM",
      "commitName": "2692675fc3b5046d2ec88542c30203c87e135b70",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "29/05/13 9:59 PM",
      "commitNameOld": "b16c5638b5190c56f9d854d873589cb5c11c8b32",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 0.97,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,110 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n-    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n-        request.getContainer();\n-    ContainerId containerID \u003d lauchContainer.getId();\n+    ContainerToken token \u003d request.getContainerToken();\n+\n+    ContainerTokenIdentifier tokenIdentifier \u003d null;\n+    try {\n+      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n+    } catch (IOException e) {\n+      throw RPCUtil.getRemoteException(e);\n+    }\n+\n+    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n+    ContainerTokenIdentifier tokenId \u003d \n+        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n+\n+    ContainerId containerID \u003d tokenId.getContainerID();\n     String containerIDStr \u003d containerID.toString();\n \n-    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n-    ContainerTokenIdentifier tokenId \u003d \n-        getContainerTokenIdentifier(remoteUgi, lauchContainer);\n-    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n-      tokenId);\n+    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n \n     // Is the container coming from unknown RM\n     if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n     String user \u003d tokenId.getApplicationSubmitter();\n \n-    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n-        launchContext, lauchContainer, credentials, metrics, tokenId);\n+    Container container \u003d\n+        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n+          credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           user, applicationID, credentials,\n           context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n     NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n-    metrics.allocateContainer(lauchContainer.getResource());\n+    metrics.allocateContainer(tokenId.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    ContainerToken token \u003d request.getContainerToken();\n\n    ContainerTokenIdentifier tokenIdentifier \u003d null;\n    try {\n      tokenIdentifier \u003d BuilderUtils.newContainerTokenIdentifier(token);\n    } catch (IOException e) {\n      throw RPCUtil.getRemoteException(e);\n    }\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi();\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, tokenIdentifier);\n\n    ContainerId containerID \u003d tokenId.getContainerID();\n    String containerIDStr \u003d containerID.toString();\n\n    authorizeRequest(containerIDStr, launchContext, remoteUgi, tokenId);\n\n    // Is the container coming from unknown RM\n    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext,\n          credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(tokenId.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "b16c5638b5190c56f9d854d873589cb5c11c8b32": {
      "type": "Ybodychange",
      "commitMessage": "YARN-719. Move RMIdentifier from Container to ContainerTokenIdentifier. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1487741 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/05/13 9:59 PM",
      "commitName": "b16c5638b5190c56f9d854d873589cb5c11c8b32",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "23/05/13 8:22 PM",
      "commitNameOld": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.07,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n     ContainerTokenIdentifier tokenId \u003d \n         getContainerTokenIdentifier(remoteUgi, lauchContainer);\n     authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n       tokenId);\n \n     // Is the container coming from unknown RM\n-    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n+    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n     String user \u003d tokenId.getApplicationSubmitter();\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, lauchContainer, credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           user, applicationID, credentials,\n           context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n     NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, lauchContainer);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n      tokenId);\n\n    // Is the container coming from unknown RM\n    if (tokenId.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "259edf8dca44de54033e96f7eb65a83aaa6096f2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-571. Remove user from ContainerLaunchContext. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1485928 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/13 8:22 PM",
      "commitName": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "16/05/13 11:36 PM",
      "commitNameOld": "ca8024673178fa1c80224b390dfba932921693d9",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.87,
      "commitsBetweenForRepo": 26,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,100 +1,102 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n     ContainerTokenIdentifier tokenId \u003d \n         getContainerTokenIdentifier(remoteUgi, lauchContainer);\n     authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n       tokenId);\n \n     // Is the container coming from unknown RM\n     if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n-        + launchContext.getUser());\n+        + tokenId.getApplicationSubmitter());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n+    String user \u003d tokenId.getApplicationSubmitter();\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n-        launchContext, lauchContainer, credentials, metrics);\n+        launchContext, lauchContainer, credentials, metrics, tokenId);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n-      NMAuditLogger.logFailure(launchContext.getUser(), \n+      NMAuditLogger.logFailure(user, \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n-          launchContext.getUser(), applicationID, credentials, context);\n+          user, applicationID, credentials,\n+          context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     \n     this.context.getContainerTokenSecretManager().startContainerSuccessful(\n       tokenId);\n-    NMAuditLogger.logSuccess(launchContext.getUser(), \n+    NMAuditLogger.logSuccess(user, \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, lauchContainer);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n      tokenId);\n\n    // Is the container coming from unknown RM\n    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + tokenId.getApplicationSubmitter());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n    String user \u003d tokenId.getApplicationSubmitter();\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics, tokenId);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(user, \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          user, applicationID, credentials,\n          context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(user, \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "ca8024673178fa1c80224b390dfba932921693d9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-617. Made ContainerTokens to be used for validation at NodeManager also in unsecure mode to prevent AMs from faking resource requirements in unsecure mode. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1483667 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/05/13 11:36 PM",
      "commitName": "ca8024673178fa1c80224b390dfba932921693d9",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/05/13 9:11 PM",
      "commitNameOld": "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 3.1,
      "commitsBetweenForRepo": 19,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,100 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n-    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n+    ContainerTokenIdentifier tokenId \u003d \n+        getContainerTokenIdentifier(remoteUgi, lauchContainer);\n+    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n+      tokenId);\n \n     // Is the container coming from unknown RM\n     if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, lauchContainer, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n-    if (UserGroupInformation.isSecurityEnabled()) {\n-      ContainerTokenIdentifier tokenId \u003d\n-          selectContainerTokenIdentifier(remoteUgi);\n-      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n-        tokenId);\n-    }\n-\n+    \n+    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n+      tokenId);\n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    ContainerTokenIdentifier tokenId \u003d \n        getContainerTokenIdentifier(remoteUgi, lauchContainer);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi,\n      tokenId);\n\n    // Is the container coming from unknown RM\n    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    \n    this.context.getContainerTokenSecretManager().startContainerSuccessful(\n      tokenId);\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-615. Rename ContainerLaunchContext.containerTokens to tokens. Contributed by Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1482199 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/05/13 9:11 PM",
      "commitName": "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "06/05/13 5:42 PM",
      "commitNameOld": "9eb53b9c841233538a51e4e854b261536c0b85d4",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.15,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,101 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n     authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n \n     // Is the container coming from unknown RM\n     if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + launchContext.getUser());\n \n     // //////////// Parse credentials\n-    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n+    ByteBuffer tokens \u003d launchContext.getTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, lauchContainer, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     if (UserGroupInformation.isSecurityEnabled()) {\n       ContainerTokenIdentifier tokenId \u003d\n           selectContainerTokenIdentifier(remoteUgi);\n       this.context.getContainerTokenSecretManager().startContainerSuccessful(\n         tokenId);\n     }\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n\n    // Is the container coming from unknown RM\n    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    if (UserGroupInformation.isSecurityEnabled()) {\n      ContainerTokenIdentifier tokenId \u003d\n          selectContainerTokenIdentifier(remoteUgi);\n      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n        tokenId);\n    }\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "9eb53b9c841233538a51e4e854b261536c0b85d4": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-632. Changed ContainerManager api to throw IOException and YarnRemoteException. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1479740 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/05/13 5:42 PM",
      "commitName": "9eb53b9c841233538a51e4e854b261536c0b85d4",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "06/05/13 12:04 PM",
      "commitNameOld": "92b7165a71656468f17ce8b760ce11e648932f0e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,101 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n-      throws YarnRemoteException {\n+      throws YarnRemoteException, IOException {\n \n     if (blockNewContainerRequests.get()) {\n       throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n           \"Rejecting new containers as NodeManager has not\" +\n           \" yet connected with ResourceManager\"));\n     }\n \n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n     authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n \n     // Is the container coming from unknown RM\n     if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n       .getRMIdentifier()) {\n       String msg \u003d \"\\nContainer \"+ containerIDStr\n           + \" rejected as it is allocated by a previous RM\";\n       LOG.error(msg);\n       throw RPCUtil\n         .getRemoteException(new InvalidContainerException(msg));\n     }\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, lauchContainer, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     if (UserGroupInformation.isSecurityEnabled()) {\n       ContainerTokenIdentifier tokenId \u003d\n           selectContainerTokenIdentifier(remoteUgi);\n       this.context.getContainerTokenSecretManager().startContainerSuccessful(\n         tokenId);\n     }\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException, IOException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n\n    // Is the container coming from unknown RM\n    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    if (UserGroupInformation.isSecurityEnabled()) {\n      ContainerTokenIdentifier tokenId \u003d\n          selectContainerTokenIdentifier(remoteUgi);\n      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n        tokenId);\n    }\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException]",
        "newValue": "[YarnRemoteException, IOException]"
      }
    },
    "fbb55784d93e1a819daf55d936e864d344579cbf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-562. Modified NM to reject any containers allocated by a previous ResourceManager. Contributed by Jian He.\nMAPREDUCE-5167. Update MR App after YARN-562 to use the new builder API for the container. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1476034 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/04/13 8:50 PM",
      "commitName": "fbb55784d93e1a819daf55d936e864d344579cbf",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/04/13 6:33 PM",
      "commitNameOld": "8e1c2823fc014a5a045c86760c61111d0bb59d2f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.1,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,101 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n+\n+    if (blockNewContainerRequests.get()) {\n+      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n+          \"Rejecting new containers as NodeManager has not\" +\n+          \" yet connected with ResourceManager\"));\n+    }\n+\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n     authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n \n+    // Is the container coming from unknown RM\n+    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n+      .getRMIdentifier()) {\n+      String msg \u003d \"\\nContainer \"+ containerIDStr\n+          + \" rejected as it is allocated by a previous RM\";\n+      LOG.error(msg);\n+      throw RPCUtil\n+        .getRemoteException(new InvalidContainerException(msg));\n+    }\n+\n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, lauchContainer, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     if (UserGroupInformation.isSecurityEnabled()) {\n       ContainerTokenIdentifier tokenId \u003d\n           selectContainerTokenIdentifier(remoteUgi);\n       this.context.getContainerTokenSecretManager().startContainerSuccessful(\n         tokenId);\n     }\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n\n    if (blockNewContainerRequests.get()) {\n      throw RPCUtil.getRemoteException(new NMNotYetReadyException(\n          \"Rejecting new containers as NodeManager has not\" +\n          \" yet connected with ResourceManager\"));\n    }\n\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n\n    // Is the container coming from unknown RM\n    if (lauchContainer.getRMIdentifer() !\u003d nodeStatusUpdater\n      .getRMIdentifier()) {\n      String msg \u003d \"\\nContainer \"+ containerIDStr\n          + \" rejected as it is allocated by a previous RM\";\n      LOG.error(msg);\n      throw RPCUtil\n        .getRemoteException(new InvalidContainerException(msg));\n    }\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    if (UserGroupInformation.isSecurityEnabled()) {\n      ContainerTokenIdentifier tokenId \u003d\n          selectContainerTokenIdentifier(remoteUgi);\n      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n        tokenId);\n    }\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "8e1c2823fc014a5a045c86760c61111d0bb59d2f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-441. Removed unused utility methods for collections from two API records. Contributed by Xuan Gong.\nMAPREDUCE-5163. Update MR App to not use API utility methods for collections after YARN-441. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469657 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/04/13 6:33 PM",
      "commitName": "8e1c2823fc014a5a045c86760c61111d0bb59d2f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "11/04/13 12:28 PM",
      "commitNameOld": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.25,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n     org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n         request.getContainer();\n     ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n     authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, lauchContainer, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     if (UserGroupInformation.isSecurityEnabled()) {\n       ContainerTokenIdentifier tokenId \u003d\n           selectContainerTokenIdentifier(remoteUgi);\n       this.context.getContainerTokenSecretManager().startContainerSuccessful(\n         tokenId);\n     }\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.addAllServiceResponse(auxiliaryServices.getMeta());\n+    response.setAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    if (UserGroupInformation.isSecurityEnabled()) {\n      ContainerTokenIdentifier tokenId \u003d\n          selectContainerTokenIdentifier(remoteUgi);\n      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n        tokenId);\n    }\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.setAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-486. Changed NM\u0027s startContainer API to accept Container record given by RM as a direct parameter instead of as part of the ContainerLaunchContext record. Contributed by Xuan Gong.\nMAPREDUCE-5139. Update MR AM to use the modified startContainer API after YARN-486. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1467063 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/04/13 12:28 PM",
      "commitName": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/12/12 4:12 AM",
      "commitNameOld": "235749a8ab5f303b5b3a2993da8c5bea1818183b",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 129.3,
      "commitsBetweenForRepo": 595,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,84 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n-\n-    ContainerId containerID \u003d launchContext.getContainerId();\n+    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n+        request.getContainer();\n+    ContainerId containerID \u003d lauchContainer.getId();\n     String containerIDStr \u003d containerID.toString();\n \n     UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n-    authorizeRequest(containerIDStr, launchContext, remoteUgi);\n+    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n \n     LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n         + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n-        launchContext, credentials, metrics);\n+        launchContext, lauchContainer, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n           launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n     if (UserGroupInformation.isSecurityEnabled()) {\n       ContainerTokenIdentifier tokenId \u003d\n           selectContainerTokenIdentifier(remoteUgi);\n       this.context.getContainerTokenSecretManager().startContainerSuccessful(\n         tokenId);\n     }\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n-    metrics.allocateContainer(launchContext.getResource());\n+    metrics.allocateContainer(lauchContainer.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n    org.apache.hadoop.yarn.api.records.Container lauchContainer \u003d\n        request.getContainer();\n    ContainerId containerID \u003d lauchContainer.getId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    authorizeRequest(containerIDStr, launchContext, lauchContainer, remoteUgi);\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, lauchContainer, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    if (UserGroupInformation.isSecurityEnabled()) {\n      ContainerTokenIdentifier tokenId \u003d\n          selectContainerTokenIdentifier(remoteUgi);\n      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n        tokenId);\n    }\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(lauchContainer.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "ffd2e01604be814fa3db1dded7cd7cff26a79b1e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-39. RM-NM secret-keys should be randomly generated and rolled every so often. (Contributed by Vinod Kumar Vavilapalli and Siddharth Seth)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1377180 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/12 7:18 PM",
      "commitName": "ffd2e01604be814fa3db1dded7cd7cff26a79b1e",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 16.87,
      "commitsBetweenForRepo": 114,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,83 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     ContainerId containerID \u003d launchContext.getContainerId();\n-    authorizeRequest(containerID, launchContext);\n+    String containerIDStr \u003d containerID.toString();\n \n-    LOG.info(\"Start request for \" + launchContext.getContainerId()\n-        + \" by user \" + launchContext.getUser());\n+    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n+    authorizeRequest(containerIDStr, launchContext, remoteUgi);\n+\n+    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n+        + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n-      throw RPCUtil.getRemoteException(\"Container \" + containerID\n+      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n-            launchContext.getUser(), applicationID, credentials, context);\n+          launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      ContainerTokenIdentifier tokenId \u003d\n+          selectContainerTokenIdentifier(remoteUgi);\n+      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n+        tokenId);\n+    }\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    ContainerId containerID \u003d launchContext.getContainerId();\n    String containerIDStr \u003d containerID.toString();\n\n    UserGroupInformation remoteUgi \u003d getRemoteUgi(containerIDStr);\n    authorizeRequest(containerIDStr, launchContext, remoteUgi);\n\n    LOG.info(\"Start request for \" + containerIDStr + \" by user \"\n        + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerIDStr\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n          launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n    if (UserGroupInformation.isSecurityEnabled()) {\n      ContainerTokenIdentifier tokenId \u003d\n          selectContainerTokenIdentifier(remoteUgi);\n      this.context.getContainerTokenSecretManager().startContainerSuccessful(\n        tokenId);\n    }\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    ContainerId containerID \u003d launchContext.getContainerId();\n    authorizeRequest(containerID, launchContext);\n\n    LOG.info(\"Start request for \" + launchContext.getContainerId()\n        + \" by user \" + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n            launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java"
      }
    },
    "4e5818698778bff9d2b1ba14297d8393e49927c7": {
      "type": "Ybodychange",
      "commitMessage": "Removed some logs.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1304099 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/03/12 3:20 PM",
      "commitName": "4e5818698778bff9d2b1ba14297d8393e49927c7",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "20/02/12 9:08 PM",
      "commitNameOld": "5ee495e6f34faff231ad87ec890188eb63617393",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 30.72,
      "commitsBetweenForRepo": 207,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,74 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     ContainerId containerID \u003d launchContext.getContainerId();\n     authorizeRequest(containerID, launchContext);\n \n-    LOG.info(\" container is \" + request);\n+    LOG.info(\"Start request for \" + launchContext.getContainerId()\n+        + \" by user \" + launchContext.getUser());\n \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n         launchContext, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n             launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    ContainerId containerID \u003d launchContext.getContainerId();\n    authorizeRequest(containerID, launchContext);\n\n    LOG.info(\"Start request for \" + launchContext.getContainerId()\n        + \" by user \" + launchContext.getUser());\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n            launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "7f4dc277572df6ba25fa961073b99a5bdb086c00": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3256. Added authorization checks for the protocol between NodeManager and ApplicationMaster. Contributed by Vinod K V.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1194850 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/10/11 2:35 AM",
      "commitName": "7f4dc277572df6ba25fa961073b99a5bdb086c00",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "27/10/11 11:45 PM",
      "commitNameOld": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,73 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n+    ContainerId containerID \u003d launchContext.getContainerId();\n+    authorizeRequest(containerID, launchContext);\n+\n     LOG.info(\" container is \" + request);\n-  \n+\n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n-    Container container \u003d\n-        new ContainerImpl(getConfig(), this.dispatcher, launchContext, credentials, metrics);\n-    ContainerId containerID \u003d launchContext.getContainerId();\n+    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n+        launchContext, credentials, metrics);\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d\n         new ApplicationImpl(dispatcher, this.aclsManager,\n             launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    ContainerId containerID \u003d launchContext.getContainerId();\n    authorizeRequest(containerID, launchContext);\n\n    LOG.info(\" container is \" + request);\n\n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d new ContainerImpl(getConfig(), this.dispatcher,\n        launchContext, credentials, metrics);\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n            launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "670fa24b48acb407c22fbfdde87ae3123dcbf449": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2989. Modified JobHistory to link to task and AM logs from the JobHistoryServer. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190174 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 11:45 PM",
      "commitName": "670fa24b48acb407c22fbfdde87ae3123dcbf449",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "26/10/11 4:58 PM",
      "commitNameOld": "237154982bd5853c6a374cb265520e0602adc52f",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.28,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,71 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(getConfig(), this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n-    Application application \u003d new ApplicationImpl(dispatcher,\n-        this.aclsManager, launchContext.getUser(), applicationID, credentials);\n+    Application application \u003d\n+        new ApplicationImpl(dispatcher, this.aclsManager,\n+            launchContext.getUser(), applicationID, credentials, context);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d\n        new ApplicationImpl(dispatcher, this.aclsManager,\n            launchContext.getUser(), applicationID, credentials, context);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "237154982bd5853c6a374cb265520e0602adc52f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3205. Fix memory specifications to be physical rather than virtual, allowing for a ratio between the two to be configurable. Contributed by Todd Lipcon. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189542 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/10/11 4:58 PM",
      "commitName": "237154982bd5853c6a374cb265520e0602adc52f",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/10/11 11:07 PM",
      "commitNameOld": "d19cfe01642f9582e1fe5d567beb480399c37a01",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 1.74,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,70 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n-        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n+        new ContainerImpl(getConfig(), this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         this.aclsManager, launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n           new ApplicationInitEvent(applicationID, container\n               .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(getConfig(), this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        this.aclsManager, launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "df2991c0cbc3f35c2640b93680667507c4f810dd": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3104. Implemented Application-acls. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1186748 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/10/11 4:45 AM",
      "commitName": "df2991c0cbc3f35c2640b93680667507c4f810dd",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/10/11 11:40 PM",
      "commitNameOld": "e3bb120e9fefb21168edd7cd06f0cbfb92a5e02b",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.21,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,70 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n-        launchContext.getUser(), applicationID, credentials);\n+        this.aclsManager, launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n       dispatcher.getEventHandler().handle(\n-          new ApplicationInitEvent(applicationID));\n+          new ApplicationInitEvent(applicationID, container\n+              .getLaunchContext().getApplicationACLs()));\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(\n         new ApplicationContainerInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        this.aclsManager, launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID, container\n              .getLaunchContext().getApplicationACLs()));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "e3bb120e9fefb21168edd7cd06f0cbfb92a5e02b": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3162. Separated application-init and container-init event types in NodeManager\u0027s Application state machine. Contributed by Todd Lipcon.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1185988 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/10/11 11:40 PM",
      "commitName": "e3bb120e9fefb21168edd7cd06f0cbfb92a5e02b",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "10/10/11 9:45 PM",
      "commitNameOld": "11b9dd4e844c762f8c53e5fafa25f29eece1bc87",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 8.08,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,69 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n+      dispatcher.getEventHandler().handle(\n+          new ApplicationInitEvent(applicationID));\n     }\n \n     // TODO: Validate the request\n-    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n+    dispatcher.getEventHandler().handle(\n+        new ApplicationContainerInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n      dispatcher.getEventHandler().handle(\n          new ApplicationInitEvent(applicationID));\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(\n        new ApplicationContainerInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "11b9dd4e844c762f8c53e5fafa25f29eece1bc87": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3161. Improved some javadocs and fixed some typos in YARN. Contributed by Todd Lipcon.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1181622 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/10/11 9:45 PM",
      "commitName": "11b9dd4e844c762f8c53e5fafa25f29eece1bc87",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "07/10/11 8:23 AM",
      "commitNameOld": "02a81203bd0ff6116e3c68d376b3af3838231986",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 3.56,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n-    response.addAllServiceResponse(auxiluaryServices.getMeta());\n+    response.addAllServiceResponse(auxiliaryServices.getMeta());\n     // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n     // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiliaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "02a81203bd0ff6116e3c68d376b3af3838231986": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2751. Modified NodeManager to stop leaving around local files after application finishes. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1180071 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/10/11 8:23 AM",
      "commitName": "02a81203bd0ff6116e3c68d376b3af3838231986",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "05/10/11 4:43 AM",
      "commitNameOld": "66137cf17cb4abccd6065819d97edc63c6510477",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.15,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d \n         containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiluaryServices.getMeta());\n+    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n+    // launch. A finished Application will not launch containers.\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiluaryServices.getMeta());\n    // TODO launchedContainer misplaced -\u003e doesn\u0027t necessarily mean a container\n    // launch. A finished Application will not launch containers.\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2896. Simplify all apis to in org.apache.hadoop.yarn.api.records.* to be get/set only. Added javadocs to all public records.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169980 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/09/11 5:05 PM",
      "commitName": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "12/09/11 12:11 AM",
      "commitNameOld": "6b2f2efe4de4e709a2b9c64b7b3b3138e1939668",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.7,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,64 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n-    ApplicationId applicationID \u003d containerID.getAppId();\n+    ApplicationId applicationID \u003d \n+        containerID.getApplicationAttemptId().getApplicationId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       NMAuditLogger.logFailure(launchContext.getUser(), \n           AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n           \"Container already running on this node!\",\n           applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n \n     NMAuditLogger.logSuccess(launchContext.getUser(), \n         AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n         applicationID, containerID);\n \n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiluaryServices.getMeta());\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d \n        containerID.getApplicationAttemptId().getApplicationId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiluaryServices.getMeta());\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "cdfabf5ae289836968b3d296668593b9500b6f26": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2655. Add audit logs to ResourceManager and NodeManager. Contributed by Thomas Graves.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165949 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/11 6:24 PM",
      "commitName": "cdfabf5ae289836968b3d296668593b9500b6f26",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "31/08/11 4:38 AM",
      "commitNameOld": "ade0f0560f729e50382c6992f713f29e2dd5b270",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 6.57,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,54 +1,63 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d containerID.getAppId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n+      NMAuditLogger.logFailure(launchContext.getUser(), \n+          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n+          \"Container already running on this node!\",\n+          applicationID, containerID);\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n+\n+    NMAuditLogger.logSuccess(launchContext.getUser(), \n+        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n+        applicationID, containerID);\n+\n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n     response.addAllServiceResponse(auxiluaryServices.getMeta());\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d containerID.getAppId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      NMAuditLogger.logFailure(launchContext.getUser(), \n          AuditConstants.START_CONTAINER, \"ContainerManagerImpl\",\n          \"Container already running on this node!\",\n          applicationID, containerID);\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n\n    NMAuditLogger.logSuccess(launchContext.getUser(), \n        AuditConstants.START_CONTAINER, \"ContainerManageImpl\", \n        applicationID, containerID);\n\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiluaryServices.getMeta());\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "ade0f0560f729e50382c6992f713f29e2dd5b270": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2652. Enabled multiple NMs to be runnable on a single node by making shuffle service port to be truely configurable. Contributed by Robert Joseph Evans.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1163585 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/08/11 4:38 AM",
      "commitName": "ade0f0560f729e50382c6992f713f29e2dd5b270",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 6.48,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,54 @@\n   public StartContainerResponse startContainer(StartContainerRequest request)\n       throws YarnRemoteException {\n     ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n \n     LOG.info(\" container is \" + request);\n   \n     // //////////// Parse credentials\n     ByteBuffer tokens \u003d launchContext.getContainerTokens();\n     Credentials credentials \u003d new Credentials();\n     if (tokens !\u003d null) {\n       DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n       tokens.rewind();\n       buf.reset(tokens);\n       try {\n         credentials.readTokenStorageStream(buf);\n         if (LOG.isDebugEnabled()) {\n           for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n               .getAllTokens()) {\n             LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n           }\n         }\n       } catch (IOException e) {\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n     // //////////// End of parsing credentials\n \n     Container container \u003d\n         new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n     ContainerId containerID \u003d launchContext.getContainerId();\n     ApplicationId applicationID \u003d containerID.getAppId();\n     if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n       throw RPCUtil.getRemoteException(\"Container \" + containerID\n           + \" already is running on this node!!\");\n     }\n \n     // Create the application\n     Application application \u003d new ApplicationImpl(dispatcher,\n         launchContext.getUser(), applicationID, credentials);\n     if (null \u003d\u003d\n         context.getApplications().putIfAbsent(applicationID, application)) {\n       LOG.info(\"Creating a new application reference for app \"\n           + applicationID);\n     }\n \n     // TODO: Validate the request\n     dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n     StartContainerResponse response \u003d\n         recordFactory.newRecordInstance(StartContainerResponse.class);\n+    response.addAllServiceResponse(auxiluaryServices.getMeta());\n     metrics.launchedContainer();\n     metrics.allocateContainer(launchContext.getResource());\n     return response;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d containerID.getAppId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    response.addAllServiceResponse(auxiluaryServices.getMeta());\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d containerID.getAppId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,53 @@\n+  public StartContainerResponse startContainer(StartContainerRequest request)\n+      throws YarnRemoteException {\n+    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n+\n+    LOG.info(\" container is \" + request);\n+  \n+    // //////////// Parse credentials\n+    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n+    Credentials credentials \u003d new Credentials();\n+    if (tokens !\u003d null) {\n+      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n+      tokens.rewind();\n+      buf.reset(tokens);\n+      try {\n+        credentials.readTokenStorageStream(buf);\n+        if (LOG.isDebugEnabled()) {\n+          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n+              .getAllTokens()) {\n+            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n+          }\n+        }\n+      } catch (IOException e) {\n+        throw RPCUtil.getRemoteException(e);\n+      }\n+    }\n+    // //////////// End of parsing credentials\n+\n+    Container container \u003d\n+        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n+    ContainerId containerID \u003d launchContext.getContainerId();\n+    ApplicationId applicationID \u003d containerID.getAppId();\n+    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n+      throw RPCUtil.getRemoteException(\"Container \" + containerID\n+          + \" already is running on this node!!\");\n+    }\n+\n+    // Create the application\n+    Application application \u003d new ApplicationImpl(dispatcher,\n+        launchContext.getUser(), applicationID, credentials);\n+    if (null \u003d\u003d\n+        context.getApplications().putIfAbsent(applicationID, application)) {\n+      LOG.info(\"Creating a new application reference for app \"\n+          + applicationID);\n+    }\n+\n+    // TODO: Validate the request\n+    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n+    StartContainerResponse response \u003d\n+        recordFactory.newRecordInstance(StartContainerResponse.class);\n+    metrics.launchedContainer();\n+    metrics.allocateContainer(launchContext.getResource());\n+    return response;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public StartContainerResponse startContainer(StartContainerRequest request)\n      throws YarnRemoteException {\n    ContainerLaunchContext launchContext \u003d request.getContainerLaunchContext();\n\n    LOG.info(\" container is \" + request);\n  \n    // //////////// Parse credentials\n    ByteBuffer tokens \u003d launchContext.getContainerTokens();\n    Credentials credentials \u003d new Credentials();\n    if (tokens !\u003d null) {\n      DataInputByteBuffer buf \u003d new DataInputByteBuffer();\n      tokens.rewind();\n      buf.reset(tokens);\n      try {\n        credentials.readTokenStorageStream(buf);\n        if (LOG.isDebugEnabled()) {\n          for (Token\u003c? extends TokenIdentifier\u003e tk : credentials\n              .getAllTokens()) {\n            LOG.debug(tk.getService() + \" \u003d \" + tk.toString());\n          }\n        }\n      } catch (IOException e) {\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n    // //////////// End of parsing credentials\n\n    Container container \u003d\n        new ContainerImpl(this.dispatcher, launchContext, credentials, metrics);\n    ContainerId containerID \u003d launchContext.getContainerId();\n    ApplicationId applicationID \u003d containerID.getAppId();\n    if (context.getContainers().putIfAbsent(containerID, container) !\u003d null) {\n      throw RPCUtil.getRemoteException(\"Container \" + containerID\n          + \" already is running on this node!!\");\n    }\n\n    // Create the application\n    Application application \u003d new ApplicationImpl(dispatcher,\n        launchContext.getUser(), applicationID, credentials);\n    if (null \u003d\u003d\n        context.getApplications().putIfAbsent(applicationID, application)) {\n      LOG.info(\"Creating a new application reference for app \"\n          + applicationID);\n    }\n\n    // TODO: Validate the request\n    dispatcher.getEventHandler().handle(new ApplicationInitEvent(container));\n    StartContainerResponse response \u003d\n        recordFactory.newRecordInstance(StartContainerResponse.class);\n    metrics.launchedContainer();\n    metrics.allocateContainer(launchContext.getResource());\n    return response;\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/ContainerManagerImpl.java"
    }
  }
}