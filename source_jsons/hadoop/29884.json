{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "EntityGroupFSTimelineStore.java",
  "functionName": "serviceInit",
  "functionId": "serviceInit___conf-Configuration",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
  "functionStartLine": 147,
  "functionEndLine": 210,
  "numCommitsSeen": 17,
  "timeTaken": 2230,
  "changeHistory": [
    "7f3c306e2ed9e865171324898decb9b587d90e73",
    "705286ccaeea36941d97ec1c1700746b74264924",
    "06413da72efed9a50e49efaf7110c220c88a7f4a",
    "e0cb426758b3d716ff143f723fc16ef2f1e4971b",
    "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec",
    "02f597c5db36ded385413958bdee793ad7eda40e"
  ],
  "changeHistoryShort": {
    "7f3c306e2ed9e865171324898decb9b587d90e73": "Ybodychange",
    "705286ccaeea36941d97ec1c1700746b74264924": "Ybodychange",
    "06413da72efed9a50e49efaf7110c220c88a7f4a": "Ybodychange",
    "e0cb426758b3d716ff143f723fc16ef2f1e4971b": "Ybodychange",
    "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec": "Ybodychange",
    "02f597c5db36ded385413958bdee793ad7eda40e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "7f3c306e2ed9e865171324898decb9b587d90e73": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5432. Lock already held by another process while LevelDB cache store creation for dag. Contributed by Li Lu.\n",
      "commitDate": "28/07/16 6:35 AM",
      "commitName": "7f3c306e2ed9e865171324898decb9b587d90e73",
      "commitAuthor": "Junping Du",
      "commitDateOld": "07/07/16 10:37 PM",
      "commitNameOld": "673e5e02feba9171498a518c06ae70639c5f8854",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 20.33,
      "commitsBetweenForRepo": 249,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,64 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     metrics \u003d EntityGroupFSTimelineStoreMetrics.create();\n     summaryStore \u003d createSummaryStore();\n     addService(summaryStore);\n \n     long logRetainSecs \u003d conf.getLong(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT);\n     logRetainMillis \u003d logRetainSecs * 1000;\n     LOG.info(\"Cleaner set to delete logs older than {} seconds\", logRetainSecs);\n     long unknownActiveSecs \u003d conf.getLong(\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS,\n         YarnConfiguration.\n             TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT\n     );\n     unknownActiveMillis \u003d unknownActiveSecs * 1000;\n     LOG.info(\"Unknown apps will be treated as complete after {} seconds\",\n         unknownActiveSecs);\n     appCacheMaxSize \u003d conf.getInt(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT);\n     LOG.info(\"Application cache size is {}\", appCacheMaxSize);\n     cachedLogs \u003d Collections.synchronizedMap(\n       new LinkedHashMap\u003cTimelineEntityGroupId, EntityCacheItem\u003e(\n           appCacheMaxSize + 1, 0.75f, true) {\n           @Override\n           protected boolean removeEldestEntry(\n               Map.Entry\u003cTimelineEntityGroupId, EntityCacheItem\u003e eldest) {\n             if (super.size() \u003e appCacheMaxSize) {\n               TimelineEntityGroupId groupId \u003d eldest.getKey();\n               LOG.debug(\"Evicting {} due to space limitations\", groupId);\n               EntityCacheItem cacheItem \u003d eldest.getValue();\n-              int activeStores \u003d EntityCacheItem.getActiveStores();\n-              if (activeStores \u003e appCacheMaxSize * CACHE_ITEM_OVERFLOW_FACTOR) {\n-                LOG.debug(\"Force release cache {} since {} stores are active\",\n-                    groupId, activeStores);\n-                cacheItem.forceRelease();\n-              } else {\n-                LOG.debug(\"Try release cache {}\", groupId);\n-                cacheItem.tryRelease();\n-              }\n+              LOG.debug(\"Force release cache {}.\", groupId);\n+              cacheItem.forceRelease();\n               if (cacheItem.getAppLogs().isDone()) {\n                 appIdLogMap.remove(groupId.getApplicationId());\n               }\n               metrics.incrCacheEvicts();\n               return true;\n             }\n             return false;\n           }\n       });\n     cacheIdPlugins \u003d loadPlugIns(conf);\n     // Initialize yarn client for application status\n     yarnClient \u003d createAndInitYarnClient(conf);\n     // if non-null, hook its lifecycle up\n     addIfService(yarnClient);\n     activeRootPath \u003d new Path(conf.get(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR_DEFAULT));\n     doneRootPath \u003d new Path(conf.get(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR_DEFAULT));\n     fs \u003d activeRootPath.getFileSystem(conf);\n     CallerContext.setCurrent(\n         new CallerContext.Builder(ATS_V15_SERVER_DFS_CALLER_CTXT).build());\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    metrics \u003d EntityGroupFSTimelineStoreMetrics.create();\n    summaryStore \u003d createSummaryStore();\n    addService(summaryStore);\n\n    long logRetainSecs \u003d conf.getLong(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT);\n    logRetainMillis \u003d logRetainSecs * 1000;\n    LOG.info(\"Cleaner set to delete logs older than {} seconds\", logRetainSecs);\n    long unknownActiveSecs \u003d conf.getLong(\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS,\n        YarnConfiguration.\n            TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT\n    );\n    unknownActiveMillis \u003d unknownActiveSecs * 1000;\n    LOG.info(\"Unknown apps will be treated as complete after {} seconds\",\n        unknownActiveSecs);\n    appCacheMaxSize \u003d conf.getInt(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT);\n    LOG.info(\"Application cache size is {}\", appCacheMaxSize);\n    cachedLogs \u003d Collections.synchronizedMap(\n      new LinkedHashMap\u003cTimelineEntityGroupId, EntityCacheItem\u003e(\n          appCacheMaxSize + 1, 0.75f, true) {\n          @Override\n          protected boolean removeEldestEntry(\n              Map.Entry\u003cTimelineEntityGroupId, EntityCacheItem\u003e eldest) {\n            if (super.size() \u003e appCacheMaxSize) {\n              TimelineEntityGroupId groupId \u003d eldest.getKey();\n              LOG.debug(\"Evicting {} due to space limitations\", groupId);\n              EntityCacheItem cacheItem \u003d eldest.getValue();\n              LOG.debug(\"Force release cache {}.\", groupId);\n              cacheItem.forceRelease();\n              if (cacheItem.getAppLogs().isDone()) {\n                appIdLogMap.remove(groupId.getApplicationId());\n              }\n              metrics.incrCacheEvicts();\n              return true;\n            }\n            return false;\n          }\n      });\n    cacheIdPlugins \u003d loadPlugIns(conf);\n    // Initialize yarn client for application status\n    yarnClient \u003d createAndInitYarnClient(conf);\n    // if non-null, hook its lifecycle up\n    addIfService(yarnClient);\n    activeRootPath \u003d new Path(conf.get(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR_DEFAULT));\n    doneRootPath \u003d new Path(conf.get(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR_DEFAULT));\n    fs \u003d activeRootPath.getFileSystem(conf);\n    CallerContext.setCurrent(\n        new CallerContext.Builder(ATS_V15_SERVER_DFS_CALLER_CTXT).build());\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
      "extendedDetails": {}
    },
    "705286ccaeea36941d97ec1c1700746b74264924": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4987. Read cache concurrency issue between read and evict in EntityGroupFS timeline store. Contributed by Li Lu.\n",
      "commitDate": "27/05/16 6:58 AM",
      "commitName": "705286ccaeea36941d97ec1c1700746b74264924",
      "commitAuthor": "Junping Du",
      "commitDateOld": "03/05/16 4:16 AM",
      "commitNameOld": "06413da72efed9a50e49efaf7110c220c88a7f4a",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 24.11,
      "commitsBetweenForRepo": 182,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,63 +1,71 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     metrics \u003d EntityGroupFSTimelineStoreMetrics.create();\n     summaryStore \u003d createSummaryStore();\n     addService(summaryStore);\n \n     long logRetainSecs \u003d conf.getLong(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT);\n     logRetainMillis \u003d logRetainSecs * 1000;\n     LOG.info(\"Cleaner set to delete logs older than {} seconds\", logRetainSecs);\n     long unknownActiveSecs \u003d conf.getLong(\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS,\n         YarnConfiguration.\n             TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT\n     );\n     unknownActiveMillis \u003d unknownActiveSecs * 1000;\n     LOG.info(\"Unknown apps will be treated as complete after {} seconds\",\n         unknownActiveSecs);\n     appCacheMaxSize \u003d conf.getInt(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT);\n     LOG.info(\"Application cache size is {}\", appCacheMaxSize);\n     cachedLogs \u003d Collections.synchronizedMap(\n       new LinkedHashMap\u003cTimelineEntityGroupId, EntityCacheItem\u003e(\n           appCacheMaxSize + 1, 0.75f, true) {\n           @Override\n           protected boolean removeEldestEntry(\n               Map.Entry\u003cTimelineEntityGroupId, EntityCacheItem\u003e eldest) {\n             if (super.size() \u003e appCacheMaxSize) {\n               TimelineEntityGroupId groupId \u003d eldest.getKey();\n               LOG.debug(\"Evicting {} due to space limitations\", groupId);\n               EntityCacheItem cacheItem \u003d eldest.getValue();\n-              cacheItem.releaseCache(groupId);\n+              int activeStores \u003d EntityCacheItem.getActiveStores();\n+              if (activeStores \u003e appCacheMaxSize * CACHE_ITEM_OVERFLOW_FACTOR) {\n+                LOG.debug(\"Force release cache {} since {} stores are active\",\n+                    groupId, activeStores);\n+                cacheItem.forceRelease();\n+              } else {\n+                LOG.debug(\"Try release cache {}\", groupId);\n+                cacheItem.tryRelease();\n+              }\n               if (cacheItem.getAppLogs().isDone()) {\n                 appIdLogMap.remove(groupId.getApplicationId());\n               }\n               metrics.incrCacheEvicts();\n               return true;\n             }\n             return false;\n           }\n       });\n     cacheIdPlugins \u003d loadPlugIns(conf);\n     // Initialize yarn client for application status\n     yarnClient \u003d createAndInitYarnClient(conf);\n     // if non-null, hook its lifecycle up\n     addIfService(yarnClient);\n     activeRootPath \u003d new Path(conf.get(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR_DEFAULT));\n     doneRootPath \u003d new Path(conf.get(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR_DEFAULT));\n     fs \u003d activeRootPath.getFileSystem(conf);\n     CallerContext.setCurrent(\n         new CallerContext.Builder(ATS_V15_SERVER_DFS_CALLER_CTXT).build());\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    metrics \u003d EntityGroupFSTimelineStoreMetrics.create();\n    summaryStore \u003d createSummaryStore();\n    addService(summaryStore);\n\n    long logRetainSecs \u003d conf.getLong(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT);\n    logRetainMillis \u003d logRetainSecs * 1000;\n    LOG.info(\"Cleaner set to delete logs older than {} seconds\", logRetainSecs);\n    long unknownActiveSecs \u003d conf.getLong(\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS,\n        YarnConfiguration.\n            TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT\n    );\n    unknownActiveMillis \u003d unknownActiveSecs * 1000;\n    LOG.info(\"Unknown apps will be treated as complete after {} seconds\",\n        unknownActiveSecs);\n    appCacheMaxSize \u003d conf.getInt(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT);\n    LOG.info(\"Application cache size is {}\", appCacheMaxSize);\n    cachedLogs \u003d Collections.synchronizedMap(\n      new LinkedHashMap\u003cTimelineEntityGroupId, EntityCacheItem\u003e(\n          appCacheMaxSize + 1, 0.75f, true) {\n          @Override\n          protected boolean removeEldestEntry(\n              Map.Entry\u003cTimelineEntityGroupId, EntityCacheItem\u003e eldest) {\n            if (super.size() \u003e appCacheMaxSize) {\n              TimelineEntityGroupId groupId \u003d eldest.getKey();\n              LOG.debug(\"Evicting {} due to space limitations\", groupId);\n              EntityCacheItem cacheItem \u003d eldest.getValue();\n              int activeStores \u003d EntityCacheItem.getActiveStores();\n              if (activeStores \u003e appCacheMaxSize * CACHE_ITEM_OVERFLOW_FACTOR) {\n                LOG.debug(\"Force release cache {} since {} stores are active\",\n                    groupId, activeStores);\n                cacheItem.forceRelease();\n              } else {\n                LOG.debug(\"Try release cache {}\", groupId);\n                cacheItem.tryRelease();\n              }\n              if (cacheItem.getAppLogs().isDone()) {\n                appIdLogMap.remove(groupId.getApplicationId());\n              }\n              metrics.incrCacheEvicts();\n              return true;\n            }\n            return false;\n          }\n      });\n    cacheIdPlugins \u003d loadPlugIns(conf);\n    // Initialize yarn client for application status\n    yarnClient \u003d createAndInitYarnClient(conf);\n    // if non-null, hook its lifecycle up\n    addIfService(yarnClient);\n    activeRootPath \u003d new Path(conf.get(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR_DEFAULT));\n    doneRootPath \u003d new Path(conf.get(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR_DEFAULT));\n    fs \u003d activeRootPath.getFileSystem(conf);\n    CallerContext.setCurrent(\n        new CallerContext.Builder(ATS_V15_SERVER_DFS_CALLER_CTXT).build());\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
      "extendedDetails": {}
    },
    "06413da72efed9a50e49efaf7110c220c88a7f4a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4851. Metric improvements for ATS v1.5 storage components. Li Lu via junping_du.\n",
      "commitDate": "03/05/16 4:16 AM",
      "commitName": "06413da72efed9a50e49efaf7110c220c88a7f4a",
      "commitAuthor": "Junping Du",
      "commitDateOld": "13/04/16 10:38 AM",
      "commitNameOld": "e0cb426758b3d716ff143f723fc16ef2f1e4971b",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 19.73,
      "commitsBetweenForRepo": 118,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,63 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n+    metrics \u003d EntityGroupFSTimelineStoreMetrics.create();\n     summaryStore \u003d createSummaryStore();\n     addService(summaryStore);\n \n     long logRetainSecs \u003d conf.getLong(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT);\n     logRetainMillis \u003d logRetainSecs * 1000;\n     LOG.info(\"Cleaner set to delete logs older than {} seconds\", logRetainSecs);\n     long unknownActiveSecs \u003d conf.getLong(\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS,\n         YarnConfiguration.\n             TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT\n     );\n     unknownActiveMillis \u003d unknownActiveSecs * 1000;\n     LOG.info(\"Unknown apps will be treated as complete after {} seconds\",\n         unknownActiveSecs);\n     appCacheMaxSize \u003d conf.getInt(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT);\n     LOG.info(\"Application cache size is {}\", appCacheMaxSize);\n     cachedLogs \u003d Collections.synchronizedMap(\n       new LinkedHashMap\u003cTimelineEntityGroupId, EntityCacheItem\u003e(\n           appCacheMaxSize + 1, 0.75f, true) {\n           @Override\n           protected boolean removeEldestEntry(\n               Map.Entry\u003cTimelineEntityGroupId, EntityCacheItem\u003e eldest) {\n             if (super.size() \u003e appCacheMaxSize) {\n               TimelineEntityGroupId groupId \u003d eldest.getKey();\n               LOG.debug(\"Evicting {} due to space limitations\", groupId);\n               EntityCacheItem cacheItem \u003d eldest.getValue();\n               cacheItem.releaseCache(groupId);\n               if (cacheItem.getAppLogs().isDone()) {\n                 appIdLogMap.remove(groupId.getApplicationId());\n               }\n+              metrics.incrCacheEvicts();\n               return true;\n             }\n             return false;\n           }\n       });\n     cacheIdPlugins \u003d loadPlugIns(conf);\n     // Initialize yarn client for application status\n     yarnClient \u003d createAndInitYarnClient(conf);\n     // if non-null, hook its lifecycle up\n     addIfService(yarnClient);\n     activeRootPath \u003d new Path(conf.get(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR_DEFAULT));\n     doneRootPath \u003d new Path(conf.get(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR_DEFAULT));\n     fs \u003d activeRootPath.getFileSystem(conf);\n     CallerContext.setCurrent(\n         new CallerContext.Builder(ATS_V15_SERVER_DFS_CALLER_CTXT).build());\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    metrics \u003d EntityGroupFSTimelineStoreMetrics.create();\n    summaryStore \u003d createSummaryStore();\n    addService(summaryStore);\n\n    long logRetainSecs \u003d conf.getLong(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT);\n    logRetainMillis \u003d logRetainSecs * 1000;\n    LOG.info(\"Cleaner set to delete logs older than {} seconds\", logRetainSecs);\n    long unknownActiveSecs \u003d conf.getLong(\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS,\n        YarnConfiguration.\n            TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT\n    );\n    unknownActiveMillis \u003d unknownActiveSecs * 1000;\n    LOG.info(\"Unknown apps will be treated as complete after {} seconds\",\n        unknownActiveSecs);\n    appCacheMaxSize \u003d conf.getInt(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT);\n    LOG.info(\"Application cache size is {}\", appCacheMaxSize);\n    cachedLogs \u003d Collections.synchronizedMap(\n      new LinkedHashMap\u003cTimelineEntityGroupId, EntityCacheItem\u003e(\n          appCacheMaxSize + 1, 0.75f, true) {\n          @Override\n          protected boolean removeEldestEntry(\n              Map.Entry\u003cTimelineEntityGroupId, EntityCacheItem\u003e eldest) {\n            if (super.size() \u003e appCacheMaxSize) {\n              TimelineEntityGroupId groupId \u003d eldest.getKey();\n              LOG.debug(\"Evicting {} due to space limitations\", groupId);\n              EntityCacheItem cacheItem \u003d eldest.getValue();\n              cacheItem.releaseCache(groupId);\n              if (cacheItem.getAppLogs().isDone()) {\n                appIdLogMap.remove(groupId.getApplicationId());\n              }\n              metrics.incrCacheEvicts();\n              return true;\n            }\n            return false;\n          }\n      });\n    cacheIdPlugins \u003d loadPlugIns(conf);\n    // Initialize yarn client for application status\n    yarnClient \u003d createAndInitYarnClient(conf);\n    // if non-null, hook its lifecycle up\n    addIfService(yarnClient);\n    activeRootPath \u003d new Path(conf.get(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR_DEFAULT));\n    doneRootPath \u003d new Path(conf.get(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR_DEFAULT));\n    fs \u003d activeRootPath.getFileSystem(conf);\n    CallerContext.setCurrent(\n        new CallerContext.Builder(ATS_V15_SERVER_DFS_CALLER_CTXT).build());\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
      "extendedDetails": {}
    },
    "e0cb426758b3d716ff143f723fc16ef2f1e4971b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4886. Add HDFS caller context for EntityGroupFSTimelineStore. Contributed by Li Lu\n",
      "commitDate": "13/04/16 10:38 AM",
      "commitName": "e0cb426758b3d716ff143f723fc16ef2f1e4971b",
      "commitAuthor": "Xuan",
      "commitDateOld": "10/03/16 10:51 AM",
      "commitNameOld": "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 33.95,
      "commitsBetweenForRepo": 194,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,61 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     summaryStore \u003d createSummaryStore();\n     addService(summaryStore);\n \n     long logRetainSecs \u003d conf.getLong(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT);\n     logRetainMillis \u003d logRetainSecs * 1000;\n     LOG.info(\"Cleaner set to delete logs older than {} seconds\", logRetainSecs);\n     long unknownActiveSecs \u003d conf.getLong(\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS,\n         YarnConfiguration.\n             TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT\n     );\n     unknownActiveMillis \u003d unknownActiveSecs * 1000;\n     LOG.info(\"Unknown apps will be treated as complete after {} seconds\",\n         unknownActiveSecs);\n     appCacheMaxSize \u003d conf.getInt(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT);\n     LOG.info(\"Application cache size is {}\", appCacheMaxSize);\n     cachedLogs \u003d Collections.synchronizedMap(\n       new LinkedHashMap\u003cTimelineEntityGroupId, EntityCacheItem\u003e(\n           appCacheMaxSize + 1, 0.75f, true) {\n           @Override\n           protected boolean removeEldestEntry(\n               Map.Entry\u003cTimelineEntityGroupId, EntityCacheItem\u003e eldest) {\n             if (super.size() \u003e appCacheMaxSize) {\n               TimelineEntityGroupId groupId \u003d eldest.getKey();\n               LOG.debug(\"Evicting {} due to space limitations\", groupId);\n               EntityCacheItem cacheItem \u003d eldest.getValue();\n               cacheItem.releaseCache(groupId);\n               if (cacheItem.getAppLogs().isDone()) {\n                 appIdLogMap.remove(groupId.getApplicationId());\n               }\n               return true;\n             }\n             return false;\n           }\n       });\n     cacheIdPlugins \u003d loadPlugIns(conf);\n     // Initialize yarn client for application status\n     yarnClient \u003d createAndInitYarnClient(conf);\n     // if non-null, hook its lifecycle up\n     addIfService(yarnClient);\n     activeRootPath \u003d new Path(conf.get(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR_DEFAULT));\n     doneRootPath \u003d new Path(conf.get(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR_DEFAULT));\n     fs \u003d activeRootPath.getFileSystem(conf);\n+    CallerContext.setCurrent(\n+        new CallerContext.Builder(ATS_V15_SERVER_DFS_CALLER_CTXT).build());\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    summaryStore \u003d createSummaryStore();\n    addService(summaryStore);\n\n    long logRetainSecs \u003d conf.getLong(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT);\n    logRetainMillis \u003d logRetainSecs * 1000;\n    LOG.info(\"Cleaner set to delete logs older than {} seconds\", logRetainSecs);\n    long unknownActiveSecs \u003d conf.getLong(\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS,\n        YarnConfiguration.\n            TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT\n    );\n    unknownActiveMillis \u003d unknownActiveSecs * 1000;\n    LOG.info(\"Unknown apps will be treated as complete after {} seconds\",\n        unknownActiveSecs);\n    appCacheMaxSize \u003d conf.getInt(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT);\n    LOG.info(\"Application cache size is {}\", appCacheMaxSize);\n    cachedLogs \u003d Collections.synchronizedMap(\n      new LinkedHashMap\u003cTimelineEntityGroupId, EntityCacheItem\u003e(\n          appCacheMaxSize + 1, 0.75f, true) {\n          @Override\n          protected boolean removeEldestEntry(\n              Map.Entry\u003cTimelineEntityGroupId, EntityCacheItem\u003e eldest) {\n            if (super.size() \u003e appCacheMaxSize) {\n              TimelineEntityGroupId groupId \u003d eldest.getKey();\n              LOG.debug(\"Evicting {} due to space limitations\", groupId);\n              EntityCacheItem cacheItem \u003d eldest.getValue();\n              cacheItem.releaseCache(groupId);\n              if (cacheItem.getAppLogs().isDone()) {\n                appIdLogMap.remove(groupId.getApplicationId());\n              }\n              return true;\n            }\n            return false;\n          }\n      });\n    cacheIdPlugins \u003d loadPlugIns(conf);\n    // Initialize yarn client for application status\n    yarnClient \u003d createAndInitYarnClient(conf);\n    // if non-null, hook its lifecycle up\n    addIfService(yarnClient);\n    activeRootPath \u003d new Path(conf.get(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR_DEFAULT));\n    doneRootPath \u003d new Path(conf.get(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR_DEFAULT));\n    fs \u003d activeRootPath.getFileSystem(conf);\n    CallerContext.setCurrent(\n        new CallerContext.Builder(ATS_V15_SERVER_DFS_CALLER_CTXT).build());\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
      "extendedDetails": {}
    },
    "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4696. Improving EntityGroupFSTimelineStore on exception handling, test setup, and concurrency. (Steve Loughran via gtcarrera9)\n",
      "commitDate": "10/03/16 10:51 AM",
      "commitName": "d49cfb350454c2dfa2f3eb70f79b6d5030ce7bec",
      "commitAuthor": "Li Lu",
      "commitDateOld": "17/01/16 5:37 PM",
      "commitNameOld": "02f597c5db36ded385413958bdee793ad7eda40e",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 52.72,
      "commitsBetweenForRepo": 371,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,59 @@\n   protected void serviceInit(Configuration conf) throws Exception {\n     summaryStore \u003d createSummaryStore();\n-    summaryStore.init(conf);\n+    addService(summaryStore);\n+\n     long logRetainSecs \u003d conf.getLong(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT);\n     logRetainMillis \u003d logRetainSecs * 1000;\n     LOG.info(\"Cleaner set to delete logs older than {} seconds\", logRetainSecs);\n     long unknownActiveSecs \u003d conf.getLong(\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS,\n         YarnConfiguration.\n             TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT\n     );\n     unknownActiveMillis \u003d unknownActiveSecs * 1000;\n     LOG.info(\"Unknown apps will be treated as complete after {} seconds\",\n         unknownActiveSecs);\n     appCacheMaxSize \u003d conf.getInt(\n         YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE,\n         YarnConfiguration\n             .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT);\n     LOG.info(\"Application cache size is {}\", appCacheMaxSize);\n     cachedLogs \u003d Collections.synchronizedMap(\n       new LinkedHashMap\u003cTimelineEntityGroupId, EntityCacheItem\u003e(\n           appCacheMaxSize + 1, 0.75f, true) {\n           @Override\n           protected boolean removeEldestEntry(\n               Map.Entry\u003cTimelineEntityGroupId, EntityCacheItem\u003e eldest) {\n             if (super.size() \u003e appCacheMaxSize) {\n               TimelineEntityGroupId groupId \u003d eldest.getKey();\n               LOG.debug(\"Evicting {} due to space limitations\", groupId);\n               EntityCacheItem cacheItem \u003d eldest.getValue();\n               cacheItem.releaseCache(groupId);\n               if (cacheItem.getAppLogs().isDone()) {\n                 appIdLogMap.remove(groupId.getApplicationId());\n               }\n               return true;\n             }\n             return false;\n           }\n       });\n     cacheIdPlugins \u003d loadPlugIns(conf);\n     // Initialize yarn client for application status\n-    yarnClient \u003d YarnClient.createYarnClient();\n-    yarnClient.init(conf);\n+    yarnClient \u003d createAndInitYarnClient(conf);\n+    // if non-null, hook its lifecycle up\n+    addIfService(yarnClient);\n+    activeRootPath \u003d new Path(conf.get(\n+        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR,\n+        YarnConfiguration\n+            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR_DEFAULT));\n+    doneRootPath \u003d new Path(conf.get(\n+        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR,\n+        YarnConfiguration\n+            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR_DEFAULT));\n+    fs \u003d activeRootPath.getFileSystem(conf);\n     super.serviceInit(conf);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    summaryStore \u003d createSummaryStore();\n    addService(summaryStore);\n\n    long logRetainSecs \u003d conf.getLong(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT);\n    logRetainMillis \u003d logRetainSecs * 1000;\n    LOG.info(\"Cleaner set to delete logs older than {} seconds\", logRetainSecs);\n    long unknownActiveSecs \u003d conf.getLong(\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS,\n        YarnConfiguration.\n            TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT\n    );\n    unknownActiveMillis \u003d unknownActiveSecs * 1000;\n    LOG.info(\"Unknown apps will be treated as complete after {} seconds\",\n        unknownActiveSecs);\n    appCacheMaxSize \u003d conf.getInt(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT);\n    LOG.info(\"Application cache size is {}\", appCacheMaxSize);\n    cachedLogs \u003d Collections.synchronizedMap(\n      new LinkedHashMap\u003cTimelineEntityGroupId, EntityCacheItem\u003e(\n          appCacheMaxSize + 1, 0.75f, true) {\n          @Override\n          protected boolean removeEldestEntry(\n              Map.Entry\u003cTimelineEntityGroupId, EntityCacheItem\u003e eldest) {\n            if (super.size() \u003e appCacheMaxSize) {\n              TimelineEntityGroupId groupId \u003d eldest.getKey();\n              LOG.debug(\"Evicting {} due to space limitations\", groupId);\n              EntityCacheItem cacheItem \u003d eldest.getValue();\n              cacheItem.releaseCache(groupId);\n              if (cacheItem.getAppLogs().isDone()) {\n                appIdLogMap.remove(groupId.getApplicationId());\n              }\n              return true;\n            }\n            return false;\n          }\n      });\n    cacheIdPlugins \u003d loadPlugIns(conf);\n    // Initialize yarn client for application status\n    yarnClient \u003d createAndInitYarnClient(conf);\n    // if non-null, hook its lifecycle up\n    addIfService(yarnClient);\n    activeRootPath \u003d new Path(conf.get(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR_DEFAULT));\n    doneRootPath \u003d new Path(conf.get(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR_DEFAULT));\n    fs \u003d activeRootPath.getFileSystem(conf);\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java",
      "extendedDetails": {}
    },
    "02f597c5db36ded385413958bdee793ad7eda40e": {
      "type": "Yintroduced",
      "commitMessage": "YARN-4265. Provide new timeline plugin storage to support fine-grained entity caching. Contributed by Li Lu and Jason Lowe\n",
      "commitDate": "17/01/16 5:37 PM",
      "commitName": "02f597c5db36ded385413958bdee793ad7eda40e",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,48 @@\n+  protected void serviceInit(Configuration conf) throws Exception {\n+    summaryStore \u003d createSummaryStore();\n+    summaryStore.init(conf);\n+    long logRetainSecs \u003d conf.getLong(\n+        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS,\n+        YarnConfiguration\n+            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT);\n+    logRetainMillis \u003d logRetainSecs * 1000;\n+    LOG.info(\"Cleaner set to delete logs older than {} seconds\", logRetainSecs);\n+    long unknownActiveSecs \u003d conf.getLong(\n+        YarnConfiguration\n+            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS,\n+        YarnConfiguration.\n+            TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT\n+    );\n+    unknownActiveMillis \u003d unknownActiveSecs * 1000;\n+    LOG.info(\"Unknown apps will be treated as complete after {} seconds\",\n+        unknownActiveSecs);\n+    appCacheMaxSize \u003d conf.getInt(\n+        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE,\n+        YarnConfiguration\n+            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT);\n+    LOG.info(\"Application cache size is {}\", appCacheMaxSize);\n+    cachedLogs \u003d Collections.synchronizedMap(\n+      new LinkedHashMap\u003cTimelineEntityGroupId, EntityCacheItem\u003e(\n+          appCacheMaxSize + 1, 0.75f, true) {\n+          @Override\n+          protected boolean removeEldestEntry(\n+              Map.Entry\u003cTimelineEntityGroupId, EntityCacheItem\u003e eldest) {\n+            if (super.size() \u003e appCacheMaxSize) {\n+              TimelineEntityGroupId groupId \u003d eldest.getKey();\n+              LOG.debug(\"Evicting {} due to space limitations\", groupId);\n+              EntityCacheItem cacheItem \u003d eldest.getValue();\n+              cacheItem.releaseCache(groupId);\n+              if (cacheItem.getAppLogs().isDone()) {\n+                appIdLogMap.remove(groupId.getApplicationId());\n+              }\n+              return true;\n+            }\n+            return false;\n+          }\n+      });\n+    cacheIdPlugins \u003d loadPlugIns(conf);\n+    // Initialize yarn client for application status\n+    yarnClient \u003d YarnClient.createYarnClient();\n+    yarnClient.init(conf);\n+    super.serviceInit(conf);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void serviceInit(Configuration conf) throws Exception {\n    summaryStore \u003d createSummaryStore();\n    summaryStore.init(conf);\n    long logRetainSecs \u003d conf.getLong(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT);\n    logRetainMillis \u003d logRetainSecs * 1000;\n    LOG.info(\"Cleaner set to delete logs older than {} seconds\", logRetainSecs);\n    long unknownActiveSecs \u003d conf.getLong(\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS,\n        YarnConfiguration.\n            TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT\n    );\n    unknownActiveMillis \u003d unknownActiveSecs * 1000;\n    LOG.info(\"Unknown apps will be treated as complete after {} seconds\",\n        unknownActiveSecs);\n    appCacheMaxSize \u003d conf.getInt(\n        YarnConfiguration.TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE,\n        YarnConfiguration\n            .TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT);\n    LOG.info(\"Application cache size is {}\", appCacheMaxSize);\n    cachedLogs \u003d Collections.synchronizedMap(\n      new LinkedHashMap\u003cTimelineEntityGroupId, EntityCacheItem\u003e(\n          appCacheMaxSize + 1, 0.75f, true) {\n          @Override\n          protected boolean removeEldestEntry(\n              Map.Entry\u003cTimelineEntityGroupId, EntityCacheItem\u003e eldest) {\n            if (super.size() \u003e appCacheMaxSize) {\n              TimelineEntityGroupId groupId \u003d eldest.getKey();\n              LOG.debug(\"Evicting {} due to space limitations\", groupId);\n              EntityCacheItem cacheItem \u003d eldest.getValue();\n              cacheItem.releaseCache(groupId);\n              if (cacheItem.getAppLogs().isDone()) {\n                appIdLogMap.remove(groupId.getApplicationId());\n              }\n              return true;\n            }\n            return false;\n          }\n      });\n    cacheIdPlugins \u003d loadPlugIns(conf);\n    // Initialize yarn client for application status\n    yarnClient \u003d YarnClient.createYarnClient();\n    yarnClient.init(conf);\n    super.serviceInit(conf);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timeline-pluginstorage/src/main/java/org/apache/hadoop/yarn/server/timeline/EntityGroupFSTimelineStore.java"
    }
  }
}