{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ResourceLocalizationService.java",
  "functionName": "processHeartbeat",
  "functionId": "processHeartbeat___remoteResourceStatuses-List__LocalResourceStatus__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
  "functionStartLine": 1139,
  "functionEndLine": 1229,
  "numCommitsSeen": 88,
  "timeTaken": 5021,
  "changeHistory": [
    "b939ae98e6fc318cdfc3ffa232e6e0c258c38762",
    "6ff0453edeeb0ed7bc9a7d3fb6dfa7048104238b",
    "585ebd873a55bedd2a364d256837f08ada8ba032",
    "9262797e86453fc04b7ca3710b73b21fcdf9e6b4",
    "72fe54684198b7df5c5fb2114616dff6d17a4402",
    "7ffb9943b8838a3bb56684e0722db40d800743a2",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "38102420621308f5ba91cdeb6a18a63aa5acf640",
    "47279c3228185548ed09c36579b420225e4894f5"
  ],
  "changeHistoryShort": {
    "b939ae98e6fc318cdfc3ffa232e6e0c258c38762": "Ybodychange",
    "6ff0453edeeb0ed7bc9a7d3fb6dfa7048104238b": "Ybodychange",
    "585ebd873a55bedd2a364d256837f08ada8ba032": "Ybodychange",
    "9262797e86453fc04b7ca3710b73b21fcdf9e6b4": "Ybodychange",
    "72fe54684198b7df5c5fb2114616dff6d17a4402": "Ybodychange",
    "7ffb9943b8838a3bb56684e0722db40d800743a2": "Ybodychange",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "38102420621308f5ba91cdeb6a18a63aa5acf640": "Ybodychange",
    "47279c3228185548ed09c36579b420225e4894f5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b939ae98e6fc318cdfc3ffa232e6e0c258c38762": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8174. Add containerId to ResourceLocalizationService fetch failure log statement. Contributed by Prabhu Joseph.\n",
      "commitDate": "01/09/19 10:15 PM",
      "commitName": "b939ae98e6fc318cdfc3ffa232e6e0c258c38762",
      "commitAuthor": "Abhishek Modi",
      "commitDateOld": "09/08/19 11:12 AM",
      "commitNameOld": "6ff0453edeeb0ed7bc9a7d3fb6dfa7048104238b",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 23.46,
      "commitsBetweenForRepo": 234,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,91 @@\n     LocalizerHeartbeatResponse processHeartbeat(\n         List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n       LocalizerHeartbeatResponse response \u003d\n         recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n       String user \u003d context.getUser();\n       ApplicationId applicationId \u003d\n           context.getContainerId().getApplicationAttemptId().getApplicationId();\n \n       boolean fetchFailed \u003d false;\n       // Update resource statuses.\n       for (LocalResourceStatus stat : remoteResourceStatuses) {\n         LocalResource rsrc \u003d stat.getResource();\n         LocalResourceRequest req \u003d null;\n         try {\n           req \u003d new LocalResourceRequest(rsrc);\n         } catch (URISyntaxException e) {\n           LOG.error(\n               \"Got exception in parsing URL of LocalResource:\"\n                   + rsrc.getResource(), e);\n           continue;\n         }\n         LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n         if (assoc \u003d\u003d null) {\n           // internal error\n           LOG.error(\"Unknown resource reported: \" + req);\n           continue;\n         }\n         LocalResourcesTracker tracker \u003d\n             getLocalResourcesTracker(req.getVisibility(), user, applicationId);\n         if (tracker \u003d\u003d null) {\n           // This is likely due to a race between heartbeat and\n           // app cleaning up.\n           continue;\n         }\n         switch (stat.getStatus()) {\n           case FETCH_SUCCESS:\n             // notify resource\n             try {\n               tracker.handle(new ResourceLocalizedEvent(req,\n                   stat.getLocalPath().toPath(), stat.getLocalSize()));\n             } catch (URISyntaxException e) { }\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           case FETCH_PENDING:\n             break;\n           case FETCH_FAILURE:\n             final String diagnostics \u003d stat.getException().toString();\n-            LOG.warn(req + \" failed: \" + diagnostics);\n+            LOG.warn(\"{} failed for {} : {}\", req, localizerId, diagnostics);\n             fetchFailed \u003d true;\n             tracker.handle(new ResourceFailedLocalizationEvent(req,\n                 diagnostics));\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           default:\n             LOG.info(\"Unknown status: \" + stat.getStatus());\n             fetchFailed \u003d true;\n             tracker.handle(new ResourceFailedLocalizationEvent(req,\n                 stat.getException().getMessage()));\n             break;\n         }\n       }\n       if (fetchFailed || killContainerLocalizer.get()) {\n         response.setLocalizerAction(LocalizerAction.DIE);\n         return response;\n       }\n \n       // Give the localizer resources for remote-fetching.\n       List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n           new ArrayList\u003cResourceLocalizationSpec\u003e();\n \n       /*\n        * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n        * at the same time. We need to think whether we should support this.\n        */\n       ResourceLocalizationSpec next \u003d findNextResource(user, applicationId);\n       if (next !\u003d null) {\n         rsrcs.add(next);\n       }\n \n       response.setLocalizerAction(LocalizerAction.LIVE);\n       response.setResourceSpecs(rsrcs);\n       return response;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    LocalizerHeartbeatResponse processHeartbeat(\n        List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n      LocalizerHeartbeatResponse response \u003d\n        recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n      String user \u003d context.getUser();\n      ApplicationId applicationId \u003d\n          context.getContainerId().getApplicationAttemptId().getApplicationId();\n\n      boolean fetchFailed \u003d false;\n      // Update resource statuses.\n      for (LocalResourceStatus stat : remoteResourceStatuses) {\n        LocalResource rsrc \u003d stat.getResource();\n        LocalResourceRequest req \u003d null;\n        try {\n          req \u003d new LocalResourceRequest(rsrc);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + rsrc.getResource(), e);\n          continue;\n        }\n        LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n        if (assoc \u003d\u003d null) {\n          // internal error\n          LOG.error(\"Unknown resource reported: \" + req);\n          continue;\n        }\n        LocalResourcesTracker tracker \u003d\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId);\n        if (tracker \u003d\u003d null) {\n          // This is likely due to a race between heartbeat and\n          // app cleaning up.\n          continue;\n        }\n        switch (stat.getStatus()) {\n          case FETCH_SUCCESS:\n            // notify resource\n            try {\n              tracker.handle(new ResourceLocalizedEvent(req,\n                  stat.getLocalPath().toPath(), stat.getLocalSize()));\n            } catch (URISyntaxException e) { }\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          case FETCH_PENDING:\n            break;\n          case FETCH_FAILURE:\n            final String diagnostics \u003d stat.getException().toString();\n            LOG.warn(\"{} failed for {} : {}\", req, localizerId, diagnostics);\n            fetchFailed \u003d true;\n            tracker.handle(new ResourceFailedLocalizationEvent(req,\n                diagnostics));\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          default:\n            LOG.info(\"Unknown status: \" + stat.getStatus());\n            fetchFailed \u003d true;\n            tracker.handle(new ResourceFailedLocalizationEvent(req,\n                stat.getException().getMessage()));\n            break;\n        }\n      }\n      if (fetchFailed || killContainerLocalizer.get()) {\n        response.setLocalizerAction(LocalizerAction.DIE);\n        return response;\n      }\n\n      // Give the localizer resources for remote-fetching.\n      List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n          new ArrayList\u003cResourceLocalizationSpec\u003e();\n\n      /*\n       * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n       * at the same time. We need to think whether we should support this.\n       */\n      ResourceLocalizationSpec next \u003d findNextResource(user, applicationId);\n      if (next !\u003d null) {\n        rsrcs.add(next);\n      }\n\n      response.setLocalizerAction(LocalizerAction.LIVE);\n      response.setResourceSpecs(rsrcs);\n      return response;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "6ff0453edeeb0ed7bc9a7d3fb6dfa7048104238b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9527.  Prevent rogue Localizer Runner from downloading same file repeatly.\n            Contributed by Jim Brennan\n",
      "commitDate": "09/08/19 11:12 AM",
      "commitName": "6ff0453edeeb0ed7bc9a7d3fb6dfa7048104238b",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 146.79,
      "commitsBetweenForRepo": 1054,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,111 +1,91 @@\n     LocalizerHeartbeatResponse processHeartbeat(\n         List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n       LocalizerHeartbeatResponse response \u003d\n         recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n       String user \u003d context.getUser();\n       ApplicationId applicationId \u003d\n           context.getContainerId().getApplicationAttemptId().getApplicationId();\n \n       boolean fetchFailed \u003d false;\n       // Update resource statuses.\n       for (LocalResourceStatus stat : remoteResourceStatuses) {\n         LocalResource rsrc \u003d stat.getResource();\n         LocalResourceRequest req \u003d null;\n         try {\n           req \u003d new LocalResourceRequest(rsrc);\n         } catch (URISyntaxException e) {\n           LOG.error(\n               \"Got exception in parsing URL of LocalResource:\"\n                   + rsrc.getResource(), e);\n           continue;\n         }\n         LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n         if (assoc \u003d\u003d null) {\n           // internal error\n           LOG.error(\"Unknown resource reported: \" + req);\n           continue;\n         }\n         LocalResourcesTracker tracker \u003d\n             getLocalResourcesTracker(req.getVisibility(), user, applicationId);\n         if (tracker \u003d\u003d null) {\n           // This is likely due to a race between heartbeat and\n           // app cleaning up.\n           continue;\n         }\n         switch (stat.getStatus()) {\n           case FETCH_SUCCESS:\n             // notify resource\n             try {\n               tracker.handle(new ResourceLocalizedEvent(req,\n                   stat.getLocalPath().toPath(), stat.getLocalSize()));\n             } catch (URISyntaxException e) { }\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           case FETCH_PENDING:\n             break;\n           case FETCH_FAILURE:\n             final String diagnostics \u003d stat.getException().toString();\n             LOG.warn(req + \" failed: \" + diagnostics);\n             fetchFailed \u003d true;\n             tracker.handle(new ResourceFailedLocalizationEvent(req,\n                 diagnostics));\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           default:\n             LOG.info(\"Unknown status: \" + stat.getStatus());\n             fetchFailed \u003d true;\n             tracker.handle(new ResourceFailedLocalizationEvent(req,\n                 stat.getException().getMessage()));\n             break;\n         }\n       }\n       if (fetchFailed || killContainerLocalizer.get()) {\n         response.setLocalizerAction(LocalizerAction.DIE);\n         return response;\n       }\n \n       // Give the localizer resources for remote-fetching.\n       List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n           new ArrayList\u003cResourceLocalizationSpec\u003e();\n \n       /*\n        * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n        * at the same time. We need to think whether we should support this.\n        */\n-      LocalResource next \u003d findNextResource();\n+      ResourceLocalizationSpec next \u003d findNextResource(user, applicationId);\n       if (next !\u003d null) {\n-        try {\n-          LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n-              next.getVisibility(), user, applicationId);\n-          if (tracker !\u003d null) {\n-            Path localPath \u003d getPathForLocalization(next, tracker);\n-            if (localPath !\u003d null) {\n-              rsrcs.add(NodeManagerBuilderUtils.newResourceLocalizationSpec(\n-                  next, localPath));\n-            }\n-          }\n-        } catch (IOException e) {\n-          LOG.error(\"local path for PRIVATE localization could not be \" +\n-            \"found. Disks might have failed.\", e);\n-        } catch (IllegalArgumentException e) {\n-          LOG.error(\"Incorrect path for PRIVATE localization.\"\n-              + next.getResource().getFile(), e);\n-        } catch (URISyntaxException e) {\n-          LOG.error(\n-              \"Got exception in parsing URL of LocalResource:\"\n-                  + next.getResource(), e);\n-        }\n+        rsrcs.add(next);\n       }\n \n       response.setLocalizerAction(LocalizerAction.LIVE);\n       response.setResourceSpecs(rsrcs);\n       return response;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    LocalizerHeartbeatResponse processHeartbeat(\n        List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n      LocalizerHeartbeatResponse response \u003d\n        recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n      String user \u003d context.getUser();\n      ApplicationId applicationId \u003d\n          context.getContainerId().getApplicationAttemptId().getApplicationId();\n\n      boolean fetchFailed \u003d false;\n      // Update resource statuses.\n      for (LocalResourceStatus stat : remoteResourceStatuses) {\n        LocalResource rsrc \u003d stat.getResource();\n        LocalResourceRequest req \u003d null;\n        try {\n          req \u003d new LocalResourceRequest(rsrc);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + rsrc.getResource(), e);\n          continue;\n        }\n        LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n        if (assoc \u003d\u003d null) {\n          // internal error\n          LOG.error(\"Unknown resource reported: \" + req);\n          continue;\n        }\n        LocalResourcesTracker tracker \u003d\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId);\n        if (tracker \u003d\u003d null) {\n          // This is likely due to a race between heartbeat and\n          // app cleaning up.\n          continue;\n        }\n        switch (stat.getStatus()) {\n          case FETCH_SUCCESS:\n            // notify resource\n            try {\n              tracker.handle(new ResourceLocalizedEvent(req,\n                  stat.getLocalPath().toPath(), stat.getLocalSize()));\n            } catch (URISyntaxException e) { }\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          case FETCH_PENDING:\n            break;\n          case FETCH_FAILURE:\n            final String diagnostics \u003d stat.getException().toString();\n            LOG.warn(req + \" failed: \" + diagnostics);\n            fetchFailed \u003d true;\n            tracker.handle(new ResourceFailedLocalizationEvent(req,\n                diagnostics));\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          default:\n            LOG.info(\"Unknown status: \" + stat.getStatus());\n            fetchFailed \u003d true;\n            tracker.handle(new ResourceFailedLocalizationEvent(req,\n                stat.getException().getMessage()));\n            break;\n        }\n      }\n      if (fetchFailed || killContainerLocalizer.get()) {\n        response.setLocalizerAction(LocalizerAction.DIE);\n        return response;\n      }\n\n      // Give the localizer resources for remote-fetching.\n      List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n          new ArrayList\u003cResourceLocalizationSpec\u003e();\n\n      /*\n       * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n       * at the same time. We need to think whether we should support this.\n       */\n      ResourceLocalizationSpec next \u003d findNextResource(user, applicationId);\n      if (next !\u003d null) {\n        rsrcs.add(next);\n      }\n\n      response.setLocalizerAction(LocalizerAction.LIVE);\n      response.setResourceSpecs(rsrcs);\n      return response;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "585ebd873a55bedd2a364d256837f08ada8ba032": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8649. NPE in localizer hearbeat processing if a container is killed while localizing. Contributed by lujie\n",
      "commitDate": "23/08/18 7:29 AM",
      "commitName": "585ebd873a55bedd2a364d256837f08ada8ba032",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "20/08/18 8:14 AM",
      "commitNameOld": "65e7469712be6cf393e29ef73cc94727eec81227",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 2.97,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,110 +1,111 @@\n     LocalizerHeartbeatResponse processHeartbeat(\n         List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n       LocalizerHeartbeatResponse response \u003d\n         recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n       String user \u003d context.getUser();\n       ApplicationId applicationId \u003d\n           context.getContainerId().getApplicationAttemptId().getApplicationId();\n \n       boolean fetchFailed \u003d false;\n       // Update resource statuses.\n       for (LocalResourceStatus stat : remoteResourceStatuses) {\n         LocalResource rsrc \u003d stat.getResource();\n         LocalResourceRequest req \u003d null;\n         try {\n           req \u003d new LocalResourceRequest(rsrc);\n         } catch (URISyntaxException e) {\n           LOG.error(\n               \"Got exception in parsing URL of LocalResource:\"\n                   + rsrc.getResource(), e);\n           continue;\n         }\n         LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n         if (assoc \u003d\u003d null) {\n           // internal error\n           LOG.error(\"Unknown resource reported: \" + req);\n           continue;\n         }\n         LocalResourcesTracker tracker \u003d\n             getLocalResourcesTracker(req.getVisibility(), user, applicationId);\n         if (tracker \u003d\u003d null) {\n           // This is likely due to a race between heartbeat and\n           // app cleaning up.\n           continue;\n         }\n         switch (stat.getStatus()) {\n           case FETCH_SUCCESS:\n             // notify resource\n             try {\n               tracker.handle(new ResourceLocalizedEvent(req,\n                   stat.getLocalPath().toPath(), stat.getLocalSize()));\n             } catch (URISyntaxException e) { }\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           case FETCH_PENDING:\n             break;\n           case FETCH_FAILURE:\n             final String diagnostics \u003d stat.getException().toString();\n             LOG.warn(req + \" failed: \" + diagnostics);\n             fetchFailed \u003d true;\n             tracker.handle(new ResourceFailedLocalizationEvent(req,\n                 diagnostics));\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           default:\n             LOG.info(\"Unknown status: \" + stat.getStatus());\n             fetchFailed \u003d true;\n             tracker.handle(new ResourceFailedLocalizationEvent(req,\n                 stat.getException().getMessage()));\n             break;\n         }\n       }\n       if (fetchFailed || killContainerLocalizer.get()) {\n         response.setLocalizerAction(LocalizerAction.DIE);\n         return response;\n       }\n \n       // Give the localizer resources for remote-fetching.\n       List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n           new ArrayList\u003cResourceLocalizationSpec\u003e();\n \n       /*\n        * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n        * at the same time. We need to think whether we should support this.\n        */\n       LocalResource next \u003d findNextResource();\n       if (next !\u003d null) {\n         try {\n           LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n               next.getVisibility(), user, applicationId);\n           if (tracker !\u003d null) {\n-            ResourceLocalizationSpec resource \u003d\n-                NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n-                getPathForLocalization(next, tracker));\n-            rsrcs.add(resource);\n+            Path localPath \u003d getPathForLocalization(next, tracker);\n+            if (localPath !\u003d null) {\n+              rsrcs.add(NodeManagerBuilderUtils.newResourceLocalizationSpec(\n+                  next, localPath));\n+            }\n           }\n         } catch (IOException e) {\n           LOG.error(\"local path for PRIVATE localization could not be \" +\n             \"found. Disks might have failed.\", e);\n         } catch (IllegalArgumentException e) {\n           LOG.error(\"Incorrect path for PRIVATE localization.\"\n               + next.getResource().getFile(), e);\n         } catch (URISyntaxException e) {\n           LOG.error(\n               \"Got exception in parsing URL of LocalResource:\"\n                   + next.getResource(), e);\n         }\n       }\n \n       response.setLocalizerAction(LocalizerAction.LIVE);\n       response.setResourceSpecs(rsrcs);\n       return response;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    LocalizerHeartbeatResponse processHeartbeat(\n        List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n      LocalizerHeartbeatResponse response \u003d\n        recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n      String user \u003d context.getUser();\n      ApplicationId applicationId \u003d\n          context.getContainerId().getApplicationAttemptId().getApplicationId();\n\n      boolean fetchFailed \u003d false;\n      // Update resource statuses.\n      for (LocalResourceStatus stat : remoteResourceStatuses) {\n        LocalResource rsrc \u003d stat.getResource();\n        LocalResourceRequest req \u003d null;\n        try {\n          req \u003d new LocalResourceRequest(rsrc);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + rsrc.getResource(), e);\n          continue;\n        }\n        LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n        if (assoc \u003d\u003d null) {\n          // internal error\n          LOG.error(\"Unknown resource reported: \" + req);\n          continue;\n        }\n        LocalResourcesTracker tracker \u003d\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId);\n        if (tracker \u003d\u003d null) {\n          // This is likely due to a race between heartbeat and\n          // app cleaning up.\n          continue;\n        }\n        switch (stat.getStatus()) {\n          case FETCH_SUCCESS:\n            // notify resource\n            try {\n              tracker.handle(new ResourceLocalizedEvent(req,\n                  stat.getLocalPath().toPath(), stat.getLocalSize()));\n            } catch (URISyntaxException e) { }\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          case FETCH_PENDING:\n            break;\n          case FETCH_FAILURE:\n            final String diagnostics \u003d stat.getException().toString();\n            LOG.warn(req + \" failed: \" + diagnostics);\n            fetchFailed \u003d true;\n            tracker.handle(new ResourceFailedLocalizationEvent(req,\n                diagnostics));\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          default:\n            LOG.info(\"Unknown status: \" + stat.getStatus());\n            fetchFailed \u003d true;\n            tracker.handle(new ResourceFailedLocalizationEvent(req,\n                stat.getException().getMessage()));\n            break;\n        }\n      }\n      if (fetchFailed || killContainerLocalizer.get()) {\n        response.setLocalizerAction(LocalizerAction.DIE);\n        return response;\n      }\n\n      // Give the localizer resources for remote-fetching.\n      List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n          new ArrayList\u003cResourceLocalizationSpec\u003e();\n\n      /*\n       * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n       * at the same time. We need to think whether we should support this.\n       */\n      LocalResource next \u003d findNextResource();\n      if (next !\u003d null) {\n        try {\n          LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n              next.getVisibility(), user, applicationId);\n          if (tracker !\u003d null) {\n            Path localPath \u003d getPathForLocalization(next, tracker);\n            if (localPath !\u003d null) {\n              rsrcs.add(NodeManagerBuilderUtils.newResourceLocalizationSpec(\n                  next, localPath));\n            }\n          }\n        } catch (IOException e) {\n          LOG.error(\"local path for PRIVATE localization could not be \" +\n            \"found. Disks might have failed.\", e);\n        } catch (IllegalArgumentException e) {\n          LOG.error(\"Incorrect path for PRIVATE localization.\"\n              + next.getResource().getFile(), e);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + next.getResource(), e);\n        }\n      }\n\n      response.setLocalizerAction(LocalizerAction.LIVE);\n      response.setResourceSpecs(rsrcs);\n      return response;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "9262797e86453fc04b7ca3710b73b21fcdf9e6b4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5257. Fix unreleased resources and null dereferences (yufeigu via rkanter)\n",
      "commitDate": "27/12/16 2:14 PM",
      "commitName": "9262797e86453fc04b7ca3710b73b21fcdf9e6b4",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "07/12/16 3:07 PM",
      "commitNameOld": "72fe54684198b7df5c5fb2114616dff6d17a4402",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 19.96,
      "commitsBetweenForRepo": 90,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,110 @@\n     LocalizerHeartbeatResponse processHeartbeat(\n         List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n       LocalizerHeartbeatResponse response \u003d\n         recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n       String user \u003d context.getUser();\n       ApplicationId applicationId \u003d\n           context.getContainerId().getApplicationAttemptId().getApplicationId();\n \n       boolean fetchFailed \u003d false;\n       // Update resource statuses.\n       for (LocalResourceStatus stat : remoteResourceStatuses) {\n         LocalResource rsrc \u003d stat.getResource();\n         LocalResourceRequest req \u003d null;\n         try {\n           req \u003d new LocalResourceRequest(rsrc);\n         } catch (URISyntaxException e) {\n           LOG.error(\n               \"Got exception in parsing URL of LocalResource:\"\n                   + rsrc.getResource(), e);\n+          continue;\n         }\n         LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n         if (assoc \u003d\u003d null) {\n           // internal error\n           LOG.error(\"Unknown resource reported: \" + req);\n           continue;\n         }\n         LocalResourcesTracker tracker \u003d\n             getLocalResourcesTracker(req.getVisibility(), user, applicationId);\n         if (tracker \u003d\u003d null) {\n           // This is likely due to a race between heartbeat and\n           // app cleaning up.\n           continue;\n         }\n         switch (stat.getStatus()) {\n           case FETCH_SUCCESS:\n             // notify resource\n             try {\n               tracker.handle(new ResourceLocalizedEvent(req,\n                   stat.getLocalPath().toPath(), stat.getLocalSize()));\n             } catch (URISyntaxException e) { }\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           case FETCH_PENDING:\n             break;\n           case FETCH_FAILURE:\n             final String diagnostics \u003d stat.getException().toString();\n             LOG.warn(req + \" failed: \" + diagnostics);\n             fetchFailed \u003d true;\n             tracker.handle(new ResourceFailedLocalizationEvent(req,\n                 diagnostics));\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           default:\n             LOG.info(\"Unknown status: \" + stat.getStatus());\n             fetchFailed \u003d true;\n             tracker.handle(new ResourceFailedLocalizationEvent(req,\n                 stat.getException().getMessage()));\n             break;\n         }\n       }\n       if (fetchFailed || killContainerLocalizer.get()) {\n         response.setLocalizerAction(LocalizerAction.DIE);\n         return response;\n       }\n \n       // Give the localizer resources for remote-fetching.\n       List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n           new ArrayList\u003cResourceLocalizationSpec\u003e();\n \n       /*\n        * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n        * at the same time. We need to think whether we should support this.\n        */\n       LocalResource next \u003d findNextResource();\n       if (next !\u003d null) {\n         try {\n           LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n               next.getVisibility(), user, applicationId);\n           if (tracker !\u003d null) {\n             ResourceLocalizationSpec resource \u003d\n                 NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n                 getPathForLocalization(next, tracker));\n             rsrcs.add(resource);\n           }\n         } catch (IOException e) {\n           LOG.error(\"local path for PRIVATE localization could not be \" +\n             \"found. Disks might have failed.\", e);\n         } catch (IllegalArgumentException e) {\n           LOG.error(\"Incorrect path for PRIVATE localization.\"\n               + next.getResource().getFile(), e);\n         } catch (URISyntaxException e) {\n           LOG.error(\n               \"Got exception in parsing URL of LocalResource:\"\n                   + next.getResource(), e);\n         }\n       }\n \n       response.setLocalizerAction(LocalizerAction.LIVE);\n       response.setResourceSpecs(rsrcs);\n       return response;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    LocalizerHeartbeatResponse processHeartbeat(\n        List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n      LocalizerHeartbeatResponse response \u003d\n        recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n      String user \u003d context.getUser();\n      ApplicationId applicationId \u003d\n          context.getContainerId().getApplicationAttemptId().getApplicationId();\n\n      boolean fetchFailed \u003d false;\n      // Update resource statuses.\n      for (LocalResourceStatus stat : remoteResourceStatuses) {\n        LocalResource rsrc \u003d stat.getResource();\n        LocalResourceRequest req \u003d null;\n        try {\n          req \u003d new LocalResourceRequest(rsrc);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + rsrc.getResource(), e);\n          continue;\n        }\n        LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n        if (assoc \u003d\u003d null) {\n          // internal error\n          LOG.error(\"Unknown resource reported: \" + req);\n          continue;\n        }\n        LocalResourcesTracker tracker \u003d\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId);\n        if (tracker \u003d\u003d null) {\n          // This is likely due to a race between heartbeat and\n          // app cleaning up.\n          continue;\n        }\n        switch (stat.getStatus()) {\n          case FETCH_SUCCESS:\n            // notify resource\n            try {\n              tracker.handle(new ResourceLocalizedEvent(req,\n                  stat.getLocalPath().toPath(), stat.getLocalSize()));\n            } catch (URISyntaxException e) { }\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          case FETCH_PENDING:\n            break;\n          case FETCH_FAILURE:\n            final String diagnostics \u003d stat.getException().toString();\n            LOG.warn(req + \" failed: \" + diagnostics);\n            fetchFailed \u003d true;\n            tracker.handle(new ResourceFailedLocalizationEvent(req,\n                diagnostics));\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          default:\n            LOG.info(\"Unknown status: \" + stat.getStatus());\n            fetchFailed \u003d true;\n            tracker.handle(new ResourceFailedLocalizationEvent(req,\n                stat.getException().getMessage()));\n            break;\n        }\n      }\n      if (fetchFailed || killContainerLocalizer.get()) {\n        response.setLocalizerAction(LocalizerAction.DIE);\n        return response;\n      }\n\n      // Give the localizer resources for remote-fetching.\n      List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n          new ArrayList\u003cResourceLocalizationSpec\u003e();\n\n      /*\n       * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n       * at the same time. We need to think whether we should support this.\n       */\n      LocalResource next \u003d findNextResource();\n      if (next !\u003d null) {\n        try {\n          LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n              next.getVisibility(), user, applicationId);\n          if (tracker !\u003d null) {\n            ResourceLocalizationSpec resource \u003d\n                NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n                getPathForLocalization(next, tracker));\n            rsrcs.add(resource);\n          }\n        } catch (IOException e) {\n          LOG.error(\"local path for PRIVATE localization could not be \" +\n            \"found. Disks might have failed.\", e);\n        } catch (IllegalArgumentException e) {\n          LOG.error(\"Incorrect path for PRIVATE localization.\"\n              + next.getResource().getFile(), e);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + next.getResource(), e);\n        }\n      }\n\n      response.setLocalizerAction(LocalizerAction.LIVE);\n      response.setResourceSpecs(rsrcs);\n      return response;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "72fe54684198b7df5c5fb2114616dff6d17a4402": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5963. Spelling errors in logging and exceptions for node manager, client, web-proxy, common, and app history code (gsohn via rkanter)\n",
      "commitDate": "07/12/16 3:07 PM",
      "commitName": "72fe54684198b7df5c5fb2114616dff6d17a4402",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "15/11/16 2:11 AM",
      "commitNameOld": "7ffb9943b8838a3bb56684e0722db40d800743a2",
      "commitAuthorOld": "Naganarasimha",
      "daysBetweenCommits": 22.54,
      "commitsBetweenForRepo": 141,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,109 @@\n     LocalizerHeartbeatResponse processHeartbeat(\n         List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n       LocalizerHeartbeatResponse response \u003d\n         recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n       String user \u003d context.getUser();\n       ApplicationId applicationId \u003d\n           context.getContainerId().getApplicationAttemptId().getApplicationId();\n \n       boolean fetchFailed \u003d false;\n       // Update resource statuses.\n       for (LocalResourceStatus stat : remoteResourceStatuses) {\n         LocalResource rsrc \u003d stat.getResource();\n         LocalResourceRequest req \u003d null;\n         try {\n           req \u003d new LocalResourceRequest(rsrc);\n         } catch (URISyntaxException e) {\n           LOG.error(\n               \"Got exception in parsing URL of LocalResource:\"\n                   + rsrc.getResource(), e);\n         }\n         LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n         if (assoc \u003d\u003d null) {\n           // internal error\n           LOG.error(\"Unknown resource reported: \" + req);\n           continue;\n         }\n         LocalResourcesTracker tracker \u003d\n             getLocalResourcesTracker(req.getVisibility(), user, applicationId);\n         if (tracker \u003d\u003d null) {\n           // This is likely due to a race between heartbeat and\n           // app cleaning up.\n           continue;\n         }\n         switch (stat.getStatus()) {\n           case FETCH_SUCCESS:\n             // notify resource\n             try {\n               tracker.handle(new ResourceLocalizedEvent(req,\n                   stat.getLocalPath().toPath(), stat.getLocalSize()));\n             } catch (URISyntaxException e) { }\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           case FETCH_PENDING:\n             break;\n           case FETCH_FAILURE:\n             final String diagnostics \u003d stat.getException().toString();\n             LOG.warn(req + \" failed: \" + diagnostics);\n             fetchFailed \u003d true;\n             tracker.handle(new ResourceFailedLocalizationEvent(req,\n                 diagnostics));\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           default:\n             LOG.info(\"Unknown status: \" + stat.getStatus());\n             fetchFailed \u003d true;\n             tracker.handle(new ResourceFailedLocalizationEvent(req,\n                 stat.getException().getMessage()));\n             break;\n         }\n       }\n       if (fetchFailed || killContainerLocalizer.get()) {\n         response.setLocalizerAction(LocalizerAction.DIE);\n         return response;\n       }\n \n       // Give the localizer resources for remote-fetching.\n       List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n           new ArrayList\u003cResourceLocalizationSpec\u003e();\n \n       /*\n        * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n        * at the same time. We need to think whether we should support this.\n        */\n       LocalResource next \u003d findNextResource();\n       if (next !\u003d null) {\n         try {\n           LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n               next.getVisibility(), user, applicationId);\n           if (tracker !\u003d null) {\n             ResourceLocalizationSpec resource \u003d\n                 NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n                 getPathForLocalization(next, tracker));\n             rsrcs.add(resource);\n           }\n         } catch (IOException e) {\n           LOG.error(\"local path for PRIVATE localization could not be \" +\n             \"found. Disks might have failed.\", e);\n         } catch (IllegalArgumentException e) {\n-          LOG.error(\"Inorrect path for PRIVATE localization.\"\n+          LOG.error(\"Incorrect path for PRIVATE localization.\"\n               + next.getResource().getFile(), e);\n         } catch (URISyntaxException e) {\n           LOG.error(\n               \"Got exception in parsing URL of LocalResource:\"\n                   + next.getResource(), e);\n         }\n       }\n \n       response.setLocalizerAction(LocalizerAction.LIVE);\n       response.setResourceSpecs(rsrcs);\n       return response;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    LocalizerHeartbeatResponse processHeartbeat(\n        List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n      LocalizerHeartbeatResponse response \u003d\n        recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n      String user \u003d context.getUser();\n      ApplicationId applicationId \u003d\n          context.getContainerId().getApplicationAttemptId().getApplicationId();\n\n      boolean fetchFailed \u003d false;\n      // Update resource statuses.\n      for (LocalResourceStatus stat : remoteResourceStatuses) {\n        LocalResource rsrc \u003d stat.getResource();\n        LocalResourceRequest req \u003d null;\n        try {\n          req \u003d new LocalResourceRequest(rsrc);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + rsrc.getResource(), e);\n        }\n        LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n        if (assoc \u003d\u003d null) {\n          // internal error\n          LOG.error(\"Unknown resource reported: \" + req);\n          continue;\n        }\n        LocalResourcesTracker tracker \u003d\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId);\n        if (tracker \u003d\u003d null) {\n          // This is likely due to a race between heartbeat and\n          // app cleaning up.\n          continue;\n        }\n        switch (stat.getStatus()) {\n          case FETCH_SUCCESS:\n            // notify resource\n            try {\n              tracker.handle(new ResourceLocalizedEvent(req,\n                  stat.getLocalPath().toPath(), stat.getLocalSize()));\n            } catch (URISyntaxException e) { }\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          case FETCH_PENDING:\n            break;\n          case FETCH_FAILURE:\n            final String diagnostics \u003d stat.getException().toString();\n            LOG.warn(req + \" failed: \" + diagnostics);\n            fetchFailed \u003d true;\n            tracker.handle(new ResourceFailedLocalizationEvent(req,\n                diagnostics));\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          default:\n            LOG.info(\"Unknown status: \" + stat.getStatus());\n            fetchFailed \u003d true;\n            tracker.handle(new ResourceFailedLocalizationEvent(req,\n                stat.getException().getMessage()));\n            break;\n        }\n      }\n      if (fetchFailed || killContainerLocalizer.get()) {\n        response.setLocalizerAction(LocalizerAction.DIE);\n        return response;\n      }\n\n      // Give the localizer resources for remote-fetching.\n      List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n          new ArrayList\u003cResourceLocalizationSpec\u003e();\n\n      /*\n       * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n       * at the same time. We need to think whether we should support this.\n       */\n      LocalResource next \u003d findNextResource();\n      if (next !\u003d null) {\n        try {\n          LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n              next.getVisibility(), user, applicationId);\n          if (tracker !\u003d null) {\n            ResourceLocalizationSpec resource \u003d\n                NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n                getPathForLocalization(next, tracker));\n            rsrcs.add(resource);\n          }\n        } catch (IOException e) {\n          LOG.error(\"local path for PRIVATE localization could not be \" +\n            \"found. Disks might have failed.\", e);\n        } catch (IllegalArgumentException e) {\n          LOG.error(\"Incorrect path for PRIVATE localization.\"\n              + next.getResource().getFile(), e);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + next.getResource(), e);\n        }\n      }\n\n      response.setLocalizerAction(LocalizerAction.LIVE);\n      response.setResourceSpecs(rsrcs);\n      return response;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "7ffb9943b8838a3bb56684e0722db40d800743a2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4355. NPE while processing localizer heartbeat. Contributed by Varun Saxena \u0026 Jonathan Hung.\n",
      "commitDate": "15/11/16 2:11 AM",
      "commitName": "7ffb9943b8838a3bb56684e0722db40d800743a2",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "28/10/16 8:58 AM",
      "commitNameOld": "1b79c417dca17bcd2e031864bc6ca07254c61b47",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 17.76,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,109 @@\n     LocalizerHeartbeatResponse processHeartbeat(\n         List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n       LocalizerHeartbeatResponse response \u003d\n         recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n-\n       String user \u003d context.getUser();\n       ApplicationId applicationId \u003d\n           context.getContainerId().getApplicationAttemptId().getApplicationId();\n \n       boolean fetchFailed \u003d false;\n       // Update resource statuses.\n       for (LocalResourceStatus stat : remoteResourceStatuses) {\n         LocalResource rsrc \u003d stat.getResource();\n         LocalResourceRequest req \u003d null;\n         try {\n           req \u003d new LocalResourceRequest(rsrc);\n         } catch (URISyntaxException e) {\n           LOG.error(\n               \"Got exception in parsing URL of LocalResource:\"\n                   + rsrc.getResource(), e);\n         }\n         LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n         if (assoc \u003d\u003d null) {\n           // internal error\n           LOG.error(\"Unknown resource reported: \" + req);\n           continue;\n         }\n+        LocalResourcesTracker tracker \u003d\n+            getLocalResourcesTracker(req.getVisibility(), user, applicationId);\n+        if (tracker \u003d\u003d null) {\n+          // This is likely due to a race between heartbeat and\n+          // app cleaning up.\n+          continue;\n+        }\n         switch (stat.getStatus()) {\n           case FETCH_SUCCESS:\n             // notify resource\n             try {\n-            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n-              .handle(\n-                new ResourceLocalizedEvent(req, stat.getLocalPath().toPath(),\n-                    stat.getLocalSize()));\n+              tracker.handle(new ResourceLocalizedEvent(req,\n+                  stat.getLocalPath().toPath(), stat.getLocalSize()));\n             } catch (URISyntaxException e) { }\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           case FETCH_PENDING:\n             break;\n           case FETCH_FAILURE:\n             final String diagnostics \u003d stat.getException().toString();\n             LOG.warn(req + \" failed: \" + diagnostics);\n             fetchFailed \u003d true;\n-            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n-              .handle(new ResourceFailedLocalizationEvent(\n-                  req, diagnostics));\n+            tracker.handle(new ResourceFailedLocalizationEvent(req,\n+                diagnostics));\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           default:\n             LOG.info(\"Unknown status: \" + stat.getStatus());\n             fetchFailed \u003d true;\n-            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n-              .handle(new ResourceFailedLocalizationEvent(\n-                  req, stat.getException().getMessage()));\n+            tracker.handle(new ResourceFailedLocalizationEvent(req,\n+                stat.getException().getMessage()));\n             break;\n         }\n       }\n       if (fetchFailed || killContainerLocalizer.get()) {\n         response.setLocalizerAction(LocalizerAction.DIE);\n         return response;\n       }\n \n       // Give the localizer resources for remote-fetching.\n       List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n           new ArrayList\u003cResourceLocalizationSpec\u003e();\n \n       /*\n        * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n        * at the same time. We need to think whether we should support this.\n        */\n       LocalResource next \u003d findNextResource();\n       if (next !\u003d null) {\n         try {\n-          ResourceLocalizationSpec resource \u003d\n-              NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n-                getPathForLocalization(next));\n-          rsrcs.add(resource);\n+          LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n+              next.getVisibility(), user, applicationId);\n+          if (tracker !\u003d null) {\n+            ResourceLocalizationSpec resource \u003d\n+                NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n+                getPathForLocalization(next, tracker));\n+            rsrcs.add(resource);\n+          }\n         } catch (IOException e) {\n           LOG.error(\"local path for PRIVATE localization could not be \" +\n             \"found. Disks might have failed.\", e);\n         } catch (IllegalArgumentException e) {\n           LOG.error(\"Inorrect path for PRIVATE localization.\"\n               + next.getResource().getFile(), e);\n         } catch (URISyntaxException e) {\n           LOG.error(\n               \"Got exception in parsing URL of LocalResource:\"\n                   + next.getResource(), e);\n         }\n       }\n \n       response.setLocalizerAction(LocalizerAction.LIVE);\n       response.setResourceSpecs(rsrcs);\n       return response;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    LocalizerHeartbeatResponse processHeartbeat(\n        List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n      LocalizerHeartbeatResponse response \u003d\n        recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n      String user \u003d context.getUser();\n      ApplicationId applicationId \u003d\n          context.getContainerId().getApplicationAttemptId().getApplicationId();\n\n      boolean fetchFailed \u003d false;\n      // Update resource statuses.\n      for (LocalResourceStatus stat : remoteResourceStatuses) {\n        LocalResource rsrc \u003d stat.getResource();\n        LocalResourceRequest req \u003d null;\n        try {\n          req \u003d new LocalResourceRequest(rsrc);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + rsrc.getResource(), e);\n        }\n        LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n        if (assoc \u003d\u003d null) {\n          // internal error\n          LOG.error(\"Unknown resource reported: \" + req);\n          continue;\n        }\n        LocalResourcesTracker tracker \u003d\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId);\n        if (tracker \u003d\u003d null) {\n          // This is likely due to a race between heartbeat and\n          // app cleaning up.\n          continue;\n        }\n        switch (stat.getStatus()) {\n          case FETCH_SUCCESS:\n            // notify resource\n            try {\n              tracker.handle(new ResourceLocalizedEvent(req,\n                  stat.getLocalPath().toPath(), stat.getLocalSize()));\n            } catch (URISyntaxException e) { }\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          case FETCH_PENDING:\n            break;\n          case FETCH_FAILURE:\n            final String diagnostics \u003d stat.getException().toString();\n            LOG.warn(req + \" failed: \" + diagnostics);\n            fetchFailed \u003d true;\n            tracker.handle(new ResourceFailedLocalizationEvent(req,\n                diagnostics));\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          default:\n            LOG.info(\"Unknown status: \" + stat.getStatus());\n            fetchFailed \u003d true;\n            tracker.handle(new ResourceFailedLocalizationEvent(req,\n                stat.getException().getMessage()));\n            break;\n        }\n      }\n      if (fetchFailed || killContainerLocalizer.get()) {\n        response.setLocalizerAction(LocalizerAction.DIE);\n        return response;\n      }\n\n      // Give the localizer resources for remote-fetching.\n      List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n          new ArrayList\u003cResourceLocalizationSpec\u003e();\n\n      /*\n       * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n       * at the same time. We need to think whether we should support this.\n       */\n      LocalResource next \u003d findNextResource();\n      if (next !\u003d null) {\n        try {\n          LocalResourcesTracker tracker \u003d getLocalResourcesTracker(\n              next.getVisibility(), user, applicationId);\n          if (tracker !\u003d null) {\n            ResourceLocalizationSpec resource \u003d\n                NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n                getPathForLocalization(next, tracker));\n            rsrcs.add(resource);\n          }\n        } catch (IOException e) {\n          LOG.error(\"local path for PRIVATE localization could not be \" +\n            \"found. Disks might have failed.\", e);\n        } catch (IllegalArgumentException e) {\n          LOG.error(\"Inorrect path for PRIVATE localization.\"\n              + next.getResource().getFile(), e);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + next.getResource(), e);\n        }\n      }\n\n      response.setLocalizerAction(LocalizerAction.LIVE);\n      response.setResourceSpecs(rsrcs);\n      return response;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "10/02/16 10:36 PM",
      "commitNameOld": "fa00d3e20560bee412b49e5792595749a247a8ab",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 124.65,
      "commitsBetweenForRepo": 784,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,103 @@\n     LocalizerHeartbeatResponse processHeartbeat(\n         List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n       LocalizerHeartbeatResponse response \u003d\n         recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n \n       String user \u003d context.getUser();\n       ApplicationId applicationId \u003d\n           context.getContainerId().getApplicationAttemptId().getApplicationId();\n \n       boolean fetchFailed \u003d false;\n       // Update resource statuses.\n       for (LocalResourceStatus stat : remoteResourceStatuses) {\n         LocalResource rsrc \u003d stat.getResource();\n         LocalResourceRequest req \u003d null;\n         try {\n           req \u003d new LocalResourceRequest(rsrc);\n         } catch (URISyntaxException e) {\n           LOG.error(\n               \"Got exception in parsing URL of LocalResource:\"\n                   + rsrc.getResource(), e);\n         }\n         LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n         if (assoc \u003d\u003d null) {\n           // internal error\n           LOG.error(\"Unknown resource reported: \" + req);\n           continue;\n         }\n         switch (stat.getStatus()) {\n           case FETCH_SUCCESS:\n             // notify resource\n             try {\n             getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n               .handle(\n-                new ResourceLocalizedEvent(req, ConverterUtils\n-                  .getPathFromYarnURL(stat.getLocalPath()), stat.getLocalSize()));\n+                new ResourceLocalizedEvent(req, stat.getLocalPath().toPath(),\n+                    stat.getLocalSize()));\n             } catch (URISyntaxException e) { }\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           case FETCH_PENDING:\n             break;\n           case FETCH_FAILURE:\n             final String diagnostics \u003d stat.getException().toString();\n             LOG.warn(req + \" failed: \" + diagnostics);\n             fetchFailed \u003d true;\n             getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n               .handle(new ResourceFailedLocalizationEvent(\n                   req, diagnostics));\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           default:\n             LOG.info(\"Unknown status: \" + stat.getStatus());\n             fetchFailed \u003d true;\n             getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n               .handle(new ResourceFailedLocalizationEvent(\n                   req, stat.getException().getMessage()));\n             break;\n         }\n       }\n       if (fetchFailed || killContainerLocalizer.get()) {\n         response.setLocalizerAction(LocalizerAction.DIE);\n         return response;\n       }\n \n       // Give the localizer resources for remote-fetching.\n       List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n           new ArrayList\u003cResourceLocalizationSpec\u003e();\n \n       /*\n        * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n        * at the same time. We need to think whether we should support this.\n        */\n       LocalResource next \u003d findNextResource();\n       if (next !\u003d null) {\n         try {\n           ResourceLocalizationSpec resource \u003d\n               NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n                 getPathForLocalization(next));\n           rsrcs.add(resource);\n         } catch (IOException e) {\n           LOG.error(\"local path for PRIVATE localization could not be \" +\n             \"found. Disks might have failed.\", e);\n         } catch (IllegalArgumentException e) {\n           LOG.error(\"Inorrect path for PRIVATE localization.\"\n               + next.getResource().getFile(), e);\n         } catch (URISyntaxException e) {\n           LOG.error(\n               \"Got exception in parsing URL of LocalResource:\"\n                   + next.getResource(), e);\n         }\n       }\n \n       response.setLocalizerAction(LocalizerAction.LIVE);\n       response.setResourceSpecs(rsrcs);\n       return response;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    LocalizerHeartbeatResponse processHeartbeat(\n        List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n      LocalizerHeartbeatResponse response \u003d\n        recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n\n      String user \u003d context.getUser();\n      ApplicationId applicationId \u003d\n          context.getContainerId().getApplicationAttemptId().getApplicationId();\n\n      boolean fetchFailed \u003d false;\n      // Update resource statuses.\n      for (LocalResourceStatus stat : remoteResourceStatuses) {\n        LocalResource rsrc \u003d stat.getResource();\n        LocalResourceRequest req \u003d null;\n        try {\n          req \u003d new LocalResourceRequest(rsrc);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + rsrc.getResource(), e);\n        }\n        LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n        if (assoc \u003d\u003d null) {\n          // internal error\n          LOG.error(\"Unknown resource reported: \" + req);\n          continue;\n        }\n        switch (stat.getStatus()) {\n          case FETCH_SUCCESS:\n            // notify resource\n            try {\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n              .handle(\n                new ResourceLocalizedEvent(req, stat.getLocalPath().toPath(),\n                    stat.getLocalSize()));\n            } catch (URISyntaxException e) { }\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          case FETCH_PENDING:\n            break;\n          case FETCH_FAILURE:\n            final String diagnostics \u003d stat.getException().toString();\n            LOG.warn(req + \" failed: \" + diagnostics);\n            fetchFailed \u003d true;\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n              .handle(new ResourceFailedLocalizationEvent(\n                  req, diagnostics));\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          default:\n            LOG.info(\"Unknown status: \" + stat.getStatus());\n            fetchFailed \u003d true;\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n              .handle(new ResourceFailedLocalizationEvent(\n                  req, stat.getException().getMessage()));\n            break;\n        }\n      }\n      if (fetchFailed || killContainerLocalizer.get()) {\n        response.setLocalizerAction(LocalizerAction.DIE);\n        return response;\n      }\n\n      // Give the localizer resources for remote-fetching.\n      List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n          new ArrayList\u003cResourceLocalizationSpec\u003e();\n\n      /*\n       * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n       * at the same time. We need to think whether we should support this.\n       */\n      LocalResource next \u003d findNextResource();\n      if (next !\u003d null) {\n        try {\n          ResourceLocalizationSpec resource \u003d\n              NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n                getPathForLocalization(next));\n          rsrcs.add(resource);\n        } catch (IOException e) {\n          LOG.error(\"local path for PRIVATE localization could not be \" +\n            \"found. Disks might have failed.\", e);\n        } catch (IllegalArgumentException e) {\n          LOG.error(\"Inorrect path for PRIVATE localization.\"\n              + next.getResource().getFile(), e);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + next.getResource(), e);\n        }\n      }\n\n      response.setLocalizerAction(LocalizerAction.LIVE);\n      response.setResourceSpecs(rsrcs);\n      return response;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "38102420621308f5ba91cdeb6a18a63aa5acf640": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3396. Handle URISyntaxException in ResourceLocalizationService. (Contributed by Brahma Reddy Battula)\n",
      "commitDate": "05/05/15 10:18 AM",
      "commitName": "38102420621308f5ba91cdeb6a18a63aa5acf640",
      "commitAuthor": "Junping Du",
      "commitDateOld": "04/05/15 8:31 AM",
      "commitNameOld": "8f65c793f2930bfd16885a2ab188a9970b754974",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 1.07,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,99 +1,103 @@\n     LocalizerHeartbeatResponse processHeartbeat(\n         List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n       LocalizerHeartbeatResponse response \u003d\n         recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n \n       String user \u003d context.getUser();\n       ApplicationId applicationId \u003d\n           context.getContainerId().getApplicationAttemptId().getApplicationId();\n \n       boolean fetchFailed \u003d false;\n       // Update resource statuses.\n       for (LocalResourceStatus stat : remoteResourceStatuses) {\n         LocalResource rsrc \u003d stat.getResource();\n         LocalResourceRequest req \u003d null;\n         try {\n           req \u003d new LocalResourceRequest(rsrc);\n         } catch (URISyntaxException e) {\n-          // TODO fail? Already translated several times...\n+          LOG.error(\n+              \"Got exception in parsing URL of LocalResource:\"\n+                  + rsrc.getResource(), e);\n         }\n         LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n         if (assoc \u003d\u003d null) {\n           // internal error\n           LOG.error(\"Unknown resource reported: \" + req);\n           continue;\n         }\n         switch (stat.getStatus()) {\n           case FETCH_SUCCESS:\n             // notify resource\n             try {\n             getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n               .handle(\n                 new ResourceLocalizedEvent(req, ConverterUtils\n                   .getPathFromYarnURL(stat.getLocalPath()), stat.getLocalSize()));\n             } catch (URISyntaxException e) { }\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           case FETCH_PENDING:\n             break;\n           case FETCH_FAILURE:\n             final String diagnostics \u003d stat.getException().toString();\n             LOG.warn(req + \" failed: \" + diagnostics);\n             fetchFailed \u003d true;\n             getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n               .handle(new ResourceFailedLocalizationEvent(\n                   req, diagnostics));\n \n             // unlocking the resource and removing it from scheduled resource\n             // list\n             assoc.getResource().unlock();\n             scheduled.remove(req);\n             break;\n           default:\n             LOG.info(\"Unknown status: \" + stat.getStatus());\n             fetchFailed \u003d true;\n             getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n               .handle(new ResourceFailedLocalizationEvent(\n                   req, stat.getException().getMessage()));\n             break;\n         }\n       }\n       if (fetchFailed || killContainerLocalizer.get()) {\n         response.setLocalizerAction(LocalizerAction.DIE);\n         return response;\n       }\n \n       // Give the localizer resources for remote-fetching.\n       List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n           new ArrayList\u003cResourceLocalizationSpec\u003e();\n \n       /*\n        * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n        * at the same time. We need to think whether we should support this.\n        */\n       LocalResource next \u003d findNextResource();\n       if (next !\u003d null) {\n         try {\n           ResourceLocalizationSpec resource \u003d\n               NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n                 getPathForLocalization(next));\n           rsrcs.add(resource);\n         } catch (IOException e) {\n           LOG.error(\"local path for PRIVATE localization could not be \" +\n             \"found. Disks might have failed.\", e);\n         } catch (IllegalArgumentException e) {\n           LOG.error(\"Inorrect path for PRIVATE localization.\"\n               + next.getResource().getFile(), e);\n         } catch (URISyntaxException e) {\n-            //TODO fail? Already translated several times...\n+          LOG.error(\n+              \"Got exception in parsing URL of LocalResource:\"\n+                  + next.getResource(), e);\n         }\n       }\n \n       response.setLocalizerAction(LocalizerAction.LIVE);\n       response.setResourceSpecs(rsrcs);\n       return response;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    LocalizerHeartbeatResponse processHeartbeat(\n        List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n      LocalizerHeartbeatResponse response \u003d\n        recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n\n      String user \u003d context.getUser();\n      ApplicationId applicationId \u003d\n          context.getContainerId().getApplicationAttemptId().getApplicationId();\n\n      boolean fetchFailed \u003d false;\n      // Update resource statuses.\n      for (LocalResourceStatus stat : remoteResourceStatuses) {\n        LocalResource rsrc \u003d stat.getResource();\n        LocalResourceRequest req \u003d null;\n        try {\n          req \u003d new LocalResourceRequest(rsrc);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + rsrc.getResource(), e);\n        }\n        LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n        if (assoc \u003d\u003d null) {\n          // internal error\n          LOG.error(\"Unknown resource reported: \" + req);\n          continue;\n        }\n        switch (stat.getStatus()) {\n          case FETCH_SUCCESS:\n            // notify resource\n            try {\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n              .handle(\n                new ResourceLocalizedEvent(req, ConverterUtils\n                  .getPathFromYarnURL(stat.getLocalPath()), stat.getLocalSize()));\n            } catch (URISyntaxException e) { }\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          case FETCH_PENDING:\n            break;\n          case FETCH_FAILURE:\n            final String diagnostics \u003d stat.getException().toString();\n            LOG.warn(req + \" failed: \" + diagnostics);\n            fetchFailed \u003d true;\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n              .handle(new ResourceFailedLocalizationEvent(\n                  req, diagnostics));\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          default:\n            LOG.info(\"Unknown status: \" + stat.getStatus());\n            fetchFailed \u003d true;\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n              .handle(new ResourceFailedLocalizationEvent(\n                  req, stat.getException().getMessage()));\n            break;\n        }\n      }\n      if (fetchFailed || killContainerLocalizer.get()) {\n        response.setLocalizerAction(LocalizerAction.DIE);\n        return response;\n      }\n\n      // Give the localizer resources for remote-fetching.\n      List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n          new ArrayList\u003cResourceLocalizationSpec\u003e();\n\n      /*\n       * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n       * at the same time. We need to think whether we should support this.\n       */\n      LocalResource next \u003d findNextResource();\n      if (next !\u003d null) {\n        try {\n          ResourceLocalizationSpec resource \u003d\n              NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n                getPathForLocalization(next));\n          rsrcs.add(resource);\n        } catch (IOException e) {\n          LOG.error(\"local path for PRIVATE localization could not be \" +\n            \"found. Disks might have failed.\", e);\n        } catch (IllegalArgumentException e) {\n          LOG.error(\"Inorrect path for PRIVATE localization.\"\n              + next.getResource().getFile(), e);\n        } catch (URISyntaxException e) {\n          LOG.error(\n              \"Got exception in parsing URL of LocalResource:\"\n                  + next.getResource(), e);\n        }\n      }\n\n      response.setLocalizerAction(LocalizerAction.LIVE);\n      response.setResourceSpecs(rsrcs);\n      return response;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java",
      "extendedDetails": {}
    },
    "47279c3228185548ed09c36579b420225e4894f5": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3464. Race condition in LocalizerRunner kills localizer before localizing all resources. (Zhihai Xu via kasha)\n",
      "commitDate": "26/04/15 9:13 AM",
      "commitName": "47279c3228185548ed09c36579b420225e4894f5",
      "commitAuthor": "Karthik Kambatla",
      "diff": "@@ -0,0 +1,99 @@\n+    LocalizerHeartbeatResponse processHeartbeat(\n+        List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n+      LocalizerHeartbeatResponse response \u003d\n+        recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n+\n+      String user \u003d context.getUser();\n+      ApplicationId applicationId \u003d\n+          context.getContainerId().getApplicationAttemptId().getApplicationId();\n+\n+      boolean fetchFailed \u003d false;\n+      // Update resource statuses.\n+      for (LocalResourceStatus stat : remoteResourceStatuses) {\n+        LocalResource rsrc \u003d stat.getResource();\n+        LocalResourceRequest req \u003d null;\n+        try {\n+          req \u003d new LocalResourceRequest(rsrc);\n+        } catch (URISyntaxException e) {\n+          // TODO fail? Already translated several times...\n+        }\n+        LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n+        if (assoc \u003d\u003d null) {\n+          // internal error\n+          LOG.error(\"Unknown resource reported: \" + req);\n+          continue;\n+        }\n+        switch (stat.getStatus()) {\n+          case FETCH_SUCCESS:\n+            // notify resource\n+            try {\n+            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n+              .handle(\n+                new ResourceLocalizedEvent(req, ConverterUtils\n+                  .getPathFromYarnURL(stat.getLocalPath()), stat.getLocalSize()));\n+            } catch (URISyntaxException e) { }\n+\n+            // unlocking the resource and removing it from scheduled resource\n+            // list\n+            assoc.getResource().unlock();\n+            scheduled.remove(req);\n+            break;\n+          case FETCH_PENDING:\n+            break;\n+          case FETCH_FAILURE:\n+            final String diagnostics \u003d stat.getException().toString();\n+            LOG.warn(req + \" failed: \" + diagnostics);\n+            fetchFailed \u003d true;\n+            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n+              .handle(new ResourceFailedLocalizationEvent(\n+                  req, diagnostics));\n+\n+            // unlocking the resource and removing it from scheduled resource\n+            // list\n+            assoc.getResource().unlock();\n+            scheduled.remove(req);\n+            break;\n+          default:\n+            LOG.info(\"Unknown status: \" + stat.getStatus());\n+            fetchFailed \u003d true;\n+            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n+              .handle(new ResourceFailedLocalizationEvent(\n+                  req, stat.getException().getMessage()));\n+            break;\n+        }\n+      }\n+      if (fetchFailed || killContainerLocalizer.get()) {\n+        response.setLocalizerAction(LocalizerAction.DIE);\n+        return response;\n+      }\n+\n+      // Give the localizer resources for remote-fetching.\n+      List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n+          new ArrayList\u003cResourceLocalizationSpec\u003e();\n+\n+      /*\n+       * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n+       * at the same time. We need to think whether we should support this.\n+       */\n+      LocalResource next \u003d findNextResource();\n+      if (next !\u003d null) {\n+        try {\n+          ResourceLocalizationSpec resource \u003d\n+              NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n+                getPathForLocalization(next));\n+          rsrcs.add(resource);\n+        } catch (IOException e) {\n+          LOG.error(\"local path for PRIVATE localization could not be \" +\n+            \"found. Disks might have failed.\", e);\n+        } catch (IllegalArgumentException e) {\n+          LOG.error(\"Inorrect path for PRIVATE localization.\"\n+              + next.getResource().getFile(), e);\n+        } catch (URISyntaxException e) {\n+            //TODO fail? Already translated several times...\n+        }\n+      }\n+\n+      response.setLocalizerAction(LocalizerAction.LIVE);\n+      response.setResourceSpecs(rsrcs);\n+      return response;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    LocalizerHeartbeatResponse processHeartbeat(\n        List\u003cLocalResourceStatus\u003e remoteResourceStatuses) {\n      LocalizerHeartbeatResponse response \u003d\n        recordFactory.newRecordInstance(LocalizerHeartbeatResponse.class);\n\n      String user \u003d context.getUser();\n      ApplicationId applicationId \u003d\n          context.getContainerId().getApplicationAttemptId().getApplicationId();\n\n      boolean fetchFailed \u003d false;\n      // Update resource statuses.\n      for (LocalResourceStatus stat : remoteResourceStatuses) {\n        LocalResource rsrc \u003d stat.getResource();\n        LocalResourceRequest req \u003d null;\n        try {\n          req \u003d new LocalResourceRequest(rsrc);\n        } catch (URISyntaxException e) {\n          // TODO fail? Already translated several times...\n        }\n        LocalizerResourceRequestEvent assoc \u003d scheduled.get(req);\n        if (assoc \u003d\u003d null) {\n          // internal error\n          LOG.error(\"Unknown resource reported: \" + req);\n          continue;\n        }\n        switch (stat.getStatus()) {\n          case FETCH_SUCCESS:\n            // notify resource\n            try {\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n              .handle(\n                new ResourceLocalizedEvent(req, ConverterUtils\n                  .getPathFromYarnURL(stat.getLocalPath()), stat.getLocalSize()));\n            } catch (URISyntaxException e) { }\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          case FETCH_PENDING:\n            break;\n          case FETCH_FAILURE:\n            final String diagnostics \u003d stat.getException().toString();\n            LOG.warn(req + \" failed: \" + diagnostics);\n            fetchFailed \u003d true;\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n              .handle(new ResourceFailedLocalizationEvent(\n                  req, diagnostics));\n\n            // unlocking the resource and removing it from scheduled resource\n            // list\n            assoc.getResource().unlock();\n            scheduled.remove(req);\n            break;\n          default:\n            LOG.info(\"Unknown status: \" + stat.getStatus());\n            fetchFailed \u003d true;\n            getLocalResourcesTracker(req.getVisibility(), user, applicationId)\n              .handle(new ResourceFailedLocalizationEvent(\n                  req, stat.getException().getMessage()));\n            break;\n        }\n      }\n      if (fetchFailed || killContainerLocalizer.get()) {\n        response.setLocalizerAction(LocalizerAction.DIE);\n        return response;\n      }\n\n      // Give the localizer resources for remote-fetching.\n      List\u003cResourceLocalizationSpec\u003e rsrcs \u003d\n          new ArrayList\u003cResourceLocalizationSpec\u003e();\n\n      /*\n       * TODO : It doesn\u0027t support multiple downloads per ContainerLocalizer\n       * at the same time. We need to think whether we should support this.\n       */\n      LocalResource next \u003d findNextResource();\n      if (next !\u003d null) {\n        try {\n          ResourceLocalizationSpec resource \u003d\n              NodeManagerBuilderUtils.newResourceLocalizationSpec(next,\n                getPathForLocalization(next));\n          rsrcs.add(resource);\n        } catch (IOException e) {\n          LOG.error(\"local path for PRIVATE localization could not be \" +\n            \"found. Disks might have failed.\", e);\n        } catch (IllegalArgumentException e) {\n          LOG.error(\"Inorrect path for PRIVATE localization.\"\n              + next.getResource().getFile(), e);\n        } catch (URISyntaxException e) {\n            //TODO fail? Already translated several times...\n        }\n      }\n\n      response.setLocalizerAction(LocalizerAction.LIVE);\n      response.setResourceSpecs(rsrcs);\n      return response;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/localizer/ResourceLocalizationService.java"
    }
  }
}