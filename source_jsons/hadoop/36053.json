{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMAppManager.java",
  "functionName": "submitApplication",
  "functionId": "submitApplication___submissionContext-ApplicationSubmissionContext__submitTime-long__user-String",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
  "functionStartLine": 345,
  "functionEndLine": 379,
  "numCommitsSeen": 208,
  "timeTaken": 8942,
  "changeHistory": [
    "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc",
    "69fa81679f59378fd19a2c65db8019393d7c05a2",
    "874577a67df8a49243586909d866034df4e3b276",
    "702236129b930a799a5a3295f0aa0dc7b619c354",
    "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af",
    "656c8f952738f469766ede729dc0f25a3ce4214e",
    "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5",
    "f8204e241d9271497defd4d42646fb89c61cefe3",
    "f65eeb412d140a3808bcf99344a9f3a965918f70",
    "b2cd2698028118b6384904732dbf94942f644732",
    "a16d022ca4313a41425c8e97841c841a2d6f2f54",
    "4de17c60528cb29bf7306dbaa720b96063948b17",
    "512475e56f0a27bf3c3ff596184f96993bb4bef4",
    "9f4d4e27fb1760b352cc5b301cd65a50d2d43ff6",
    "c6c41abf683be17c3917a7f94953b55347aaa69f",
    "a83fb61ac07c0468cbc7a38526e92683883dd932",
    "259edf8dca44de54033e96f7eb65a83aaa6096f2",
    "43876770d91a374563bf3379a5ffab5c2bac2264",
    "6de09af24487e2ff5bc22c7b1a07348c7119de80",
    "ef9f251679d7e87698eecd6a119652900274a172",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
    "d27291842605555f6727faa4454211f55da28cca",
    "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5",
    "1943fdbec613715f3cdc3ca60cbd273115f28299",
    "f79ae9141422dc4b2211ad3ca60bb79c3d266cb3",
    "c074cfd6f0ec695d85a73cddba1404c9db79342e",
    "40062e1aaa09628c6f45d20298fd66d799fd1f3f",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "6733a1ca5ef741d3bdf886f301954e9a9e7a875f",
    "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2",
    "29c6c3ed328965a73fe7b68eb29cb30794beef38",
    "df2991c0cbc3f35c2640b93680667507c4f810dd",
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
    "312a7e71001d55f88781e56b331ab1b40a72a980",
    "88b82a0f6687ce103817fbb460fd30d870f717a0",
    "ca853445e9a31e05278e9dceea9dbed734103f49",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "8af5c4b24aae932ecc8f09e72fdc7dc8307b6cc5"
  ],
  "changeHistoryShort": {
    "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc": "Ybodychange",
    "69fa81679f59378fd19a2c65db8019393d7c05a2": "Ybodychange",
    "874577a67df8a49243586909d866034df4e3b276": "Yexceptionschange",
    "702236129b930a799a5a3295f0aa0dc7b619c354": "Ybodychange",
    "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af": "Yexceptionschange",
    "656c8f952738f469766ede729dc0f25a3ce4214e": "Ybodychange",
    "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5": "Ybodychange",
    "f8204e241d9271497defd4d42646fb89c61cefe3": "Ybodychange",
    "f65eeb412d140a3808bcf99344a9f3a965918f70": "Ybodychange",
    "b2cd2698028118b6384904732dbf94942f644732": "Ybodychange",
    "a16d022ca4313a41425c8e97841c841a2d6f2f54": "Ybodychange",
    "4de17c60528cb29bf7306dbaa720b96063948b17": "Ymultichange(Yparameterchange,Ybodychange)",
    "512475e56f0a27bf3c3ff596184f96993bb4bef4": "Ymultichange(Yparameterchange,Ybodychange)",
    "9f4d4e27fb1760b352cc5b301cd65a50d2d43ff6": "Ybodychange",
    "c6c41abf683be17c3917a7f94953b55347aaa69f": "Ybodychange",
    "a83fb61ac07c0468cbc7a38526e92683883dd932": "Yexceptionschange",
    "259edf8dca44de54033e96f7eb65a83aaa6096f2": "Ymultichange(Yparameterchange,Ybodychange)",
    "43876770d91a374563bf3379a5ffab5c2bac2264": "Ybodychange",
    "6de09af24487e2ff5bc22c7b1a07348c7119de80": "Ymultichange(Yexceptionschange,Ybodychange)",
    "ef9f251679d7e87698eecd6a119652900274a172": "Ymultichange(Yparameterchange,Ybodychange)",
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": "Ybodychange",
    "d27291842605555f6727faa4454211f55da28cca": "Ymodifierchange",
    "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5": "Ybodychange",
    "1943fdbec613715f3cdc3ca60cbd273115f28299": "Ybodychange",
    "f79ae9141422dc4b2211ad3ca60bb79c3d266cb3": "Ybodychange",
    "c074cfd6f0ec695d85a73cddba1404c9db79342e": "Ybodychange",
    "40062e1aaa09628c6f45d20298fd66d799fd1f3f": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "6733a1ca5ef741d3bdf886f301954e9a9e7a875f": "Ybodychange",
    "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2": "Ybodychange",
    "29c6c3ed328965a73fe7b68eb29cb30794beef38": "Ybodychange",
    "df2991c0cbc3f35c2640b93680667507c4f810dd": "Ybodychange",
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546": "Ymultichange(Yparameterchange,Ybodychange)",
    "312a7e71001d55f88781e56b331ab1b40a72a980": "Ybodychange",
    "88b82a0f6687ce103817fbb460fd30d870f717a0": "Ybodychange",
    "ca853445e9a31e05278e9dceea9dbed734103f49": "Ymodifierchange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "8af5c4b24aae932ecc8f09e72fdc7dc8307b6cc5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9723. ApplicationPlacementContext is not required for terminated jobs during recovery. Contributed by Prabhu Joseph\n",
      "commitDate": "12/08/19 6:15 AM",
      "commitName": "e4b538bbda6dc25d7f45bffd6a4ce49f3f84acdc",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "15/05/19 1:00 AM",
      "commitNameOld": "570fa2da20706490dc7823efd0ce0cef3ddc81f9",
      "commitAuthorOld": "bibinchundatt",
      "daysBetweenCommits": 89.22,
      "commitsBetweenForRepo": 715,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     // Passing start time as -1. It will be eventually set in RMAppImpl\n     // constructor.\n     RMAppImpl application \u003d createAndPopulateNewRMApp(\n-        submissionContext, submitTime, user, false, -1);\n+        submissionContext, submitTime, user, false, -1, null);\n     try {\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer()\n             .addApplicationAsync(applicationId,\n                 BuilderUtils.parseCredentials(submissionContext),\n                 submissionContext.getCancelTokensWhenComplete(),\n                 application.getUser(),\n                 BuilderUtils.parseTokensConf(submissionContext));\n       } else {\n         // Dispatcher is not yet started at this time, so these START events\n         // enqueued should be guaranteed to be first processed when dispatcher\n         // gets started.\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (Exception e) {\n       LOG.warn(\"Unable to parse credentials for \" + applicationId, e);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we haven\u0027t yet informed the\n       // scheduler about the existence of the application\n       this.rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppEvent(applicationId,\n               RMAppEventType.APP_REJECTED, e.getMessage()));\n       throw RPCUtil.getRemoteException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    // Passing start time as -1. It will be eventually set in RMAppImpl\n    // constructor.\n    RMAppImpl application \u003d createAndPopulateNewRMApp(\n        submissionContext, submitTime, user, false, -1, null);\n    try {\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer()\n            .addApplicationAsync(applicationId,\n                BuilderUtils.parseCredentials(submissionContext),\n                submissionContext.getCancelTokensWhenComplete(),\n                application.getUser(),\n                BuilderUtils.parseTokensConf(submissionContext));\n      } else {\n        // Dispatcher is not yet started at this time, so these START events\n        // enqueued should be guaranteed to be first processed when dispatcher\n        // gets started.\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Unable to parse credentials for \" + applicationId, e);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we haven\u0027t yet informed the\n      // scheduler about the existence of the application\n      this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, e.getMessage()));\n      throw RPCUtil.getRemoteException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "69fa81679f59378fd19a2c65db8019393d7c05a2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5910. Support for multi-cluster delegation tokens. Contributed by Jian He\n",
      "commitDate": "23/01/17 9:12 AM",
      "commitName": "69fa81679f59378fd19a2c65db8019393d7c05a2",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "22/01/17 10:49 PM",
      "commitNameOld": "3fa0d540dfca579f3c2840a959b748a7528b02ed",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 0.43,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,35 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     // Passing start time as -1. It will be eventually set in RMAppImpl\n     // constructor.\n     RMAppImpl application \u003d createAndPopulateNewRMApp(\n         submissionContext, submitTime, user, false, -1);\n-    Credentials credentials \u003d null;\n     try {\n-      credentials \u003d parseCredentials(submissionContext);\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer()\n-            .addApplicationAsync(applicationId, credentials,\n+            .addApplicationAsync(applicationId,\n+                BuilderUtils.parseCredentials(submissionContext),\n                 submissionContext.getCancelTokensWhenComplete(),\n-                application.getUser());\n+                application.getUser(),\n+                BuilderUtils.parseTokensConf(submissionContext));\n       } else {\n         // Dispatcher is not yet started at this time, so these START events\n         // enqueued should be guaranteed to be first processed when dispatcher\n         // gets started.\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (Exception e) {\n-      LOG.warn(\"Unable to parse credentials.\", e);\n+      LOG.warn(\"Unable to parse credentials for \" + applicationId, e);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we haven\u0027t yet informed the\n       // scheduler about the existence of the application\n-      assert application.getState() \u003d\u003d RMAppState.NEW;\n       this.rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppEvent(applicationId,\n               RMAppEventType.APP_REJECTED, e.getMessage()));\n       throw RPCUtil.getRemoteException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    // Passing start time as -1. It will be eventually set in RMAppImpl\n    // constructor.\n    RMAppImpl application \u003d createAndPopulateNewRMApp(\n        submissionContext, submitTime, user, false, -1);\n    try {\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer()\n            .addApplicationAsync(applicationId,\n                BuilderUtils.parseCredentials(submissionContext),\n                submissionContext.getCancelTokensWhenComplete(),\n                application.getUser(),\n                BuilderUtils.parseTokensConf(submissionContext));\n      } else {\n        // Dispatcher is not yet started at this time, so these START events\n        // enqueued should be guaranteed to be first processed when dispatcher\n        // gets started.\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Unable to parse credentials for \" + applicationId, e);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we haven\u0027t yet informed the\n      // scheduler about the existence of the application\n      this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, e.getMessage()));\n      throw RPCUtil.getRemoteException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "874577a67df8a49243586909d866034df4e3b276": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-4833. For Queue AccessControlException client retries multiple times on both RM. Contributed by Bibin A Chundatt\n",
      "commitDate": "11/08/16 12:39 PM",
      "commitName": "874577a67df8a49243586909d866034df4e3b276",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "10/07/16 8:46 AM",
      "commitNameOld": "702236129b930a799a5a3295f0aa0dc7b619c354",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 32.16,
      "commitsBetweenForRepo": 250,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,36 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      String user) throws YarnException, AccessControlException {\n+      String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     // Passing start time as -1. It will be eventually set in RMAppImpl\n     // constructor.\n     RMAppImpl application \u003d createAndPopulateNewRMApp(\n         submissionContext, submitTime, user, false, -1);\n     Credentials credentials \u003d null;\n     try {\n       credentials \u003d parseCredentials(submissionContext);\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer()\n             .addApplicationAsync(applicationId, credentials,\n                 submissionContext.getCancelTokensWhenComplete(),\n                 application.getUser());\n       } else {\n         // Dispatcher is not yet started at this time, so these START events\n         // enqueued should be guaranteed to be first processed when dispatcher\n         // gets started.\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (Exception e) {\n       LOG.warn(\"Unable to parse credentials.\", e);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we haven\u0027t yet informed the\n       // scheduler about the existence of the application\n       assert application.getState() \u003d\u003d RMAppState.NEW;\n       this.rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppEvent(applicationId,\n               RMAppEventType.APP_REJECTED, e.getMessage()));\n       throw RPCUtil.getRemoteException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    // Passing start time as -1. It will be eventually set in RMAppImpl\n    // constructor.\n    RMAppImpl application \u003d createAndPopulateNewRMApp(\n        submissionContext, submitTime, user, false, -1);\n    Credentials credentials \u003d null;\n    try {\n      credentials \u003d parseCredentials(submissionContext);\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer()\n            .addApplicationAsync(applicationId, credentials,\n                submissionContext.getCancelTokensWhenComplete(),\n                application.getUser());\n      } else {\n        // Dispatcher is not yet started at this time, so these START events\n        // enqueued should be guaranteed to be first processed when dispatcher\n        // gets started.\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Unable to parse credentials.\", e);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we haven\u0027t yet informed the\n      // scheduler about the existence of the application\n      assert application.getState() \u003d\u003d RMAppState.NEW;\n      this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, e.getMessage()));\n      throw RPCUtil.getRemoteException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {
        "oldValue": "[YarnException, AccessControlException]",
        "newValue": "[YarnException]"
      }
    },
    "702236129b930a799a5a3295f0aa0dc7b619c354": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5095. flow activities and flow runs are populated with wrong timestamp when RM restarts w/ recovery enabled (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:46 AM",
      "commitName": "702236129b930a799a5a3295f0aa0dc7b619c354",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "89e5c44f9e891a3579384c3fa3766937cd4970f1",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,36 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user) throws YarnException, AccessControlException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n-    RMAppImpl application \u003d\n-        createAndPopulateNewRMApp(submissionContext, submitTime, user, false);\n+    // Passing start time as -1. It will be eventually set in RMAppImpl\n+    // constructor.\n+    RMAppImpl application \u003d createAndPopulateNewRMApp(\n+        submissionContext, submitTime, user, false, -1);\n     Credentials credentials \u003d null;\n     try {\n       credentials \u003d parseCredentials(submissionContext);\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer()\n             .addApplicationAsync(applicationId, credentials,\n                 submissionContext.getCancelTokensWhenComplete(),\n                 application.getUser());\n       } else {\n         // Dispatcher is not yet started at this time, so these START events\n         // enqueued should be guaranteed to be first processed when dispatcher\n         // gets started.\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (Exception e) {\n       LOG.warn(\"Unable to parse credentials.\", e);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we haven\u0027t yet informed the\n       // scheduler about the existence of the application\n       assert application.getState() \u003d\u003d RMAppState.NEW;\n       this.rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppEvent(applicationId,\n               RMAppEventType.APP_REJECTED, e.getMessage()));\n       throw RPCUtil.getRemoteException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException, AccessControlException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    // Passing start time as -1. It will be eventually set in RMAppImpl\n    // constructor.\n    RMAppImpl application \u003d createAndPopulateNewRMApp(\n        submissionContext, submitTime, user, false, -1);\n    Credentials credentials \u003d null;\n    try {\n      credentials \u003d parseCredentials(submissionContext);\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer()\n            .addApplicationAsync(applicationId, credentials,\n                submissionContext.getCancelTokensWhenComplete(),\n                application.getUser());\n      } else {\n        // Dispatcher is not yet started at this time, so these START events\n        // enqueued should be guaranteed to be first processed when dispatcher\n        // gets started.\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Unable to parse credentials.\", e);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we haven\u0027t yet informed the\n      // scheduler about the existence of the application\n      assert application.getState() \u003d\u003d RMAppState.NEW;\n      this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, e.getMessage()));\n      throw RPCUtil.getRemoteException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-4522. Queue acl can be checked at app submission. (Jian He via wangda)\n",
      "commitDate": "30/12/15 3:30 PM",
      "commitName": "8310b2e9ff3d6804bad703c4c15458b0dfeeb4af",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "07/12/15 12:24 PM",
      "commitNameOld": "4546c7582b6762c18ba150d80a8976eb51a8290c",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 23.13,
      "commitsBetweenForRepo": 129,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      String user) throws YarnException {\n+      String user) throws YarnException, AccessControlException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(submissionContext, submitTime, user, false);\n     Credentials credentials \u003d null;\n     try {\n       credentials \u003d parseCredentials(submissionContext);\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer()\n             .addApplicationAsync(applicationId, credentials,\n                 submissionContext.getCancelTokensWhenComplete(),\n                 application.getUser());\n       } else {\n         // Dispatcher is not yet started at this time, so these START events\n         // enqueued should be guaranteed to be first processed when dispatcher\n         // gets started.\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (Exception e) {\n       LOG.warn(\"Unable to parse credentials.\", e);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we haven\u0027t yet informed the\n       // scheduler about the existence of the application\n       assert application.getState() \u003d\u003d RMAppState.NEW;\n       this.rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppEvent(applicationId,\n               RMAppEventType.APP_REJECTED, e.getMessage()));\n       throw RPCUtil.getRemoteException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException, AccessControlException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(submissionContext, submitTime, user, false);\n    Credentials credentials \u003d null;\n    try {\n      credentials \u003d parseCredentials(submissionContext);\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer()\n            .addApplicationAsync(applicationId, credentials,\n                submissionContext.getCancelTokensWhenComplete(),\n                application.getUser());\n      } else {\n        // Dispatcher is not yet started at this time, so these START events\n        // enqueued should be guaranteed to be first processed when dispatcher\n        // gets started.\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Unable to parse credentials.\", e);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we haven\u0027t yet informed the\n      // scheduler about the existence of the application\n      assert application.getState() \u003d\u003d RMAppState.NEW;\n      this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, e.getMessage()));\n      throw RPCUtil.getRemoteException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {
        "oldValue": "[YarnException]",
        "newValue": "[YarnException, AccessControlException]"
      }
    },
    "656c8f952738f469766ede729dc0f25a3ce4214e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4130. Duplicate declaration of ApplicationId in RMAppManager#submitApplication method. (Kai Sasaki via rohithsharmaks)\n",
      "commitDate": "28/10/15 11:52 PM",
      "commitName": "656c8f952738f469766ede729dc0f25a3ce4214e",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "15/10/15 5:12 PM",
      "commitNameOld": "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 13.28,
      "commitsBetweenForRepo": 125,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,34 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(submissionContext, submitTime, user, false);\n-    ApplicationId appId \u003d submissionContext.getApplicationId();\n     Credentials credentials \u003d null;\n     try {\n       credentials \u003d parseCredentials(submissionContext);\n       if (UserGroupInformation.isSecurityEnabled()) {\n-        this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n-            credentials, submissionContext.getCancelTokensWhenComplete(),\n-            application.getUser());\n+        this.rmContext.getDelegationTokenRenewer()\n+            .addApplicationAsync(applicationId, credentials,\n+                submissionContext.getCancelTokensWhenComplete(),\n+                application.getUser());\n       } else {\n         // Dispatcher is not yet started at this time, so these START events\n         // enqueued should be guaranteed to be first processed when dispatcher\n         // gets started.\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (Exception e) {\n       LOG.warn(\"Unable to parse credentials.\", e);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we haven\u0027t yet informed the\n       // scheduler about the existence of the application\n       assert application.getState() \u003d\u003d RMAppState.NEW;\n       this.rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppEvent(applicationId,\n               RMAppEventType.APP_REJECTED, e.getMessage()));\n       throw RPCUtil.getRemoteException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(submissionContext, submitTime, user, false);\n    Credentials credentials \u003d null;\n    try {\n      credentials \u003d parseCredentials(submissionContext);\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer()\n            .addApplicationAsync(applicationId, credentials,\n                submissionContext.getCancelTokensWhenComplete(),\n                application.getUser());\n      } else {\n        // Dispatcher is not yet started at this time, so these START events\n        // enqueued should be guaranteed to be first processed when dispatcher\n        // gets started.\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Unable to parse credentials.\", e);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we haven\u0027t yet informed the\n      // scheduler about the existence of the application\n      assert application.getState() \u003d\u003d RMAppState.NEW;\n      this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, e.getMessage()));\n      throw RPCUtil.getRemoteException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4000. RM crashes with NPE if leaf queue becomes parent queue during restart. Contributed by Varun Saxena\n",
      "commitDate": "15/10/15 5:12 PM",
      "commitName": "cf23f2c2b5b4eb9e51de1a66b7aa57dee7ff30b5",
      "commitAuthor": "Jian He",
      "commitDateOld": "15/09/15 12:39 AM",
      "commitNameOld": "5468baa80aa2a3e2a02e9a902deebafd734daf23",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 30.69,
      "commitsBetweenForRepo": 251,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,34 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(submissionContext, submitTime, user, false);\n     ApplicationId appId \u003d submissionContext.getApplicationId();\n     Credentials credentials \u003d null;\n     try {\n       credentials \u003d parseCredentials(submissionContext);\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n             credentials, submissionContext.getCancelTokensWhenComplete(),\n             application.getUser());\n       } else {\n         // Dispatcher is not yet started at this time, so these START events\n         // enqueued should be guaranteed to be first processed when dispatcher\n         // gets started.\n         this.rmContext.getDispatcher().getEventHandler()\n             .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (Exception e) {\n       LOG.warn(\"Unable to parse credentials.\", e);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we haven\u0027t yet informed the\n       // scheduler about the existence of the application\n       assert application.getState() \u003d\u003d RMAppState.NEW;\n       this.rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n+          .handle(new RMAppEvent(applicationId,\n+              RMAppEventType.APP_REJECTED, e.getMessage()));\n       throw RPCUtil.getRemoteException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(submissionContext, submitTime, user, false);\n    ApplicationId appId \u003d submissionContext.getApplicationId();\n    Credentials credentials \u003d null;\n    try {\n      credentials \u003d parseCredentials(submissionContext);\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n            credentials, submissionContext.getCancelTokensWhenComplete(),\n            application.getUser());\n      } else {\n        // Dispatcher is not yet started at this time, so these START events\n        // enqueued should be guaranteed to be first processed when dispatcher\n        // gets started.\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Unable to parse credentials.\", e);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we haven\u0027t yet informed the\n      // scheduler about the existence of the application\n      assert application.getState() \u003d\u003d RMAppState.NEW;\n      this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              RMAppEventType.APP_REJECTED, e.getMessage()));\n      throw RPCUtil.getRemoteException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "f8204e241d9271497defd4d42646fb89c61cefe3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2893. AMLaucher: sporadic job failures due to EOFException in readTokenStorageStream. (Zhihai Xu via gera)\n",
      "commitDate": "01/05/15 6:18 PM",
      "commitName": "f8204e241d9271497defd4d42646fb89c61cefe3",
      "commitAuthor": "Gera Shegalov",
      "commitDateOld": "17/04/15 5:11 PM",
      "commitNameOld": "f65eeb412d140a3808bcf99344a9f3a965918f70",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 14.05,
      "commitsBetweenForRepo": 127,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(submissionContext, submitTime, user, false);\n     ApplicationId appId \u003d submissionContext.getApplicationId();\n-\n-    if (UserGroupInformation.isSecurityEnabled()) {\n-      try {\n+    Credentials credentials \u003d null;\n+    try {\n+      credentials \u003d parseCredentials(submissionContext);\n+      if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n-            parseCredentials(submissionContext),\n-            submissionContext.getCancelTokensWhenComplete(),\n+            credentials, submissionContext.getCancelTokensWhenComplete(),\n             application.getUser());\n-      } catch (Exception e) {\n-        LOG.warn(\"Unable to parse credentials.\", e);\n-        // Sending APP_REJECTED is fine, since we assume that the\n-        // RMApp is in NEW state and thus we haven\u0027t yet informed the\n-        // scheduler about the existence of the application\n-        assert application.getState() \u003d\u003d RMAppState.NEW;\n+      } else {\n+        // Dispatcher is not yet started at this time, so these START events\n+        // enqueued should be guaranteed to be first processed when dispatcher\n+        // gets started.\n         this.rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n-        throw RPCUtil.getRemoteException(e);\n+            .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n-    } else {\n-      // Dispatcher is not yet started at this time, so these START events\n-      // enqueued should be guaranteed to be first processed when dispatcher\n-      // gets started.\n+    } catch (Exception e) {\n+      LOG.warn(\"Unable to parse credentials.\", e);\n+      // Sending APP_REJECTED is fine, since we assume that the\n+      // RMApp is in NEW state and thus we haven\u0027t yet informed the\n+      // scheduler about the existence of the application\n+      assert application.getState() \u003d\u003d RMAppState.NEW;\n       this.rmContext.getDispatcher().getEventHandler()\n-        .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n+          .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n+      throw RPCUtil.getRemoteException(e);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(submissionContext, submitTime, user, false);\n    ApplicationId appId \u003d submissionContext.getApplicationId();\n    Credentials credentials \u003d null;\n    try {\n      credentials \u003d parseCredentials(submissionContext);\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n            credentials, submissionContext.getCancelTokensWhenComplete(),\n            application.getUser());\n      } else {\n        // Dispatcher is not yet started at this time, so these START events\n        // enqueued should be guaranteed to be first processed when dispatcher\n        // gets started.\n        this.rmContext.getDispatcher().getEventHandler()\n            .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (Exception e) {\n      LOG.warn(\"Unable to parse credentials.\", e);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we haven\u0027t yet informed the\n      // scheduler about the existence of the application\n      assert application.getState() \u003d\u003d RMAppState.NEW;\n      this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n      throw RPCUtil.getRemoteException(e);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "f65eeb412d140a3808bcf99344a9f3a965918f70": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3493. RM fails to come up with error \"Failed to load/recover state\" when mem settings are changed. (Jian He via wangda)\n",
      "commitDate": "17/04/15 5:11 PM",
      "commitName": "f65eeb412d140a3808bcf99344a9f3a965918f70",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "17/03/15 1:49 PM",
      "commitNameOld": "968425e9f7b850ff9c2ab8ca37a64c3fdbe77dbf",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 31.14,
      "commitsBetweenForRepo": 283,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,33 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     RMAppImpl application \u003d\n-        createAndPopulateNewRMApp(submissionContext, submitTime, user);\n+        createAndPopulateNewRMApp(submissionContext, submitTime, user, false);\n     ApplicationId appId \u003d submissionContext.getApplicationId();\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       try {\n         this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n             parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete(),\n             application.getUser());\n       } catch (Exception e) {\n         LOG.warn(\"Unable to parse credentials.\", e);\n         // Sending APP_REJECTED is fine, since we assume that the\n         // RMApp is in NEW state and thus we haven\u0027t yet informed the\n         // scheduler about the existence of the application\n         assert application.getState() \u003d\u003d RMAppState.NEW;\n         this.rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n         throw RPCUtil.getRemoteException(e);\n       }\n     } else {\n       // Dispatcher is not yet started at this time, so these START events\n       // enqueued should be guaranteed to be first processed when dispatcher\n       // gets started.\n       this.rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(submissionContext, submitTime, user, false);\n    ApplicationId appId \u003d submissionContext.getApplicationId();\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      try {\n        this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n            parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete(),\n            application.getUser());\n      } catch (Exception e) {\n        LOG.warn(\"Unable to parse credentials.\", e);\n        // Sending APP_REJECTED is fine, since we assume that the\n        // RMApp is in NEW state and thus we haven\u0027t yet informed the\n        // scheduler about the existence of the application\n        assert application.getState() \u003d\u003d RMAppState.NEW;\n        this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n        throw RPCUtil.getRemoteException(e);\n      }\n    } else {\n      // Dispatcher is not yet started at this time, so these START events\n      // enqueued should be guaranteed to be first processed when dispatcher\n      // gets started.\n      this.rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "b2cd2698028118b6384904732dbf94942f644732": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2010. Handle app-recovery failures gracefully. (Jian He and Karthik Kambatla via kasha)\n",
      "commitDate": "04/11/14 5:45 PM",
      "commitName": "b2cd2698028118b6384904732dbf94942f644732",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "27/10/14 3:49 PM",
      "commitNameOld": "a16d022ca4313a41425c8e97841c841a2d6f2f54",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 8.12,
      "commitsBetweenForRepo": 95,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,34 +1,33 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(submissionContext, submitTime, user);\n     ApplicationId appId \u003d submissionContext.getApplicationId();\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n-      Credentials credentials \u003d null;\n       try {\n-        credentials \u003d parseCredentials(submissionContext);\n         this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n-          credentials, submissionContext.getCancelTokensWhenComplete(),\n-          application.getUser());\n+            parseCredentials(submissionContext),\n+            submissionContext.getCancelTokensWhenComplete(),\n+            application.getUser());\n       } catch (Exception e) {\n         LOG.warn(\"Unable to parse credentials.\", e);\n         // Sending APP_REJECTED is fine, since we assume that the\n         // RMApp is in NEW state and thus we haven\u0027t yet informed the\n         // scheduler about the existence of the application\n         assert application.getState() \u003d\u003d RMAppState.NEW;\n         this.rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n         throw RPCUtil.getRemoteException(e);\n       }\n     } else {\n       // Dispatcher is not yet started at this time, so these START events\n       // enqueued should be guaranteed to be first processed when dispatcher\n       // gets started.\n       this.rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(submissionContext, submitTime, user);\n    ApplicationId appId \u003d submissionContext.getApplicationId();\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      try {\n        this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n            parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete(),\n            application.getUser());\n      } catch (Exception e) {\n        LOG.warn(\"Unable to parse credentials.\", e);\n        // Sending APP_REJECTED is fine, since we assume that the\n        // RMApp is in NEW state and thus we haven\u0027t yet informed the\n        // scheduler about the existence of the application\n        assert application.getState() \u003d\u003d RMAppState.NEW;\n        this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n        throw RPCUtil.getRemoteException(e);\n      }\n    } else {\n      // Dispatcher is not yet started at this time, so these START events\n      // enqueued should be guaranteed to be first processed when dispatcher\n      // gets started.\n      this.rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "a16d022ca4313a41425c8e97841c841a2d6f2f54": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2704. Changed ResourceManager to optionally obtain tokens itself for the sake of localization and log-aggregation for long-running services. Contributed by Jian He.\n",
      "commitDate": "27/10/14 3:49 PM",
      "commitName": "a16d022ca4313a41425c8e97841c841a2d6f2f54",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "15/10/14 6:33 PM",
      "commitNameOld": "f2ea555ac6c06a3f2f6559731f48711fff05d3f1",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 11.89,
      "commitsBetweenForRepo": 94,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,34 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(submissionContext, submitTime, user);\n     ApplicationId appId \u003d submissionContext.getApplicationId();\n \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials credentials \u003d null;\n       try {\n         credentials \u003d parseCredentials(submissionContext);\n         this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n-          credentials, submissionContext.getCancelTokensWhenComplete());\n+          credentials, submissionContext.getCancelTokensWhenComplete(),\n+          application.getUser());\n       } catch (Exception e) {\n         LOG.warn(\"Unable to parse credentials.\", e);\n         // Sending APP_REJECTED is fine, since we assume that the\n         // RMApp is in NEW state and thus we haven\u0027t yet informed the\n         // scheduler about the existence of the application\n         assert application.getState() \u003d\u003d RMAppState.NEW;\n         this.rmContext.getDispatcher().getEventHandler()\n           .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n         throw RPCUtil.getRemoteException(e);\n       }\n     } else {\n       // Dispatcher is not yet started at this time, so these START events\n       // enqueued should be guaranteed to be first processed when dispatcher\n       // gets started.\n       this.rmContext.getDispatcher().getEventHandler()\n         .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(submissionContext, submitTime, user);\n    ApplicationId appId \u003d submissionContext.getApplicationId();\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials credentials \u003d null;\n      try {\n        credentials \u003d parseCredentials(submissionContext);\n        this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n          credentials, submissionContext.getCancelTokensWhenComplete(),\n          application.getUser());\n      } catch (Exception e) {\n        LOG.warn(\"Unable to parse credentials.\", e);\n        // Sending APP_REJECTED is fine, since we assume that the\n        // RMApp is in NEW state and thus we haven\u0027t yet informed the\n        // scheduler about the existence of the application\n        assert application.getState() \u003d\u003d RMAppState.NEW;\n        this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n        throw RPCUtil.getRemoteException(e);\n      }\n    } else {\n      // Dispatcher is not yet started at this time, so these START events\n      // enqueued should be guaranteed to be first processed when dispatcher\n      // gets started.\n      this.rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "4de17c60528cb29bf7306dbaa720b96063948b17": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1812. Fixed ResourceManager to synchrously renew tokens after recovery and thus recover app itself synchronously and avoid races with resyncing NodeManagers. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1576843 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/03/14 11:25 AM",
      "commitName": "4de17c60528cb29bf7306dbaa720b96063948b17",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1812. Fixed ResourceManager to synchrously renew tokens after recovery and thus recover app itself synchronously and avoid races with resyncing NodeManagers. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1576843 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/03/14 11:25 AM",
          "commitName": "4de17c60528cb29bf7306dbaa720b96063948b17",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "04/02/14 8:55 PM",
          "commitNameOld": "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 35.56,
          "commitsBetweenForRepo": 336,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,33 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      String user, boolean isRecovered, RMState state) throws YarnException {\n+      String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(submissionContext, submitTime, user);\n+    ApplicationId appId \u003d submissionContext.getApplicationId();\n \n-    if (isRecovered) {\n-      recoverApplication(state, application);\n-      RMAppState rmAppState \u003d\n-          state.getApplicationState().get(applicationId).getState();\n-      if (isApplicationInFinalState(rmAppState)) {\n-        // We are synchronously moving the application into final state so that\n-        // momentarily client will not see this application in NEW state. Also\n-        // for finished applications we will avoid renewing tokens.\n-        application\n-            .handle(new RMAppEvent(applicationId, RMAppEventType.RECOVER));\n-        return;\n-      }\n-    }\n-    \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials credentials \u003d null;\n       try {\n         credentials \u003d parseCredentials(submissionContext);\n+        this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n+          credentials, submissionContext.getCancelTokensWhenComplete());\n       } catch (Exception e) {\n-        LOG.warn(\n-            \"Unable to parse credentials.\", e);\n+        LOG.warn(\"Unable to parse credentials.\", e);\n         // Sending APP_REJECTED is fine, since we assume that the\n         // RMApp is in NEW state and thus we haven\u0027t yet informed the\n         // scheduler about the existence of the application\n         assert application.getState() \u003d\u003d RMAppState.NEW;\n-        this.rmContext.getDispatcher().getEventHandler().handle(\n-            new RMAppRejectedEvent(applicationId, e.getMessage()));\n+        this.rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n         throw RPCUtil.getRemoteException(e);\n       }\n-      this.rmContext.getDelegationTokenRenewer().addApplication(\n-          applicationId, credentials,\n-          submissionContext.getCancelTokensWhenComplete(), isRecovered);\n     } else {\n+      // Dispatcher is not yet started at this time, so these START events\n+      // enqueued should be guaranteed to be first processed when dispatcher\n+      // gets started.\n       this.rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppEvent(applicationId,\n-              isRecovered ? RMAppEventType.RECOVER : RMAppEventType.START));\n+        .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(submissionContext, submitTime, user);\n    ApplicationId appId \u003d submissionContext.getApplicationId();\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials credentials \u003d null;\n      try {\n        credentials \u003d parseCredentials(submissionContext);\n        this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n          credentials, submissionContext.getCancelTokensWhenComplete());\n      } catch (Exception e) {\n        LOG.warn(\"Unable to parse credentials.\", e);\n        // Sending APP_REJECTED is fine, since we assume that the\n        // RMApp is in NEW state and thus we haven\u0027t yet informed the\n        // scheduler about the existence of the application\n        assert application.getState() \u003d\u003d RMAppState.NEW;\n        this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n        throw RPCUtil.getRemoteException(e);\n      }\n    } else {\n      // Dispatcher is not yet started at this time, so these START events\n      // enqueued should be guaranteed to be first processed when dispatcher\n      // gets started.\n      this.rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, user-String, isRecovered-boolean, state-RMState]",
            "newValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, user-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1812. Fixed ResourceManager to synchrously renew tokens after recovery and thus recover app itself synchronously and avoid races with resyncing NodeManagers. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1576843 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "12/03/14 11:25 AM",
          "commitName": "4de17c60528cb29bf7306dbaa720b96063948b17",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "04/02/14 8:55 PM",
          "commitNameOld": "ebe0c17a95ae37d4768f2928ea193e89db34ead5",
          "commitAuthorOld": "Zhijie Shen",
          "daysBetweenCommits": 35.56,
          "commitsBetweenForRepo": 336,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,46 +1,33 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      String user, boolean isRecovered, RMState state) throws YarnException {\n+      String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     RMAppImpl application \u003d\n         createAndPopulateNewRMApp(submissionContext, submitTime, user);\n+    ApplicationId appId \u003d submissionContext.getApplicationId();\n \n-    if (isRecovered) {\n-      recoverApplication(state, application);\n-      RMAppState rmAppState \u003d\n-          state.getApplicationState().get(applicationId).getState();\n-      if (isApplicationInFinalState(rmAppState)) {\n-        // We are synchronously moving the application into final state so that\n-        // momentarily client will not see this application in NEW state. Also\n-        // for finished applications we will avoid renewing tokens.\n-        application\n-            .handle(new RMAppEvent(applicationId, RMAppEventType.RECOVER));\n-        return;\n-      }\n-    }\n-    \n     if (UserGroupInformation.isSecurityEnabled()) {\n       Credentials credentials \u003d null;\n       try {\n         credentials \u003d parseCredentials(submissionContext);\n+        this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n+          credentials, submissionContext.getCancelTokensWhenComplete());\n       } catch (Exception e) {\n-        LOG.warn(\n-            \"Unable to parse credentials.\", e);\n+        LOG.warn(\"Unable to parse credentials.\", e);\n         // Sending APP_REJECTED is fine, since we assume that the\n         // RMApp is in NEW state and thus we haven\u0027t yet informed the\n         // scheduler about the existence of the application\n         assert application.getState() \u003d\u003d RMAppState.NEW;\n-        this.rmContext.getDispatcher().getEventHandler().handle(\n-            new RMAppRejectedEvent(applicationId, e.getMessage()));\n+        this.rmContext.getDispatcher().getEventHandler()\n+          .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n         throw RPCUtil.getRemoteException(e);\n       }\n-      this.rmContext.getDelegationTokenRenewer().addApplication(\n-          applicationId, credentials,\n-          submissionContext.getCancelTokensWhenComplete(), isRecovered);\n     } else {\n+      // Dispatcher is not yet started at this time, so these START events\n+      // enqueued should be guaranteed to be first processed when dispatcher\n+      // gets started.\n       this.rmContext.getDispatcher().getEventHandler()\n-          .handle(new RMAppEvent(applicationId,\n-              isRecovered ? RMAppEventType.RECOVER : RMAppEventType.START));\n+        .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(submissionContext, submitTime, user);\n    ApplicationId appId \u003d submissionContext.getApplicationId();\n\n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials credentials \u003d null;\n      try {\n        credentials \u003d parseCredentials(submissionContext);\n        this.rmContext.getDelegationTokenRenewer().addApplicationAsync(appId,\n          credentials, submissionContext.getCancelTokensWhenComplete());\n      } catch (Exception e) {\n        LOG.warn(\"Unable to parse credentials.\", e);\n        // Sending APP_REJECTED is fine, since we assume that the\n        // RMApp is in NEW state and thus we haven\u0027t yet informed the\n        // scheduler about the existence of the application\n        assert application.getState() \u003d\u003d RMAppState.NEW;\n        this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppRejectedEvent(applicationId, e.getMessage()));\n        throw RPCUtil.getRemoteException(e);\n      }\n    } else {\n      // Dispatcher is not yet started at this time, so these START events\n      // enqueued should be guaranteed to be first processed when dispatcher\n      // gets started.\n      this.rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "512475e56f0a27bf3c3ff596184f96993bb4bef4": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-674. Fixed ResourceManager to renew DelegationTokens on submission asynchronously to work around potential slowness in state-store. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543312 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/11/13 9:20 PM",
      "commitName": "512475e56f0a27bf3c3ff596184f96993bb4bef4",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-674. Fixed ResourceManager to renew DelegationTokens on submission asynchronously to work around potential slowness in state-store. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543312 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/11/13 9:20 PM",
          "commitName": "512475e56f0a27bf3c3ff596184f96993bb4bef4",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "18/11/13 4:50 PM",
          "commitNameOld": "4341562622df16b8a0c13af257ac0d03919b374d",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.19,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,46 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      boolean isRecovered, String user) throws YarnException {\n+      String user, boolean isRecovered, RMState state) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n-    // Validation of the ApplicationSubmissionContext needs to be completed\n-    // here. Only those fields that are dependent on RM\u0027s configuration are\n-    // checked here as they have to be validated whether they are part of new\n-    // submission or just being recovered.\n+    RMAppImpl application \u003d\n+        createAndPopulateNewRMApp(submissionContext, submitTime, user);\n \n-    // Check whether AM resource requirements are within required limits\n-    if (!submissionContext.getUnmanagedAM()) {\n-      ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n-          RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n-          submissionContext.getResource(), 1);\n+    if (isRecovered) {\n+      recoverApplication(state, application);\n+      RMAppState rmAppState \u003d\n+          state.getApplicationState().get(applicationId).getState();\n+      if (isApplicationInFinalState(rmAppState)) {\n+        // We are synchronously moving the application into final state so that\n+        // momentarily client will not see this application in NEW state. Also\n+        // for finished applications we will avoid renewing tokens.\n+        application\n+            .handle(new RMAppEvent(applicationId, RMAppEventType.RECOVER));\n+        return;\n+      }\n+    }\n+    \n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      Credentials credentials \u003d null;\n       try {\n-        SchedulerUtils.validateResourceRequest(amReq,\n-            scheduler.getMaximumResourceCapability());\n-      } catch (InvalidResourceRequestException e) {\n-        LOG.warn(\"RM app submission failed in validating AM resource request\"\n-            + \" for application \" + applicationId, e);\n-        throw e;\n+        credentials \u003d parseCredentials(submissionContext);\n+      } catch (Exception e) {\n+        LOG.warn(\n+            \"Unable to parse credentials.\", e);\n+        // Sending APP_REJECTED is fine, since we assume that the\n+        // RMApp is in NEW state and thus we haven\u0027t yet informed the\n+        // scheduler about the existence of the application\n+        assert application.getState() \u003d\u003d RMAppState.NEW;\n+        this.rmContext.getDispatcher().getEventHandler().handle(\n+            new RMAppRejectedEvent(applicationId, e.getMessage()));\n+        throw RPCUtil.getRemoteException(e);\n       }\n-    }\n-\n-    // Create RMApp\n-    RMApp application \u003d\n-        new RMAppImpl(applicationId, rmContext, this.conf,\n-            submissionContext.getApplicationName(), user,\n-            submissionContext.getQueue(),\n-            submissionContext, this.scheduler, this.masterService,\n-            submitTime, submissionContext.getApplicationType());\n-\n-    // Concurrent app submissions with same applicationId will fail here\n-    // Concurrent app submissions with different applicationIds will not\n-    // influence each other\n-    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n-        null) {\n-      String message \u003d \"Application with id \" + applicationId\n-          + \" is already present! Cannot add a duplicate!\";\n-      LOG.warn(message);\n-      throw RPCUtil.getRemoteException(message);\n-    }\n-\n-    // Inform the ACLs Manager\n-    this.applicationACLsManager.addApplication(applicationId,\n-        submissionContext.getAMContainerSpec().getApplicationACLs());\n-\n-    try {\n-      // Setup tokens for renewal\n-      if (UserGroupInformation.isSecurityEnabled()) {\n-        this.rmContext.getDelegationTokenRenewer().addApplication(\n-            applicationId,parseCredentials(submissionContext),\n-            submissionContext.getCancelTokensWhenComplete()\n-            );\n-      }\n-    } catch (IOException ie) {\n-      LOG.warn(\n-          \"Unable to add the application to the delegation token renewer.\",\n-          ie);\n-      // Sending APP_REJECTED is fine, since we assume that the\n-      // RMApp is in NEW state and thus we havne\u0027t yet informed the\n-      // Scheduler about the existence of the application\n-      this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppRejectedEvent(applicationId, ie.getMessage()));\n-      throw RPCUtil.getRemoteException(ie);\n-    }\n-\n-    if (!isRecovered) {\n-      // All done, start the RMApp\n+      this.rmContext.getDelegationTokenRenewer().addApplication(\n+          applicationId, credentials,\n+          submissionContext.getCancelTokensWhenComplete(), isRecovered);\n+    } else {\n       this.rmContext.getDispatcher().getEventHandler()\n-        .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n+          .handle(new RMAppEvent(applicationId,\n+              isRecovered ? RMAppEventType.RECOVER : RMAppEventType.START));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovered, RMState state) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(submissionContext, submitTime, user);\n\n    if (isRecovered) {\n      recoverApplication(state, application);\n      RMAppState rmAppState \u003d\n          state.getApplicationState().get(applicationId).getState();\n      if (isApplicationInFinalState(rmAppState)) {\n        // We are synchronously moving the application into final state so that\n        // momentarily client will not see this application in NEW state. Also\n        // for finished applications we will avoid renewing tokens.\n        application\n            .handle(new RMAppEvent(applicationId, RMAppEventType.RECOVER));\n        return;\n      }\n    }\n    \n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials credentials \u003d null;\n      try {\n        credentials \u003d parseCredentials(submissionContext);\n      } catch (Exception e) {\n        LOG.warn(\n            \"Unable to parse credentials.\", e);\n        // Sending APP_REJECTED is fine, since we assume that the\n        // RMApp is in NEW state and thus we haven\u0027t yet informed the\n        // scheduler about the existence of the application\n        assert application.getState() \u003d\u003d RMAppState.NEW;\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppRejectedEvent(applicationId, e.getMessage()));\n        throw RPCUtil.getRemoteException(e);\n      }\n      this.rmContext.getDelegationTokenRenewer().addApplication(\n          applicationId, credentials,\n          submissionContext.getCancelTokensWhenComplete(), isRecovered);\n    } else {\n      this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              isRecovered ? RMAppEventType.RECOVER : RMAppEventType.START));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, isRecovered-boolean, user-String]",
            "newValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, user-String, isRecovered-boolean, state-RMState]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-674. Fixed ResourceManager to renew DelegationTokens on submission asynchronously to work around potential slowness in state-store. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1543312 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/11/13 9:20 PM",
          "commitName": "512475e56f0a27bf3c3ff596184f96993bb4bef4",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "18/11/13 4:50 PM",
          "commitNameOld": "4341562622df16b8a0c13af257ac0d03919b374d",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.19,
          "commitsBetweenForRepo": 5,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,46 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      boolean isRecovered, String user) throws YarnException {\n+      String user, boolean isRecovered, RMState state) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n-    // Validation of the ApplicationSubmissionContext needs to be completed\n-    // here. Only those fields that are dependent on RM\u0027s configuration are\n-    // checked here as they have to be validated whether they are part of new\n-    // submission or just being recovered.\n+    RMAppImpl application \u003d\n+        createAndPopulateNewRMApp(submissionContext, submitTime, user);\n \n-    // Check whether AM resource requirements are within required limits\n-    if (!submissionContext.getUnmanagedAM()) {\n-      ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n-          RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n-          submissionContext.getResource(), 1);\n+    if (isRecovered) {\n+      recoverApplication(state, application);\n+      RMAppState rmAppState \u003d\n+          state.getApplicationState().get(applicationId).getState();\n+      if (isApplicationInFinalState(rmAppState)) {\n+        // We are synchronously moving the application into final state so that\n+        // momentarily client will not see this application in NEW state. Also\n+        // for finished applications we will avoid renewing tokens.\n+        application\n+            .handle(new RMAppEvent(applicationId, RMAppEventType.RECOVER));\n+        return;\n+      }\n+    }\n+    \n+    if (UserGroupInformation.isSecurityEnabled()) {\n+      Credentials credentials \u003d null;\n       try {\n-        SchedulerUtils.validateResourceRequest(amReq,\n-            scheduler.getMaximumResourceCapability());\n-      } catch (InvalidResourceRequestException e) {\n-        LOG.warn(\"RM app submission failed in validating AM resource request\"\n-            + \" for application \" + applicationId, e);\n-        throw e;\n+        credentials \u003d parseCredentials(submissionContext);\n+      } catch (Exception e) {\n+        LOG.warn(\n+            \"Unable to parse credentials.\", e);\n+        // Sending APP_REJECTED is fine, since we assume that the\n+        // RMApp is in NEW state and thus we haven\u0027t yet informed the\n+        // scheduler about the existence of the application\n+        assert application.getState() \u003d\u003d RMAppState.NEW;\n+        this.rmContext.getDispatcher().getEventHandler().handle(\n+            new RMAppRejectedEvent(applicationId, e.getMessage()));\n+        throw RPCUtil.getRemoteException(e);\n       }\n-    }\n-\n-    // Create RMApp\n-    RMApp application \u003d\n-        new RMAppImpl(applicationId, rmContext, this.conf,\n-            submissionContext.getApplicationName(), user,\n-            submissionContext.getQueue(),\n-            submissionContext, this.scheduler, this.masterService,\n-            submitTime, submissionContext.getApplicationType());\n-\n-    // Concurrent app submissions with same applicationId will fail here\n-    // Concurrent app submissions with different applicationIds will not\n-    // influence each other\n-    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n-        null) {\n-      String message \u003d \"Application with id \" + applicationId\n-          + \" is already present! Cannot add a duplicate!\";\n-      LOG.warn(message);\n-      throw RPCUtil.getRemoteException(message);\n-    }\n-\n-    // Inform the ACLs Manager\n-    this.applicationACLsManager.addApplication(applicationId,\n-        submissionContext.getAMContainerSpec().getApplicationACLs());\n-\n-    try {\n-      // Setup tokens for renewal\n-      if (UserGroupInformation.isSecurityEnabled()) {\n-        this.rmContext.getDelegationTokenRenewer().addApplication(\n-            applicationId,parseCredentials(submissionContext),\n-            submissionContext.getCancelTokensWhenComplete()\n-            );\n-      }\n-    } catch (IOException ie) {\n-      LOG.warn(\n-          \"Unable to add the application to the delegation token renewer.\",\n-          ie);\n-      // Sending APP_REJECTED is fine, since we assume that the\n-      // RMApp is in NEW state and thus we havne\u0027t yet informed the\n-      // Scheduler about the existence of the application\n-      this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppRejectedEvent(applicationId, ie.getMessage()));\n-      throw RPCUtil.getRemoteException(ie);\n-    }\n-\n-    if (!isRecovered) {\n-      // All done, start the RMApp\n+      this.rmContext.getDelegationTokenRenewer().addApplication(\n+          applicationId, credentials,\n+          submissionContext.getCancelTokensWhenComplete(), isRecovered);\n+    } else {\n       this.rmContext.getDispatcher().getEventHandler()\n-        .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n+          .handle(new RMAppEvent(applicationId,\n+              isRecovered ? RMAppEventType.RECOVER : RMAppEventType.START));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      String user, boolean isRecovered, RMState state) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    RMAppImpl application \u003d\n        createAndPopulateNewRMApp(submissionContext, submitTime, user);\n\n    if (isRecovered) {\n      recoverApplication(state, application);\n      RMAppState rmAppState \u003d\n          state.getApplicationState().get(applicationId).getState();\n      if (isApplicationInFinalState(rmAppState)) {\n        // We are synchronously moving the application into final state so that\n        // momentarily client will not see this application in NEW state. Also\n        // for finished applications we will avoid renewing tokens.\n        application\n            .handle(new RMAppEvent(applicationId, RMAppEventType.RECOVER));\n        return;\n      }\n    }\n    \n    if (UserGroupInformation.isSecurityEnabled()) {\n      Credentials credentials \u003d null;\n      try {\n        credentials \u003d parseCredentials(submissionContext);\n      } catch (Exception e) {\n        LOG.warn(\n            \"Unable to parse credentials.\", e);\n        // Sending APP_REJECTED is fine, since we assume that the\n        // RMApp is in NEW state and thus we haven\u0027t yet informed the\n        // scheduler about the existence of the application\n        assert application.getState() \u003d\u003d RMAppState.NEW;\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppRejectedEvent(applicationId, e.getMessage()));\n        throw RPCUtil.getRemoteException(e);\n      }\n      this.rmContext.getDelegationTokenRenewer().addApplication(\n          applicationId, credentials,\n          submissionContext.getCancelTokensWhenComplete(), isRecovered);\n    } else {\n      this.rmContext.getDispatcher().getEventHandler()\n          .handle(new RMAppEvent(applicationId,\n              isRecovered ? RMAppEventType.RECOVER : RMAppEventType.START));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "9f4d4e27fb1760b352cc5b301cd65a50d2d43ff6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-891. Modified ResourceManager state-store to remember completed applications so that clients can get information about them post RM-restart. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1537560 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/10/13 10:25 AM",
      "commitName": "9f4d4e27fb1760b352cc5b301cd65a50d2d43ff6",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "28/09/13 9:29 AM",
      "commitNameOld": "4ce930ea444d313eeb49e1f9ddbe5f52c7dc63a2",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 33.04,
      "commitsBetweenForRepo": 233,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,74 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       boolean isRecovered, String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     // Validation of the ApplicationSubmissionContext needs to be completed\n     // here. Only those fields that are dependent on RM\u0027s configuration are\n     // checked here as they have to be validated whether they are part of new\n     // submission or just being recovered.\n \n     // Check whether AM resource requirements are within required limits\n     if (!submissionContext.getUnmanagedAM()) {\n       ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n           RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n           submissionContext.getResource(), 1);\n       try {\n         SchedulerUtils.validateResourceRequest(amReq,\n             scheduler.getMaximumResourceCapability());\n       } catch (InvalidResourceRequestException e) {\n         LOG.warn(\"RM app submission failed in validating AM resource request\"\n             + \" for application \" + applicationId, e);\n         throw e;\n       }\n     }\n \n     // Create RMApp\n     RMApp application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType());\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n \n     try {\n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }\n     } catch (IOException ie) {\n       LOG.warn(\n           \"Unable to add the application to the delegation token renewer.\",\n           ie);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we havne\u0027t yet informed the\n       // Scheduler about the existence of the application\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppRejectedEvent(applicationId, ie.getMessage()));\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n-    // All done, start the RMApp\n-    this.rmContext.getDispatcher().getEventHandler().handle(\n-        new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n-            RMAppEventType.START));\n+    if (!isRecovered) {\n+      // All done, start the RMApp\n+      this.rmContext.getDispatcher().getEventHandler()\n+        .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      boolean isRecovered, String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    // Validation of the ApplicationSubmissionContext needs to be completed\n    // here. Only those fields that are dependent on RM\u0027s configuration are\n    // checked here as they have to be validated whether they are part of new\n    // submission or just being recovered.\n\n    // Check whether AM resource requirements are within required limits\n    if (!submissionContext.getUnmanagedAM()) {\n      ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n          RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n          submissionContext.getResource(), 1);\n      try {\n        SchedulerUtils.validateResourceRequest(amReq,\n            scheduler.getMaximumResourceCapability());\n      } catch (InvalidResourceRequestException e) {\n        LOG.warn(\"RM app submission failed in validating AM resource request\"\n            + \" for application \" + applicationId, e);\n        throw e;\n      }\n    }\n\n    // Create RMApp\n    RMApp application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType());\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n\n    try {\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }\n    } catch (IOException ie) {\n      LOG.warn(\n          \"Unable to add the application to the delegation token renewer.\",\n          ie);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we havne\u0027t yet informed the\n      // Scheduler about the existence of the application\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId, ie.getMessage()));\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    if (!isRecovered) {\n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler()\n        .handle(new RMAppEvent(applicationId, RMAppEventType.START));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "c6c41abf683be17c3917a7f94953b55347aaa69f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-737. Throw some specific exceptions directly instead of wrapping them in YarnException. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1491896 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/06/13 11:47 AM",
      "commitName": "c6c41abf683be17c3917a7f94953b55347aaa69f",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "03/06/13 9:05 PM",
      "commitNameOld": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 7.61,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       boolean isRecovered, String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     // Validation of the ApplicationSubmissionContext needs to be completed\n     // here. Only those fields that are dependent on RM\u0027s configuration are\n     // checked here as they have to be validated whether they are part of new\n     // submission or just being recovered.\n \n     // Check whether AM resource requirements are within required limits\n     if (!submissionContext.getUnmanagedAM()) {\n       ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n           RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n           submissionContext.getResource(), 1);\n       try {\n         SchedulerUtils.validateResourceRequest(amReq,\n             scheduler.getMaximumResourceCapability());\n       } catch (InvalidResourceRequestException e) {\n         LOG.warn(\"RM app submission failed in validating AM resource request\"\n             + \" for application \" + applicationId, e);\n-        throw RPCUtil.getRemoteException(e);\n+        throw e;\n       }\n     }\n \n     // Create RMApp\n     RMApp application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType());\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n \n     try {\n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }\n     } catch (IOException ie) {\n       LOG.warn(\n           \"Unable to add the application to the delegation token renewer.\",\n           ie);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we havne\u0027t yet informed the\n       // Scheduler about the existence of the application\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppRejectedEvent(applicationId, ie.getMessage()));\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     // All done, start the RMApp\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n             RMAppEventType.START));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      boolean isRecovered, String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    // Validation of the ApplicationSubmissionContext needs to be completed\n    // here. Only those fields that are dependent on RM\u0027s configuration are\n    // checked here as they have to be validated whether they are part of new\n    // submission or just being recovered.\n\n    // Check whether AM resource requirements are within required limits\n    if (!submissionContext.getUnmanagedAM()) {\n      ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n          RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n          submissionContext.getResource(), 1);\n      try {\n        SchedulerUtils.validateResourceRequest(amReq,\n            scheduler.getMaximumResourceCapability());\n      } catch (InvalidResourceRequestException e) {\n        LOG.warn(\"RM app submission failed in validating AM resource request\"\n            + \" for application \" + applicationId, e);\n        throw e;\n      }\n    }\n\n    // Create RMApp\n    RMApp application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType());\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n\n    try {\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }\n    } catch (IOException ie) {\n      LOG.warn(\n          \"Unable to add the application to the delegation token renewer.\",\n          ie);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we havne\u0027t yet informed the\n      // Scheduler about the existence of the application\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId, ie.getMessage()));\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    // All done, start the RMApp\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n            RMAppEventType.START));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "a83fb61ac07c0468cbc7a38526e92683883dd932": {
      "type": "Yexceptionschange",
      "commitMessage": "YARN-635. Renamed YarnRemoteException to YarnException. Contributed by Siddharth Seth.\nMAPREDUCE-5301. Updated MR code to work with YARN-635 changes of renaming YarnRemoteException to YarnException. Contributed by Siddharth Seth\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 9:05 PM",
      "commitName": "a83fb61ac07c0468cbc7a38526e92683883dd932",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "03/06/13 5:34 PM",
      "commitNameOld": "d33534c4fb35cb82ff8d56abeeb63a949e72a031",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.15,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      boolean isRecovered, String user) throws YarnRemoteException {\n+      boolean isRecovered, String user) throws YarnException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     // Validation of the ApplicationSubmissionContext needs to be completed\n     // here. Only those fields that are dependent on RM\u0027s configuration are\n     // checked here as they have to be validated whether they are part of new\n     // submission or just being recovered.\n \n     // Check whether AM resource requirements are within required limits\n     if (!submissionContext.getUnmanagedAM()) {\n       ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n           RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n           submissionContext.getResource(), 1);\n       try {\n         SchedulerUtils.validateResourceRequest(amReq,\n             scheduler.getMaximumResourceCapability());\n       } catch (InvalidResourceRequestException e) {\n         LOG.warn(\"RM app submission failed in validating AM resource request\"\n             + \" for application \" + applicationId, e);\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n \n     // Create RMApp\n     RMApp application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType());\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n \n     try {\n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }\n     } catch (IOException ie) {\n       LOG.warn(\n           \"Unable to add the application to the delegation token renewer.\",\n           ie);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we havne\u0027t yet informed the\n       // Scheduler about the existence of the application\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppRejectedEvent(applicationId, ie.getMessage()));\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     // All done, start the RMApp\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n             RMAppEventType.START));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      boolean isRecovered, String user) throws YarnException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    // Validation of the ApplicationSubmissionContext needs to be completed\n    // here. Only those fields that are dependent on RM\u0027s configuration are\n    // checked here as they have to be validated whether they are part of new\n    // submission or just being recovered.\n\n    // Check whether AM resource requirements are within required limits\n    if (!submissionContext.getUnmanagedAM()) {\n      ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n          RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n          submissionContext.getResource(), 1);\n      try {\n        SchedulerUtils.validateResourceRequest(amReq,\n            scheduler.getMaximumResourceCapability());\n      } catch (InvalidResourceRequestException e) {\n        LOG.warn(\"RM app submission failed in validating AM resource request\"\n            + \" for application \" + applicationId, e);\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    // Create RMApp\n    RMApp application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType());\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n\n    try {\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }\n    } catch (IOException ie) {\n      LOG.warn(\n          \"Unable to add the application to the delegation token renewer.\",\n          ie);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we havne\u0027t yet informed the\n      // Scheduler about the existence of the application\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId, ie.getMessage()));\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    // All done, start the RMApp\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n            RMAppEventType.START));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {
        "oldValue": "[YarnRemoteException]",
        "newValue": "[YarnException]"
      }
    },
    "259edf8dca44de54033e96f7eb65a83aaa6096f2": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-571. Remove user from ContainerLaunchContext. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1485928 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/13 8:22 PM",
      "commitName": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-571. Remove user from ContainerLaunchContext. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1485928 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/05/13 8:22 PM",
          "commitName": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "23/05/13 11:02 AM",
          "commitNameOld": "43876770d91a374563bf3379a5ffab5c2bac2264",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.39,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,73 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      boolean isRecovered) throws YarnRemoteException {\n+      boolean isRecovered, String user) throws YarnRemoteException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     // Validation of the ApplicationSubmissionContext needs to be completed\n     // here. Only those fields that are dependent on RM\u0027s configuration are\n     // checked here as they have to be validated whether they are part of new\n     // submission or just being recovered.\n \n     // Check whether AM resource requirements are within required limits\n     if (!submissionContext.getUnmanagedAM()) {\n       ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n           RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n           submissionContext.getResource(), 1);\n       try {\n         SchedulerUtils.validateResourceRequest(amReq,\n             scheduler.getMaximumResourceCapability());\n       } catch (InvalidResourceRequestException e) {\n         LOG.warn(\"RM app submission failed in validating AM resource request\"\n             + \" for application \" + applicationId, e);\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n \n     // Create RMApp\n     RMApp application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n-            submissionContext.getApplicationName(),\n-            submissionContext.getAMContainerSpec().getUser(),\n+            submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType());\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n \n     try {\n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }\n     } catch (IOException ie) {\n       LOG.warn(\n           \"Unable to add the application to the delegation token renewer.\",\n           ie);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we havne\u0027t yet informed the\n       // Scheduler about the existence of the application\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppRejectedEvent(applicationId, ie.getMessage()));\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     // All done, start the RMApp\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n             RMAppEventType.START));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      boolean isRecovered, String user) throws YarnRemoteException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    // Validation of the ApplicationSubmissionContext needs to be completed\n    // here. Only those fields that are dependent on RM\u0027s configuration are\n    // checked here as they have to be validated whether they are part of new\n    // submission or just being recovered.\n\n    // Check whether AM resource requirements are within required limits\n    if (!submissionContext.getUnmanagedAM()) {\n      ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n          RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n          submissionContext.getResource(), 1);\n      try {\n        SchedulerUtils.validateResourceRequest(amReq,\n            scheduler.getMaximumResourceCapability());\n      } catch (InvalidResourceRequestException e) {\n        LOG.warn(\"RM app submission failed in validating AM resource request\"\n            + \" for application \" + applicationId, e);\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    // Create RMApp\n    RMApp application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType());\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n\n    try {\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }\n    } catch (IOException ie) {\n      LOG.warn(\n          \"Unable to add the application to the delegation token renewer.\",\n          ie);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we havne\u0027t yet informed the\n      // Scheduler about the existence of the application\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId, ie.getMessage()));\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    // All done, start the RMApp\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n            RMAppEventType.START));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, isRecovered-boolean]",
            "newValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, isRecovered-boolean, user-String]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-571. Remove user from ContainerLaunchContext. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1485928 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "23/05/13 8:22 PM",
          "commitName": "259edf8dca44de54033e96f7eb65a83aaa6096f2",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "23/05/13 11:02 AM",
          "commitNameOld": "43876770d91a374563bf3379a5ffab5c2bac2264",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 0.39,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,74 +1,73 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      boolean isRecovered) throws YarnRemoteException {\n+      boolean isRecovered, String user) throws YarnRemoteException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     // Validation of the ApplicationSubmissionContext needs to be completed\n     // here. Only those fields that are dependent on RM\u0027s configuration are\n     // checked here as they have to be validated whether they are part of new\n     // submission or just being recovered.\n \n     // Check whether AM resource requirements are within required limits\n     if (!submissionContext.getUnmanagedAM()) {\n       ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n           RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n           submissionContext.getResource(), 1);\n       try {\n         SchedulerUtils.validateResourceRequest(amReq,\n             scheduler.getMaximumResourceCapability());\n       } catch (InvalidResourceRequestException e) {\n         LOG.warn(\"RM app submission failed in validating AM resource request\"\n             + \" for application \" + applicationId, e);\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n \n     // Create RMApp\n     RMApp application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n-            submissionContext.getApplicationName(),\n-            submissionContext.getAMContainerSpec().getUser(),\n+            submissionContext.getApplicationName(), user,\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime, submissionContext.getApplicationType());\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n \n     try {\n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }\n     } catch (IOException ie) {\n       LOG.warn(\n           \"Unable to add the application to the delegation token renewer.\",\n           ie);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we havne\u0027t yet informed the\n       // Scheduler about the existence of the application\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppRejectedEvent(applicationId, ie.getMessage()));\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     // All done, start the RMApp\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n             RMAppEventType.START));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      boolean isRecovered, String user) throws YarnRemoteException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    // Validation of the ApplicationSubmissionContext needs to be completed\n    // here. Only those fields that are dependent on RM\u0027s configuration are\n    // checked here as they have to be validated whether they are part of new\n    // submission or just being recovered.\n\n    // Check whether AM resource requirements are within required limits\n    if (!submissionContext.getUnmanagedAM()) {\n      ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n          RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n          submissionContext.getResource(), 1);\n      try {\n        SchedulerUtils.validateResourceRequest(amReq,\n            scheduler.getMaximumResourceCapability());\n      } catch (InvalidResourceRequestException e) {\n        LOG.warn(\"RM app submission failed in validating AM resource request\"\n            + \" for application \" + applicationId, e);\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    // Create RMApp\n    RMApp application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(), user,\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType());\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n\n    try {\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }\n    } catch (IOException ie) {\n      LOG.warn(\n          \"Unable to add the application to the delegation token renewer.\",\n          ie);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we havne\u0027t yet informed the\n      // Scheduler about the existence of the application\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId, ie.getMessage()));\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    // All done, start the RMApp\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n            RMAppEventType.START));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "43876770d91a374563bf3379a5ffab5c2bac2264": {
      "type": "Ybodychange",
      "commitMessage": "YARN-563. Add the concept of an application-type for each application. Contributed by Mayank Bansal.\nMAPREDUCE-5246. Specify application-type at the time of job submission after YARN-563. Contributed by Mayank Bansal.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1485790 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/05/13 11:02 AM",
      "commitName": "43876770d91a374563bf3379a5ffab5c2bac2264",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/05/13 9:11 PM",
      "commitNameOld": "1a119f87b4f0a78d56e1bb998b1cbc081484fbd1",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 9.58,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,74 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n       boolean isRecovered) throws YarnRemoteException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n \n     // Validation of the ApplicationSubmissionContext needs to be completed\n     // here. Only those fields that are dependent on RM\u0027s configuration are\n     // checked here as they have to be validated whether they are part of new\n     // submission or just being recovered.\n \n     // Check whether AM resource requirements are within required limits\n     if (!submissionContext.getUnmanagedAM()) {\n       ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n           RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n           submissionContext.getResource(), 1);\n       try {\n         SchedulerUtils.validateResourceRequest(amReq,\n             scheduler.getMaximumResourceCapability());\n       } catch (InvalidResourceRequestException e) {\n         LOG.warn(\"RM app submission failed in validating AM resource request\"\n             + \" for application \" + applicationId, e);\n         throw RPCUtil.getRemoteException(e);\n       }\n     }\n \n     // Create RMApp\n     RMApp application \u003d\n         new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(),\n             submissionContext.getAMContainerSpec().getUser(),\n             submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n-            submitTime);\n+            submitTime, submissionContext.getApplicationType());\n \n     // Concurrent app submissions with same applicationId will fail here\n     // Concurrent app submissions with different applicationIds will not\n     // influence each other\n     if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n         null) {\n       String message \u003d \"Application with id \" + applicationId\n           + \" is already present! Cannot add a duplicate!\";\n       LOG.warn(message);\n       throw RPCUtil.getRemoteException(message);\n     }\n \n     // Inform the ACLs Manager\n     this.applicationACLsManager.addApplication(applicationId,\n         submissionContext.getAMContainerSpec().getApplicationACLs());\n \n     try {\n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }\n     } catch (IOException ie) {\n       LOG.warn(\n           \"Unable to add the application to the delegation token renewer.\",\n           ie);\n       // Sending APP_REJECTED is fine, since we assume that the\n       // RMApp is in NEW state and thus we havne\u0027t yet informed the\n       // Scheduler about the existence of the application\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppRejectedEvent(applicationId, ie.getMessage()));\n       throw RPCUtil.getRemoteException(ie);\n     }\n \n     // All done, start the RMApp\n     this.rmContext.getDispatcher().getEventHandler().handle(\n         new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n             RMAppEventType.START));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      boolean isRecovered) throws YarnRemoteException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    // Validation of the ApplicationSubmissionContext needs to be completed\n    // here. Only those fields that are dependent on RM\u0027s configuration are\n    // checked here as they have to be validated whether they are part of new\n    // submission or just being recovered.\n\n    // Check whether AM resource requirements are within required limits\n    if (!submissionContext.getUnmanagedAM()) {\n      ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n          RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n          submissionContext.getResource(), 1);\n      try {\n        SchedulerUtils.validateResourceRequest(amReq,\n            scheduler.getMaximumResourceCapability());\n      } catch (InvalidResourceRequestException e) {\n        LOG.warn(\"RM app submission failed in validating AM resource request\"\n            + \" for application \" + applicationId, e);\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    // Create RMApp\n    RMApp application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(),\n            submissionContext.getAMContainerSpec().getUser(),\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime, submissionContext.getApplicationType());\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n\n    try {\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }\n    } catch (IOException ie) {\n      LOG.warn(\n          \"Unable to add the application to the delegation token renewer.\",\n          ie);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we havne\u0027t yet informed the\n      // Scheduler about the existence of the application\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId, ie.getMessage()));\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    // All done, start the RMApp\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n            RMAppEventType.START));\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "6de09af24487e2ff5bc22c7b1a07348c7119de80": {
      "type": "Ymultichange(Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-599. Refactoring submitApplication in ClientRMService and RMAppManager to separate out various validation checks depending on whether they rely on RM configuration or not. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1477478 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/04/13 10:44 PM",
      "commitName": "6de09af24487e2ff5bc22c7b1a07348c7119de80",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-599. Refactoring submitApplication in ClientRMService and RMAppManager to separate out various validation checks depending on whether they rely on RM configuration or not. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1477478 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/04/13 10:44 PM",
          "commitName": "6de09af24487e2ff5bc22c7b1a07348c7119de80",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "20/04/13 3:04 PM",
          "commitNameOld": "e24a9b83f137c7a27d57934580140693b5a86826",
          "commitAuthorOld": "Bikas Saha",
          "daysBetweenCommits": 9.32,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,74 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      boolean isRecovered) {\n+      boolean isRecovered) throws YarnRemoteException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n-    RMApp application \u003d null;\n+\n+    // Validation of the ApplicationSubmissionContext needs to be completed\n+    // here. Only those fields that are dependent on RM\u0027s configuration are\n+    // checked here as they have to be validated whether they are part of new\n+    // submission or just being recovered.\n+\n+    // Check whether AM resource requirements are within required limits\n+    if (!submissionContext.getUnmanagedAM()) {\n+      ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n+          RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n+          submissionContext.getResource(), 1);\n+      try {\n+        SchedulerUtils.validateResourceRequest(amReq,\n+            scheduler.getMaximumResourceCapability());\n+      } catch (InvalidResourceRequestException e) {\n+        LOG.warn(\"RM app submission failed in validating AM resource request\"\n+            + \" for application \" + applicationId, e);\n+        throw RPCUtil.getRemoteException(e);\n+      }\n+    }\n+\n+    // Create RMApp\n+    RMApp application \u003d\n+        new RMAppImpl(applicationId, rmContext, this.conf,\n+            submissionContext.getApplicationName(),\n+            submissionContext.getAMContainerSpec().getUser(),\n+            submissionContext.getQueue(),\n+            submissionContext, this.scheduler, this.masterService,\n+            submitTime);\n+\n+    // Concurrent app submissions with same applicationId will fail here\n+    // Concurrent app submissions with different applicationIds will not\n+    // influence each other\n+    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n+        null) {\n+      String message \u003d \"Application with id \" + applicationId\n+          + \" is already present! Cannot add a duplicate!\";\n+      LOG.warn(message);\n+      throw RPCUtil.getRemoteException(message);\n+    }\n+\n+    // Inform the ACLs Manager\n+    this.applicationACLsManager.addApplication(applicationId,\n+        submissionContext.getAMContainerSpec().getApplicationACLs());\n+\n     try {\n-\n-      // Sanity checks\n-      if (submissionContext.getQueue() \u003d\u003d null) {\n-        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n-      }\n-      if (submissionContext.getApplicationName() \u003d\u003d null) {\n-        submissionContext.setApplicationName(\n-            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n-      }\n-\n-      // Create RMApp\n-      application \u003d\n-          new RMAppImpl(applicationId, rmContext, this.conf,\n-              submissionContext.getApplicationName(),\n-              submissionContext.getAMContainerSpec().getUser(),\n-              submissionContext.getQueue(),\n-              submissionContext, this.scheduler, this.masterService,\n-              submitTime);\n-\n-      // Sanity check - duplicate?\n-      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n-          null) {\n-        String message \u003d \"Application with id \" + applicationId\n-            + \" is already present! Cannot add a duplicate!\";\n-        LOG.info(message);\n-        throw RPCUtil.getRemoteException(message);\n-      } \n-\n-      // Inform the ACLs Manager\n-      this.applicationACLsManager.addApplication(applicationId,\n-          submissionContext.getAMContainerSpec().getApplicationACLs());\n-\n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n-      }      \n-      \n-      // All done, start the RMApp\n-      this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n-            RMAppEventType.START));\n+      }\n     } catch (IOException ie) {\n-        LOG.info(\"RMAppManager submit application exception\", ie);\n-        if (application !\u003d null) {\n-          // Sending APP_REJECTED is fine, since we assume that the \n-          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n-          // Scheduler about the existence of the application\n-          this.rmContext.getDispatcher().getEventHandler().handle(\n-              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n-        }\n+      LOG.warn(\n+          \"Unable to add the application to the delegation token renewer.\",\n+          ie);\n+      // Sending APP_REJECTED is fine, since we assume that the\n+      // RMApp is in NEW state and thus we havne\u0027t yet informed the\n+      // Scheduler about the existence of the application\n+      this.rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppRejectedEvent(applicationId, ie.getMessage()));\n+      throw RPCUtil.getRemoteException(ie);\n     }\n+\n+    // All done, start the RMApp\n+    this.rmContext.getDispatcher().getEventHandler().handle(\n+        new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n+            RMAppEventType.START));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      boolean isRecovered) throws YarnRemoteException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    // Validation of the ApplicationSubmissionContext needs to be completed\n    // here. Only those fields that are dependent on RM\u0027s configuration are\n    // checked here as they have to be validated whether they are part of new\n    // submission or just being recovered.\n\n    // Check whether AM resource requirements are within required limits\n    if (!submissionContext.getUnmanagedAM()) {\n      ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n          RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n          submissionContext.getResource(), 1);\n      try {\n        SchedulerUtils.validateResourceRequest(amReq,\n            scheduler.getMaximumResourceCapability());\n      } catch (InvalidResourceRequestException e) {\n        LOG.warn(\"RM app submission failed in validating AM resource request\"\n            + \" for application \" + applicationId, e);\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    // Create RMApp\n    RMApp application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(),\n            submissionContext.getAMContainerSpec().getUser(),\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n\n    try {\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }\n    } catch (IOException ie) {\n      LOG.warn(\n          \"Unable to add the application to the delegation token renewer.\",\n          ie);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we havne\u0027t yet informed the\n      // Scheduler about the existence of the application\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId, ie.getMessage()));\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    // All done, start the RMApp\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n            RMAppEventType.START));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[YarnRemoteException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-599. Refactoring submitApplication in ClientRMService and RMAppManager to separate out various validation checks depending on whether they rely on RM configuration or not. Contributed by Zhijie Shen.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1477478 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/04/13 10:44 PM",
          "commitName": "6de09af24487e2ff5bc22c7b1a07348c7119de80",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "20/04/13 3:04 PM",
          "commitNameOld": "e24a9b83f137c7a27d57934580140693b5a86826",
          "commitAuthorOld": "Bikas Saha",
          "daysBetweenCommits": 9.32,
          "commitsBetweenForRepo": 56,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,61 +1,74 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime,\n-      boolean isRecovered) {\n+      boolean isRecovered) throws YarnRemoteException {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n-    RMApp application \u003d null;\n+\n+    // Validation of the ApplicationSubmissionContext needs to be completed\n+    // here. Only those fields that are dependent on RM\u0027s configuration are\n+    // checked here as they have to be validated whether they are part of new\n+    // submission or just being recovered.\n+\n+    // Check whether AM resource requirements are within required limits\n+    if (!submissionContext.getUnmanagedAM()) {\n+      ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n+          RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n+          submissionContext.getResource(), 1);\n+      try {\n+        SchedulerUtils.validateResourceRequest(amReq,\n+            scheduler.getMaximumResourceCapability());\n+      } catch (InvalidResourceRequestException e) {\n+        LOG.warn(\"RM app submission failed in validating AM resource request\"\n+            + \" for application \" + applicationId, e);\n+        throw RPCUtil.getRemoteException(e);\n+      }\n+    }\n+\n+    // Create RMApp\n+    RMApp application \u003d\n+        new RMAppImpl(applicationId, rmContext, this.conf,\n+            submissionContext.getApplicationName(),\n+            submissionContext.getAMContainerSpec().getUser(),\n+            submissionContext.getQueue(),\n+            submissionContext, this.scheduler, this.masterService,\n+            submitTime);\n+\n+    // Concurrent app submissions with same applicationId will fail here\n+    // Concurrent app submissions with different applicationIds will not\n+    // influence each other\n+    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n+        null) {\n+      String message \u003d \"Application with id \" + applicationId\n+          + \" is already present! Cannot add a duplicate!\";\n+      LOG.warn(message);\n+      throw RPCUtil.getRemoteException(message);\n+    }\n+\n+    // Inform the ACLs Manager\n+    this.applicationACLsManager.addApplication(applicationId,\n+        submissionContext.getAMContainerSpec().getApplicationACLs());\n+\n     try {\n-\n-      // Sanity checks\n-      if (submissionContext.getQueue() \u003d\u003d null) {\n-        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n-      }\n-      if (submissionContext.getApplicationName() \u003d\u003d null) {\n-        submissionContext.setApplicationName(\n-            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n-      }\n-\n-      // Create RMApp\n-      application \u003d\n-          new RMAppImpl(applicationId, rmContext, this.conf,\n-              submissionContext.getApplicationName(),\n-              submissionContext.getAMContainerSpec().getUser(),\n-              submissionContext.getQueue(),\n-              submissionContext, this.scheduler, this.masterService,\n-              submitTime);\n-\n-      // Sanity check - duplicate?\n-      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n-          null) {\n-        String message \u003d \"Application with id \" + applicationId\n-            + \" is already present! Cannot add a duplicate!\";\n-        LOG.info(message);\n-        throw RPCUtil.getRemoteException(message);\n-      } \n-\n-      // Inform the ACLs Manager\n-      this.applicationACLsManager.addApplication(applicationId,\n-          submissionContext.getAMContainerSpec().getApplicationACLs());\n-\n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n-      }      \n-      \n-      // All done, start the RMApp\n-      this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n-            RMAppEventType.START));\n+      }\n     } catch (IOException ie) {\n-        LOG.info(\"RMAppManager submit application exception\", ie);\n-        if (application !\u003d null) {\n-          // Sending APP_REJECTED is fine, since we assume that the \n-          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n-          // Scheduler about the existence of the application\n-          this.rmContext.getDispatcher().getEventHandler().handle(\n-              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n-        }\n+      LOG.warn(\n+          \"Unable to add the application to the delegation token renewer.\",\n+          ie);\n+      // Sending APP_REJECTED is fine, since we assume that the\n+      // RMApp is in NEW state and thus we havne\u0027t yet informed the\n+      // Scheduler about the existence of the application\n+      this.rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppRejectedEvent(applicationId, ie.getMessage()));\n+      throw RPCUtil.getRemoteException(ie);\n     }\n+\n+    // All done, start the RMApp\n+    this.rmContext.getDispatcher().getEventHandler().handle(\n+        new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n+            RMAppEventType.START));\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      boolean isRecovered) throws YarnRemoteException {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n\n    // Validation of the ApplicationSubmissionContext needs to be completed\n    // here. Only those fields that are dependent on RM\u0027s configuration are\n    // checked here as they have to be validated whether they are part of new\n    // submission or just being recovered.\n\n    // Check whether AM resource requirements are within required limits\n    if (!submissionContext.getUnmanagedAM()) {\n      ResourceRequest amReq \u003d BuilderUtils.newResourceRequest(\n          RMAppAttemptImpl.AM_CONTAINER_PRIORITY, ResourceRequest.ANY,\n          submissionContext.getResource(), 1);\n      try {\n        SchedulerUtils.validateResourceRequest(amReq,\n            scheduler.getMaximumResourceCapability());\n      } catch (InvalidResourceRequestException e) {\n        LOG.warn(\"RM app submission failed in validating AM resource request\"\n            + \" for application \" + applicationId, e);\n        throw RPCUtil.getRemoteException(e);\n      }\n    }\n\n    // Create RMApp\n    RMApp application \u003d\n        new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(),\n            submissionContext.getAMContainerSpec().getUser(),\n            submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime);\n\n    // Concurrent app submissions with same applicationId will fail here\n    // Concurrent app submissions with different applicationIds will not\n    // influence each other\n    if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d\n        null) {\n      String message \u003d \"Application with id \" + applicationId\n          + \" is already present! Cannot add a duplicate!\";\n      LOG.warn(message);\n      throw RPCUtil.getRemoteException(message);\n    }\n\n    // Inform the ACLs Manager\n    this.applicationACLsManager.addApplication(applicationId,\n        submissionContext.getAMContainerSpec().getApplicationACLs());\n\n    try {\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }\n    } catch (IOException ie) {\n      LOG.warn(\n          \"Unable to add the application to the delegation token renewer.\",\n          ie);\n      // Sending APP_REJECTED is fine, since we assume that the\n      // RMApp is in NEW state and thus we havne\u0027t yet informed the\n      // Scheduler about the existence of the application\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppRejectedEvent(applicationId, ie.getMessage()));\n      throw RPCUtil.getRemoteException(ie);\n    }\n\n    // All done, start the RMApp\n    this.rmContext.getDispatcher().getEventHandler().handle(\n        new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n            RMAppEventType.START));\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "ef9f251679d7e87698eecd6a119652900274a172": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-514.Delayed store operations should not result in RM unavailability for app submission (Zhijie Shen via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469059 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/04/13 1:19 PM",
      "commitName": "ef9f251679d7e87698eecd6a119652900274a172",
      "commitAuthor": "Bikas Saha",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-514.Delayed store operations should not result in RM unavailability for app submission (Zhijie Shen via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469059 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/04/13 1:19 PM",
          "commitName": "ef9f251679d7e87698eecd6a119652900274a172",
          "commitAuthor": "Bikas Saha",
          "commitDateOld": "11/04/13 12:28 PM",
          "commitNameOld": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 6.04,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,61 @@\n   protected void submitApplication(\n-      ApplicationSubmissionContext submissionContext, long submitTime) {\n+      ApplicationSubmissionContext submissionContext, long submitTime,\n+      boolean isRecovered) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Create RMApp\n       application \u003d\n           new RMAppImpl(applicationId, rmContext, this.conf,\n               submissionContext.getApplicationName(),\n               submissionContext.getAMContainerSpec().getUser(),\n               submissionContext.getQueue(),\n               submissionContext, this.scheduler, this.masterService,\n               submitTime);\n \n       // Sanity check - duplicate?\n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } \n \n       // Inform the ACLs Manager\n       this.applicationACLsManager.addApplication(applicationId,\n           submissionContext.getAMContainerSpec().getApplicationACLs());\n \n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }      \n       \n       // All done, start the RMApp\n       this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppEvent(applicationId, RMAppEventType.START));\n+          new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n+            RMAppEventType.START));\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           // Sending APP_REJECTED is fine, since we assume that the \n           // RMApp is in NEW state and thus we havne\u0027t yet informed the \n           // Scheduler about the existence of the application\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      boolean isRecovered) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n\n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Create RMApp\n      application \u003d\n          new RMAppImpl(applicationId, rmContext, this.conf,\n              submissionContext.getApplicationName(),\n              submissionContext.getAMContainerSpec().getUser(),\n              submissionContext.getQueue(),\n              submissionContext, this.scheduler, this.masterService,\n              submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n            RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long]",
            "newValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long, isRecovered-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-514.Delayed store operations should not result in RM unavailability for app submission (Zhijie Shen via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469059 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "17/04/13 1:19 PM",
          "commitName": "ef9f251679d7e87698eecd6a119652900274a172",
          "commitAuthor": "Bikas Saha",
          "commitDateOld": "11/04/13 12:28 PM",
          "commitNameOld": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
          "commitAuthorOld": "Vinod Kumar Vavilapalli",
          "daysBetweenCommits": 6.04,
          "commitsBetweenForRepo": 26,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,61 @@\n   protected void submitApplication(\n-      ApplicationSubmissionContext submissionContext, long submitTime) {\n+      ApplicationSubmissionContext submissionContext, long submitTime,\n+      boolean isRecovered) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Create RMApp\n       application \u003d\n           new RMAppImpl(applicationId, rmContext, this.conf,\n               submissionContext.getApplicationName(),\n               submissionContext.getAMContainerSpec().getUser(),\n               submissionContext.getQueue(),\n               submissionContext, this.scheduler, this.masterService,\n               submitTime);\n \n       // Sanity check - duplicate?\n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } \n \n       // Inform the ACLs Manager\n       this.applicationACLsManager.addApplication(applicationId,\n           submissionContext.getAMContainerSpec().getApplicationACLs());\n \n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }      \n       \n       // All done, start the RMApp\n       this.rmContext.getDispatcher().getEventHandler().handle(\n-          new RMAppEvent(applicationId, RMAppEventType.START));\n+          new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n+            RMAppEventType.START));\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           // Sending APP_REJECTED is fine, since we assume that the \n           // RMApp is in NEW state and thus we havne\u0027t yet informed the \n           // Scheduler about the existence of the application\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime,\n      boolean isRecovered) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n\n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Create RMApp\n      application \u003d\n          new RMAppImpl(applicationId, rmContext, this.conf,\n              submissionContext.getApplicationName(),\n              submissionContext.getAMContainerSpec().getUser(),\n              submissionContext.getQueue(),\n              submissionContext, this.scheduler, this.masterService,\n              submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, isRecovered ? RMAppEventType.RECOVER:\n            RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-486. Changed NM\u0027s startContainer API to accept Container record given by RM as a direct parameter instead of as part of the ContainerLaunchContext record. Contributed by Xuan Gong.\nMAPREDUCE-5139. Update MR AM to use the modified startContainer API after YARN-486. Contributed by Xuan Gong.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1467063 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/04/13 12:28 PM",
      "commitName": "e4c55e17fea55e2fcbef182bb2b0c4b22686f38c",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "09/04/13 1:16 PM",
      "commitNameOld": "7d00d3d20fc33e2de85f3864e8a1ad68695c526e",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.97,
      "commitsBetweenForRepo": 14,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,59 @@\n   protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Create RMApp\n       application \u003d\n           new RMAppImpl(applicationId, rmContext, this.conf,\n-            submissionContext.getApplicationName(),\n-            submissionContext.getUser(), submissionContext.getQueue(),\n-            submissionContext, this.scheduler, this.masterService,\n-            submitTime);\n+              submissionContext.getApplicationName(),\n+              submissionContext.getAMContainerSpec().getUser(),\n+              submissionContext.getQueue(),\n+              submissionContext, this.scheduler, this.masterService,\n+              submitTime);\n \n       // Sanity check - duplicate?\n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } \n \n       // Inform the ACLs Manager\n       this.applicationACLsManager.addApplication(applicationId,\n           submissionContext.getAMContainerSpec().getApplicationACLs());\n \n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }      \n       \n       // All done, start the RMApp\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppEvent(applicationId, RMAppEventType.START));\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           // Sending APP_REJECTED is fine, since we assume that the \n           // RMApp is in NEW state and thus we havne\u0027t yet informed the \n           // Scheduler about the existence of the application\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n\n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Create RMApp\n      application \u003d\n          new RMAppImpl(applicationId, rmContext, this.conf,\n              submissionContext.getApplicationName(),\n              submissionContext.getAMContainerSpec().getUser(),\n              submissionContext.getQueue(),\n              submissionContext, this.scheduler, this.masterService,\n              submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "d27291842605555f6727faa4454211f55da28cca": {
      "type": "Ymodifierchange",
      "commitMessage": "YARN-357. App submission should not be synchronized (daryn)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1443016 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/02/13 7:26 AM",
      "commitName": "d27291842605555f6727faa4454211f55da28cca",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "15/01/13 10:33 AM",
      "commitNameOld": "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 21.87,
      "commitsBetweenForRepo": 98,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,58 @@\n-  protected synchronized void submitApplication(\n+  protected void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Create RMApp\n       application \u003d\n           new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(),\n             submissionContext.getUser(), submissionContext.getQueue(),\n             submissionContext, this.scheduler, this.masterService,\n             submitTime);\n \n       // Sanity check - duplicate?\n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } \n \n       // Inform the ACLs Manager\n       this.applicationACLsManager.addApplication(applicationId,\n           submissionContext.getAMContainerSpec().getApplicationACLs());\n \n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }      \n       \n       // All done, start the RMApp\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppEvent(applicationId, RMAppEventType.START));\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           // Sending APP_REJECTED is fine, since we assume that the \n           // RMApp is in NEW state and thus we havne\u0027t yet informed the \n           // Scheduler about the existence of the application\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n\n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Create RMApp\n      application \u003d\n          new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(),\n            submissionContext.getUser(), submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {
        "oldValue": "[protected, synchronized]",
        "newValue": "[protected]"
      }
    },
    "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-135. Client tokens should be per app-attempt, and should be unregistered on App-finish. Contributed by Vinod Kumar Vavilapalli\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1433570 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/01/13 10:33 AM",
      "commitName": "6a2f2551fd13f6d3c932cc9b592e2a23b616a7f5",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "18/12/12 8:21 PM",
      "commitNameOld": "6cd0736cc57849e4f7c5d38a3986432a9717fe39",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 27.59,
      "commitsBetweenForRepo": 127,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,58 @@\n   protected synchronized void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n \n-      String clientTokenStr \u003d null;\n-      if (UserGroupInformation.isSecurityEnabled()) {\n-\n-        // TODO: This needs to move to per-AppAttempt\n-        this.rmContext.getClientToAMTokenSecretManager().registerApplication(\n-          applicationId);\n-\n-        Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n-            Token\u003cClientTokenIdentifier\u003e(\n-            new ClientTokenIdentifier(applicationId),\n-            this.rmContext.getClientToAMTokenSecretManager());\n-        clientTokenStr \u003d clientToken.encodeToUrlString();\n-        LOG.debug(\"Sending client token as \" + clientTokenStr);\n-      }\n-      \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Create RMApp\n       application \u003d\n           new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(),\n             submissionContext.getUser(), submissionContext.getQueue(),\n-            submissionContext, clientTokenStr, this.scheduler,\n-            this.masterService, submitTime);\n+            submissionContext, this.scheduler, this.masterService,\n+            submitTime);\n \n       // Sanity check - duplicate?\n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } \n \n       // Inform the ACLs Manager\n       this.applicationACLsManager.addApplication(applicationId,\n           submissionContext.getAMContainerSpec().getApplicationACLs());\n \n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }      \n       \n       // All done, start the RMApp\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppEvent(applicationId, RMAppEventType.START));\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           // Sending APP_REJECTED is fine, since we assume that the \n           // RMApp is in NEW state and thus we havne\u0027t yet informed the \n           // Scheduler about the existence of the application\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n\n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Create RMApp\n      application \u003d\n          new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(),\n            submissionContext.getUser(), submissionContext.getQueue(),\n            submissionContext, this.scheduler, this.masterService,\n            submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "1943fdbec613715f3cdc3ca60cbd273115f28299": {
      "type": "Ybodychange",
      "commitMessage": "YARN-229. Remove old unused RM recovery code. Contributed by Bikas Saha.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1415029 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/11/12 5:56 PM",
      "commitName": "1943fdbec613715f3cdc3ca60cbd273115f28299",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "19/10/12 1:37 PM",
      "commitNameOld": "f79ae9141422dc4b2211ad3ca60bb79c3d266cb3",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 40.22,
      "commitsBetweenForRepo": 201,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,78 +1,73 @@\n   protected synchronized void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n \n       String clientTokenStr \u003d null;\n       if (UserGroupInformation.isSecurityEnabled()) {\n \n         // TODO: This needs to move to per-AppAttempt\n         this.rmContext.getClientToAMTokenSecretManager().registerApplication(\n           applicationId);\n \n         Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n             Token\u003cClientTokenIdentifier\u003e(\n             new ClientTokenIdentifier(applicationId),\n             this.rmContext.getClientToAMTokenSecretManager());\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n       \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n-      // Store application for recovery\n-      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n-          .createApplicationStore(submissionContext.getApplicationId(),\n-          submissionContext);\n-\n       // Create RMApp\n       application \u003d\n           new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(),\n             submissionContext.getUser(), submissionContext.getQueue(),\n-            submissionContext, clientTokenStr, appStore, this.scheduler,\n+            submissionContext, clientTokenStr, this.scheduler,\n             this.masterService, submitTime);\n \n       // Sanity check - duplicate?\n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } \n \n       // Inform the ACLs Manager\n       this.applicationACLsManager.addApplication(applicationId,\n           submissionContext.getAMContainerSpec().getApplicationACLs());\n \n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }      \n       \n       // All done, start the RMApp\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppEvent(applicationId, RMAppEventType.START));\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           // Sending APP_REJECTED is fine, since we assume that the \n           // RMApp is in NEW state and thus we havne\u0027t yet informed the \n           // Scheduler about the existence of the application\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n\n      String clientTokenStr \u003d null;\n      if (UserGroupInformation.isSecurityEnabled()) {\n\n        // TODO: This needs to move to per-AppAttempt\n        this.rmContext.getClientToAMTokenSecretManager().registerApplication(\n          applicationId);\n\n        Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cClientTokenIdentifier\u003e(\n            new ClientTokenIdentifier(applicationId),\n            this.rmContext.getClientToAMTokenSecretManager());\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Create RMApp\n      application \u003d\n          new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(),\n            submissionContext.getUser(), submissionContext.getQueue(),\n            submissionContext, clientTokenStr, this.scheduler,\n            this.masterService, submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "f79ae9141422dc4b2211ad3ca60bb79c3d266cb3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-136. Make ClientToAMTokenSecretManager part of RMContext (Contributed by Vinod Kumar Vavilapalli)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1400278 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/10/12 1:37 PM",
      "commitName": "f79ae9141422dc4b2211ad3ca60bb79c3d266cb3",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "08/10/12 6:56 PM",
      "commitNameOld": "c074cfd6f0ec695d85a73cddba1404c9db79342e",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 10.78,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,78 @@\n   protected synchronized void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n-      // TODO: This needs to move to per-AppAttempt\n-      this.clientToAMSecretManager.registerApplication(applicationId);\n+\n       String clientTokenStr \u003d null;\n       if (UserGroupInformation.isSecurityEnabled()) {\n+\n+        // TODO: This needs to move to per-AppAttempt\n+        this.rmContext.getClientToAMTokenSecretManager().registerApplication(\n+          applicationId);\n+\n         Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n             Token\u003cClientTokenIdentifier\u003e(\n             new ClientTokenIdentifier(applicationId),\n-            this.clientToAMSecretManager);\n+            this.rmContext.getClientToAMTokenSecretManager());\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n       \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Store application for recovery\n       ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n           .createApplicationStore(submissionContext.getApplicationId(),\n           submissionContext);\n \n       // Create RMApp\n       application \u003d\n           new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(),\n             submissionContext.getUser(), submissionContext.getQueue(),\n             submissionContext, clientTokenStr, appStore, this.scheduler,\n             this.masterService, submitTime);\n \n       // Sanity check - duplicate?\n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } \n \n       // Inform the ACLs Manager\n       this.applicationACLsManager.addApplication(applicationId,\n           submissionContext.getAMContainerSpec().getApplicationACLs());\n \n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }      \n       \n       // All done, start the RMApp\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppEvent(applicationId, RMAppEventType.START));\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           // Sending APP_REJECTED is fine, since we assume that the \n           // RMApp is in NEW state and thus we havne\u0027t yet informed the \n           // Scheduler about the existence of the application\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n\n      String clientTokenStr \u003d null;\n      if (UserGroupInformation.isSecurityEnabled()) {\n\n        // TODO: This needs to move to per-AppAttempt\n        this.rmContext.getClientToAMTokenSecretManager().registerApplication(\n          applicationId);\n\n        Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cClientTokenIdentifier\u003e(\n            new ClientTokenIdentifier(applicationId),\n            this.rmContext.getClientToAMTokenSecretManager());\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Store application for recovery\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n\n      // Create RMApp\n      application \u003d\n          new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(),\n            submissionContext.getUser(), submissionContext.getQueue(),\n            submissionContext, clientTokenStr, appStore, this.scheduler,\n            this.masterService, submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "c074cfd6f0ec695d85a73cddba1404c9db79342e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-134. Fixes ClientToAMSecretManager creates keys without checking for validity of the appID. (Contributed by Vinod Kumar Vavilapalli)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1395841 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/10/12 6:56 PM",
      "commitName": "c074cfd6f0ec695d85a73cddba1404c9db79342e",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "26/09/12 8:43 PM",
      "commitNameOld": "40062e1aaa09628c6f45d20298fd66d799fd1f3f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 11.93,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,74 @@\n   protected synchronized void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n+      // TODO: This needs to move to per-AppAttempt\n+      this.clientToAMSecretManager.registerApplication(applicationId);\n       String clientTokenStr \u003d null;\n       if (UserGroupInformation.isSecurityEnabled()) {\n         Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n             Token\u003cClientTokenIdentifier\u003e(\n             new ClientTokenIdentifier(applicationId),\n             this.clientToAMSecretManager);\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n       \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Store application for recovery\n       ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n           .createApplicationStore(submissionContext.getApplicationId(),\n           submissionContext);\n \n       // Create RMApp\n       application \u003d\n           new RMAppImpl(applicationId, rmContext, this.conf,\n             submissionContext.getApplicationName(),\n             submissionContext.getUser(), submissionContext.getQueue(),\n             submissionContext, clientTokenStr, appStore, this.scheduler,\n             this.masterService, submitTime);\n \n       // Sanity check - duplicate?\n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } \n \n       // Inform the ACLs Manager\n       this.applicationACLsManager.addApplication(applicationId,\n           submissionContext.getAMContainerSpec().getApplicationACLs());\n \n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }      \n       \n       // All done, start the RMApp\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppEvent(applicationId, RMAppEventType.START));\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           // Sending APP_REJECTED is fine, since we assume that the \n           // RMApp is in NEW state and thus we havne\u0027t yet informed the \n           // Scheduler about the existence of the application\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      // TODO: This needs to move to per-AppAttempt\n      this.clientToAMSecretManager.registerApplication(applicationId);\n      String clientTokenStr \u003d null;\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cClientTokenIdentifier\u003e(\n            new ClientTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Store application for recovery\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n\n      // Create RMApp\n      application \u003d\n          new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(),\n            submissionContext.getUser(), submissionContext.getQueue(),\n            submissionContext, clientTokenStr, appStore, this.scheduler,\n            this.masterService, submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "40062e1aaa09628c6f45d20298fd66d799fd1f3f": {
      "type": "Ybodychange",
      "commitMessage": "Fix NodeManager to verify the application\u0027s user-name.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1390825 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/09/12 8:43 PM",
      "commitName": "40062e1aaa09628c6f45d20298fd66d799fd1f3f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "07/08/12 10:22 PM",
      "commitNameOld": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 49.93,
      "commitsBetweenForRepo": 287,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   protected synchronized void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n       String clientTokenStr \u003d null;\n-      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n       if (UserGroupInformation.isSecurityEnabled()) {\n         Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n             Token\u003cClientTokenIdentifier\u003e(\n             new ClientTokenIdentifier(applicationId),\n             this.clientToAMSecretManager);\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n       \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Store application for recovery\n       ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n           .createApplicationStore(submissionContext.getApplicationId(),\n           submissionContext);\n \n       // Create RMApp\n-      application \u003d new RMAppImpl(applicationId, rmContext,\n-          this.conf, submissionContext.getApplicationName(), user,\n-          submissionContext.getQueue(), submissionContext, clientTokenStr,\n-          appStore, this.scheduler,\n-          this.masterService, submitTime);\n+      application \u003d\n+          new RMAppImpl(applicationId, rmContext, this.conf,\n+            submissionContext.getApplicationName(),\n+            submissionContext.getUser(), submissionContext.getQueue(),\n+            submissionContext, clientTokenStr, appStore, this.scheduler,\n+            this.masterService, submitTime);\n \n       // Sanity check - duplicate?\n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } \n \n       // Inform the ACLs Manager\n       this.applicationACLsManager.addApplication(applicationId,\n           submissionContext.getAMContainerSpec().getApplicationACLs());\n \n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext),\n             submissionContext.getCancelTokensWhenComplete()\n             );\n       }      \n       \n       // All done, start the RMApp\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppEvent(applicationId, RMAppEventType.START));\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           // Sending APP_REJECTED is fine, since we assume that the \n           // RMApp is in NEW state and thus we havne\u0027t yet informed the \n           // Scheduler about the existence of the application\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cClientTokenIdentifier\u003e(\n            new ClientTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Store application for recovery\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n\n      // Create RMApp\n      application \u003d\n          new RMAppImpl(applicationId, rmContext, this.conf,\n            submissionContext.getApplicationName(),\n            submissionContext.getUser(), submissionContext.getQueue(),\n            submissionContext, clientTokenStr, appStore, this.scheduler,\n            this.masterService, submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cClientTokenIdentifier\u003e(\n            new ClientTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Store application for recovery\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n\n      // Create RMApp\n      application \u003d new RMAppImpl(applicationId, rmContext,\n          this.conf, submissionContext.getApplicationName(), user,\n          submissionContext.getQueue(), submissionContext, clientTokenStr,\n          appStore, this.scheduler,\n          this.masterService, submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java"
      }
    },
    "6733a1ca5ef741d3bdf886f301954e9a9e7a875f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3291. App fail to launch due to delegation token not found in cache (Robert Evans via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1198583 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/11/11 2:58 PM",
      "commitName": "6733a1ca5ef741d3bdf886f301954e9a9e7a875f",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "26/10/11 11:24 PM",
      "commitNameOld": "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 10.69,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,72 @@\n   protected synchronized void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n       String clientTokenStr \u003d null;\n       String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n       if (UserGroupInformation.isSecurityEnabled()) {\n         Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n             Token\u003cClientTokenIdentifier\u003e(\n             new ClientTokenIdentifier(applicationId),\n             this.clientToAMSecretManager);\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n       \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Store application for recovery\n       ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n           .createApplicationStore(submissionContext.getApplicationId(),\n           submissionContext);\n \n       // Create RMApp\n       application \u003d new RMAppImpl(applicationId, rmContext,\n           this.conf, submissionContext.getApplicationName(), user,\n           submissionContext.getQueue(), submissionContext, clientTokenStr,\n           appStore, this.scheduler,\n           this.masterService, submitTime);\n \n       // Sanity check - duplicate?\n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } \n \n       // Inform the ACLs Manager\n       this.applicationACLsManager.addApplication(applicationId,\n           submissionContext.getAMContainerSpec().getApplicationACLs());\n \n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n-            applicationId,parseCredentials(submissionContext)\n+            applicationId,parseCredentials(submissionContext),\n+            submissionContext.getCancelTokensWhenComplete()\n             );\n       }      \n       \n       // All done, start the RMApp\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppEvent(applicationId, RMAppEventType.START));\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           // Sending APP_REJECTED is fine, since we assume that the \n           // RMApp is in NEW state and thus we havne\u0027t yet informed the \n           // Scheduler about the existence of the application\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cClientTokenIdentifier\u003e(\n            new ClientTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Store application for recovery\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n\n      // Create RMApp\n      application \u003d new RMAppImpl(applicationId, rmContext,\n          this.conf, submissionContext.getApplicationName(), user,\n          submissionContext.getQueue(), submissionContext, clientTokenStr,\n          appStore, this.scheduler,\n          this.masterService, submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext),\n            submissionContext.getCancelTokensWhenComplete()\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3257. Added authorization checks for the protocol between ResourceManager and ApplicatoinMaster. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189630 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/10/11 11:24 PM",
      "commitName": "db8ac0ec3cbec046f9cf32644c16fd2a51dd85a2",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "25/10/11 7:53 PM",
      "commitNameOld": "29c6c3ed328965a73fe7b68eb29cb30794beef38",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.15,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   protected synchronized void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n       String clientTokenStr \u003d null;\n       String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n       if (UserGroupInformation.isSecurityEnabled()) {\n-        Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n-            Token\u003cApplicationTokenIdentifier\u003e(\n-            new ApplicationTokenIdentifier(applicationId),\n+        Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n+            Token\u003cClientTokenIdentifier\u003e(\n+            new ClientTokenIdentifier(applicationId),\n             this.clientToAMSecretManager);\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n       \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Store application for recovery\n       ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n           .createApplicationStore(submissionContext.getApplicationId(),\n           submissionContext);\n \n       // Create RMApp\n       application \u003d new RMAppImpl(applicationId, rmContext,\n           this.conf, submissionContext.getApplicationName(), user,\n           submissionContext.getQueue(), submissionContext, clientTokenStr,\n           appStore, this.scheduler,\n           this.masterService, submitTime);\n \n       // Sanity check - duplicate?\n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } \n \n       // Inform the ACLs Manager\n       this.applicationACLsManager.addApplication(applicationId,\n           submissionContext.getAMContainerSpec().getApplicationACLs());\n \n       // Setup tokens for renewal\n       if (UserGroupInformation.isSecurityEnabled()) {\n         this.rmContext.getDelegationTokenRenewer().addApplication(\n             applicationId,parseCredentials(submissionContext)\n             );\n       }      \n       \n       // All done, start the RMApp\n       this.rmContext.getDispatcher().getEventHandler().handle(\n           new RMAppEvent(applicationId, RMAppEventType.START));\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           // Sending APP_REJECTED is fine, since we assume that the \n           // RMApp is in NEW state and thus we havne\u0027t yet informed the \n           // Scheduler about the existence of the application\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cClientTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cClientTokenIdentifier\u003e(\n            new ClientTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Store application for recovery\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n\n      // Create RMApp\n      application \u003d new RMAppImpl(applicationId, rmContext,\n          this.conf, submissionContext.getApplicationName(), user,\n          submissionContext.getQueue(), submissionContext, clientTokenStr,\n          appStore, this.scheduler,\n          this.masterService, submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext)\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "29c6c3ed328965a73fe7b68eb29cb30794beef38": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2977. Fix ResourceManager to renew HDFS delegation tokens for applications. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189012 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/10/11 7:53 PM",
      "commitName": "29c6c3ed328965a73fe7b68eb29cb30794beef38",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "20/10/11 4:45 AM",
      "commitNameOld": "df2991c0cbc3f35c2640b93680667507c4f810dd",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 5.63,
      "commitsBetweenForRepo": 40,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,71 @@\n   protected synchronized void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n       String clientTokenStr \u003d null;\n       String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n       if (UserGroupInformation.isSecurityEnabled()) {\n         Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n             Token\u003cApplicationTokenIdentifier\u003e(\n             new ApplicationTokenIdentifier(applicationId),\n             this.clientToAMSecretManager);\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n       \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Store application for recovery\n       ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n           .createApplicationStore(submissionContext.getApplicationId(),\n           submissionContext);\n \n       // Create RMApp\n       application \u003d new RMAppImpl(applicationId, rmContext,\n           this.conf, submissionContext.getApplicationName(), user,\n           submissionContext.getQueue(), submissionContext, clientTokenStr,\n           appStore, this.scheduler,\n           this.masterService, submitTime);\n \n+      // Sanity check - duplicate?\n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n-      } else {\n+      } \n \n-        this.applicationACLsManager.addApplication(applicationId,\n-            submissionContext.getAMContainerSpec().getApplicationACLs());\n+      // Inform the ACLs Manager\n+      this.applicationACLsManager.addApplication(applicationId,\n+          submissionContext.getAMContainerSpec().getApplicationACLs());\n \n-        this.rmContext.getDispatcher().getEventHandler().handle(\n-            new RMAppEvent(applicationId, RMAppEventType.START));\n-      }\n+      // Setup tokens for renewal\n+      if (UserGroupInformation.isSecurityEnabled()) {\n+        this.rmContext.getDelegationTokenRenewer().addApplication(\n+            applicationId,parseCredentials(submissionContext)\n+            );\n+      }      \n+      \n+      // All done, start the RMApp\n+      this.rmContext.getDispatcher().getEventHandler().handle(\n+          new RMAppEvent(applicationId, RMAppEventType.START));\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n-          // TODO: Weird setup.\n+          // Sending APP_REJECTED is fine, since we assume that the \n+          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n+          // Scheduler about the existence of the application\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cApplicationTokenIdentifier\u003e(\n            new ApplicationTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Store application for recovery\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n\n      // Create RMApp\n      application \u003d new RMAppImpl(applicationId, rmContext,\n          this.conf, submissionContext.getApplicationName(), user,\n          submissionContext.getQueue(), submissionContext, clientTokenStr,\n          appStore, this.scheduler,\n          this.masterService, submitTime);\n\n      // Sanity check - duplicate?\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } \n\n      // Inform the ACLs Manager\n      this.applicationACLsManager.addApplication(applicationId,\n          submissionContext.getAMContainerSpec().getApplicationACLs());\n\n      // Setup tokens for renewal\n      if (UserGroupInformation.isSecurityEnabled()) {\n        this.rmContext.getDelegationTokenRenewer().addApplication(\n            applicationId,parseCredentials(submissionContext)\n            );\n      }      \n      \n      // All done, start the RMApp\n      this.rmContext.getDispatcher().getEventHandler().handle(\n          new RMAppEvent(applicationId, RMAppEventType.START));\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // Sending APP_REJECTED is fine, since we assume that the \n          // RMApp is in NEW state and thus we havne\u0027t yet informed the \n          // Scheduler about the existence of the application\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "df2991c0cbc3f35c2640b93680667507c4f810dd": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3104. Implemented Application-acls. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1186748 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/10/11 4:45 AM",
      "commitName": "df2991c0cbc3f35c2640b93680667507c4f810dd",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/10/11 10:21 PM",
      "commitNameOld": "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 1.27,
      "commitsBetweenForRepo": 17,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,60 @@\n   protected synchronized void submitApplication(\n       ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n       String clientTokenStr \u003d null;\n       String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n       if (UserGroupInformation.isSecurityEnabled()) {\n         Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n             Token\u003cApplicationTokenIdentifier\u003e(\n             new ApplicationTokenIdentifier(applicationId),\n             this.clientToAMSecretManager);\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n       \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Store application for recovery\n       ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n           .createApplicationStore(submissionContext.getApplicationId(),\n           submissionContext);\n \n       // Create RMApp\n       application \u003d new RMAppImpl(applicationId, rmContext,\n           this.conf, submissionContext.getApplicationName(), user,\n           submissionContext.getQueue(), submissionContext, clientTokenStr,\n           appStore, this.scheduler,\n           this.masterService, submitTime);\n \n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } else {\n+\n+        this.applicationACLsManager.addApplication(applicationId,\n+            submissionContext.getAMContainerSpec().getApplicationACLs());\n+\n         this.rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n+          // TODO: Weird setup.\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cApplicationTokenIdentifier\u003e(\n            new ApplicationTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Store application for recovery\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n\n      // Create RMApp\n      application \u003d new RMAppImpl(applicationId, rmContext,\n          this.conf, submissionContext.getApplicationName(), user,\n          submissionContext.getQueue(), submissionContext, clientTokenStr,\n          appStore, this.scheduler,\n          this.masterService, submitTime);\n\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } else {\n\n        this.applicationACLsManager.addApplication(applicationId,\n            submissionContext.getAMContainerSpec().getApplicationACLs());\n\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          // TODO: Weird setup.\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "13e4562924a6cb3d16c262e0f595b2ffbf9e0546": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "MAPREDUCE-3144. Augmented JobHistory with the information needed for serving aggregated logs. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1185976 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/10/11 10:21 PM",
      "commitName": "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-3144. Augmented JobHistory with the information needed for serving aggregated logs. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1185976 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/10/11 10:21 PM",
          "commitName": "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "28/09/11 12:31 AM",
          "commitNameOld": "312a7e71001d55f88781e56b331ab1b40a72a980",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 20.91,
          "commitsBetweenForRepo": 158,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,55 +1,55 @@\n   protected synchronized void submitApplication(\n-      ApplicationSubmissionContext submissionContext) {\n+      ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n       String clientTokenStr \u003d null;\n       String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n       if (UserGroupInformation.isSecurityEnabled()) {\n         Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n             Token\u003cApplicationTokenIdentifier\u003e(\n             new ApplicationTokenIdentifier(applicationId),\n             this.clientToAMSecretManager);\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n       \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Store application for recovery\n       ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n           .createApplicationStore(submissionContext.getApplicationId(),\n           submissionContext);\n-      \n+\n       // Create RMApp\n       application \u003d new RMAppImpl(applicationId, rmContext,\n           this.conf, submissionContext.getApplicationName(), user,\n           submissionContext.getQueue(), submissionContext, clientTokenStr,\n           appStore, this.scheduler,\n-          this.masterService);\n+          this.masterService, submitTime);\n \n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } else {\n         this.rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cApplicationTokenIdentifier\u003e(\n            new ApplicationTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Store application for recovery\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n\n      // Create RMApp\n      application \u003d new RMAppImpl(applicationId, rmContext,\n          this.conf, submissionContext.getApplicationName(), user,\n          submissionContext.getQueue(), submissionContext, clientTokenStr,\n          appStore, this.scheduler,\n          this.masterService, submitTime);\n\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } else {\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {
            "oldValue": "[submissionContext-ApplicationSubmissionContext]",
            "newValue": "[submissionContext-ApplicationSubmissionContext, submitTime-long]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "MAPREDUCE-3144. Augmented JobHistory with the information needed for serving aggregated logs. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1185976 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/10/11 10:21 PM",
          "commitName": "13e4562924a6cb3d16c262e0f595b2ffbf9e0546",
          "commitAuthor": "Vinod Kumar Vavilapalli",
          "commitDateOld": "28/09/11 12:31 AM",
          "commitNameOld": "312a7e71001d55f88781e56b331ab1b40a72a980",
          "commitAuthorOld": "Arun Murthy",
          "daysBetweenCommits": 20.91,
          "commitsBetweenForRepo": 158,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,55 +1,55 @@\n   protected synchronized void submitApplication(\n-      ApplicationSubmissionContext submissionContext) {\n+      ApplicationSubmissionContext submissionContext, long submitTime) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n       String clientTokenStr \u003d null;\n       String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n       if (UserGroupInformation.isSecurityEnabled()) {\n         Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n             Token\u003cApplicationTokenIdentifier\u003e(\n             new ApplicationTokenIdentifier(applicationId),\n             this.clientToAMSecretManager);\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n       \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Store application for recovery\n       ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n           .createApplicationStore(submissionContext.getApplicationId(),\n           submissionContext);\n-      \n+\n       // Create RMApp\n       application \u003d new RMAppImpl(applicationId, rmContext,\n           this.conf, submissionContext.getApplicationName(), user,\n           submissionContext.getQueue(), submissionContext, clientTokenStr,\n           appStore, this.scheduler,\n-          this.masterService);\n+          this.masterService, submitTime);\n \n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n         String message \u003d \"Application with id \" + applicationId\n             + \" is already present! Cannot add a duplicate!\";\n         LOG.info(message);\n         throw RPCUtil.getRemoteException(message);\n       } else {\n         this.rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext, long submitTime) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cApplicationTokenIdentifier\u003e(\n            new ApplicationTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Store application for recovery\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n\n      // Create RMApp\n      application \u003d new RMAppImpl(applicationId, rmContext,\n          this.conf, submissionContext.getApplicationName(), user,\n          submissionContext.getQueue(), submissionContext, clientTokenStr,\n          appStore, this.scheduler,\n          this.masterService, submitTime);\n\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } else {\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "312a7e71001d55f88781e56b331ab1b40a72a980": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3078. Ensure MapReduce AM reports progress correctly for displaying on the RM Web-UI. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1176762 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/09/11 12:31 AM",
      "commitName": "312a7e71001d55f88781e56b331ab1b40a72a980",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "14/09/11 12:26 AM",
      "commitNameOld": "88b82a0f6687ce103817fbb460fd30d870f717a0",
      "commitAuthorOld": "Mahadev Konar",
      "daysBetweenCommits": 14.0,
      "commitsBetweenForRepo": 96,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,55 @@\n   protected synchronized void submitApplication(\n       ApplicationSubmissionContext submissionContext) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n       String clientTokenStr \u003d null;\n       String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n       if (UserGroupInformation.isSecurityEnabled()) {\n         Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n             Token\u003cApplicationTokenIdentifier\u003e(\n             new ApplicationTokenIdentifier(applicationId),\n             this.clientToAMSecretManager);\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n       \n       // Sanity checks\n       if (submissionContext.getQueue() \u003d\u003d null) {\n         submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n       }\n       if (submissionContext.getApplicationName() \u003d\u003d null) {\n         submissionContext.setApplicationName(\n             YarnConfiguration.DEFAULT_APPLICATION_NAME);\n       }\n \n       // Store application for recovery\n       ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n           .createApplicationStore(submissionContext.getApplicationId(),\n           submissionContext);\n       \n       // Create RMApp\n       application \u003d new RMAppImpl(applicationId, rmContext,\n           this.conf, submissionContext.getApplicationName(), user,\n           submissionContext.getQueue(), submissionContext, clientTokenStr,\n           appStore, this.scheduler,\n           this.masterService);\n \n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n           null) {\n-        LOG.info(\"Application with id \" + applicationId + \n-            \" is already present! Cannot add a duplicate!\");\n-        // don\u0027t send event through dispatcher as it will be handled by app \n-        // already present with this id.\n-        application.handle(new RMAppRejectedEvent(applicationId,\n-            \"Application with this id is already present! \" +\n-            \"Cannot add a duplicate!\"));\n+        String message \u003d \"Application with id \" + applicationId\n+            + \" is already present! Cannot add a duplicate!\";\n+        LOG.info(message);\n+        throw RPCUtil.getRemoteException(message);\n       } else {\n         this.rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cApplicationTokenIdentifier\u003e(\n            new ApplicationTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Store application for recovery\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n      \n      // Create RMApp\n      application \u003d new RMAppImpl(applicationId, rmContext,\n          this.conf, submissionContext.getApplicationName(), user,\n          submissionContext.getQueue(), submissionContext, clientTokenStr,\n          appStore, this.scheduler,\n          this.masterService);\n\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        String message \u003d \"Application with id \" + applicationId\n            + \" is already present! Cannot add a duplicate!\";\n        LOG.info(message);\n        throw RPCUtil.getRemoteException(message);\n      } else {\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "88b82a0f6687ce103817fbb460fd30d870f717a0": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2899. Replace major parts of ApplicationSubmissionContext with a ContainerLaunchContext (Arun Murthy via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1170459 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/09/11 12:26 AM",
      "commitName": "88b82a0f6687ce103817fbb460fd30d870f717a0",
      "commitAuthor": "Mahadev Konar",
      "commitDateOld": "08/09/11 7:19 PM",
      "commitNameOld": "ca853445e9a31e05278e9dceea9dbed734103f49",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 5.21,
      "commitsBetweenForRepo": 32,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,58 @@\n-  protected synchronized void submitApplication(ApplicationSubmissionContext submissionContext) {\n+  protected synchronized void submitApplication(\n+      ApplicationSubmissionContext submissionContext) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n       String clientTokenStr \u003d null;\n       String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n       if (UserGroupInformation.isSecurityEnabled()) {\n         Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n             Token\u003cApplicationTokenIdentifier\u003e(\n             new ApplicationTokenIdentifier(applicationId),\n             this.clientToAMSecretManager);\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n-      submissionContext.setQueue(submissionContext.getQueue() \u003d\u003d null\n-          ? \"default\" : submissionContext.getQueue());\n-      submissionContext.setApplicationName(submissionContext\n-          .getApplicationName() \u003d\u003d null ? \"N/A\" : submissionContext\n-          .getApplicationName());\n+      \n+      // Sanity checks\n+      if (submissionContext.getQueue() \u003d\u003d null) {\n+        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n+      }\n+      if (submissionContext.getApplicationName() \u003d\u003d null) {\n+        submissionContext.setApplicationName(\n+            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n+      }\n+\n+      // Store application for recovery\n       ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n           .createApplicationStore(submissionContext.getApplicationId(),\n           submissionContext);\n+      \n+      // Create RMApp\n       application \u003d new RMAppImpl(applicationId, rmContext,\n           this.conf, submissionContext.getApplicationName(), user,\n           submissionContext.getQueue(), submissionContext, clientTokenStr,\n-          appStore, rmContext.getAMLivelinessMonitor(), this.scheduler,\n+          appStore, this.scheduler,\n           this.masterService);\n \n-      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d null) {\n+      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n+          null) {\n         LOG.info(\"Application with id \" + applicationId + \n             \" is already present! Cannot add a duplicate!\");\n-        // don\u0027t send event through dispatcher as it will be handled by app already\n-        // present with this id.\n+        // don\u0027t send event through dispatcher as it will be handled by app \n+        // already present with this id.\n         application.handle(new RMAppRejectedEvent(applicationId,\n-            \"Application with this id is already present! Cannot add a duplicate!\"));\n+            \"Application with this id is already present! \" +\n+            \"Cannot add a duplicate!\"));\n       } else {\n         this.rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void submitApplication(\n      ApplicationSubmissionContext submissionContext) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cApplicationTokenIdentifier\u003e(\n            new ApplicationTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      \n      // Sanity checks\n      if (submissionContext.getQueue() \u003d\u003d null) {\n        submissionContext.setQueue(YarnConfiguration.DEFAULT_QUEUE_NAME);\n      }\n      if (submissionContext.getApplicationName() \u003d\u003d null) {\n        submissionContext.setApplicationName(\n            YarnConfiguration.DEFAULT_APPLICATION_NAME);\n      }\n\n      // Store application for recovery\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n      \n      // Create RMApp\n      application \u003d new RMAppImpl(applicationId, rmContext,\n          this.conf, submissionContext.getApplicationName(), user,\n          submissionContext.getQueue(), submissionContext, clientTokenStr,\n          appStore, this.scheduler,\n          this.masterService);\n\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d \n          null) {\n        LOG.info(\"Application with id \" + applicationId + \n            \" is already present! Cannot add a duplicate!\");\n        // don\u0027t send event through dispatcher as it will be handled by app \n        // already present with this id.\n        application.handle(new RMAppRejectedEvent(applicationId,\n            \"Application with this id is already present! \" +\n            \"Cannot add a duplicate!\"));\n      } else {\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {}
    },
    "ca853445e9a31e05278e9dceea9dbed734103f49": {
      "type": "Ymodifierchange",
      "commitMessage": "MAPREDUCE-2953. Fix a race condition on submission which caused client to incorrectly assume application was gone by making submission synchronous for RMAppManager. Contributed by Thomas Graves.  \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166968 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/09/11 7:19 PM",
      "commitName": "ca853445e9a31e05278e9dceea9dbed734103f49",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "08/09/11 6:44 PM",
      "commitNameOld": "fafe8cd28e726566509c679e19d7da622f29f90d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n-  protected void submitApplication(ApplicationSubmissionContext submissionContext) {\n+  protected synchronized void submitApplication(ApplicationSubmissionContext submissionContext) {\n     ApplicationId applicationId \u003d submissionContext.getApplicationId();\n     RMApp application \u003d null;\n     try {\n       String clientTokenStr \u003d null;\n       String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n       if (UserGroupInformation.isSecurityEnabled()) {\n         Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n             Token\u003cApplicationTokenIdentifier\u003e(\n             new ApplicationTokenIdentifier(applicationId),\n             this.clientToAMSecretManager);\n         clientTokenStr \u003d clientToken.encodeToUrlString();\n         LOG.debug(\"Sending client token as \" + clientTokenStr);\n       }\n       submissionContext.setQueue(submissionContext.getQueue() \u003d\u003d null\n           ? \"default\" : submissionContext.getQueue());\n       submissionContext.setApplicationName(submissionContext\n           .getApplicationName() \u003d\u003d null ? \"N/A\" : submissionContext\n           .getApplicationName());\n       ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n           .createApplicationStore(submissionContext.getApplicationId(),\n           submissionContext);\n       application \u003d new RMAppImpl(applicationId, rmContext,\n           this.conf, submissionContext.getApplicationName(), user,\n           submissionContext.getQueue(), submissionContext, clientTokenStr,\n           appStore, rmContext.getAMLivelinessMonitor(), this.scheduler,\n           this.masterService);\n \n       if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d null) {\n         LOG.info(\"Application with id \" + applicationId + \n             \" is already present! Cannot add a duplicate!\");\n         // don\u0027t send event through dispatcher as it will be handled by app already\n         // present with this id.\n         application.handle(new RMAppRejectedEvent(applicationId,\n             \"Application with this id is already present! Cannot add a duplicate!\"));\n       } else {\n         this.rmContext.getDispatcher().getEventHandler().handle(\n             new RMAppEvent(applicationId, RMAppEventType.START));\n       }\n     } catch (IOException ie) {\n         LOG.info(\"RMAppManager submit application exception\", ie);\n         if (application !\u003d null) {\n           this.rmContext.getDispatcher().getEventHandler().handle(\n               new RMAppRejectedEvent(applicationId, ie.getMessage()));\n         }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected synchronized void submitApplication(ApplicationSubmissionContext submissionContext) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cApplicationTokenIdentifier\u003e(\n            new ApplicationTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      submissionContext.setQueue(submissionContext.getQueue() \u003d\u003d null\n          ? \"default\" : submissionContext.getQueue());\n      submissionContext.setApplicationName(submissionContext\n          .getApplicationName() \u003d\u003d null ? \"N/A\" : submissionContext\n          .getApplicationName());\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n      application \u003d new RMAppImpl(applicationId, rmContext,\n          this.conf, submissionContext.getApplicationName(), user,\n          submissionContext.getQueue(), submissionContext, clientTokenStr,\n          appStore, rmContext.getAMLivelinessMonitor(), this.scheduler,\n          this.masterService);\n\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d null) {\n        LOG.info(\"Application with id \" + applicationId + \n            \" is already present! Cannot add a duplicate!\");\n        // don\u0027t send event through dispatcher as it will be handled by app already\n        // present with this id.\n        application.handle(new RMAppRejectedEvent(applicationId,\n            \"Application with this id is already present! Cannot add a duplicate!\"));\n      } else {\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {
        "oldValue": "[protected]",
        "newValue": "[protected, synchronized]"
      }
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected void submitApplication(ApplicationSubmissionContext submissionContext) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cApplicationTokenIdentifier\u003e(\n            new ApplicationTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      submissionContext.setQueue(submissionContext.getQueue() \u003d\u003d null\n          ? \"default\" : submissionContext.getQueue());\n      submissionContext.setApplicationName(submissionContext\n          .getApplicationName() \u003d\u003d null ? \"N/A\" : submissionContext\n          .getApplicationName());\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n      application \u003d new RMAppImpl(applicationId, rmContext,\n          this.conf, submissionContext.getApplicationName(), user,\n          submissionContext.getQueue(), submissionContext, clientTokenStr,\n          appStore, rmContext.getAMLivelinessMonitor(), this.scheduler,\n          this.masterService);\n\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d null) {\n        LOG.info(\"Application with id \" + applicationId + \n            \" is already present! Cannot add a duplicate!\");\n        // don\u0027t send event through dispatcher as it will be handled by app already\n        // present with this id.\n        application.handle(new RMAppRejectedEvent(applicationId,\n            \"Application with this id is already present! Cannot add a duplicate!\"));\n      } else {\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java"
      }
    },
    "8af5c4b24aae932ecc8f09e72fdc7dc8307b6cc5": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-2649. Handling of finished applications in RM. Contributed by Thomas Graves.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1160521 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/08/11 6:32 PM",
      "commitName": "8af5c4b24aae932ecc8f09e72fdc7dc8307b6cc5",
      "commitAuthor": "Arun Murthy",
      "diff": "@@ -0,0 +1,47 @@\n+  protected void submitApplication(ApplicationSubmissionContext submissionContext) {\n+    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n+    RMApp application \u003d null;\n+    try {\n+      String clientTokenStr \u003d null;\n+      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n+      if (UserGroupInformation.isSecurityEnabled()) {\n+        Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n+            Token\u003cApplicationTokenIdentifier\u003e(\n+            new ApplicationTokenIdentifier(applicationId),\n+            this.clientToAMSecretManager);\n+        clientTokenStr \u003d clientToken.encodeToUrlString();\n+        LOG.debug(\"Sending client token as \" + clientTokenStr);\n+      }\n+      submissionContext.setQueue(submissionContext.getQueue() \u003d\u003d null\n+          ? \"default\" : submissionContext.getQueue());\n+      submissionContext.setApplicationName(submissionContext\n+          .getApplicationName() \u003d\u003d null ? \"N/A\" : submissionContext\n+          .getApplicationName());\n+      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n+          .createApplicationStore(submissionContext.getApplicationId(),\n+          submissionContext);\n+      application \u003d new RMAppImpl(applicationId, rmContext,\n+          this.conf, submissionContext.getApplicationName(), user,\n+          submissionContext.getQueue(), submissionContext, clientTokenStr,\n+          appStore, rmContext.getAMLivelinessMonitor(), this.scheduler,\n+          this.masterService);\n+\n+      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d null) {\n+        LOG.info(\"Application with id \" + applicationId + \n+            \" is already present! Cannot add a duplicate!\");\n+        // don\u0027t send event through dispatcher as it will be handled by app already\n+        // present with this id.\n+        application.handle(new RMAppRejectedEvent(applicationId,\n+            \"Application with this id is already present! Cannot add a duplicate!\"));\n+      } else {\n+        this.rmContext.getDispatcher().getEventHandler().handle(\n+            new RMAppEvent(applicationId, RMAppEventType.START));\n+      }\n+    } catch (IOException ie) {\n+        LOG.info(\"RMAppManager submit application exception\", ie);\n+        if (application !\u003d null) {\n+          this.rmContext.getDispatcher().getEventHandler().handle(\n+              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n+        }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void submitApplication(ApplicationSubmissionContext submissionContext) {\n    ApplicationId applicationId \u003d submissionContext.getApplicationId();\n    RMApp application \u003d null;\n    try {\n      String clientTokenStr \u003d null;\n      String user \u003d UserGroupInformation.getCurrentUser().getShortUserName();\n      if (UserGroupInformation.isSecurityEnabled()) {\n        Token\u003cApplicationTokenIdentifier\u003e clientToken \u003d new \n            Token\u003cApplicationTokenIdentifier\u003e(\n            new ApplicationTokenIdentifier(applicationId),\n            this.clientToAMSecretManager);\n        clientTokenStr \u003d clientToken.encodeToUrlString();\n        LOG.debug(\"Sending client token as \" + clientTokenStr);\n      }\n      submissionContext.setQueue(submissionContext.getQueue() \u003d\u003d null\n          ? \"default\" : submissionContext.getQueue());\n      submissionContext.setApplicationName(submissionContext\n          .getApplicationName() \u003d\u003d null ? \"N/A\" : submissionContext\n          .getApplicationName());\n      ApplicationStore appStore \u003d rmContext.getApplicationsStore()\n          .createApplicationStore(submissionContext.getApplicationId(),\n          submissionContext);\n      application \u003d new RMAppImpl(applicationId, rmContext,\n          this.conf, submissionContext.getApplicationName(), user,\n          submissionContext.getQueue(), submissionContext, clientTokenStr,\n          appStore, rmContext.getAMLivelinessMonitor(), this.scheduler,\n          this.masterService);\n\n      if (rmContext.getRMApps().putIfAbsent(applicationId, application) !\u003d null) {\n        LOG.info(\"Application with id \" + applicationId + \n            \" is already present! Cannot add a duplicate!\");\n        // don\u0027t send event through dispatcher as it will be handled by app already\n        // present with this id.\n        application.handle(new RMAppRejectedEvent(applicationId,\n            \"Application with this id is already present! Cannot add a duplicate!\"));\n      } else {\n        this.rmContext.getDispatcher().getEventHandler().handle(\n            new RMAppEvent(applicationId, RMAppEventType.START));\n      }\n    } catch (IOException ie) {\n        LOG.info(\"RMAppManager submit application exception\", ie);\n        if (application !\u003d null) {\n          this.rmContext.getDispatcher().getEventHandler().handle(\n              new RMAppRejectedEvent(applicationId, ie.getMessage()));\n        }\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/RMAppManager.java"
    }
  }
}