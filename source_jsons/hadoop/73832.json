{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "Server.java",
  "functionName": "doRunLoop",
  "functionId": "doRunLoop",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
  "functionStartLine": 1258,
  "functionEndLine": 1299,
  "numCommitsSeen": 205,
  "timeTaken": 7781,
  "changeHistory": [
    "827a84778a4e3b8f165806dfd2966f0951a5e575",
    "f96a2df38d889f29314c57f4d94227b2e419a11f",
    "e19b37ead23805c7ed45bdcbfa7fdc8898cde7b2",
    "76cd81f4b656f0d40a4b2122e15f04ea53d8020b",
    "81485dbfc1ffb8daa609be8eb31094cc28646dd3",
    "d288a0ba8364d81aacda9f4a21022eecb6dc4e22",
    "763f073f41e3eaa9ecd11c6ec0b76234739272aa",
    "3eb61be352589491117ac2781bb18f55988a8084",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
    "2f6c03ad54725e59e3d18866cfaaea734bb37c82"
  ],
  "changeHistoryShort": {
    "827a84778a4e3b8f165806dfd2966f0951a5e575": "Ybodychange",
    "f96a2df38d889f29314c57f4d94227b2e419a11f": "Ybodychange",
    "e19b37ead23805c7ed45bdcbfa7fdc8898cde7b2": "Ybodychange",
    "76cd81f4b656f0d40a4b2122e15f04ea53d8020b": "Ybodychange",
    "81485dbfc1ffb8daa609be8eb31094cc28646dd3": "Ybodychange",
    "d288a0ba8364d81aacda9f4a21022eecb6dc4e22": "Ybodychange",
    "763f073f41e3eaa9ecd11c6ec0b76234739272aa": "Ybodychange",
    "3eb61be352589491117ac2781bb18f55988a8084": "Ybodychange",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yfilerename",
    "2f6c03ad54725e59e3d18866cfaaea734bb37c82": "Yintroduced"
  },
  "changeHistoryDetails": {
    "827a84778a4e3b8f165806dfd2966f0951a5e575": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16266. Add more fine-grained processing time metrics to the RPC layer -follow-on patch.\n\nThis follow-on patch to HADOOP-16266 fixes up the problem where logs were being full of\nstack traces because the timeout passed down to select was in nanos, whereas the API\nexpected millis.\n\nContributed by Erik Krogen.\n\nChange-Id: I5c6e9ddf68127b1d7e0ca0e179d036eb9941e445\n",
      "commitDate": "04/06/19 7:56 AM",
      "commitName": "827a84778a4e3b8f165806dfd2966f0951a5e575",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "24/05/19 9:42 AM",
      "commitNameOld": "93d7630062247793a4860704fad4a31437693de1",
      "commitAuthorOld": "Shweta",
      "daysBetweenCommits": 10.93,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,72 @@\n     private void doRunLoop() {\n       long lastPurgeTimeNanos \u003d 0;   // last check for old calls.\n \n       while (running) {\n         try {\n           waitPending();     // If a channel is being registered, wait.\n-          writeSelector.select(PURGE_INTERVAL_NANOS);\n+          writeSelector.select(\n+              TimeUnit.NANOSECONDS.toMillis(PURGE_INTERVAL_NANOS));\n           Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n           while (iter.hasNext()) {\n             SelectionKey key \u003d iter.next();\n             iter.remove();\n             try {\n               if (key.isWritable()) {\n                 doAsyncWrite(key);\n               }\n             } catch (CancelledKeyException cke) {\n               // something else closed the connection, ex. reader or the\n               // listener doing an idle scan.  ignore it and let them clean\n               // up\n               RpcCall call \u003d (RpcCall)key.attachment();\n               if (call !\u003d null) {\n                 LOG.info(Thread.currentThread().getName() +\n                     \": connection aborted from \" + call.connection);\n               }\n             } catch (IOException e) {\n               LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n             }\n           }\n           long nowNanos \u003d Time.monotonicNowNanos();\n           if (nowNanos \u003c lastPurgeTimeNanos + PURGE_INTERVAL_NANOS) {\n             continue;\n           }\n           lastPurgeTimeNanos \u003d nowNanos;\n           //\n           // If there were some calls that have not been sent out for a\n           // long time, discard them.\n           //\n           if(LOG.isDebugEnabled()) {\n             LOG.debug(\"Checking for old call responses.\");\n           }\n           ArrayList\u003cRpcCall\u003e calls;\n           \n           // get the list of channels from list of keys.\n           synchronized (writeSelector.keys()) {\n             calls \u003d new ArrayList\u003cRpcCall\u003e(writeSelector.keys().size());\n             iter \u003d writeSelector.keys().iterator();\n             while (iter.hasNext()) {\n               SelectionKey key \u003d iter.next();\n               RpcCall call \u003d (RpcCall)key.attachment();\n               if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                 calls.add(call);\n               }\n             }\n           }\n \n           for (RpcCall call : calls) {\n             doPurge(call, nowNanos);\n           }\n         } catch (OutOfMemoryError e) {\n           //\n           // we can run out of memory if we have too many threads\n           // log the event and sleep for a minute and give\n           // some thread(s) a chance to finish\n           //\n           LOG.warn(\"Out of Memory in server select\", e);\n           try { Thread.sleep(60000); } catch (Exception ie) {}\n         } catch (Exception e) {\n           LOG.warn(\"Exception in Responder\", e);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTimeNanos \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(\n              TimeUnit.NANOSECONDS.toMillis(PURGE_INTERVAL_NANOS));\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isWritable()) {\n                doAsyncWrite(key);\n              }\n            } catch (CancelledKeyException cke) {\n              // something else closed the connection, ex. reader or the\n              // listener doing an idle scan.  ignore it and let them clean\n              // up\n              RpcCall call \u003d (RpcCall)key.attachment();\n              if (call !\u003d null) {\n                LOG.info(Thread.currentThread().getName() +\n                    \": connection aborted from \" + call.connection);\n              }\n            } catch (IOException e) {\n              LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long nowNanos \u003d Time.monotonicNowNanos();\n          if (nowNanos \u003c lastPurgeTimeNanos + PURGE_INTERVAL_NANOS) {\n            continue;\n          }\n          lastPurgeTimeNanos \u003d nowNanos;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cRpcCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cRpcCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              RpcCall call \u003d (RpcCall)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n\n          for (RpcCall call : calls) {\n            doPurge(call, nowNanos);\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "f96a2df38d889f29314c57f4d94227b2e419a11f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16266. Add more fine-grained processing time metrics to the RPC layer. Contributed by Christopher Gregorian.\n",
      "commitDate": "23/05/19 10:28 AM",
      "commitName": "f96a2df38d889f29314c57f4d94227b2e419a11f",
      "commitAuthor": "Christopher Gregorian",
      "commitDateOld": "07/05/19 5:48 PM",
      "commitNameOld": "713e8a27aea03f302b7a7d58769c967958f6e46a",
      "commitAuthorOld": "Peter Bacsko",
      "daysBetweenCommits": 15.69,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n     private void doRunLoop() {\n-      long lastPurgeTime \u003d 0;   // last check for old calls.\n+      long lastPurgeTimeNanos \u003d 0;   // last check for old calls.\n \n       while (running) {\n         try {\n           waitPending();     // If a channel is being registered, wait.\n-          writeSelector.select(PURGE_INTERVAL);\n+          writeSelector.select(PURGE_INTERVAL_NANOS);\n           Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n           while (iter.hasNext()) {\n             SelectionKey key \u003d iter.next();\n             iter.remove();\n             try {\n               if (key.isWritable()) {\n                 doAsyncWrite(key);\n               }\n             } catch (CancelledKeyException cke) {\n               // something else closed the connection, ex. reader or the\n               // listener doing an idle scan.  ignore it and let them clean\n               // up\n               RpcCall call \u003d (RpcCall)key.attachment();\n               if (call !\u003d null) {\n                 LOG.info(Thread.currentThread().getName() +\n                     \": connection aborted from \" + call.connection);\n               }\n             } catch (IOException e) {\n               LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n             }\n           }\n-          long now \u003d Time.now();\n-          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n+          long nowNanos \u003d Time.monotonicNowNanos();\n+          if (nowNanos \u003c lastPurgeTimeNanos + PURGE_INTERVAL_NANOS) {\n             continue;\n           }\n-          lastPurgeTime \u003d now;\n+          lastPurgeTimeNanos \u003d nowNanos;\n           //\n           // If there were some calls that have not been sent out for a\n           // long time, discard them.\n           //\n           if(LOG.isDebugEnabled()) {\n             LOG.debug(\"Checking for old call responses.\");\n           }\n           ArrayList\u003cRpcCall\u003e calls;\n           \n           // get the list of channels from list of keys.\n           synchronized (writeSelector.keys()) {\n             calls \u003d new ArrayList\u003cRpcCall\u003e(writeSelector.keys().size());\n             iter \u003d writeSelector.keys().iterator();\n             while (iter.hasNext()) {\n               SelectionKey key \u003d iter.next();\n               RpcCall call \u003d (RpcCall)key.attachment();\n               if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                 calls.add(call);\n               }\n             }\n           }\n \n           for (RpcCall call : calls) {\n-            doPurge(call, now);\n+            doPurge(call, nowNanos);\n           }\n         } catch (OutOfMemoryError e) {\n           //\n           // we can run out of memory if we have too many threads\n           // log the event and sleep for a minute and give\n           // some thread(s) a chance to finish\n           //\n           LOG.warn(\"Out of Memory in server select\", e);\n           try { Thread.sleep(60000); } catch (Exception ie) {}\n         } catch (Exception e) {\n           LOG.warn(\"Exception in Responder\", e);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTimeNanos \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(PURGE_INTERVAL_NANOS);\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isWritable()) {\n                doAsyncWrite(key);\n              }\n            } catch (CancelledKeyException cke) {\n              // something else closed the connection, ex. reader or the\n              // listener doing an idle scan.  ignore it and let them clean\n              // up\n              RpcCall call \u003d (RpcCall)key.attachment();\n              if (call !\u003d null) {\n                LOG.info(Thread.currentThread().getName() +\n                    \": connection aborted from \" + call.connection);\n              }\n            } catch (IOException e) {\n              LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long nowNanos \u003d Time.monotonicNowNanos();\n          if (nowNanos \u003c lastPurgeTimeNanos + PURGE_INTERVAL_NANOS) {\n            continue;\n          }\n          lastPurgeTimeNanos \u003d nowNanos;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cRpcCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cRpcCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              RpcCall call \u003d (RpcCall)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n\n          for (RpcCall call : calls) {\n            doPurge(call, nowNanos);\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "e19b37ead23805c7ed45bdcbfa7fdc8898cde7b2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11780. Prevent IPC reader thread death. Contributed by Daryn Sharp.\n",
      "commitDate": "28/09/16 6:24 AM",
      "commitName": "e19b37ead23805c7ed45bdcbfa7fdc8898cde7b2",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "14/09/16 7:46 PM",
      "commitNameOld": "ea0c2b8b051a2d14927e8f314245442f30748dc8",
      "commitAuthorOld": "Kai Zheng",
      "daysBetweenCommits": 13.44,
      "commitsBetweenForRepo": 79,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,71 @@\n     private void doRunLoop() {\n       long lastPurgeTime \u003d 0;   // last check for old calls.\n \n       while (running) {\n         try {\n           waitPending();     // If a channel is being registered, wait.\n           writeSelector.select(PURGE_INTERVAL);\n           Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n           while (iter.hasNext()) {\n             SelectionKey key \u003d iter.next();\n             iter.remove();\n             try {\n-              if (key.isValid() \u0026\u0026 key.isWritable()) {\n-                  doAsyncWrite(key);\n+              if (key.isWritable()) {\n+                doAsyncWrite(key);\n+              }\n+            } catch (CancelledKeyException cke) {\n+              // something else closed the connection, ex. reader or the\n+              // listener doing an idle scan.  ignore it and let them clean\n+              // up\n+              RpcCall call \u003d (RpcCall)key.attachment();\n+              if (call !\u003d null) {\n+                LOG.info(Thread.currentThread().getName() +\n+                    \": connection aborted from \" + call.connection);\n               }\n             } catch (IOException e) {\n               LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n             }\n           }\n           long now \u003d Time.now();\n           if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n             continue;\n           }\n           lastPurgeTime \u003d now;\n           //\n           // If there were some calls that have not been sent out for a\n           // long time, discard them.\n           //\n           if(LOG.isDebugEnabled()) {\n             LOG.debug(\"Checking for old call responses.\");\n           }\n           ArrayList\u003cRpcCall\u003e calls;\n           \n           // get the list of channels from list of keys.\n           synchronized (writeSelector.keys()) {\n             calls \u003d new ArrayList\u003cRpcCall\u003e(writeSelector.keys().size());\n             iter \u003d writeSelector.keys().iterator();\n             while (iter.hasNext()) {\n               SelectionKey key \u003d iter.next();\n               RpcCall call \u003d (RpcCall)key.attachment();\n               if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                 calls.add(call);\n               }\n             }\n           }\n \n           for (RpcCall call : calls) {\n             doPurge(call, now);\n           }\n         } catch (OutOfMemoryError e) {\n           //\n           // we can run out of memory if we have too many threads\n           // log the event and sleep for a minute and give\n           // some thread(s) a chance to finish\n           //\n           LOG.warn(\"Out of Memory in server select\", e);\n           try { Thread.sleep(60000); } catch (Exception ie) {}\n         } catch (Exception e) {\n           LOG.warn(\"Exception in Responder\", e);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTime \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(PURGE_INTERVAL);\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isWritable()) {\n                doAsyncWrite(key);\n              }\n            } catch (CancelledKeyException cke) {\n              // something else closed the connection, ex. reader or the\n              // listener doing an idle scan.  ignore it and let them clean\n              // up\n              RpcCall call \u003d (RpcCall)key.attachment();\n              if (call !\u003d null) {\n                LOG.info(Thread.currentThread().getName() +\n                    \": connection aborted from \" + call.connection);\n              }\n            } catch (IOException e) {\n              LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long now \u003d Time.now();\n          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n            continue;\n          }\n          lastPurgeTime \u003d now;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cRpcCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cRpcCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              RpcCall call \u003d (RpcCall)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n\n          for (RpcCall call : calls) {\n            doPurge(call, now);\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "76cd81f4b656f0d40a4b2122e15f04ea53d8020b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13465. Design Server.Call to be extensible for unified call queue. Contributed by Daryn Sharp.\n",
      "commitDate": "01/09/16 1:44 PM",
      "commitName": "76cd81f4b656f0d40a4b2122e15f04ea53d8020b",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "25/08/16 2:04 PM",
      "commitNameOld": "81485dbfc1ffb8daa609be8eb31094cc28646dd3",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 6.99,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n     private void doRunLoop() {\n       long lastPurgeTime \u003d 0;   // last check for old calls.\n \n       while (running) {\n         try {\n           waitPending();     // If a channel is being registered, wait.\n           writeSelector.select(PURGE_INTERVAL);\n           Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n           while (iter.hasNext()) {\n             SelectionKey key \u003d iter.next();\n             iter.remove();\n             try {\n               if (key.isValid() \u0026\u0026 key.isWritable()) {\n                   doAsyncWrite(key);\n               }\n             } catch (IOException e) {\n               LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n             }\n           }\n           long now \u003d Time.now();\n           if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n             continue;\n           }\n           lastPurgeTime \u003d now;\n           //\n           // If there were some calls that have not been sent out for a\n           // long time, discard them.\n           //\n           if(LOG.isDebugEnabled()) {\n             LOG.debug(\"Checking for old call responses.\");\n           }\n-          ArrayList\u003cCall\u003e calls;\n+          ArrayList\u003cRpcCall\u003e calls;\n           \n           // get the list of channels from list of keys.\n           synchronized (writeSelector.keys()) {\n-            calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n+            calls \u003d new ArrayList\u003cRpcCall\u003e(writeSelector.keys().size());\n             iter \u003d writeSelector.keys().iterator();\n             while (iter.hasNext()) {\n               SelectionKey key \u003d iter.next();\n-              Call call \u003d (Call)key.attachment();\n+              RpcCall call \u003d (RpcCall)key.attachment();\n               if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                 calls.add(call);\n               }\n             }\n           }\n-          \n-          for(Call call : calls) {\n+\n+          for (RpcCall call : calls) {\n             doPurge(call, now);\n           }\n         } catch (OutOfMemoryError e) {\n           //\n           // we can run out of memory if we have too many threads\n           // log the event and sleep for a minute and give\n           // some thread(s) a chance to finish\n           //\n           LOG.warn(\"Out of Memory in server select\", e);\n           try { Thread.sleep(60000); } catch (Exception ie) {}\n         } catch (Exception e) {\n           LOG.warn(\"Exception in Responder\", e);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTime \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(PURGE_INTERVAL);\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isValid() \u0026\u0026 key.isWritable()) {\n                  doAsyncWrite(key);\n              }\n            } catch (IOException e) {\n              LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long now \u003d Time.now();\n          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n            continue;\n          }\n          lastPurgeTime \u003d now;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cRpcCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cRpcCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              RpcCall call \u003d (RpcCall)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n\n          for (RpcCall call : calls) {\n            doPurge(call, now);\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "81485dbfc1ffb8daa609be8eb31094cc28646dd3": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-13465. Design Server.Call to be extensible for unified call queue. Contributed by Daryn Sharp.\"\n\nThis reverts commit d288a0ba8364d81aacda9f4a21022eecb6dc4e22.\n",
      "commitDate": "25/08/16 2:04 PM",
      "commitName": "81485dbfc1ffb8daa609be8eb31094cc28646dd3",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "25/08/16 9:44 AM",
      "commitNameOld": "d288a0ba8364d81aacda9f4a21022eecb6dc4e22",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 0.18,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n     private void doRunLoop() {\n       long lastPurgeTime \u003d 0;   // last check for old calls.\n \n       while (running) {\n         try {\n           waitPending();     // If a channel is being registered, wait.\n           writeSelector.select(PURGE_INTERVAL);\n           Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n           while (iter.hasNext()) {\n             SelectionKey key \u003d iter.next();\n             iter.remove();\n             try {\n               if (key.isValid() \u0026\u0026 key.isWritable()) {\n                   doAsyncWrite(key);\n               }\n             } catch (IOException e) {\n               LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n             }\n           }\n           long now \u003d Time.now();\n           if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n             continue;\n           }\n           lastPurgeTime \u003d now;\n           //\n           // If there were some calls that have not been sent out for a\n           // long time, discard them.\n           //\n           if(LOG.isDebugEnabled()) {\n             LOG.debug(\"Checking for old call responses.\");\n           }\n-          ArrayList\u003cRpcCall\u003e calls;\n+          ArrayList\u003cCall\u003e calls;\n           \n           // get the list of channels from list of keys.\n           synchronized (writeSelector.keys()) {\n-            calls \u003d new ArrayList\u003cRpcCall\u003e(writeSelector.keys().size());\n+            calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n             iter \u003d writeSelector.keys().iterator();\n             while (iter.hasNext()) {\n               SelectionKey key \u003d iter.next();\n-              RpcCall call \u003d (RpcCall)key.attachment();\n+              Call call \u003d (Call)key.attachment();\n               if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                 calls.add(call);\n               }\n             }\n           }\n-\n-          for (RpcCall call : calls) {\n+          \n+          for(Call call : calls) {\n             doPurge(call, now);\n           }\n         } catch (OutOfMemoryError e) {\n           //\n           // we can run out of memory if we have too many threads\n           // log the event and sleep for a minute and give\n           // some thread(s) a chance to finish\n           //\n           LOG.warn(\"Out of Memory in server select\", e);\n           try { Thread.sleep(60000); } catch (Exception ie) {}\n         } catch (Exception e) {\n           LOG.warn(\"Exception in Responder\", e);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTime \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(PURGE_INTERVAL);\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isValid() \u0026\u0026 key.isWritable()) {\n                  doAsyncWrite(key);\n              }\n            } catch (IOException e) {\n              LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long now \u003d Time.now();\n          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n            continue;\n          }\n          lastPurgeTime \u003d now;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              Call call \u003d (Call)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n          \n          for(Call call : calls) {\n            doPurge(call, now);\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "d288a0ba8364d81aacda9f4a21022eecb6dc4e22": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13465. Design Server.Call to be extensible for unified call queue. Contributed by Daryn Sharp.\n",
      "commitDate": "25/08/16 9:44 AM",
      "commitName": "d288a0ba8364d81aacda9f4a21022eecb6dc4e22",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "03/08/16 11:22 AM",
      "commitNameOld": "580a8334963709e728ed677c815fb7fef9bca70e",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 21.93,
      "commitsBetweenForRepo": 167,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n     private void doRunLoop() {\n       long lastPurgeTime \u003d 0;   // last check for old calls.\n \n       while (running) {\n         try {\n           waitPending();     // If a channel is being registered, wait.\n           writeSelector.select(PURGE_INTERVAL);\n           Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n           while (iter.hasNext()) {\n             SelectionKey key \u003d iter.next();\n             iter.remove();\n             try {\n               if (key.isValid() \u0026\u0026 key.isWritable()) {\n                   doAsyncWrite(key);\n               }\n             } catch (IOException e) {\n               LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n             }\n           }\n           long now \u003d Time.now();\n           if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n             continue;\n           }\n           lastPurgeTime \u003d now;\n           //\n           // If there were some calls that have not been sent out for a\n           // long time, discard them.\n           //\n           if(LOG.isDebugEnabled()) {\n             LOG.debug(\"Checking for old call responses.\");\n           }\n-          ArrayList\u003cCall\u003e calls;\n+          ArrayList\u003cRpcCall\u003e calls;\n           \n           // get the list of channels from list of keys.\n           synchronized (writeSelector.keys()) {\n-            calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n+            calls \u003d new ArrayList\u003cRpcCall\u003e(writeSelector.keys().size());\n             iter \u003d writeSelector.keys().iterator();\n             while (iter.hasNext()) {\n               SelectionKey key \u003d iter.next();\n-              Call call \u003d (Call)key.attachment();\n+              RpcCall call \u003d (RpcCall)key.attachment();\n               if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                 calls.add(call);\n               }\n             }\n           }\n-          \n-          for(Call call : calls) {\n+\n+          for (RpcCall call : calls) {\n             doPurge(call, now);\n           }\n         } catch (OutOfMemoryError e) {\n           //\n           // we can run out of memory if we have too many threads\n           // log the event and sleep for a minute and give\n           // some thread(s) a chance to finish\n           //\n           LOG.warn(\"Out of Memory in server select\", e);\n           try { Thread.sleep(60000); } catch (Exception ie) {}\n         } catch (Exception e) {\n           LOG.warn(\"Exception in Responder\", e);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTime \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(PURGE_INTERVAL);\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isValid() \u0026\u0026 key.isWritable()) {\n                  doAsyncWrite(key);\n              }\n            } catch (IOException e) {\n              LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long now \u003d Time.now();\n          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n            continue;\n          }\n          lastPurgeTime \u003d now;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cRpcCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cRpcCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              RpcCall call \u003d (RpcCall)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n\n          for (RpcCall call : calls) {\n            doPurge(call, now);\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "763f073f41e3eaa9ecd11c6ec0b76234739272aa": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10106. Incorrect thread name in RPC log messages. Contributed by Ming Ma.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1551369 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/12/13 1:57 PM",
      "commitName": "763f073f41e3eaa9ecd11c6ec0b76234739272aa",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "12/12/13 10:56 AM",
      "commitNameOld": "a4819e70dbf88b0905a6669078afa1ff0924ad4f",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 4.13,
      "commitsBetweenForRepo": 20,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n     private void doRunLoop() {\n       long lastPurgeTime \u003d 0;   // last check for old calls.\n \n       while (running) {\n         try {\n           waitPending();     // If a channel is being registered, wait.\n           writeSelector.select(PURGE_INTERVAL);\n           Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n           while (iter.hasNext()) {\n             SelectionKey key \u003d iter.next();\n             iter.remove();\n             try {\n               if (key.isValid() \u0026\u0026 key.isWritable()) {\n                   doAsyncWrite(key);\n               }\n             } catch (IOException e) {\n-              LOG.info(getName() + \": doAsyncWrite threw exception \" + e);\n+              LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n             }\n           }\n           long now \u003d Time.now();\n           if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n             continue;\n           }\n           lastPurgeTime \u003d now;\n           //\n           // If there were some calls that have not been sent out for a\n           // long time, discard them.\n           //\n           if(LOG.isDebugEnabled()) {\n             LOG.debug(\"Checking for old call responses.\");\n           }\n           ArrayList\u003cCall\u003e calls;\n           \n           // get the list of channels from list of keys.\n           synchronized (writeSelector.keys()) {\n             calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n             iter \u003d writeSelector.keys().iterator();\n             while (iter.hasNext()) {\n               SelectionKey key \u003d iter.next();\n               Call call \u003d (Call)key.attachment();\n               if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                 calls.add(call);\n               }\n             }\n           }\n           \n           for(Call call : calls) {\n             doPurge(call, now);\n           }\n         } catch (OutOfMemoryError e) {\n           //\n           // we can run out of memory if we have too many threads\n           // log the event and sleep for a minute and give\n           // some thread(s) a chance to finish\n           //\n           LOG.warn(\"Out of Memory in server select\", e);\n           try { Thread.sleep(60000); } catch (Exception ie) {}\n         } catch (Exception e) {\n           LOG.warn(\"Exception in Responder\", e);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTime \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(PURGE_INTERVAL);\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isValid() \u0026\u0026 key.isWritable()) {\n                  doAsyncWrite(key);\n              }\n            } catch (IOException e) {\n              LOG.info(Thread.currentThread().getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long now \u003d Time.now();\n          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n            continue;\n          }\n          lastPurgeTime \u003d now;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              Call call \u003d (Call)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n          \n          for(Call call : calls) {\n            doPurge(call, now);\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "3eb61be352589491117ac2781bb18f55988a8084": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-9754. Remove unnecessary \"throws IOException/InterruptedException\", and fix generic and other javac warnings.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1505610 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/07/13 12:22 AM",
      "commitName": "3eb61be352589491117ac2781bb18f55988a8084",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "19/07/13 2:49 PM",
      "commitNameOld": "9ff01d626118a97ea4bf2fd72f022e11e69ee17d",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 2.4,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,62 @@\n     private void doRunLoop() {\n       long lastPurgeTime \u003d 0;   // last check for old calls.\n \n       while (running) {\n         try {\n           waitPending();     // If a channel is being registered, wait.\n           writeSelector.select(PURGE_INTERVAL);\n           Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n           while (iter.hasNext()) {\n             SelectionKey key \u003d iter.next();\n             iter.remove();\n             try {\n               if (key.isValid() \u0026\u0026 key.isWritable()) {\n                   doAsyncWrite(key);\n               }\n             } catch (IOException e) {\n               LOG.info(getName() + \": doAsyncWrite threw exception \" + e);\n             }\n           }\n           long now \u003d Time.now();\n           if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n             continue;\n           }\n           lastPurgeTime \u003d now;\n           //\n           // If there were some calls that have not been sent out for a\n           // long time, discard them.\n           //\n           if(LOG.isDebugEnabled()) {\n             LOG.debug(\"Checking for old call responses.\");\n           }\n           ArrayList\u003cCall\u003e calls;\n           \n           // get the list of channels from list of keys.\n           synchronized (writeSelector.keys()) {\n             calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n             iter \u003d writeSelector.keys().iterator();\n             while (iter.hasNext()) {\n               SelectionKey key \u003d iter.next();\n               Call call \u003d (Call)key.attachment();\n               if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                 calls.add(call);\n               }\n             }\n           }\n           \n           for(Call call : calls) {\n-            try {\n-              doPurge(call, now);\n-            } catch (IOException e) {\n-              LOG.warn(\"Error in purging old calls \" + e);\n-            }\n+            doPurge(call, now);\n           }\n         } catch (OutOfMemoryError e) {\n           //\n           // we can run out of memory if we have too many threads\n           // log the event and sleep for a minute and give\n           // some thread(s) a chance to finish\n           //\n           LOG.warn(\"Out of Memory in server select\", e);\n           try { Thread.sleep(60000); } catch (Exception ie) {}\n         } catch (Exception e) {\n           LOG.warn(\"Exception in Responder\", e);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTime \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(PURGE_INTERVAL);\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isValid() \u0026\u0026 key.isWritable()) {\n                  doAsyncWrite(key);\n              }\n            } catch (IOException e) {\n              LOG.info(getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long now \u003d Time.now();\n          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n            continue;\n          }\n          lastPurgeTime \u003d now;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              Call call \u003d (Call)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n          \n          for(Call call : calls) {\n            doPurge(call, now);\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3641. Move server Util time methods to common and use now instead of System#currentTimeMillis. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1360858 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 12:01 PM",
      "commitName": "4a5ba3b7bd2360fd9605863630b477d362874e1e",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "11/05/12 9:56 AM",
      "commitNameOld": "2116f28d9e95896b54f4dc60336dc3f6ac7d64f3",
      "commitAuthorOld": "Sanjay Radia",
      "daysBetweenCommits": 62.09,
      "commitsBetweenForRepo": 300,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n     private void doRunLoop() {\n       long lastPurgeTime \u003d 0;   // last check for old calls.\n \n       while (running) {\n         try {\n           waitPending();     // If a channel is being registered, wait.\n           writeSelector.select(PURGE_INTERVAL);\n           Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n           while (iter.hasNext()) {\n             SelectionKey key \u003d iter.next();\n             iter.remove();\n             try {\n               if (key.isValid() \u0026\u0026 key.isWritable()) {\n                   doAsyncWrite(key);\n               }\n             } catch (IOException e) {\n               LOG.info(getName() + \": doAsyncWrite threw exception \" + e);\n             }\n           }\n-          long now \u003d System.currentTimeMillis();\n+          long now \u003d Time.now();\n           if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n             continue;\n           }\n           lastPurgeTime \u003d now;\n           //\n           // If there were some calls that have not been sent out for a\n           // long time, discard them.\n           //\n           if(LOG.isDebugEnabled()) {\n             LOG.debug(\"Checking for old call responses.\");\n           }\n           ArrayList\u003cCall\u003e calls;\n           \n           // get the list of channels from list of keys.\n           synchronized (writeSelector.keys()) {\n             calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n             iter \u003d writeSelector.keys().iterator();\n             while (iter.hasNext()) {\n               SelectionKey key \u003d iter.next();\n               Call call \u003d (Call)key.attachment();\n               if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                 calls.add(call);\n               }\n             }\n           }\n           \n           for(Call call : calls) {\n             try {\n               doPurge(call, now);\n             } catch (IOException e) {\n               LOG.warn(\"Error in purging old calls \" + e);\n             }\n           }\n         } catch (OutOfMemoryError e) {\n           //\n           // we can run out of memory if we have too many threads\n           // log the event and sleep for a minute and give\n           // some thread(s) a chance to finish\n           //\n           LOG.warn(\"Out of Memory in server select\", e);\n           try { Thread.sleep(60000); } catch (Exception ie) {}\n         } catch (Exception e) {\n           LOG.warn(\"Exception in Responder\", e);\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTime \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(PURGE_INTERVAL);\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isValid() \u0026\u0026 key.isWritable()) {\n                  doAsyncWrite(key);\n              }\n            } catch (IOException e) {\n              LOG.info(getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long now \u003d Time.now();\n          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n            continue;\n          }\n          lastPurgeTime \u003d now;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              Call call \u003d (Call)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n          \n          for(Call call : calls) {\n            try {\n              doPurge(call, now);\n            } catch (IOException e) {\n              LOG.warn(\"Error in purging old calls \" + e);\n            }\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTime \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(PURGE_INTERVAL);\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isValid() \u0026\u0026 key.isWritable()) {\n                  doAsyncWrite(key);\n              }\n            } catch (IOException e) {\n              LOG.info(getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long now \u003d System.currentTimeMillis();\n          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n            continue;\n          }\n          lastPurgeTime \u003d now;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              Call call \u003d (Call)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n          \n          for(Call call : calls) {\n            try {\n              doPurge(call, now);\n            } catch (IOException e) {\n              LOG.warn(\"Error in purging old calls \" + e);\n            }\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "0f6dfeeacbab65a31a33927a4eb84871d371fe52": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-6671. Use maven for hadoop common builds. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1153184 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/08/11 9:37 AM",
      "commitName": "0f6dfeeacbab65a31a33927a4eb84871d371fe52",
      "commitAuthor": "Thomas White",
      "commitDateOld": "01/08/11 3:53 PM",
      "commitNameOld": "9bac807cedbcff34e1a144fb475eff267e5ed86d",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTime \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(PURGE_INTERVAL);\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isValid() \u0026\u0026 key.isWritable()) {\n                  doAsyncWrite(key);\n              }\n            } catch (IOException e) {\n              LOG.info(getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long now \u003d System.currentTimeMillis();\n          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n            continue;\n          }\n          lastPurgeTime \u003d now;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              Call call \u003d (Call)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n          \n          for(Call call : calls) {\n            try {\n              doPurge(call, now);\n            } catch (IOException e) {\n              LOG.warn(\"Error in purging old calls \" + e);\n            }\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "common/src/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "hadoop-common/src/main/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "11/06/11 9:13 PM",
      "commitNameOld": "a285fb5effe9ba3be4ec5f942afaf5ddd1186151",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.74,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTime \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(PURGE_INTERVAL);\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isValid() \u0026\u0026 key.isWritable()) {\n                  doAsyncWrite(key);\n              }\n            } catch (IOException e) {\n              LOG.info(getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long now \u003d System.currentTimeMillis();\n          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n            continue;\n          }\n          lastPurgeTime \u003d now;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              Call call \u003d (Call)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n          \n          for(Call call : calls) {\n            try {\n              doPurge(call, now);\n            } catch (IOException e) {\n              LOG.warn(\"Error in purging old calls \" + e);\n            }\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "common/src/java/org/apache/hadoop/ipc/Server.java",
      "extendedDetails": {
        "oldPath": "src/java/org/apache/hadoop/ipc/Server.java",
        "newPath": "common/src/java/org/apache/hadoop/ipc/Server.java"
      }
    },
    "2f6c03ad54725e59e3d18866cfaaea734bb37c82": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7146. RPC server leaks file descriptors. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1127811 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/05/11 12:48 AM",
      "commitName": "2f6c03ad54725e59e3d18866cfaaea734bb37c82",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,66 @@\n+    private void doRunLoop() {\n+      long lastPurgeTime \u003d 0;   // last check for old calls.\n+\n+      while (running) {\n+        try {\n+          waitPending();     // If a channel is being registered, wait.\n+          writeSelector.select(PURGE_INTERVAL);\n+          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n+          while (iter.hasNext()) {\n+            SelectionKey key \u003d iter.next();\n+            iter.remove();\n+            try {\n+              if (key.isValid() \u0026\u0026 key.isWritable()) {\n+                  doAsyncWrite(key);\n+              }\n+            } catch (IOException e) {\n+              LOG.info(getName() + \": doAsyncWrite threw exception \" + e);\n+            }\n+          }\n+          long now \u003d System.currentTimeMillis();\n+          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n+            continue;\n+          }\n+          lastPurgeTime \u003d now;\n+          //\n+          // If there were some calls that have not been sent out for a\n+          // long time, discard them.\n+          //\n+          if(LOG.isDebugEnabled()) {\n+            LOG.debug(\"Checking for old call responses.\");\n+          }\n+          ArrayList\u003cCall\u003e calls;\n+          \n+          // get the list of channels from list of keys.\n+          synchronized (writeSelector.keys()) {\n+            calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n+            iter \u003d writeSelector.keys().iterator();\n+            while (iter.hasNext()) {\n+              SelectionKey key \u003d iter.next();\n+              Call call \u003d (Call)key.attachment();\n+              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n+                calls.add(call);\n+              }\n+            }\n+          }\n+          \n+          for(Call call : calls) {\n+            try {\n+              doPurge(call, now);\n+            } catch (IOException e) {\n+              LOG.warn(\"Error in purging old calls \" + e);\n+            }\n+          }\n+        } catch (OutOfMemoryError e) {\n+          //\n+          // we can run out of memory if we have too many threads\n+          // log the event and sleep for a minute and give\n+          // some thread(s) a chance to finish\n+          //\n+          LOG.warn(\"Out of Memory in server select\", e);\n+          try { Thread.sleep(60000); } catch (Exception ie) {}\n+        } catch (Exception e) {\n+          LOG.warn(\"Exception in Responder\", e);\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    private void doRunLoop() {\n      long lastPurgeTime \u003d 0;   // last check for old calls.\n\n      while (running) {\n        try {\n          waitPending();     // If a channel is being registered, wait.\n          writeSelector.select(PURGE_INTERVAL);\n          Iterator\u003cSelectionKey\u003e iter \u003d writeSelector.selectedKeys().iterator();\n          while (iter.hasNext()) {\n            SelectionKey key \u003d iter.next();\n            iter.remove();\n            try {\n              if (key.isValid() \u0026\u0026 key.isWritable()) {\n                  doAsyncWrite(key);\n              }\n            } catch (IOException e) {\n              LOG.info(getName() + \": doAsyncWrite threw exception \" + e);\n            }\n          }\n          long now \u003d System.currentTimeMillis();\n          if (now \u003c lastPurgeTime + PURGE_INTERVAL) {\n            continue;\n          }\n          lastPurgeTime \u003d now;\n          //\n          // If there were some calls that have not been sent out for a\n          // long time, discard them.\n          //\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Checking for old call responses.\");\n          }\n          ArrayList\u003cCall\u003e calls;\n          \n          // get the list of channels from list of keys.\n          synchronized (writeSelector.keys()) {\n            calls \u003d new ArrayList\u003cCall\u003e(writeSelector.keys().size());\n            iter \u003d writeSelector.keys().iterator();\n            while (iter.hasNext()) {\n              SelectionKey key \u003d iter.next();\n              Call call \u003d (Call)key.attachment();\n              if (call !\u003d null \u0026\u0026 key.channel() \u003d\u003d call.connection.channel) { \n                calls.add(call);\n              }\n            }\n          }\n          \n          for(Call call : calls) {\n            try {\n              doPurge(call, now);\n            } catch (IOException e) {\n              LOG.warn(\"Error in purging old calls \" + e);\n            }\n          }\n        } catch (OutOfMemoryError e) {\n          //\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give\n          // some thread(s) a chance to finish\n          //\n          LOG.warn(\"Out of Memory in server select\", e);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          LOG.warn(\"Exception in Responder\", e);\n        }\n      }\n    }",
      "path": "src/java/org/apache/hadoop/ipc/Server.java"
    }
  }
}