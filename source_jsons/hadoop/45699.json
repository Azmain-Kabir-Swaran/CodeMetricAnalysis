{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LogAggregationIndexedFileController.java",
  "functionName": "write",
  "functionId": "write___logKey-LogKey__logValue-LogValue",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
  "functionStartLine": 358,
  "functionEndLine": 422,
  "numCommitsSeen": 18,
  "timeTaken": 1586,
  "changeHistory": [
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc"
  ],
  "changeHistoryShort": {
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": "Ybodychange",
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2b39ad26984d641bad57db2cfcc0b7515ef95f46": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8584. Several typos in Log Aggregation related classes. Contributed by Szilard Nemeth.\n",
      "commitDate": "30/07/18 10:55 AM",
      "commitName": "2b39ad26984d641bad57db2cfcc0b7515ef95f46",
      "commitAuthor": "bibinchundatt",
      "commitDateOld": "12/06/18 8:35 AM",
      "commitNameOld": "652bcbb3e4950758e61ce123ecc1798ae2b60a7f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 48.1,
      "commitsBetweenForRepo": 294,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   public void write(LogKey logKey, LogValue logValue) throws IOException {\n     String containerId \u003d logKey.toString();\n     Set\u003cFile\u003e pendingUploadFiles \u003d logValue\n         .getPendingLogFilesToUploadForThisContainer();\n     List\u003cIndexedFileLogMeta\u003e metas \u003d new ArrayList\u003c\u003e();\n     for (File logFile : pendingUploadFiles) {\n       FileInputStream in \u003d null;\n       try {\n         in \u003d SecureIOUtils.openForRead(logFile, logValue.getUser(), null);\n       } catch (IOException e) {\n         logErrorMessage(logFile, e);\n         IOUtils.cleanupWithLogger(LOG, in);\n         continue;\n       }\n       final long fileLength \u003d logFile.length();\n       IndexedFileOutputStreamState outputStreamState \u003d null;\n       try {\n         outputStreamState \u003d new IndexedFileOutputStreamState(\n             this.compressAlgo, this.fsDataOStream, conf, this.currentOffSet);\n         byte[] buf \u003d new byte[65535];\n         int len \u003d 0;\n         long bytesLeft \u003d fileLength;\n         while ((len \u003d in.read(buf)) !\u003d -1) {\n           //If buffer contents within fileLength, write\n           if (len \u003c bytesLeft) {\n             outputStreamState.getOutputStream().write(buf, 0, len);\n             bytesLeft-\u003dlen;\n           } else {\n             //else only write contents within fileLength, then exit early\n             outputStreamState.getOutputStream().write(buf, 0,\n                 (int)bytesLeft);\n             break;\n           }\n         }\n         long newLength \u003d logFile.length();\n         if(fileLength \u003c newLength) {\n           LOG.warn(\"Aggregated logs truncated by approximately \"+\n               (newLength-fileLength) +\" bytes.\");\n         }\n         logAggregationSuccessfullyInThisCyCle \u003d true;\n       } catch (IOException e) {\n         String message \u003d logErrorMessage(logFile, e);\n         if (outputStreamState !\u003d null \u0026\u0026\n             outputStreamState.getOutputStream() !\u003d null) {\n           outputStreamState.getOutputStream().write(\n               message.getBytes(Charset.forName(\"UTF-8\")));\n         }\n       } finally {\n         IOUtils.cleanupWithLogger(LOG, in);\n       }\n \n       IndexedFileLogMeta meta \u003d new IndexedFileLogMeta();\n       meta.setContainerId(containerId.toString());\n       meta.setFileName(logFile.getName());\n       if (outputStreamState !\u003d null) {\n         outputStreamState.finish();\n         meta.setFileCompressedSize(outputStreamState.getCompressedSize());\n         meta.setStartIndex(outputStreamState.getStartPos());\n         meta.setFileSize(fileLength);\n       }\n-      meta.setLastModificatedTime(logFile.lastModified());\n+      meta.setLastModifiedTime(logFile.lastModified());\n       metas.add(meta);\n     }\n     logsMetaInThisCycle.addContainerLogMeta(containerId, metas);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void write(LogKey logKey, LogValue logValue) throws IOException {\n    String containerId \u003d logKey.toString();\n    Set\u003cFile\u003e pendingUploadFiles \u003d logValue\n        .getPendingLogFilesToUploadForThisContainer();\n    List\u003cIndexedFileLogMeta\u003e metas \u003d new ArrayList\u003c\u003e();\n    for (File logFile : pendingUploadFiles) {\n      FileInputStream in \u003d null;\n      try {\n        in \u003d SecureIOUtils.openForRead(logFile, logValue.getUser(), null);\n      } catch (IOException e) {\n        logErrorMessage(logFile, e);\n        IOUtils.cleanupWithLogger(LOG, in);\n        continue;\n      }\n      final long fileLength \u003d logFile.length();\n      IndexedFileOutputStreamState outputStreamState \u003d null;\n      try {\n        outputStreamState \u003d new IndexedFileOutputStreamState(\n            this.compressAlgo, this.fsDataOStream, conf, this.currentOffSet);\n        byte[] buf \u003d new byte[65535];\n        int len \u003d 0;\n        long bytesLeft \u003d fileLength;\n        while ((len \u003d in.read(buf)) !\u003d -1) {\n          //If buffer contents within fileLength, write\n          if (len \u003c bytesLeft) {\n            outputStreamState.getOutputStream().write(buf, 0, len);\n            bytesLeft-\u003dlen;\n          } else {\n            //else only write contents within fileLength, then exit early\n            outputStreamState.getOutputStream().write(buf, 0,\n                (int)bytesLeft);\n            break;\n          }\n        }\n        long newLength \u003d logFile.length();\n        if(fileLength \u003c newLength) {\n          LOG.warn(\"Aggregated logs truncated by approximately \"+\n              (newLength-fileLength) +\" bytes.\");\n        }\n        logAggregationSuccessfullyInThisCyCle \u003d true;\n      } catch (IOException e) {\n        String message \u003d logErrorMessage(logFile, e);\n        if (outputStreamState !\u003d null \u0026\u0026\n            outputStreamState.getOutputStream() !\u003d null) {\n          outputStreamState.getOutputStream().write(\n              message.getBytes(Charset.forName(\"UTF-8\")));\n        }\n      } finally {\n        IOUtils.cleanupWithLogger(LOG, in);\n      }\n\n      IndexedFileLogMeta meta \u003d new IndexedFileLogMeta();\n      meta.setContainerId(containerId.toString());\n      meta.setFileName(logFile.getName());\n      if (outputStreamState !\u003d null) {\n        outputStreamState.finish();\n        meta.setFileCompressedSize(outputStreamState.getCompressedSize());\n        meta.setStartIndex(outputStreamState.getStartPos());\n        meta.setFileSize(fileLength);\n      }\n      meta.setLastModifiedTime(logFile.lastModified());\n      metas.add(meta);\n    }\n    logsMetaInThisCycle.addContainerLogMeta(containerId, metas);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java",
      "extendedDetails": {}
    },
    "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7072. Add a new log aggregation file format controller. Contributed by Xuan Gong.\n",
      "commitDate": "08/09/17 3:16 PM",
      "commitName": "3fddabc2fe4fbdb8ef3f9ce7558955c4f0794dcc",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,65 @@\n+  public void write(LogKey logKey, LogValue logValue) throws IOException {\n+    String containerId \u003d logKey.toString();\n+    Set\u003cFile\u003e pendingUploadFiles \u003d logValue\n+        .getPendingLogFilesToUploadForThisContainer();\n+    List\u003cIndexedFileLogMeta\u003e metas \u003d new ArrayList\u003c\u003e();\n+    for (File logFile : pendingUploadFiles) {\n+      FileInputStream in \u003d null;\n+      try {\n+        in \u003d SecureIOUtils.openForRead(logFile, logValue.getUser(), null);\n+      } catch (IOException e) {\n+        logErrorMessage(logFile, e);\n+        IOUtils.cleanupWithLogger(LOG, in);\n+        continue;\n+      }\n+      final long fileLength \u003d logFile.length();\n+      IndexedFileOutputStreamState outputStreamState \u003d null;\n+      try {\n+        outputStreamState \u003d new IndexedFileOutputStreamState(\n+            this.compressAlgo, this.fsDataOStream, conf, this.currentOffSet);\n+        byte[] buf \u003d new byte[65535];\n+        int len \u003d 0;\n+        long bytesLeft \u003d fileLength;\n+        while ((len \u003d in.read(buf)) !\u003d -1) {\n+          //If buffer contents within fileLength, write\n+          if (len \u003c bytesLeft) {\n+            outputStreamState.getOutputStream().write(buf, 0, len);\n+            bytesLeft-\u003dlen;\n+          } else {\n+            //else only write contents within fileLength, then exit early\n+            outputStreamState.getOutputStream().write(buf, 0,\n+                (int)bytesLeft);\n+            break;\n+          }\n+        }\n+        long newLength \u003d logFile.length();\n+        if(fileLength \u003c newLength) {\n+          LOG.warn(\"Aggregated logs truncated by approximately \"+\n+              (newLength-fileLength) +\" bytes.\");\n+        }\n+        logAggregationSuccessfullyInThisCyCle \u003d true;\n+      } catch (IOException e) {\n+        String message \u003d logErrorMessage(logFile, e);\n+        if (outputStreamState !\u003d null \u0026\u0026\n+            outputStreamState.getOutputStream() !\u003d null) {\n+          outputStreamState.getOutputStream().write(\n+              message.getBytes(Charset.forName(\"UTF-8\")));\n+        }\n+      } finally {\n+        IOUtils.cleanupWithLogger(LOG, in);\n+      }\n+\n+      IndexedFileLogMeta meta \u003d new IndexedFileLogMeta();\n+      meta.setContainerId(containerId.toString());\n+      meta.setFileName(logFile.getName());\n+      if (outputStreamState !\u003d null) {\n+        outputStreamState.finish();\n+        meta.setFileCompressedSize(outputStreamState.getCompressedSize());\n+        meta.setStartIndex(outputStreamState.getStartPos());\n+        meta.setFileSize(fileLength);\n+      }\n+      meta.setLastModificatedTime(logFile.lastModified());\n+      metas.add(meta);\n+    }\n+    logsMetaInThisCycle.addContainerLogMeta(containerId, metas);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void write(LogKey logKey, LogValue logValue) throws IOException {\n    String containerId \u003d logKey.toString();\n    Set\u003cFile\u003e pendingUploadFiles \u003d logValue\n        .getPendingLogFilesToUploadForThisContainer();\n    List\u003cIndexedFileLogMeta\u003e metas \u003d new ArrayList\u003c\u003e();\n    for (File logFile : pendingUploadFiles) {\n      FileInputStream in \u003d null;\n      try {\n        in \u003d SecureIOUtils.openForRead(logFile, logValue.getUser(), null);\n      } catch (IOException e) {\n        logErrorMessage(logFile, e);\n        IOUtils.cleanupWithLogger(LOG, in);\n        continue;\n      }\n      final long fileLength \u003d logFile.length();\n      IndexedFileOutputStreamState outputStreamState \u003d null;\n      try {\n        outputStreamState \u003d new IndexedFileOutputStreamState(\n            this.compressAlgo, this.fsDataOStream, conf, this.currentOffSet);\n        byte[] buf \u003d new byte[65535];\n        int len \u003d 0;\n        long bytesLeft \u003d fileLength;\n        while ((len \u003d in.read(buf)) !\u003d -1) {\n          //If buffer contents within fileLength, write\n          if (len \u003c bytesLeft) {\n            outputStreamState.getOutputStream().write(buf, 0, len);\n            bytesLeft-\u003dlen;\n          } else {\n            //else only write contents within fileLength, then exit early\n            outputStreamState.getOutputStream().write(buf, 0,\n                (int)bytesLeft);\n            break;\n          }\n        }\n        long newLength \u003d logFile.length();\n        if(fileLength \u003c newLength) {\n          LOG.warn(\"Aggregated logs truncated by approximately \"+\n              (newLength-fileLength) +\" bytes.\");\n        }\n        logAggregationSuccessfullyInThisCyCle \u003d true;\n      } catch (IOException e) {\n        String message \u003d logErrorMessage(logFile, e);\n        if (outputStreamState !\u003d null \u0026\u0026\n            outputStreamState.getOutputStream() !\u003d null) {\n          outputStreamState.getOutputStream().write(\n              message.getBytes(Charset.forName(\"UTF-8\")));\n        }\n      } finally {\n        IOUtils.cleanupWithLogger(LOG, in);\n      }\n\n      IndexedFileLogMeta meta \u003d new IndexedFileLogMeta();\n      meta.setContainerId(containerId.toString());\n      meta.setFileName(logFile.getName());\n      if (outputStreamState !\u003d null) {\n        outputStreamState.finish();\n        meta.setFileCompressedSize(outputStreamState.getCompressedSize());\n        meta.setStartIndex(outputStreamState.getStartPos());\n        meta.setFileSize(fileLength);\n      }\n      meta.setLastModificatedTime(logFile.lastModified());\n      metas.add(meta);\n    }\n    logsMetaInThisCycle.addContainerLogMeta(containerId, metas);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/logaggregation/filecontroller/ifile/LogAggregationIndexedFileController.java"
    }
  }
}