{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ApplicationHistoryManagerOnTimelineStore.java",
  "functionName": "convertToApplicationReport",
  "functionId": "convertToApplicationReport___entity-TimelineEntity__field-ApplicationReportField",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
  "functionStartLine": 245,
  "functionEndLine": 466,
  "numCommitsSeen": 42,
  "timeTaken": 8145,
  "changeHistory": [
    "9520b2ad790bd8527033a03e7ee50da71a85df1d",
    "491313ab84cc76683d0ef93a1ac17d8ecc8c430c",
    "04105bbfdb041a41062c856632641140de84fba8",
    "dae65f3bef8ffa34d02a37041f1dfdfeeee91845",
    "c48f2976a3de60b95c4a5ada4f0131c4cdde177a",
    "93eeb13164707d0e3556c2bf737bd2ee09a335c6",
    "4d2f380d787a6145f45c87ba663079fedbf645b8",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "141873ca7d68619e3458712b17aed57fec8fd7c8",
    "39f2bac38b111f90d3402229201cdb4315f5d4f5",
    "3cc73773eb26f7469c99b25a76814d6fad0be28e",
    "a9aafad12b1d2f67e55e09a6fa261d61789c9d7e",
    "ae5308fe1d08479da0f3929cc6a57816411e9121",
    "1c12adb71f32f24ec525313ff8dfcd2b738fc8e2",
    "0306d902f53582320aa5895ca9f5c31f64aaaff6",
    "3e000a919fede85230fcfb06309a1f1d5e0c479c",
    "bc85959eddcb11037e8b9f0e06780b7c3e1cbab6",
    "4a9ec1a8243e2394ff7221b1c20dfaa80e9f5111",
    "19a4feaf6fcf42ebbfe98b8a7153ade96d37fb14",
    "e5b56e2af6b48cbc8501f624ae4b4f9d13eccacf",
    "bbff96be48119774688981d04baf444639135977",
    "90a0c03f0a696d32e871a5da4560828edea8cfa9",
    "6b8b1608e64e300e4e1d23c60476febaca29ca38"
  ],
  "changeHistoryShort": {
    "9520b2ad790bd8527033a03e7ee50da71a85df1d": "Ybodychange",
    "491313ab84cc76683d0ef93a1ac17d8ecc8c430c": "Ybodychange",
    "04105bbfdb041a41062c856632641140de84fba8": "Ybodychange",
    "dae65f3bef8ffa34d02a37041f1dfdfeeee91845": "Ybodychange",
    "c48f2976a3de60b95c4a5ada4f0131c4cdde177a": "Ybodychange",
    "93eeb13164707d0e3556c2bf737bd2ee09a335c6": "Ybodychange",
    "4d2f380d787a6145f45c87ba663079fedbf645b8": "Ybodychange",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "141873ca7d68619e3458712b17aed57fec8fd7c8": "Ybodychange",
    "39f2bac38b111f90d3402229201cdb4315f5d4f5": "Ybodychange",
    "3cc73773eb26f7469c99b25a76814d6fad0be28e": "Ybodychange",
    "a9aafad12b1d2f67e55e09a6fa261d61789c9d7e": "Ybodychange",
    "ae5308fe1d08479da0f3929cc6a57816411e9121": "Ybodychange",
    "1c12adb71f32f24ec525313ff8dfcd2b738fc8e2": "Ybodychange",
    "0306d902f53582320aa5895ca9f5c31f64aaaff6": "Ybodychange",
    "3e000a919fede85230fcfb06309a1f1d5e0c479c": "Ybodychange",
    "bc85959eddcb11037e8b9f0e06780b7c3e1cbab6": "Ybodychange",
    "4a9ec1a8243e2394ff7221b1c20dfaa80e9f5111": "Ybodychange",
    "19a4feaf6fcf42ebbfe98b8a7153ade96d37fb14": "Ybodychange",
    "e5b56e2af6b48cbc8501f624ae4b4f9d13eccacf": "Ybodychange",
    "bbff96be48119774688981d04baf444639135977": "Ybodychange",
    "90a0c03f0a696d32e871a5da4560828edea8cfa9": "Ymultichange(Yreturntypechange,Ybodychange)",
    "6b8b1608e64e300e4e1d23c60476febaca29ca38": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9520b2ad790bd8527033a03e7ee50da71a85df1d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-10083. Provide utility to ask whether an application is in final status. Contributed by Adam Antal\n",
      "commitDate": "22/01/20 7:25 AM",
      "commitName": "9520b2ad790bd8527033a03e7ee50da71a85df1d",
      "commitAuthor": "Szilard Nemeth",
      "commitDateOld": "06/03/19 9:47 PM",
      "commitNameOld": "491313ab84cc76683d0ef93a1ac17d8ecc8c430c",
      "commitAuthorOld": "Vrushali C",
      "daysBetweenCommits": 321.4,
      "commitsBetweenForRepo": 2063,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,222 +1,222 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long launchTime \u003d 0;\n     long submittedTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ApplicationId.fromString(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n             state, diagnosticsInfo, null, createdTime, submittedTime, 0,\n             finishedTime, finalStatus, null, null, progress, type, null,\n             appTags, unmanagedApplication, Priority.newInstance(\n             applicationPriority), appNodeLabelExpression,\n             amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n         appNodeLabelExpression \u003d entityInfo\n             .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n         amNodeLabelExpression \u003d\n             entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                 .toString();\n       }\n       submittedTime \u003d parseLong(entityInfo,\n           ApplicationMetricsConstants.SUBMITTED_TIME_ENTITY_INFO);\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_CPU_METRICS);\n         long memorySeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_MEM_METRICS);\n         long preemptedMemorySeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS);\n         long preemptedVcoreSeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS);\n         Map\u003cString, Long\u003e resourceSecondsMap \u003d new HashMap\u003c\u003e();\n         Map\u003cString, Long\u003e preemptedResoureSecondsMap \u003d new HashMap\u003c\u003e();\n         resourceSecondsMap\n             .put(ResourceInformation.MEMORY_MB.getName(), memorySeconds);\n         resourceSecondsMap\n             .put(ResourceInformation.VCORES.getName(), vcoreSeconds);\n         preemptedResoureSecondsMap.put(ResourceInformation.MEMORY_MB.getName(),\n             preemptedMemorySeconds);\n         preemptedResoureSecondsMap\n             .put(ResourceInformation.VCORES.getName(), preemptedVcoreSeconds);\n \n         appResources \u003d ApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, resourceSecondsMap, 0, 0,\n                 preemptedResoureSecondsMap);\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     long updatedTimeStamp \u003d 0L;\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.LAUNCHED_EVENT_TYPE)) {\n           launchTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n           // This type of events are parsed in time-stamp descending order\n           // which means the previous event could override the information\n           // from the later same type of event. Hence compare timestamp\n           // before over writing.\n           if (event.getTimestamp() \u003e updatedTimeStamp) {\n             updatedTimeStamp \u003d event.getTimestamp();\n           } else {\n             continue;\n           }\n \n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           applicationPriority \u003d Integer\n               .parseInt(eventInfo.get(\n                   ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                   .toString());\n           queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n               .toString();\n         } else if (event.getEventType().equals(\n               ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo.containsKey(\n               ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n-            if (!isFinalState(state)) {\n+            if (!Apps.isApplicationFinalState(state)) {\n               state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                   ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n             }\n           }\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                 eventInfo.get(\n                     ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ApplicationId.fromString(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime,\n         submittedTime, launchTime, finishedTime,\n         finalStatus, appResources, null, progress, type, null, appTags,\n         unmanagedApplication, Priority.newInstance(applicationPriority),\n         appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long launchTime \u003d 0;\n    long submittedTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ApplicationId.fromString(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, submittedTime, 0,\n            finishedTime, finalStatus, null, null, progress, type, null,\n            appTags, unmanagedApplication, Priority.newInstance(\n            applicationPriority), appNodeLabelExpression,\n            amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n      submittedTime \u003d parseLong(entityInfo,\n          ApplicationMetricsConstants.SUBMITTED_TIME_ENTITY_INFO);\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_CPU_METRICS);\n        long memorySeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_MEM_METRICS);\n        long preemptedMemorySeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS);\n        long preemptedVcoreSeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS);\n        Map\u003cString, Long\u003e resourceSecondsMap \u003d new HashMap\u003c\u003e();\n        Map\u003cString, Long\u003e preemptedResoureSecondsMap \u003d new HashMap\u003c\u003e();\n        resourceSecondsMap\n            .put(ResourceInformation.MEMORY_MB.getName(), memorySeconds);\n        resourceSecondsMap\n            .put(ResourceInformation.VCORES.getName(), vcoreSeconds);\n        preemptedResoureSecondsMap.put(ResourceInformation.MEMORY_MB.getName(),\n            preemptedMemorySeconds);\n        preemptedResoureSecondsMap\n            .put(ResourceInformation.VCORES.getName(), preemptedVcoreSeconds);\n\n        appResources \u003d ApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, resourceSecondsMap, 0, 0,\n                preemptedResoureSecondsMap);\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    long updatedTimeStamp \u003d 0L;\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.LAUNCHED_EVENT_TYPE)) {\n          launchTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          // This type of events are parsed in time-stamp descending order\n          // which means the previous event could override the information\n          // from the later same type of event. Hence compare timestamp\n          // before over writing.\n          if (event.getTimestamp() \u003e updatedTimeStamp) {\n            updatedTimeStamp \u003d event.getTimestamp();\n          } else {\n            continue;\n          }\n\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          applicationPriority \u003d Integer\n              .parseInt(eventInfo.get(\n                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                  .toString());\n          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n              .toString();\n        } else if (event.getEventType().equals(\n              ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo.containsKey(\n              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            if (!Apps.isApplicationFinalState(state)) {\n              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n            }\n          }\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                eventInfo.get(\n                    ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ApplicationId.fromString(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime,\n        submittedTime, launchTime, finishedTime,\n        finalStatus, appResources, null, progress, type, null, appTags,\n        unmanagedApplication, Priority.newInstance(applicationPriority),\n        appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "491313ab84cc76683d0ef93a1ac17d8ecc8c430c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8218 Add application launch time to ATSV1. Contributed by Abhishek Modi\n",
      "commitDate": "06/03/19 9:47 PM",
      "commitName": "491313ab84cc76683d0ef93a1ac17d8ecc8c430c",
      "commitAuthor": "Vrushali C",
      "commitDateOld": "29/01/19 9:22 AM",
      "commitNameOld": "04105bbfdb041a41062c856632641140de84fba8",
      "commitAuthorOld": "Eric E Payne",
      "daysBetweenCommits": 36.52,
      "commitsBetweenForRepo": 316,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,217 +1,222 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n+    long launchTime \u003d 0;\n     long submittedTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ApplicationId.fromString(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n             state, diagnosticsInfo, null, createdTime, submittedTime, 0,\n             finishedTime, finalStatus, null, null, progress, type, null,\n             appTags, unmanagedApplication, Priority.newInstance(\n             applicationPriority), appNodeLabelExpression,\n             amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n         appNodeLabelExpression \u003d entityInfo\n             .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n         amNodeLabelExpression \u003d\n             entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                 .toString();\n       }\n       submittedTime \u003d parseLong(entityInfo,\n           ApplicationMetricsConstants.SUBMITTED_TIME_ENTITY_INFO);\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_CPU_METRICS);\n         long memorySeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_MEM_METRICS);\n         long preemptedMemorySeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS);\n         long preemptedVcoreSeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS);\n         Map\u003cString, Long\u003e resourceSecondsMap \u003d new HashMap\u003c\u003e();\n         Map\u003cString, Long\u003e preemptedResoureSecondsMap \u003d new HashMap\u003c\u003e();\n         resourceSecondsMap\n             .put(ResourceInformation.MEMORY_MB.getName(), memorySeconds);\n         resourceSecondsMap\n             .put(ResourceInformation.VCORES.getName(), vcoreSeconds);\n         preemptedResoureSecondsMap.put(ResourceInformation.MEMORY_MB.getName(),\n             preemptedMemorySeconds);\n         preemptedResoureSecondsMap\n             .put(ResourceInformation.VCORES.getName(), preemptedVcoreSeconds);\n \n         appResources \u003d ApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, resourceSecondsMap, 0, 0,\n                 preemptedResoureSecondsMap);\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     long updatedTimeStamp \u003d 0L;\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n+            ApplicationMetricsConstants.LAUNCHED_EVENT_TYPE)) {\n+          launchTime \u003d event.getTimestamp();\n+        } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n           // This type of events are parsed in time-stamp descending order\n           // which means the previous event could override the information\n           // from the later same type of event. Hence compare timestamp\n           // before over writing.\n           if (event.getTimestamp() \u003e updatedTimeStamp) {\n             updatedTimeStamp \u003d event.getTimestamp();\n           } else {\n             continue;\n           }\n \n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           applicationPriority \u003d Integer\n               .parseInt(eventInfo.get(\n                   ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                   .toString());\n           queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n               .toString();\n         } else if (event.getEventType().equals(\n               ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo.containsKey(\n               ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             if (!isFinalState(state)) {\n               state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                   ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n             }\n           }\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                 eventInfo.get(\n                     ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ApplicationId.fromString(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n-        diagnosticsInfo, null, createdTime, submittedTime, 0, finishedTime,\n+        diagnosticsInfo, null, createdTime,\n+        submittedTime, launchTime, finishedTime,\n         finalStatus, appResources, null, progress, type, null, appTags,\n         unmanagedApplication, Priority.newInstance(applicationPriority),\n         appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long launchTime \u003d 0;\n    long submittedTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ApplicationId.fromString(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, submittedTime, 0,\n            finishedTime, finalStatus, null, null, progress, type, null,\n            appTags, unmanagedApplication, Priority.newInstance(\n            applicationPriority), appNodeLabelExpression,\n            amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n      submittedTime \u003d parseLong(entityInfo,\n          ApplicationMetricsConstants.SUBMITTED_TIME_ENTITY_INFO);\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_CPU_METRICS);\n        long memorySeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_MEM_METRICS);\n        long preemptedMemorySeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS);\n        long preemptedVcoreSeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS);\n        Map\u003cString, Long\u003e resourceSecondsMap \u003d new HashMap\u003c\u003e();\n        Map\u003cString, Long\u003e preemptedResoureSecondsMap \u003d new HashMap\u003c\u003e();\n        resourceSecondsMap\n            .put(ResourceInformation.MEMORY_MB.getName(), memorySeconds);\n        resourceSecondsMap\n            .put(ResourceInformation.VCORES.getName(), vcoreSeconds);\n        preemptedResoureSecondsMap.put(ResourceInformation.MEMORY_MB.getName(),\n            preemptedMemorySeconds);\n        preemptedResoureSecondsMap\n            .put(ResourceInformation.VCORES.getName(), preemptedVcoreSeconds);\n\n        appResources \u003d ApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, resourceSecondsMap, 0, 0,\n                preemptedResoureSecondsMap);\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    long updatedTimeStamp \u003d 0L;\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.LAUNCHED_EVENT_TYPE)) {\n          launchTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          // This type of events are parsed in time-stamp descending order\n          // which means the previous event could override the information\n          // from the later same type of event. Hence compare timestamp\n          // before over writing.\n          if (event.getTimestamp() \u003e updatedTimeStamp) {\n            updatedTimeStamp \u003d event.getTimestamp();\n          } else {\n            continue;\n          }\n\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          applicationPriority \u003d Integer\n              .parseInt(eventInfo.get(\n                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                  .toString());\n          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n              .toString();\n        } else if (event.getEventType().equals(\n              ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo.containsKey(\n              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            if (!isFinalState(state)) {\n              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n            }\n          }\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                eventInfo.get(\n                    ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ApplicationId.fromString(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime,\n        submittedTime, launchTime, finishedTime,\n        finalStatus, appResources, null, progress, type, null, appTags,\n        unmanagedApplication, Priority.newInstance(applicationPriority),\n        appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "04105bbfdb041a41062c856632641140de84fba8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6616: YARN AHS shows submitTime for jobs same as startTime. Contributed by  Prabhu Joseph\n",
      "commitDate": "29/01/19 9:22 AM",
      "commitName": "04105bbfdb041a41062c856632641140de84fba8",
      "commitAuthor": "Eric E Payne",
      "commitDateOld": "21/12/18 4:44 PM",
      "commitNameOld": "f82922dcfae0b7e3e68ce970c441d8b7edc59acf",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 38.69,
      "commitsBetweenForRepo": 259,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,213 +1,217 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n+    long submittedTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ApplicationId.fromString(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n-            state, diagnosticsInfo, null, createdTime, finishedTime,\n-            finalStatus, null, null, progress, type, null, appTags,\n-            unmanagedApplication, Priority.newInstance(applicationPriority),\n-            appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n+            state, diagnosticsInfo, null, createdTime, submittedTime, 0,\n+            finishedTime, finalStatus, null, null, progress, type, null,\n+            appTags, unmanagedApplication, Priority.newInstance(\n+            applicationPriority), appNodeLabelExpression,\n+            amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n         appNodeLabelExpression \u003d entityInfo\n             .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n         amNodeLabelExpression \u003d\n             entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                 .toString();\n       }\n+      submittedTime \u003d parseLong(entityInfo,\n+          ApplicationMetricsConstants.SUBMITTED_TIME_ENTITY_INFO);\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_CPU_METRICS);\n         long memorySeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_MEM_METRICS);\n         long preemptedMemorySeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS);\n         long preemptedVcoreSeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS);\n         Map\u003cString, Long\u003e resourceSecondsMap \u003d new HashMap\u003c\u003e();\n         Map\u003cString, Long\u003e preemptedResoureSecondsMap \u003d new HashMap\u003c\u003e();\n         resourceSecondsMap\n             .put(ResourceInformation.MEMORY_MB.getName(), memorySeconds);\n         resourceSecondsMap\n             .put(ResourceInformation.VCORES.getName(), vcoreSeconds);\n         preemptedResoureSecondsMap.put(ResourceInformation.MEMORY_MB.getName(),\n             preemptedMemorySeconds);\n         preemptedResoureSecondsMap\n             .put(ResourceInformation.VCORES.getName(), preemptedVcoreSeconds);\n \n         appResources \u003d ApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, resourceSecondsMap, 0, 0,\n                 preemptedResoureSecondsMap);\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     long updatedTimeStamp \u003d 0L;\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n           // This type of events are parsed in time-stamp descending order\n           // which means the previous event could override the information\n           // from the later same type of event. Hence compare timestamp\n           // before over writing.\n           if (event.getTimestamp() \u003e updatedTimeStamp) {\n             updatedTimeStamp \u003d event.getTimestamp();\n           } else {\n             continue;\n           }\n \n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           applicationPriority \u003d Integer\n               .parseInt(eventInfo.get(\n                   ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                   .toString());\n           queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n               .toString();\n         } else if (event.getEventType().equals(\n               ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo.containsKey(\n               ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             if (!isFinalState(state)) {\n               state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                   ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n             }\n           }\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                 eventInfo.get(\n                     ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ApplicationId.fromString(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n-        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n-        appResources, null, progress, type, null, appTags, unmanagedApplication,\n-        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n-        amNodeLabelExpression), appViewACLs);\n+        diagnosticsInfo, null, createdTime, submittedTime, 0, finishedTime,\n+        finalStatus, appResources, null, progress, type, null, appTags,\n+        unmanagedApplication, Priority.newInstance(applicationPriority),\n+        appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long submittedTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ApplicationId.fromString(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, submittedTime, 0,\n            finishedTime, finalStatus, null, null, progress, type, null,\n            appTags, unmanagedApplication, Priority.newInstance(\n            applicationPriority), appNodeLabelExpression,\n            amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n      submittedTime \u003d parseLong(entityInfo,\n          ApplicationMetricsConstants.SUBMITTED_TIME_ENTITY_INFO);\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_CPU_METRICS);\n        long memorySeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_MEM_METRICS);\n        long preemptedMemorySeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS);\n        long preemptedVcoreSeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS);\n        Map\u003cString, Long\u003e resourceSecondsMap \u003d new HashMap\u003c\u003e();\n        Map\u003cString, Long\u003e preemptedResoureSecondsMap \u003d new HashMap\u003c\u003e();\n        resourceSecondsMap\n            .put(ResourceInformation.MEMORY_MB.getName(), memorySeconds);\n        resourceSecondsMap\n            .put(ResourceInformation.VCORES.getName(), vcoreSeconds);\n        preemptedResoureSecondsMap.put(ResourceInformation.MEMORY_MB.getName(),\n            preemptedMemorySeconds);\n        preemptedResoureSecondsMap\n            .put(ResourceInformation.VCORES.getName(), preemptedVcoreSeconds);\n\n        appResources \u003d ApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, resourceSecondsMap, 0, 0,\n                preemptedResoureSecondsMap);\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    long updatedTimeStamp \u003d 0L;\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          // This type of events are parsed in time-stamp descending order\n          // which means the previous event could override the information\n          // from the later same type of event. Hence compare timestamp\n          // before over writing.\n          if (event.getTimestamp() \u003e updatedTimeStamp) {\n            updatedTimeStamp \u003d event.getTimestamp();\n          } else {\n            continue;\n          }\n\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          applicationPriority \u003d Integer\n              .parseInt(eventInfo.get(\n                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                  .toString());\n          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n              .toString();\n        } else if (event.getEventType().equals(\n              ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo.containsKey(\n              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            if (!isFinalState(state)) {\n              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n            }\n          }\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                eventInfo.get(\n                    ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ApplicationId.fromString(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, submittedTime, 0, finishedTime,\n        finalStatus, appResources, null, progress, type, null, appTags,\n        unmanagedApplication, Priority.newInstance(applicationPriority),\n        appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "dae65f3bef8ffa34d02a37041f1dfdfeeee91845": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6232. Update resource usage and preempted resource calculations to take into account all resource types. Contributed by Varun Vasudev.\n",
      "commitDate": "12/09/17 9:19 AM",
      "commitName": "dae65f3bef8ffa34d02a37041f1dfdfeeee91845",
      "commitAuthor": "Sunil G",
      "commitDateOld": "07/08/17 2:56 AM",
      "commitNameOld": "839e077faf4019d6efdcd89d95930023cd0b0a08",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 36.27,
      "commitsBetweenForRepo": 308,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,202 +1,213 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ApplicationId.fromString(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n             state, diagnosticsInfo, null, createdTime, finishedTime,\n             finalStatus, null, null, progress, type, null, appTags,\n             unmanagedApplication, Priority.newInstance(applicationPriority),\n             appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n         appNodeLabelExpression \u003d entityInfo\n             .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n         amNodeLabelExpression \u003d\n             entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                 .toString();\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_CPU_METRICS);\n         long memorySeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_MEM_METRICS);\n         long preemptedMemorySeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS);\n         long preemptedVcoreSeconds \u003d parseLong(entityInfo,\n             ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS);\n-        appResources \u003d ApplicationResourceUsageReport.newInstance(0, 0, null,\n-            null, null, memorySeconds, vcoreSeconds, 0, 0,\n-            preemptedMemorySeconds, preemptedVcoreSeconds);\n+        Map\u003cString, Long\u003e resourceSecondsMap \u003d new HashMap\u003c\u003e();\n+        Map\u003cString, Long\u003e preemptedResoureSecondsMap \u003d new HashMap\u003c\u003e();\n+        resourceSecondsMap\n+            .put(ResourceInformation.MEMORY_MB.getName(), memorySeconds);\n+        resourceSecondsMap\n+            .put(ResourceInformation.VCORES.getName(), vcoreSeconds);\n+        preemptedResoureSecondsMap.put(ResourceInformation.MEMORY_MB.getName(),\n+            preemptedMemorySeconds);\n+        preemptedResoureSecondsMap\n+            .put(ResourceInformation.VCORES.getName(), preemptedVcoreSeconds);\n+\n+        appResources \u003d ApplicationResourceUsageReport\n+            .newInstance(0, 0, null, null, null, resourceSecondsMap, 0, 0,\n+                preemptedResoureSecondsMap);\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     long updatedTimeStamp \u003d 0L;\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n           // This type of events are parsed in time-stamp descending order\n           // which means the previous event could override the information\n           // from the later same type of event. Hence compare timestamp\n           // before over writing.\n           if (event.getTimestamp() \u003e updatedTimeStamp) {\n             updatedTimeStamp \u003d event.getTimestamp();\n           } else {\n             continue;\n           }\n \n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           applicationPriority \u003d Integer\n               .parseInt(eventInfo.get(\n                   ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                   .toString());\n           queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n               .toString();\n         } else if (event.getEventType().equals(\n               ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo.containsKey(\n               ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             if (!isFinalState(state)) {\n               state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                   ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n             }\n           }\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                 eventInfo.get(\n                     ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ApplicationId.fromString(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n         appResources, null, progress, type, null, appTags, unmanagedApplication,\n         Priority.newInstance(applicationPriority), appNodeLabelExpression,\n         amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ApplicationId.fromString(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, finishedTime,\n            finalStatus, null, null, progress, type, null, appTags,\n            unmanagedApplication, Priority.newInstance(applicationPriority),\n            appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_CPU_METRICS);\n        long memorySeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_MEM_METRICS);\n        long preemptedMemorySeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS);\n        long preemptedVcoreSeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS);\n        Map\u003cString, Long\u003e resourceSecondsMap \u003d new HashMap\u003c\u003e();\n        Map\u003cString, Long\u003e preemptedResoureSecondsMap \u003d new HashMap\u003c\u003e();\n        resourceSecondsMap\n            .put(ResourceInformation.MEMORY_MB.getName(), memorySeconds);\n        resourceSecondsMap\n            .put(ResourceInformation.VCORES.getName(), vcoreSeconds);\n        preemptedResoureSecondsMap.put(ResourceInformation.MEMORY_MB.getName(),\n            preemptedMemorySeconds);\n        preemptedResoureSecondsMap\n            .put(ResourceInformation.VCORES.getName(), preemptedVcoreSeconds);\n\n        appResources \u003d ApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, resourceSecondsMap, 0, 0,\n                preemptedResoureSecondsMap);\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    long updatedTimeStamp \u003d 0L;\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          // This type of events are parsed in time-stamp descending order\n          // which means the previous event could override the information\n          // from the later same type of event. Hence compare timestamp\n          // before over writing.\n          if (event.getTimestamp() \u003e updatedTimeStamp) {\n            updatedTimeStamp \u003d event.getTimestamp();\n          } else {\n            continue;\n          }\n\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          applicationPriority \u003d Integer\n              .parseInt(eventInfo.get(\n                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                  .toString());\n          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n              .toString();\n        } else if (event.getEventType().equals(\n              ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo.containsKey(\n              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            if (!isFinalState(state)) {\n              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n            }\n          }\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                eventInfo.get(\n                    ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ApplicationId.fromString(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n        appResources, null, progress, type, null, appTags, unmanagedApplication,\n        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n        amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "c48f2976a3de60b95c4a5ada4f0131c4cdde177a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6598. History server getApplicationReport NPE when fetching report for pre-2.8 job (Jason Lowe via jeagles)\n",
      "commitDate": "15/05/17 8:32 AM",
      "commitName": "c48f2976a3de60b95c4a5ada4f0131c4cdde177a",
      "commitAuthor": "Jonathan Eagles",
      "commitDateOld": "07/12/16 3:07 PM",
      "commitNameOld": "72fe54684198b7df5c5fb2114616dff6d17a4402",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 158.68,
      "commitsBetweenForRepo": 839,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,203 +1,202 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ApplicationId.fromString(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n             state, diagnosticsInfo, null, createdTime, finishedTime,\n             finalStatus, null, null, progress, type, null, appTags,\n             unmanagedApplication, Priority.newInstance(applicationPriority),\n             appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n         appNodeLabelExpression \u003d entityInfo\n             .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n         amNodeLabelExpression \u003d\n             entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                 .toString();\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n-        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n-                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n-        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n-                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n-        long preemptedMemorySeconds \u003d Long.parseLong(entityInfo.get(\n-            ApplicationMetricsConstants\n-                .APP_MEM_PREEMPT_METRICS).toString());\n-        long preemptedVcoreSeconds \u003d Long.parseLong(entityInfo.get(\n-            ApplicationMetricsConstants\n-                .APP_CPU_PREEMPT_METRICS).toString());\n-        appResources \u003d ApplicationResourceUsageReport\n-            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n-                0, preemptedMemorySeconds, preemptedVcoreSeconds);\n+        long vcoreSeconds \u003d parseLong(entityInfo,\n+            ApplicationMetricsConstants.APP_CPU_METRICS);\n+        long memorySeconds \u003d parseLong(entityInfo,\n+            ApplicationMetricsConstants.APP_MEM_METRICS);\n+        long preemptedMemorySeconds \u003d parseLong(entityInfo,\n+            ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS);\n+        long preemptedVcoreSeconds \u003d parseLong(entityInfo,\n+            ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS);\n+        appResources \u003d ApplicationResourceUsageReport.newInstance(0, 0, null,\n+            null, null, memorySeconds, vcoreSeconds, 0, 0,\n+            preemptedMemorySeconds, preemptedVcoreSeconds);\n       }\n+\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     long updatedTimeStamp \u003d 0L;\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n           // This type of events are parsed in time-stamp descending order\n           // which means the previous event could override the information\n           // from the later same type of event. Hence compare timestamp\n           // before over writing.\n           if (event.getTimestamp() \u003e updatedTimeStamp) {\n             updatedTimeStamp \u003d event.getTimestamp();\n           } else {\n             continue;\n           }\n \n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           applicationPriority \u003d Integer\n               .parseInt(eventInfo.get(\n                   ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                   .toString());\n           queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n               .toString();\n         } else if (event.getEventType().equals(\n               ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo.containsKey(\n               ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             if (!isFinalState(state)) {\n               state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                   ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n             }\n           }\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                 eventInfo.get(\n                     ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ApplicationId.fromString(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n         appResources, null, progress, type, null, appTags, unmanagedApplication,\n         Priority.newInstance(applicationPriority), appNodeLabelExpression,\n         amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ApplicationId.fromString(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, finishedTime,\n            finalStatus, null, null, progress, type, null, appTags,\n            unmanagedApplication, Priority.newInstance(applicationPriority),\n            appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_CPU_METRICS);\n        long memorySeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_MEM_METRICS);\n        long preemptedMemorySeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_MEM_PREEMPT_METRICS);\n        long preemptedVcoreSeconds \u003d parseLong(entityInfo,\n            ApplicationMetricsConstants.APP_CPU_PREEMPT_METRICS);\n        appResources \u003d ApplicationResourceUsageReport.newInstance(0, 0, null,\n            null, null, memorySeconds, vcoreSeconds, 0, 0,\n            preemptedMemorySeconds, preemptedVcoreSeconds);\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    long updatedTimeStamp \u003d 0L;\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          // This type of events are parsed in time-stamp descending order\n          // which means the previous event could override the information\n          // from the later same type of event. Hence compare timestamp\n          // before over writing.\n          if (event.getTimestamp() \u003e updatedTimeStamp) {\n            updatedTimeStamp \u003d event.getTimestamp();\n          } else {\n            continue;\n          }\n\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          applicationPriority \u003d Integer\n              .parseInt(eventInfo.get(\n                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                  .toString());\n          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n              .toString();\n        } else if (event.getEventType().equals(\n              ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo.containsKey(\n              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            if (!isFinalState(state)) {\n              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n            }\n          }\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                eventInfo.get(\n                    ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ApplicationId.fromString(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n        appResources, null, progress, type, null, appTags, unmanagedApplication,\n        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n        amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "93eeb13164707d0e3556c2bf737bd2ee09a335c6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4218. Metric for resource*time that was preempted. Contributed by Chang Li.\n",
      "commitDate": "10/11/16 2:35 PM",
      "commitName": "93eeb13164707d0e3556c2bf737bd2ee09a335c6",
      "commitAuthor": "Eric Payne",
      "commitDateOld": "15/10/16 1:54 PM",
      "commitNameOld": "1f304b0c7f261369dd68839507bb609a949965ad",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 26.07,
      "commitsBetweenForRepo": 264,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,197 +1,203 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ApplicationId.fromString(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n             state, diagnosticsInfo, null, createdTime, finishedTime,\n             finalStatus, null, null, progress, type, null, appTags,\n             unmanagedApplication, Priority.newInstance(applicationPriority),\n             appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n         appNodeLabelExpression \u003d entityInfo\n             .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n         amNodeLabelExpression \u003d\n             entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                 .toString();\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n+        long preemptedMemorySeconds \u003d Long.parseLong(entityInfo.get(\n+            ApplicationMetricsConstants\n+                .APP_MEM_PREEMPT_METRICS).toString());\n+        long preemptedVcoreSeconds \u003d Long.parseLong(entityInfo.get(\n+            ApplicationMetricsConstants\n+                .APP_CPU_PREEMPT_METRICS).toString());\n         appResources \u003d ApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n-                0);\n+                0, preemptedMemorySeconds, preemptedVcoreSeconds);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     long updatedTimeStamp \u003d 0L;\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n           // This type of events are parsed in time-stamp descending order\n           // which means the previous event could override the information\n           // from the later same type of event. Hence compare timestamp\n           // before over writing.\n           if (event.getTimestamp() \u003e updatedTimeStamp) {\n             updatedTimeStamp \u003d event.getTimestamp();\n           } else {\n             continue;\n           }\n \n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           applicationPriority \u003d Integer\n               .parseInt(eventInfo.get(\n                   ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                   .toString());\n           queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n               .toString();\n         } else if (event.getEventType().equals(\n               ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo.containsKey(\n               ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             if (!isFinalState(state)) {\n               state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                   ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n             }\n           }\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                 eventInfo.get(\n                     ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ApplicationId.fromString(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n         appResources, null, progress, type, null, appTags, unmanagedApplication,\n         Priority.newInstance(applicationPriority), appNodeLabelExpression,\n         amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ApplicationId.fromString(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, finishedTime,\n            finalStatus, null, null, progress, type, null, appTags,\n            unmanagedApplication, Priority.newInstance(applicationPriority),\n            appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        long preemptedMemorySeconds \u003d Long.parseLong(entityInfo.get(\n            ApplicationMetricsConstants\n                .APP_MEM_PREEMPT_METRICS).toString());\n        long preemptedVcoreSeconds \u003d Long.parseLong(entityInfo.get(\n            ApplicationMetricsConstants\n                .APP_CPU_PREEMPT_METRICS).toString());\n        appResources \u003d ApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n                0, preemptedMemorySeconds, preemptedVcoreSeconds);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    long updatedTimeStamp \u003d 0L;\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          // This type of events are parsed in time-stamp descending order\n          // which means the previous event could override the information\n          // from the later same type of event. Hence compare timestamp\n          // before over writing.\n          if (event.getTimestamp() \u003e updatedTimeStamp) {\n            updatedTimeStamp \u003d event.getTimestamp();\n          } else {\n            continue;\n          }\n\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          applicationPriority \u003d Integer\n              .parseInt(eventInfo.get(\n                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                  .toString());\n          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n              .toString();\n        } else if (event.getEventType().equals(\n              ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo.containsKey(\n              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            if (!isFinalState(state)) {\n              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n            }\n          }\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                eventInfo.get(\n                    ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ApplicationId.fromString(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n        appResources, null, progress, type, null, appTags, unmanagedApplication,\n        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n        amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "4d2f380d787a6145f45c87ba663079fedbf645b8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5101. YARN_APPLICATION_UPDATED event is parsed in ApplicationHistoryManagerOnTimelineStore#convertToApplicationReport with reversed order. Contributed by Sunil G.\n",
      "commitDate": "06/10/16 8:12 AM",
      "commitName": "4d2f380d787a6145f45c87ba663079fedbf645b8",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 113.71,
      "commitsBetweenForRepo": 866,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,189 +1,197 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ApplicationId.fromString(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n             state, diagnosticsInfo, null, createdTime, finishedTime,\n             finalStatus, null, null, progress, type, null, appTags,\n             unmanagedApplication, Priority.newInstance(applicationPriority),\n             appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n         appNodeLabelExpression \u003d entityInfo\n             .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n         amNodeLabelExpression \u003d\n             entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                 .toString();\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n         appResources \u003d ApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n                 0);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n+    long updatedTimeStamp \u003d 0L;\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n-          // TODO: YARN-5101. This type of events are parsed in\n-          // time-stamp descending order which means the previous event\n-          // could override the information from the later same type of event.\n+          // This type of events are parsed in time-stamp descending order\n+          // which means the previous event could override the information\n+          // from the later same type of event. Hence compare timestamp\n+          // before over writing.\n+          if (event.getTimestamp() \u003e updatedTimeStamp) {\n+            updatedTimeStamp \u003d event.getTimestamp();\n+          } else {\n+            continue;\n+          }\n+\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           applicationPriority \u003d Integer\n               .parseInt(eventInfo.get(\n                   ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                   .toString());\n           queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n               .toString();\n         } else if (event.getEventType().equals(\n               ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo.containsKey(\n               ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             if (!isFinalState(state)) {\n               state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                   ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n             }\n           }\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                 eventInfo.get(\n                     ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ApplicationId.fromString(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n         appResources, null, progress, type, null, appTags, unmanagedApplication,\n         Priority.newInstance(applicationPriority), appNodeLabelExpression,\n         amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ApplicationId.fromString(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, finishedTime,\n            finalStatus, null, null, progress, type, null, appTags,\n            unmanagedApplication, Priority.newInstance(applicationPriority),\n            appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources \u003d ApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n                0);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    long updatedTimeStamp \u003d 0L;\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          // This type of events are parsed in time-stamp descending order\n          // which means the previous event could override the information\n          // from the later same type of event. Hence compare timestamp\n          // before over writing.\n          if (event.getTimestamp() \u003e updatedTimeStamp) {\n            updatedTimeStamp \u003d event.getTimestamp();\n          } else {\n            continue;\n          }\n\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          applicationPriority \u003d Integer\n              .parseInt(eventInfo.get(\n                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                  .toString());\n          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n              .toString();\n        } else if (event.getEventType().equals(\n              ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo.containsKey(\n              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            if (!isFinalState(state)) {\n              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n            }\n          }\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                eventInfo.get(\n                    ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ApplicationId.fromString(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n        appResources, null, progress, type, null, appTags, unmanagedApplication,\n        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n        amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "19/05/16 9:13 AM",
      "commitNameOld": "141873ca7d68619e3458712b17aed57fec8fd7c8",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 26.25,
      "commitsBetweenForRepo": 163,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,192 +1,189 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n-            ConverterUtils.toApplicationId(entity.getEntityId()),\n+            ApplicationId.fromString(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n             state, diagnosticsInfo, null, createdTime, finishedTime,\n             finalStatus, null, null, progress, type, null, appTags,\n             unmanagedApplication, Priority.newInstance(applicationPriority),\n             appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n         appNodeLabelExpression \u003d entityInfo\n             .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n         amNodeLabelExpression \u003d\n             entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                 .toString();\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n         appResources \u003d ApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n                 0);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n           // TODO: YARN-5101. This type of events are parsed in\n           // time-stamp descending order which means the previous event\n           // could override the information from the later same type of event.\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           applicationPriority \u003d Integer\n               .parseInt(eventInfo.get(\n                   ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                   .toString());\n           queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n               .toString();\n         } else if (event.getEventType().equals(\n               ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo.containsKey(\n               ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             if (!isFinalState(state)) {\n               state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                   ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n             }\n           }\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n-            latestApplicationAttemptId \u003d\n-                ConverterUtils\n-                    .toApplicationAttemptId(\n-                    eventInfo\n-                        .get(\n-                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n-                        .toString());\n+            latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n+                eventInfo.get(\n+                    ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n+                    .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n-        ConverterUtils.toApplicationId(entity.getEntityId()),\n+        ApplicationId.fromString(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n         appResources, null, progress, type, null, appTags, unmanagedApplication,\n         Priority.newInstance(applicationPriority), appNodeLabelExpression,\n         amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ApplicationId.fromString(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, finishedTime,\n            finalStatus, null, null, progress, type, null, appTags,\n            unmanagedApplication, Priority.newInstance(applicationPriority),\n            appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources \u003d ApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n                0);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          // TODO: YARN-5101. This type of events are parsed in\n          // time-stamp descending order which means the previous event\n          // could override the information from the later same type of event.\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          applicationPriority \u003d Integer\n              .parseInt(eventInfo.get(\n                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                  .toString());\n          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n              .toString();\n        } else if (event.getEventType().equals(\n              ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo.containsKey(\n              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            if (!isFinalState(state)) {\n              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n            }\n          }\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d ApplicationAttemptId.fromString(\n                eventInfo.get(\n                    ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ApplicationId.fromString(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n        appResources, null, progress, type, null, appTags, unmanagedApplication,\n        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n        amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "141873ca7d68619e3458712b17aed57fec8fd7c8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5100. The YarnApplicationState is always running in ATS even application is finished. Contributed by Xuan Gong.\n",
      "commitDate": "19/05/16 9:13 AM",
      "commitName": "141873ca7d68619e3458712b17aed57fec8fd7c8",
      "commitAuthor": "Junping Du",
      "commitDateOld": "11/05/16 9:28 AM",
      "commitNameOld": "39f2bac38b111f90d3402229201cdb4315f5d4f5",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 7.99,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,187 +1,192 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n             state, diagnosticsInfo, null, createdTime, finishedTime,\n             finalStatus, null, null, progress, type, null, appTags,\n             unmanagedApplication, Priority.newInstance(applicationPriority),\n             appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n         appNodeLabelExpression \u003d entityInfo\n             .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n         amNodeLabelExpression \u003d\n             entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                 .toString();\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n         appResources \u003d ApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n                 0);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n+          // TODO: YARN-5101. This type of events are parsed in\n+          // time-stamp descending order which means the previous event\n+          // could override the information from the later same type of event.\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           applicationPriority \u003d Integer\n               .parseInt(eventInfo.get(\n                   ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                   .toString());\n           queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n               .toString();\n         } else if (event.getEventType().equals(\n               ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo.containsKey(\n               ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n-            state \u003d YarnApplicationState.valueOf(eventInfo.get(\n-                ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n+            if (!isFinalState(state)) {\n+              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n+                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n+            }\n           }\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n         appResources, null, progress, type, null, appTags, unmanagedApplication,\n         Priority.newInstance(applicationPriority), appNodeLabelExpression,\n         amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, finishedTime,\n            finalStatus, null, null, progress, type, null, appTags,\n            unmanagedApplication, Priority.newInstance(applicationPriority),\n            appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources \u003d ApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n                0);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          // TODO: YARN-5101. This type of events are parsed in\n          // time-stamp descending order which means the previous event\n          // could override the information from the later same type of event.\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          applicationPriority \u003d Integer\n              .parseInt(eventInfo.get(\n                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                  .toString());\n          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n              .toString();\n        } else if (event.getEventType().equals(\n              ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo.containsKey(\n              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            if (!isFinalState(state)) {\n              state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                  ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n            }\n          }\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n        appResources, null, progress, type, null, appTags, unmanagedApplication,\n        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n        amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "39f2bac38b111f90d3402229201cdb4315f5d4f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5029. RM needs to send update event with YarnApplicationState as Running to ATS/AHS. Contributed by Xuan Gong.\n",
      "commitDate": "11/05/16 9:28 AM",
      "commitName": "39f2bac38b111f90d3402229201cdb4315f5d4f5",
      "commitAuthor": "Junping Du",
      "commitDateOld": "06/05/16 3:59 PM",
      "commitNameOld": "b2ed6ae73197990a950ce71ece80c0f23221c384",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 4.73,
      "commitsBetweenForRepo": 22,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,176 +1,187 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n             state, diagnosticsInfo, null, createdTime, finishedTime,\n             finalStatus, null, null, progress, type, null, appTags,\n             unmanagedApplication, Priority.newInstance(applicationPriority),\n             appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n         appNodeLabelExpression \u003d entityInfo\n             .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n         amNodeLabelExpression \u003d\n             entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                 .toString();\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n         appResources \u003d ApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n                 0);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           applicationPriority \u003d Integer\n               .parseInt(eventInfo.get(\n                   ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                   .toString());\n           queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n               .toString();\n         } else if (event.getEventType().equals(\n+              ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n+          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n+          if (eventInfo \u003d\u003d null) {\n+            continue;\n+          }\n+          if (eventInfo.containsKey(\n+              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n+            state \u003d YarnApplicationState.valueOf(eventInfo.get(\n+                ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n+          }\n+        } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n         appResources, null, progress, type, null, appTags, unmanagedApplication,\n         Priority.newInstance(applicationPriority), appNodeLabelExpression,\n         amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, finishedTime,\n            finalStatus, null, null, progress, type, null, appTags,\n            unmanagedApplication, Priority.newInstance(applicationPriority),\n            appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources \u003d ApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n                0);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          applicationPriority \u003d Integer\n              .parseInt(eventInfo.get(\n                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                  .toString());\n          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n              .toString();\n        } else if (event.getEventType().equals(\n              ApplicationMetricsConstants.STATE_UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo.containsKey(\n              ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d YarnApplicationState.valueOf(eventInfo.get(\n                ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n        appResources, null, progress, type, null, appTags, unmanagedApplication,\n        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n        amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "3cc73773eb26f7469c99b25a76814d6fad0be28e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4285. Display resource usage as percentage of queue and cluster in the RM UI (Varun Vasudev via wangda)\n",
      "commitDate": "26/10/15 1:07 PM",
      "commitName": "3cc73773eb26f7469c99b25a76814d6fad0be28e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "23/09/15 11:43 PM",
      "commitNameOld": "a9aafad12b1d2f67e55e09a6fa261d61789c9d7e",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 32.56,
      "commitsBetweenForRepo": 247,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,175 +1,176 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n             state, diagnosticsInfo, null, createdTime, finishedTime,\n             finalStatus, null, null, progress, type, null, appTags,\n             unmanagedApplication, Priority.newInstance(applicationPriority),\n             appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n         appNodeLabelExpression \u003d entityInfo\n             .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n         amNodeLabelExpression \u003d\n             entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                 .toString();\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n-        appResources\u003dApplicationResourceUsageReport\n-            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n+        appResources \u003d ApplicationResourceUsageReport\n+            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n+                0);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           applicationPriority \u003d Integer\n               .parseInt(eventInfo.get(\n                   ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                   .toString());\n           queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n               .toString();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n         appResources, null, progress, type, null, appTags, unmanagedApplication,\n         Priority.newInstance(applicationPriority), appNodeLabelExpression,\n         amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, finishedTime,\n            finalStatus, null, null, progress, type, null, appTags,\n            unmanagedApplication, Priority.newInstance(applicationPriority),\n            appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources \u003d ApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds, 0,\n                0);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          applicationPriority \u003d Integer\n              .parseInt(eventInfo.get(\n                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                  .toString());\n          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n              .toString();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n        appResources, null, progress, type, null, appTags, unmanagedApplication,\n        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n        amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "a9aafad12b1d2f67e55e09a6fa261d61789c9d7e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4044. Running applications information changes such as movequeue is not published to TimeLine server. (Sunil G via rohithsharmaks)\n",
      "commitDate": "23/09/15 11:43 PM",
      "commitName": "a9aafad12b1d2f67e55e09a6fa261d61789c9d7e",
      "commitAuthor": "Rohith Sharma K S",
      "commitDateOld": "15/09/15 11:40 AM",
      "commitNameOld": "ae5308fe1d08479da0f3929cc6a57816411e9121",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 8.5,
      "commitsBetweenForRepo": 68,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,163 +1,175 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     String appNodeLabelExpression \u003d null;\n     String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n             state, diagnosticsInfo, null, createdTime, finishedTime,\n             finalStatus, null, null, progress, type, null, appTags,\n             unmanagedApplication, Priority.newInstance(applicationPriority),\n             appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n         appNodeLabelExpression \u003d entityInfo\n             .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n         amNodeLabelExpression \u003d\n             entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                 .toString();\n       }\n \n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n         appResources\u003dApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n+            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n+          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n+          if (eventInfo \u003d\u003d null) {\n+            continue;\n+          }\n+          applicationPriority \u003d Integer\n+              .parseInt(eventInfo.get(\n+                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n+                  .toString());\n+          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n+              .toString();\n+        } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n         appResources, null, progress, type, null, appTags, unmanagedApplication,\n         Priority.newInstance(applicationPriority), appNodeLabelExpression,\n         amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, finishedTime,\n            finalStatus, null, null, progress, type, null, appTags,\n            unmanagedApplication, Priority.newInstance(applicationPriority),\n            appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources\u003dApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.UPDATED_EVENT_TYPE)) {\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          applicationPriority \u003d Integer\n              .parseInt(eventInfo.get(\n                  ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)\n                  .toString());\n          queue \u003d eventInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n              .toString();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n        appResources, null, progress, type, null, appTags, unmanagedApplication,\n        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n        amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "ae5308fe1d08479da0f3929cc6a57816411e9121": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3717. Expose app/am/queue\u0027s node-label-expression to RM web UI / CLI / REST-API. (Naganarasimha G R via wangda)\n",
      "commitDate": "15/09/15 11:40 AM",
      "commitName": "ae5308fe1d08479da0f3929cc6a57816411e9121",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "12/08/15 2:15 AM",
      "commitNameOld": "1c12adb71f32f24ec525313ff8dfcd2b738fc8e2",
      "commitAuthorOld": "rohithsharmaks",
      "daysBetweenCommits": 34.39,
      "commitsBetweenForRepo": 201,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,163 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n+    String appNodeLabelExpression \u003d null;\n+    String amNodeLabelExpression \u003d null;\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null,\n             state, diagnosticsInfo, null, createdTime, finishedTime,\n             finalStatus, null, null, progress, type, null, appTags,\n-            unmanagedApplication, Priority.newInstance(applicationPriority)),\n-            appViewACLs);\n+            unmanagedApplication, Priority.newInstance(applicationPriority),\n+            appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n+      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n+        type \u003d\n+            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n+                .toString();\n+      }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n         applicationPriority \u003d Integer.parseInt(entityInfo.get(\n             ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n       }\n+      if (entityInfo\n+          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n+        appNodeLabelExpression \u003d entityInfo\n+            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n+      }\n+      if (entityInfo\n+          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n+        amNodeLabelExpression \u003d\n+            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n+                .toString();\n+      }\n+\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n         appResources\u003dApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n-        appResources, null, progress, type, null, appTags,\n-        unmanagedApplication, Priority.newInstance(applicationPriority)),\n-        appViewACLs);\n+        appResources, null, progress, type, null, appTags, unmanagedApplication,\n+        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n+        amNodeLabelExpression), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    String appNodeLabelExpression \u003d null;\n    String amNodeLabelExpression \u003d null;\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, finishedTime,\n            finalStatus, null, null, progress, type, null, appTags,\n            unmanagedApplication, Priority.newInstance(applicationPriority),\n            appNodeLabelExpression, amNodeLabelExpression), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION)) {\n        appNodeLabelExpression \u003d entityInfo\n            .get(ApplicationMetricsConstants.APP_NODE_LABEL_EXPRESSION).toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)) {\n        amNodeLabelExpression \u003d\n            entityInfo.get(ApplicationMetricsConstants.AM_NODE_LABEL_EXPRESSION)\n                .toString();\n      }\n\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources\u003dApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n        appResources, null, progress, type, null, appTags, unmanagedApplication,\n        Priority.newInstance(applicationPriority), appNodeLabelExpression,\n        amNodeLabelExpression), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "1c12adb71f32f24ec525313ff8dfcd2b738fc8e2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4023. Publish Application Priority to TimelineServer. (Sunil G via rohithsharmaks)\n",
      "commitDate": "12/08/15 2:15 AM",
      "commitName": "1c12adb71f32f24ec525313ff8dfcd2b738fc8e2",
      "commitAuthor": "rohithsharmaks",
      "commitDateOld": "03/08/15 3:46 PM",
      "commitNameOld": "0306d902f53582320aa5895ca9f5c31f64aaaff6",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 8.44,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,144 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n+    int applicationPriority \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n-            latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n-            diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n-            null, progress, type, null, appTags,\n-            unmanagedApplication), appViewACLs);\n+            latestApplicationAttemptId, user, queue, name, null, -1, null,\n+            state, diagnosticsInfo, null, createdTime, finishedTime,\n+            finalStatus, null, null, progress, type, null, appTags,\n+            unmanagedApplication, Priority.newInstance(applicationPriority)),\n+            appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo\n           .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n         unmanagedApplication \u003d\n             Boolean.parseBoolean(entityInfo.get(\n                 ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                 .toString());\n       }\n+      if (entityInfo\n+          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n+        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n+            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n+      }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n         appResources\u003dApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n-        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n-        null, progress, type, null, appTags, unmanagedApplication), appViewACLs);\n+        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n+        appResources, null, progress, type, null, appTags,\n+        unmanagedApplication, Priority.newInstance(applicationPriority)),\n+        appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    int applicationPriority \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null,\n            state, diagnosticsInfo, null, createdTime, finishedTime,\n            finalStatus, null, null, progress, type, null, appTags,\n            unmanagedApplication, Priority.newInstance(applicationPriority)),\n            appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO)) {\n        applicationPriority \u003d Integer.parseInt(entityInfo.get(\n            ApplicationMetricsConstants.APPLICATION_PRIORITY_INFO).toString());\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources\u003dApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus,\n        appResources, null, progress, type, null, appTags,\n        unmanagedApplication, Priority.newInstance(applicationPriority)),\n        appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "0306d902f53582320aa5895ca9f5c31f64aaaff6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3543. ApplicationReport should be able to tell whether the\nApplication is AM managed or not. Contributed by Rohith Sharma K S\n",
      "commitDate": "03/08/15 3:46 PM",
      "commitName": "0306d902f53582320aa5895ca9f5c31f64aaaff6",
      "commitAuthor": "Xuan",
      "commitDateOld": "08/06/15 11:14 PM",
      "commitNameOld": "8d0ef3163287d811381e94cc0101dbc9847ee2db",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 55.69,
      "commitsBetweenForRepo": 338,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,135 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n+    boolean unmanagedApplication \u003d false;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n             diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n-            null, progress, type, null, appTags), appViewACLs);\n+            null, progress, type, null, appTags,\n+            unmanagedApplication), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n+      if (entityInfo\n+          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n+        unmanagedApplication \u003d\n+            Boolean.parseBoolean(entityInfo.get(\n+                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n+                .toString());\n+      }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n         appResources\u003dApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n         appTags \u003d new HashSet\u003cString\u003e();\n         Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n         if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n           for(Object o : (Collection\u003c?\u003e)obj) {\n             if (o !\u003d null) {\n               appTags.add(o.toString());\n             }\n           }\n         }\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n-        null, progress, type, null, appTags), appViewACLs);\n+        null, progress, type, null, appTags, unmanagedApplication), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    boolean unmanagedApplication \u003d false;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n            diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n            null, progress, type, null, appTags,\n            unmanagedApplication), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo\n          .containsKey(ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)) {\n        unmanagedApplication \u003d\n            Boolean.parseBoolean(entityInfo.get(\n                ApplicationMetricsConstants.UNMANAGED_APPLICATION_ENTITY_INFO)\n                .toString());\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources\u003dApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n        null, progress, type, null, appTags, unmanagedApplication), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "3e000a919fede85230fcfb06309a1f1d5e0c479c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1462. AHS API and other AHS changes to handle tags for completed MR jobs. Contributed by Xuan Gong\n",
      "commitDate": "05/06/15 12:48 PM",
      "commitName": "3e000a919fede85230fcfb06309a1f1d5e0c479c",
      "commitAuthor": "Xuan",
      "commitDateOld": "03/06/15 2:15 PM",
      "commitNameOld": "bc85959eddcb11037e8b9f0e06780b7c3e1cbab6",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 1.94,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,126 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n+    Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n             diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n-            null, progress, type, null), appViewACLs);\n+            null, progress, type, null, appTags), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n         appResources\u003dApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n       }\n+      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n+        appTags \u003d new HashSet\u003cString\u003e();\n+        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n+        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n+          for(Object o : (Collection\u003c?\u003e)obj) {\n+            if (o !\u003d null) {\n+              appTags.add(o.toString());\n+            }\n+          }\n+        }\n+      }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n-        null, progress, type, null), appViewACLs);\n+        null, progress, type, null, appTags), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n            diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n            null, progress, type, null, appTags), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources\u003dApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n        null, progress, type, null, appTags), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "bc85959eddcb11037e8b9f0e06780b7c3e1cbab6": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"YARN-1462. Made RM write application tags to timeline server and exposed them to users via generic history web UI and REST API. Contributed by Xuan Gong.\"\n\nThis reverts commit 4a9ec1a8243e2394ff7221b1c20dfaa80e9f5111.\n",
      "commitDate": "03/06/15 2:15 PM",
      "commitName": "bc85959eddcb11037e8b9f0e06780b7c3e1cbab6",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "30/05/15 9:05 PM",
      "commitNameOld": "4a9ec1a8243e2394ff7221b1c20dfaa80e9f5111",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 3.72,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,126 +1,114 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n-    Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n             diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n-            null, progress, type, null, appTags), appViewACLs);\n+            null, progress, type, null), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n         appResources\u003dApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n       }\n-      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n-        appTags \u003d new HashSet\u003cString\u003e();\n-        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n-        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n-          for(Object o : (Collection\u003c?\u003e)obj) {\n-            if (o !\u003d null) {\n-              appTags.add(o.toString());\n-            }\n-          }\n-        }\n-      }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n-        null, progress, type, null, appTags), appViewACLs);\n+        null, progress, type, null), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n            diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n            null, progress, type, null), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources\u003dApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n        null, progress, type, null), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "4a9ec1a8243e2394ff7221b1c20dfaa80e9f5111": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1462. Made RM write application tags to timeline server and exposed them to users via generic history web UI and REST API. Contributed by Xuan Gong.\n",
      "commitDate": "30/05/15 9:05 PM",
      "commitName": "4a9ec1a8243e2394ff7221b1c20dfaa80e9f5111",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "29/05/15 6:17 PM",
      "commitNameOld": "eb6bf91eeacf97afb4cefe590f75ba94f3187d2b",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 1.12,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,114 +1,126 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     float progress \u003d 0.0f;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n+    Set\u003cString\u003e appTags \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n             diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n-            null, progress, type, null), appViewACLs);\n+            null, progress, type, null, appTags), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n         appResources\u003dApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n       }\n+      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n+        appTags \u003d new HashSet\u003cString\u003e();\n+        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n+        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n+          for(Object o : (Collection\u003c?\u003e)obj) {\n+            if (o !\u003d null) {\n+              appTags.add(o.toString());\n+            }\n+          }\n+        }\n+      }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n-        null, progress, type, null), appViewACLs);\n+        null, progress, type, null, appTags), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Set\u003cString\u003e appTags \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n            diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n            null, progress, type, null, appTags), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources\u003dApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_TAGS_INFO)) {\n        appTags \u003d new HashSet\u003cString\u003e();\n        Object obj \u003d entityInfo.get(ApplicationMetricsConstants.APP_TAGS_INFO);\n        if (obj !\u003d null \u0026\u0026 obj instanceof Collection\u003c?\u003e) {\n          for(Object o : (Collection\u003c?\u003e)obj) {\n            if (o !\u003d null) {\n              appTags.add(o.toString());\n            }\n          }\n        }\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n        null, progress, type, null, appTags), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "19a4feaf6fcf42ebbfe98b8a7153ade96d37fb14": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3110. Few issues in ApplicationHistory web ui. Contributed by Naganarasimha G R\n",
      "commitDate": "07/04/15 8:22 AM",
      "commitName": "19a4feaf6fcf42ebbfe98b8a7153ade96d37fb14",
      "commitAuthor": "Xuan",
      "commitDateOld": "23/03/15 8:33 PM",
      "commitNameOld": "9fae455e26e0230107e1c6db58a49a5b6b296cf4",
      "commitAuthorOld": "Xuan",
      "daysBetweenCommits": 14.49,
      "commitsBetweenForRepo": 121,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,112 +1,114 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n+    float progress \u003d 0.0f;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n-    YarnApplicationState state \u003d null;\n+    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n     ApplicationResourceUsageReport appResources \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n             diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n-            null, 1.0F, type, null), appViewACLs);\n+            null, progress, type, null), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n         long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n         long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                 ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n         appResources\u003dApplicationResourceUsageReport\n             .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n+          progress\u003d1.0F;\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n-        null, 1.0F, type, null), appViewACLs);\n+        null, progress, type, null), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    float progress \u003d 0.0f;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d YarnApplicationState.ACCEPTED;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n            diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n            null, progress, type, null), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources\u003dApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          progress\u003d1.0F;\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n        null, progress, type, null), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "e5b56e2af6b48cbc8501f624ae4b4f9d13eccacf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2543. Made resource usage be published to the timeline server too. Contributed by Naganarasimha G R.\n",
      "commitDate": "03/02/15 5:34 PM",
      "commitName": "e5b56e2af6b48cbc8501f624ae4b4f9d13eccacf",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "13/11/14 1:47 PM",
      "commitNameOld": "3648cb57c9f018a3a339c26f5a0ca2779485521a",
      "commitAuthorOld": "Zhijie Shen",
      "daysBetweenCommits": 82.16,
      "commitsBetweenForRepo": 505,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,112 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d null;\n+    ApplicationResourceUsageReport appResources \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n         if (appViewACLsStr.length() \u003e 0) {\n           appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n         }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n             diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n             null, 1.0F, type, null), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n+      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n+        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n+                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n+        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n+                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n+        appResources\u003dApplicationResourceUsageReport\n+            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n+      }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n-        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n+        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n         null, 1.0F, type, null), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d null;\n    ApplicationResourceUsageReport appResources \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n            diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n            null, 1.0F, type, null), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_CPU_METRICS)) {\n        long vcoreSeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_CPU_METRICS).toString());\n        long memorySeconds\u003dLong.parseLong(entityInfo.get(\n                ApplicationMetricsConstants.APP_MEM_METRICS).toString());\n        appResources\u003dApplicationResourceUsageReport\n            .newInstance(0, 0, null, null, null, memorySeconds, vcoreSeconds);\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, appResources,\n        null, 1.0F, type, null), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "bbff96be48119774688981d04baf444639135977": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2602. Fixed possible NPE in ApplicationHistoryManagerOnTimelineStore. Contributed by Zhijie Shen\n",
      "commitDate": "30/09/14 4:44 PM",
      "commitName": "bbff96be48119774688981d04baf444639135977",
      "commitAuthor": "Jian He",
      "commitDateOld": "16/09/14 6:20 PM",
      "commitNameOld": "90a0c03f0a696d32e871a5da4560828edea8cfa9",
      "commitAuthorOld": "junping_du",
      "daysBetweenCommits": 13.93,
      "commitsBetweenForRepo": 162,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,103 @@\n   private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d null;\n     Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n         new HashMap\u003cApplicationAccessType, String\u003e();\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n         String appViewACLsStr \u003d entityInfo.get(\n             ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n-        appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n+        if (appViewACLsStr.length() \u003e 0) {\n+          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n+        }\n       }\n       if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n         return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n             diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n             null, 1.0F, type, null), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n     return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n         null, 1.0F, type, null), appViewACLs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        if (appViewACLsStr.length() \u003e 0) {\n          appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n        }\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n            diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n            null, 1.0F, type, null), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n        null, 1.0F, type, null), appViewACLs);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
      "extendedDetails": {}
    },
    "90a0c03f0a696d32e871a5da4560828edea8cfa9": {
      "type": "Ymultichange(Yreturntypechange,Ybodychange)",
      "commitMessage": "YARN-1250. Generic history service should support application-acls. (Contributed by Zhijie Shen)\n",
      "commitDate": "16/09/14 6:20 PM",
      "commitName": "90a0c03f0a696d32e871a5da4560828edea8cfa9",
      "commitAuthor": "junping_du",
      "subchanges": [
        {
          "type": "Yreturntypechange",
          "commitMessage": "YARN-1250. Generic history service should support application-acls. (Contributed by Zhijie Shen)\n",
          "commitDate": "16/09/14 6:20 PM",
          "commitName": "90a0c03f0a696d32e871a5da4560828edea8cfa9",
          "commitAuthor": "junping_du",
          "commitDateOld": "11/09/14 7:04 PM",
          "commitNameOld": "6b8b1608e64e300e4e1d23c60476febaca29ca38",
          "commitAuthorOld": "junping_du",
          "daysBetweenCommits": 4.97,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,101 +1,101 @@\n-  private static ApplicationReport convertToApplicationReport(\n+  private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d null;\n-    if (field \u003d\u003d ApplicationReportField.NONE) {\n-      return ApplicationReport.newInstance(\n-          ConverterUtils.toApplicationId(entity.getEntityId()),\n-          latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n-          diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n-          null, 1.0F, type, null);\n-    }\n+    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n+        new HashMap\u003cApplicationAccessType, String\u003e();\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n-      if (field \u003d\u003d ApplicationReportField.USER) {\n-        return ApplicationReport.newInstance(\n+      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n+        String appViewACLsStr \u003d entityInfo.get(\n+            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n+        appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n+      }\n+      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n+        return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n             diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n-            null, 1.0F, type, null);\n+            null, 1.0F, type, null), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n-    return ApplicationReport.newInstance(\n+    return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n-        null, 1.0F, type, null);\n+        null, 1.0F, type, null), appViewACLs);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n            diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n            null, 1.0F, type, null), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n        null, 1.0F, type, null), appViewACLs);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
          "extendedDetails": {
            "oldValue": "ApplicationReport",
            "newValue": "ApplicationReportExt"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1250. Generic history service should support application-acls. (Contributed by Zhijie Shen)\n",
          "commitDate": "16/09/14 6:20 PM",
          "commitName": "90a0c03f0a696d32e871a5da4560828edea8cfa9",
          "commitAuthor": "junping_du",
          "commitDateOld": "11/09/14 7:04 PM",
          "commitNameOld": "6b8b1608e64e300e4e1d23c60476febaca29ca38",
          "commitAuthorOld": "junping_du",
          "daysBetweenCommits": 4.97,
          "commitsBetweenForRepo": 36,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,101 +1,101 @@\n-  private static ApplicationReport convertToApplicationReport(\n+  private static ApplicationReportExt convertToApplicationReport(\n       TimelineEntity entity, ApplicationReportField field) {\n     String user \u003d null;\n     String queue \u003d null;\n     String name \u003d null;\n     String type \u003d null;\n     long createdTime \u003d 0;\n     long finishedTime \u003d 0;\n     ApplicationAttemptId latestApplicationAttemptId \u003d null;\n     String diagnosticsInfo \u003d null;\n     FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n     YarnApplicationState state \u003d null;\n-    if (field \u003d\u003d ApplicationReportField.NONE) {\n-      return ApplicationReport.newInstance(\n-          ConverterUtils.toApplicationId(entity.getEntityId()),\n-          latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n-          diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n-          null, 1.0F, type, null);\n-    }\n+    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n+        new HashMap\u003cApplicationAccessType, String\u003e();\n     Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n     if (entityInfo !\u003d null) {\n       if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n         user \u003d\n             entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                 .toString();\n       }\n-      if (field \u003d\u003d ApplicationReportField.USER) {\n-        return ApplicationReport.newInstance(\n+      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n+        String appViewACLsStr \u003d entityInfo.get(\n+            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n+        appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n+      }\n+      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n+        return new ApplicationReportExt(ApplicationReport.newInstance(\n             ConverterUtils.toApplicationId(entity.getEntityId()),\n             latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n             diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n-            null, 1.0F, type, null);\n+            null, 1.0F, type, null), appViewACLs);\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n         queue \u003d\n             entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n         name \u003d\n             entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                 .toString();\n       }\n       if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n         type \u003d\n             entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                 .toString();\n       }\n     }\n     List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n     if (events !\u003d null) {\n       for (TimelineEvent event : events) {\n         if (event.getEventType().equals(\n             ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n           createdTime \u003d event.getTimestamp();\n         } else if (event.getEventType().equals(\n             ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n           finishedTime \u003d event.getTimestamp();\n           Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n           if (eventInfo \u003d\u003d null) {\n             continue;\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n             latestApplicationAttemptId \u003d\n                 ConverterUtils\n                     .toApplicationAttemptId(\n                     eventInfo\n                         .get(\n                             ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                         .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n             diagnosticsInfo \u003d\n                 eventInfo.get(\n                     ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                     .toString();\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n             finalStatus \u003d\n                 FinalApplicationStatus.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                     .toString());\n           }\n           if (eventInfo\n               .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n             state \u003d\n                 YarnApplicationState.valueOf(eventInfo.get(\n                     ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n           }\n         }\n       }\n     }\n-    return ApplicationReport.newInstance(\n+    return new ApplicationReportExt(ApplicationReport.newInstance(\n         ConverterUtils.toApplicationId(entity.getEntityId()),\n         latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n         diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n-        null, 1.0F, type, null);\n+        null, 1.0F, type, null), appViewACLs);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static ApplicationReportExt convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d null;\n    Map\u003cApplicationAccessType, String\u003e appViewACLs \u003d\n        new HashMap\u003cApplicationAccessType, String\u003e();\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO)) {\n        String appViewACLsStr \u003d entityInfo.get(\n            ApplicationMetricsConstants.APP_VIEW_ACLS_ENTITY_INFO).toString();\n        appViewACLs.put(ApplicationAccessType.VIEW_APP, appViewACLsStr);\n      }\n      if (field \u003d\u003d ApplicationReportField.USER_AND_ACLS) {\n        return new ApplicationReportExt(ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n            diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n            null, 1.0F, type, null), appViewACLs);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return new ApplicationReportExt(ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n        null, 1.0F, type, null), appViewACLs);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java",
          "extendedDetails": {}
        }
      ]
    },
    "6b8b1608e64e300e4e1d23c60476febaca29ca38": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2033. Merging generic-history into the Timeline Store (Contributed by Zhijie Shen)\n",
      "commitDate": "11/09/14 7:04 PM",
      "commitName": "6b8b1608e64e300e4e1d23c60476febaca29ca38",
      "commitAuthor": "junping_du",
      "diff": "@@ -0,0 +1,101 @@\n+  private static ApplicationReport convertToApplicationReport(\n+      TimelineEntity entity, ApplicationReportField field) {\n+    String user \u003d null;\n+    String queue \u003d null;\n+    String name \u003d null;\n+    String type \u003d null;\n+    long createdTime \u003d 0;\n+    long finishedTime \u003d 0;\n+    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n+    String diagnosticsInfo \u003d null;\n+    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n+    YarnApplicationState state \u003d null;\n+    if (field \u003d\u003d ApplicationReportField.NONE) {\n+      return ApplicationReport.newInstance(\n+          ConverterUtils.toApplicationId(entity.getEntityId()),\n+          latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n+          diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n+          null, 1.0F, type, null);\n+    }\n+    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n+    if (entityInfo !\u003d null) {\n+      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n+        user \u003d\n+            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n+                .toString();\n+      }\n+      if (field \u003d\u003d ApplicationReportField.USER) {\n+        return ApplicationReport.newInstance(\n+            ConverterUtils.toApplicationId(entity.getEntityId()),\n+            latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n+            diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n+            null, 1.0F, type, null);\n+      }\n+      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n+        queue \u003d\n+            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n+                .toString();\n+      }\n+      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n+        name \u003d\n+            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n+                .toString();\n+      }\n+      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n+        type \u003d\n+            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n+                .toString();\n+      }\n+    }\n+    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n+    if (events !\u003d null) {\n+      for (TimelineEvent event : events) {\n+        if (event.getEventType().equals(\n+            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n+          createdTime \u003d event.getTimestamp();\n+        } else if (event.getEventType().equals(\n+            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n+          finishedTime \u003d event.getTimestamp();\n+          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n+          if (eventInfo \u003d\u003d null) {\n+            continue;\n+          }\n+          if (eventInfo\n+              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n+            latestApplicationAttemptId \u003d\n+                ConverterUtils\n+                    .toApplicationAttemptId(\n+                    eventInfo\n+                        .get(\n+                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n+                        .toString());\n+          }\n+          if (eventInfo\n+              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n+            diagnosticsInfo \u003d\n+                eventInfo.get(\n+                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n+                    .toString();\n+          }\n+          if (eventInfo\n+              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n+            finalStatus \u003d\n+                FinalApplicationStatus.valueOf(eventInfo.get(\n+                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n+                    .toString());\n+          }\n+          if (eventInfo\n+              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n+            state \u003d\n+                YarnApplicationState.valueOf(eventInfo.get(\n+                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n+          }\n+        }\n+      }\n+    }\n+    return ApplicationReport.newInstance(\n+        ConverterUtils.toApplicationId(entity.getEntityId()),\n+        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n+        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n+        null, 1.0F, type, null);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static ApplicationReport convertToApplicationReport(\n      TimelineEntity entity, ApplicationReportField field) {\n    String user \u003d null;\n    String queue \u003d null;\n    String name \u003d null;\n    String type \u003d null;\n    long createdTime \u003d 0;\n    long finishedTime \u003d 0;\n    ApplicationAttemptId latestApplicationAttemptId \u003d null;\n    String diagnosticsInfo \u003d null;\n    FinalApplicationStatus finalStatus \u003d FinalApplicationStatus.UNDEFINED;\n    YarnApplicationState state \u003d null;\n    if (field \u003d\u003d ApplicationReportField.NONE) {\n      return ApplicationReport.newInstance(\n          ConverterUtils.toApplicationId(entity.getEntityId()),\n          latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n          diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n          null, 1.0F, type, null);\n    }\n    Map\u003cString, Object\u003e entityInfo \u003d entity.getOtherInfo();\n    if (entityInfo !\u003d null) {\n      if (entityInfo.containsKey(ApplicationMetricsConstants.USER_ENTITY_INFO)) {\n        user \u003d\n            entityInfo.get(ApplicationMetricsConstants.USER_ENTITY_INFO)\n                .toString();\n      }\n      if (field \u003d\u003d ApplicationReportField.USER) {\n        return ApplicationReport.newInstance(\n            ConverterUtils.toApplicationId(entity.getEntityId()),\n            latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n            diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n            null, 1.0F, type, null);\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)) {\n        queue \u003d\n            entityInfo.get(ApplicationMetricsConstants.QUEUE_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.NAME_ENTITY_INFO)) {\n        name \u003d\n            entityInfo.get(ApplicationMetricsConstants.NAME_ENTITY_INFO)\n                .toString();\n      }\n      if (entityInfo.containsKey(ApplicationMetricsConstants.TYPE_ENTITY_INFO)) {\n        type \u003d\n            entityInfo.get(ApplicationMetricsConstants.TYPE_ENTITY_INFO)\n                .toString();\n      }\n    }\n    List\u003cTimelineEvent\u003e events \u003d entity.getEvents();\n    if (events !\u003d null) {\n      for (TimelineEvent event : events) {\n        if (event.getEventType().equals(\n            ApplicationMetricsConstants.CREATED_EVENT_TYPE)) {\n          createdTime \u003d event.getTimestamp();\n        } else if (event.getEventType().equals(\n            ApplicationMetricsConstants.FINISHED_EVENT_TYPE)) {\n          finishedTime \u003d event.getTimestamp();\n          Map\u003cString, Object\u003e eventInfo \u003d event.getEventInfo();\n          if (eventInfo \u003d\u003d null) {\n            continue;\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)) {\n            latestApplicationAttemptId \u003d\n                ConverterUtils\n                    .toApplicationAttemptId(\n                    eventInfo\n                        .get(\n                            ApplicationMetricsConstants.LATEST_APP_ATTEMPT_EVENT_INFO)\n                        .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)) {\n            diagnosticsInfo \u003d\n                eventInfo.get(\n                    ApplicationMetricsConstants.DIAGNOSTICS_INFO_EVENT_INFO)\n                    .toString();\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)) {\n            finalStatus \u003d\n                FinalApplicationStatus.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.FINAL_STATUS_EVENT_INFO)\n                    .toString());\n          }\n          if (eventInfo\n              .containsKey(ApplicationMetricsConstants.STATE_EVENT_INFO)) {\n            state \u003d\n                YarnApplicationState.valueOf(eventInfo.get(\n                    ApplicationMetricsConstants.STATE_EVENT_INFO).toString());\n          }\n        }\n      }\n    }\n    return ApplicationReport.newInstance(\n        ConverterUtils.toApplicationId(entity.getEntityId()),\n        latestApplicationAttemptId, user, queue, name, null, -1, null, state,\n        diagnosticsInfo, null, createdTime, finishedTime, finalStatus, null,\n        null, 1.0F, type, null);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-applicationhistoryservice/src/main/java/org/apache/hadoop/yarn/server/applicationhistoryservice/ApplicationHistoryManagerOnTimelineStore.java"
    }
  }
}