{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ZKFailoverController.java",
  "functionName": "recheckElectability",
  "functionId": "recheckElectability",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java",
  "functionStartLine": 787,
  "functionEndLine": 839,
  "numCommitsSeen": 35,
  "timeTaken": 1831,
  "changeHistory": [
    "83a14559e594b0e918d04cafd8c7c6ac57715b22",
    "6eba48cbdeae7f7d46b2e0ad84bf3845c333000d",
    "9d5799553fea81920edfab611e5d485a97841848"
  ],
  "changeHistoryShort": {
    "83a14559e594b0e918d04cafd8c7c6ac57715b22": "Ybodychange",
    "6eba48cbdeae7f7d46b2e0ad84bf3845c333000d": "Ybodychange",
    "9d5799553fea81920edfab611e5d485a97841848": "Yintroduced"
  },
  "changeHistoryDetails": {
    "83a14559e594b0e918d04cafd8c7c6ac57715b22": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-15023. [SBN read] ZKFC should check the state before joining the election. Contributed by Fei Hui.\n",
      "commitDate": "05/12/19 5:22 AM",
      "commitName": "83a14559e594b0e918d04cafd8c7c6ac57715b22",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "18/10/19 1:26 PM",
      "commitNameOld": "6d92aa7c30439d78deb68cc3186a67557544681f",
      "commitAuthorOld": "Mate Szalay-Beko",
      "daysBetweenCommits": 47.71,
      "commitsBetweenForRepo": 173,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,53 @@\n   private void recheckElectability() {\n     // Maintain lock ordering of elector -\u003e ZKFC\n     synchronized (elector) {\n       synchronized (this) {\n         boolean healthy \u003d lastHealthState \u003d\u003d State.SERVICE_HEALTHY;\n     \n         long remainingDelay \u003d delayJoiningUntilNanotime - System.nanoTime(); \n         if (remainingDelay \u003e 0) {\n           if (healthy) {\n             LOG.info(\"Would have joined master election, but this node is \" +\n                 \"prohibited from doing so for \" +\n                 TimeUnit.NANOSECONDS.toMillis(remainingDelay) + \" more ms\");\n           }\n           scheduleRecheck(remainingDelay);\n           return;\n         }\n     \n         switch (lastHealthState) {\n         case SERVICE_HEALTHY:\n-          elector.joinElection(targetToData(localTarget));\n+          if(serviceState !\u003d HAServiceState.OBSERVER) {\n+            elector.joinElection(targetToData(localTarget));\n+          }\n           if (quitElectionOnBadState) {\n             quitElectionOnBadState \u003d false;\n           }\n           break;\n           \n         case INITIALIZING:\n           LOG.info(\"Ensuring that \" + localTarget + \" does not \" +\n               \"participate in active master election\");\n           elector.quitElection(false);\n           serviceState \u003d HAServiceState.INITIALIZING;\n           break;\n     \n         case SERVICE_UNHEALTHY:\n         case SERVICE_NOT_RESPONDING:\n           LOG.info(\"Quitting master election for \" + localTarget +\n               \" and marking that fencing is necessary\");\n           elector.quitElection(true);\n           serviceState \u003d HAServiceState.INITIALIZING;\n           break;\n           \n         case HEALTH_MONITOR_FAILED:\n           fatalError(\"Health monitor failed!\");\n           break;\n           \n         default:\n           throw new IllegalArgumentException(\"Unhandled state:\"\n                                                + lastHealthState);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void recheckElectability() {\n    // Maintain lock ordering of elector -\u003e ZKFC\n    synchronized (elector) {\n      synchronized (this) {\n        boolean healthy \u003d lastHealthState \u003d\u003d State.SERVICE_HEALTHY;\n    \n        long remainingDelay \u003d delayJoiningUntilNanotime - System.nanoTime(); \n        if (remainingDelay \u003e 0) {\n          if (healthy) {\n            LOG.info(\"Would have joined master election, but this node is \" +\n                \"prohibited from doing so for \" +\n                TimeUnit.NANOSECONDS.toMillis(remainingDelay) + \" more ms\");\n          }\n          scheduleRecheck(remainingDelay);\n          return;\n        }\n    \n        switch (lastHealthState) {\n        case SERVICE_HEALTHY:\n          if(serviceState !\u003d HAServiceState.OBSERVER) {\n            elector.joinElection(targetToData(localTarget));\n          }\n          if (quitElectionOnBadState) {\n            quitElectionOnBadState \u003d false;\n          }\n          break;\n          \n        case INITIALIZING:\n          LOG.info(\"Ensuring that \" + localTarget + \" does not \" +\n              \"participate in active master election\");\n          elector.quitElection(false);\n          serviceState \u003d HAServiceState.INITIALIZING;\n          break;\n    \n        case SERVICE_UNHEALTHY:\n        case SERVICE_NOT_RESPONDING:\n          LOG.info(\"Quitting master election for \" + localTarget +\n              \" and marking that fencing is necessary\");\n          elector.quitElection(true);\n          serviceState \u003d HAServiceState.INITIALIZING;\n          break;\n          \n        case HEALTH_MONITOR_FAILED:\n          fatalError(\"Health monitor failed!\");\n          break;\n          \n        default:\n          throw new IllegalArgumentException(\"Unhandled state:\"\n                                               + lastHealthState);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java",
      "extendedDetails": {}
    },
    "6eba48cbdeae7f7d46b2e0ad84bf3845c333000d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10251. Both NameNodes could be in STANDBY State if SNN network is unstable. Contributed by Vinayakumar B.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1589494 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/04/14 11:55 AM",
      "commitName": "6eba48cbdeae7f7d46b2e0ad84bf3845c333000d",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "28/08/13 10:54 AM",
      "commitNameOld": "f3c0074030864a0f1da2e4c2376798585cf13db0",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 238.04,
      "commitsBetweenForRepo": 1639,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,50 @@\n   private void recheckElectability() {\n     // Maintain lock ordering of elector -\u003e ZKFC\n     synchronized (elector) {\n       synchronized (this) {\n         boolean healthy \u003d lastHealthState \u003d\u003d State.SERVICE_HEALTHY;\n     \n         long remainingDelay \u003d delayJoiningUntilNanotime - System.nanoTime(); \n         if (remainingDelay \u003e 0) {\n           if (healthy) {\n             LOG.info(\"Would have joined master election, but this node is \" +\n                 \"prohibited from doing so for \" +\n                 TimeUnit.NANOSECONDS.toMillis(remainingDelay) + \" more ms\");\n           }\n           scheduleRecheck(remainingDelay);\n           return;\n         }\n     \n         switch (lastHealthState) {\n         case SERVICE_HEALTHY:\n           elector.joinElection(targetToData(localTarget));\n+          if (quitElectionOnBadState) {\n+            quitElectionOnBadState \u003d false;\n+          }\n           break;\n           \n         case INITIALIZING:\n           LOG.info(\"Ensuring that \" + localTarget + \" does not \" +\n               \"participate in active master election\");\n           elector.quitElection(false);\n+          serviceState \u003d HAServiceState.INITIALIZING;\n           break;\n     \n         case SERVICE_UNHEALTHY:\n         case SERVICE_NOT_RESPONDING:\n           LOG.info(\"Quitting master election for \" + localTarget +\n               \" and marking that fencing is necessary\");\n           elector.quitElection(true);\n+          serviceState \u003d HAServiceState.INITIALIZING;\n           break;\n           \n         case HEALTH_MONITOR_FAILED:\n           fatalError(\"Health monitor failed!\");\n           break;\n           \n         default:\n           throw new IllegalArgumentException(\"Unhandled state:\" + lastHealthState);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void recheckElectability() {\n    // Maintain lock ordering of elector -\u003e ZKFC\n    synchronized (elector) {\n      synchronized (this) {\n        boolean healthy \u003d lastHealthState \u003d\u003d State.SERVICE_HEALTHY;\n    \n        long remainingDelay \u003d delayJoiningUntilNanotime - System.nanoTime(); \n        if (remainingDelay \u003e 0) {\n          if (healthy) {\n            LOG.info(\"Would have joined master election, but this node is \" +\n                \"prohibited from doing so for \" +\n                TimeUnit.NANOSECONDS.toMillis(remainingDelay) + \" more ms\");\n          }\n          scheduleRecheck(remainingDelay);\n          return;\n        }\n    \n        switch (lastHealthState) {\n        case SERVICE_HEALTHY:\n          elector.joinElection(targetToData(localTarget));\n          if (quitElectionOnBadState) {\n            quitElectionOnBadState \u003d false;\n          }\n          break;\n          \n        case INITIALIZING:\n          LOG.info(\"Ensuring that \" + localTarget + \" does not \" +\n              \"participate in active master election\");\n          elector.quitElection(false);\n          serviceState \u003d HAServiceState.INITIALIZING;\n          break;\n    \n        case SERVICE_UNHEALTHY:\n        case SERVICE_NOT_RESPONDING:\n          LOG.info(\"Quitting master election for \" + localTarget +\n              \" and marking that fencing is necessary\");\n          elector.quitElection(true);\n          serviceState \u003d HAServiceState.INITIALIZING;\n          break;\n          \n        case HEALTH_MONITOR_FAILED:\n          fatalError(\"Health monitor failed!\");\n          break;\n          \n        default:\n          throw new IllegalArgumentException(\"Unhandled state:\" + lastHealthState);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java",
      "extendedDetails": {}
    },
    "9d5799553fea81920edfab611e5d485a97841848": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8279. Allow manual failover to be invoked when auto-failover is enabled. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-3042@1333288 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/05/12 6:56 PM",
      "commitName": "9d5799553fea81920edfab611e5d485a97841848",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,45 @@\n+  private void recheckElectability() {\n+    // Maintain lock ordering of elector -\u003e ZKFC\n+    synchronized (elector) {\n+      synchronized (this) {\n+        boolean healthy \u003d lastHealthState \u003d\u003d State.SERVICE_HEALTHY;\n+    \n+        long remainingDelay \u003d delayJoiningUntilNanotime - System.nanoTime(); \n+        if (remainingDelay \u003e 0) {\n+          if (healthy) {\n+            LOG.info(\"Would have joined master election, but this node is \" +\n+                \"prohibited from doing so for \" +\n+                TimeUnit.NANOSECONDS.toMillis(remainingDelay) + \" more ms\");\n+          }\n+          scheduleRecheck(remainingDelay);\n+          return;\n+        }\n+    \n+        switch (lastHealthState) {\n+        case SERVICE_HEALTHY:\n+          elector.joinElection(targetToData(localTarget));\n+          break;\n+          \n+        case INITIALIZING:\n+          LOG.info(\"Ensuring that \" + localTarget + \" does not \" +\n+              \"participate in active master election\");\n+          elector.quitElection(false);\n+          break;\n+    \n+        case SERVICE_UNHEALTHY:\n+        case SERVICE_NOT_RESPONDING:\n+          LOG.info(\"Quitting master election for \" + localTarget +\n+              \" and marking that fencing is necessary\");\n+          elector.quitElection(true);\n+          break;\n+          \n+        case HEALTH_MONITOR_FAILED:\n+          fatalError(\"Health monitor failed!\");\n+          break;\n+          \n+        default:\n+          throw new IllegalArgumentException(\"Unhandled state:\" + lastHealthState);\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void recheckElectability() {\n    // Maintain lock ordering of elector -\u003e ZKFC\n    synchronized (elector) {\n      synchronized (this) {\n        boolean healthy \u003d lastHealthState \u003d\u003d State.SERVICE_HEALTHY;\n    \n        long remainingDelay \u003d delayJoiningUntilNanotime - System.nanoTime(); \n        if (remainingDelay \u003e 0) {\n          if (healthy) {\n            LOG.info(\"Would have joined master election, but this node is \" +\n                \"prohibited from doing so for \" +\n                TimeUnit.NANOSECONDS.toMillis(remainingDelay) + \" more ms\");\n          }\n          scheduleRecheck(remainingDelay);\n          return;\n        }\n    \n        switch (lastHealthState) {\n        case SERVICE_HEALTHY:\n          elector.joinElection(targetToData(localTarget));\n          break;\n          \n        case INITIALIZING:\n          LOG.info(\"Ensuring that \" + localTarget + \" does not \" +\n              \"participate in active master election\");\n          elector.quitElection(false);\n          break;\n    \n        case SERVICE_UNHEALTHY:\n        case SERVICE_NOT_RESPONDING:\n          LOG.info(\"Quitting master election for \" + localTarget +\n              \" and marking that fencing is necessary\");\n          elector.quitElection(true);\n          break;\n          \n        case HEALTH_MONITOR_FAILED:\n          fatalError(\"Health monitor failed!\");\n          break;\n          \n        default:\n          throw new IllegalArgumentException(\"Unhandled state:\" + lastHealthState);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ha/ZKFailoverController.java"
    }
  }
}