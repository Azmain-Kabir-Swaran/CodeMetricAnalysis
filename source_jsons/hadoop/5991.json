{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NamenodeFsck.java",
  "functionName": "fsck",
  "functionId": "fsck",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
  "functionStartLine": 371,
  "functionEndLine": 479,
  "numCommitsSeen": 128,
  "timeTaken": 8763,
  "changeHistory": [
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
    "796a676d18bd7cd3ed4113d002e0e69cf261d6d1",
    "194251c85250fcbe80a6ffee88b2cd4689334be3",
    "97913f430cbe3f82ac866ae6ab8f42754102f6c0",
    "0ed92e5b13f6bbc0ea7475bc67488359413a980e",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498",
    "430b5371883e22abb65f37c3e3d4afc3f421fc89",
    "d140d76a43c88e326b9c2818578f22bd3563b969",
    "371a3b87ed346732ed58a4faab0c6c1db57c86ed",
    "b6d483b1221296be408df66bc56b37765ce196de",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e",
    "21fdf16b0d866dfd9eef22515be5da5f1cd9ac59",
    "b0632df93ae5d00180b21983d960d50a45f8fb7a",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568": "Ybodychange",
    "796a676d18bd7cd3ed4113d002e0e69cf261d6d1": "Ybodychange",
    "194251c85250fcbe80a6ffee88b2cd4689334be3": "Ybodychange",
    "97913f430cbe3f82ac866ae6ab8f42754102f6c0": "Ybodychange",
    "0ed92e5b13f6bbc0ea7475bc67488359413a980e": "Ybodychange",
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": "Ybodychange",
    "430b5371883e22abb65f37c3e3d4afc3f421fc89": "Ybodychange",
    "d140d76a43c88e326b9c2818578f22bd3563b969": "Ybodychange",
    "371a3b87ed346732ed58a4faab0c6c1db57c86ed": "Ybodychange",
    "b6d483b1221296be408df66bc56b37765ce196de": "Ybodychange",
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": "Ybodychange",
    "21fdf16b0d866dfd9eef22515be5da5f1cd9ac59": "Ybodychange",
    "b0632df93ae5d00180b21983d960d50a45f8fb7a": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "eca1a4bfe952fc184fe90dde50bac9b0e5293568": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13695. Move logging to slf4j in HDFS package. Contributed by Ian Pickering.\n",
      "commitDate": "06/09/18 2:48 PM",
      "commitName": "eca1a4bfe952fc184fe90dde50bac9b0e5293568",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "30/08/18 9:45 AM",
      "commitNameOld": "c36d69a7b30927eaea16335e06cfcc247accde35",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 7.21,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,109 @@\n   public void fsck() {\n     final long startTime \u003d Time.monotonicNow();\n     try {\n       if(blockIds !\u003d null) {\n         String[] blocks \u003d blockIds.split(\" \");\n         StringBuilder sb \u003d new StringBuilder();\n         sb.append(\"FSCK started by \" +\n             UserGroupInformation.getCurrentUser() + \" from \" +\n             remoteAddress + \" at \" + new Date());\n         out.println(sb);\n         sb.append(\" for blockIds: \\n\");\n         for (String blk: blocks) {\n           if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n             out.println(\"Incorrect blockId format: \" + blk);\n             continue;\n           }\n           out.print(\"\\n\");\n           blockIdCK(blk);\n           sb.append(blk + \"\\n\");\n         }\n-        LOG.info(sb);\n+        LOG.info(\"{}\", sb.toString());\n         namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n         out.flush();\n         return;\n       }\n \n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n       if (snapshottableDirs !\u003d null) {\n         SnapshottableDirectoryStatus[] snapshotDirs \u003d\n             namenode.getRpcServer().getSnapshottableDirListing();\n         if (snapshotDirs !\u003d null) {\n           for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n             snapshottableDirs.add(dir.getFullPath().toString());\n           }\n         }\n       }\n \n       final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n \n         if (this.showStoragePolcies) {\n           storageTypeSummary \u003d new StoragePolicySummary(\n               namenode.getNamesystem().getBlockManager().getStoragePolicies());\n         }\n \n         Result replRes \u003d new ReplicationResult(conf);\n         Result ecRes \u003d new ErasureCodingResult(conf);\n \n         check(path, file, replRes, ecRes);\n \n         out.print(\"\\nStatus: \");\n         out.println(replRes.isHealthy() \u0026\u0026 ecRes.isHealthy() ? \"HEALTHY\" : \"CORRUPT\");\n         out.println(\" Number of data-nodes:\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n         out.println(\" Total dirs:\\t\\t\\t\" + totalDirs);\n         out.println(\" Total symlinks:\\t\\t\" + totalSymlinks);\n         out.println(\"\\nReplicated Blocks:\");\n         out.println(replRes);\n         out.println(\"\\nErasure Coded Block Groups:\");\n         out.println(ecRes);\n \n         if (this.showStoragePolcies) {\n           out.print(storageTypeSummary);\n         }\n \n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n             + (Time.monotonicNow() - startTime + \" milliseconds\"));\n \n         // If there were internal errors during the fsck operation, we want to\n         // return FAILURE_STATUS, even if those errors were not immediately\n         // fatal.  Otherwise many unit tests will pass even when there are bugs.\n         if (internalError) {\n           throw new IOException(\"fsck encountered internal errors!\");\n         }\n \n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line\n         // of the report.\n         if (replRes.isHealthy() \u0026\u0026 ecRes.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n           + (Time.monotonicNow() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d Time.monotonicNow();\n    try {\n      if(blockIds !\u003d null) {\n        String[] blocks \u003d blockIds.split(\" \");\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"FSCK started by \" +\n            UserGroupInformation.getCurrentUser() + \" from \" +\n            remoteAddress + \" at \" + new Date());\n        out.println(sb);\n        sb.append(\" for blockIds: \\n\");\n        for (String blk: blocks) {\n          if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n            out.println(\"Incorrect blockId format: \" + blk);\n            continue;\n          }\n          out.print(\"\\n\");\n          blockIdCK(blk);\n          sb.append(blk + \"\\n\");\n        }\n        LOG.info(\"{}\", sb.toString());\n        namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n        out.flush();\n        return;\n      }\n\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      if (snapshottableDirs !\u003d null) {\n        SnapshottableDirectoryStatus[] snapshotDirs \u003d\n            namenode.getRpcServer().getSnapshottableDirListing();\n        if (snapshotDirs !\u003d null) {\n          for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n            snapshottableDirs.add(dir.getFullPath().toString());\n          }\n        }\n      }\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n\n        if (this.showStoragePolcies) {\n          storageTypeSummary \u003d new StoragePolicySummary(\n              namenode.getNamesystem().getBlockManager().getStoragePolicies());\n        }\n\n        Result replRes \u003d new ReplicationResult(conf);\n        Result ecRes \u003d new ErasureCodingResult(conf);\n\n        check(path, file, replRes, ecRes);\n\n        out.print(\"\\nStatus: \");\n        out.println(replRes.isHealthy() \u0026\u0026 ecRes.isHealthy() ? \"HEALTHY\" : \"CORRUPT\");\n        out.println(\" Number of data-nodes:\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n        out.println(\" Total dirs:\\t\\t\\t\" + totalDirs);\n        out.println(\" Total symlinks:\\t\\t\" + totalSymlinks);\n        out.println(\"\\nReplicated Blocks:\");\n        out.println(replRes);\n        out.println(\"\\nErasure Coded Block Groups:\");\n        out.println(ecRes);\n\n        if (this.showStoragePolcies) {\n          out.print(storageTypeSummary);\n        }\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (Time.monotonicNow() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line\n        // of the report.\n        if (replRes.isHealthy() \u0026\u0026 ecRes.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (Time.monotonicNow() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "796a676d18bd7cd3ed4113d002e0e69cf261d6d1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9528. Cleanup namenode audit/log/exception messages. (szetszwo via umamahesh)\n",
      "commitDate": "11/12/15 5:57 PM",
      "commitName": "796a676d18bd7cd3ed4113d002e0e69cf261d6d1",
      "commitAuthor": "Uma Mahesh",
      "commitDateOld": "09/12/15 5:55 PM",
      "commitNameOld": "132478e805ba0f955345217b8ad87c2d17cccb2d",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 2.0,
      "commitsBetweenForRepo": 10,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,109 @@\n   public void fsck() {\n     final long startTime \u003d Time.monotonicNow();\n     try {\n       if(blockIds !\u003d null) {\n         String[] blocks \u003d blockIds.split(\" \");\n         StringBuilder sb \u003d new StringBuilder();\n         sb.append(\"FSCK started by \" +\n             UserGroupInformation.getCurrentUser() + \" from \" +\n             remoteAddress + \" at \" + new Date());\n-        out.println(sb.toString());\n+        out.println(sb);\n         sb.append(\" for blockIds: \\n\");\n         for (String blk: blocks) {\n           if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n             out.println(\"Incorrect blockId format: \" + blk);\n             continue;\n           }\n           out.print(\"\\n\");\n           blockIdCK(blk);\n           sb.append(blk + \"\\n\");\n         }\n-        LOG.info(sb.toString());\n+        LOG.info(sb);\n         namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n         out.flush();\n         return;\n       }\n \n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n       if (snapshottableDirs !\u003d null) {\n         SnapshottableDirectoryStatus[] snapshotDirs \u003d\n             namenode.getRpcServer().getSnapshottableDirListing();\n         if (snapshotDirs !\u003d null) {\n           for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n             snapshottableDirs.add(dir.getFullPath().toString());\n           }\n         }\n       }\n \n       final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n \n         if (this.showStoragePolcies) {\n           storageTypeSummary \u003d new StoragePolicySummary(\n               namenode.getNamesystem().getBlockManager().getStoragePolicies());\n         }\n \n         Result replRes \u003d new ReplicationResult(conf);\n         Result ecRes \u003d new ErasureCodingResult(conf);\n \n         check(path, file, replRes, ecRes);\n \n         out.print(\"\\nStatus: \");\n         out.println(replRes.isHealthy() \u0026\u0026 ecRes.isHealthy() ? \"HEALTHY\" : \"CORRUPT\");\n         out.println(\" Number of data-nodes:\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n         out.println(\" Total dirs:\\t\\t\\t\" + totalDirs);\n         out.println(\" Total symlinks:\\t\\t\" + totalSymlinks);\n         out.println(\"\\nReplicated Blocks:\");\n         out.println(replRes);\n         out.println(\"\\nErasure Coded Block Groups:\");\n         out.println(ecRes);\n \n         if (this.showStoragePolcies) {\n-          out.print(storageTypeSummary.toString());\n+          out.print(storageTypeSummary);\n         }\n \n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n             + (Time.monotonicNow() - startTime + \" milliseconds\"));\n \n         // If there were internal errors during the fsck operation, we want to\n         // return FAILURE_STATUS, even if those errors were not immediately\n         // fatal.  Otherwise many unit tests will pass even when there are bugs.\n         if (internalError) {\n           throw new IOException(\"fsck encountered internal errors!\");\n         }\n \n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line\n         // of the report.\n         if (replRes.isHealthy() \u0026\u0026 ecRes.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n           + (Time.monotonicNow() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d Time.monotonicNow();\n    try {\n      if(blockIds !\u003d null) {\n        String[] blocks \u003d blockIds.split(\" \");\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"FSCK started by \" +\n            UserGroupInformation.getCurrentUser() + \" from \" +\n            remoteAddress + \" at \" + new Date());\n        out.println(sb);\n        sb.append(\" for blockIds: \\n\");\n        for (String blk: blocks) {\n          if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n            out.println(\"Incorrect blockId format: \" + blk);\n            continue;\n          }\n          out.print(\"\\n\");\n          blockIdCK(blk);\n          sb.append(blk + \"\\n\");\n        }\n        LOG.info(sb);\n        namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n        out.flush();\n        return;\n      }\n\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      if (snapshottableDirs !\u003d null) {\n        SnapshottableDirectoryStatus[] snapshotDirs \u003d\n            namenode.getRpcServer().getSnapshottableDirListing();\n        if (snapshotDirs !\u003d null) {\n          for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n            snapshottableDirs.add(dir.getFullPath().toString());\n          }\n        }\n      }\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n\n        if (this.showStoragePolcies) {\n          storageTypeSummary \u003d new StoragePolicySummary(\n              namenode.getNamesystem().getBlockManager().getStoragePolicies());\n        }\n\n        Result replRes \u003d new ReplicationResult(conf);\n        Result ecRes \u003d new ErasureCodingResult(conf);\n\n        check(path, file, replRes, ecRes);\n\n        out.print(\"\\nStatus: \");\n        out.println(replRes.isHealthy() \u0026\u0026 ecRes.isHealthy() ? \"HEALTHY\" : \"CORRUPT\");\n        out.println(\" Number of data-nodes:\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n        out.println(\" Total dirs:\\t\\t\\t\" + totalDirs);\n        out.println(\" Total symlinks:\\t\\t\" + totalSymlinks);\n        out.println(\"\\nReplicated Blocks:\");\n        out.println(replRes);\n        out.println(\"\\nErasure Coded Block Groups:\");\n        out.println(ecRes);\n\n        if (this.showStoragePolcies) {\n          out.print(storageTypeSummary);\n        }\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (Time.monotonicNow() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line\n        // of the report.\n        if (replRes.isHealthy() \u0026\u0026 ecRes.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (Time.monotonicNow() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "194251c85250fcbe80a6ffee88b2cd4689334be3": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9351. checkNNStartup() need to be called when fsck calls FSNamesystem.getSnapshottableDirs(). (Xiao Chen via Yongjun Zhang)\n",
      "commitDate": "03/11/15 5:16 PM",
      "commitName": "194251c85250fcbe80a6ffee88b2cd4689334be3",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "27/10/15 11:31 PM",
      "commitNameOld": "97913f430cbe3f82ac866ae6ab8f42754102f6c0",
      "commitAuthorOld": "Yongjun Zhang",
      "daysBetweenCommits": 6.78,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,109 @@\n   public void fsck() {\n     final long startTime \u003d Time.monotonicNow();\n     try {\n       if(blockIds !\u003d null) {\n         String[] blocks \u003d blockIds.split(\" \");\n         StringBuilder sb \u003d new StringBuilder();\n         sb.append(\"FSCK started by \" +\n             UserGroupInformation.getCurrentUser() + \" from \" +\n             remoteAddress + \" at \" + new Date());\n         out.println(sb.toString());\n         sb.append(\" for blockIds: \\n\");\n         for (String blk: blocks) {\n           if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n             out.println(\"Incorrect blockId format: \" + blk);\n             continue;\n           }\n           out.print(\"\\n\");\n           blockIdCK(blk);\n           sb.append(blk + \"\\n\");\n         }\n         LOG.info(sb.toString());\n         namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n         out.flush();\n         return;\n       }\n \n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n       if (snapshottableDirs !\u003d null) {\n-        snapshottableDirs \u003d namenode.getNamesystem().getSnapshottableDirs();\n+        SnapshottableDirectoryStatus[] snapshotDirs \u003d\n+            namenode.getRpcServer().getSnapshottableDirListing();\n+        if (snapshotDirs !\u003d null) {\n+          for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n+            snapshottableDirs.add(dir.getFullPath().toString());\n+          }\n+        }\n       }\n \n       final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n \n         if (this.showStoragePolcies) {\n           storageTypeSummary \u003d new StoragePolicySummary(\n               namenode.getNamesystem().getBlockManager().getStoragePolicies());\n         }\n \n         Result replRes \u003d new ReplicationResult(conf);\n         Result ecRes \u003d new ErasureCodingResult(conf);\n \n         check(path, file, replRes, ecRes);\n \n         out.print(\"\\nStatus: \");\n         out.println(replRes.isHealthy() \u0026\u0026 ecRes.isHealthy() ? \"HEALTHY\" : \"CORRUPT\");\n         out.println(\" Number of data-nodes:\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n         out.println(\" Total dirs:\\t\\t\\t\" + totalDirs);\n         out.println(\" Total symlinks:\\t\\t\" + totalSymlinks);\n         out.println(\"\\nReplicated Blocks:\");\n         out.println(replRes);\n         out.println(\"\\nErasure Coded Block Groups:\");\n         out.println(ecRes);\n \n         if (this.showStoragePolcies) {\n           out.print(storageTypeSummary.toString());\n         }\n \n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n             + (Time.monotonicNow() - startTime + \" milliseconds\"));\n \n         // If there were internal errors during the fsck operation, we want to\n         // return FAILURE_STATUS, even if those errors were not immediately\n         // fatal.  Otherwise many unit tests will pass even when there are bugs.\n         if (internalError) {\n           throw new IOException(\"fsck encountered internal errors!\");\n         }\n \n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line\n         // of the report.\n         if (replRes.isHealthy() \u0026\u0026 ecRes.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n           + (Time.monotonicNow() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d Time.monotonicNow();\n    try {\n      if(blockIds !\u003d null) {\n        String[] blocks \u003d blockIds.split(\" \");\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"FSCK started by \" +\n            UserGroupInformation.getCurrentUser() + \" from \" +\n            remoteAddress + \" at \" + new Date());\n        out.println(sb.toString());\n        sb.append(\" for blockIds: \\n\");\n        for (String blk: blocks) {\n          if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n            out.println(\"Incorrect blockId format: \" + blk);\n            continue;\n          }\n          out.print(\"\\n\");\n          blockIdCK(blk);\n          sb.append(blk + \"\\n\");\n        }\n        LOG.info(sb.toString());\n        namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n        out.flush();\n        return;\n      }\n\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      if (snapshottableDirs !\u003d null) {\n        SnapshottableDirectoryStatus[] snapshotDirs \u003d\n            namenode.getRpcServer().getSnapshottableDirListing();\n        if (snapshotDirs !\u003d null) {\n          for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n            snapshottableDirs.add(dir.getFullPath().toString());\n          }\n        }\n      }\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n\n        if (this.showStoragePolcies) {\n          storageTypeSummary \u003d new StoragePolicySummary(\n              namenode.getNamesystem().getBlockManager().getStoragePolicies());\n        }\n\n        Result replRes \u003d new ReplicationResult(conf);\n        Result ecRes \u003d new ErasureCodingResult(conf);\n\n        check(path, file, replRes, ecRes);\n\n        out.print(\"\\nStatus: \");\n        out.println(replRes.isHealthy() \u0026\u0026 ecRes.isHealthy() ? \"HEALTHY\" : \"CORRUPT\");\n        out.println(\" Number of data-nodes:\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n        out.println(\" Total dirs:\\t\\t\\t\" + totalDirs);\n        out.println(\" Total symlinks:\\t\\t\" + totalSymlinks);\n        out.println(\"\\nReplicated Blocks:\");\n        out.println(replRes);\n        out.println(\"\\nErasure Coded Block Groups:\");\n        out.println(ecRes);\n\n        if (this.showStoragePolcies) {\n          out.print(storageTypeSummary.toString());\n        }\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (Time.monotonicNow() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line\n        // of the report.\n        if (replRes.isHealthy() \u0026\u0026 ecRes.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (Time.monotonicNow() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "97913f430cbe3f82ac866ae6ab8f42754102f6c0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9231. fsck doesn\u0027t list correct file path when Bad Replicas/Blocks are in a snapshot. (Xiao Chen via Yongjun Zhang)\n",
      "commitDate": "27/10/15 11:31 PM",
      "commitName": "97913f430cbe3f82ac866ae6ab8f42754102f6c0",
      "commitAuthor": "Yongjun Zhang",
      "commitDateOld": "21/10/15 2:44 PM",
      "commitNameOld": "d806a5bf079bf136114520c5a3a9d1f16ecf2eda",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 6.37,
      "commitsBetweenForRepo": 74,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,103 @@\n   public void fsck() {\n     final long startTime \u003d Time.monotonicNow();\n     try {\n       if(blockIds !\u003d null) {\n         String[] blocks \u003d blockIds.split(\" \");\n         StringBuilder sb \u003d new StringBuilder();\n         sb.append(\"FSCK started by \" +\n             UserGroupInformation.getCurrentUser() + \" from \" +\n             remoteAddress + \" at \" + new Date());\n         out.println(sb.toString());\n         sb.append(\" for blockIds: \\n\");\n         for (String blk: blocks) {\n           if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n             out.println(\"Incorrect blockId format: \" + blk);\n             continue;\n           }\n           out.print(\"\\n\");\n           blockIdCK(blk);\n           sb.append(blk + \"\\n\");\n         }\n         LOG.info(sb.toString());\n         namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n         out.flush();\n         return;\n       }\n \n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n       if (snapshottableDirs !\u003d null) {\n-        SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n-            .getSnapshottableDirListing();\n-        if (snapshotDirs !\u003d null) {\n-          for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n-            snapshottableDirs.add(dir.getFullPath().toString());\n-          }\n-        }\n+        snapshottableDirs \u003d namenode.getNamesystem().getSnapshottableDirs();\n       }\n \n       final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n \n         if (this.showStoragePolcies) {\n           storageTypeSummary \u003d new StoragePolicySummary(\n               namenode.getNamesystem().getBlockManager().getStoragePolicies());\n         }\n \n         Result replRes \u003d new ReplicationResult(conf);\n         Result ecRes \u003d new ErasureCodingResult(conf);\n \n         check(path, file, replRes, ecRes);\n \n         out.print(\"\\nStatus: \");\n         out.println(replRes.isHealthy() \u0026\u0026 ecRes.isHealthy() ? \"HEALTHY\" : \"CORRUPT\");\n         out.println(\" Number of data-nodes:\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n         out.println(\" Total dirs:\\t\\t\\t\" + totalDirs);\n         out.println(\" Total symlinks:\\t\\t\" + totalSymlinks);\n         out.println(\"\\nReplicated Blocks:\");\n         out.println(replRes);\n         out.println(\"\\nErasure Coded Block Groups:\");\n         out.println(ecRes);\n \n         if (this.showStoragePolcies) {\n           out.print(storageTypeSummary.toString());\n         }\n \n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n             + (Time.monotonicNow() - startTime + \" milliseconds\"));\n \n         // If there were internal errors during the fsck operation, we want to\n         // return FAILURE_STATUS, even if those errors were not immediately\n         // fatal.  Otherwise many unit tests will pass even when there are bugs.\n         if (internalError) {\n           throw new IOException(\"fsck encountered internal errors!\");\n         }\n \n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line\n         // of the report.\n         if (replRes.isHealthy() \u0026\u0026 ecRes.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n           + (Time.monotonicNow() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d Time.monotonicNow();\n    try {\n      if(blockIds !\u003d null) {\n        String[] blocks \u003d blockIds.split(\" \");\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"FSCK started by \" +\n            UserGroupInformation.getCurrentUser() + \" from \" +\n            remoteAddress + \" at \" + new Date());\n        out.println(sb.toString());\n        sb.append(\" for blockIds: \\n\");\n        for (String blk: blocks) {\n          if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n            out.println(\"Incorrect blockId format: \" + blk);\n            continue;\n          }\n          out.print(\"\\n\");\n          blockIdCK(blk);\n          sb.append(blk + \"\\n\");\n        }\n        LOG.info(sb.toString());\n        namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n        out.flush();\n        return;\n      }\n\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      if (snapshottableDirs !\u003d null) {\n        snapshottableDirs \u003d namenode.getNamesystem().getSnapshottableDirs();\n      }\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n\n        if (this.showStoragePolcies) {\n          storageTypeSummary \u003d new StoragePolicySummary(\n              namenode.getNamesystem().getBlockManager().getStoragePolicies());\n        }\n\n        Result replRes \u003d new ReplicationResult(conf);\n        Result ecRes \u003d new ErasureCodingResult(conf);\n\n        check(path, file, replRes, ecRes);\n\n        out.print(\"\\nStatus: \");\n        out.println(replRes.isHealthy() \u0026\u0026 ecRes.isHealthy() ? \"HEALTHY\" : \"CORRUPT\");\n        out.println(\" Number of data-nodes:\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n        out.println(\" Total dirs:\\t\\t\\t\" + totalDirs);\n        out.println(\" Total symlinks:\\t\\t\" + totalSymlinks);\n        out.println(\"\\nReplicated Blocks:\");\n        out.println(replRes);\n        out.println(\"\\nErasure Coded Block Groups:\");\n        out.println(ecRes);\n\n        if (this.showStoragePolcies) {\n          out.print(storageTypeSummary.toString());\n        }\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (Time.monotonicNow() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line\n        // of the report.\n        if (replRes.isHealthy() \u0026\u0026 ecRes.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (Time.monotonicNow() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "0ed92e5b13f6bbc0ea7475bc67488359413a980e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7768. Change fsck to support EC files.  Contributed by Takanobu Asanuma\n",
      "commitDate": "26/05/15 12:07 PM",
      "commitName": "0ed92e5b13f6bbc0ea7475bc67488359413a980e",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "26/05/15 12:02 PM",
      "commitNameOld": "e53fa769c97416af69ea567aecd44f67e896688b",
      "commitAuthorOld": "Zhe Zhang",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,101 +1,109 @@\n   public void fsck() {\n     final long startTime \u003d Time.monotonicNow();\n     try {\n       if(blockIds !\u003d null) {\n         String[] blocks \u003d blockIds.split(\" \");\n         StringBuilder sb \u003d new StringBuilder();\n         sb.append(\"FSCK started by \" +\n             UserGroupInformation.getCurrentUser() + \" from \" +\n             remoteAddress + \" at \" + new Date());\n         out.println(sb.toString());\n         sb.append(\" for blockIds: \\n\");\n         for (String blk: blocks) {\n           if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n             out.println(\"Incorrect blockId format: \" + blk);\n             continue;\n           }\n           out.print(\"\\n\");\n           blockIdCK(blk);\n           sb.append(blk + \"\\n\");\n         }\n         LOG.info(sb.toString());\n         namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n         out.flush();\n         return;\n       }\n \n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n       if (snapshottableDirs !\u003d null) {\n         SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n             .getSnapshottableDirListing();\n         if (snapshotDirs !\u003d null) {\n           for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n             snapshottableDirs.add(dir.getFullPath().toString());\n           }\n         }\n       }\n \n       final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n \n         if (this.showStoragePolcies) {\n           storageTypeSummary \u003d new StoragePolicySummary(\n               namenode.getNamesystem().getBlockManager().getStoragePolicies());\n         }\n \n-        Result res \u003d new Result(conf);\n+        Result replRes \u003d new ReplicationResult(conf);\n+        Result ecRes \u003d new ErasureCodingResult(conf);\n \n-        check(path, file, res);\n+        check(path, file, replRes, ecRes);\n \n-        out.println(res);\n-        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n+        out.print(\"\\nStatus: \");\n+        out.println(replRes.isHealthy() \u0026\u0026 ecRes.isHealthy() ? \"HEALTHY\" : \"CORRUPT\");\n+        out.println(\" Number of data-nodes:\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n+        out.println(\" Total dirs:\\t\\t\\t\" + totalDirs);\n+        out.println(\" Total symlinks:\\t\\t\" + totalSymlinks);\n+        out.println(\"\\nReplicated Blocks:\");\n+        out.println(replRes);\n+        out.println(\"\\nErasure Coded Block Groups:\");\n+        out.println(ecRes);\n \n         if (this.showStoragePolcies) {\n           out.print(storageTypeSummary.toString());\n         }\n \n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n             + (Time.monotonicNow() - startTime + \" milliseconds\"));\n \n         // If there were internal errors during the fsck operation, we want to\n         // return FAILURE_STATUS, even if those errors were not immediately\n         // fatal.  Otherwise many unit tests will pass even when there are bugs.\n         if (internalError) {\n           throw new IOException(\"fsck encountered internal errors!\");\n         }\n \n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line\n         // of the report.\n-        if (res.isHealthy()) {\n+        if (replRes.isHealthy() \u0026\u0026 ecRes.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n           + (Time.monotonicNow() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d Time.monotonicNow();\n    try {\n      if(blockIds !\u003d null) {\n        String[] blocks \u003d blockIds.split(\" \");\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"FSCK started by \" +\n            UserGroupInformation.getCurrentUser() + \" from \" +\n            remoteAddress + \" at \" + new Date());\n        out.println(sb.toString());\n        sb.append(\" for blockIds: \\n\");\n        for (String blk: blocks) {\n          if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n            out.println(\"Incorrect blockId format: \" + blk);\n            continue;\n          }\n          out.print(\"\\n\");\n          blockIdCK(blk);\n          sb.append(blk + \"\\n\");\n        }\n        LOG.info(sb.toString());\n        namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n        out.flush();\n        return;\n      }\n\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      if (snapshottableDirs !\u003d null) {\n        SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n            .getSnapshottableDirListing();\n        if (snapshotDirs !\u003d null) {\n          for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n            snapshottableDirs.add(dir.getFullPath().toString());\n          }\n        }\n      }\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n\n        if (this.showStoragePolcies) {\n          storageTypeSummary \u003d new StoragePolicySummary(\n              namenode.getNamesystem().getBlockManager().getStoragePolicies());\n        }\n\n        Result replRes \u003d new ReplicationResult(conf);\n        Result ecRes \u003d new ErasureCodingResult(conf);\n\n        check(path, file, replRes, ecRes);\n\n        out.print(\"\\nStatus: \");\n        out.println(replRes.isHealthy() \u0026\u0026 ecRes.isHealthy() ? \"HEALTHY\" : \"CORRUPT\");\n        out.println(\" Number of data-nodes:\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n        out.println(\" Total dirs:\\t\\t\\t\" + totalDirs);\n        out.println(\" Total symlinks:\\t\\t\" + totalSymlinks);\n        out.println(\"\\nReplicated Blocks:\");\n        out.println(replRes);\n        out.println(\"\\nErasure Coded Block Groups:\");\n        out.println(ecRes);\n\n        if (this.showStoragePolcies) {\n          out.print(storageTypeSummary.toString());\n        }\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (Time.monotonicNow() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line\n        // of the report.\n        if (replRes.isHealthy() \u0026\u0026 ecRes.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (Time.monotonicNow() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "75ead273bea8a7dad61c4f99c3a16cab2697c498": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6841. Use Time.monotonicNow() wherever applicable instead of Time.now(). Contributed by Vinayakumar B\n",
      "commitDate": "20/03/15 12:02 PM",
      "commitName": "75ead273bea8a7dad61c4f99c3a16cab2697c498",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "04/03/15 5:51 PM",
      "commitNameOld": "430b5371883e22abb65f37c3e3d4afc3f421fc89",
      "commitAuthorOld": "Dongming Liang",
      "daysBetweenCommits": 15.72,
      "commitsBetweenForRepo": 134,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   public void fsck() {\n-    final long startTime \u003d Time.now();\n+    final long startTime \u003d Time.monotonicNow();\n     try {\n       if(blockIds !\u003d null) {\n \n         String[] blocks \u003d blockIds.split(\" \");\n         StringBuilder sb \u003d new StringBuilder();\n         sb.append(\"FSCK started by \" +\n             UserGroupInformation.getCurrentUser() + \" from \" +\n             remoteAddress + \" at \" + new Date());\n         out.println(sb.toString());\n         sb.append(\" for blockIds: \\n\");\n         for (String blk: blocks) {\n           if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n             out.println(\"Incorrect blockId format: \" + blk);\n             continue;\n           }\n           out.print(\"\\n\");\n           blockIdCK(blk);\n           sb.append(blk + \"\\n\");\n         }\n         LOG.info(sb.toString());\n         namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n         out.flush();\n         return;\n       }\n \n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n       if (snapshottableDirs !\u003d null) {\n         SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n             .getSnapshottableDirListing();\n         if (snapshotDirs !\u003d null) {\n           for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n             snapshottableDirs.add(dir.getFullPath().toString());\n           }\n         }\n       }\n \n       final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n         \n         if (this.showStoragePolcies) {\n           storageTypeSummary \u003d new StoragePolicySummary(\n               namenode.getNamesystem().getBlockManager().getStoragePolicies());\n         }\n \n         Result res \u003d new Result(conf);\n \n         check(path, file, res);\n \n         out.println(res);\n         out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n \n         if (this.showStoragePolcies) {\n           out.print(storageTypeSummary.toString());\n         }\n \n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n-            + (Time.now() - startTime + \" milliseconds\"));\n+            + (Time.monotonicNow() - startTime + \" milliseconds\"));\n \n         // If there were internal errors during the fsck operation, we want to\n         // return FAILURE_STATUS, even if those errors were not immediately\n         // fatal.  Otherwise many unit tests will pass even when there are bugs.\n         if (internalError) {\n           throw new IOException(\"fsck encountered internal errors!\");\n         }\n \n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line \n         // of the report.\n         if (res.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n-          + (Time.now() - startTime + \" milliseconds\"));\n+          + (Time.monotonicNow() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d Time.monotonicNow();\n    try {\n      if(blockIds !\u003d null) {\n\n        String[] blocks \u003d blockIds.split(\" \");\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"FSCK started by \" +\n            UserGroupInformation.getCurrentUser() + \" from \" +\n            remoteAddress + \" at \" + new Date());\n        out.println(sb.toString());\n        sb.append(\" for blockIds: \\n\");\n        for (String blk: blocks) {\n          if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n            out.println(\"Incorrect blockId format: \" + blk);\n            continue;\n          }\n          out.print(\"\\n\");\n          blockIdCK(blk);\n          sb.append(blk + \"\\n\");\n        }\n        LOG.info(sb.toString());\n        namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n        out.flush();\n        return;\n      }\n\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      if (snapshottableDirs !\u003d null) {\n        SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n            .getSnapshottableDirListing();\n        if (snapshotDirs !\u003d null) {\n          for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n            snapshottableDirs.add(dir.getFullPath().toString());\n          }\n        }\n      }\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        if (this.showStoragePolcies) {\n          storageTypeSummary \u003d new StoragePolicySummary(\n              namenode.getNamesystem().getBlockManager().getStoragePolicies());\n        }\n\n        Result res \u003d new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        if (this.showStoragePolcies) {\n          out.print(storageTypeSummary.toString());\n        }\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (Time.monotonicNow() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (Time.monotonicNow() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "430b5371883e22abb65f37c3e3d4afc3f421fc89": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1522. Combine two BLOCK_FILE_PREFIX constants into one. Contributed by Dongming Liang.",
      "commitDate": "04/03/15 5:51 PM",
      "commitName": "430b5371883e22abb65f37c3e3d4afc3f421fc89",
      "commitAuthor": "Dongming Liang",
      "commitDateOld": "25/02/15 7:45 PM",
      "commitNameOld": "725cc499f00abeeab9f58cbc778e65522eec9d98",
      "commitAuthorOld": "Tsz-Wo Nicholas Sze",
      "daysBetweenCommits": 6.92,
      "commitsBetweenForRepo": 59,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,102 +1,102 @@\n   public void fsck() {\n     final long startTime \u003d Time.now();\n     try {\n       if(blockIds !\u003d null) {\n \n         String[] blocks \u003d blockIds.split(\" \");\n         StringBuilder sb \u003d new StringBuilder();\n         sb.append(\"FSCK started by \" +\n             UserGroupInformation.getCurrentUser() + \" from \" +\n             remoteAddress + \" at \" + new Date());\n         out.println(sb.toString());\n         sb.append(\" for blockIds: \\n\");\n         for (String blk: blocks) {\n-          if(blk \u003d\u003d null || !blk.contains(\"blk_\")) {\n+          if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n             out.println(\"Incorrect blockId format: \" + blk);\n             continue;\n           }\n           out.print(\"\\n\");\n           blockIdCK(blk);\n           sb.append(blk + \"\\n\");\n         }\n         LOG.info(sb.toString());\n         namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n         out.flush();\n         return;\n       }\n \n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n       if (snapshottableDirs !\u003d null) {\n         SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n             .getSnapshottableDirListing();\n         if (snapshotDirs !\u003d null) {\n           for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n             snapshottableDirs.add(dir.getFullPath().toString());\n           }\n         }\n       }\n \n       final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n         \n         if (this.showStoragePolcies) {\n           storageTypeSummary \u003d new StoragePolicySummary(\n               namenode.getNamesystem().getBlockManager().getStoragePolicies());\n         }\n \n         Result res \u003d new Result(conf);\n \n         check(path, file, res);\n \n         out.println(res);\n         out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n \n         if (this.showStoragePolcies) {\n           out.print(storageTypeSummary.toString());\n         }\n \n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n             + (Time.now() - startTime + \" milliseconds\"));\n \n         // If there were internal errors during the fsck operation, we want to\n         // return FAILURE_STATUS, even if those errors were not immediately\n         // fatal.  Otherwise many unit tests will pass even when there are bugs.\n         if (internalError) {\n           throw new IOException(\"fsck encountered internal errors!\");\n         }\n \n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line \n         // of the report.\n         if (res.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n           + (Time.now() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d Time.now();\n    try {\n      if(blockIds !\u003d null) {\n\n        String[] blocks \u003d blockIds.split(\" \");\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"FSCK started by \" +\n            UserGroupInformation.getCurrentUser() + \" from \" +\n            remoteAddress + \" at \" + new Date());\n        out.println(sb.toString());\n        sb.append(\" for blockIds: \\n\");\n        for (String blk: blocks) {\n          if(blk \u003d\u003d null || !blk.contains(Block.BLOCK_FILE_PREFIX)) {\n            out.println(\"Incorrect blockId format: \" + blk);\n            continue;\n          }\n          out.print(\"\\n\");\n          blockIdCK(blk);\n          sb.append(blk + \"\\n\");\n        }\n        LOG.info(sb.toString());\n        namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n        out.flush();\n        return;\n      }\n\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      if (snapshottableDirs !\u003d null) {\n        SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n            .getSnapshottableDirListing();\n        if (snapshotDirs !\u003d null) {\n          for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n            snapshottableDirs.add(dir.getFullPath().toString());\n          }\n        }\n      }\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        if (this.showStoragePolcies) {\n          storageTypeSummary \u003d new StoragePolicySummary(\n              namenode.getNamesystem().getBlockManager().getStoragePolicies());\n        }\n\n        Result res \u003d new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        if (this.showStoragePolcies) {\n          out.print(storageTypeSummary.toString());\n        }\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (Time.now() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (Time.now() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "d140d76a43c88e326b9c2818578f22bd3563b969": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7467. Provide storage tier information for a directory via fsck. (Benoy Antony)\n",
      "commitDate": "25/02/15 4:19 PM",
      "commitName": "d140d76a43c88e326b9c2818578f22bd3563b969",
      "commitAuthor": "Benoy Antony",
      "commitDateOld": "08/02/15 11:51 AM",
      "commitNameOld": "1382ae525c67bf95d8f3a436b547dbc72cfbb177",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 17.19,
      "commitsBetweenForRepo": 190,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,93 +1,102 @@\n   public void fsck() {\n     final long startTime \u003d Time.now();\n     try {\n       if(blockIds !\u003d null) {\n \n         String[] blocks \u003d blockIds.split(\" \");\n         StringBuilder sb \u003d new StringBuilder();\n         sb.append(\"FSCK started by \" +\n             UserGroupInformation.getCurrentUser() + \" from \" +\n             remoteAddress + \" at \" + new Date());\n         out.println(sb.toString());\n         sb.append(\" for blockIds: \\n\");\n         for (String blk: blocks) {\n           if(blk \u003d\u003d null || !blk.contains(\"blk_\")) {\n             out.println(\"Incorrect blockId format: \" + blk);\n             continue;\n           }\n           out.print(\"\\n\");\n           blockIdCK(blk);\n           sb.append(blk + \"\\n\");\n         }\n         LOG.info(sb.toString());\n         namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n         out.flush();\n         return;\n       }\n \n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n       if (snapshottableDirs !\u003d null) {\n         SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n             .getSnapshottableDirListing();\n         if (snapshotDirs !\u003d null) {\n           for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n             snapshottableDirs.add(dir.getFullPath().toString());\n           }\n         }\n       }\n \n       final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n         \n+        if (this.showStoragePolcies) {\n+          storageTypeSummary \u003d new StoragePolicySummary(\n+              namenode.getNamesystem().getBlockManager().getStoragePolicies());\n+        }\n+\n         Result res \u003d new Result(conf);\n \n         check(path, file, res);\n \n         out.println(res);\n         out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n \n+        if (this.showStoragePolcies) {\n+          out.print(storageTypeSummary.toString());\n+        }\n+\n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n             + (Time.now() - startTime + \" milliseconds\"));\n \n         // If there were internal errors during the fsck operation, we want to\n         // return FAILURE_STATUS, even if those errors were not immediately\n         // fatal.  Otherwise many unit tests will pass even when there are bugs.\n         if (internalError) {\n           throw new IOException(\"fsck encountered internal errors!\");\n         }\n \n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line \n         // of the report.\n         if (res.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n           + (Time.now() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d Time.now();\n    try {\n      if(blockIds !\u003d null) {\n\n        String[] blocks \u003d blockIds.split(\" \");\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"FSCK started by \" +\n            UserGroupInformation.getCurrentUser() + \" from \" +\n            remoteAddress + \" at \" + new Date());\n        out.println(sb.toString());\n        sb.append(\" for blockIds: \\n\");\n        for (String blk: blocks) {\n          if(blk \u003d\u003d null || !blk.contains(\"blk_\")) {\n            out.println(\"Incorrect blockId format: \" + blk);\n            continue;\n          }\n          out.print(\"\\n\");\n          blockIdCK(blk);\n          sb.append(blk + \"\\n\");\n        }\n        LOG.info(sb.toString());\n        namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n        out.flush();\n        return;\n      }\n\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      if (snapshottableDirs !\u003d null) {\n        SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n            .getSnapshottableDirListing();\n        if (snapshotDirs !\u003d null) {\n          for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n            snapshottableDirs.add(dir.getFullPath().toString());\n          }\n        }\n      }\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        if (this.showStoragePolcies) {\n          storageTypeSummary \u003d new StoragePolicySummary(\n              namenode.getNamesystem().getBlockManager().getStoragePolicies());\n        }\n\n        Result res \u003d new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        if (this.showStoragePolcies) {\n          out.print(storageTypeSummary.toString());\n        }\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (Time.now() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (Time.now() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "371a3b87ed346732ed58a4faab0c6c1db57c86ed": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6663. Admin command to track file and locations from block id.\nContributed by Chen He.\n",
      "commitDate": "28/10/14 12:26 PM",
      "commitName": "371a3b87ed346732ed58a4faab0c6c1db57c86ed",
      "commitAuthor": "Kihwal Lee",
      "commitDateOld": "19/09/14 9:23 PM",
      "commitNameOld": "f85cc14eb49a46e81d2edcdc1ffe4d0852f193a5",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 38.63,
      "commitsBetweenForRepo": 357,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,93 @@\n   public void fsck() {\n     final long startTime \u003d Time.now();\n     try {\n+      if(blockIds !\u003d null) {\n+\n+        String[] blocks \u003d blockIds.split(\" \");\n+        StringBuilder sb \u003d new StringBuilder();\n+        sb.append(\"FSCK started by \" +\n+            UserGroupInformation.getCurrentUser() + \" from \" +\n+            remoteAddress + \" at \" + new Date());\n+        out.println(sb.toString());\n+        sb.append(\" for blockIds: \\n\");\n+        for (String blk: blocks) {\n+          if(blk \u003d\u003d null || !blk.contains(\"blk_\")) {\n+            out.println(\"Incorrect blockId format: \" + blk);\n+            continue;\n+          }\n+          out.print(\"\\n\");\n+          blockIdCK(blk);\n+          sb.append(blk + \"\\n\");\n+        }\n+        LOG.info(sb.toString());\n+        namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n+        out.flush();\n+        return;\n+      }\n+\n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n       if (snapshottableDirs !\u003d null) {\n         SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n             .getSnapshottableDirListing();\n         if (snapshotDirs !\u003d null) {\n           for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n             snapshottableDirs.add(dir.getFullPath().toString());\n           }\n         }\n       }\n \n       final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n         \n         Result res \u003d new Result(conf);\n \n         check(path, file, res);\n \n         out.println(res);\n         out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n \n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n             + (Time.now() - startTime + \" milliseconds\"));\n \n         // If there were internal errors during the fsck operation, we want to\n         // return FAILURE_STATUS, even if those errors were not immediately\n         // fatal.  Otherwise many unit tests will pass even when there are bugs.\n         if (internalError) {\n           throw new IOException(\"fsck encountered internal errors!\");\n         }\n \n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line \n         // of the report.\n         if (res.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n           + (Time.now() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d Time.now();\n    try {\n      if(blockIds !\u003d null) {\n\n        String[] blocks \u003d blockIds.split(\" \");\n        StringBuilder sb \u003d new StringBuilder();\n        sb.append(\"FSCK started by \" +\n            UserGroupInformation.getCurrentUser() + \" from \" +\n            remoteAddress + \" at \" + new Date());\n        out.println(sb.toString());\n        sb.append(\" for blockIds: \\n\");\n        for (String blk: blocks) {\n          if(blk \u003d\u003d null || !blk.contains(\"blk_\")) {\n            out.println(\"Incorrect blockId format: \" + blk);\n            continue;\n          }\n          out.print(\"\\n\");\n          blockIdCK(blk);\n          sb.append(blk + \"\\n\");\n        }\n        LOG.info(sb.toString());\n        namenode.getNamesystem().logFsckEvent(\"/\", remoteAddress);\n        out.flush();\n        return;\n      }\n\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      if (snapshottableDirs !\u003d null) {\n        SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n            .getSnapshottableDirListing();\n        if (snapshotDirs !\u003d null) {\n          for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n            snapshottableDirs.add(dir.getFullPath().toString());\n          }\n        }\n      }\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        Result res \u003d new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (Time.now() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (Time.now() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "b6d483b1221296be408df66bc56b37765ce196de": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5568. Support includeSnapshots option with Fsck command. Contributed by Vinay\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1545987 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/13 2:59 AM",
      "commitName": "b6d483b1221296be408df66bc56b37765ce196de",
      "commitAuthor": "Uma Maheswara Rao G",
      "commitDateOld": "21/10/13 5:20 PM",
      "commitNameOld": "df87ed34f2b18b42cfbc8253bd28431063654e19",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 36.44,
      "commitsBetweenForRepo": 192,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,69 @@\n   public void fsck() {\n     final long startTime \u003d Time.now();\n     try {\n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n+      if (snapshottableDirs !\u003d null) {\n+        SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n+            .getSnapshottableDirListing();\n+        if (snapshotDirs !\u003d null) {\n+          for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n+            snapshottableDirs.add(dir.getFullPath().toString());\n+          }\n+        }\n+      }\n+\n       final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n         \n         Result res \u003d new Result(conf);\n \n         check(path, file, res);\n \n         out.println(res);\n         out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n \n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n             + (Time.now() - startTime + \" milliseconds\"));\n \n         // If there were internal errors during the fsck operation, we want to\n         // return FAILURE_STATUS, even if those errors were not immediately\n         // fatal.  Otherwise many unit tests will pass even when there are bugs.\n         if (internalError) {\n           throw new IOException(\"fsck encountered internal errors!\");\n         }\n \n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line \n         // of the report.\n         if (res.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n           + (Time.now() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d Time.now();\n    try {\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      if (snapshottableDirs !\u003d null) {\n        SnapshottableDirectoryStatus[] snapshotDirs \u003d namenode.getRpcServer()\n            .getSnapshottableDirListing();\n        if (snapshotDirs !\u003d null) {\n          for (SnapshottableDirectoryStatus dir : snapshotDirs) {\n            snapshottableDirs.add(dir.getFullPath().toString());\n          }\n        }\n      }\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        Result res \u003d new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (Time.now() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (Time.now() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "4a5ba3b7bd2360fd9605863630b477d362874e1e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3641. Move server Util time methods to common and use now instead of System#currentTimeMillis. Contributed by Eli Collins\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1360858 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 12:01 PM",
      "commitName": "4a5ba3b7bd2360fd9605863630b477d362874e1e",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "08/07/12 12:41 PM",
      "commitNameOld": "21fdf16b0d866dfd9eef22515be5da5f1cd9ac59",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 3.97,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   public void fsck() {\n-    final long startTime \u003d System.currentTimeMillis();\n+    final long startTime \u003d Time.now();\n     try {\n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n       final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n         \n         Result res \u003d new Result(conf);\n \n         check(path, file, res);\n \n         out.println(res);\n         out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n \n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n-            + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n+            + (Time.now() - startTime + \" milliseconds\"));\n \n         // If there were internal errors during the fsck operation, we want to\n         // return FAILURE_STATUS, even if those errors were not immediately\n         // fatal.  Otherwise many unit tests will pass even when there are bugs.\n         if (internalError) {\n           throw new IOException(\"fsck encountered internal errors!\");\n         }\n \n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line \n         // of the report.\n         if (res.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n-          + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n+          + (Time.now() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d Time.now();\n    try {\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        Result res \u003d new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (Time.now() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (Time.now() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "21fdf16b0d866dfd9eef22515be5da5f1cd9ac59": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3548. NamenodeFsck.copyBlock fails to create a Block Reader. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1358822 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/07/12 12:41 PM",
      "commitName": "21fdf16b0d866dfd9eef22515be5da5f1cd9ac59",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "11/06/12 6:55 PM",
      "commitNameOld": "543f86631bf07053a045d5dabcad16fb8f9eff97",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 26.74,
      "commitsBetweenForRepo": 119,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,59 @@\n   public void fsck() {\n     final long startTime \u003d System.currentTimeMillis();\n     try {\n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n       final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n         \n         Result res \u003d new Result(conf);\n \n         check(path, file, res);\n \n         out.println(res);\n         out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n \n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n             + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n \n+        // If there were internal errors during the fsck operation, we want to\n+        // return FAILURE_STATUS, even if those errors were not immediately\n+        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n+        if (internalError) {\n+          throw new IOException(\"fsck encountered internal errors!\");\n+        }\n+\n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line \n         // of the report.\n         if (res.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n           + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d System.currentTimeMillis();\n    try {\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        Result res \u003d new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n\n        // If there were internal errors during the fsck operation, we want to\n        // return FAILURE_STATUS, even if those errors were not immediately\n        // fatal.  Otherwise many unit tests will pass even when there are bugs.\n        if (internalError) {\n          throw new IOException(\"fsck encountered internal errors!\");\n        }\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "b0632df93ae5d00180b21983d960d50a45f8fb7a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2197. Refactor RPC call implementations out of NameNode class. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165463 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "05/09/11 5:41 PM",
      "commitName": "b0632df93ae5d00180b21983d960d50a45f8fb7a",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "04/09/11 12:30 PM",
      "commitNameOld": "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 1.22,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,52 @@\n   public void fsck() {\n     final long startTime \u003d System.currentTimeMillis();\n     try {\n       String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n           + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n       LOG.info(msg);\n       out.println(msg);\n       namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n \n-      final HdfsFileStatus file \u003d namenode.getFileInfo(path);\n+      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n       if (file !\u003d null) {\n \n         if (showCorruptFileBlocks) {\n           listCorruptFileBlocks();\n           return;\n         }\n         \n         Result res \u003d new Result(conf);\n \n         check(path, file, res);\n \n         out.println(res);\n         out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n         out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n \n         out.println(\"FSCK ended at \" + new Date() + \" in \"\n             + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n \n         // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n         // of file system and return appropriate code. Changing the output\n         // string might break testcases. Also note this must be the last line \n         // of the report.\n         if (res.isHealthy()) {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n         } else {\n           out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n         }\n \n       } else {\n         out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n       }\n     } catch (Exception e) {\n       String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n       LOG.warn(errMsg, e);\n       out.println(\"FSCK ended at \" + new Date() + \" in \"\n           + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n       out.println(e.getMessage());\n       out.print(\"\\n\\n\" + errMsg);\n     } finally {\n       out.close();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d System.currentTimeMillis();\n    try {\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      final HdfsFileStatus file \u003d namenode.getRpcServer().getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        Result res \u003d new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d System.currentTimeMillis();\n    try {\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      final HdfsFileStatus file \u003d namenode.getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        Result res \u003d new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d System.currentTimeMillis();\n    try {\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      final HdfsFileStatus file \u003d namenode.getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        Result res \u003d new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java"
      }
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,52 @@\n+  public void fsck() {\n+    final long startTime \u003d System.currentTimeMillis();\n+    try {\n+      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n+          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n+      LOG.info(msg);\n+      out.println(msg);\n+      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n+\n+      final HdfsFileStatus file \u003d namenode.getFileInfo(path);\n+      if (file !\u003d null) {\n+\n+        if (showCorruptFileBlocks) {\n+          listCorruptFileBlocks();\n+          return;\n+        }\n+        \n+        Result res \u003d new Result(conf);\n+\n+        check(path, file, res);\n+\n+        out.println(res);\n+        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n+        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n+\n+        out.println(\"FSCK ended at \" + new Date() + \" in \"\n+            + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n+\n+        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n+        // of file system and return appropriate code. Changing the output\n+        // string might break testcases. Also note this must be the last line \n+        // of the report.\n+        if (res.isHealthy()) {\n+          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n+        } else {\n+          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n+        }\n+\n+      } else {\n+        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n+      }\n+    } catch (Exception e) {\n+      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n+      LOG.warn(errMsg, e);\n+      out.println(\"FSCK ended at \" + new Date() + \" in \"\n+          + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n+      out.println(e.getMessage());\n+      out.print(\"\\n\\n\" + errMsg);\n+    } finally {\n+      out.close();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void fsck() {\n    final long startTime \u003d System.currentTimeMillis();\n    try {\n      String msg \u003d \"FSCK started by \" + UserGroupInformation.getCurrentUser()\n          + \" from \" + remoteAddress + \" for path \" + path + \" at \" + new Date();\n      LOG.info(msg);\n      out.println(msg);\n      namenode.getNamesystem().logFsckEvent(path, remoteAddress);\n\n      final HdfsFileStatus file \u003d namenode.getFileInfo(path);\n      if (file !\u003d null) {\n\n        if (showCorruptFileBlocks) {\n          listCorruptFileBlocks();\n          return;\n        }\n        \n        Result res \u003d new Result(conf);\n\n        check(path, file, res);\n\n        out.println(res);\n        out.println(\" Number of data-nodes:\\t\\t\" + totalDatanodes);\n        out.println(\" Number of racks:\\t\\t\" + networktopology.getNumOfRacks());\n\n        out.println(\"FSCK ended at \" + new Date() + \" in \"\n            + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n\n        // DFSck client scans for the string HEALTHY/CORRUPT to check the status\n        // of file system and return appropriate code. Changing the output\n        // string might break testcases. Also note this must be the last line \n        // of the report.\n        if (res.isHealthy()) {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + HEALTHY_STATUS);\n        } else {\n          out.print(\"\\n\\nThe filesystem under path \u0027\" + path + \"\u0027 \" + CORRUPT_STATUS);\n        }\n\n      } else {\n        out.print(\"\\n\\nPath \u0027\" + path + \"\u0027 \" + NONEXISTENT_STATUS);\n      }\n    } catch (Exception e) {\n      String errMsg \u003d \"Fsck on path \u0027\" + path + \"\u0027 \" + FAILURE_STATUS;\n      LOG.warn(errMsg, e);\n      out.println(\"FSCK ended at \" + new Date() + \" in \"\n          + (System.currentTimeMillis() - startTime + \" milliseconds\"));\n      out.println(e.getMessage());\n      out.print(\"\\n\\n\" + errMsg);\n    } finally {\n      out.close();\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/NamenodeFsck.java"
    }
  }
}