{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "WriteManager.java",
  "functionName": "handleCommit",
  "functionId": "handleCommit___dfsClient-DFSClient__fileHandle-FileHandle__commitOffset-long__channel-Channel__xid-int__preOpAttr-Nfs3FileAttributes__namenodeId-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
  "functionStartLine": 268,
  "functionEndLine": 323,
  "numCommitsSeen": 45,
  "timeTaken": 3428,
  "changeHistory": [
    "d6602b5f39833611b4afa4581552f6c4c37e23a8",
    "f37849188b05a6251584de1aed5e66d5dfa7da4f",
    "f6f2a3f1c73266bfedd802eacde60d8b19b81015",
    "b6f9d5538cf2b425652687e99503f3d566b2056a",
    "875aa797caee96572162ff59bc50cf97d1195348",
    "3bfd18c6b0483ae27eff6d53bda934e67dda5464",
    "5ea533c2bfc72fd3adbfd972d18806fbc397e0f8",
    "3fccdec6e0a8e9305fc75921211c3745eddb9c45",
    "a9befa6f0a8a27b49b1e6483e749661f493f06cf",
    "5c02d2f6225144772dcb975d3144b057b71d6476",
    "28e3d09230971b32f74284311931525cb7ad1b7c",
    "37f587563a943a827fbff865f5302bac6d202415"
  ],
  "changeHistoryShort": {
    "d6602b5f39833611b4afa4581552f6c4c37e23a8": "Ymultichange(Yparameterchange,Ybodychange)",
    "f37849188b05a6251584de1aed5e66d5dfa7da4f": "Ybodychange",
    "f6f2a3f1c73266bfedd802eacde60d8b19b81015": "Ybodychange",
    "b6f9d5538cf2b425652687e99503f3d566b2056a": "Ybodychange",
    "875aa797caee96572162ff59bc50cf97d1195348": "Ybodychange",
    "3bfd18c6b0483ae27eff6d53bda934e67dda5464": "Ybodychange",
    "5ea533c2bfc72fd3adbfd972d18806fbc397e0f8": "Ybodychange",
    "3fccdec6e0a8e9305fc75921211c3745eddb9c45": "Ybodychange",
    "a9befa6f0a8a27b49b1e6483e749661f493f06cf": "Ybodychange",
    "5c02d2f6225144772dcb975d3144b057b71d6476": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "28e3d09230971b32f74284311931525cb7ad1b7c": "Ybodychange",
    "37f587563a943a827fbff865f5302bac6d202415": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d6602b5f39833611b4afa4581552f6c4c37e23a8": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-11575. Supporting HDFS NFS gateway with Federated HDFS. Contributed by Mukul Kumar Singh.\n",
      "commitDate": "10/10/17 10:38 AM",
      "commitName": "d6602b5f39833611b4afa4581552f6c4c37e23a8",
      "commitAuthor": "Jitendra Pandey",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-11575. Supporting HDFS NFS gateway with Federated HDFS. Contributed by Mukul Kumar Singh.\n",
          "commitDate": "10/10/17 10:38 AM",
          "commitName": "d6602b5f39833611b4afa4581552f6c4c37e23a8",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "28/01/15 12:56 PM",
          "commitNameOld": "f37849188b05a6251584de1aed5e66d5dfa7da4f",
          "commitAuthorOld": "yliu",
          "daysBetweenCommits": 985.86,
          "commitsBetweenForRepo": 7119,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,56 @@\n   void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n-      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n+      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr,\n+      int namenodeId) {\n     long startTime \u003d System.nanoTime();\n     int status;\n     OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n-      LOG.info(\"No opened stream for fileId: \" + fileHandle.getFileId()\n+      LOG.info(\"No opened stream for fileId: \" + fileHandle.dumpFileHandle()\n           + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n       status \u003d Nfs3Status.NFS3_OK;\n       \n     } else {\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           channel, xid, preOpAttr, false);\n       switch (ret) {\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n         // Do nothing. Commit is async now.\n         return;\n       case COMMIT_SPECIAL_WAIT:\n         status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n         break;\n       case COMMIT_SPECIAL_SUCCESS:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       default:\n         LOG.error(\"Should not get commit return code: \" + ret.name());\n         throw new RuntimeException(\"Should not get commit return code: \"\n             + ret.name());\n       }\n     }\n     \n     // Send out the response\n     Nfs3FileAttributes postOpAttr \u003d null;\n     try {\n-      postOpAttr \u003d getFileAttr(dfsClient, new FileHandle(preOpAttr.getFileId()), iug);\n+      postOpAttr \u003d\n+          getFileAttr(dfsClient, new FileHandle(preOpAttr.getFileId(),\n+              namenodeId), iug);\n     } catch (IOException e1) {\n       LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n     }\n     WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n     COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n         Nfs3Constant.WRITE_COMMIT_VERF);\n     RpcProgramNfs3.metrics.addCommit(Nfs3Utils.getElapsedTime(startTime));\n     Nfs3Utils.writeChannelCommit(channel,\n         response.serialize(new XDR(), xid, new VerifierNone()), xid);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr,\n      int namenodeId) {\n    long startTime \u003d System.nanoTime();\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId: \" + fileHandle.dumpFileHandle()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr, false);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      case COMMIT_SPECIAL_WAIT:\n        status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n        break;\n      case COMMIT_SPECIAL_SUCCESS:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      default:\n        LOG.error(\"Should not get commit return code: \" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code: \"\n            + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      postOpAttr \u003d\n          getFileAttr(dfsClient, new FileHandle(preOpAttr.getFileId(),\n              namenodeId), iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    RpcProgramNfs3.metrics.addCommit(Nfs3Utils.getElapsedTime(startTime));\n    Nfs3Utils.writeChannelCommit(channel,\n        response.serialize(new XDR(), xid, new VerifierNone()), xid);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
          "extendedDetails": {
            "oldValue": "[dfsClient-DFSClient, fileHandle-FileHandle, commitOffset-long, channel-Channel, xid-int, preOpAttr-Nfs3FileAttributes]",
            "newValue": "[dfsClient-DFSClient, fileHandle-FileHandle, commitOffset-long, channel-Channel, xid-int, preOpAttr-Nfs3FileAttributes, namenodeId-int]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-11575. Supporting HDFS NFS gateway with Federated HDFS. Contributed by Mukul Kumar Singh.\n",
          "commitDate": "10/10/17 10:38 AM",
          "commitName": "d6602b5f39833611b4afa4581552f6c4c37e23a8",
          "commitAuthor": "Jitendra Pandey",
          "commitDateOld": "28/01/15 12:56 PM",
          "commitNameOld": "f37849188b05a6251584de1aed5e66d5dfa7da4f",
          "commitAuthorOld": "yliu",
          "daysBetweenCommits": 985.86,
          "commitsBetweenForRepo": 7119,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,53 +1,56 @@\n   void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n-      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n+      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr,\n+      int namenodeId) {\n     long startTime \u003d System.nanoTime();\n     int status;\n     OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n-      LOG.info(\"No opened stream for fileId: \" + fileHandle.getFileId()\n+      LOG.info(\"No opened stream for fileId: \" + fileHandle.dumpFileHandle()\n           + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n       status \u003d Nfs3Status.NFS3_OK;\n       \n     } else {\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           channel, xid, preOpAttr, false);\n       switch (ret) {\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n         // Do nothing. Commit is async now.\n         return;\n       case COMMIT_SPECIAL_WAIT:\n         status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n         break;\n       case COMMIT_SPECIAL_SUCCESS:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       default:\n         LOG.error(\"Should not get commit return code: \" + ret.name());\n         throw new RuntimeException(\"Should not get commit return code: \"\n             + ret.name());\n       }\n     }\n     \n     // Send out the response\n     Nfs3FileAttributes postOpAttr \u003d null;\n     try {\n-      postOpAttr \u003d getFileAttr(dfsClient, new FileHandle(preOpAttr.getFileId()), iug);\n+      postOpAttr \u003d\n+          getFileAttr(dfsClient, new FileHandle(preOpAttr.getFileId(),\n+              namenodeId), iug);\n     } catch (IOException e1) {\n       LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n     }\n     WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n     COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n         Nfs3Constant.WRITE_COMMIT_VERF);\n     RpcProgramNfs3.metrics.addCommit(Nfs3Utils.getElapsedTime(startTime));\n     Nfs3Utils.writeChannelCommit(channel,\n         response.serialize(new XDR(), xid, new VerifierNone()), xid);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr,\n      int namenodeId) {\n    long startTime \u003d System.nanoTime();\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId: \" + fileHandle.dumpFileHandle()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr, false);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      case COMMIT_SPECIAL_WAIT:\n        status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n        break;\n      case COMMIT_SPECIAL_SUCCESS:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      default:\n        LOG.error(\"Should not get commit return code: \" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code: \"\n            + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      postOpAttr \u003d\n          getFileAttr(dfsClient, new FileHandle(preOpAttr.getFileId(),\n              namenodeId), iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    RpcProgramNfs3.metrics.addCommit(Nfs3Utils.getElapsedTime(startTime));\n    Nfs3Utils.writeChannelCommit(channel,\n        response.serialize(new XDR(), xid, new VerifierNone()), xid);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "f37849188b05a6251584de1aed5e66d5dfa7da4f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7423. various typos and message formatting fixes in nfs daemon and doc. (Charles Lamb via yliu)\n",
      "commitDate": "28/01/15 12:56 PM",
      "commitName": "f37849188b05a6251584de1aed5e66d5dfa7da4f",
      "commitAuthor": "yliu",
      "commitDateOld": "27/01/15 12:58 PM",
      "commitNameOld": "2848db814a98b83e7546f65a2751e56fb5b2dbe0",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 1.0,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n       long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n     long startTime \u003d System.nanoTime();\n     int status;\n     OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n-      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n+      LOG.info(\"No opened stream for fileId: \" + fileHandle.getFileId()\n           + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n       status \u003d Nfs3Status.NFS3_OK;\n       \n     } else {\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           channel, xid, preOpAttr, false);\n       switch (ret) {\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n         // Do nothing. Commit is async now.\n         return;\n       case COMMIT_SPECIAL_WAIT:\n         status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n         break;\n       case COMMIT_SPECIAL_SUCCESS:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       default:\n-        LOG.error(\"Should not get commit return code:\" + ret.name());\n-        throw new RuntimeException(\"Should not get commit return code:\"\n+        LOG.error(\"Should not get commit return code: \" + ret.name());\n+        throw new RuntimeException(\"Should not get commit return code: \"\n             + ret.name());\n       }\n     }\n     \n     // Send out the response\n     Nfs3FileAttributes postOpAttr \u003d null;\n     try {\n       postOpAttr \u003d getFileAttr(dfsClient, new FileHandle(preOpAttr.getFileId()), iug);\n     } catch (IOException e1) {\n       LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n     }\n     WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n     COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n         Nfs3Constant.WRITE_COMMIT_VERF);\n     RpcProgramNfs3.metrics.addCommit(Nfs3Utils.getElapsedTime(startTime));\n     Nfs3Utils.writeChannelCommit(channel,\n         response.serialize(new XDR(), xid, new VerifierNone()), xid);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n    long startTime \u003d System.nanoTime();\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId: \" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr, false);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      case COMMIT_SPECIAL_WAIT:\n        status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n        break;\n      case COMMIT_SPECIAL_SUCCESS:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      default:\n        LOG.error(\"Should not get commit return code: \" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code: \"\n            + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      postOpAttr \u003d getFileAttr(dfsClient, new FileHandle(preOpAttr.getFileId()), iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    RpcProgramNfs3.metrics.addCommit(Nfs3Utils.getElapsedTime(startTime));\n    Nfs3Utils.writeChannelCommit(channel,\n        response.serialize(new XDR(), xid, new VerifierNone()), xid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "f6f2a3f1c73266bfedd802eacde60d8b19b81015": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7449. Add metrics to NFS gateway. Contributed by Brandon Li\n",
      "commitDate": "11/12/14 3:40 PM",
      "commitName": "f6f2a3f1c73266bfedd802eacde60d8b19b81015",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "29/10/14 11:05 AM",
      "commitNameOld": "72a556d3b0def0ab4e4509528cc513f6df06b084",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 43.23,
      "commitsBetweenForRepo": 356,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,52 +1,53 @@\n   void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n       long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n+    long startTime \u003d System.nanoTime();\n     int status;\n     OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n       LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n           + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n       status \u003d Nfs3Status.NFS3_OK;\n       \n     } else {\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           channel, xid, preOpAttr, false);\n       switch (ret) {\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n         // Do nothing. Commit is async now.\n         return;\n       case COMMIT_SPECIAL_WAIT:\n         status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n         break;\n       case COMMIT_SPECIAL_SUCCESS:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       default:\n         LOG.error(\"Should not get commit return code:\" + ret.name());\n         throw new RuntimeException(\"Should not get commit return code:\"\n             + ret.name());\n       }\n     }\n     \n     // Send out the response\n     Nfs3FileAttributes postOpAttr \u003d null;\n     try {\n       postOpAttr \u003d getFileAttr(dfsClient, new FileHandle(preOpAttr.getFileId()), iug);\n     } catch (IOException e1) {\n       LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n     }\n     WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n     COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n         Nfs3Constant.WRITE_COMMIT_VERF);\n+    RpcProgramNfs3.metrics.addCommit(Nfs3Utils.getElapsedTime(startTime));\n     Nfs3Utils.writeChannelCommit(channel,\n-        response.serialize(new XDR(), xid, new VerifierNone()),\n-        xid);\n+        response.serialize(new XDR(), xid, new VerifierNone()), xid);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n    long startTime \u003d System.nanoTime();\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr, false);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      case COMMIT_SPECIAL_WAIT:\n        status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n        break;\n      case COMMIT_SPECIAL_SUCCESS:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      default:\n        LOG.error(\"Should not get commit return code:\" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code:\"\n            + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      postOpAttr \u003d getFileAttr(dfsClient, new FileHandle(preOpAttr.getFileId()), iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    RpcProgramNfs3.metrics.addCommit(Nfs3Utils.getElapsedTime(startTime));\n    Nfs3Utils.writeChannelCommit(channel,\n        response.serialize(new XDR(), xid, new VerifierNone()), xid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "b6f9d5538cf2b425652687e99503f3d566b2056a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7259. Unresponseive NFS mount point due to deferred COMMIT response. Contributed by Brandon Li\n",
      "commitDate": "21/10/14 10:20 AM",
      "commitName": "b6f9d5538cf2b425652687e99503f3d566b2056a",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "01/10/14 1:18 PM",
      "commitNameOld": "875aa797caee96572162ff59bc50cf97d1195348",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 19.88,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,52 @@\n   void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n       long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n     int status;\n     OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n       LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n           + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n       status \u003d Nfs3Status.NFS3_OK;\n       \n     } else {\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           channel, xid, preOpAttr, false);\n       switch (ret) {\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n         // Do nothing. Commit is async now.\n         return;\n+      case COMMIT_SPECIAL_WAIT:\n+        status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n+        break;\n+      case COMMIT_SPECIAL_SUCCESS:\n+        status \u003d Nfs3Status.NFS3_OK;\n+        break;\n       default:\n         LOG.error(\"Should not get commit return code:\" + ret.name());\n         throw new RuntimeException(\"Should not get commit return code:\"\n             + ret.name());\n       }\n     }\n     \n     // Send out the response\n     Nfs3FileAttributes postOpAttr \u003d null;\n     try {\n-      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileId());\n-      postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n+      postOpAttr \u003d getFileAttr(dfsClient, new FileHandle(preOpAttr.getFileId()), iug);\n     } catch (IOException e1) {\n       LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n     }\n     WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n     COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n         Nfs3Constant.WRITE_COMMIT_VERF);\n     Nfs3Utils.writeChannelCommit(channel,\n         response.serialize(new XDR(), xid, new VerifierNone()),\n         xid);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr, false);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      case COMMIT_SPECIAL_WAIT:\n        status \u003d Nfs3Status.NFS3ERR_JUKEBOX;\n        break;\n      case COMMIT_SPECIAL_SUCCESS:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      default:\n        LOG.error(\"Should not get commit return code:\" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code:\"\n            + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      postOpAttr \u003d getFileAttr(dfsClient, new FileHandle(preOpAttr.getFileId()), iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    Nfs3Utils.writeChannelCommit(channel,\n        response.serialize(new XDR(), xid, new VerifierNone()),\n        xid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "875aa797caee96572162ff59bc50cf97d1195348": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6894. Add XDR parser method for each NFS response. Contributed by Brandon Li.\n",
      "commitDate": "01/10/14 1:18 PM",
      "commitName": "875aa797caee96572162ff59bc50cf97d1195348",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "19/06/14 12:39 PM",
      "commitNameOld": "9ff3836a367737d6dfcb12f50c8bd2f1b2233e37",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 104.03,
      "commitsBetweenForRepo": 982,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n       long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n     int status;\n     OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n       LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n           + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n       status \u003d Nfs3Status.NFS3_OK;\n       \n     } else {\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           channel, xid, preOpAttr, false);\n       switch (ret) {\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n         // Do nothing. Commit is async now.\n         return;\n       default:\n         LOG.error(\"Should not get commit return code:\" + ret.name());\n         throw new RuntimeException(\"Should not get commit return code:\"\n             + ret.name());\n       }\n     }\n     \n     // Send out the response\n     Nfs3FileAttributes postOpAttr \u003d null;\n     try {\n       String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileId());\n       postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n     } catch (IOException e1) {\n       LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n     }\n     WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n     COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n         Nfs3Constant.WRITE_COMMIT_VERF);\n     Nfs3Utils.writeChannelCommit(channel,\n-        response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n+        response.serialize(new XDR(), xid, new VerifierNone()),\n         xid);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr, false);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      default:\n        LOG.error(\"Should not get commit return code:\" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code:\"\n            + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileId());\n      postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    Nfs3Utils.writeChannelCommit(channel,\n        response.serialize(new XDR(), xid, new VerifierNone()),\n        xid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "3bfd18c6b0483ae27eff6d53bda934e67dda5464": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6050. NFS does not handle exceptions correctly in a few places. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1581055 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/03/14 1:49 PM",
      "commitName": "3bfd18c6b0483ae27eff6d53bda934e67dda5464",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "27/11/13 3:41 PM",
      "commitNameOld": "5ea533c2bfc72fd3adbfd972d18806fbc397e0f8",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 116.88,
      "commitsBetweenForRepo": 832,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n       long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n     int status;\n     OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n       LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n           + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n       status \u003d Nfs3Status.NFS3_OK;\n       \n     } else {\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           channel, xid, preOpAttr, false);\n       switch (ret) {\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n         // Do nothing. Commit is async now.\n         return;\n       default:\n         LOG.error(\"Should not get commit return code:\" + ret.name());\n         throw new RuntimeException(\"Should not get commit return code:\"\n             + ret.name());\n       }\n     }\n     \n     // Send out the response\n     Nfs3FileAttributes postOpAttr \u003d null;\n     try {\n-      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n+      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileId());\n       postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n     } catch (IOException e1) {\n-      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n+      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n     }\n     WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n     COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n         Nfs3Constant.WRITE_COMMIT_VERF);\n     Nfs3Utils.writeChannelCommit(channel,\n         response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n         xid);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr, false);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      default:\n        LOG.error(\"Should not get commit return code:\" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code:\"\n            + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileId());\n      postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileId(), e1);\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    Nfs3Utils.writeChannelCommit(channel,\n        response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n        xid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "5ea533c2bfc72fd3adbfd972d18806fbc397e0f8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5563. NFS gateway should commit the buffered data when read request comes after write to the same file. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1546233 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/11/13 3:41 PM",
      "commitName": "5ea533c2bfc72fd3adbfd972d18806fbc397e0f8",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "07/11/13 1:49 PM",
      "commitNameOld": "3fccdec6e0a8e9305fc75921211c3745eddb9c45",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 20.08,
      "commitsBetweenForRepo": 128,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n       long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n     int status;\n     OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n       LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n           + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n       status \u003d Nfs3Status.NFS3_OK;\n       \n     } else {\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n-          channel, xid, preOpAttr);\n+          channel, xid, preOpAttr, false);\n       switch (ret) {\n-      case COMMIT_DO_SYNC:\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n         // Do nothing. Commit is async now.\n         return;\n       default:\n+        LOG.error(\"Should not get commit return code:\" + ret.name());\n         throw new RuntimeException(\"Should not get commit return code:\"\n             + ret.name());\n       }\n     }\n     \n     // Send out the response\n     Nfs3FileAttributes postOpAttr \u003d null;\n     try {\n       String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n       postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n     } catch (IOException e1) {\n       LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n     }\n     WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n     COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n         Nfs3Constant.WRITE_COMMIT_VERF);\n     Nfs3Utils.writeChannelCommit(channel,\n         response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n         xid);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr, false);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      default:\n        LOG.error(\"Should not get commit return code:\" + ret.name());\n        throw new RuntimeException(\"Should not get commit return code:\"\n            + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n      postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    Nfs3Utils.writeChannelCommit(channel,\n        response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n        xid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "3fccdec6e0a8e9305fc75921211c3745eddb9c45": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5364. Add OpenFileCtx cache. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1539834 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/11/13 1:49 PM",
      "commitName": "3fccdec6e0a8e9305fc75921211c3745eddb9c45",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "07/11/13 10:02 AM",
      "commitNameOld": "16c6755554cc5ecd9d4e0ba74b75b10c74bb0ab4",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 0.16,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n       long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n     int status;\n-    OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n+    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n       LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n           + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n       status \u003d Nfs3Status.NFS3_OK;\n       \n     } else {\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           channel, xid, preOpAttr);\n       switch (ret) {\n       case COMMIT_DO_SYNC:\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n         // Do nothing. Commit is async now.\n         return;\n       default:\n         throw new RuntimeException(\"Should not get commit return code:\"\n             + ret.name());\n       }\n     }\n     \n     // Send out the response\n     Nfs3FileAttributes postOpAttr \u003d null;\n     try {\n       String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n       postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n     } catch (IOException e1) {\n       LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n     }\n     WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n     COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n         Nfs3Constant.WRITE_COMMIT_VERF);\n     Nfs3Utils.writeChannelCommit(channel,\n         response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n         xid);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n    int status;\n    OpenFileCtx openFileCtx \u003d fileContextCache.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr);\n      switch (ret) {\n      case COMMIT_DO_SYNC:\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      default:\n        throw new RuntimeException(\"Should not get commit return code:\"\n            + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n      postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    Nfs3Utils.writeChannelCommit(channel,\n        response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n        xid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "a9befa6f0a8a27b49b1e6483e749661f493f06cf": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5330. fix readdir and readdirplus for large directories. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1532539 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/10/13 2:23 PM",
      "commitName": "a9befa6f0a8a27b49b1e6483e749661f493f06cf",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "08/10/13 4:40 PM",
      "commitNameOld": "5c02d2f6225144772dcb975d3144b057b71d6476",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 6.9,
      "commitsBetweenForRepo": 49,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,47 @@\n   void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n       long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n     int status;\n     OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n \n     if (openFileCtx \u003d\u003d null) {\n       LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n           + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n       status \u003d Nfs3Status.NFS3_OK;\n       \n     } else {\n       COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n           channel, xid, preOpAttr);\n       switch (ret) {\n+      case COMMIT_DO_SYNC:\n       case COMMIT_FINISHED:\n       case COMMIT_INACTIVE_CTX:\n         status \u003d Nfs3Status.NFS3_OK;\n         break;\n       case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n       case COMMIT_ERROR:\n         status \u003d Nfs3Status.NFS3ERR_IO;\n         break;\n       case COMMIT_WAIT:\n         // Do nothing. Commit is async now.\n         return;\n       default:\n-        throw new RuntimeException(\"Wring error code:\" + ret.name());\n+        throw new RuntimeException(\"Should not get commit return code:\"\n+            + ret.name());\n       }\n     }\n     \n     // Send out the response\n     Nfs3FileAttributes postOpAttr \u003d null;\n     try {\n       String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n       postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n     } catch (IOException e1) {\n       LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n     }\n     WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n     COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n         Nfs3Constant.WRITE_COMMIT_VERF);\n     Nfs3Utils.writeChannelCommit(channel,\n         response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n         xid);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n    int status;\n    OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr);\n      switch (ret) {\n      case COMMIT_DO_SYNC:\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      default:\n        throw new RuntimeException(\"Should not get commit return code:\"\n            + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n      postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    Nfs3Utils.writeChannelCommit(channel,\n        response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n        xid);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "5c02d2f6225144772dcb975d3144b057b71d6476": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-5281. COMMIT request should not block. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1530461 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/10/13 4:40 PM",
      "commitName": "5c02d2f6225144772dcb975d3144b057b71d6476",
      "commitAuthor": "Brandon Li",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5281. COMMIT request should not block. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1530461 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/10/13 4:40 PM",
          "commitName": "5c02d2f6225144772dcb975d3144b057b71d6476",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "23/09/13 1:02 PM",
          "commitNameOld": "28e3d09230971b32f74284311931525cb7ad1b7c",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 15.15,
          "commitsBetweenForRepo": 122,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,45 @@\n-  boolean handleCommit(FileHandle fileHandle, long commitOffset) {\n+  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n+      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n+    int status;\n     OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n+\n     if (openFileCtx \u003d\u003d null) {\n       LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n-          + \" commitOffset\u003d\" + commitOffset);\n-      return true;\n-    }\n-    long timeout \u003d 30 * 1000; // 30 seconds\n-    long startCommit \u003d System.currentTimeMillis();\n-    while (true) {\n-      int ret \u003d openFileCtx.checkCommit(commitOffset);\n-      if (ret \u003d\u003d OpenFileCtx.COMMIT_FINISHED) {\n-        // Committed\n-        return true;\n-      } else if (ret \u003d\u003d OpenFileCtx.COMMIT_INACTIVE_CTX) {\n-        LOG.info(\"Inactive stream, fileId\u003d\" + fileHandle.getFileId()\n-            + \" commitOffset\u003d\" + commitOffset);\n-        return true;\n-      } else if (ret \u003d\u003d OpenFileCtx.COMMIT_INACTIVE_WITH_PENDING_WRITE) {\n-        LOG.info(\"Inactive stream with pending writes, fileId\u003d\"\n-            + fileHandle.getFileId() + \" commitOffset\u003d\" + commitOffset);\n-        return false;\n-      }\n-      assert (ret \u003d\u003d OpenFileCtx.COMMIT_WAIT || ret \u003d\u003d OpenFileCtx.COMMIT_ERROR);\n-      if (ret \u003d\u003d OpenFileCtx.COMMIT_ERROR) {\n-        return false;\n-      }\n+          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n+      status \u003d Nfs3Status.NFS3_OK;\n       \n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Not committed yet, wait., fileId\u003d\" + fileHandle.getFileId()\n-            + \" commitOffset\u003d\" + commitOffset);\n+    } else {\n+      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n+          channel, xid, preOpAttr);\n+      switch (ret) {\n+      case COMMIT_FINISHED:\n+      case COMMIT_INACTIVE_CTX:\n+        status \u003d Nfs3Status.NFS3_OK;\n+        break;\n+      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n+      case COMMIT_ERROR:\n+        status \u003d Nfs3Status.NFS3ERR_IO;\n+        break;\n+      case COMMIT_WAIT:\n+        // Do nothing. Commit is async now.\n+        return;\n+      default:\n+        throw new RuntimeException(\"Wring error code:\" + ret.name());\n       }\n-      if (System.currentTimeMillis() - startCommit \u003e timeout) {\n-        // Commit took too long, return error\n-        return false;\n-      }\n-      try {\n-        Thread.sleep(100);\n-      } catch (InterruptedException e) {\n-        LOG.info(\"Commit is interrupted, fileId\u003d\" + fileHandle.getFileId()\n-            + \" commitOffset\u003d\" + commitOffset);\n-        return false;\n-      }\n-    }// while\n+    }\n+    \n+    // Send out the response\n+    Nfs3FileAttributes postOpAttr \u003d null;\n+    try {\n+      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n+      postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n+    } catch (IOException e1) {\n+      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n+    }\n+    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n+    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n+        Nfs3Constant.WRITE_COMMIT_VERF);\n+    Nfs3Utils.writeChannelCommit(channel,\n+        response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n+        xid);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n    int status;\n    OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      default:\n        throw new RuntimeException(\"Wring error code:\" + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n      postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    Nfs3Utils.writeChannelCommit(channel,\n        response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n        xid);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
          "extendedDetails": {
            "oldValue": "[fileHandle-FileHandle, commitOffset-long]",
            "newValue": "[dfsClient-DFSClient, fileHandle-FileHandle, commitOffset-long, channel-Channel, xid-int, preOpAttr-Nfs3FileAttributes]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5281. COMMIT request should not block. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1530461 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/10/13 4:40 PM",
          "commitName": "5c02d2f6225144772dcb975d3144b057b71d6476",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "23/09/13 1:02 PM",
          "commitNameOld": "28e3d09230971b32f74284311931525cb7ad1b7c",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 15.15,
          "commitsBetweenForRepo": 122,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,45 @@\n-  boolean handleCommit(FileHandle fileHandle, long commitOffset) {\n+  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n+      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n+    int status;\n     OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n+\n     if (openFileCtx \u003d\u003d null) {\n       LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n-          + \" commitOffset\u003d\" + commitOffset);\n-      return true;\n-    }\n-    long timeout \u003d 30 * 1000; // 30 seconds\n-    long startCommit \u003d System.currentTimeMillis();\n-    while (true) {\n-      int ret \u003d openFileCtx.checkCommit(commitOffset);\n-      if (ret \u003d\u003d OpenFileCtx.COMMIT_FINISHED) {\n-        // Committed\n-        return true;\n-      } else if (ret \u003d\u003d OpenFileCtx.COMMIT_INACTIVE_CTX) {\n-        LOG.info(\"Inactive stream, fileId\u003d\" + fileHandle.getFileId()\n-            + \" commitOffset\u003d\" + commitOffset);\n-        return true;\n-      } else if (ret \u003d\u003d OpenFileCtx.COMMIT_INACTIVE_WITH_PENDING_WRITE) {\n-        LOG.info(\"Inactive stream with pending writes, fileId\u003d\"\n-            + fileHandle.getFileId() + \" commitOffset\u003d\" + commitOffset);\n-        return false;\n-      }\n-      assert (ret \u003d\u003d OpenFileCtx.COMMIT_WAIT || ret \u003d\u003d OpenFileCtx.COMMIT_ERROR);\n-      if (ret \u003d\u003d OpenFileCtx.COMMIT_ERROR) {\n-        return false;\n-      }\n+          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n+      status \u003d Nfs3Status.NFS3_OK;\n       \n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Not committed yet, wait., fileId\u003d\" + fileHandle.getFileId()\n-            + \" commitOffset\u003d\" + commitOffset);\n+    } else {\n+      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n+          channel, xid, preOpAttr);\n+      switch (ret) {\n+      case COMMIT_FINISHED:\n+      case COMMIT_INACTIVE_CTX:\n+        status \u003d Nfs3Status.NFS3_OK;\n+        break;\n+      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n+      case COMMIT_ERROR:\n+        status \u003d Nfs3Status.NFS3ERR_IO;\n+        break;\n+      case COMMIT_WAIT:\n+        // Do nothing. Commit is async now.\n+        return;\n+      default:\n+        throw new RuntimeException(\"Wring error code:\" + ret.name());\n       }\n-      if (System.currentTimeMillis() - startCommit \u003e timeout) {\n-        // Commit took too long, return error\n-        return false;\n-      }\n-      try {\n-        Thread.sleep(100);\n-      } catch (InterruptedException e) {\n-        LOG.info(\"Commit is interrupted, fileId\u003d\" + fileHandle.getFileId()\n-            + \" commitOffset\u003d\" + commitOffset);\n-        return false;\n-      }\n-    }// while\n+    }\n+    \n+    // Send out the response\n+    Nfs3FileAttributes postOpAttr \u003d null;\n+    try {\n+      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n+      postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n+    } catch (IOException e1) {\n+      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n+    }\n+    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n+    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n+        Nfs3Constant.WRITE_COMMIT_VERF);\n+    Nfs3Utils.writeChannelCommit(channel,\n+        response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n+        xid);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n    int status;\n    OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      default:\n        throw new RuntimeException(\"Wring error code:\" + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n      postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    Nfs3Utils.writeChannelCommit(channel,\n        response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n        xid);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
          "extendedDetails": {
            "oldValue": "boolean",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5281. COMMIT request should not block. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1530461 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/10/13 4:40 PM",
          "commitName": "5c02d2f6225144772dcb975d3144b057b71d6476",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "23/09/13 1:02 PM",
          "commitNameOld": "28e3d09230971b32f74284311931525cb7ad1b7c",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 15.15,
          "commitsBetweenForRepo": 122,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,45 +1,45 @@\n-  boolean handleCommit(FileHandle fileHandle, long commitOffset) {\n+  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n+      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n+    int status;\n     OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n+\n     if (openFileCtx \u003d\u003d null) {\n       LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n-          + \" commitOffset\u003d\" + commitOffset);\n-      return true;\n-    }\n-    long timeout \u003d 30 * 1000; // 30 seconds\n-    long startCommit \u003d System.currentTimeMillis();\n-    while (true) {\n-      int ret \u003d openFileCtx.checkCommit(commitOffset);\n-      if (ret \u003d\u003d OpenFileCtx.COMMIT_FINISHED) {\n-        // Committed\n-        return true;\n-      } else if (ret \u003d\u003d OpenFileCtx.COMMIT_INACTIVE_CTX) {\n-        LOG.info(\"Inactive stream, fileId\u003d\" + fileHandle.getFileId()\n-            + \" commitOffset\u003d\" + commitOffset);\n-        return true;\n-      } else if (ret \u003d\u003d OpenFileCtx.COMMIT_INACTIVE_WITH_PENDING_WRITE) {\n-        LOG.info(\"Inactive stream with pending writes, fileId\u003d\"\n-            + fileHandle.getFileId() + \" commitOffset\u003d\" + commitOffset);\n-        return false;\n-      }\n-      assert (ret \u003d\u003d OpenFileCtx.COMMIT_WAIT || ret \u003d\u003d OpenFileCtx.COMMIT_ERROR);\n-      if (ret \u003d\u003d OpenFileCtx.COMMIT_ERROR) {\n-        return false;\n-      }\n+          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n+      status \u003d Nfs3Status.NFS3_OK;\n       \n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Not committed yet, wait., fileId\u003d\" + fileHandle.getFileId()\n-            + \" commitOffset\u003d\" + commitOffset);\n+    } else {\n+      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n+          channel, xid, preOpAttr);\n+      switch (ret) {\n+      case COMMIT_FINISHED:\n+      case COMMIT_INACTIVE_CTX:\n+        status \u003d Nfs3Status.NFS3_OK;\n+        break;\n+      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n+      case COMMIT_ERROR:\n+        status \u003d Nfs3Status.NFS3ERR_IO;\n+        break;\n+      case COMMIT_WAIT:\n+        // Do nothing. Commit is async now.\n+        return;\n+      default:\n+        throw new RuntimeException(\"Wring error code:\" + ret.name());\n       }\n-      if (System.currentTimeMillis() - startCommit \u003e timeout) {\n-        // Commit took too long, return error\n-        return false;\n-      }\n-      try {\n-        Thread.sleep(100);\n-      } catch (InterruptedException e) {\n-        LOG.info(\"Commit is interrupted, fileId\u003d\" + fileHandle.getFileId()\n-            + \" commitOffset\u003d\" + commitOffset);\n-        return false;\n-      }\n-    }// while\n+    }\n+    \n+    // Send out the response\n+    Nfs3FileAttributes postOpAttr \u003d null;\n+    try {\n+      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n+      postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n+    } catch (IOException e1) {\n+      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n+    }\n+    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n+    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n+        Nfs3Constant.WRITE_COMMIT_VERF);\n+    Nfs3Utils.writeChannelCommit(channel,\n+        response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n+        xid);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void handleCommit(DFSClient dfsClient, FileHandle fileHandle,\n      long commitOffset, Channel channel, int xid, Nfs3FileAttributes preOpAttr) {\n    int status;\n    OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset + \". Return success in this case.\");\n      status \u003d Nfs3Status.NFS3_OK;\n      \n    } else {\n      COMMIT_STATUS ret \u003d openFileCtx.checkCommit(dfsClient, commitOffset,\n          channel, xid, preOpAttr);\n      switch (ret) {\n      case COMMIT_FINISHED:\n      case COMMIT_INACTIVE_CTX:\n        status \u003d Nfs3Status.NFS3_OK;\n        break;\n      case COMMIT_INACTIVE_WITH_PENDING_WRITE:\n      case COMMIT_ERROR:\n        status \u003d Nfs3Status.NFS3ERR_IO;\n        break;\n      case COMMIT_WAIT:\n        // Do nothing. Commit is async now.\n        return;\n      default:\n        throw new RuntimeException(\"Wring error code:\" + ret.name());\n      }\n    }\n    \n    // Send out the response\n    Nfs3FileAttributes postOpAttr \u003d null;\n    try {\n      String fileIdPath \u003d Nfs3Utils.getFileIdPath(preOpAttr.getFileid());\n      postOpAttr \u003d Nfs3Utils.getFileAttr(dfsClient, fileIdPath, iug);\n    } catch (IOException e1) {\n      LOG.info(\"Can\u0027t get postOpAttr for fileId: \" + preOpAttr.getFileid());\n    }\n    WccData fileWcc \u003d new WccData(Nfs3Utils.getWccAttr(preOpAttr), postOpAttr);\n    COMMIT3Response response \u003d new COMMIT3Response(status, fileWcc,\n        Nfs3Constant.WRITE_COMMIT_VERF);\n    Nfs3Utils.writeChannelCommit(channel,\n        response.writeHeaderAndResponse(new XDR(), xid, new VerifierNone()),\n        xid);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "28e3d09230971b32f74284311931525cb7ad1b7c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4971. Move IO operations out of locking in OpenFileCtx. Contributed by Jing Zhao and Brandon Li.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1525681 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/09/13 1:02 PM",
      "commitName": "28e3d09230971b32f74284311931525cb7ad1b7c",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "17/09/13 11:08 PM",
      "commitNameOld": "5e18410e06dd63113c49029894007e0878312903",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 5.58,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,45 @@\n   boolean handleCommit(FileHandle fileHandle, long commitOffset) {\n     OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n     if (openFileCtx \u003d\u003d null) {\n       LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n           + \" commitOffset\u003d\" + commitOffset);\n       return true;\n     }\n     long timeout \u003d 30 * 1000; // 30 seconds\n     long startCommit \u003d System.currentTimeMillis();\n     while (true) {\n       int ret \u003d openFileCtx.checkCommit(commitOffset);\n       if (ret \u003d\u003d OpenFileCtx.COMMIT_FINISHED) {\n         // Committed\n         return true;\n       } else if (ret \u003d\u003d OpenFileCtx.COMMIT_INACTIVE_CTX) {\n         LOG.info(\"Inactive stream, fileId\u003d\" + fileHandle.getFileId()\n             + \" commitOffset\u003d\" + commitOffset);\n         return true;\n+      } else if (ret \u003d\u003d OpenFileCtx.COMMIT_INACTIVE_WITH_PENDING_WRITE) {\n+        LOG.info(\"Inactive stream with pending writes, fileId\u003d\"\n+            + fileHandle.getFileId() + \" commitOffset\u003d\" + commitOffset);\n+        return false;\n       }\n       assert (ret \u003d\u003d OpenFileCtx.COMMIT_WAIT || ret \u003d\u003d OpenFileCtx.COMMIT_ERROR);\n       if (ret \u003d\u003d OpenFileCtx.COMMIT_ERROR) {\n         return false;\n       }\n       \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Not committed yet, wait., fileId\u003d\" + fileHandle.getFileId()\n             + \" commitOffset\u003d\" + commitOffset);\n       }\n       if (System.currentTimeMillis() - startCommit \u003e timeout) {\n         // Commit took too long, return error\n         return false;\n       }\n       try {\n         Thread.sleep(100);\n       } catch (InterruptedException e) {\n         LOG.info(\"Commit is interrupted, fileId\u003d\" + fileHandle.getFileId()\n             + \" commitOffset\u003d\" + commitOffset);\n         return false;\n       }\n     }// while\n   }\n\\ No newline at end of file\n",
      "actualSource": "  boolean handleCommit(FileHandle fileHandle, long commitOffset) {\n    OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset);\n      return true;\n    }\n    long timeout \u003d 30 * 1000; // 30 seconds\n    long startCommit \u003d System.currentTimeMillis();\n    while (true) {\n      int ret \u003d openFileCtx.checkCommit(commitOffset);\n      if (ret \u003d\u003d OpenFileCtx.COMMIT_FINISHED) {\n        // Committed\n        return true;\n      } else if (ret \u003d\u003d OpenFileCtx.COMMIT_INACTIVE_CTX) {\n        LOG.info(\"Inactive stream, fileId\u003d\" + fileHandle.getFileId()\n            + \" commitOffset\u003d\" + commitOffset);\n        return true;\n      } else if (ret \u003d\u003d OpenFileCtx.COMMIT_INACTIVE_WITH_PENDING_WRITE) {\n        LOG.info(\"Inactive stream with pending writes, fileId\u003d\"\n            + fileHandle.getFileId() + \" commitOffset\u003d\" + commitOffset);\n        return false;\n      }\n      assert (ret \u003d\u003d OpenFileCtx.COMMIT_WAIT || ret \u003d\u003d OpenFileCtx.COMMIT_ERROR);\n      if (ret \u003d\u003d OpenFileCtx.COMMIT_ERROR) {\n        return false;\n      }\n      \n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Not committed yet, wait., fileId\u003d\" + fileHandle.getFileId()\n            + \" commitOffset\u003d\" + commitOffset);\n      }\n      if (System.currentTimeMillis() - startCommit \u003e timeout) {\n        // Commit took too long, return error\n        return false;\n      }\n      try {\n        Thread.sleep(100);\n      } catch (InterruptedException e) {\n        LOG.info(\"Commit is interrupted, fileId\u003d\" + fileHandle.getFileId()\n            + \" commitOffset\u003d\" + commitOffset);\n        return false;\n      }\n    }// while\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java",
      "extendedDetails": {}
    },
    "37f587563a943a827fbff865f5302bac6d202415": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-4762 Provide HDFS based NFSv3 and Mountd implementation. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1499029 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/07/13 10:31 AM",
      "commitName": "37f587563a943a827fbff865f5302bac6d202415",
      "commitAuthor": "Brandon Li",
      "diff": "@@ -0,0 +1,41 @@\n+  boolean handleCommit(FileHandle fileHandle, long commitOffset) {\n+    OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n+    if (openFileCtx \u003d\u003d null) {\n+      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n+          + \" commitOffset\u003d\" + commitOffset);\n+      return true;\n+    }\n+    long timeout \u003d 30 * 1000; // 30 seconds\n+    long startCommit \u003d System.currentTimeMillis();\n+    while (true) {\n+      int ret \u003d openFileCtx.checkCommit(commitOffset);\n+      if (ret \u003d\u003d OpenFileCtx.COMMIT_FINISHED) {\n+        // Committed\n+        return true;\n+      } else if (ret \u003d\u003d OpenFileCtx.COMMIT_INACTIVE_CTX) {\n+        LOG.info(\"Inactive stream, fileId\u003d\" + fileHandle.getFileId()\n+            + \" commitOffset\u003d\" + commitOffset);\n+        return true;\n+      }\n+      assert (ret \u003d\u003d OpenFileCtx.COMMIT_WAIT || ret \u003d\u003d OpenFileCtx.COMMIT_ERROR);\n+      if (ret \u003d\u003d OpenFileCtx.COMMIT_ERROR) {\n+        return false;\n+      }\n+      \n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Not committed yet, wait., fileId\u003d\" + fileHandle.getFileId()\n+            + \" commitOffset\u003d\" + commitOffset);\n+      }\n+      if (System.currentTimeMillis() - startCommit \u003e timeout) {\n+        // Commit took too long, return error\n+        return false;\n+      }\n+      try {\n+        Thread.sleep(100);\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Commit is interrupted, fileId\u003d\" + fileHandle.getFileId()\n+            + \" commitOffset\u003d\" + commitOffset);\n+        return false;\n+      }\n+    }// while\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  boolean handleCommit(FileHandle fileHandle, long commitOffset) {\n    OpenFileCtx openFileCtx \u003d openFileMap.get(fileHandle);\n    if (openFileCtx \u003d\u003d null) {\n      LOG.info(\"No opened stream for fileId:\" + fileHandle.getFileId()\n          + \" commitOffset\u003d\" + commitOffset);\n      return true;\n    }\n    long timeout \u003d 30 * 1000; // 30 seconds\n    long startCommit \u003d System.currentTimeMillis();\n    while (true) {\n      int ret \u003d openFileCtx.checkCommit(commitOffset);\n      if (ret \u003d\u003d OpenFileCtx.COMMIT_FINISHED) {\n        // Committed\n        return true;\n      } else if (ret \u003d\u003d OpenFileCtx.COMMIT_INACTIVE_CTX) {\n        LOG.info(\"Inactive stream, fileId\u003d\" + fileHandle.getFileId()\n            + \" commitOffset\u003d\" + commitOffset);\n        return true;\n      }\n      assert (ret \u003d\u003d OpenFileCtx.COMMIT_WAIT || ret \u003d\u003d OpenFileCtx.COMMIT_ERROR);\n      if (ret \u003d\u003d OpenFileCtx.COMMIT_ERROR) {\n        return false;\n      }\n      \n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Not committed yet, wait., fileId\u003d\" + fileHandle.getFileId()\n            + \" commitOffset\u003d\" + commitOffset);\n      }\n      if (System.currentTimeMillis() - startCommit \u003e timeout) {\n        // Commit took too long, return error\n        return false;\n      }\n      try {\n        Thread.sleep(100);\n      } catch (InterruptedException e) {\n        LOG.info(\"Commit is interrupted, fileId\u003d\" + fileHandle.getFileId()\n            + \" commitOffset\u003d\" + commitOffset);\n        return false;\n      }\n    }// while\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/nfs3/WriteManager.java"
    }
  }
}