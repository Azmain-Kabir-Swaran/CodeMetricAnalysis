{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerScheduler.java",
  "functionName": "onUpdateContainer",
  "functionId": "onUpdateContainer___updateEvent-UpdateContainerSchedulerEvent",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
  "functionStartLine": 204,
  "functionEndLine": 250,
  "numCommitsSeen": 22,
  "timeTaken": 3432,
  "changeHistory": [
    "489411579c5e30c1dc855c4fd3d5f7f68a58b27e",
    "6341c3a437489737a9c4bf0911b218b0023d8dd9",
    "df800f6cf3ea663daf4081ebe784808b08d9366d",
    "4f8194430fc6a69d9cc99b78828fd7045d5683e8",
    "8410d862d3a72740f461ef91dddb5325955e1ca5",
    "4d7be1d8575e9254c59d41460960708e3718503a"
  ],
  "changeHistoryShort": {
    "489411579c5e30c1dc855c4fd3d5f7f68a58b27e": "Ybodychange",
    "6341c3a437489737a9c4bf0911b218b0023d8dd9": "Ybodychange",
    "df800f6cf3ea663daf4081ebe784808b08d9366d": "Ybodychange",
    "4f8194430fc6a69d9cc99b78828fd7045d5683e8": "Ybodychange",
    "8410d862d3a72740f461ef91dddb5325955e1ca5": "Ybodychange",
    "4d7be1d8575e9254c59d41460960708e3718503a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "489411579c5e30c1dc855c4fd3d5f7f68a58b27e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9169. Add metrics for queued opportunistic and guaranteed containers. Contributed by Abhishek Modi.\n",
      "commitDate": "07/01/19 3:16 PM",
      "commitName": "489411579c5e30c1dc855c4fd3d5f7f68a58b27e",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "04/01/19 11:16 AM",
      "commitNameOld": "6e35f7130fb3fb17665e818f838ed750425348c0",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 3.17,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,47 @@\n   private void onUpdateContainer(UpdateContainerSchedulerEvent updateEvent) {\n     ContainerId containerId \u003d updateEvent.getContainer().getContainerId();\n     if (updateEvent.isResourceChange()) {\n       if (runningContainers.containsKey(containerId)) {\n         this.utilizationTracker.subtractContainerResource(\n             new ContainerImpl(getConfig(), null, null, null, null,\n                 updateEvent.getOriginalToken(), context));\n         this.utilizationTracker.addContainerResources(\n             updateEvent.getContainer());\n         getContainersMonitor().handle(\n             new ChangeMonitoringContainerResourceEvent(containerId,\n                 updateEvent.getUpdatedToken().getResource()));\n       }\n     }\n \n     if (updateEvent.isExecTypeUpdate()) {\n       // Promotion or not (Increase signifies either a promotion\n       // or container size increase)\n       if (updateEvent.isIncrease()) {\n         // Promotion of queued container..\n         if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n           queuedGuaranteedContainers.put(containerId,\n               updateEvent.getContainer());\n           //Kill/pause opportunistic containers if any to make room for\n           // promotion request\n           reclaimOpportunisticContainerResources(updateEvent.getContainer());\n         }\n       } else {\n         // Demotion of queued container.. Should not happen too often\n         // since you should not find too many queued guaranteed\n         // containers\n         if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n           queuedOpportunisticContainers.put(containerId,\n               updateEvent.getContainer());\n         }\n       }\n       try {\n         resourceHandlerChain.updateContainer(updateEvent.getContainer());\n       } catch (Exception ex) {\n         LOG.warn(String.format(\"Could not update resources on \" +\n             \"continer update of %s\", containerId), ex);\n       }\n       startPendingContainers(maxOppQueueLength \u003c\u003d 0);\n+      metrics.setQueuedContainers(queuedOpportunisticContainers.size(),\n+          queuedGuaranteedContainers.size());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void onUpdateContainer(UpdateContainerSchedulerEvent updateEvent) {\n    ContainerId containerId \u003d updateEvent.getContainer().getContainerId();\n    if (updateEvent.isResourceChange()) {\n      if (runningContainers.containsKey(containerId)) {\n        this.utilizationTracker.subtractContainerResource(\n            new ContainerImpl(getConfig(), null, null, null, null,\n                updateEvent.getOriginalToken(), context));\n        this.utilizationTracker.addContainerResources(\n            updateEvent.getContainer());\n        getContainersMonitor().handle(\n            new ChangeMonitoringContainerResourceEvent(containerId,\n                updateEvent.getUpdatedToken().getResource()));\n      }\n    }\n\n    if (updateEvent.isExecTypeUpdate()) {\n      // Promotion or not (Increase signifies either a promotion\n      // or container size increase)\n      if (updateEvent.isIncrease()) {\n        // Promotion of queued container..\n        if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n          queuedGuaranteedContainers.put(containerId,\n              updateEvent.getContainer());\n          //Kill/pause opportunistic containers if any to make room for\n          // promotion request\n          reclaimOpportunisticContainerResources(updateEvent.getContainer());\n        }\n      } else {\n        // Demotion of queued container.. Should not happen too often\n        // since you should not find too many queued guaranteed\n        // containers\n        if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n          queuedOpportunisticContainers.put(containerId,\n              updateEvent.getContainer());\n        }\n      }\n      try {\n        resourceHandlerChain.updateContainer(updateEvent.getContainer());\n      } catch (Exception ex) {\n        LOG.warn(String.format(\"Could not update resources on \" +\n            \"continer update of %s\", containerId), ex);\n      }\n      startPendingContainers(maxOppQueueLength \u003c\u003d 0);\n      metrics.setQueuedContainers(queuedOpportunisticContainers.size(),\n          queuedGuaranteedContainers.size());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "6341c3a437489737a9c4bf0911b218b0023d8dd9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7715. Support NM promotion/demotion of running containers. (Miklos Szegedi via Haibo Chen)\n",
      "commitDate": "10/05/18 11:01 AM",
      "commitName": "6341c3a437489737a9c4bf0911b218b0023d8dd9",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "12/04/18 10:17 PM",
      "commitNameOld": "226bedc0239ba23f3ca0c40dac6aab3777d3ada6",
      "commitAuthorOld": "Weiwei Yang",
      "daysBetweenCommits": 27.53,
      "commitsBetweenForRepo": 685,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,45 @@\n   private void onUpdateContainer(UpdateContainerSchedulerEvent updateEvent) {\n     ContainerId containerId \u003d updateEvent.getContainer().getContainerId();\n     if (updateEvent.isResourceChange()) {\n       if (runningContainers.containsKey(containerId)) {\n         this.utilizationTracker.subtractContainerResource(\n             new ContainerImpl(getConfig(), null, null, null, null,\n                 updateEvent.getOriginalToken(), context));\n         this.utilizationTracker.addContainerResources(\n             updateEvent.getContainer());\n         getContainersMonitor().handle(\n             new ChangeMonitoringContainerResourceEvent(containerId,\n                 updateEvent.getUpdatedToken().getResource()));\n       }\n     }\n \n     if (updateEvent.isExecTypeUpdate()) {\n       // Promotion or not (Increase signifies either a promotion\n       // or container size increase)\n       if (updateEvent.isIncrease()) {\n         // Promotion of queued container..\n         if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n           queuedGuaranteedContainers.put(containerId,\n               updateEvent.getContainer());\n           //Kill/pause opportunistic containers if any to make room for\n           // promotion request\n           reclaimOpportunisticContainerResources(updateEvent.getContainer());\n         }\n       } else {\n         // Demotion of queued container.. Should not happen too often\n         // since you should not find too many queued guaranteed\n         // containers\n         if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n           queuedOpportunisticContainers.put(containerId,\n               updateEvent.getContainer());\n         }\n       }\n+      try {\n+        resourceHandlerChain.updateContainer(updateEvent.getContainer());\n+      } catch (Exception ex) {\n+        LOG.warn(String.format(\"Could not update resources on \" +\n+            \"continer update of %s\", containerId), ex);\n+      }\n       startPendingContainers(maxOppQueueLength \u003c\u003d 0);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void onUpdateContainer(UpdateContainerSchedulerEvent updateEvent) {\n    ContainerId containerId \u003d updateEvent.getContainer().getContainerId();\n    if (updateEvent.isResourceChange()) {\n      if (runningContainers.containsKey(containerId)) {\n        this.utilizationTracker.subtractContainerResource(\n            new ContainerImpl(getConfig(), null, null, null, null,\n                updateEvent.getOriginalToken(), context));\n        this.utilizationTracker.addContainerResources(\n            updateEvent.getContainer());\n        getContainersMonitor().handle(\n            new ChangeMonitoringContainerResourceEvent(containerId,\n                updateEvent.getUpdatedToken().getResource()));\n      }\n    }\n\n    if (updateEvent.isExecTypeUpdate()) {\n      // Promotion or not (Increase signifies either a promotion\n      // or container size increase)\n      if (updateEvent.isIncrease()) {\n        // Promotion of queued container..\n        if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n          queuedGuaranteedContainers.put(containerId,\n              updateEvent.getContainer());\n          //Kill/pause opportunistic containers if any to make room for\n          // promotion request\n          reclaimOpportunisticContainerResources(updateEvent.getContainer());\n        }\n      } else {\n        // Demotion of queued container.. Should not happen too often\n        // since you should not find too many queued guaranteed\n        // containers\n        if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n          queuedOpportunisticContainers.put(containerId,\n              updateEvent.getContainer());\n        }\n      }\n      try {\n        resourceHandlerChain.updateContainer(updateEvent.getContainer());\n      } catch (Exception ex) {\n        LOG.warn(String.format(\"Could not update resources on \" +\n            \"continer update of %s\", containerId), ex);\n      }\n      startPendingContainers(maxOppQueueLength \u003c\u003d 0);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "df800f6cf3ea663daf4081ebe784808b08d9366d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7240. Add more states and transitions to stabilize the NM Container state machine. (Kartheek Muthyala via asuresh)\n",
      "commitDate": "25/09/17 4:02 PM",
      "commitName": "df800f6cf3ea663daf4081ebe784808b08d9366d",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "14/09/17 8:51 AM",
      "commitNameOld": "4f8194430fc6a69d9cc99b78828fd7045d5683e8",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 11.3,
      "commitsBetweenForRepo": 97,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,39 @@\n   private void onUpdateContainer(UpdateContainerSchedulerEvent updateEvent) {\n     ContainerId containerId \u003d updateEvent.getContainer().getContainerId();\n     if (updateEvent.isResourceChange()) {\n       if (runningContainers.containsKey(containerId)) {\n         this.utilizationTracker.subtractContainerResource(\n-            updateEvent.getContainer());\n-        updateEvent.getContainer().setContainerTokenIdentifier(\n-            updateEvent.getUpdatedToken());\n+            new ContainerImpl(getConfig(), null, null, null, null,\n+                updateEvent.getOriginalToken(), context));\n         this.utilizationTracker.addContainerResources(\n             updateEvent.getContainer());\n         getContainersMonitor().handle(\n             new ChangeMonitoringContainerResourceEvent(containerId,\n                 updateEvent.getUpdatedToken().getResource()));\n-      } else {\n-        // Is Queued or localizing..\n-        updateEvent.getContainer().setContainerTokenIdentifier(\n-            updateEvent.getUpdatedToken());\n-      }\n-      try {\n-        // Persist change in the state store.\n-        this.context.getNMStateStore().storeContainerResourceChanged(\n-            containerId,\n-            updateEvent.getUpdatedToken().getVersion(),\n-            updateEvent.getUpdatedToken().getResource());\n-      } catch (IOException e) {\n-        LOG.warn(\"Could not store container [\" + containerId + \"] resource \" +\n-            \"change..\", e);\n       }\n     }\n \n     if (updateEvent.isExecTypeUpdate()) {\n-      updateEvent.getContainer().setContainerTokenIdentifier(\n-          updateEvent.getUpdatedToken());\n-      // If this is a running container.. just change the execution type\n-      // and be done with it.\n-      if (!runningContainers.containsKey(containerId)) {\n-        // Promotion or not (Increase signifies either a promotion\n-        // or container size increase)\n-        if (updateEvent.isIncrease()) {\n-          // Promotion of queued container..\n-          if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n-            queuedGuaranteedContainers.put(containerId,\n-                updateEvent.getContainer());\n-          }\n+      // Promotion or not (Increase signifies either a promotion\n+      // or container size increase)\n+      if (updateEvent.isIncrease()) {\n+        // Promotion of queued container..\n+        if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n+          queuedGuaranteedContainers.put(containerId,\n+              updateEvent.getContainer());\n           //Kill/pause opportunistic containers if any to make room for\n           // promotion request\n           reclaimOpportunisticContainerResources(updateEvent.getContainer());\n-        } else {\n-          // Demotion of queued container.. Should not happen too often\n-          // since you should not find too many queued guaranteed\n-          // containers\n-          if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n-            queuedOpportunisticContainers.put(containerId,\n-                updateEvent.getContainer());\n-          }\n+        }\n+      } else {\n+        // Demotion of queued container.. Should not happen too often\n+        // since you should not find too many queued guaranteed\n+        // containers\n+        if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n+          queuedOpportunisticContainers.put(containerId,\n+              updateEvent.getContainer());\n         }\n       }\n+      startPendingContainers(maxOppQueueLength \u003c\u003d 0);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void onUpdateContainer(UpdateContainerSchedulerEvent updateEvent) {\n    ContainerId containerId \u003d updateEvent.getContainer().getContainerId();\n    if (updateEvent.isResourceChange()) {\n      if (runningContainers.containsKey(containerId)) {\n        this.utilizationTracker.subtractContainerResource(\n            new ContainerImpl(getConfig(), null, null, null, null,\n                updateEvent.getOriginalToken(), context));\n        this.utilizationTracker.addContainerResources(\n            updateEvent.getContainer());\n        getContainersMonitor().handle(\n            new ChangeMonitoringContainerResourceEvent(containerId,\n                updateEvent.getUpdatedToken().getResource()));\n      }\n    }\n\n    if (updateEvent.isExecTypeUpdate()) {\n      // Promotion or not (Increase signifies either a promotion\n      // or container size increase)\n      if (updateEvent.isIncrease()) {\n        // Promotion of queued container..\n        if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n          queuedGuaranteedContainers.put(containerId,\n              updateEvent.getContainer());\n          //Kill/pause opportunistic containers if any to make room for\n          // promotion request\n          reclaimOpportunisticContainerResources(updateEvent.getContainer());\n        }\n      } else {\n        // Demotion of queued container.. Should not happen too often\n        // since you should not find too many queued guaranteed\n        // containers\n        if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n          queuedOpportunisticContainers.put(containerId,\n              updateEvent.getContainer());\n        }\n      }\n      startPendingContainers(maxOppQueueLength \u003c\u003d 0);\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "4f8194430fc6a69d9cc99b78828fd7045d5683e8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5216. Expose configurable preemption policy for OPPORTUNISTIC containers running on the NM. (Hitesh Sharma via asuresh)\n",
      "commitDate": "14/09/17 8:51 AM",
      "commitName": "4f8194430fc6a69d9cc99b78828fd7045d5683e8",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "12/09/17 4:10 PM",
      "commitNameOld": "2ae72692fc370267141a1ee55ef372ff62302b54",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 1.7,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,59 @@\n   private void onUpdateContainer(UpdateContainerSchedulerEvent updateEvent) {\n     ContainerId containerId \u003d updateEvent.getContainer().getContainerId();\n     if (updateEvent.isResourceChange()) {\n       if (runningContainers.containsKey(containerId)) {\n         this.utilizationTracker.subtractContainerResource(\n             updateEvent.getContainer());\n         updateEvent.getContainer().setContainerTokenIdentifier(\n             updateEvent.getUpdatedToken());\n         this.utilizationTracker.addContainerResources(\n             updateEvent.getContainer());\n         getContainersMonitor().handle(\n             new ChangeMonitoringContainerResourceEvent(containerId,\n                 updateEvent.getUpdatedToken().getResource()));\n       } else {\n         // Is Queued or localizing..\n         updateEvent.getContainer().setContainerTokenIdentifier(\n             updateEvent.getUpdatedToken());\n       }\n       try {\n         // Persist change in the state store.\n         this.context.getNMStateStore().storeContainerResourceChanged(\n             containerId,\n             updateEvent.getUpdatedToken().getVersion(),\n             updateEvent.getUpdatedToken().getResource());\n       } catch (IOException e) {\n         LOG.warn(\"Could not store container [\" + containerId + \"] resource \" +\n             \"change..\", e);\n       }\n     }\n \n     if (updateEvent.isExecTypeUpdate()) {\n       updateEvent.getContainer().setContainerTokenIdentifier(\n           updateEvent.getUpdatedToken());\n       // If this is a running container.. just change the execution type\n       // and be done with it.\n       if (!runningContainers.containsKey(containerId)) {\n         // Promotion or not (Increase signifies either a promotion\n         // or container size increase)\n         if (updateEvent.isIncrease()) {\n           // Promotion of queued container..\n           if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n             queuedGuaranteedContainers.put(containerId,\n                 updateEvent.getContainer());\n           }\n-          //Kill opportunistic containers if any to make room for\n+          //Kill/pause opportunistic containers if any to make room for\n           // promotion request\n-          killOpportunisticContainers(updateEvent.getContainer());\n+          reclaimOpportunisticContainerResources(updateEvent.getContainer());\n         } else {\n           // Demotion of queued container.. Should not happen too often\n           // since you should not find too many queued guaranteed\n           // containers\n           if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n             queuedOpportunisticContainers.put(containerId,\n                 updateEvent.getContainer());\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void onUpdateContainer(UpdateContainerSchedulerEvent updateEvent) {\n    ContainerId containerId \u003d updateEvent.getContainer().getContainerId();\n    if (updateEvent.isResourceChange()) {\n      if (runningContainers.containsKey(containerId)) {\n        this.utilizationTracker.subtractContainerResource(\n            updateEvent.getContainer());\n        updateEvent.getContainer().setContainerTokenIdentifier(\n            updateEvent.getUpdatedToken());\n        this.utilizationTracker.addContainerResources(\n            updateEvent.getContainer());\n        getContainersMonitor().handle(\n            new ChangeMonitoringContainerResourceEvent(containerId,\n                updateEvent.getUpdatedToken().getResource()));\n      } else {\n        // Is Queued or localizing..\n        updateEvent.getContainer().setContainerTokenIdentifier(\n            updateEvent.getUpdatedToken());\n      }\n      try {\n        // Persist change in the state store.\n        this.context.getNMStateStore().storeContainerResourceChanged(\n            containerId,\n            updateEvent.getUpdatedToken().getVersion(),\n            updateEvent.getUpdatedToken().getResource());\n      } catch (IOException e) {\n        LOG.warn(\"Could not store container [\" + containerId + \"] resource \" +\n            \"change..\", e);\n      }\n    }\n\n    if (updateEvent.isExecTypeUpdate()) {\n      updateEvent.getContainer().setContainerTokenIdentifier(\n          updateEvent.getUpdatedToken());\n      // If this is a running container.. just change the execution type\n      // and be done with it.\n      if (!runningContainers.containsKey(containerId)) {\n        // Promotion or not (Increase signifies either a promotion\n        // or container size increase)\n        if (updateEvent.isIncrease()) {\n          // Promotion of queued container..\n          if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n            queuedGuaranteedContainers.put(containerId,\n                updateEvent.getContainer());\n          }\n          //Kill/pause opportunistic containers if any to make room for\n          // promotion request\n          reclaimOpportunisticContainerResources(updateEvent.getContainer());\n        } else {\n          // Demotion of queued container.. Should not happen too often\n          // since you should not find too many queued guaranteed\n          // containers\n          if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n            queuedOpportunisticContainers.put(containerId,\n                updateEvent.getContainer());\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "8410d862d3a72740f461ef91dddb5325955e1ca5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6979. Add flag to notify all types of container updates to NM via NodeHeartbeatResponse. (Kartheek Muthyala via asuresh)\n",
      "commitDate": "20/08/17 7:54 AM",
      "commitName": "8410d862d3a72740f461ef91dddb5325955e1ca5",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "14/08/17 7:46 PM",
      "commitNameOld": "4d7be1d8575e9254c59d41460960708e3718503a",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 5.51,
      "commitsBetweenForRepo": 28,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,59 @@\n   private void onUpdateContainer(UpdateContainerSchedulerEvent updateEvent) {\n     ContainerId containerId \u003d updateEvent.getContainer().getContainerId();\n     if (updateEvent.isResourceChange()) {\n       if (runningContainers.containsKey(containerId)) {\n         this.utilizationTracker.subtractContainerResource(\n             updateEvent.getContainer());\n         updateEvent.getContainer().setContainerTokenIdentifier(\n             updateEvent.getUpdatedToken());\n         this.utilizationTracker.addContainerResources(\n             updateEvent.getContainer());\n         getContainersMonitor().handle(\n             new ChangeMonitoringContainerResourceEvent(containerId,\n                 updateEvent.getUpdatedToken().getResource()));\n       } else {\n+        // Is Queued or localizing..\n         updateEvent.getContainer().setContainerTokenIdentifier(\n             updateEvent.getUpdatedToken());\n       }\n       try {\n         // Persist change in the state store.\n         this.context.getNMStateStore().storeContainerResourceChanged(\n             containerId,\n             updateEvent.getUpdatedToken().getVersion(),\n             updateEvent.getUpdatedToken().getResource());\n       } catch (IOException e) {\n         LOG.warn(\"Could not store container [\" + containerId + \"] resource \" +\n             \"change..\", e);\n       }\n     }\n \n     if (updateEvent.isExecTypeUpdate()) {\n       updateEvent.getContainer().setContainerTokenIdentifier(\n           updateEvent.getUpdatedToken());\n       // If this is a running container.. just change the execution type\n       // and be done with it.\n       if (!runningContainers.containsKey(containerId)) {\n         // Promotion or not (Increase signifies either a promotion\n         // or container size increase)\n         if (updateEvent.isIncrease()) {\n           // Promotion of queued container..\n           if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n             queuedGuaranteedContainers.put(containerId,\n                 updateEvent.getContainer());\n           }\n           //Kill opportunistic containers if any to make room for\n           // promotion request\n           killOpportunisticContainers(updateEvent.getContainer());\n         } else {\n           // Demotion of queued container.. Should not happen too often\n           // since you should not find too many queued guaranteed\n           // containers\n           if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n             queuedOpportunisticContainers.put(containerId,\n                 updateEvent.getContainer());\n           }\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void onUpdateContainer(UpdateContainerSchedulerEvent updateEvent) {\n    ContainerId containerId \u003d updateEvent.getContainer().getContainerId();\n    if (updateEvent.isResourceChange()) {\n      if (runningContainers.containsKey(containerId)) {\n        this.utilizationTracker.subtractContainerResource(\n            updateEvent.getContainer());\n        updateEvent.getContainer().setContainerTokenIdentifier(\n            updateEvent.getUpdatedToken());\n        this.utilizationTracker.addContainerResources(\n            updateEvent.getContainer());\n        getContainersMonitor().handle(\n            new ChangeMonitoringContainerResourceEvent(containerId,\n                updateEvent.getUpdatedToken().getResource()));\n      } else {\n        // Is Queued or localizing..\n        updateEvent.getContainer().setContainerTokenIdentifier(\n            updateEvent.getUpdatedToken());\n      }\n      try {\n        // Persist change in the state store.\n        this.context.getNMStateStore().storeContainerResourceChanged(\n            containerId,\n            updateEvent.getUpdatedToken().getVersion(),\n            updateEvent.getUpdatedToken().getResource());\n      } catch (IOException e) {\n        LOG.warn(\"Could not store container [\" + containerId + \"] resource \" +\n            \"change..\", e);\n      }\n    }\n\n    if (updateEvent.isExecTypeUpdate()) {\n      updateEvent.getContainer().setContainerTokenIdentifier(\n          updateEvent.getUpdatedToken());\n      // If this is a running container.. just change the execution type\n      // and be done with it.\n      if (!runningContainers.containsKey(containerId)) {\n        // Promotion or not (Increase signifies either a promotion\n        // or container size increase)\n        if (updateEvent.isIncrease()) {\n          // Promotion of queued container..\n          if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n            queuedGuaranteedContainers.put(containerId,\n                updateEvent.getContainer());\n          }\n          //Kill opportunistic containers if any to make room for\n          // promotion request\n          killOpportunisticContainers(updateEvent.getContainer());\n        } else {\n          // Demotion of queued container.. Should not happen too often\n          // since you should not find too many queued guaranteed\n          // containers\n          if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n            queuedOpportunisticContainers.put(containerId,\n                updateEvent.getContainer());\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java",
      "extendedDetails": {}
    },
    "4d7be1d8575e9254c59d41460960708e3718503a": {
      "type": "Yintroduced",
      "commitMessage": "YARN-5978. ContainerScheduler and ContainerManager changes to support ExecType update. (Kartheek Muthyala via asuresh)\n",
      "commitDate": "14/08/17 7:46 PM",
      "commitName": "4d7be1d8575e9254c59d41460960708e3718503a",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,58 @@\n+  private void onUpdateContainer(UpdateContainerSchedulerEvent updateEvent) {\n+    ContainerId containerId \u003d updateEvent.getContainer().getContainerId();\n+    if (updateEvent.isResourceChange()) {\n+      if (runningContainers.containsKey(containerId)) {\n+        this.utilizationTracker.subtractContainerResource(\n+            updateEvent.getContainer());\n+        updateEvent.getContainer().setContainerTokenIdentifier(\n+            updateEvent.getUpdatedToken());\n+        this.utilizationTracker.addContainerResources(\n+            updateEvent.getContainer());\n+        getContainersMonitor().handle(\n+            new ChangeMonitoringContainerResourceEvent(containerId,\n+                updateEvent.getUpdatedToken().getResource()));\n+      } else {\n+        updateEvent.getContainer().setContainerTokenIdentifier(\n+            updateEvent.getUpdatedToken());\n+      }\n+      try {\n+        // Persist change in the state store.\n+        this.context.getNMStateStore().storeContainerResourceChanged(\n+            containerId,\n+            updateEvent.getUpdatedToken().getVersion(),\n+            updateEvent.getUpdatedToken().getResource());\n+      } catch (IOException e) {\n+        LOG.warn(\"Could not store container [\" + containerId + \"] resource \" +\n+            \"change..\", e);\n+      }\n+    }\n+\n+    if (updateEvent.isExecTypeUpdate()) {\n+      updateEvent.getContainer().setContainerTokenIdentifier(\n+          updateEvent.getUpdatedToken());\n+      // If this is a running container.. just change the execution type\n+      // and be done with it.\n+      if (!runningContainers.containsKey(containerId)) {\n+        // Promotion or not (Increase signifies either a promotion\n+        // or container size increase)\n+        if (updateEvent.isIncrease()) {\n+          // Promotion of queued container..\n+          if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n+            queuedGuaranteedContainers.put(containerId,\n+                updateEvent.getContainer());\n+          }\n+          //Kill opportunistic containers if any to make room for\n+          // promotion request\n+          killOpportunisticContainers(updateEvent.getContainer());\n+        } else {\n+          // Demotion of queued container.. Should not happen too often\n+          // since you should not find too many queued guaranteed\n+          // containers\n+          if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n+            queuedOpportunisticContainers.put(containerId,\n+                updateEvent.getContainer());\n+          }\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void onUpdateContainer(UpdateContainerSchedulerEvent updateEvent) {\n    ContainerId containerId \u003d updateEvent.getContainer().getContainerId();\n    if (updateEvent.isResourceChange()) {\n      if (runningContainers.containsKey(containerId)) {\n        this.utilizationTracker.subtractContainerResource(\n            updateEvent.getContainer());\n        updateEvent.getContainer().setContainerTokenIdentifier(\n            updateEvent.getUpdatedToken());\n        this.utilizationTracker.addContainerResources(\n            updateEvent.getContainer());\n        getContainersMonitor().handle(\n            new ChangeMonitoringContainerResourceEvent(containerId,\n                updateEvent.getUpdatedToken().getResource()));\n      } else {\n        updateEvent.getContainer().setContainerTokenIdentifier(\n            updateEvent.getUpdatedToken());\n      }\n      try {\n        // Persist change in the state store.\n        this.context.getNMStateStore().storeContainerResourceChanged(\n            containerId,\n            updateEvent.getUpdatedToken().getVersion(),\n            updateEvent.getUpdatedToken().getResource());\n      } catch (IOException e) {\n        LOG.warn(\"Could not store container [\" + containerId + \"] resource \" +\n            \"change..\", e);\n      }\n    }\n\n    if (updateEvent.isExecTypeUpdate()) {\n      updateEvent.getContainer().setContainerTokenIdentifier(\n          updateEvent.getUpdatedToken());\n      // If this is a running container.. just change the execution type\n      // and be done with it.\n      if (!runningContainers.containsKey(containerId)) {\n        // Promotion or not (Increase signifies either a promotion\n        // or container size increase)\n        if (updateEvent.isIncrease()) {\n          // Promotion of queued container..\n          if (queuedOpportunisticContainers.remove(containerId) !\u003d null) {\n            queuedGuaranteedContainers.put(containerId,\n                updateEvent.getContainer());\n          }\n          //Kill opportunistic containers if any to make room for\n          // promotion request\n          killOpportunisticContainers(updateEvent.getContainer());\n        } else {\n          // Demotion of queued container.. Should not happen too often\n          // since you should not find too many queued guaranteed\n          // containers\n          if (queuedGuaranteedContainers.remove(containerId) !\u003d null) {\n            queuedOpportunisticContainers.put(containerId,\n                updateEvent.getContainer());\n          }\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/scheduler/ContainerScheduler.java"
    }
  }
}