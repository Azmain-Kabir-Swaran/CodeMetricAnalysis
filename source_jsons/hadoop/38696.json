{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FiCaSchedulerApp.java",
  "functionName": "allocate",
  "functionId": "allocate___node-FiCaSchedulerNode__schedulerKey-SchedulerRequestKey__container-Container",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
  "functionStartLine": 247,
  "functionEndLine": 290,
  "numCommitsSeen": 269,
  "timeTaken": 16776,
  "changeHistory": [
    "cdb2107066a2d8557270888c0a9a75f29a6853bf",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
    "2977bc6a141041ef7579efc416e93fc55e0c2a1a",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c",
    "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
    "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
    "ed54f5f1ff7862f8216f77d5ea8f9ccea674ccd1",
    "ae14e5d07f1b6702a5160637438028bb03d9387e",
    "fa7a43529d529f0006c8033c2003f15b9b93f103",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
    "1b89a3e173f8e905074ed6714a7be5c003c0e2c4",
    "586348e4cbf197188057d6b843a6701cfffdaff3",
    "43589a8df70d4dbaf86609961e27cc4e23dda993",
    "cbee889711eddc5c67a61df4a6531b4ab3cd205a",
    "01aabf73639785a29d1651f2e268cec04a8b9b94",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
    "312a7e71001d55f88781e56b331ab1b40a72a980",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
    "cdfabf5ae289836968b3d296668593b9500b6f26",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": "Ybodychange",
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949": "Ybodychange",
    "2977bc6a141041ef7579efc416e93fc55e0c2a1a": "Ymultichange(Yparameterchange,Ybodychange)",
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": "Ybodychange",
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": "Ymultichange(Yparameterchange,Ybodychange)",
    "b8a30f2f170ffbd590e7366c3c944ab4919e40df": "Ymultichange(Ymodifierchange,Ybodychange)",
    "5aace38b748ba71aaadd2c4d64eba8dc1f816828": "Ymultichange(Yparameterchange,Ybodychange)",
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": "Ybodychange",
    "ed54f5f1ff7862f8216f77d5ea8f9ccea674ccd1": "Ybodychange",
    "ae14e5d07f1b6702a5160637438028bb03d9387e": "Ybodychange",
    "fa7a43529d529f0006c8033c2003f15b9b93f103": "Ybodychange",
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": "Ybodychange",
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": "Ybodychange",
    "1b89a3e173f8e905074ed6714a7be5c003c0e2c4": "Ybodychange",
    "586348e4cbf197188057d6b843a6701cfffdaff3": "Ybodychange",
    "43589a8df70d4dbaf86609961e27cc4e23dda993": "Ybodychange",
    "cbee889711eddc5c67a61df4a6531b4ab3cd205a": "Ybodychange",
    "01aabf73639785a29d1651f2e268cec04a8b9b94": "Ybodychange",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": "Ymultichange(Yfilerename,Yparameterchange)",
    "312a7e71001d55f88781e56b331ab1b40a72a980": "Ybodychange",
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": "Ybodychange",
    "cdfabf5ae289836968b3d296668593b9500b6f26": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "cdb2107066a2d8557270888c0a9a75f29a6853bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9879. Allow multiple leaf queues with the same name in CapacityScheduler. Contributed by Gergely Pollak.\n",
      "commitDate": "25/03/20 4:20 AM",
      "commitName": "cdb2107066a2d8557270888c0a9a75f29a6853bf",
      "commitAuthor": "Sunil G",
      "commitDateOld": "26/11/19 1:04 PM",
      "commitNameOld": "ef950b086354c8a02eecd6745f6ab0fe5449f7b0",
      "commitAuthorOld": "Szilard Nemeth",
      "daysBetweenCommits": 119.59,
      "commitsBetweenForRepo": 396,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,44 @@\n   public RMContainer allocate(FiCaSchedulerNode node,\n       SchedulerRequestKey schedulerKey, Container container) {\n     readLock.lock();\n     try {\n \n       if (isStopped) {\n         return null;\n       }\n \n       // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n       // request without locking the scheduler, hence we need to check\n       if (getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n         return null;\n       }\n \n       AppPlacementAllocator\u003cFiCaSchedulerNode\u003e ps \u003d\n           appSchedulingInfo.getAppPlacementAllocator(schedulerKey);\n       if (null \u003d\u003d ps) {\n         LOG.warn(\"Failed to get \" + AppPlacementAllocator.class.getName()\n             + \" for application\u003d\" + getApplicationId() + \" schedulerRequestKey\u003d\"\n             + schedulerKey);\n         return null;\n       }\n \n       // Create RMContainer\n       RMContainer rmContainer \u003d new RMContainerImpl(container, schedulerKey,\n           this.getApplicationAttemptId(), node.getNodeID(),\n           appSchedulingInfo.getUser(), this.rmContext,\n           ps.getPrimaryRequestedNodePartition());\n-      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n+\n+      String qn \u003d this.getQueueName();\n+      if (this.scheduler instanceof CapacityScheduler) {\n+        qn \u003d ((CapacityScheduler)this.scheduler).normalizeQueueName(qn);\n+      }\n+      ((RMContainerImpl) rmContainer).setQueueName(qn);\n \n       // FIXME, should set when confirmed\n       updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n       return rmContainer;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RMContainer allocate(FiCaSchedulerNode node,\n      SchedulerRequestKey schedulerKey, Container container) {\n    readLock.lock();\n    try {\n\n      if (isStopped) {\n        return null;\n      }\n\n      // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n      // request without locking the scheduler, hence we need to check\n      if (getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n        return null;\n      }\n\n      AppPlacementAllocator\u003cFiCaSchedulerNode\u003e ps \u003d\n          appSchedulingInfo.getAppPlacementAllocator(schedulerKey);\n      if (null \u003d\u003d ps) {\n        LOG.warn(\"Failed to get \" + AppPlacementAllocator.class.getName()\n            + \" for application\u003d\" + getApplicationId() + \" schedulerRequestKey\u003d\"\n            + schedulerKey);\n        return null;\n      }\n\n      // Create RMContainer\n      RMContainer rmContainer \u003d new RMContainerImpl(container, schedulerKey,\n          this.getApplicationAttemptId(), node.getNodeID(),\n          appSchedulingInfo.getUser(), this.rmContext,\n          ps.getPrimaryRequestedNodePartition());\n\n      String qn \u003d this.getQueueName();\n      if (this.scheduler instanceof CapacityScheduler) {\n        qn \u003d ((CapacityScheduler)this.scheduler).normalizeQueueName(qn);\n      }\n      ((RMContainerImpl) rmContainer).setQueueName(qn);\n\n      // FIXME, should set when confirmed\n      updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n      return rmContainer;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   public RMContainer allocate(FiCaSchedulerNode node,\n       SchedulerRequestKey schedulerKey, Container container) {\n+    readLock.lock();\n     try {\n-      readLock.lock();\n \n       if (isStopped) {\n         return null;\n       }\n \n       // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n       // request without locking the scheduler, hence we need to check\n       if (getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n         return null;\n       }\n \n       AppPlacementAllocator\u003cFiCaSchedulerNode\u003e ps \u003d\n           appSchedulingInfo.getAppPlacementAllocator(schedulerKey);\n       if (null \u003d\u003d ps) {\n         LOG.warn(\"Failed to get \" + AppPlacementAllocator.class.getName()\n             + \" for application\u003d\" + getApplicationId() + \" schedulerRequestKey\u003d\"\n             + schedulerKey);\n         return null;\n       }\n \n       // Create RMContainer\n       RMContainer rmContainer \u003d new RMContainerImpl(container, schedulerKey,\n           this.getApplicationAttemptId(), node.getNodeID(),\n           appSchedulingInfo.getUser(), this.rmContext,\n           ps.getPrimaryRequestedNodePartition());\n       ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n \n       // FIXME, should set when confirmed\n       updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n       return rmContainer;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RMContainer allocate(FiCaSchedulerNode node,\n      SchedulerRequestKey schedulerKey, Container container) {\n    readLock.lock();\n    try {\n\n      if (isStopped) {\n        return null;\n      }\n\n      // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n      // request without locking the scheduler, hence we need to check\n      if (getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n        return null;\n      }\n\n      AppPlacementAllocator\u003cFiCaSchedulerNode\u003e ps \u003d\n          appSchedulingInfo.getAppPlacementAllocator(schedulerKey);\n      if (null \u003d\u003d ps) {\n        LOG.warn(\"Failed to get \" + AppPlacementAllocator.class.getName()\n            + \" for application\u003d\" + getApplicationId() + \" schedulerRequestKey\u003d\"\n            + schedulerKey);\n        return null;\n      }\n\n      // Create RMContainer\n      RMContainer rmContainer \u003d new RMContainerImpl(container, schedulerKey,\n          this.getApplicationAttemptId(), node.getNodeID(),\n          appSchedulingInfo.getUser(), this.rmContext,\n          ps.getPrimaryRequestedNodePartition());\n      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n\n      // FIXME, should set when confirmed\n      updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n      return rmContainer;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7437. Rename PlacementSet and SchedulingPlacementSet. (Wangda Tan via kkaranasos)\n",
      "commitDate": "09/11/17 1:01 PM",
      "commitName": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
      "commitAuthor": "Konstantinos Karanasos",
      "commitDateOld": "17/09/17 9:20 PM",
      "commitNameOld": "e81596d06d226f1cfa44b2390ce3095ed4dee621",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 52.69,
      "commitsBetweenForRepo": 485,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,39 @@\n   public RMContainer allocate(FiCaSchedulerNode node,\n       SchedulerRequestKey schedulerKey, Container container) {\n     try {\n       readLock.lock();\n \n       if (isStopped) {\n         return null;\n       }\n \n       // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n       // request without locking the scheduler, hence we need to check\n       if (getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n         return null;\n       }\n \n-      SchedulingPlacementSet\u003cFiCaSchedulerNode\u003e ps \u003d\n-          appSchedulingInfo.getSchedulingPlacementSet(schedulerKey);\n+      AppPlacementAllocator\u003cFiCaSchedulerNode\u003e ps \u003d\n+          appSchedulingInfo.getAppPlacementAllocator(schedulerKey);\n       if (null \u003d\u003d ps) {\n-        LOG.warn(\"Failed to get \" + SchedulingPlacementSet.class.getName()\n+        LOG.warn(\"Failed to get \" + AppPlacementAllocator.class.getName()\n             + \" for application\u003d\" + getApplicationId() + \" schedulerRequestKey\u003d\"\n             + schedulerKey);\n         return null;\n       }\n \n       // Create RMContainer\n       RMContainer rmContainer \u003d new RMContainerImpl(container, schedulerKey,\n           this.getApplicationAttemptId(), node.getNodeID(),\n           appSchedulingInfo.getUser(), this.rmContext,\n           ps.getPrimaryRequestedNodePartition());\n       ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n \n       // FIXME, should set when confirmed\n       updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n       return rmContainer;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RMContainer allocate(FiCaSchedulerNode node,\n      SchedulerRequestKey schedulerKey, Container container) {\n    try {\n      readLock.lock();\n\n      if (isStopped) {\n        return null;\n      }\n\n      // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n      // request without locking the scheduler, hence we need to check\n      if (getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n        return null;\n      }\n\n      AppPlacementAllocator\u003cFiCaSchedulerNode\u003e ps \u003d\n          appSchedulingInfo.getAppPlacementAllocator(schedulerKey);\n      if (null \u003d\u003d ps) {\n        LOG.warn(\"Failed to get \" + AppPlacementAllocator.class.getName()\n            + \" for application\u003d\" + getApplicationId() + \" schedulerRequestKey\u003d\"\n            + schedulerKey);\n        return null;\n      }\n\n      // Create RMContainer\n      RMContainer rmContainer \u003d new RMContainerImpl(container, schedulerKey,\n          this.getApplicationAttemptId(), node.getNodeID(),\n          appSchedulingInfo.getUser(), this.rmContext,\n          ps.getPrimaryRequestedNodePartition());\n      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n\n      // FIXME, should set when confirmed\n      updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n      return rmContainer;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "2977bc6a141041ef7579efc416e93fc55e0c2a1a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6040. Introduce api independent PendingAsk to replace usage of ResourceRequest within Scheduler classes. (Wangda Tan via asuresh)\n",
      "commitDate": "06/01/17 9:59 AM",
      "commitName": "2977bc6a141041ef7579efc416e93fc55e0c2a1a",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6040. Introduce api independent PendingAsk to replace usage of ResourceRequest within Scheduler classes. (Wangda Tan via asuresh)\n",
          "commitDate": "06/01/17 9:59 AM",
          "commitName": "2977bc6a141041ef7579efc416e93fc55e0c2a1a",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "05/01/17 10:31 AM",
          "commitNameOld": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.98,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,39 @@\n   public RMContainer allocate(FiCaSchedulerNode node,\n-      SchedulerRequestKey schedulerKey, ResourceRequest request,\n-      Container container) {\n+      SchedulerRequestKey schedulerKey, Container container) {\n     try {\n       readLock.lock();\n \n       if (isStopped) {\n         return null;\n       }\n \n       // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n       // request without locking the scheduler, hence we need to check\n-      if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n+      if (getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n+        return null;\n+      }\n+\n+      SchedulingPlacementSet\u003cFiCaSchedulerNode\u003e ps \u003d\n+          appSchedulingInfo.getSchedulingPlacementSet(schedulerKey);\n+      if (null \u003d\u003d ps) {\n+        LOG.warn(\"Failed to get \" + SchedulingPlacementSet.class.getName()\n+            + \" for application\u003d\" + getApplicationId() + \" schedulerRequestKey\u003d\"\n+            + schedulerKey);\n         return null;\n       }\n \n       // Create RMContainer\n       RMContainer rmContainer \u003d new RMContainerImpl(container, schedulerKey,\n           this.getApplicationAttemptId(), node.getNodeID(),\n           appSchedulingInfo.getUser(), this.rmContext,\n-          request.getNodeLabelExpression());\n+          ps.getPrimaryRequestedNodePartition());\n       ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n \n       // FIXME, should set when confirmed\n       updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n       return rmContainer;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RMContainer allocate(FiCaSchedulerNode node,\n      SchedulerRequestKey schedulerKey, Container container) {\n    try {\n      readLock.lock();\n\n      if (isStopped) {\n        return null;\n      }\n\n      // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n      // request without locking the scheduler, hence we need to check\n      if (getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n        return null;\n      }\n\n      SchedulingPlacementSet\u003cFiCaSchedulerNode\u003e ps \u003d\n          appSchedulingInfo.getSchedulingPlacementSet(schedulerKey);\n      if (null \u003d\u003d ps) {\n        LOG.warn(\"Failed to get \" + SchedulingPlacementSet.class.getName()\n            + \" for application\u003d\" + getApplicationId() + \" schedulerRequestKey\u003d\"\n            + schedulerKey);\n        return null;\n      }\n\n      // Create RMContainer\n      RMContainer rmContainer \u003d new RMContainerImpl(container, schedulerKey,\n          this.getApplicationAttemptId(), node.getNodeID(),\n          appSchedulingInfo.getUser(), this.rmContext,\n          ps.getPrimaryRequestedNodePartition());\n      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n\n      // FIXME, should set when confirmed\n      updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n      return rmContainer;\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {
            "oldValue": "[node-FiCaSchedulerNode, schedulerKey-SchedulerRequestKey, request-ResourceRequest, container-Container]",
            "newValue": "[node-FiCaSchedulerNode, schedulerKey-SchedulerRequestKey, container-Container]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6040. Introduce api independent PendingAsk to replace usage of ResourceRequest within Scheduler classes. (Wangda Tan via asuresh)\n",
          "commitDate": "06/01/17 9:59 AM",
          "commitName": "2977bc6a141041ef7579efc416e93fc55e0c2a1a",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "05/01/17 10:31 AM",
          "commitNameOld": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 0.98,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,31 +1,39 @@\n   public RMContainer allocate(FiCaSchedulerNode node,\n-      SchedulerRequestKey schedulerKey, ResourceRequest request,\n-      Container container) {\n+      SchedulerRequestKey schedulerKey, Container container) {\n     try {\n       readLock.lock();\n \n       if (isStopped) {\n         return null;\n       }\n \n       // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n       // request without locking the scheduler, hence we need to check\n-      if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n+      if (getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n+        return null;\n+      }\n+\n+      SchedulingPlacementSet\u003cFiCaSchedulerNode\u003e ps \u003d\n+          appSchedulingInfo.getSchedulingPlacementSet(schedulerKey);\n+      if (null \u003d\u003d ps) {\n+        LOG.warn(\"Failed to get \" + SchedulingPlacementSet.class.getName()\n+            + \" for application\u003d\" + getApplicationId() + \" schedulerRequestKey\u003d\"\n+            + schedulerKey);\n         return null;\n       }\n \n       // Create RMContainer\n       RMContainer rmContainer \u003d new RMContainerImpl(container, schedulerKey,\n           this.getApplicationAttemptId(), node.getNodeID(),\n           appSchedulingInfo.getUser(), this.rmContext,\n-          request.getNodeLabelExpression());\n+          ps.getPrimaryRequestedNodePartition());\n       ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n \n       // FIXME, should set when confirmed\n       updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n       return rmContainer;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RMContainer allocate(FiCaSchedulerNode node,\n      SchedulerRequestKey schedulerKey, Container container) {\n    try {\n      readLock.lock();\n\n      if (isStopped) {\n        return null;\n      }\n\n      // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n      // request without locking the scheduler, hence we need to check\n      if (getOutstandingAsksCount(schedulerKey) \u003c\u003d 0) {\n        return null;\n      }\n\n      SchedulingPlacementSet\u003cFiCaSchedulerNode\u003e ps \u003d\n          appSchedulingInfo.getSchedulingPlacementSet(schedulerKey);\n      if (null \u003d\u003d ps) {\n        LOG.warn(\"Failed to get \" + SchedulingPlacementSet.class.getName()\n            + \" for application\u003d\" + getApplicationId() + \" schedulerRequestKey\u003d\"\n            + schedulerKey);\n        return null;\n      }\n\n      // Create RMContainer\n      RMContainer rmContainer \u003d new RMContainerImpl(container, schedulerKey,\n          this.getApplicationAttemptId(), node.getNodeID(),\n          appSchedulingInfo.getUser(), this.rmContext,\n          ps.getPrimaryRequestedNodePartition());\n      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n\n      // FIXME, should set when confirmed\n      updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n      return rmContainer;\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {}
        }
      ]
    },
    "0a55bd841ec0f2eb89a0383f4c589526e8b138d4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5959. RM changes to support change of container ExecutionType. (Arun Suresh via wangda)\n",
      "commitDate": "05/01/17 10:31 AM",
      "commitName": "0a55bd841ec0f2eb89a0383f4c589526e8b138d4",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/12/16 12:40 PM",
      "commitNameOld": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 8.91,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,31 +1,31 @@\n   public RMContainer allocate(FiCaSchedulerNode node,\n       SchedulerRequestKey schedulerKey, ResourceRequest request,\n       Container container) {\n     try {\n       readLock.lock();\n \n       if (isStopped) {\n         return null;\n       }\n \n       // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n       // request without locking the scheduler, hence we need to check\n       if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n         return null;\n       }\n \n       // Create RMContainer\n-      RMContainer rmContainer \u003d new RMContainerImpl(container,\n+      RMContainer rmContainer \u003d new RMContainerImpl(container, schedulerKey,\n           this.getApplicationAttemptId(), node.getNodeID(),\n           appSchedulingInfo.getUser(), this.rmContext,\n           request.getNodeLabelExpression());\n       ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n \n       // FIXME, should set when confirmed\n       updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n       return rmContainer;\n     } finally {\n       readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public RMContainer allocate(FiCaSchedulerNode node,\n      SchedulerRequestKey schedulerKey, ResourceRequest request,\n      Container container) {\n    try {\n      readLock.lock();\n\n      if (isStopped) {\n        return null;\n      }\n\n      // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n      // request without locking the scheduler, hence we need to check\n      if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n        return null;\n      }\n\n      // Create RMContainer\n      RMContainer rmContainer \u003d new RMContainerImpl(container, schedulerKey,\n          this.getApplicationAttemptId(), node.getNodeID(),\n          appSchedulingInfo.getUser(), this.rmContext,\n          request.getNodeLabelExpression());\n      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n\n      // FIXME, should set when confirmed\n      updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n      return rmContainer;\n    } finally {\n      readLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "de3b4aac561258ad242a3c5ed1c919428893fd4c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
      "commitDate": "07/11/16 10:14 AM",
      "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "31/10/16 3:18 PM",
          "commitNameOld": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 6.83,
          "commitsBetweenForRepo": 84,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,31 @@\n-  public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n+  public RMContainer allocate(FiCaSchedulerNode node,\n       SchedulerRequestKey schedulerKey, ResourceRequest request,\n       Container container) {\n     try {\n-      writeLock.lock();\n+      readLock.lock();\n \n       if (isStopped) {\n         return null;\n       }\n \n       // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n       // request without locking the scheduler, hence we need to check\n       if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n         return null;\n       }\n \n       // Create RMContainer\n       RMContainer rmContainer \u003d new RMContainerImpl(container,\n           this.getApplicationAttemptId(), node.getNodeID(),\n           appSchedulingInfo.getUser(), this.rmContext,\n           request.getNodeLabelExpression());\n       ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n \n+      // FIXME, should set when confirmed\n       updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n-      // Add it to allContainers list.\n-      newlyAllocatedContainers.add(rmContainer);\n-\n-      ContainerId containerId \u003d container.getId();\n-      liveContainers.put(containerId, rmContainer);\n-\n-      // Update consumption and track allocations\n-      List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n-          type, node, schedulerKey, request, container);\n-\n-      attemptResourceUsage.incUsed(node.getPartition(),\n-          container.getResource());\n-\n-      // Update resource requests related to \"request\" and store in RMContainer\n-      ((RMContainerImpl) rmContainer).setResourceRequests(resourceRequestList);\n-\n-      // Inform the container\n-      rmContainer.handle(\n-          new RMContainerEvent(containerId, RMContainerEventType.START));\n-\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n-            .getApplicationAttemptId() + \" container\u003d\" + containerId + \" host\u003d\"\n-            + container.getNodeId().getHost() + \" type\u003d\" + type);\n-      }\n-      RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n-          \"SchedulerApp\", getApplicationId(), containerId,\n-          container.getResource());\n-\n       return rmContainer;\n     } finally {\n-      writeLock.unlock();\n+      readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RMContainer allocate(FiCaSchedulerNode node,\n      SchedulerRequestKey schedulerKey, ResourceRequest request,\n      Container container) {\n    try {\n      readLock.lock();\n\n      if (isStopped) {\n        return null;\n      }\n\n      // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n      // request without locking the scheduler, hence we need to check\n      if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n        return null;\n      }\n\n      // Create RMContainer\n      RMContainer rmContainer \u003d new RMContainerImpl(container,\n          this.getApplicationAttemptId(), node.getNodeID(),\n          appSchedulingInfo.getUser(), this.rmContext,\n          request.getNodeLabelExpression());\n      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n\n      // FIXME, should set when confirmed\n      updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n      return rmContainer;\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {
            "oldValue": "[type-NodeType, node-FiCaSchedulerNode, schedulerKey-SchedulerRequestKey, request-ResourceRequest, container-Container]",
            "newValue": "[node-FiCaSchedulerNode, schedulerKey-SchedulerRequestKey, request-ResourceRequest, container-Container]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5716. Add global scheduler interface definition and update CapacityScheduler to use it. Contributed by Wangda Tan\n",
          "commitDate": "07/11/16 10:14 AM",
          "commitName": "de3b4aac561258ad242a3c5ed1c919428893fd4c",
          "commitAuthor": "Jian He",
          "commitDateOld": "31/10/16 3:18 PM",
          "commitNameOld": "90dd3a8148468ac37a3f2173ad8d45e38bfcb0c9",
          "commitAuthorOld": "Wangda Tan",
          "daysBetweenCommits": 6.83,
          "commitsBetweenForRepo": 84,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,59 +1,31 @@\n-  public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n+  public RMContainer allocate(FiCaSchedulerNode node,\n       SchedulerRequestKey schedulerKey, ResourceRequest request,\n       Container container) {\n     try {\n-      writeLock.lock();\n+      readLock.lock();\n \n       if (isStopped) {\n         return null;\n       }\n \n       // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n       // request without locking the scheduler, hence we need to check\n       if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n         return null;\n       }\n \n       // Create RMContainer\n       RMContainer rmContainer \u003d new RMContainerImpl(container,\n           this.getApplicationAttemptId(), node.getNodeID(),\n           appSchedulingInfo.getUser(), this.rmContext,\n           request.getNodeLabelExpression());\n       ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n \n+      // FIXME, should set when confirmed\n       updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n-      // Add it to allContainers list.\n-      newlyAllocatedContainers.add(rmContainer);\n-\n-      ContainerId containerId \u003d container.getId();\n-      liveContainers.put(containerId, rmContainer);\n-\n-      // Update consumption and track allocations\n-      List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n-          type, node, schedulerKey, request, container);\n-\n-      attemptResourceUsage.incUsed(node.getPartition(),\n-          container.getResource());\n-\n-      // Update resource requests related to \"request\" and store in RMContainer\n-      ((RMContainerImpl) rmContainer).setResourceRequests(resourceRequestList);\n-\n-      // Inform the container\n-      rmContainer.handle(\n-          new RMContainerEvent(containerId, RMContainerEventType.START));\n-\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n-            .getApplicationAttemptId() + \" container\u003d\" + containerId + \" host\u003d\"\n-            + container.getNodeId().getHost() + \" type\u003d\" + type);\n-      }\n-      RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n-          \"SchedulerApp\", getApplicationId(), containerId,\n-          container.getResource());\n-\n       return rmContainer;\n     } finally {\n-      writeLock.unlock();\n+      readLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RMContainer allocate(FiCaSchedulerNode node,\n      SchedulerRequestKey schedulerKey, ResourceRequest request,\n      Container container) {\n    try {\n      readLock.lock();\n\n      if (isStopped) {\n        return null;\n      }\n\n      // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n      // request without locking the scheduler, hence we need to check\n      if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n        return null;\n      }\n\n      // Create RMContainer\n      RMContainer rmContainer \u003d new RMContainerImpl(container,\n          this.getApplicationAttemptId(), node.getNodeID(),\n          appSchedulingInfo.getUser(), this.rmContext,\n          request.getNodeLabelExpression());\n      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n\n      // FIXME, should set when confirmed\n      updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n      return rmContainer;\n    } finally {\n      readLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {}
        }
      ]
    },
    "b8a30f2f170ffbd590e7366c3c944ab4919e40df": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "YARN-3141. Improve locks in SchedulerApplicationAttempt/FSAppAttempt/FiCaSchedulerApp. Contributed by Wangda Tan\n",
      "commitDate": "19/09/16 2:08 AM",
      "commitName": "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3141. Improve locks in SchedulerApplicationAttempt/FSAppAttempt/FiCaSchedulerApp. Contributed by Wangda Tan\n",
          "commitDate": "19/09/16 2:08 AM",
          "commitName": "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
          "commitAuthor": "Jian He",
          "commitDateOld": "02/09/16 3:32 AM",
          "commitNameOld": "05f5c0f631680cffc36a79550c351620615445db",
          "commitAuthorOld": "Varun Vasudev",
          "daysBetweenCommits": 16.94,
          "commitsBetweenForRepo": 79,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,59 @@\n-  public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n+  public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       SchedulerRequestKey schedulerKey, ResourceRequest request,\n       Container container) {\n+    try {\n+      writeLock.lock();\n \n-    if (isStopped) {\n-      return null;\n+      if (isStopped) {\n+        return null;\n+      }\n+\n+      // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n+      // request without locking the scheduler, hence we need to check\n+      if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n+        return null;\n+      }\n+\n+      // Create RMContainer\n+      RMContainer rmContainer \u003d new RMContainerImpl(container,\n+          this.getApplicationAttemptId(), node.getNodeID(),\n+          appSchedulingInfo.getUser(), this.rmContext,\n+          request.getNodeLabelExpression());\n+      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n+\n+      updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n+\n+      // Add it to allContainers list.\n+      newlyAllocatedContainers.add(rmContainer);\n+\n+      ContainerId containerId \u003d container.getId();\n+      liveContainers.put(containerId, rmContainer);\n+\n+      // Update consumption and track allocations\n+      List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n+          type, node, schedulerKey, request, container);\n+\n+      attemptResourceUsage.incUsed(node.getPartition(),\n+          container.getResource());\n+\n+      // Update resource requests related to \"request\" and store in RMContainer\n+      ((RMContainerImpl) rmContainer).setResourceRequests(resourceRequestList);\n+\n+      // Inform the container\n+      rmContainer.handle(\n+          new RMContainerEvent(containerId, RMContainerEventType.START));\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n+            .getApplicationAttemptId() + \" container\u003d\" + containerId + \" host\u003d\"\n+            + container.getNodeId().getHost() + \" type\u003d\" + type);\n+      }\n+      RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n+          \"SchedulerApp\", getApplicationId(), containerId,\n+          container.getResource());\n+\n+      return rmContainer;\n+    } finally {\n+      writeLock.unlock();\n     }\n-    \n-    // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n-    // request without locking the scheduler, hence we need to check\n-    if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n-      return null;\n-    }\n-\n-    // Create RMContainer\n-    RMContainer rmContainer \u003d\n-        new RMContainerImpl(container, this.getApplicationAttemptId(),\n-            node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n-            request.getNodeLabelExpression());\n-    ((RMContainerImpl)rmContainer).setQueueName(this.getQueueName());\n-\n-    updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n-\n-    // Add it to allContainers list.\n-    newlyAllocatedContainers.add(rmContainer);\n-\n-    ContainerId containerId \u003d container.getId();\n-    liveContainers.put(containerId, rmContainer);\n-\n-    // Update consumption and track allocations\n-    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n-        type, node, schedulerKey, request, container);\n-\n-    attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n-\n-    // Update resource requests related to \"request\" and store in RMContainer\n-    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n-\n-    // Inform the container\n-    rmContainer.handle(\n-        new RMContainerEvent(containerId, RMContainerEventType.START));\n-\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n-          + containerId.getApplicationAttemptId()\n-          + \" container\u003d\" + containerId + \" host\u003d\"\n-          + container.getNodeId().getHost() + \" type\u003d\" + type);\n-    }\n-    RMAuditLogger.logSuccess(getUser(),\n-        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n-        getApplicationId(), containerId, container.getResource());\n-    \n-    return rmContainer;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      SchedulerRequestKey schedulerKey, ResourceRequest request,\n      Container container) {\n    try {\n      writeLock.lock();\n\n      if (isStopped) {\n        return null;\n      }\n\n      // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n      // request without locking the scheduler, hence we need to check\n      if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n        return null;\n      }\n\n      // Create RMContainer\n      RMContainer rmContainer \u003d new RMContainerImpl(container,\n          this.getApplicationAttemptId(), node.getNodeID(),\n          appSchedulingInfo.getUser(), this.rmContext,\n          request.getNodeLabelExpression());\n      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n\n      updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n      // Add it to allContainers list.\n      newlyAllocatedContainers.add(rmContainer);\n\n      ContainerId containerId \u003d container.getId();\n      liveContainers.put(containerId, rmContainer);\n\n      // Update consumption and track allocations\n      List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n          type, node, schedulerKey, request, container);\n\n      attemptResourceUsage.incUsed(node.getPartition(),\n          container.getResource());\n\n      // Update resource requests related to \"request\" and store in RMContainer\n      ((RMContainerImpl) rmContainer).setResourceRequests(resourceRequestList);\n\n      // Inform the container\n      rmContainer.handle(\n          new RMContainerEvent(containerId, RMContainerEventType.START));\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n            .getApplicationAttemptId() + \" container\u003d\" + containerId + \" host\u003d\"\n            + container.getNodeId().getHost() + \" type\u003d\" + type);\n      }\n      RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n          \"SchedulerApp\", getApplicationId(), containerId,\n          container.getResource());\n\n      return rmContainer;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3141. Improve locks in SchedulerApplicationAttempt/FSAppAttempt/FiCaSchedulerApp. Contributed by Wangda Tan\n",
          "commitDate": "19/09/16 2:08 AM",
          "commitName": "b8a30f2f170ffbd590e7366c3c944ab4919e40df",
          "commitAuthor": "Jian He",
          "commitDateOld": "02/09/16 3:32 AM",
          "commitNameOld": "05f5c0f631680cffc36a79550c351620615445db",
          "commitAuthorOld": "Varun Vasudev",
          "daysBetweenCommits": 16.94,
          "commitsBetweenForRepo": 79,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,59 @@\n-  public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n+  public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       SchedulerRequestKey schedulerKey, ResourceRequest request,\n       Container container) {\n+    try {\n+      writeLock.lock();\n \n-    if (isStopped) {\n-      return null;\n+      if (isStopped) {\n+        return null;\n+      }\n+\n+      // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n+      // request without locking the scheduler, hence we need to check\n+      if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n+        return null;\n+      }\n+\n+      // Create RMContainer\n+      RMContainer rmContainer \u003d new RMContainerImpl(container,\n+          this.getApplicationAttemptId(), node.getNodeID(),\n+          appSchedulingInfo.getUser(), this.rmContext,\n+          request.getNodeLabelExpression());\n+      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n+\n+      updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n+\n+      // Add it to allContainers list.\n+      newlyAllocatedContainers.add(rmContainer);\n+\n+      ContainerId containerId \u003d container.getId();\n+      liveContainers.put(containerId, rmContainer);\n+\n+      // Update consumption and track allocations\n+      List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n+          type, node, schedulerKey, request, container);\n+\n+      attemptResourceUsage.incUsed(node.getPartition(),\n+          container.getResource());\n+\n+      // Update resource requests related to \"request\" and store in RMContainer\n+      ((RMContainerImpl) rmContainer).setResourceRequests(resourceRequestList);\n+\n+      // Inform the container\n+      rmContainer.handle(\n+          new RMContainerEvent(containerId, RMContainerEventType.START));\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n+            .getApplicationAttemptId() + \" container\u003d\" + containerId + \" host\u003d\"\n+            + container.getNodeId().getHost() + \" type\u003d\" + type);\n+      }\n+      RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n+          \"SchedulerApp\", getApplicationId(), containerId,\n+          container.getResource());\n+\n+      return rmContainer;\n+    } finally {\n+      writeLock.unlock();\n     }\n-    \n-    // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n-    // request without locking the scheduler, hence we need to check\n-    if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n-      return null;\n-    }\n-\n-    // Create RMContainer\n-    RMContainer rmContainer \u003d\n-        new RMContainerImpl(container, this.getApplicationAttemptId(),\n-            node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n-            request.getNodeLabelExpression());\n-    ((RMContainerImpl)rmContainer).setQueueName(this.getQueueName());\n-\n-    updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n-\n-    // Add it to allContainers list.\n-    newlyAllocatedContainers.add(rmContainer);\n-\n-    ContainerId containerId \u003d container.getId();\n-    liveContainers.put(containerId, rmContainer);\n-\n-    // Update consumption and track allocations\n-    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n-        type, node, schedulerKey, request, container);\n-\n-    attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n-\n-    // Update resource requests related to \"request\" and store in RMContainer\n-    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n-\n-    // Inform the container\n-    rmContainer.handle(\n-        new RMContainerEvent(containerId, RMContainerEventType.START));\n-\n-    if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n-          + containerId.getApplicationAttemptId()\n-          + \" container\u003d\" + containerId + \" host\u003d\"\n-          + container.getNodeId().getHost() + \" type\u003d\" + type);\n-    }\n-    RMAuditLogger.logSuccess(getUser(),\n-        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n-        getApplicationId(), containerId, container.getResource());\n-    \n-    return rmContainer;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      SchedulerRequestKey schedulerKey, ResourceRequest request,\n      Container container) {\n    try {\n      writeLock.lock();\n\n      if (isStopped) {\n        return null;\n      }\n\n      // Required sanity check - AM can call \u0027allocate\u0027 to update resource\n      // request without locking the scheduler, hence we need to check\n      if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n        return null;\n      }\n\n      // Create RMContainer\n      RMContainer rmContainer \u003d new RMContainerImpl(container,\n          this.getApplicationAttemptId(), node.getNodeID(),\n          appSchedulingInfo.getUser(), this.rmContext,\n          request.getNodeLabelExpression());\n      ((RMContainerImpl) rmContainer).setQueueName(this.getQueueName());\n\n      updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n      // Add it to allContainers list.\n      newlyAllocatedContainers.add(rmContainer);\n\n      ContainerId containerId \u003d container.getId();\n      liveContainers.put(containerId, rmContainer);\n\n      // Update consumption and track allocations\n      List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n          type, node, schedulerKey, request, container);\n\n      attemptResourceUsage.incUsed(node.getPartition(),\n          container.getResource());\n\n      // Update resource requests related to \"request\" and store in RMContainer\n      ((RMContainerImpl) rmContainer).setResourceRequests(resourceRequestList);\n\n      // Inform the container\n      rmContainer.handle(\n          new RMContainerEvent(containerId, RMContainerEventType.START));\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"allocate: applicationAttemptId\u003d\" + containerId\n            .getApplicationAttemptId() + \" container\u003d\" + containerId + \" host\u003d\"\n            + container.getNodeId().getHost() + \" type\u003d\" + type);\n      }\n      RMAuditLogger.logSuccess(getUser(), AuditConstants.ALLOC_CONTAINER,\n          \"SchedulerApp\", getApplicationId(), containerId,\n          container.getResource());\n\n      return rmContainer;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {}
        }
      ]
    },
    "5aace38b748ba71aaadd2c4d64eba8dc1f816828": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-5392. Replace use of Priority in the Scheduling infrastructure with an opaque ShedulerRequestKey. (asuresh and subru)\n",
      "commitDate": "26/07/16 2:54 PM",
      "commitName": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-5392. Replace use of Priority in the Scheduling infrastructure with an opaque ShedulerRequestKey. (asuresh and subru)\n",
          "commitDate": "26/07/16 2:54 PM",
          "commitName": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "05/05/16 12:56 PM",
          "commitNameOld": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 82.08,
          "commitsBetweenForRepo": 671,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,54 @@\n   public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n-      Priority priority, ResourceRequest request, \n+      SchedulerRequestKey schedulerKey, ResourceRequest request,\n       Container container) {\n \n     if (isStopped) {\n       return null;\n     }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n-    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n+    if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n       return null;\n     }\n-    \n+\n     // Create RMContainer\n     RMContainer rmContainer \u003d\n         new RMContainerImpl(container, this.getApplicationAttemptId(),\n             node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n             request.getNodeLabelExpression());\n     ((RMContainerImpl)rmContainer).setQueueName(this.getQueueName());\n \n     updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n \n     ContainerId containerId \u003d container.getId();\n     liveContainers.put(containerId, rmContainer);\n \n     // Update consumption and track allocations\n     List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n-        type, node, priority, request, container);\n+        type, node, schedulerKey, request, container);\n \n     attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n \n     // Update resource requests related to \"request\" and store in RMContainer\n     ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(containerId, RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + containerId.getApplicationAttemptId()\n           + \" container\u003d\" + containerId + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(),\n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n         getApplicationId(), containerId, container.getResource());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      SchedulerRequestKey schedulerKey, ResourceRequest request,\n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n      return null;\n    }\n\n    // Create RMContainer\n    RMContainer rmContainer \u003d\n        new RMContainerImpl(container, this.getApplicationAttemptId(),\n            node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n            request.getNodeLabelExpression());\n    ((RMContainerImpl)rmContainer).setQueueName(this.getQueueName());\n\n    updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n\n    ContainerId containerId \u003d container.getId();\n    liveContainers.put(containerId, rmContainer);\n\n    // Update consumption and track allocations\n    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n        type, node, schedulerKey, request, container);\n\n    attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n\n    // Update resource requests related to \"request\" and store in RMContainer\n    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(containerId, RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + containerId.getApplicationAttemptId()\n          + \" container\u003d\" + containerId + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(),\n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n        getApplicationId(), containerId, container.getResource());\n    \n    return rmContainer;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {
            "oldValue": "[type-NodeType, node-FiCaSchedulerNode, priority-Priority, request-ResourceRequest, container-Container]",
            "newValue": "[type-NodeType, node-FiCaSchedulerNode, schedulerKey-SchedulerRequestKey, request-ResourceRequest, container-Container]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-5392. Replace use of Priority in the Scheduling infrastructure with an opaque ShedulerRequestKey. (asuresh and subru)\n",
          "commitDate": "26/07/16 2:54 PM",
          "commitName": "5aace38b748ba71aaadd2c4d64eba8dc1f816828",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "05/05/16 12:56 PM",
          "commitNameOld": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 82.08,
          "commitsBetweenForRepo": 671,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,54 +1,54 @@\n   public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n-      Priority priority, ResourceRequest request, \n+      SchedulerRequestKey schedulerKey, ResourceRequest request,\n       Container container) {\n \n     if (isStopped) {\n       return null;\n     }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n-    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n+    if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n       return null;\n     }\n-    \n+\n     // Create RMContainer\n     RMContainer rmContainer \u003d\n         new RMContainerImpl(container, this.getApplicationAttemptId(),\n             node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n             request.getNodeLabelExpression());\n     ((RMContainerImpl)rmContainer).setQueueName(this.getQueueName());\n \n     updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n \n     ContainerId containerId \u003d container.getId();\n     liveContainers.put(containerId, rmContainer);\n \n     // Update consumption and track allocations\n     List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n-        type, node, priority, request, container);\n+        type, node, schedulerKey, request, container);\n \n     attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n \n     // Update resource requests related to \"request\" and store in RMContainer\n     ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(containerId, RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + containerId.getApplicationAttemptId()\n           + \" container\u003d\" + containerId + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(),\n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n         getApplicationId(), containerId, container.getResource());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      SchedulerRequestKey schedulerKey, ResourceRequest request,\n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(schedulerKey) \u003c\u003d 0) {\n      return null;\n    }\n\n    // Create RMContainer\n    RMContainer rmContainer \u003d\n        new RMContainerImpl(container, this.getApplicationAttemptId(),\n            node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n            request.getNodeLabelExpression());\n    ((RMContainerImpl)rmContainer).setQueueName(this.getQueueName());\n\n    updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n\n    ContainerId containerId \u003d container.getId();\n    liveContainers.put(containerId, rmContainer);\n\n    // Update consumption and track allocations\n    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n        type, node, schedulerKey, request, container);\n\n    attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n\n    // Update resource requests related to \"request\" and store in RMContainer\n    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(containerId, RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + containerId.getApplicationAttemptId()\n          + \" container\u003d\" + containerId + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(),\n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n        getApplicationId(), containerId, container.getResource());\n    \n    return rmContainer;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {}
        }
      ]
    },
    "bb62e0592566b2fcae7136b30972aad2d3ac55b0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4390. Do surgical preemption based on reserved container in CapacityScheduler. Contributed by Wangda Tan\n",
      "commitDate": "05/05/16 12:56 PM",
      "commitName": "bb62e0592566b2fcae7136b30972aad2d3ac55b0",
      "commitAuthor": "Jian He",
      "commitDateOld": "03/05/16 1:03 PM",
      "commitNameOld": "ed54f5f1ff7862f8216f77d5ea8f9ccea674ccd1",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 1.99,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,54 @@\n   public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n \n     if (isStopped) {\n       return null;\n     }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d\n         new RMContainerImpl(container, this.getApplicationAttemptId(),\n             node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n             request.getNodeLabelExpression());\n+    ((RMContainerImpl)rmContainer).setQueueName(this.getQueueName());\n \n     updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n \n     ContainerId containerId \u003d container.getId();\n     liveContainers.put(containerId, rmContainer);\n \n     // Update consumption and track allocations\n     List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n         type, node, priority, request, container);\n \n     attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n \n     // Update resource requests related to \"request\" and store in RMContainer\n     ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(containerId, RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + containerId.getApplicationAttemptId()\n           + \" container\u003d\" + containerId + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(),\n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n         getApplicationId(), containerId, container.getResource());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d\n        new RMContainerImpl(container, this.getApplicationAttemptId(),\n            node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n            request.getNodeLabelExpression());\n    ((RMContainerImpl)rmContainer).setQueueName(this.getQueueName());\n\n    updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n\n    ContainerId containerId \u003d container.getId();\n    liveContainers.put(containerId, rmContainer);\n\n    // Update consumption and track allocations\n    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n        type, node, priority, request, container);\n\n    attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n\n    // Update resource requests related to \"request\" and store in RMContainer\n    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(containerId, RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + containerId.getApplicationAttemptId()\n          + \" container\u003d\" + containerId + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(),\n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n        getApplicationId(), containerId, container.getResource());\n    \n    return rmContainer;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "ed54f5f1ff7862f8216f77d5ea8f9ccea674ccd1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5003. Add container resource to RM audit log. Contributed by Nathan Roberts\n",
      "commitDate": "03/05/16 1:03 PM",
      "commitName": "ed54f5f1ff7862f8216f77d5ea8f9ccea674ccd1",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "16/04/16 10:47 PM",
      "commitNameOld": "fdc46bfb37776d8c41b68f6c33a2379d0f329994",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 16.59,
      "commitsBetweenForRepo": 92,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,53 @@\n   public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n \n     if (isStopped) {\n       return null;\n     }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d\n         new RMContainerImpl(container, this.getApplicationAttemptId(),\n             node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n             request.getNodeLabelExpression());\n \n     updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n \n     ContainerId containerId \u003d container.getId();\n     liveContainers.put(containerId, rmContainer);\n \n     // Update consumption and track allocations\n     List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n         type, node, priority, request, container);\n \n     attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n \n     // Update resource requests related to \"request\" and store in RMContainer\n     ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(containerId, RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + containerId.getApplicationAttemptId()\n           + \" container\u003d\" + containerId + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(),\n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n-        getApplicationId(), containerId);\n+        getApplicationId(), containerId, container.getResource());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d\n        new RMContainerImpl(container, this.getApplicationAttemptId(),\n            node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n            request.getNodeLabelExpression());\n\n    updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n\n    ContainerId containerId \u003d container.getId();\n    liveContainers.put(containerId, rmContainer);\n\n    // Update consumption and track allocations\n    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n        type, node, priority, request, container);\n\n    attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n\n    // Update resource requests related to \"request\" and store in RMContainer\n    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(containerId, RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + containerId.getApplicationAttemptId()\n          + \" container\u003d\" + containerId + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(),\n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n        getApplicationId(), containerId, container.getResource());\n    \n    return rmContainer;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "ae14e5d07f1b6702a5160637438028bb03d9387e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4108. CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n\n(cherry picked from commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913)\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "ae14e5d07f1b6702a5160637438028bb03d9387e",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 5:02 PM",
      "commitNameOld": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,53 @@\n-  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n+  public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n \n     if (isStopped) {\n       return null;\n     }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d\n         new RMContainerImpl(container, this.getApplicationAttemptId(),\n             node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n             request.getNodeLabelExpression());\n \n     updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n-    liveContainers.put(container.getId(), rmContainer);    \n+\n+    ContainerId containerId \u003d container.getId();\n+    liveContainers.put(containerId, rmContainer);\n \n     // Update consumption and track allocations\n     List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n         type, node, priority, request, container);\n \n     attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n \n     // Update resource requests related to \"request\" and store in RMContainer\n     ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n \n     // Inform the container\n     rmContainer.handle(\n-        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n+        new RMContainerEvent(containerId, RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n-          + container.getId().getApplicationAttemptId() \n-          + \" container\u003d\" + container.getId() + \" host\u003d\"\n+          + containerId.getApplicationAttemptId()\n+          + \" container\u003d\" + containerId + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(),\n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n-        getApplicationId(), container.getId());\n+        getApplicationId(), containerId);\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d\n        new RMContainerImpl(container, this.getApplicationAttemptId(),\n            node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n            request.getNodeLabelExpression());\n\n    updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n\n    ContainerId containerId \u003d container.getId();\n    liveContainers.put(containerId, rmContainer);\n\n    // Update consumption and track allocations\n    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n        type, node, priority, request, container);\n\n    attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n\n    // Update resource requests related to \"request\" and store in RMContainer\n    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(containerId, RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + containerId.getApplicationAttemptId()\n          + \" container\u003d\" + containerId + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(),\n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n        getApplicationId(), containerId);\n    \n    return rmContainer;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "fa7a43529d529f0006c8033c2003f15b9b93f103": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\"\n\nThis reverts commit 7e8c9beb4156dcaeb3a11e60aaa06d2370626913.\n",
      "commitDate": "16/03/16 5:02 PM",
      "commitName": "fa7a43529d529f0006c8033c2003f15b9b93f103",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "16/03/16 4:59 PM",
      "commitNameOld": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,51 @@\n-  public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n+  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n \n     if (isStopped) {\n       return null;\n     }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d\n         new RMContainerImpl(container, this.getApplicationAttemptId(),\n             node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n             request.getNodeLabelExpression());\n \n     updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n-\n-    ContainerId containerId \u003d container.getId();\n-    liveContainers.put(containerId, rmContainer);\n+    liveContainers.put(container.getId(), rmContainer);    \n \n     // Update consumption and track allocations\n     List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n         type, node, priority, request, container);\n \n     attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n \n     // Update resource requests related to \"request\" and store in RMContainer\n     ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n \n     // Inform the container\n     rmContainer.handle(\n-        new RMContainerEvent(containerId, RMContainerEventType.START));\n+        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n-          + containerId.getApplicationAttemptId()\n-          + \" container\u003d\" + containerId + \" host\u003d\"\n+          + container.getId().getApplicationAttemptId() \n+          + \" container\u003d\" + container.getId() + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(),\n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n-        getApplicationId(), containerId);\n+        getApplicationId(), container.getId());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d\n        new RMContainerImpl(container, this.getApplicationAttemptId(),\n            node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n            request.getNodeLabelExpression());\n\n    updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);    \n\n    // Update consumption and track allocations\n    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n        type, node, priority, request, container);\n\n    attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n\n    // Update resource requests related to \"request\" and store in RMContainer\n    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + container.getId().getApplicationAttemptId() \n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(),\n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n        getApplicationId(), container.getId());\n    \n    return rmContainer;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "7e8c9beb4156dcaeb3a11e60aaa06d2370626913": {
      "type": "Ybodychange",
      "commitMessage": "CapacityScheduler: Improve preemption to only kill containers that would satisfy the incoming request. (Wangda Tan)\n",
      "commitDate": "16/03/16 4:59 PM",
      "commitName": "7e8c9beb4156dcaeb3a11e60aaa06d2370626913",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "28/02/16 9:35 AM",
      "commitNameOld": "f9692770a58af0ab082eb7f15da9cbdcd177605b",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 17.27,
      "commitsBetweenForRepo": 107,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,53 @@\n-  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n+  public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n \n     if (isStopped) {\n       return null;\n     }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d\n         new RMContainerImpl(container, this.getApplicationAttemptId(),\n             node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n             request.getNodeLabelExpression());\n \n     updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n-    liveContainers.put(container.getId(), rmContainer);    \n+\n+    ContainerId containerId \u003d container.getId();\n+    liveContainers.put(containerId, rmContainer);\n \n     // Update consumption and track allocations\n     List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n         type, node, priority, request, container);\n \n     attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n \n     // Update resource requests related to \"request\" and store in RMContainer\n     ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n \n     // Inform the container\n     rmContainer.handle(\n-        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n+        new RMContainerEvent(containerId, RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n-          + container.getId().getApplicationAttemptId() \n-          + \" container\u003d\" + container.getId() + \" host\u003d\"\n+          + containerId.getApplicationAttemptId()\n+          + \" container\u003d\" + containerId + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(),\n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n-        getApplicationId(), container.getId());\n+        getApplicationId(), containerId);\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d\n        new RMContainerImpl(container, this.getApplicationAttemptId(),\n            node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n            request.getNodeLabelExpression());\n\n    updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n\n    ContainerId containerId \u003d container.getId();\n    liveContainers.put(containerId, rmContainer);\n\n    // Update consumption and track allocations\n    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n        type, node, priority, request, container);\n\n    attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n\n    // Update resource requests related to \"request\" and store in RMContainer\n    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(containerId, RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + containerId.getApplicationAttemptId()\n          + \" container\u003d\" + containerId + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(),\n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n        getApplicationId(), containerId);\n    \n    return rmContainer;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3946. Update exact reason as to why a submitted app is in ACCEPTED state to app\u0027s diagnostic message. (Naganarasimha G R via wangda)\n",
      "commitDate": "14/12/15 10:52 AM",
      "commitName": "6cb0af3c39a5d49cb2f7911ee21363a9542ca2d7",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "26/10/15 4:44 PM",
      "commitNameOld": "56e4f6237ae8b1852e82b186e08db3934f79a9db",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 48.8,
      "commitsBetweenForRepo": 328,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,51 @@\n   synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n \n     if (isStopped) {\n       return null;\n     }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d\n         new RMContainerImpl(container, this.getApplicationAttemptId(),\n             node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n             request.getNodeLabelExpression());\n \n+    updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n+\n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n     liveContainers.put(container.getId(), rmContainer);    \n \n     // Update consumption and track allocations\n     List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n         type, node, priority, request, container);\n \n     attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n \n     // Update resource requests related to \"request\" and store in RMContainer\n     ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(container.getId(), RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + container.getId().getApplicationAttemptId() \n           + \" container\u003d\" + container.getId() + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(),\n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n         getApplicationId(), container.getId());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d\n        new RMContainerImpl(container, this.getApplicationAttemptId(),\n            node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n            request.getNodeLabelExpression());\n\n    updateAMContainerDiagnostics(AMState.ASSIGNED, null);\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);    \n\n    // Update consumption and track allocations\n    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n        type, node, priority, request, container);\n\n    attemptResourceUsage.incUsed(node.getPartition(), container.getResource());\n\n    // Update resource requests related to \"request\" and store in RMContainer\n    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + container.getId().getApplicationAttemptId() \n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(),\n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\",\n        getApplicationId(), container.getId());\n    \n    return rmContainer;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "1b89a3e173f8e905074ed6714a7be5c003c0e2c4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3354. Add node label expression in ContainerTokenIdentifier to support RM recovery. Contributed by Wangda Tan\n",
      "commitDate": "15/04/15 1:57 PM",
      "commitName": "1b89a3e173f8e905074ed6714a7be5c003c0e2c4",
      "commitAuthor": "Jian He",
      "commitDateOld": "20/03/15 1:54 PM",
      "commitNameOld": "586348e4cbf197188057d6b843a6701cfffdaff3",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 26.0,
      "commitsBetweenForRepo": 224,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,49 @@\n   synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n \n     if (isStopped) {\n       return null;\n     }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n-    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n-        .getApplicationAttemptId(), node.getNodeID(),\n-        appSchedulingInfo.getUser(), this.rmContext);\n+    RMContainer rmContainer \u003d\n+        new RMContainerImpl(container, this.getApplicationAttemptId(),\n+            node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n+            request.getNodeLabelExpression());\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n     liveContainers.put(container.getId(), rmContainer);    \n \n     // Update consumption and track allocations\n     List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n         type, node, priority, request, container);\n     attemptResourceUsage.incUsed(node.getPartition(),\n         container.getResource());\n     \n     // Update resource requests related to \"request\" and store in RMContainer \n     ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(container.getId(), RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + container.getId().getApplicationAttemptId() \n           + \" container\u003d\" + container.getId() + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(), \n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n         getApplicationId(), container.getId());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d\n        new RMContainerImpl(container, this.getApplicationAttemptId(),\n            node.getNodeID(), appSchedulingInfo.getUser(), this.rmContext,\n            request.getNodeLabelExpression());\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);    \n\n    // Update consumption and track allocations\n    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n        type, node, priority, request, container);\n    attemptResourceUsage.incUsed(node.getPartition(),\n        container.getResource());\n    \n    // Update resource requests related to \"request\" and store in RMContainer \n    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + container.getId().getApplicationAttemptId() \n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(), \n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n        getApplicationId(), container.getId());\n    \n    return rmContainer;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "586348e4cbf197188057d6b843a6701cfffdaff3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3356. Capacity Scheduler FiCaSchedulerApp should use ResourceUsage to track used-resources-by-label. Contributed by Wangda Tan\n",
      "commitDate": "20/03/15 1:54 PM",
      "commitName": "586348e4cbf197188057d6b843a6701cfffdaff3",
      "commitAuthor": "Jian He",
      "commitDateOld": "17/03/15 9:30 PM",
      "commitNameOld": "658097d6da1b1aac8e01db459f0c3b456e99652f",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 2.68,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,48 @@\n   synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n \n     if (isStopped) {\n       return null;\n     }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d new RMContainerImpl(container, this\n         .getApplicationAttemptId(), node.getNodeID(),\n         appSchedulingInfo.getUser(), this.rmContext);\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n     liveContainers.put(container.getId(), rmContainer);    \n \n     // Update consumption and track allocations\n     List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n         type, node, priority, request, container);\n-    Resources.addTo(currentConsumption, container.getResource());\n+    attemptResourceUsage.incUsed(node.getPartition(),\n+        container.getResource());\n     \n     // Update resource requests related to \"request\" and store in RMContainer \n     ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(container.getId(), RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + container.getId().getApplicationAttemptId() \n           + \" container\u003d\" + container.getId() + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(), \n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n         getApplicationId(), container.getId());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n        .getApplicationAttemptId(), node.getNodeID(),\n        appSchedulingInfo.getUser(), this.rmContext);\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);    \n\n    // Update consumption and track allocations\n    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n        type, node, priority, request, container);\n    attemptResourceUsage.incUsed(node.getPartition(),\n        container.getResource());\n    \n    // Update resource requests related to \"request\" and store in RMContainer \n    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + container.getId().getApplicationAttemptId() \n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(), \n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n        getApplicationId(), container.getId());\n    \n    return rmContainer;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "43589a8df70d4dbaf86609961e27cc4e23dda993": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1408 Preemption caused Invalid State Event: ACQUIRED at KILLED and caused a task timeout for 30mins. (Sunil G via mayank)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1610860 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/07/14 2:48 PM",
      "commitName": "43589a8df70d4dbaf86609961e27cc4e23dda993",
      "commitAuthor": "Mayank Bansal",
      "commitDateOld": "19/02/14 3:39 PM",
      "commitNameOld": "5fd5c9900cfd299428acbc8dff767273e44647c0",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 145.92,
      "commitsBetweenForRepo": 979,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,47 @@\n   synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n \n     if (isStopped) {\n       return null;\n     }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d new RMContainerImpl(container, this\n         .getApplicationAttemptId(), node.getNodeID(),\n         appSchedulingInfo.getUser(), this.rmContext);\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n     liveContainers.put(container.getId(), rmContainer);    \n \n     // Update consumption and track allocations\n-    appSchedulingInfo.allocate(type, node, priority, request, container);\n+    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n+        type, node, priority, request, container);\n     Resources.addTo(currentConsumption, container.getResource());\n+    \n+    // Update resource requests related to \"request\" and store in RMContainer \n+    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(container.getId(), RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + container.getId().getApplicationAttemptId() \n           + \" container\u003d\" + container.getId() + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(), \n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n         getApplicationId(), container.getId());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n        .getApplicationAttemptId(), node.getNodeID(),\n        appSchedulingInfo.getUser(), this.rmContext);\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);    \n\n    // Update consumption and track allocations\n    List\u003cResourceRequest\u003e resourceRequestList \u003d appSchedulingInfo.allocate(\n        type, node, priority, request, container);\n    Resources.addTo(currentConsumption, container.getResource());\n    \n    // Update resource requests related to \"request\" and store in RMContainer \n    ((RMContainerImpl)rmContainer).setResourceRequests(resourceRequestList);\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + container.getId().getApplicationAttemptId() \n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(), \n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n        getApplicationId(), container.getId());\n    \n    return rmContainer;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "cbee889711eddc5c67a61df4a6531b4ab3cd205a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-321. Merging YARN-321 branch to trunk.\nsvn merge ../branches/YARN-321\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561452 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/14 8:51 PM",
      "commitName": "cbee889711eddc5c67a61df4a6531b4ab3cd205a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/01/14 12:19 PM",
      "commitNameOld": "a45017a5f17ec11814db7e206d1e80aaa4dd8d8f",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 23.36,
      "commitsBetweenForRepo": 112,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,43 @@\n   synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n \n     if (isStopped) {\n       return null;\n     }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d new RMContainerImpl(container, this\n-        .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n-        .getDispatcher().getEventHandler(), this.rmContext\n-        .getContainerAllocationExpirer());\n+        .getApplicationAttemptId(), node.getNodeID(),\n+        appSchedulingInfo.getUser(), this.rmContext);\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n     liveContainers.put(container.getId(), rmContainer);    \n \n     // Update consumption and track allocations\n     appSchedulingInfo.allocate(type, node, priority, request, container);\n     Resources.addTo(currentConsumption, container.getResource());\n \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(container.getId(), RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + container.getId().getApplicationAttemptId() \n           + \" container\u003d\" + container.getId() + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(), \n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n         getApplicationId(), container.getId());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n        .getApplicationAttemptId(), node.getNodeID(),\n        appSchedulingInfo.getUser(), this.rmContext);\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);    \n\n    // Update consumption and track allocations\n    appSchedulingInfo.allocate(type, node, priority, request, container);\n    Resources.addTo(currentConsumption, container.getResource());\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + container.getId().getApplicationAttemptId() \n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(), \n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n        getApplicationId(), container.getId());\n    \n    return rmContainer;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "01aabf73639785a29d1651f2e268cec04a8b9b94": {
      "type": "Ybodychange",
      "commitMessage": "YARN-460. CS user left in list of active users for the queue even when application finished (tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1462486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/03/13 7:36 AM",
      "commitName": "01aabf73639785a29d1651f2e268cec04a8b9b94",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "28/03/13 12:44 PM",
      "commitNameOld": "520033b1cd81c76b38fcdcfcfeed16158db4bbba",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 0.79,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,44 @@\n   synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n+\n+    if (isStopped) {\n+      return null;\n+    }\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d new RMContainerImpl(container, this\n         .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n         .getDispatcher().getEventHandler(), this.rmContext\n         .getContainerAllocationExpirer());\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n     liveContainers.put(container.getId(), rmContainer);    \n \n     // Update consumption and track allocations\n     appSchedulingInfo.allocate(type, node, priority, request, container);\n     Resources.addTo(currentConsumption, container.getResource());\n \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(container.getId(), RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + container.getId().getApplicationAttemptId() \n           + \" container\u003d\" + container.getId() + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(), \n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n         getApplicationId(), container.getId());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n\n    if (isStopped) {\n      return null;\n    }\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n        .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n        .getDispatcher().getEventHandler(), this.rmContext\n        .getContainerAllocationExpirer());\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);    \n\n    // Update consumption and track allocations\n    appSchedulingInfo.allocate(type, node, priority, request, container);\n    Resources.addTo(currentConsumption, container.getResource());\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + container.getId().getApplicationAttemptId() \n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(), \n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n        getApplicationId(), container.getId());\n    \n    return rmContainer;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {}
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n        .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n        .getDispatcher().getEventHandler(), this.rmContext\n        .getContainerAllocationExpirer());\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);    \n\n    // Update consumption and track allocations\n    appSchedulingInfo.allocate(type, node, priority, request, container);\n    Resources.addTo(currentConsumption, container.getResource());\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + container.getId().getApplicationAttemptId() \n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(), \n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n        getApplicationId(), container.getId());\n    \n    return rmContainer;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java"
      }
    },
    "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76": {
      "type": "Ymultichange(Yfilerename,Yparameterchange)",
      "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "16/07/12 6:43 PM",
      "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
      "commitAuthor": "Arun Murthy",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/12 6:43 PM",
          "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "16/07/12 3:41 PM",
          "commitNameOld": "30099efb3525265f8b9fccd2709d45327f5b6724",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,40 @@\n-  synchronized public RMContainer allocate(NodeType type, SchedulerNode node,\n+  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d new RMContainerImpl(container, this\n         .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n         .getDispatcher().getEventHandler(), this.rmContext\n         .getContainerAllocationExpirer());\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n     liveContainers.put(container.getId(), rmContainer);    \n \n     // Update consumption and track allocations\n     appSchedulingInfo.allocate(type, node, priority, request, container);\n     Resources.addTo(currentConsumption, container.getResource());\n \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(container.getId(), RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + container.getId().getApplicationAttemptId() \n           + \" container\u003d\" + container.getId() + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(), \n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n         getApplicationId(), container.getId());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n        .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n        .getDispatcher().getEventHandler(), this.rmContext\n        .getContainerAllocationExpirer());\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);    \n\n    // Update consumption and track allocations\n    appSchedulingInfo.allocate(type, node, priority, request, container);\n    Resources.addTo(currentConsumption, container.getResource());\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + container.getId().getApplicationAttemptId() \n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(), \n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n        getApplicationId(), container.getId());\n    \n    return rmContainer;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {
            "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApp.java",
            "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java"
          }
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "MAPREDUCE-4440. Changed SchedulerApp and SchedulerNode to be a minimal interface to allow schedulers to maintain their own.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1362332 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "16/07/12 6:43 PM",
          "commitName": "7f2b1eadc1b0807ec1302a0c3488bf6e7a59bc76",
          "commitAuthor": "Arun Murthy",
          "commitDateOld": "16/07/12 3:41 PM",
          "commitNameOld": "30099efb3525265f8b9fccd2709d45327f5b6724",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 0.13,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,40 +1,40 @@\n-  synchronized public RMContainer allocate(NodeType type, SchedulerNode node,\n+  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d new RMContainerImpl(container, this\n         .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n         .getDispatcher().getEventHandler(), this.rmContext\n         .getContainerAllocationExpirer());\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n     liveContainers.put(container.getId(), rmContainer);    \n \n     // Update consumption and track allocations\n     appSchedulingInfo.allocate(type, node, priority, request, container);\n     Resources.addTo(currentConsumption, container.getResource());\n \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(container.getId(), RMContainerEventType.START));\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + container.getId().getApplicationAttemptId() \n           + \" container\u003d\" + container.getId() + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(), \n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n         getApplicationId(), container.getId());\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  synchronized public RMContainer allocate(NodeType type, FiCaSchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n        .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n        .getDispatcher().getEventHandler(), this.rmContext\n        .getContainerAllocationExpirer());\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);    \n\n    // Update consumption and track allocations\n    appSchedulingInfo.allocate(type, node, priority, request, container);\n    Resources.addTo(currentConsumption, container.getResource());\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + container.getId().getApplicationAttemptId() \n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(), \n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n        getApplicationId(), container.getId());\n    \n    return rmContainer;\n  }",
          "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/common/fica/FiCaSchedulerApp.java",
          "extendedDetails": {
            "oldValue": "[type-NodeType, node-SchedulerNode, priority-Priority, request-ResourceRequest, container-Container]",
            "newValue": "[type-NodeType, node-FiCaSchedulerNode, priority-Priority, request-ResourceRequest, container-Container]"
          }
        }
      ]
    },
    "312a7e71001d55f88781e56b331ab1b40a72a980": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3078. Ensure MapReduce AM reports progress correctly for displaying on the RM Web-UI. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1176762 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/09/11 12:31 AM",
      "commitName": "312a7e71001d55f88781e56b331ab1b40a72a980",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "12/09/11 5:05 PM",
      "commitNameOld": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 15.31,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,40 @@\n   synchronized public RMContainer allocate(NodeType type, SchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d new RMContainerImpl(container, this\n         .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n         .getDispatcher().getEventHandler(), this.rmContext\n         .getContainerAllocationExpirer());\n \n+    // Add it to allContainers list.\n+    newlyAllocatedContainers.add(rmContainer);\n+    liveContainers.put(container.getId(), rmContainer);    \n+\n     // Update consumption and track allocations\n-    \n+    appSchedulingInfo.allocate(type, node, priority, request, container);\n+    Resources.addTo(currentConsumption, container.getResource());\n+\n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(container.getId(), RMContainerEventType.START));\n \n-    Resources.addTo(currentConsumption, container.getResource());\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationAttemptId\u003d\" \n           + container.getId().getApplicationAttemptId() \n           + \" container\u003d\" + container.getId() + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(), \n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n         getApplicationId(), container.getId());\n-\n-    // Add it to allContainers list.\n-    newlyAllocatedContainers.add(rmContainer);\n-    liveContainers.put(container.getId(), rmContainer);\n-    \n-    appSchedulingInfo.allocate(type, node, priority, request, container);\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, SchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n        .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n        .getDispatcher().getEventHandler(), this.rmContext\n        .getContainerAllocationExpirer());\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);    \n\n    // Update consumption and track allocations\n    appSchedulingInfo.allocate(type, node, priority, request, container);\n    Resources.addTo(currentConsumption, container.getResource());\n\n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + container.getId().getApplicationAttemptId() \n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(), \n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n        getApplicationId(), container.getId());\n    \n    return rmContainer;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApp.java",
      "extendedDetails": {}
    },
    "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2896. Simplify all apis to in org.apache.hadoop.yarn.api.records.* to be get/set only. Added javadocs to all public records.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1169980 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/09/11 5:05 PM",
      "commitName": "6165875dc6bf67d72fc3ce1d96dfc80ba312d4a1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "11/09/11 10:26 AM",
      "commitNameOld": "817ead65b99f465fc2dfa18072cf23cadf5f05d0",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 1.28,
      "commitsBetweenForRepo": 9,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,41 @@\n   synchronized public RMContainer allocate(NodeType type, SchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d new RMContainerImpl(container, this\n         .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n         .getDispatcher().getEventHandler(), this.rmContext\n         .getContainerAllocationExpirer());\n \n     // Update consumption and track allocations\n     \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(container.getId(), RMContainerEventType.START));\n \n     Resources.addTo(currentConsumption, container.getResource());\n     if (LOG.isDebugEnabled()) {\n-      LOG.debug(\"allocate: applicationId\u003d\" + container.getId().getAppId()\n+      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n+          + container.getId().getApplicationAttemptId() \n           + \" container\u003d\" + container.getId() + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n     RMAuditLogger.logSuccess(getUser(), \n         AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n         getApplicationId(), container.getId());\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n     liveContainers.put(container.getId(), rmContainer);\n     \n     appSchedulingInfo.allocate(type, node, priority, request, container);\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, SchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n        .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n        .getDispatcher().getEventHandler(), this.rmContext\n        .getContainerAllocationExpirer());\n\n    // Update consumption and track allocations\n    \n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    Resources.addTo(currentConsumption, container.getResource());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationAttemptId\u003d\" \n          + container.getId().getApplicationAttemptId() \n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(), \n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n        getApplicationId(), container.getId());\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);\n    \n    appSchedulingInfo.allocate(type, node, priority, request, container);\n    \n    return rmContainer;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApp.java",
      "extendedDetails": {}
    },
    "cdfabf5ae289836968b3d296668593b9500b6f26": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2655. Add audit logs to ResourceManager and NodeManager. Contributed by Thomas Graves.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165949 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/09/11 6:24 PM",
      "commitName": "cdfabf5ae289836968b3d296668593b9500b6f26",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "31/08/11 12:52 PM",
      "commitNameOld": "b9a5fd51904a074a7a33f38266378f0f6f97b531",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 6.23,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,40 @@\n   synchronized public RMContainer allocate(NodeType type, SchedulerNode node,\n       Priority priority, ResourceRequest request, \n       Container container) {\n     \n     // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n     // request without locking the scheduler, hence we need to check\n     if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n       return null;\n     }\n     \n     // Create RMContainer\n     RMContainer rmContainer \u003d new RMContainerImpl(container, this\n         .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n         .getDispatcher().getEventHandler(), this.rmContext\n         .getContainerAllocationExpirer());\n \n     // Update consumption and track allocations\n     \n     // Inform the container\n     rmContainer.handle(\n         new RMContainerEvent(container.getId(), RMContainerEventType.START));\n \n     Resources.addTo(currentConsumption, container.getResource());\n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"allocate: applicationId\u003d\" + container.getId().getAppId()\n           + \" container\u003d\" + container.getId() + \" host\u003d\"\n           + container.getNodeId().getHost() + \" type\u003d\" + type);\n     }\n+    RMAuditLogger.logSuccess(getUser(), \n+        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n+        getApplicationId(), container.getId());\n \n     // Add it to allContainers list.\n     newlyAllocatedContainers.add(rmContainer);\n     liveContainers.put(container.getId(), rmContainer);\n     \n     appSchedulingInfo.allocate(type, node, priority, request, container);\n     \n     return rmContainer;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, SchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n        .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n        .getDispatcher().getEventHandler(), this.rmContext\n        .getContainerAllocationExpirer());\n\n    // Update consumption and track allocations\n    \n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    Resources.addTo(currentConsumption, container.getResource());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationId\u003d\" + container.getId().getAppId()\n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n    RMAuditLogger.logSuccess(getUser(), \n        AuditConstants.ALLOC_CONTAINER, \"SchedulerApp\", \n        getApplicationId(), container.getId());\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);\n    \n    appSchedulingInfo.allocate(type, node, priority, request, container);\n    \n    return rmContainer;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApp.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, SchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n        .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n        .getDispatcher().getEventHandler(), this.rmContext\n        .getContainerAllocationExpirer());\n\n    // Update consumption and track allocations\n    \n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    Resources.addTo(currentConsumption, container.getResource());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationId\u003d\" + container.getId().getAppId()\n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);\n    \n    appSchedulingInfo.allocate(type, node, priority, request, container);\n    \n    return rmContainer;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApp.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApp.java",
        "newPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApp.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,37 @@\n+  synchronized public RMContainer allocate(NodeType type, SchedulerNode node,\n+      Priority priority, ResourceRequest request, \n+      Container container) {\n+    \n+    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n+    // request without locking the scheduler, hence we need to check\n+    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n+      return null;\n+    }\n+    \n+    // Create RMContainer\n+    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n+        .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n+        .getDispatcher().getEventHandler(), this.rmContext\n+        .getContainerAllocationExpirer());\n+\n+    // Update consumption and track allocations\n+    \n+    // Inform the container\n+    rmContainer.handle(\n+        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n+\n+    Resources.addTo(currentConsumption, container.getResource());\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"allocate: applicationId\u003d\" + container.getId().getAppId()\n+          + \" container\u003d\" + container.getId() + \" host\u003d\"\n+          + container.getNodeId().getHost() + \" type\u003d\" + type);\n+    }\n+\n+    // Add it to allContainers list.\n+    newlyAllocatedContainers.add(rmContainer);\n+    liveContainers.put(container.getId(), rmContainer);\n+    \n+    appSchedulingInfo.allocate(type, node, priority, request, container);\n+    \n+    return rmContainer;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized public RMContainer allocate(NodeType type, SchedulerNode node,\n      Priority priority, ResourceRequest request, \n      Container container) {\n    \n    // Required sanity check - AM can call \u0027allocate\u0027 to update resource \n    // request without locking the scheduler, hence we need to check\n    if (getTotalRequiredResources(priority) \u003c\u003d 0) {\n      return null;\n    }\n    \n    // Create RMContainer\n    RMContainer rmContainer \u003d new RMContainerImpl(container, this\n        .getApplicationAttemptId(), node.getNodeID(), this.rmContext\n        .getDispatcher().getEventHandler(), this.rmContext\n        .getContainerAllocationExpirer());\n\n    // Update consumption and track allocations\n    \n    // Inform the container\n    rmContainer.handle(\n        new RMContainerEvent(container.getId(), RMContainerEventType.START));\n\n    Resources.addTo(currentConsumption, container.getResource());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"allocate: applicationId\u003d\" + container.getId().getAppId()\n          + \" container\u003d\" + container.getId() + \" host\u003d\"\n          + container.getNodeId().getHost() + \" type\u003d\" + type);\n    }\n\n    // Add it to allContainers list.\n    newlyAllocatedContainers.add(rmContainer);\n    liveContainers.put(container.getId(), rmContainer);\n    \n    appSchedulingInfo.allocate(type, node, priority, request, container);\n    \n    return rmContainer;\n  }",
      "path": "hadoop-mapreduce/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/SchedulerApp.java"
    }
  }
}