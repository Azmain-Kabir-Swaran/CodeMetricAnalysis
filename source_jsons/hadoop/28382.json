{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AMRMClientRelayer.java",
  "functionName": "allocate",
  "functionId": "allocate___allocateRequest-AllocateRequest",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/AMRMClientRelayer.java",
  "functionStartLine": 309,
  "functionEndLine": 432,
  "numCommitsSeen": 8,
  "timeTaken": 2987,
  "changeHistory": [
    "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a",
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
    "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9",
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f",
    "99948565cb5d5706241d7a8fc591e1617c499e03",
    "3159bffce23abf35754da2d7d51de7d8c2631ae3"
  ],
  "changeHistoryShort": {
    "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a": "Ybodychange",
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09": "Ybodychange",
    "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9": "Ybodychange",
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f": "Ybodychange",
    "99948565cb5d5706241d7a8fc591e1617c499e03": "Ybodychange",
    "3159bffce23abf35754da2d7d51de7d8c2631ae3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8760. [AMRMProxy] Fix concurrent re-register due to YarnRM failover in AMRMClientRelayer. Contributed by Botong Huang.\n",
      "commitDate": "01/10/18 1:12 PM",
      "commitName": "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "12/09/18 11:46 AM",
      "commitNameOld": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 19.06,
      "commitsBetweenForRepo": 185,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,124 +1,124 @@\n   public AllocateResponse allocate(AllocateRequest allocateRequest)\n       throws YarnException, IOException {\n     AllocateResponse allocateResponse \u003d null;\n     long startTime \u003d System.currentTimeMillis();\n     synchronized (this) {\n       if(this.shutdown){\n         throw new YarnException(\"Allocate called after AMRMClientRelayer for \"\n             + \"RM \" + rmId + \" shutdown.\");\n       }\n       addNewAllocateRequest(allocateRequest);\n \n       ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n       for (ResourceRequest r : ask) {\n         // create a copy of ResourceRequest as we might change it while the\n         // RPC layer is using it to send info across\n         askList.add(ResourceRequest.clone(r));\n       }\n \n       allocateRequest \u003d AllocateRequest.newBuilder()\n           .responseId(allocateRequest.getResponseId())\n           .progress(allocateRequest.getProgress()).askList(askList)\n           .releaseList(new ArrayList\u003c\u003e(this.release))\n           .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n               new ArrayList\u003c\u003e(this.blacklistAdditions),\n               new ArrayList\u003c\u003e(this.blacklistRemovals)))\n           .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n           .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n           .build();\n \n       if (this.resetResponseId !\u003d -1) {\n         LOG.info(\"Override allocate responseId from \"\n             + allocateRequest.getResponseId() + \" to \" + this.resetResponseId\n             + \" for \" + this.appId);\n         allocateRequest.setResponseId(this.resetResponseId);\n       }\n     }\n \n     // Do the actual allocate call\n     try {\n       allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n \n       // Heartbeat succeeded, wipe out responseId overriding\n       this.resetResponseId \u003d -1;\n     } catch (ApplicationMasterNotRegisteredException e) {\n       // This is a retriable exception - we will re register and mke a\n       // recursive call to retry\n       LOG.warn(\"ApplicationMaster is out of sync with RM \" + rmId\n           + \" for \" + this.appId + \", hence resyncing.\");\n \n       this.metrics.incrRMMasterSlaveSwitch(this.rmId);\n \n       synchronized (this) {\n         // Add all remotePending data into to-send data structures\n         for (ResourceRequestSet requestSet : this.remotePendingAsks\n             .values()) {\n           for (ResourceRequest rr : requestSet.getRRs()) {\n             addResourceRequestToAsk(rr);\n           }\n         }\n         this.release.addAll(this.remotePendingRelease);\n         this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n         this.change.putAll(this.remotePendingChange);\n         for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n             .values()) {\n           this.schedulingRequest.addAll(reqs);\n         }\n       }\n \n       // re-register with RM, then retry allocate recursively\n-      registerApplicationMaster(this.amRegistrationRequest);\n+      reRegisterApplicationMaster(this.amRegistrationRequest);\n       // Reset responseId after re-register\n       allocateRequest.setResponseId(0);\n       allocateResponse \u003d allocate(allocateRequest);\n       return allocateResponse;\n     } catch (Throwable t) {\n       // Unexpected exception - rethrow and increment heart beat failure metric\n       this.metrics.addHeartbeatFailure(this.rmId,\n           System.currentTimeMillis() - startTime);\n \n       // If RM is complaining about responseId out of sync, force reset next\n       // time\n       if (t instanceof InvalidApplicationMasterRequestException) {\n         int responseId \u003d AMRMClientUtils\n             .parseExpectedResponseIdFromException(t.getMessage());\n         if (responseId !\u003d -1) {\n           this.resetResponseId \u003d responseId;\n           LOG.info(\"ResponseId out of sync with RM, expect \" + responseId\n               + \" but \" + allocateRequest.getResponseId() + \" used by \"\n               + this.appId + \". Will override in the next allocate.\");\n         } else {\n           LOG.warn(\"Failed to parse expected responseId out of exception for \"\n               + this.appId);\n         }\n       }\n \n       throw t;\n     }\n \n     synchronized (this) {\n       if (this.shutdown) {\n         throw new YarnException(\"Allocate call succeeded for \" + this.appId\n             + \" after AMRMClientRelayer for RM \" + rmId + \" shutdown.\");\n       }\n \n       updateMetrics(allocateResponse, startTime);\n \n       AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n           allocateResponse.getAllocatedContainers(),\n           this.remotePendingSchedRequest);\n       AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n           allocateResponse.getContainersFromPreviousAttempts(),\n           this.remotePendingSchedRequest);\n \n       this.ask.clear();\n       this.release.clear();\n \n       this.blacklistAdditions.clear();\n       this.blacklistRemovals.clear();\n \n       this.change.clear();\n       this.schedulingRequest.clear();\n       return allocateResponse;\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest allocateRequest)\n      throws YarnException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    long startTime \u003d System.currentTimeMillis();\n    synchronized (this) {\n      if(this.shutdown){\n        throw new YarnException(\"Allocate called after AMRMClientRelayer for \"\n            + \"RM \" + rmId + \" shutdown.\");\n      }\n      addNewAllocateRequest(allocateRequest);\n\n      ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n      for (ResourceRequest r : ask) {\n        // create a copy of ResourceRequest as we might change it while the\n        // RPC layer is using it to send info across\n        askList.add(ResourceRequest.clone(r));\n      }\n\n      allocateRequest \u003d AllocateRequest.newBuilder()\n          .responseId(allocateRequest.getResponseId())\n          .progress(allocateRequest.getProgress()).askList(askList)\n          .releaseList(new ArrayList\u003c\u003e(this.release))\n          .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n              new ArrayList\u003c\u003e(this.blacklistAdditions),\n              new ArrayList\u003c\u003e(this.blacklistRemovals)))\n          .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n          .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n          .build();\n\n      if (this.resetResponseId !\u003d -1) {\n        LOG.info(\"Override allocate responseId from \"\n            + allocateRequest.getResponseId() + \" to \" + this.resetResponseId\n            + \" for \" + this.appId);\n        allocateRequest.setResponseId(this.resetResponseId);\n      }\n    }\n\n    // Do the actual allocate call\n    try {\n      allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n\n      // Heartbeat succeeded, wipe out responseId overriding\n      this.resetResponseId \u003d -1;\n    } catch (ApplicationMasterNotRegisteredException e) {\n      // This is a retriable exception - we will re register and mke a\n      // recursive call to retry\n      LOG.warn(\"ApplicationMaster is out of sync with RM \" + rmId\n          + \" for \" + this.appId + \", hence resyncing.\");\n\n      this.metrics.incrRMMasterSlaveSwitch(this.rmId);\n\n      synchronized (this) {\n        // Add all remotePending data into to-send data structures\n        for (ResourceRequestSet requestSet : this.remotePendingAsks\n            .values()) {\n          for (ResourceRequest rr : requestSet.getRRs()) {\n            addResourceRequestToAsk(rr);\n          }\n        }\n        this.release.addAll(this.remotePendingRelease);\n        this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n        this.change.putAll(this.remotePendingChange);\n        for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n            .values()) {\n          this.schedulingRequest.addAll(reqs);\n        }\n      }\n\n      // re-register with RM, then retry allocate recursively\n      reRegisterApplicationMaster(this.amRegistrationRequest);\n      // Reset responseId after re-register\n      allocateRequest.setResponseId(0);\n      allocateResponse \u003d allocate(allocateRequest);\n      return allocateResponse;\n    } catch (Throwable t) {\n      // Unexpected exception - rethrow and increment heart beat failure metric\n      this.metrics.addHeartbeatFailure(this.rmId,\n          System.currentTimeMillis() - startTime);\n\n      // If RM is complaining about responseId out of sync, force reset next\n      // time\n      if (t instanceof InvalidApplicationMasterRequestException) {\n        int responseId \u003d AMRMClientUtils\n            .parseExpectedResponseIdFromException(t.getMessage());\n        if (responseId !\u003d -1) {\n          this.resetResponseId \u003d responseId;\n          LOG.info(\"ResponseId out of sync with RM, expect \" + responseId\n              + \" but \" + allocateRequest.getResponseId() + \" used by \"\n              + this.appId + \". Will override in the next allocate.\");\n        } else {\n          LOG.warn(\"Failed to parse expected responseId out of exception for \"\n              + this.appId);\n        }\n      }\n\n      throw t;\n    }\n\n    synchronized (this) {\n      if (this.shutdown) {\n        throw new YarnException(\"Allocate call succeeded for \" + this.appId\n            + \" after AMRMClientRelayer for RM \" + rmId + \" shutdown.\");\n      }\n\n      updateMetrics(allocateResponse, startTime);\n\n      AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n          allocateResponse.getAllocatedContainers(),\n          this.remotePendingSchedRequest);\n      AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n          allocateResponse.getContainersFromPreviousAttempts(),\n          this.remotePendingSchedRequest);\n\n      this.ask.clear();\n      this.release.clear();\n\n      this.blacklistAdditions.clear();\n      this.blacklistRemovals.clear();\n\n      this.change.clear();\n      this.schedulingRequest.clear();\n      return allocateResponse;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/AMRMClientRelayer.java",
      "extendedDetails": {}
    },
    "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8658. [AMRMProxy] Metrics for AMRMClientRelayer inside FederationInterceptor. Contributed by Young Chen.\n",
      "commitDate": "12/09/18 11:46 AM",
      "commitName": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "20/08/18 12:22 PM",
      "commitNameOld": "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 22.97,
      "commitsBetweenForRepo": 175,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,124 @@\n   public AllocateResponse allocate(AllocateRequest allocateRequest)\n       throws YarnException, IOException {\n     AllocateResponse allocateResponse \u003d null;\n-    try {\n-      synchronized (this) {\n-        addNewAllocateRequest(allocateRequest);\n+    long startTime \u003d System.currentTimeMillis();\n+    synchronized (this) {\n+      if(this.shutdown){\n+        throw new YarnException(\"Allocate called after AMRMClientRelayer for \"\n+            + \"RM \" + rmId + \" shutdown.\");\n+      }\n+      addNewAllocateRequest(allocateRequest);\n \n-        ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n-        for (ResourceRequest r : ask) {\n-          // create a copy of ResourceRequest as we might change it while the\n-          // RPC layer is using it to send info across\n-          askList.add(ResourceRequest.clone(r));\n-        }\n-\n-        allocateRequest \u003d AllocateRequest.newBuilder()\n-            .responseId(allocateRequest.getResponseId())\n-            .progress(allocateRequest.getProgress()).askList(askList)\n-            .releaseList(new ArrayList\u003c\u003e(this.release))\n-            .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n-                new ArrayList\u003c\u003e(this.blacklistAdditions),\n-                new ArrayList\u003c\u003e(this.blacklistRemovals)))\n-            .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n-            .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n-            .build();\n-\n-        if (this.resetResponseId !\u003d -1) {\n-          LOG.info(\"Override allocate responseId from \"\n-              + allocateRequest.getResponseId() + \" to \" + this.resetResponseId\n-              + \" for \" + this.appId);\n-          allocateRequest.setResponseId(this.resetResponseId);\n-        }\n+      ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n+      for (ResourceRequest r : ask) {\n+        // create a copy of ResourceRequest as we might change it while the\n+        // RPC layer is using it to send info across\n+        askList.add(ResourceRequest.clone(r));\n       }\n \n-      // Do the actual allocate call\n-      try {\n-        allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n+      allocateRequest \u003d AllocateRequest.newBuilder()\n+          .responseId(allocateRequest.getResponseId())\n+          .progress(allocateRequest.getProgress()).askList(askList)\n+          .releaseList(new ArrayList\u003c\u003e(this.release))\n+          .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n+              new ArrayList\u003c\u003e(this.blacklistAdditions),\n+              new ArrayList\u003c\u003e(this.blacklistRemovals)))\n+          .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n+          .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n+          .build();\n \n-        // Heartbeat succeeded, wipe out responseId overriding\n-        this.resetResponseId \u003d -1;\n-      } catch (ApplicationMasterNotRegisteredException e) {\n-        LOG.warn(\"ApplicationMaster is out of sync with RM for \" + this.appId\n-            + \" hence resyncing.\");\n-\n-        synchronized (this) {\n-          // Add all remotePending data into to-send data structures\n-          for (ResourceRequestSet requestSet : this.remotePendingAsks\n-              .values()) {\n-            for (ResourceRequest rr : requestSet.getRRs()) {\n-              addResourceRequestToAsk(rr);\n-            }\n-          }\n-          this.release.addAll(this.remotePendingRelease);\n-          this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n-          this.change.putAll(this.remotePendingChange);\n-          for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n-              .values()) {\n-            this.schedulingRequest.addAll(reqs);\n-          }\n-        }\n-\n-        // re-register with RM, then retry allocate recursively\n-        registerApplicationMaster(this.amRegistrationRequest);\n-        // Reset responseId after re-register\n-        allocateRequest.setResponseId(0);\n-        return allocate(allocateRequest);\n-      } catch (Throwable t) {\n-\n-        // If RM is complaining about responseId out of sync, force reset next\n-        // time\n-        if (t instanceof InvalidApplicationMasterRequestException) {\n-          int responseId \u003d AMRMClientUtils\n-              .parseExpectedResponseIdFromException(t.getMessage());\n-          if (responseId !\u003d -1) {\n-            this.resetResponseId \u003d responseId;\n-            LOG.info(\"ResponseId out of sync with RM, expect \" + responseId\n-                + \" but \" + allocateRequest.getResponseId() + \" used by \"\n-                + this.appId + \". Will override in the next allocate.\");\n-          } else {\n-            LOG.warn(\"Failed to parse expected responseId out of exception for \"\n-                + this.appId);\n-          }\n-        }\n-\n-        throw t;\n-      }\n-\n-      synchronized (this) {\n-        // Process the allocate response from RM\n-        if (allocateResponse.getCompletedContainersStatuses() !\u003d null) {\n-          for (ContainerStatus container : allocateResponse\n-              .getCompletedContainersStatuses()) {\n-            this.remotePendingRelease.remove(container.getContainerId());\n-            this.remotePendingChange.remove(container.getContainerId());\n-          }\n-        }\n-\n-        if (allocateResponse.getUpdatedContainers() !\u003d null) {\n-          for (UpdatedContainer updatedContainer : allocateResponse\n-              .getUpdatedContainers()) {\n-            this.remotePendingChange\n-                .remove(updatedContainer.getContainer().getId());\n-          }\n-        }\n-\n-        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n-            allocateResponse.getAllocatedContainers(),\n-            this.remotePendingSchedRequest);\n-        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n-            allocateResponse.getContainersFromPreviousAttempts(),\n-            this.remotePendingSchedRequest);\n-      }\n-\n-    } finally {\n-      synchronized (this) {\n-        /*\n-         * If allocateResponse is null, it means exception happened and RM did\n-         * not accept the request. Don\u0027t clear any data structures so that they\n-         * will be re-sent next time.\n-         *\n-         * Otherwise request was accepted by RM, we are safe to clear these.\n-         */\n-        if (allocateResponse !\u003d null) {\n-          this.ask.clear();\n-          this.release.clear();\n-\n-          this.blacklistAdditions.clear();\n-          this.blacklistRemovals.clear();\n-\n-          this.change.clear();\n-          this.schedulingRequest.clear();\n-        }\n+      if (this.resetResponseId !\u003d -1) {\n+        LOG.info(\"Override allocate responseId from \"\n+            + allocateRequest.getResponseId() + \" to \" + this.resetResponseId\n+            + \" for \" + this.appId);\n+        allocateRequest.setResponseId(this.resetResponseId);\n       }\n     }\n-    return allocateResponse;\n+\n+    // Do the actual allocate call\n+    try {\n+      allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n+\n+      // Heartbeat succeeded, wipe out responseId overriding\n+      this.resetResponseId \u003d -1;\n+    } catch (ApplicationMasterNotRegisteredException e) {\n+      // This is a retriable exception - we will re register and mke a\n+      // recursive call to retry\n+      LOG.warn(\"ApplicationMaster is out of sync with RM \" + rmId\n+          + \" for \" + this.appId + \", hence resyncing.\");\n+\n+      this.metrics.incrRMMasterSlaveSwitch(this.rmId);\n+\n+      synchronized (this) {\n+        // Add all remotePending data into to-send data structures\n+        for (ResourceRequestSet requestSet : this.remotePendingAsks\n+            .values()) {\n+          for (ResourceRequest rr : requestSet.getRRs()) {\n+            addResourceRequestToAsk(rr);\n+          }\n+        }\n+        this.release.addAll(this.remotePendingRelease);\n+        this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n+        this.change.putAll(this.remotePendingChange);\n+        for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n+            .values()) {\n+          this.schedulingRequest.addAll(reqs);\n+        }\n+      }\n+\n+      // re-register with RM, then retry allocate recursively\n+      registerApplicationMaster(this.amRegistrationRequest);\n+      // Reset responseId after re-register\n+      allocateRequest.setResponseId(0);\n+      allocateResponse \u003d allocate(allocateRequest);\n+      return allocateResponse;\n+    } catch (Throwable t) {\n+      // Unexpected exception - rethrow and increment heart beat failure metric\n+      this.metrics.addHeartbeatFailure(this.rmId,\n+          System.currentTimeMillis() - startTime);\n+\n+      // If RM is complaining about responseId out of sync, force reset next\n+      // time\n+      if (t instanceof InvalidApplicationMasterRequestException) {\n+        int responseId \u003d AMRMClientUtils\n+            .parseExpectedResponseIdFromException(t.getMessage());\n+        if (responseId !\u003d -1) {\n+          this.resetResponseId \u003d responseId;\n+          LOG.info(\"ResponseId out of sync with RM, expect \" + responseId\n+              + \" but \" + allocateRequest.getResponseId() + \" used by \"\n+              + this.appId + \". Will override in the next allocate.\");\n+        } else {\n+          LOG.warn(\"Failed to parse expected responseId out of exception for \"\n+              + this.appId);\n+        }\n+      }\n+\n+      throw t;\n+    }\n+\n+    synchronized (this) {\n+      if (this.shutdown) {\n+        throw new YarnException(\"Allocate call succeeded for \" + this.appId\n+            + \" after AMRMClientRelayer for RM \" + rmId + \" shutdown.\");\n+      }\n+\n+      updateMetrics(allocateResponse, startTime);\n+\n+      AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n+          allocateResponse.getAllocatedContainers(),\n+          this.remotePendingSchedRequest);\n+      AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n+          allocateResponse.getContainersFromPreviousAttempts(),\n+          this.remotePendingSchedRequest);\n+\n+      this.ask.clear();\n+      this.release.clear();\n+\n+      this.blacklistAdditions.clear();\n+      this.blacklistRemovals.clear();\n+\n+      this.change.clear();\n+      this.schedulingRequest.clear();\n+      return allocateResponse;\n+    }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest allocateRequest)\n      throws YarnException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    long startTime \u003d System.currentTimeMillis();\n    synchronized (this) {\n      if(this.shutdown){\n        throw new YarnException(\"Allocate called after AMRMClientRelayer for \"\n            + \"RM \" + rmId + \" shutdown.\");\n      }\n      addNewAllocateRequest(allocateRequest);\n\n      ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n      for (ResourceRequest r : ask) {\n        // create a copy of ResourceRequest as we might change it while the\n        // RPC layer is using it to send info across\n        askList.add(ResourceRequest.clone(r));\n      }\n\n      allocateRequest \u003d AllocateRequest.newBuilder()\n          .responseId(allocateRequest.getResponseId())\n          .progress(allocateRequest.getProgress()).askList(askList)\n          .releaseList(new ArrayList\u003c\u003e(this.release))\n          .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n              new ArrayList\u003c\u003e(this.blacklistAdditions),\n              new ArrayList\u003c\u003e(this.blacklistRemovals)))\n          .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n          .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n          .build();\n\n      if (this.resetResponseId !\u003d -1) {\n        LOG.info(\"Override allocate responseId from \"\n            + allocateRequest.getResponseId() + \" to \" + this.resetResponseId\n            + \" for \" + this.appId);\n        allocateRequest.setResponseId(this.resetResponseId);\n      }\n    }\n\n    // Do the actual allocate call\n    try {\n      allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n\n      // Heartbeat succeeded, wipe out responseId overriding\n      this.resetResponseId \u003d -1;\n    } catch (ApplicationMasterNotRegisteredException e) {\n      // This is a retriable exception - we will re register and mke a\n      // recursive call to retry\n      LOG.warn(\"ApplicationMaster is out of sync with RM \" + rmId\n          + \" for \" + this.appId + \", hence resyncing.\");\n\n      this.metrics.incrRMMasterSlaveSwitch(this.rmId);\n\n      synchronized (this) {\n        // Add all remotePending data into to-send data structures\n        for (ResourceRequestSet requestSet : this.remotePendingAsks\n            .values()) {\n          for (ResourceRequest rr : requestSet.getRRs()) {\n            addResourceRequestToAsk(rr);\n          }\n        }\n        this.release.addAll(this.remotePendingRelease);\n        this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n        this.change.putAll(this.remotePendingChange);\n        for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n            .values()) {\n          this.schedulingRequest.addAll(reqs);\n        }\n      }\n\n      // re-register with RM, then retry allocate recursively\n      registerApplicationMaster(this.amRegistrationRequest);\n      // Reset responseId after re-register\n      allocateRequest.setResponseId(0);\n      allocateResponse \u003d allocate(allocateRequest);\n      return allocateResponse;\n    } catch (Throwable t) {\n      // Unexpected exception - rethrow and increment heart beat failure metric\n      this.metrics.addHeartbeatFailure(this.rmId,\n          System.currentTimeMillis() - startTime);\n\n      // If RM is complaining about responseId out of sync, force reset next\n      // time\n      if (t instanceof InvalidApplicationMasterRequestException) {\n        int responseId \u003d AMRMClientUtils\n            .parseExpectedResponseIdFromException(t.getMessage());\n        if (responseId !\u003d -1) {\n          this.resetResponseId \u003d responseId;\n          LOG.info(\"ResponseId out of sync with RM, expect \" + responseId\n              + \" but \" + allocateRequest.getResponseId() + \" used by \"\n              + this.appId + \". Will override in the next allocate.\");\n        } else {\n          LOG.warn(\"Failed to parse expected responseId out of exception for \"\n              + this.appId);\n        }\n      }\n\n      throw t;\n    }\n\n    synchronized (this) {\n      if (this.shutdown) {\n        throw new YarnException(\"Allocate call succeeded for \" + this.appId\n            + \" after AMRMClientRelayer for RM \" + rmId + \" shutdown.\");\n      }\n\n      updateMetrics(allocateResponse, startTime);\n\n      AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n          allocateResponse.getAllocatedContainers(),\n          this.remotePendingSchedRequest);\n      AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n          allocateResponse.getContainersFromPreviousAttempts(),\n          this.remotePendingSchedRequest);\n\n      this.ask.clear();\n      this.release.clear();\n\n      this.blacklistAdditions.clear();\n      this.blacklistRemovals.clear();\n\n      this.change.clear();\n      this.schedulingRequest.clear();\n      return allocateResponse;\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/AMRMClientRelayer.java",
      "extendedDetails": {}
    },
    "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8673. [AMRMProxy] More robust responseId resync after an YarnRM master slave switch. Contributed by Botong Huang.\n",
      "commitDate": "20/08/18 12:22 PM",
      "commitName": "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "09/07/18 12:27 PM",
      "commitNameOld": "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 42.0,
      "commitsBetweenForRepo": 336,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,145 +1,135 @@\n   public AllocateResponse allocate(AllocateRequest allocateRequest)\n       throws YarnException, IOException {\n     AllocateResponse allocateResponse \u003d null;\n     try {\n       synchronized (this) {\n-        // update the data structures first\n-        addNewAsks(allocateRequest.getAskList());\n-\n-        if (allocateRequest.getReleaseList() !\u003d null) {\n-          this.remotePendingRelease.addAll(allocateRequest.getReleaseList());\n-          this.release.addAll(allocateRequest.getReleaseList());\n-        }\n-\n-        if (allocateRequest.getResourceBlacklistRequest() !\u003d null) {\n-          if (allocateRequest.getResourceBlacklistRequest()\n-              .getBlacklistAdditions() !\u003d null) {\n-            this.remoteBlacklistedNodes.addAll(allocateRequest\n-                .getResourceBlacklistRequest().getBlacklistAdditions());\n-            this.blacklistAdditions.addAll(allocateRequest\n-                .getResourceBlacklistRequest().getBlacklistAdditions());\n-          }\n-          if (allocateRequest.getResourceBlacklistRequest()\n-              .getBlacklistRemovals() !\u003d null) {\n-            this.remoteBlacklistedNodes.removeAll(allocateRequest\n-                .getResourceBlacklistRequest().getBlacklistRemovals());\n-            this.blacklistRemovals.addAll(allocateRequest\n-                .getResourceBlacklistRequest().getBlacklistRemovals());\n-          }\n-        }\n-\n-        if (allocateRequest.getUpdateRequests() !\u003d null) {\n-          for (UpdateContainerRequest update : allocateRequest\n-              .getUpdateRequests()) {\n-            this.remotePendingChange.put(update.getContainerId(), update);\n-            this.change.put(update.getContainerId(), update);\n-          }\n-        }\n-\n-        if (allocateRequest.getSchedulingRequests() !\u003d null) {\n-          AMRMClientUtils.addToOutstandingSchedulingRequests(\n-              allocateRequest.getSchedulingRequests(),\n-              this.remotePendingSchedRequest);\n-          this.schedulingRequest\n-              .addAll(allocateRequest.getSchedulingRequests());\n-        }\n+        addNewAllocateRequest(allocateRequest);\n \n         ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n         for (ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the\n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.clone(r));\n         }\n \n         allocateRequest \u003d AllocateRequest.newBuilder()\n             .responseId(allocateRequest.getResponseId())\n             .progress(allocateRequest.getProgress()).askList(askList)\n             .releaseList(new ArrayList\u003c\u003e(this.release))\n             .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n                 new ArrayList\u003c\u003e(this.blacklistAdditions),\n                 new ArrayList\u003c\u003e(this.blacklistRemovals)))\n             .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n             .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n             .build();\n+\n+        if (this.resetResponseId !\u003d -1) {\n+          LOG.info(\"Override allocate responseId from \"\n+              + allocateRequest.getResponseId() + \" to \" + this.resetResponseId\n+              + \" for \" + this.appId);\n+          allocateRequest.setResponseId(this.resetResponseId);\n+        }\n       }\n \n       // Do the actual allocate call\n       try {\n         allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n+\n+        // Heartbeat succeeded, wipe out responseId overriding\n+        this.resetResponseId \u003d -1;\n       } catch (ApplicationMasterNotRegisteredException e) {\n-        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n+        LOG.warn(\"ApplicationMaster is out of sync with RM for \" + this.appId\n             + \" hence resyncing.\");\n \n         synchronized (this) {\n           // Add all remotePending data into to-send data structures\n           for (ResourceRequestSet requestSet : this.remotePendingAsks\n               .values()) {\n             for (ResourceRequest rr : requestSet.getRRs()) {\n               addResourceRequestToAsk(rr);\n             }\n           }\n           this.release.addAll(this.remotePendingRelease);\n           this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n           this.change.putAll(this.remotePendingChange);\n           for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n               .values()) {\n             this.schedulingRequest.addAll(reqs);\n           }\n         }\n \n         // re-register with RM, then retry allocate recursively\n         registerApplicationMaster(this.amRegistrationRequest);\n         // Reset responseId after re-register\n         allocateRequest.setResponseId(0);\n         return allocate(allocateRequest);\n+      } catch (Throwable t) {\n+\n+        // If RM is complaining about responseId out of sync, force reset next\n+        // time\n+        if (t instanceof InvalidApplicationMasterRequestException) {\n+          int responseId \u003d AMRMClientUtils\n+              .parseExpectedResponseIdFromException(t.getMessage());\n+          if (responseId !\u003d -1) {\n+            this.resetResponseId \u003d responseId;\n+            LOG.info(\"ResponseId out of sync with RM, expect \" + responseId\n+                + \" but \" + allocateRequest.getResponseId() + \" used by \"\n+                + this.appId + \". Will override in the next allocate.\");\n+          } else {\n+            LOG.warn(\"Failed to parse expected responseId out of exception for \"\n+                + this.appId);\n+          }\n+        }\n+\n+        throw t;\n       }\n \n       synchronized (this) {\n         // Process the allocate response from RM\n         if (allocateResponse.getCompletedContainersStatuses() !\u003d null) {\n           for (ContainerStatus container : allocateResponse\n               .getCompletedContainersStatuses()) {\n             this.remotePendingRelease.remove(container.getContainerId());\n             this.remotePendingChange.remove(container.getContainerId());\n           }\n         }\n \n         if (allocateResponse.getUpdatedContainers() !\u003d null) {\n           for (UpdatedContainer updatedContainer : allocateResponse\n               .getUpdatedContainers()) {\n             this.remotePendingChange\n                 .remove(updatedContainer.getContainer().getId());\n           }\n         }\n \n         AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n             allocateResponse.getAllocatedContainers(),\n             this.remotePendingSchedRequest);\n         AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n             allocateResponse.getContainersFromPreviousAttempts(),\n             this.remotePendingSchedRequest);\n       }\n \n     } finally {\n       synchronized (this) {\n         /*\n          * If allocateResponse is null, it means exception happened and RM did\n          * not accept the request. Don\u0027t clear any data structures so that they\n          * will be re-sent next time.\n          *\n          * Otherwise request was accepted by RM, we are safe to clear these.\n          */\n         if (allocateResponse !\u003d null) {\n           this.ask.clear();\n           this.release.clear();\n \n           this.blacklistAdditions.clear();\n           this.blacklistRemovals.clear();\n \n           this.change.clear();\n           this.schedulingRequest.clear();\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest allocateRequest)\n      throws YarnException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    try {\n      synchronized (this) {\n        addNewAllocateRequest(allocateRequest);\n\n        ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n        for (ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the\n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.clone(r));\n        }\n\n        allocateRequest \u003d AllocateRequest.newBuilder()\n            .responseId(allocateRequest.getResponseId())\n            .progress(allocateRequest.getProgress()).askList(askList)\n            .releaseList(new ArrayList\u003c\u003e(this.release))\n            .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n                new ArrayList\u003c\u003e(this.blacklistAdditions),\n                new ArrayList\u003c\u003e(this.blacklistRemovals)))\n            .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n            .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n            .build();\n\n        if (this.resetResponseId !\u003d -1) {\n          LOG.info(\"Override allocate responseId from \"\n              + allocateRequest.getResponseId() + \" to \" + this.resetResponseId\n              + \" for \" + this.appId);\n          allocateRequest.setResponseId(this.resetResponseId);\n        }\n      }\n\n      // Do the actual allocate call\n      try {\n        allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n\n        // Heartbeat succeeded, wipe out responseId overriding\n        this.resetResponseId \u003d -1;\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with RM for \" + this.appId\n            + \" hence resyncing.\");\n\n        synchronized (this) {\n          // Add all remotePending data into to-send data structures\n          for (ResourceRequestSet requestSet : this.remotePendingAsks\n              .values()) {\n            for (ResourceRequest rr : requestSet.getRRs()) {\n              addResourceRequestToAsk(rr);\n            }\n          }\n          this.release.addAll(this.remotePendingRelease);\n          this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n          this.change.putAll(this.remotePendingChange);\n          for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n              .values()) {\n            this.schedulingRequest.addAll(reqs);\n          }\n        }\n\n        // re-register with RM, then retry allocate recursively\n        registerApplicationMaster(this.amRegistrationRequest);\n        // Reset responseId after re-register\n        allocateRequest.setResponseId(0);\n        return allocate(allocateRequest);\n      } catch (Throwable t) {\n\n        // If RM is complaining about responseId out of sync, force reset next\n        // time\n        if (t instanceof InvalidApplicationMasterRequestException) {\n          int responseId \u003d AMRMClientUtils\n              .parseExpectedResponseIdFromException(t.getMessage());\n          if (responseId !\u003d -1) {\n            this.resetResponseId \u003d responseId;\n            LOG.info(\"ResponseId out of sync with RM, expect \" + responseId\n                + \" but \" + allocateRequest.getResponseId() + \" used by \"\n                + this.appId + \". Will override in the next allocate.\");\n          } else {\n            LOG.warn(\"Failed to parse expected responseId out of exception for \"\n                + this.appId);\n          }\n        }\n\n        throw t;\n      }\n\n      synchronized (this) {\n        // Process the allocate response from RM\n        if (allocateResponse.getCompletedContainersStatuses() !\u003d null) {\n          for (ContainerStatus container : allocateResponse\n              .getCompletedContainersStatuses()) {\n            this.remotePendingRelease.remove(container.getContainerId());\n            this.remotePendingChange.remove(container.getContainerId());\n          }\n        }\n\n        if (allocateResponse.getUpdatedContainers() !\u003d null) {\n          for (UpdatedContainer updatedContainer : allocateResponse\n              .getUpdatedContainers()) {\n            this.remotePendingChange\n                .remove(updatedContainer.getContainer().getId());\n          }\n        }\n\n        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n            allocateResponse.getAllocatedContainers(),\n            this.remotePendingSchedRequest);\n        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n            allocateResponse.getContainersFromPreviousAttempts(),\n            this.remotePendingSchedRequest);\n      }\n\n    } finally {\n      synchronized (this) {\n        /*\n         * If allocateResponse is null, it means exception happened and RM did\n         * not accept the request. Don\u0027t clear any data structures so that they\n         * will be re-sent next time.\n         *\n         * Otherwise request was accepted by RM, we are safe to clear these.\n         */\n        if (allocateResponse !\u003d null) {\n          this.ask.clear();\n          this.release.clear();\n\n          this.blacklistAdditions.clear();\n          this.blacklistRemovals.clear();\n\n          this.change.clear();\n          this.schedulingRequest.clear();\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/AMRMClientRelayer.java",
      "extendedDetails": {}
    },
    "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7899. [AMRMProxy] Stateful FederationInterceptor for pending requests. Contributed by Botong Huang.\n",
      "commitDate": "09/07/18 12:27 PM",
      "commitName": "ea9b608237e7f2cf9b1e36b0f78c9674ec84096f",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "21/06/18 6:24 PM",
      "commitNameOld": "99948565cb5d5706241d7a8fc591e1617c499e03",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 17.75,
      "commitsBetweenForRepo": 87,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,143 +1,145 @@\n   public AllocateResponse allocate(AllocateRequest allocateRequest)\n       throws YarnException, IOException {\n     AllocateResponse allocateResponse \u003d null;\n     try {\n       synchronized (this) {\n         // update the data structures first\n         addNewAsks(allocateRequest.getAskList());\n \n         if (allocateRequest.getReleaseList() !\u003d null) {\n           this.remotePendingRelease.addAll(allocateRequest.getReleaseList());\n           this.release.addAll(allocateRequest.getReleaseList());\n         }\n \n         if (allocateRequest.getResourceBlacklistRequest() !\u003d null) {\n           if (allocateRequest.getResourceBlacklistRequest()\n               .getBlacklistAdditions() !\u003d null) {\n             this.remoteBlacklistedNodes.addAll(allocateRequest\n                 .getResourceBlacklistRequest().getBlacklistAdditions());\n             this.blacklistAdditions.addAll(allocateRequest\n                 .getResourceBlacklistRequest().getBlacklistAdditions());\n           }\n           if (allocateRequest.getResourceBlacklistRequest()\n               .getBlacklistRemovals() !\u003d null) {\n             this.remoteBlacklistedNodes.removeAll(allocateRequest\n                 .getResourceBlacklistRequest().getBlacklistRemovals());\n             this.blacklistRemovals.addAll(allocateRequest\n                 .getResourceBlacklistRequest().getBlacklistRemovals());\n           }\n         }\n \n         if (allocateRequest.getUpdateRequests() !\u003d null) {\n           for (UpdateContainerRequest update : allocateRequest\n               .getUpdateRequests()) {\n             this.remotePendingChange.put(update.getContainerId(), update);\n             this.change.put(update.getContainerId(), update);\n           }\n         }\n \n         if (allocateRequest.getSchedulingRequests() !\u003d null) {\n           AMRMClientUtils.addToOutstandingSchedulingRequests(\n               allocateRequest.getSchedulingRequests(),\n               this.remotePendingSchedRequest);\n           this.schedulingRequest\n               .addAll(allocateRequest.getSchedulingRequests());\n         }\n \n         ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n         for (ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the\n           // RPC layer is using it to send info across\n           askList.add(ResourceRequest.clone(r));\n         }\n \n         allocateRequest \u003d AllocateRequest.newBuilder()\n             .responseId(allocateRequest.getResponseId())\n             .progress(allocateRequest.getProgress()).askList(askList)\n             .releaseList(new ArrayList\u003c\u003e(this.release))\n             .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n                 new ArrayList\u003c\u003e(this.blacklistAdditions),\n                 new ArrayList\u003c\u003e(this.blacklistRemovals)))\n             .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n             .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n             .build();\n       }\n \n       // Do the actual allocate call\n       try {\n         allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n \n         synchronized (this) {\n           // Add all remotePending data into to-send data structures\n           for (ResourceRequestSet requestSet : this.remotePendingAsks\n               .values()) {\n             for (ResourceRequest rr : requestSet.getRRs()) {\n               addResourceRequestToAsk(rr);\n             }\n           }\n           this.release.addAll(this.remotePendingRelease);\n           this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n           this.change.putAll(this.remotePendingChange);\n           for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n               .values()) {\n             this.schedulingRequest.addAll(reqs);\n           }\n         }\n \n-        // re register with RM, then retry allocate recursively\n+        // re-register with RM, then retry allocate recursively\n         registerApplicationMaster(this.amRegistrationRequest);\n+        // Reset responseId after re-register\n+        allocateRequest.setResponseId(0);\n         return allocate(allocateRequest);\n       }\n \n       synchronized (this) {\n         // Process the allocate response from RM\n         if (allocateResponse.getCompletedContainersStatuses() !\u003d null) {\n           for (ContainerStatus container : allocateResponse\n               .getCompletedContainersStatuses()) {\n             this.remotePendingRelease.remove(container.getContainerId());\n             this.remotePendingChange.remove(container.getContainerId());\n           }\n         }\n \n         if (allocateResponse.getUpdatedContainers() !\u003d null) {\n           for (UpdatedContainer updatedContainer : allocateResponse\n               .getUpdatedContainers()) {\n             this.remotePendingChange\n                 .remove(updatedContainer.getContainer().getId());\n           }\n         }\n \n         AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n             allocateResponse.getAllocatedContainers(),\n             this.remotePendingSchedRequest);\n         AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n             allocateResponse.getContainersFromPreviousAttempts(),\n             this.remotePendingSchedRequest);\n       }\n \n     } finally {\n       synchronized (this) {\n         /*\n          * If allocateResponse is null, it means exception happened and RM did\n          * not accept the request. Don\u0027t clear any data structures so that they\n          * will be re-sent next time.\n          *\n          * Otherwise request was accepted by RM, we are safe to clear these.\n          */\n         if (allocateResponse !\u003d null) {\n           this.ask.clear();\n           this.release.clear();\n \n           this.blacklistAdditions.clear();\n           this.blacklistRemovals.clear();\n \n           this.change.clear();\n           this.schedulingRequest.clear();\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest allocateRequest)\n      throws YarnException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    try {\n      synchronized (this) {\n        // update the data structures first\n        addNewAsks(allocateRequest.getAskList());\n\n        if (allocateRequest.getReleaseList() !\u003d null) {\n          this.remotePendingRelease.addAll(allocateRequest.getReleaseList());\n          this.release.addAll(allocateRequest.getReleaseList());\n        }\n\n        if (allocateRequest.getResourceBlacklistRequest() !\u003d null) {\n          if (allocateRequest.getResourceBlacklistRequest()\n              .getBlacklistAdditions() !\u003d null) {\n            this.remoteBlacklistedNodes.addAll(allocateRequest\n                .getResourceBlacklistRequest().getBlacklistAdditions());\n            this.blacklistAdditions.addAll(allocateRequest\n                .getResourceBlacklistRequest().getBlacklistAdditions());\n          }\n          if (allocateRequest.getResourceBlacklistRequest()\n              .getBlacklistRemovals() !\u003d null) {\n            this.remoteBlacklistedNodes.removeAll(allocateRequest\n                .getResourceBlacklistRequest().getBlacklistRemovals());\n            this.blacklistRemovals.addAll(allocateRequest\n                .getResourceBlacklistRequest().getBlacklistRemovals());\n          }\n        }\n\n        if (allocateRequest.getUpdateRequests() !\u003d null) {\n          for (UpdateContainerRequest update : allocateRequest\n              .getUpdateRequests()) {\n            this.remotePendingChange.put(update.getContainerId(), update);\n            this.change.put(update.getContainerId(), update);\n          }\n        }\n\n        if (allocateRequest.getSchedulingRequests() !\u003d null) {\n          AMRMClientUtils.addToOutstandingSchedulingRequests(\n              allocateRequest.getSchedulingRequests(),\n              this.remotePendingSchedRequest);\n          this.schedulingRequest\n              .addAll(allocateRequest.getSchedulingRequests());\n        }\n\n        ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n        for (ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the\n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.clone(r));\n        }\n\n        allocateRequest \u003d AllocateRequest.newBuilder()\n            .responseId(allocateRequest.getResponseId())\n            .progress(allocateRequest.getProgress()).askList(askList)\n            .releaseList(new ArrayList\u003c\u003e(this.release))\n            .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n                new ArrayList\u003c\u003e(this.blacklistAdditions),\n                new ArrayList\u003c\u003e(this.blacklistRemovals)))\n            .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n            .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n            .build();\n      }\n\n      // Do the actual allocate call\n      try {\n        allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n\n        synchronized (this) {\n          // Add all remotePending data into to-send data structures\n          for (ResourceRequestSet requestSet : this.remotePendingAsks\n              .values()) {\n            for (ResourceRequest rr : requestSet.getRRs()) {\n              addResourceRequestToAsk(rr);\n            }\n          }\n          this.release.addAll(this.remotePendingRelease);\n          this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n          this.change.putAll(this.remotePendingChange);\n          for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n              .values()) {\n            this.schedulingRequest.addAll(reqs);\n          }\n        }\n\n        // re-register with RM, then retry allocate recursively\n        registerApplicationMaster(this.amRegistrationRequest);\n        // Reset responseId after re-register\n        allocateRequest.setResponseId(0);\n        return allocate(allocateRequest);\n      }\n\n      synchronized (this) {\n        // Process the allocate response from RM\n        if (allocateResponse.getCompletedContainersStatuses() !\u003d null) {\n          for (ContainerStatus container : allocateResponse\n              .getCompletedContainersStatuses()) {\n            this.remotePendingRelease.remove(container.getContainerId());\n            this.remotePendingChange.remove(container.getContainerId());\n          }\n        }\n\n        if (allocateResponse.getUpdatedContainers() !\u003d null) {\n          for (UpdatedContainer updatedContainer : allocateResponse\n              .getUpdatedContainers()) {\n            this.remotePendingChange\n                .remove(updatedContainer.getContainer().getId());\n          }\n        }\n\n        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n            allocateResponse.getAllocatedContainers(),\n            this.remotePendingSchedRequest);\n        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n            allocateResponse.getContainersFromPreviousAttempts(),\n            this.remotePendingSchedRequest);\n      }\n\n    } finally {\n      synchronized (this) {\n        /*\n         * If allocateResponse is null, it means exception happened and RM did\n         * not accept the request. Don\u0027t clear any data structures so that they\n         * will be re-sent next time.\n         *\n         * Otherwise request was accepted by RM, we are safe to clear these.\n         */\n        if (allocateResponse !\u003d null) {\n          this.ask.clear();\n          this.release.clear();\n\n          this.blacklistAdditions.clear();\n          this.blacklistRemovals.clear();\n\n          this.change.clear();\n          this.schedulingRequest.clear();\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/AMRMClientRelayer.java",
      "extendedDetails": {}
    },
    "99948565cb5d5706241d7a8fc591e1617c499e03": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8412. Move ResourceRequest.clone logic everywhere into a proper API. Contributed by Botong Huang.\n",
      "commitDate": "21/06/18 6:24 PM",
      "commitName": "99948565cb5d5706241d7a8fc591e1617c499e03",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "17/05/18 8:00 PM",
      "commitNameOld": "3159bffce23abf35754da2d7d51de7d8c2631ae3",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 34.93,
      "commitsBetweenForRepo": 251,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,149 +1,143 @@\n   public AllocateResponse allocate(AllocateRequest allocateRequest)\n       throws YarnException, IOException {\n     AllocateResponse allocateResponse \u003d null;\n     try {\n       synchronized (this) {\n         // update the data structures first\n         addNewAsks(allocateRequest.getAskList());\n \n         if (allocateRequest.getReleaseList() !\u003d null) {\n           this.remotePendingRelease.addAll(allocateRequest.getReleaseList());\n           this.release.addAll(allocateRequest.getReleaseList());\n         }\n \n         if (allocateRequest.getResourceBlacklistRequest() !\u003d null) {\n           if (allocateRequest.getResourceBlacklistRequest()\n               .getBlacklistAdditions() !\u003d null) {\n             this.remoteBlacklistedNodes.addAll(allocateRequest\n                 .getResourceBlacklistRequest().getBlacklistAdditions());\n             this.blacklistAdditions.addAll(allocateRequest\n                 .getResourceBlacklistRequest().getBlacklistAdditions());\n           }\n           if (allocateRequest.getResourceBlacklistRequest()\n               .getBlacklistRemovals() !\u003d null) {\n             this.remoteBlacklistedNodes.removeAll(allocateRequest\n                 .getResourceBlacklistRequest().getBlacklistRemovals());\n             this.blacklistRemovals.addAll(allocateRequest\n                 .getResourceBlacklistRequest().getBlacklistRemovals());\n           }\n         }\n \n         if (allocateRequest.getUpdateRequests() !\u003d null) {\n           for (UpdateContainerRequest update : allocateRequest\n               .getUpdateRequests()) {\n             this.remotePendingChange.put(update.getContainerId(), update);\n             this.change.put(update.getContainerId(), update);\n           }\n         }\n \n         if (allocateRequest.getSchedulingRequests() !\u003d null) {\n           AMRMClientUtils.addToOutstandingSchedulingRequests(\n               allocateRequest.getSchedulingRequests(),\n               this.remotePendingSchedRequest);\n           this.schedulingRequest\n               .addAll(allocateRequest.getSchedulingRequests());\n         }\n \n         ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n         for (ResourceRequest r : ask) {\n           // create a copy of ResourceRequest as we might change it while the\n           // RPC layer is using it to send info across\n-          askList.add(ResourceRequest.newBuilder().priority(r.getPriority())\n-              .resourceName(r.getResourceName()).capability(r.getCapability())\n-              .numContainers(r.getNumContainers())\n-              .relaxLocality(r.getRelaxLocality())\n-              .nodeLabelExpression(r.getNodeLabelExpression())\n-              .executionTypeRequest(r.getExecutionTypeRequest())\n-              .allocationRequestId(r.getAllocationRequestId()).build());\n+          askList.add(ResourceRequest.clone(r));\n         }\n \n         allocateRequest \u003d AllocateRequest.newBuilder()\n             .responseId(allocateRequest.getResponseId())\n             .progress(allocateRequest.getProgress()).askList(askList)\n             .releaseList(new ArrayList\u003c\u003e(this.release))\n             .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n                 new ArrayList\u003c\u003e(this.blacklistAdditions),\n                 new ArrayList\u003c\u003e(this.blacklistRemovals)))\n             .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n             .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n             .build();\n       }\n \n       // Do the actual allocate call\n       try {\n         allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n       } catch (ApplicationMasterNotRegisteredException e) {\n         LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n             + \" hence resyncing.\");\n \n         synchronized (this) {\n           // Add all remotePending data into to-send data structures\n           for (ResourceRequestSet requestSet : this.remotePendingAsks\n               .values()) {\n             for (ResourceRequest rr : requestSet.getRRs()) {\n               addResourceRequestToAsk(rr);\n             }\n           }\n           this.release.addAll(this.remotePendingRelease);\n           this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n           this.change.putAll(this.remotePendingChange);\n           for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n               .values()) {\n             this.schedulingRequest.addAll(reqs);\n           }\n         }\n \n         // re register with RM, then retry allocate recursively\n         registerApplicationMaster(this.amRegistrationRequest);\n         return allocate(allocateRequest);\n       }\n \n       synchronized (this) {\n         // Process the allocate response from RM\n         if (allocateResponse.getCompletedContainersStatuses() !\u003d null) {\n           for (ContainerStatus container : allocateResponse\n               .getCompletedContainersStatuses()) {\n             this.remotePendingRelease.remove(container.getContainerId());\n             this.remotePendingChange.remove(container.getContainerId());\n           }\n         }\n \n         if (allocateResponse.getUpdatedContainers() !\u003d null) {\n           for (UpdatedContainer updatedContainer : allocateResponse\n               .getUpdatedContainers()) {\n             this.remotePendingChange\n                 .remove(updatedContainer.getContainer().getId());\n           }\n         }\n \n         AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n             allocateResponse.getAllocatedContainers(),\n             this.remotePendingSchedRequest);\n         AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n             allocateResponse.getContainersFromPreviousAttempts(),\n             this.remotePendingSchedRequest);\n       }\n \n     } finally {\n       synchronized (this) {\n         /*\n          * If allocateResponse is null, it means exception happened and RM did\n          * not accept the request. Don\u0027t clear any data structures so that they\n          * will be re-sent next time.\n          *\n          * Otherwise request was accepted by RM, we are safe to clear these.\n          */\n         if (allocateResponse !\u003d null) {\n           this.ask.clear();\n           this.release.clear();\n \n           this.blacklistAdditions.clear();\n           this.blacklistRemovals.clear();\n \n           this.change.clear();\n           this.schedulingRequest.clear();\n         }\n       }\n     }\n     return allocateResponse;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest allocateRequest)\n      throws YarnException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    try {\n      synchronized (this) {\n        // update the data structures first\n        addNewAsks(allocateRequest.getAskList());\n\n        if (allocateRequest.getReleaseList() !\u003d null) {\n          this.remotePendingRelease.addAll(allocateRequest.getReleaseList());\n          this.release.addAll(allocateRequest.getReleaseList());\n        }\n\n        if (allocateRequest.getResourceBlacklistRequest() !\u003d null) {\n          if (allocateRequest.getResourceBlacklistRequest()\n              .getBlacklistAdditions() !\u003d null) {\n            this.remoteBlacklistedNodes.addAll(allocateRequest\n                .getResourceBlacklistRequest().getBlacklistAdditions());\n            this.blacklistAdditions.addAll(allocateRequest\n                .getResourceBlacklistRequest().getBlacklistAdditions());\n          }\n          if (allocateRequest.getResourceBlacklistRequest()\n              .getBlacklistRemovals() !\u003d null) {\n            this.remoteBlacklistedNodes.removeAll(allocateRequest\n                .getResourceBlacklistRequest().getBlacklistRemovals());\n            this.blacklistRemovals.addAll(allocateRequest\n                .getResourceBlacklistRequest().getBlacklistRemovals());\n          }\n        }\n\n        if (allocateRequest.getUpdateRequests() !\u003d null) {\n          for (UpdateContainerRequest update : allocateRequest\n              .getUpdateRequests()) {\n            this.remotePendingChange.put(update.getContainerId(), update);\n            this.change.put(update.getContainerId(), update);\n          }\n        }\n\n        if (allocateRequest.getSchedulingRequests() !\u003d null) {\n          AMRMClientUtils.addToOutstandingSchedulingRequests(\n              allocateRequest.getSchedulingRequests(),\n              this.remotePendingSchedRequest);\n          this.schedulingRequest\n              .addAll(allocateRequest.getSchedulingRequests());\n        }\n\n        ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n        for (ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the\n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.clone(r));\n        }\n\n        allocateRequest \u003d AllocateRequest.newBuilder()\n            .responseId(allocateRequest.getResponseId())\n            .progress(allocateRequest.getProgress()).askList(askList)\n            .releaseList(new ArrayList\u003c\u003e(this.release))\n            .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n                new ArrayList\u003c\u003e(this.blacklistAdditions),\n                new ArrayList\u003c\u003e(this.blacklistRemovals)))\n            .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n            .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n            .build();\n      }\n\n      // Do the actual allocate call\n      try {\n        allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n\n        synchronized (this) {\n          // Add all remotePending data into to-send data structures\n          for (ResourceRequestSet requestSet : this.remotePendingAsks\n              .values()) {\n            for (ResourceRequest rr : requestSet.getRRs()) {\n              addResourceRequestToAsk(rr);\n            }\n          }\n          this.release.addAll(this.remotePendingRelease);\n          this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n          this.change.putAll(this.remotePendingChange);\n          for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n              .values()) {\n            this.schedulingRequest.addAll(reqs);\n          }\n        }\n\n        // re register with RM, then retry allocate recursively\n        registerApplicationMaster(this.amRegistrationRequest);\n        return allocate(allocateRequest);\n      }\n\n      synchronized (this) {\n        // Process the allocate response from RM\n        if (allocateResponse.getCompletedContainersStatuses() !\u003d null) {\n          for (ContainerStatus container : allocateResponse\n              .getCompletedContainersStatuses()) {\n            this.remotePendingRelease.remove(container.getContainerId());\n            this.remotePendingChange.remove(container.getContainerId());\n          }\n        }\n\n        if (allocateResponse.getUpdatedContainers() !\u003d null) {\n          for (UpdatedContainer updatedContainer : allocateResponse\n              .getUpdatedContainers()) {\n            this.remotePendingChange\n                .remove(updatedContainer.getContainer().getId());\n          }\n        }\n\n        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n            allocateResponse.getAllocatedContainers(),\n            this.remotePendingSchedRequest);\n        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n            allocateResponse.getContainersFromPreviousAttempts(),\n            this.remotePendingSchedRequest);\n      }\n\n    } finally {\n      synchronized (this) {\n        /*\n         * If allocateResponse is null, it means exception happened and RM did\n         * not accept the request. Don\u0027t clear any data structures so that they\n         * will be re-sent next time.\n         *\n         * Otherwise request was accepted by RM, we are safe to clear these.\n         */\n        if (allocateResponse !\u003d null) {\n          this.ask.clear();\n          this.release.clear();\n\n          this.blacklistAdditions.clear();\n          this.blacklistRemovals.clear();\n\n          this.change.clear();\n          this.schedulingRequest.clear();\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/AMRMClientRelayer.java",
      "extendedDetails": {}
    },
    "3159bffce23abf35754da2d7d51de7d8c2631ae3": {
      "type": "Yintroduced",
      "commitMessage": "YARN-7900. [AMRMProxy] AMRMClientRelayer for stateful FederationInterceptor. (Botong Huang via asuresh)\n",
      "commitDate": "17/05/18 8:00 PM",
      "commitName": "3159bffce23abf35754da2d7d51de7d8c2631ae3",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,149 @@\n+  public AllocateResponse allocate(AllocateRequest allocateRequest)\n+      throws YarnException, IOException {\n+    AllocateResponse allocateResponse \u003d null;\n+    try {\n+      synchronized (this) {\n+        // update the data structures first\n+        addNewAsks(allocateRequest.getAskList());\n+\n+        if (allocateRequest.getReleaseList() !\u003d null) {\n+          this.remotePendingRelease.addAll(allocateRequest.getReleaseList());\n+          this.release.addAll(allocateRequest.getReleaseList());\n+        }\n+\n+        if (allocateRequest.getResourceBlacklistRequest() !\u003d null) {\n+          if (allocateRequest.getResourceBlacklistRequest()\n+              .getBlacklistAdditions() !\u003d null) {\n+            this.remoteBlacklistedNodes.addAll(allocateRequest\n+                .getResourceBlacklistRequest().getBlacklistAdditions());\n+            this.blacklistAdditions.addAll(allocateRequest\n+                .getResourceBlacklistRequest().getBlacklistAdditions());\n+          }\n+          if (allocateRequest.getResourceBlacklistRequest()\n+              .getBlacklistRemovals() !\u003d null) {\n+            this.remoteBlacklistedNodes.removeAll(allocateRequest\n+                .getResourceBlacklistRequest().getBlacklistRemovals());\n+            this.blacklistRemovals.addAll(allocateRequest\n+                .getResourceBlacklistRequest().getBlacklistRemovals());\n+          }\n+        }\n+\n+        if (allocateRequest.getUpdateRequests() !\u003d null) {\n+          for (UpdateContainerRequest update : allocateRequest\n+              .getUpdateRequests()) {\n+            this.remotePendingChange.put(update.getContainerId(), update);\n+            this.change.put(update.getContainerId(), update);\n+          }\n+        }\n+\n+        if (allocateRequest.getSchedulingRequests() !\u003d null) {\n+          AMRMClientUtils.addToOutstandingSchedulingRequests(\n+              allocateRequest.getSchedulingRequests(),\n+              this.remotePendingSchedRequest);\n+          this.schedulingRequest\n+              .addAll(allocateRequest.getSchedulingRequests());\n+        }\n+\n+        ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n+        for (ResourceRequest r : ask) {\n+          // create a copy of ResourceRequest as we might change it while the\n+          // RPC layer is using it to send info across\n+          askList.add(ResourceRequest.newBuilder().priority(r.getPriority())\n+              .resourceName(r.getResourceName()).capability(r.getCapability())\n+              .numContainers(r.getNumContainers())\n+              .relaxLocality(r.getRelaxLocality())\n+              .nodeLabelExpression(r.getNodeLabelExpression())\n+              .executionTypeRequest(r.getExecutionTypeRequest())\n+              .allocationRequestId(r.getAllocationRequestId()).build());\n+        }\n+\n+        allocateRequest \u003d AllocateRequest.newBuilder()\n+            .responseId(allocateRequest.getResponseId())\n+            .progress(allocateRequest.getProgress()).askList(askList)\n+            .releaseList(new ArrayList\u003c\u003e(this.release))\n+            .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n+                new ArrayList\u003c\u003e(this.blacklistAdditions),\n+                new ArrayList\u003c\u003e(this.blacklistRemovals)))\n+            .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n+            .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n+            .build();\n+      }\n+\n+      // Do the actual allocate call\n+      try {\n+        allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n+      } catch (ApplicationMasterNotRegisteredException e) {\n+        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n+            + \" hence resyncing.\");\n+\n+        synchronized (this) {\n+          // Add all remotePending data into to-send data structures\n+          for (ResourceRequestSet requestSet : this.remotePendingAsks\n+              .values()) {\n+            for (ResourceRequest rr : requestSet.getRRs()) {\n+              addResourceRequestToAsk(rr);\n+            }\n+          }\n+          this.release.addAll(this.remotePendingRelease);\n+          this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n+          this.change.putAll(this.remotePendingChange);\n+          for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n+              .values()) {\n+            this.schedulingRequest.addAll(reqs);\n+          }\n+        }\n+\n+        // re register with RM, then retry allocate recursively\n+        registerApplicationMaster(this.amRegistrationRequest);\n+        return allocate(allocateRequest);\n+      }\n+\n+      synchronized (this) {\n+        // Process the allocate response from RM\n+        if (allocateResponse.getCompletedContainersStatuses() !\u003d null) {\n+          for (ContainerStatus container : allocateResponse\n+              .getCompletedContainersStatuses()) {\n+            this.remotePendingRelease.remove(container.getContainerId());\n+            this.remotePendingChange.remove(container.getContainerId());\n+          }\n+        }\n+\n+        if (allocateResponse.getUpdatedContainers() !\u003d null) {\n+          for (UpdatedContainer updatedContainer : allocateResponse\n+              .getUpdatedContainers()) {\n+            this.remotePendingChange\n+                .remove(updatedContainer.getContainer().getId());\n+          }\n+        }\n+\n+        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n+            allocateResponse.getAllocatedContainers(),\n+            this.remotePendingSchedRequest);\n+        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n+            allocateResponse.getContainersFromPreviousAttempts(),\n+            this.remotePendingSchedRequest);\n+      }\n+\n+    } finally {\n+      synchronized (this) {\n+        /*\n+         * If allocateResponse is null, it means exception happened and RM did\n+         * not accept the request. Don\u0027t clear any data structures so that they\n+         * will be re-sent next time.\n+         *\n+         * Otherwise request was accepted by RM, we are safe to clear these.\n+         */\n+        if (allocateResponse !\u003d null) {\n+          this.ask.clear();\n+          this.release.clear();\n+\n+          this.blacklistAdditions.clear();\n+          this.blacklistRemovals.clear();\n+\n+          this.change.clear();\n+          this.schedulingRequest.clear();\n+        }\n+      }\n+    }\n+    return allocateResponse;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public AllocateResponse allocate(AllocateRequest allocateRequest)\n      throws YarnException, IOException {\n    AllocateResponse allocateResponse \u003d null;\n    try {\n      synchronized (this) {\n        // update the data structures first\n        addNewAsks(allocateRequest.getAskList());\n\n        if (allocateRequest.getReleaseList() !\u003d null) {\n          this.remotePendingRelease.addAll(allocateRequest.getReleaseList());\n          this.release.addAll(allocateRequest.getReleaseList());\n        }\n\n        if (allocateRequest.getResourceBlacklistRequest() !\u003d null) {\n          if (allocateRequest.getResourceBlacklistRequest()\n              .getBlacklistAdditions() !\u003d null) {\n            this.remoteBlacklistedNodes.addAll(allocateRequest\n                .getResourceBlacklistRequest().getBlacklistAdditions());\n            this.blacklistAdditions.addAll(allocateRequest\n                .getResourceBlacklistRequest().getBlacklistAdditions());\n          }\n          if (allocateRequest.getResourceBlacklistRequest()\n              .getBlacklistRemovals() !\u003d null) {\n            this.remoteBlacklistedNodes.removeAll(allocateRequest\n                .getResourceBlacklistRequest().getBlacklistRemovals());\n            this.blacklistRemovals.addAll(allocateRequest\n                .getResourceBlacklistRequest().getBlacklistRemovals());\n          }\n        }\n\n        if (allocateRequest.getUpdateRequests() !\u003d null) {\n          for (UpdateContainerRequest update : allocateRequest\n              .getUpdateRequests()) {\n            this.remotePendingChange.put(update.getContainerId(), update);\n            this.change.put(update.getContainerId(), update);\n          }\n        }\n\n        if (allocateRequest.getSchedulingRequests() !\u003d null) {\n          AMRMClientUtils.addToOutstandingSchedulingRequests(\n              allocateRequest.getSchedulingRequests(),\n              this.remotePendingSchedRequest);\n          this.schedulingRequest\n              .addAll(allocateRequest.getSchedulingRequests());\n        }\n\n        ArrayList\u003cResourceRequest\u003e askList \u003d new ArrayList\u003c\u003e(ask.size());\n        for (ResourceRequest r : ask) {\n          // create a copy of ResourceRequest as we might change it while the\n          // RPC layer is using it to send info across\n          askList.add(ResourceRequest.newBuilder().priority(r.getPriority())\n              .resourceName(r.getResourceName()).capability(r.getCapability())\n              .numContainers(r.getNumContainers())\n              .relaxLocality(r.getRelaxLocality())\n              .nodeLabelExpression(r.getNodeLabelExpression())\n              .executionTypeRequest(r.getExecutionTypeRequest())\n              .allocationRequestId(r.getAllocationRequestId()).build());\n        }\n\n        allocateRequest \u003d AllocateRequest.newBuilder()\n            .responseId(allocateRequest.getResponseId())\n            .progress(allocateRequest.getProgress()).askList(askList)\n            .releaseList(new ArrayList\u003c\u003e(this.release))\n            .resourceBlacklistRequest(ResourceBlacklistRequest.newInstance(\n                new ArrayList\u003c\u003e(this.blacklistAdditions),\n                new ArrayList\u003c\u003e(this.blacklistRemovals)))\n            .updateRequests(new ArrayList\u003c\u003e(this.change.values()))\n            .schedulingRequests(new ArrayList\u003c\u003e(this.schedulingRequest))\n            .build();\n      }\n\n      // Do the actual allocate call\n      try {\n        allocateResponse \u003d this.rmClient.allocate(allocateRequest);\n      } catch (ApplicationMasterNotRegisteredException e) {\n        LOG.warn(\"ApplicationMaster is out of sync with ResourceManager,\"\n            + \" hence resyncing.\");\n\n        synchronized (this) {\n          // Add all remotePending data into to-send data structures\n          for (ResourceRequestSet requestSet : this.remotePendingAsks\n              .values()) {\n            for (ResourceRequest rr : requestSet.getRRs()) {\n              addResourceRequestToAsk(rr);\n            }\n          }\n          this.release.addAll(this.remotePendingRelease);\n          this.blacklistAdditions.addAll(this.remoteBlacklistedNodes);\n          this.change.putAll(this.remotePendingChange);\n          for (List\u003cSchedulingRequest\u003e reqs : this.remotePendingSchedRequest\n              .values()) {\n            this.schedulingRequest.addAll(reqs);\n          }\n        }\n\n        // re register with RM, then retry allocate recursively\n        registerApplicationMaster(this.amRegistrationRequest);\n        return allocate(allocateRequest);\n      }\n\n      synchronized (this) {\n        // Process the allocate response from RM\n        if (allocateResponse.getCompletedContainersStatuses() !\u003d null) {\n          for (ContainerStatus container : allocateResponse\n              .getCompletedContainersStatuses()) {\n            this.remotePendingRelease.remove(container.getContainerId());\n            this.remotePendingChange.remove(container.getContainerId());\n          }\n        }\n\n        if (allocateResponse.getUpdatedContainers() !\u003d null) {\n          for (UpdatedContainer updatedContainer : allocateResponse\n              .getUpdatedContainers()) {\n            this.remotePendingChange\n                .remove(updatedContainer.getContainer().getId());\n          }\n        }\n\n        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n            allocateResponse.getAllocatedContainers(),\n            this.remotePendingSchedRequest);\n        AMRMClientUtils.removeFromOutstandingSchedulingRequests(\n            allocateResponse.getContainersFromPreviousAttempts(),\n            this.remotePendingSchedRequest);\n      }\n\n    } finally {\n      synchronized (this) {\n        /*\n         * If allocateResponse is null, it means exception happened and RM did\n         * not accept the request. Don\u0027t clear any data structures so that they\n         * will be re-sent next time.\n         *\n         * Otherwise request was accepted by RM, we are safe to clear these.\n         */\n        if (allocateResponse !\u003d null) {\n          this.ask.clear();\n          this.release.clear();\n\n          this.blacklistAdditions.clear();\n          this.blacklistRemovals.clear();\n\n          this.change.clear();\n          this.schedulingRequest.clear();\n        }\n      }\n    }\n    return allocateResponse;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-common/src/main/java/org/apache/hadoop/yarn/server/AMRMClientRelayer.java"
    }
  }
}