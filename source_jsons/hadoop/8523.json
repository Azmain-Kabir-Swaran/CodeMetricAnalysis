{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSImage.java",
  "functionName": "saveNamespace",
  "functionId": "saveNamespace___timeWindow-long__txGap-long__source-FSNamesystem",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
  "functionStartLine": 1116,
  "functionEndLine": 1134,
  "numCommitsSeen": 229,
  "timeTaken": 8193,
  "changeHistory": [
    "e0fa49234fd37aca88e1caa95bac77bca192bae4",
    "5e21e4ca377f68e030f8f3436cd93fd7a74dc5e0",
    "4f9bbaa301194e3d20972a10f51638c7f4d121f0",
    "15ddb6634f8bdab37ce43f99f8338d84422c7232",
    "841fdc5628fbba341efe0bfc6763fe12e7fca7f4",
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae",
    "2481474bd9c50a23e4fd2eea67ac2dea11ca1f58",
    "f87a4b40bc99e76602a75906df31747cfdbff78a",
    "646e855f6ef058b636a5fc85637a3f8e17fddaba",
    "06e84a1bca19bd01568a3095e33944d4d6387fd3",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "e0fa49234fd37aca88e1caa95bac77bca192bae4": "Ybodychange",
    "5e21e4ca377f68e030f8f3436cd93fd7a74dc5e0": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "4f9bbaa301194e3d20972a10f51638c7f4d121f0": "Ybodychange",
    "15ddb6634f8bdab37ce43f99f8338d84422c7232": "Ybodychange",
    "841fdc5628fbba341efe0bfc6763fe12e7fca7f4": "Ybodychange",
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae": "Ymultichange(Ymodifierchange,Ybodychange)",
    "2481474bd9c50a23e4fd2eea67ac2dea11ca1f58": "Ybodychange",
    "f87a4b40bc99e76602a75906df31747cfdbff78a": "Ybodychange",
    "646e855f6ef058b636a5fc85637a3f8e17fddaba": "Ymultichange(Ymodifierchange,Ybodychange)",
    "06e84a1bca19bd01568a3095e33944d4d6387fd3": "Ymultichange(Yparameterchange,Ybodychange)",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": "Ymultichange(Yparameterchange,Ybodychange)",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "e0fa49234fd37aca88e1caa95bac77bca192bae4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11180. Intermittent deadlock in NameNode when failover happens.\n",
      "commitDate": "01/12/16 6:08 AM",
      "commitName": "e0fa49234fd37aca88e1caa95bac77bca192bae4",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "06/09/16 10:38 AM",
      "commitNameOld": "d37dc5d1b8e022a7085118a2e7066623483c293f",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 85.85,
      "commitsBetweenForRepo": 656,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,19 @@\n   public synchronized boolean saveNamespace(long timeWindow, long txGap,\n       FSNamesystem source) throws IOException {\n     if (timeWindow \u003e 0 || txGap \u003e 0) {\n       final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(\n           EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK),\n           StartupOption.REGULAR);\n       FSImageFile image \u003d inspector.getLatestImages().get(0);\n       File imageFile \u003d image.getFile();\n \n       final long checkpointTxId \u003d image.getCheckpointTxId();\n       final long checkpointAge \u003d Time.now() - imageFile.lastModified();\n       if (checkpointAge \u003c\u003d timeWindow * 1000 \u0026\u0026\n-          checkpointTxId \u003e\u003d this.getLastAppliedOrWrittenTxId() - txGap) {\n+          checkpointTxId \u003e\u003d this.getCorrectLastAppliedOrWrittenTxId() - txGap) {\n         return false;\n       }\n     }\n     saveNamespace(source, NameNodeFile.IMAGE, null);\n     return true;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized boolean saveNamespace(long timeWindow, long txGap,\n      FSNamesystem source) throws IOException {\n    if (timeWindow \u003e 0 || txGap \u003e 0) {\n      final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(\n          EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK),\n          StartupOption.REGULAR);\n      FSImageFile image \u003d inspector.getLatestImages().get(0);\n      File imageFile \u003d image.getFile();\n\n      final long checkpointTxId \u003d image.getCheckpointTxId();\n      final long checkpointAge \u003d Time.now() - imageFile.lastModified();\n      if (checkpointAge \u003c\u003d timeWindow * 1000 \u0026\u0026\n          checkpointTxId \u003e\u003d this.getCorrectLastAppliedOrWrittenTxId() - txGap) {\n        return false;\n      }\n    }\n    saveNamespace(source, NameNodeFile.IMAGE, null);\n    return true;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "5e21e4ca377f68e030f8f3436cd93fd7a74dc5e0": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-6353. Check and make checkpoint before stopping the NameNode. Contributed by Jing Zhao.\n",
      "commitDate": "25/03/15 10:38 AM",
      "commitName": "5e21e4ca377f68e030f8f3436cd93fd7a74dc5e0",
      "commitAuthor": "Jing Zhao",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-6353. Check and make checkpoint before stopping the NameNode. Contributed by Jing Zhao.\n",
          "commitDate": "25/03/15 10:38 AM",
          "commitName": "5e21e4ca377f68e030f8f3436cd93fd7a74dc5e0",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "18/03/15 6:48 PM",
          "commitNameOld": "43b41f22411439c5e23629197fb2fde45dcf0f0f",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 6.66,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,4 +1,19 @@\n-  public synchronized void saveNamespace(FSNamesystem source)\n-      throws IOException {\n+  public synchronized boolean saveNamespace(long timeWindow, long txGap,\n+      FSNamesystem source) throws IOException {\n+    if (timeWindow \u003e 0 || txGap \u003e 0) {\n+      final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(\n+          EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK),\n+          StartupOption.REGULAR);\n+      FSImageFile image \u003d inspector.getLatestImages().get(0);\n+      File imageFile \u003d image.getFile();\n+\n+      final long checkpointTxId \u003d image.getCheckpointTxId();\n+      final long checkpointAge \u003d Time.now() - imageFile.lastModified();\n+      if (checkpointAge \u003c\u003d timeWindow * 1000 \u0026\u0026\n+          checkpointTxId \u003e\u003d this.getLastAppliedOrWrittenTxId() - txGap) {\n+        return false;\n+      }\n+    }\n     saveNamespace(source, NameNodeFile.IMAGE, null);\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized boolean saveNamespace(long timeWindow, long txGap,\n      FSNamesystem source) throws IOException {\n    if (timeWindow \u003e 0 || txGap \u003e 0) {\n      final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(\n          EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK),\n          StartupOption.REGULAR);\n      FSImageFile image \u003d inspector.getLatestImages().get(0);\n      File imageFile \u003d image.getFile();\n\n      final long checkpointTxId \u003d image.getCheckpointTxId();\n      final long checkpointAge \u003d Time.now() - imageFile.lastModified();\n      if (checkpointAge \u003c\u003d timeWindow * 1000 \u0026\u0026\n          checkpointTxId \u003e\u003d this.getLastAppliedOrWrittenTxId() - txGap) {\n        return false;\n      }\n    }\n    saveNamespace(source, NameNodeFile.IMAGE, null);\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[source-FSNamesystem]",
            "newValue": "[timeWindow-long, txGap-long, source-FSNamesystem]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-6353. Check and make checkpoint before stopping the NameNode. Contributed by Jing Zhao.\n",
          "commitDate": "25/03/15 10:38 AM",
          "commitName": "5e21e4ca377f68e030f8f3436cd93fd7a74dc5e0",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "18/03/15 6:48 PM",
          "commitNameOld": "43b41f22411439c5e23629197fb2fde45dcf0f0f",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 6.66,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,4 +1,19 @@\n-  public synchronized void saveNamespace(FSNamesystem source)\n-      throws IOException {\n+  public synchronized boolean saveNamespace(long timeWindow, long txGap,\n+      FSNamesystem source) throws IOException {\n+    if (timeWindow \u003e 0 || txGap \u003e 0) {\n+      final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(\n+          EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK),\n+          StartupOption.REGULAR);\n+      FSImageFile image \u003d inspector.getLatestImages().get(0);\n+      File imageFile \u003d image.getFile();\n+\n+      final long checkpointTxId \u003d image.getCheckpointTxId();\n+      final long checkpointAge \u003d Time.now() - imageFile.lastModified();\n+      if (checkpointAge \u003c\u003d timeWindow * 1000 \u0026\u0026\n+          checkpointTxId \u003e\u003d this.getLastAppliedOrWrittenTxId() - txGap) {\n+        return false;\n+      }\n+    }\n     saveNamespace(source, NameNodeFile.IMAGE, null);\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized boolean saveNamespace(long timeWindow, long txGap,\n      FSNamesystem source) throws IOException {\n    if (timeWindow \u003e 0 || txGap \u003e 0) {\n      final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(\n          EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK),\n          StartupOption.REGULAR);\n      FSImageFile image \u003d inspector.getLatestImages().get(0);\n      File imageFile \u003d image.getFile();\n\n      final long checkpointTxId \u003d image.getCheckpointTxId();\n      final long checkpointAge \u003d Time.now() - imageFile.lastModified();\n      if (checkpointAge \u003c\u003d timeWindow * 1000 \u0026\u0026\n          checkpointTxId \u003e\u003d this.getLastAppliedOrWrittenTxId() - txGap) {\n        return false;\n      }\n    }\n    saveNamespace(source, NameNodeFile.IMAGE, null);\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "void",
            "newValue": "boolean"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-6353. Check and make checkpoint before stopping the NameNode. Contributed by Jing Zhao.\n",
          "commitDate": "25/03/15 10:38 AM",
          "commitName": "5e21e4ca377f68e030f8f3436cd93fd7a74dc5e0",
          "commitAuthor": "Jing Zhao",
          "commitDateOld": "18/03/15 6:48 PM",
          "commitNameOld": "43b41f22411439c5e23629197fb2fde45dcf0f0f",
          "commitAuthorOld": "Colin Patrick Mccabe",
          "daysBetweenCommits": 6.66,
          "commitsBetweenForRepo": 71,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,4 +1,19 @@\n-  public synchronized void saveNamespace(FSNamesystem source)\n-      throws IOException {\n+  public synchronized boolean saveNamespace(long timeWindow, long txGap,\n+      FSNamesystem source) throws IOException {\n+    if (timeWindow \u003e 0 || txGap \u003e 0) {\n+      final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(\n+          EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK),\n+          StartupOption.REGULAR);\n+      FSImageFile image \u003d inspector.getLatestImages().get(0);\n+      File imageFile \u003d image.getFile();\n+\n+      final long checkpointTxId \u003d image.getCheckpointTxId();\n+      final long checkpointAge \u003d Time.now() - imageFile.lastModified();\n+      if (checkpointAge \u003c\u003d timeWindow * 1000 \u0026\u0026\n+          checkpointTxId \u003e\u003d this.getLastAppliedOrWrittenTxId() - txGap) {\n+        return false;\n+      }\n+    }\n     saveNamespace(source, NameNodeFile.IMAGE, null);\n+    return true;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized boolean saveNamespace(long timeWindow, long txGap,\n      FSNamesystem source) throws IOException {\n    if (timeWindow \u003e 0 || txGap \u003e 0) {\n      final FSImageStorageInspector inspector \u003d storage.readAndInspectDirs(\n          EnumSet.of(NameNodeFile.IMAGE, NameNodeFile.IMAGE_ROLLBACK),\n          StartupOption.REGULAR);\n      FSImageFile image \u003d inspector.getLatestImages().get(0);\n      File imageFile \u003d image.getFile();\n\n      final long checkpointTxId \u003d image.getCheckpointTxId();\n      final long checkpointAge \u003d Time.now() - imageFile.lastModified();\n      if (checkpointAge \u003c\u003d timeWindow * 1000 \u0026\u0026\n          checkpointTxId \u003e\u003d this.getLastAppliedOrWrittenTxId() - txGap) {\n        return false;\n      }\n    }\n    saveNamespace(source, NameNodeFile.IMAGE, null);\n    return true;\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {}
        }
      ]
    },
    "4f9bbaa301194e3d20972a10f51638c7f4d121f0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5889. When starting rolling upgrade, create a fs image for rollback so that the standby namenode can create checkpoints during upgrade.  Contributed by szetszwo \u0026 jing9\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1567861 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/02/14 12:04 AM",
      "commitName": "4f9bbaa301194e3d20972a10f51638c7f4d121f0",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "06/02/14 6:08 PM",
      "commitNameOld": "c780454413caffbc37a02c4252eb5ec7abe57f97",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 6.25,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,4 +1,4 @@\n   public synchronized void saveNamespace(FSNamesystem source)\n       throws IOException {\n-    saveNamespace(source, null);\n+    saveNamespace(source, NameNodeFile.IMAGE, null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void saveNamespace(FSNamesystem source)\n      throws IOException {\n    saveNamespace(source, NameNodeFile.IMAGE, null);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "15ddb6634f8bdab37ce43f99f8338d84422c7232": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2800. Fix cancellation of checkpoints in the standby node to be more reliable. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1339745 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/05/12 10:49 AM",
      "commitName": "15ddb6634f8bdab37ce43f99f8338d84422c7232",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "14/05/12 5:41 PM",
      "commitNameOld": "95710c15b7a724897bcde826e112df6d4b4fe56b",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 2.71,
      "commitsBetweenForRepo": 23,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,4 @@\n-  public synchronized void saveNamespace(FSNamesystem source) throws IOException {\n-    assert editLog !\u003d null : \"editLog must be initialized\";\n-    storage.attemptRestoreRemovedStorage();\n-\n-    boolean editLogWasOpen \u003d editLog.isSegmentOpen();\n-    \n-    if (editLogWasOpen) {\n-      editLog.endCurrentLogSegment(true);\n-    }\n-    long imageTxId \u003d getLastAppliedOrWrittenTxId();\n-    try {\n-      saveFSImageInAllDirs(source, imageTxId);\n-      storage.writeAll();\n-    } finally {\n-      if (editLogWasOpen) {\n-        editLog.startLogSegmentAndWriteHeaderTxn(imageTxId + 1);\n-        // Take this opportunity to note the current transaction.\n-        // Even if the namespace save was cancelled, this marker\n-        // is only used to determine what transaction ID is required\n-        // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n-        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n-      }\n-    }\n-    \n+  public synchronized void saveNamespace(FSNamesystem source)\n+      throws IOException {\n+    saveNamespace(source, null);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void saveNamespace(FSNamesystem source)\n      throws IOException {\n    saveNamespace(source, null);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "841fdc5628fbba341efe0bfc6763fe12e7fca7f4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3273. Refactor BackupImage and FSEditLog, and rename JournalListener.rollLogs(..) to startLogSegment(..). \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1326016 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "13/04/12 4:41 PM",
      "commitName": "841fdc5628fbba341efe0bfc6763fe12e7fca7f4",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "13/04/12 2:31 PM",
      "commitNameOld": "5a20d446cf2a947b37fd5856a7e1fe6c21547557",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 0.09,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n   public synchronized void saveNamespace(FSNamesystem source) throws IOException {\n     assert editLog !\u003d null : \"editLog must be initialized\";\n     storage.attemptRestoreRemovedStorage();\n \n     boolean editLogWasOpen \u003d editLog.isSegmentOpen();\n     \n     if (editLogWasOpen) {\n       editLog.endCurrentLogSegment(true);\n     }\n     long imageTxId \u003d getLastAppliedOrWrittenTxId();\n     try {\n       saveFSImageInAllDirs(source, imageTxId);\n       storage.writeAll();\n     } finally {\n       if (editLogWasOpen) {\n-        editLog.startLogSegment(imageTxId + 1, true);\n+        editLog.startLogSegmentAndWriteHeaderTxn(imageTxId + 1);\n         // Take this opportunity to note the current transaction.\n         // Even if the namespace save was cancelled, this marker\n         // is only used to determine what transaction ID is required\n         // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n         storage.writeTransactionIdFileToStorage(imageTxId + 1);\n       }\n     }\n     \n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void saveNamespace(FSNamesystem source) throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isSegmentOpen();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d getLastAppliedOrWrittenTxId();\n    try {\n      saveFSImageInAllDirs(source, imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegmentAndWriteHeaderTxn(imageTxId + 1);\n        // Take this opportunity to note the current transaction.\n        // Even if the namespace save was cancelled, this marker\n        // is only used to determine what transaction ID is required\n        // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-2291. Allow the StandbyNode to make checkpoints in an HA setup. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1227411 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/01/12 4:22 PM",
      "commitName": "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-2291. Allow the StandbyNode to make checkpoints in an HA setup. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1227411 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/01/12 4:22 PM",
          "commitName": "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "15/12/11 8:25 PM",
          "commitNameOld": "cdb9f01ad4e6084ddf83e40eb3ec18a89fbbae42",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 19.83,
          "commitsBetweenForRepo": 70,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,25 @@\n-  synchronized void saveNamespace(FSNamesystem source) throws IOException {\n+  public synchronized void saveNamespace(FSNamesystem source) throws IOException {\n     assert editLog !\u003d null : \"editLog must be initialized\";\n     storage.attemptRestoreRemovedStorage();\n \n     boolean editLogWasOpen \u003d editLog.isSegmentOpen();\n     \n     if (editLogWasOpen) {\n       editLog.endCurrentLogSegment(true);\n     }\n-    long imageTxId \u003d editLog.getLastWrittenTxId();\n+    long imageTxId \u003d getLastAppliedOrWrittenTxId();\n     try {\n       saveFSImageInAllDirs(source, imageTxId);\n       storage.writeAll();\n     } finally {\n       if (editLogWasOpen) {\n         editLog.startLogSegment(imageTxId + 1, true);\n         // Take this opportunity to note the current transaction.\n         // Even if the namespace save was cancelled, this marker\n         // is only used to determine what transaction ID is required\n         // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n         storage.writeTransactionIdFileToStorage(imageTxId + 1);\n       }\n     }\n     \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void saveNamespace(FSNamesystem source) throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isSegmentOpen();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d getLastAppliedOrWrittenTxId();\n    try {\n      saveFSImageInAllDirs(source, imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegment(imageTxId + 1, true);\n        // Take this opportunity to note the current transaction.\n        // Even if the namespace save was cancelled, this marker\n        // is only used to determine what transaction ID is required\n        // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[synchronized]",
            "newValue": "[public, synchronized]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2291. Allow the StandbyNode to make checkpoints in an HA setup. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1227411 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/01/12 4:22 PM",
          "commitName": "5b8dcb20a2fad2e7e9dee56c451f68f9d865b5ae",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "15/12/11 8:25 PM",
          "commitNameOld": "cdb9f01ad4e6084ddf83e40eb3ec18a89fbbae42",
          "commitAuthorOld": "Todd Lipcon",
          "daysBetweenCommits": 19.83,
          "commitsBetweenForRepo": 70,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,25 +1,25 @@\n-  synchronized void saveNamespace(FSNamesystem source) throws IOException {\n+  public synchronized void saveNamespace(FSNamesystem source) throws IOException {\n     assert editLog !\u003d null : \"editLog must be initialized\";\n     storage.attemptRestoreRemovedStorage();\n \n     boolean editLogWasOpen \u003d editLog.isSegmentOpen();\n     \n     if (editLogWasOpen) {\n       editLog.endCurrentLogSegment(true);\n     }\n-    long imageTxId \u003d editLog.getLastWrittenTxId();\n+    long imageTxId \u003d getLastAppliedOrWrittenTxId();\n     try {\n       saveFSImageInAllDirs(source, imageTxId);\n       storage.writeAll();\n     } finally {\n       if (editLogWasOpen) {\n         editLog.startLogSegment(imageTxId + 1, true);\n         // Take this opportunity to note the current transaction.\n         // Even if the namespace save was cancelled, this marker\n         // is only used to determine what transaction ID is required\n         // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n         storage.writeTransactionIdFileToStorage(imageTxId + 1);\n       }\n     }\n     \n   }\n\\ No newline at end of file\n",
          "actualSource": "  public synchronized void saveNamespace(FSNamesystem source) throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isSegmentOpen();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d getLastAppliedOrWrittenTxId();\n    try {\n      saveFSImageInAllDirs(source, imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegment(imageTxId + 1, true);\n        // Take this opportunity to note the current transaction.\n        // Even if the namespace save was cancelled, this marker\n        // is only used to determine what transaction ID is required\n        // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {}
        }
      ]
    },
    "2481474bd9c50a23e4fd2eea67ac2dea11ca1f58": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2634. Standby needs to ingest latest edit logs before transitioning to active. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1212187 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/12/11 3:55 PM",
      "commitName": "2481474bd9c50a23e4fd2eea67ac2dea11ca1f58",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "07/12/11 6:57 PM",
      "commitNameOld": "d9ea5bb48940c6ee2b6688a527ad74bccce6ed18",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n   synchronized void saveNamespace(FSNamesystem source) throws IOException {\n     assert editLog !\u003d null : \"editLog must be initialized\";\n     storage.attemptRestoreRemovedStorage();\n \n-    boolean editLogWasOpen \u003d editLog.isOpenForWrite();\n+    boolean editLogWasOpen \u003d editLog.isSegmentOpen();\n     \n     if (editLogWasOpen) {\n       editLog.endCurrentLogSegment(true);\n     }\n     long imageTxId \u003d editLog.getLastWrittenTxId();\n     try {\n       saveFSImageInAllDirs(source, imageTxId);\n       storage.writeAll();\n     } finally {\n       if (editLogWasOpen) {\n         editLog.startLogSegment(imageTxId + 1, true);\n         // Take this opportunity to note the current transaction.\n         // Even if the namespace save was cancelled, this marker\n         // is only used to determine what transaction ID is required\n         // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n         storage.writeTransactionIdFileToStorage(imageTxId + 1);\n       }\n     }\n     \n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized void saveNamespace(FSNamesystem source) throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isSegmentOpen();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d editLog.getLastWrittenTxId();\n    try {\n      saveFSImageInAllDirs(source, imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegment(imageTxId + 1, true);\n        // Take this opportunity to note the current transaction.\n        // Even if the namespace save was cancelled, this marker\n        // is only used to determine what transaction ID is required\n        // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "f87a4b40bc99e76602a75906df31747cfdbff78a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1975. Support for sharing the namenode state from active to standby. Contributed by Jitendra Nath Pandey, Aaron T Myers, and Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1208813 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/11/11 1:46 PM",
      "commitName": "f87a4b40bc99e76602a75906df31747cfdbff78a",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "01/11/11 9:44 AM",
      "commitNameOld": "496144158443078f5fc7c8930d971601f2b08dff",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 29.21,
      "commitsBetweenForRepo": 147,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,25 +1,25 @@\n   synchronized void saveNamespace(FSNamesystem source) throws IOException {\n     assert editLog !\u003d null : \"editLog must be initialized\";\n     storage.attemptRestoreRemovedStorage();\n \n-    boolean editLogWasOpen \u003d editLog.isOpen();\n+    boolean editLogWasOpen \u003d editLog.isOpenForWrite();\n     \n     if (editLogWasOpen) {\n       editLog.endCurrentLogSegment(true);\n     }\n     long imageTxId \u003d editLog.getLastWrittenTxId();\n     try {\n       saveFSImageInAllDirs(source, imageTxId);\n       storage.writeAll();\n     } finally {\n       if (editLogWasOpen) {\n         editLog.startLogSegment(imageTxId + 1, true);\n         // Take this opportunity to note the current transaction.\n         // Even if the namespace save was cancelled, this marker\n         // is only used to determine what transaction ID is required\n         // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n         storage.writeTransactionIdFileToStorage(imageTxId + 1);\n       }\n     }\n     \n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized void saveNamespace(FSNamesystem source) throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isOpenForWrite();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d editLog.getLastWrittenTxId();\n    try {\n      saveFSImageInAllDirs(source, imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegment(imageTxId + 1, true);\n        // Take this opportunity to note the current transaction.\n        // Even if the namespace save was cancelled, this marker\n        // is only used to determine what transaction ID is required\n        // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "646e855f6ef058b636a5fc85637a3f8e17fddaba": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-2507. Allow saveNamespace operations to be canceled. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190060 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 3:11 PM",
      "commitName": "646e855f6ef058b636a5fc85637a3f8e17fddaba",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-2507. Allow saveNamespace operations to be canceled. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190060 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/10/11 3:11 PM",
          "commitName": "646e855f6ef058b636a5fc85637a3f8e17fddaba",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "17/10/11 1:23 PM",
          "commitNameOld": "8d4842383ede2aceec11c33f6314aa50b0c5ae55",
          "commitAuthorOld": "Jitendra Nath Pandey",
          "daysBetweenCommits": 10.07,
          "commitsBetweenForRepo": 97,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,22 +1,25 @@\n-  void saveNamespace(FSNamesystem source) throws IOException {\n+  synchronized void saveNamespace(FSNamesystem source) throws IOException {\n     assert editLog !\u003d null : \"editLog must be initialized\";\n     storage.attemptRestoreRemovedStorage();\n \n     boolean editLogWasOpen \u003d editLog.isOpen();\n     \n     if (editLogWasOpen) {\n       editLog.endCurrentLogSegment(true);\n     }\n     long imageTxId \u003d editLog.getLastWrittenTxId();\n     try {\n       saveFSImageInAllDirs(source, imageTxId);\n       storage.writeAll();\n     } finally {\n       if (editLogWasOpen) {\n         editLog.startLogSegment(imageTxId + 1, true);\n-        // Take this opportunity to note the current transaction\n+        // Take this opportunity to note the current transaction.\n+        // Even if the namespace save was cancelled, this marker\n+        // is only used to determine what transaction ID is required\n+        // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n         storage.writeTransactionIdFileToStorage(imageTxId + 1);\n       }\n     }\n     \n   }\n\\ No newline at end of file\n",
          "actualSource": "  synchronized void saveNamespace(FSNamesystem source) throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isOpen();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d editLog.getLastWrittenTxId();\n    try {\n      saveFSImageInAllDirs(source, imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegment(imageTxId + 1, true);\n        // Take this opportunity to note the current transaction.\n        // Even if the namespace save was cancelled, this marker\n        // is only used to determine what transaction ID is required\n        // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[synchronized]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2507. Allow saveNamespace operations to be canceled. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1190060 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "27/10/11 3:11 PM",
          "commitName": "646e855f6ef058b636a5fc85637a3f8e17fddaba",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "17/10/11 1:23 PM",
          "commitNameOld": "8d4842383ede2aceec11c33f6314aa50b0c5ae55",
          "commitAuthorOld": "Jitendra Nath Pandey",
          "daysBetweenCommits": 10.07,
          "commitsBetweenForRepo": 97,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,22 +1,25 @@\n-  void saveNamespace(FSNamesystem source) throws IOException {\n+  synchronized void saveNamespace(FSNamesystem source) throws IOException {\n     assert editLog !\u003d null : \"editLog must be initialized\";\n     storage.attemptRestoreRemovedStorage();\n \n     boolean editLogWasOpen \u003d editLog.isOpen();\n     \n     if (editLogWasOpen) {\n       editLog.endCurrentLogSegment(true);\n     }\n     long imageTxId \u003d editLog.getLastWrittenTxId();\n     try {\n       saveFSImageInAllDirs(source, imageTxId);\n       storage.writeAll();\n     } finally {\n       if (editLogWasOpen) {\n         editLog.startLogSegment(imageTxId + 1, true);\n-        // Take this opportunity to note the current transaction\n+        // Take this opportunity to note the current transaction.\n+        // Even if the namespace save was cancelled, this marker\n+        // is only used to determine what transaction ID is required\n+        // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n         storage.writeTransactionIdFileToStorage(imageTxId + 1);\n       }\n     }\n     \n   }\n\\ No newline at end of file\n",
          "actualSource": "  synchronized void saveNamespace(FSNamesystem source) throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isOpen();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d editLog.getLastWrittenTxId();\n    try {\n      saveFSImageInAllDirs(source, imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegment(imageTxId + 1, true);\n        // Take this opportunity to note the current transaction.\n        // Even if the namespace save was cancelled, this marker\n        // is only used to determine what transaction ID is required\n        // for startup. So, it doesn\u0027t hurt to update it unnecessarily.\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {}
        }
      ]
    },
    "06e84a1bca19bd01568a3095e33944d4d6387fd3": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-2223. Untangle depencencies between NN components. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166466 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/09/11 4:23 PM",
      "commitName": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-2223. Untangle depencencies between NN components. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166466 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/09/11 4:23 PM",
          "commitName": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "06/09/11 1:27 PM",
          "commitNameOld": "bdc3720d5b67a1c8fc2dfb29be16e4155c0e7f15",
          "commitAuthorOld": "Jitendra Nath Pandey",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,22 +1,22 @@\n-  void saveNamespace() throws IOException {\n+  void saveNamespace(FSNamesystem source) throws IOException {\n     assert editLog !\u003d null : \"editLog must be initialized\";\n     storage.attemptRestoreRemovedStorage();\n \n     boolean editLogWasOpen \u003d editLog.isOpen();\n     \n     if (editLogWasOpen) {\n       editLog.endCurrentLogSegment(true);\n     }\n     long imageTxId \u003d editLog.getLastWrittenTxId();\n     try {\n-      saveFSImageInAllDirs(imageTxId);\n+      saveFSImageInAllDirs(source, imageTxId);\n       storage.writeAll();\n     } finally {\n       if (editLogWasOpen) {\n         editLog.startLogSegment(imageTxId + 1, true);\n         // Take this opportunity to note the current transaction\n         storage.writeTransactionIdFileToStorage(imageTxId + 1);\n       }\n     }\n     \n   }\n\\ No newline at end of file\n",
          "actualSource": "  void saveNamespace(FSNamesystem source) throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isOpen();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d editLog.getLastWrittenTxId();\n    try {\n      saveFSImageInAllDirs(source, imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegment(imageTxId + 1, true);\n        // Take this opportunity to note the current transaction\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[source-FSNamesystem]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2223. Untangle depencencies between NN components. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166466 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/09/11 4:23 PM",
          "commitName": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "06/09/11 1:27 PM",
          "commitNameOld": "bdc3720d5b67a1c8fc2dfb29be16e4155c0e7f15",
          "commitAuthorOld": "Jitendra Nath Pandey",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,22 +1,22 @@\n-  void saveNamespace() throws IOException {\n+  void saveNamespace(FSNamesystem source) throws IOException {\n     assert editLog !\u003d null : \"editLog must be initialized\";\n     storage.attemptRestoreRemovedStorage();\n \n     boolean editLogWasOpen \u003d editLog.isOpen();\n     \n     if (editLogWasOpen) {\n       editLog.endCurrentLogSegment(true);\n     }\n     long imageTxId \u003d editLog.getLastWrittenTxId();\n     try {\n-      saveFSImageInAllDirs(imageTxId);\n+      saveFSImageInAllDirs(source, imageTxId);\n       storage.writeAll();\n     } finally {\n       if (editLogWasOpen) {\n         editLog.startLogSegment(imageTxId + 1, true);\n         // Take this opportunity to note the current transaction\n         storage.writeTransactionIdFileToStorage(imageTxId + 1);\n       }\n     }\n     \n   }\n\\ No newline at end of file\n",
          "actualSource": "  void saveNamespace(FSNamesystem source) throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isOpen();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d editLog.getLastWrittenTxId();\n    try {\n      saveFSImageInAllDirs(source, imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegment(imageTxId + 1, true);\n        // Take this opportunity to note the current transaction\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {}
        }
      ]
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  void saveNamespace() throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isOpen();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d editLog.getLastWrittenTxId();\n    try {\n      saveFSImageInAllDirs(imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegment(imageTxId + 1, true);\n        // Take this opportunity to note the current transaction\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  void saveNamespace() throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isOpen();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d editLog.getLastWrittenTxId();\n    try {\n      saveFSImageInAllDirs(imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegment(imageTxId + 1, true);\n        // Take this opportunity to note the current transaction\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
      }
    },
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/11 9:28 AM",
      "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/07/11 9:28 AM",
          "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "27/07/11 8:19 PM",
          "commitNameOld": "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
          "commitAuthorOld": "Eli Collins",
          "daysBetweenCommits": 1.55,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,111 +1,22 @@\n-  void saveNamespace(boolean renewCheckpointTime) throws IOException {\n- \n-    // try to restore all failed edit logs here\n+  void saveNamespace() throws IOException {\n     assert editLog !\u003d null : \"editLog must be initialized\";\n     storage.attemptRestoreRemovedStorage();\n \n-    editLog.close();\n-    if(renewCheckpointTime)\n-      storage.setCheckpointTime(now());\n-    List\u003cStorageDirectory\u003e errorSDs \u003d\n-      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n-\n-    // mv current -\u003e lastcheckpoint.tmp\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      try {\n-        storage.moveCurrent(sd);\n-      } catch(IOException ie) {\n-        LOG.error(\"Unable to move current for \" + sd.getRoot(), ie);\n-        errorSDs.add(sd);\n-      }\n+    boolean editLogWasOpen \u003d editLog.isOpen();\n+    \n+    if (editLogWasOpen) {\n+      editLog.endCurrentLogSegment(true);\n     }\n-\n-    List\u003cThread\u003e saveThreads \u003d new ArrayList\u003cThread\u003e();\n-    // save images into current\n-    for (Iterator\u003cStorageDirectory\u003e it\n-           \u003d storage.dirIterator(NameNodeDirType.IMAGE); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      if (errorSDs.contains(sd)) {\n-        continue;\n-      }\n-      try {\n-        FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n-        Thread saveThread \u003d new Thread(saver, saver.toString());\n-        saveThreads.add(saveThread);\n-        saveThread.start();\n-      } catch (Exception e) {\n-        LOG.error(\"Failed save to image directory \" + sd.getRoot(), e);\n-        errorSDs.add(sd);\n-        continue;\n-      }\n-    }\n-    waitForThreads(saveThreads);\n-    saveThreads.clear();\n-\n-    // -NOTE-\n-    // If NN has image-only and edits-only storage directories and fails here\n-    // the image will have the latest namespace state.\n-    // During startup the image-only directories will recover by discarding\n-    // lastcheckpoint.tmp, while\n-    // the edits-only directories will recover by falling back\n-    // to the old state contained in their lastcheckpoint.tmp.\n-    // The edits directories should be discarded during startup because their\n-    // checkpointTime is older than that of image directories.\n-    // recreate edits in current\n-    for (Iterator\u003cStorageDirectory\u003e it\n-           \u003d storage.dirIterator(NameNodeDirType.EDITS); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      if (errorSDs.contains(sd)) {\n-        continue;\n-      }\n-\n-      // if this directory already stores the image and edits, then it was\n-      // already processed in the earlier loop.\n-      if (sd.getStorageDirType() \u003d\u003d NameNodeDirType.IMAGE_AND_EDITS) {\n-        continue;\n-      }\n-\n-      try {\n-        FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n-        Thread saveThread \u003d new Thread(saver, saver.toString());\n-        saveThreads.add(saveThread);\n-        saveThread.start();\n-      } catch (Exception e) {\n-        LOG.error(\"Failed save to edits directory \" + sd.getRoot(), e);\n-        errorSDs.add(sd);\n-        continue;\n-      }\n-    }\n-    waitForThreads(saveThreads);\n-\n-    // mv lastcheckpoint.tmp -\u003e previous.checkpoint\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      if (errorSDs.contains(sd)) {\n-        continue;\n-      }\n-      try {\n-        storage.moveLastCheckpoint(sd);\n-      } catch(IOException ie) {\n-        LOG.error(\"Unable to move last checkpoint for \" + sd.getRoot(), ie);\n-        errorSDs.add(sd);\n-        continue;\n+    long imageTxId \u003d editLog.getLastWrittenTxId();\n+    try {\n+      saveFSImageInAllDirs(imageTxId);\n+      storage.writeAll();\n+    } finally {\n+      if (editLogWasOpen) {\n+        editLog.startLogSegment(imageTxId + 1, true);\n+        // Take this opportunity to note the current transaction\n+        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n       }\n     }\n     \n-    try {\n-      storage.reportErrorsOnDirectories(errorSDs);\n-      \n-      // If there was an error in every storage dir, each one will have been\n-      // removed from the list of storage directories.\n-      if (storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0 ||\n-          storage.getNumStorageDirs(NameNodeDirType.EDITS) \u003d\u003d 0) {\n-        throw new IOException(\"Failed to save any storage directories while saving namespace\");\n-      }\n-      \n-      if(!editLog.isOpen()) editLog.open();\n-    } finally {\n-      ckptState \u003d CheckpointStates.UPLOAD_DONE;\n-    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void saveNamespace() throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isOpen();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d editLog.getLastWrittenTxId();\n    try {\n      saveFSImageInAllDirs(imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegment(imageTxId + 1, true);\n        // Take this opportunity to note the current transaction\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[renewCheckpointTime-boolean]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "29/07/11 9:28 AM",
          "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "27/07/11 8:19 PM",
          "commitNameOld": "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
          "commitAuthorOld": "Eli Collins",
          "daysBetweenCommits": 1.55,
          "commitsBetweenForRepo": 6,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,111 +1,22 @@\n-  void saveNamespace(boolean renewCheckpointTime) throws IOException {\n- \n-    // try to restore all failed edit logs here\n+  void saveNamespace() throws IOException {\n     assert editLog !\u003d null : \"editLog must be initialized\";\n     storage.attemptRestoreRemovedStorage();\n \n-    editLog.close();\n-    if(renewCheckpointTime)\n-      storage.setCheckpointTime(now());\n-    List\u003cStorageDirectory\u003e errorSDs \u003d\n-      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n-\n-    // mv current -\u003e lastcheckpoint.tmp\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      try {\n-        storage.moveCurrent(sd);\n-      } catch(IOException ie) {\n-        LOG.error(\"Unable to move current for \" + sd.getRoot(), ie);\n-        errorSDs.add(sd);\n-      }\n+    boolean editLogWasOpen \u003d editLog.isOpen();\n+    \n+    if (editLogWasOpen) {\n+      editLog.endCurrentLogSegment(true);\n     }\n-\n-    List\u003cThread\u003e saveThreads \u003d new ArrayList\u003cThread\u003e();\n-    // save images into current\n-    for (Iterator\u003cStorageDirectory\u003e it\n-           \u003d storage.dirIterator(NameNodeDirType.IMAGE); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      if (errorSDs.contains(sd)) {\n-        continue;\n-      }\n-      try {\n-        FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n-        Thread saveThread \u003d new Thread(saver, saver.toString());\n-        saveThreads.add(saveThread);\n-        saveThread.start();\n-      } catch (Exception e) {\n-        LOG.error(\"Failed save to image directory \" + sd.getRoot(), e);\n-        errorSDs.add(sd);\n-        continue;\n-      }\n-    }\n-    waitForThreads(saveThreads);\n-    saveThreads.clear();\n-\n-    // -NOTE-\n-    // If NN has image-only and edits-only storage directories and fails here\n-    // the image will have the latest namespace state.\n-    // During startup the image-only directories will recover by discarding\n-    // lastcheckpoint.tmp, while\n-    // the edits-only directories will recover by falling back\n-    // to the old state contained in their lastcheckpoint.tmp.\n-    // The edits directories should be discarded during startup because their\n-    // checkpointTime is older than that of image directories.\n-    // recreate edits in current\n-    for (Iterator\u003cStorageDirectory\u003e it\n-           \u003d storage.dirIterator(NameNodeDirType.EDITS); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      if (errorSDs.contains(sd)) {\n-        continue;\n-      }\n-\n-      // if this directory already stores the image and edits, then it was\n-      // already processed in the earlier loop.\n-      if (sd.getStorageDirType() \u003d\u003d NameNodeDirType.IMAGE_AND_EDITS) {\n-        continue;\n-      }\n-\n-      try {\n-        FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n-        Thread saveThread \u003d new Thread(saver, saver.toString());\n-        saveThreads.add(saveThread);\n-        saveThread.start();\n-      } catch (Exception e) {\n-        LOG.error(\"Failed save to edits directory \" + sd.getRoot(), e);\n-        errorSDs.add(sd);\n-        continue;\n-      }\n-    }\n-    waitForThreads(saveThreads);\n-\n-    // mv lastcheckpoint.tmp -\u003e previous.checkpoint\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      if (errorSDs.contains(sd)) {\n-        continue;\n-      }\n-      try {\n-        storage.moveLastCheckpoint(sd);\n-      } catch(IOException ie) {\n-        LOG.error(\"Unable to move last checkpoint for \" + sd.getRoot(), ie);\n-        errorSDs.add(sd);\n-        continue;\n+    long imageTxId \u003d editLog.getLastWrittenTxId();\n+    try {\n+      saveFSImageInAllDirs(imageTxId);\n+      storage.writeAll();\n+    } finally {\n+      if (editLogWasOpen) {\n+        editLog.startLogSegment(imageTxId + 1, true);\n+        // Take this opportunity to note the current transaction\n+        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n       }\n     }\n     \n-    try {\n-      storage.reportErrorsOnDirectories(errorSDs);\n-      \n-      // If there was an error in every storage dir, each one will have been\n-      // removed from the list of storage directories.\n-      if (storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0 ||\n-          storage.getNumStorageDirs(NameNodeDirType.EDITS) \u003d\u003d 0) {\n-        throw new IOException(\"Failed to save any storage directories while saving namespace\");\n-      }\n-      \n-      if(!editLog.isOpen()) editLog.open();\n-    } finally {\n-      ckptState \u003d CheckpointStates.UPLOAD_DONE;\n-    }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void saveNamespace() throws IOException {\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    boolean editLogWasOpen \u003d editLog.isOpen();\n    \n    if (editLogWasOpen) {\n      editLog.endCurrentLogSegment(true);\n    }\n    long imageTxId \u003d editLog.getLastWrittenTxId();\n    try {\n      saveFSImageInAllDirs(imageTxId);\n      storage.writeAll();\n    } finally {\n      if (editLogWasOpen) {\n        editLog.startLogSegment(imageTxId + 1, true);\n        // Take this opportunity to note the current transaction\n        storage.writeTransactionIdFileToStorage(imageTxId + 1);\n      }\n    }\n    \n  }",
          "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {}
        }
      ]
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,111 @@\n+  void saveNamespace(boolean renewCheckpointTime) throws IOException {\n+ \n+    // try to restore all failed edit logs here\n+    assert editLog !\u003d null : \"editLog must be initialized\";\n+    storage.attemptRestoreRemovedStorage();\n+\n+    editLog.close();\n+    if(renewCheckpointTime)\n+      storage.setCheckpointTime(now());\n+    List\u003cStorageDirectory\u003e errorSDs \u003d\n+      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n+\n+    // mv current -\u003e lastcheckpoint.tmp\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      StorageDirectory sd \u003d it.next();\n+      try {\n+        storage.moveCurrent(sd);\n+      } catch(IOException ie) {\n+        LOG.error(\"Unable to move current for \" + sd.getRoot(), ie);\n+        errorSDs.add(sd);\n+      }\n+    }\n+\n+    List\u003cThread\u003e saveThreads \u003d new ArrayList\u003cThread\u003e();\n+    // save images into current\n+    for (Iterator\u003cStorageDirectory\u003e it\n+           \u003d storage.dirIterator(NameNodeDirType.IMAGE); it.hasNext();) {\n+      StorageDirectory sd \u003d it.next();\n+      if (errorSDs.contains(sd)) {\n+        continue;\n+      }\n+      try {\n+        FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n+        Thread saveThread \u003d new Thread(saver, saver.toString());\n+        saveThreads.add(saveThread);\n+        saveThread.start();\n+      } catch (Exception e) {\n+        LOG.error(\"Failed save to image directory \" + sd.getRoot(), e);\n+        errorSDs.add(sd);\n+        continue;\n+      }\n+    }\n+    waitForThreads(saveThreads);\n+    saveThreads.clear();\n+\n+    // -NOTE-\n+    // If NN has image-only and edits-only storage directories and fails here\n+    // the image will have the latest namespace state.\n+    // During startup the image-only directories will recover by discarding\n+    // lastcheckpoint.tmp, while\n+    // the edits-only directories will recover by falling back\n+    // to the old state contained in their lastcheckpoint.tmp.\n+    // The edits directories should be discarded during startup because their\n+    // checkpointTime is older than that of image directories.\n+    // recreate edits in current\n+    for (Iterator\u003cStorageDirectory\u003e it\n+           \u003d storage.dirIterator(NameNodeDirType.EDITS); it.hasNext();) {\n+      StorageDirectory sd \u003d it.next();\n+      if (errorSDs.contains(sd)) {\n+        continue;\n+      }\n+\n+      // if this directory already stores the image and edits, then it was\n+      // already processed in the earlier loop.\n+      if (sd.getStorageDirType() \u003d\u003d NameNodeDirType.IMAGE_AND_EDITS) {\n+        continue;\n+      }\n+\n+      try {\n+        FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n+        Thread saveThread \u003d new Thread(saver, saver.toString());\n+        saveThreads.add(saveThread);\n+        saveThread.start();\n+      } catch (Exception e) {\n+        LOG.error(\"Failed save to edits directory \" + sd.getRoot(), e);\n+        errorSDs.add(sd);\n+        continue;\n+      }\n+    }\n+    waitForThreads(saveThreads);\n+\n+    // mv lastcheckpoint.tmp -\u003e previous.checkpoint\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      StorageDirectory sd \u003d it.next();\n+      if (errorSDs.contains(sd)) {\n+        continue;\n+      }\n+      try {\n+        storage.moveLastCheckpoint(sd);\n+      } catch(IOException ie) {\n+        LOG.error(\"Unable to move last checkpoint for \" + sd.getRoot(), ie);\n+        errorSDs.add(sd);\n+        continue;\n+      }\n+    }\n+    \n+    try {\n+      storage.reportErrorsOnDirectories(errorSDs);\n+      \n+      // If there was an error in every storage dir, each one will have been\n+      // removed from the list of storage directories.\n+      if (storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0 ||\n+          storage.getNumStorageDirs(NameNodeDirType.EDITS) \u003d\u003d 0) {\n+        throw new IOException(\"Failed to save any storage directories while saving namespace\");\n+      }\n+      \n+      if(!editLog.isOpen()) editLog.open();\n+    } finally {\n+      ckptState \u003d CheckpointStates.UPLOAD_DONE;\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void saveNamespace(boolean renewCheckpointTime) throws IOException {\n \n    // try to restore all failed edit logs here\n    assert editLog !\u003d null : \"editLog must be initialized\";\n    storage.attemptRestoreRemovedStorage();\n\n    editLog.close();\n    if(renewCheckpointTime)\n      storage.setCheckpointTime(now());\n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n\n    // mv current -\u003e lastcheckpoint.tmp\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        storage.moveCurrent(sd);\n      } catch(IOException ie) {\n        LOG.error(\"Unable to move current for \" + sd.getRoot(), ie);\n        errorSDs.add(sd);\n      }\n    }\n\n    List\u003cThread\u003e saveThreads \u003d new ArrayList\u003cThread\u003e();\n    // save images into current\n    for (Iterator\u003cStorageDirectory\u003e it\n           \u003d storage.dirIterator(NameNodeDirType.IMAGE); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (errorSDs.contains(sd)) {\n        continue;\n      }\n      try {\n        FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n        Thread saveThread \u003d new Thread(saver, saver.toString());\n        saveThreads.add(saveThread);\n        saveThread.start();\n      } catch (Exception e) {\n        LOG.error(\"Failed save to image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    waitForThreads(saveThreads);\n    saveThreads.clear();\n\n    // -NOTE-\n    // If NN has image-only and edits-only storage directories and fails here\n    // the image will have the latest namespace state.\n    // During startup the image-only directories will recover by discarding\n    // lastcheckpoint.tmp, while\n    // the edits-only directories will recover by falling back\n    // to the old state contained in their lastcheckpoint.tmp.\n    // The edits directories should be discarded during startup because their\n    // checkpointTime is older than that of image directories.\n    // recreate edits in current\n    for (Iterator\u003cStorageDirectory\u003e it\n           \u003d storage.dirIterator(NameNodeDirType.EDITS); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (errorSDs.contains(sd)) {\n        continue;\n      }\n\n      // if this directory already stores the image and edits, then it was\n      // already processed in the earlier loop.\n      if (sd.getStorageDirType() \u003d\u003d NameNodeDirType.IMAGE_AND_EDITS) {\n        continue;\n      }\n\n      try {\n        FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n        Thread saveThread \u003d new Thread(saver, saver.toString());\n        saveThreads.add(saveThread);\n        saveThread.start();\n      } catch (Exception e) {\n        LOG.error(\"Failed save to edits directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    waitForThreads(saveThreads);\n\n    // mv lastcheckpoint.tmp -\u003e previous.checkpoint\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (errorSDs.contains(sd)) {\n        continue;\n      }\n      try {\n        storage.moveLastCheckpoint(sd);\n      } catch(IOException ie) {\n        LOG.error(\"Unable to move last checkpoint for \" + sd.getRoot(), ie);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    \n    try {\n      storage.reportErrorsOnDirectories(errorSDs);\n      \n      // If there was an error in every storage dir, each one will have been\n      // removed from the list of storage directories.\n      if (storage.getNumStorageDirs(NameNodeDirType.IMAGE) \u003d\u003d 0 ||\n          storage.getNumStorageDirs(NameNodeDirType.EDITS) \u003d\u003d 0) {\n        throw new IOException(\"Failed to save any storage directories while saving namespace\");\n      }\n      \n      if(!editLog.isOpen()) editLog.open();\n    } finally {\n      ckptState \u003d CheckpointStates.UPLOAD_DONE;\n    }\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
    }
  }
}