{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AuthenticationFilter.java",
  "functionName": "doFilter",
  "functionId": "doFilter___request-ServletRequest__response-ServletResponse__filterChain-FilterChain",
  "sourceFilePath": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
  "functionStartLine": 504,
  "functionEndLine": 629,
  "numCommitsSeen": 36,
  "timeTaken": 3381,
  "changeHistory": [
    "0202480742b8539aa7aa1e94dc9cab75d863cc4e",
    "dec8dfdfa66c37f8cc8c0900fd12f98c7529b99e",
    "71aedfabf39e03104c8d22456e95ef6349aae6c0",
    "a815cc157ceb24e02189634a85abed8e874568e0",
    "0ebe84d30af2046775884c9fb1e054da31582657",
    "ef5af4f8de91fbe7891ae3471eb03397e74e1811",
    "6d7a6766bd55b355e44dbdcc4dfa22b050b1a509",
    "3c4d44d4cef8f908b76ba9fff28666b9e8ee56b1",
    "95ebf9ecc4809b8a977a0a847515649486a004c4",
    "5a2e0ee4d293ed4e5da32edc7331ae350432def6",
    "22c65886237ed7c4e8cfa0aff95d751b6d70f7cc",
    "a7993ef5e8d34c16b1dbaaa562048456770dbf4b",
    "90d9cab02e8652c119565230ec6f1bc1cde08195",
    "2b016dac8232e0f5c43293adcbdf7164f5fca74c",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "a0f120ce68dddb0cb31b64c89f3224313f3cb5af"
  ],
  "changeHistoryShort": {
    "0202480742b8539aa7aa1e94dc9cab75d863cc4e": "Ybodychange",
    "dec8dfdfa66c37f8cc8c0900fd12f98c7529b99e": "Ybodychange",
    "71aedfabf39e03104c8d22456e95ef6349aae6c0": "Ybodychange",
    "a815cc157ceb24e02189634a85abed8e874568e0": "Ybodychange",
    "0ebe84d30af2046775884c9fb1e054da31582657": "Ybodychange",
    "ef5af4f8de91fbe7891ae3471eb03397e74e1811": "Ybodychange",
    "6d7a6766bd55b355e44dbdcc4dfa22b050b1a509": "Ybodychange",
    "3c4d44d4cef8f908b76ba9fff28666b9e8ee56b1": "Ybodychange",
    "95ebf9ecc4809b8a977a0a847515649486a004c4": "Ybodychange",
    "5a2e0ee4d293ed4e5da32edc7331ae350432def6": "Ybodychange",
    "22c65886237ed7c4e8cfa0aff95d751b6d70f7cc": "Ybodychange",
    "a7993ef5e8d34c16b1dbaaa562048456770dbf4b": "Ybodychange",
    "90d9cab02e8652c119565230ec6f1bc1cde08195": "Ybodychange",
    "2b016dac8232e0f5c43293adcbdf7164f5fca74c": "Yfilerename",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "a0f120ce68dddb0cb31b64c89f3224313f3cb5af": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0202480742b8539aa7aa1e94dc9cab75d863cc4e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13174. Add more debug logs for delegation tokens and authentication.\n",
      "commitDate": "08/06/17 9:34 PM",
      "commitName": "0202480742b8539aa7aa1e94dc9cab75d863cc4e",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "05/01/17 5:21 PM",
      "commitNameOld": "5d182949badb2eb80393de7ba3838102d006488b",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 154.13,
      "commitsBetweenForRepo": 840,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,118 +1,126 @@\n   public void doFilter(ServletRequest request,\n                        ServletResponse response,\n                        FilterChain filterChain)\n                            throws IOException, ServletException {\n     boolean unauthorizedResponse \u003d true;\n     int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n     AuthenticationException authenticationEx \u003d null;\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n     boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n     try {\n       boolean newToken \u003d false;\n       AuthenticationToken token;\n       try {\n         token \u003d getToken(httpRequest);\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Got token {} from httpRequest {}\", token,\n+              getRequestURL(httpRequest));\n+        }\n       }\n       catch (AuthenticationException ex) {\n         LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n         // will be sent back in a 401 unless filter authenticates\n         authenticationEx \u003d ex;\n         token \u003d null;\n       }\n       if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n         if (token \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Request [{}] triggering authentication\",\n-                getRequestURL(httpRequest));\n+            LOG.debug(\"Request [{}] triggering authentication. handler: {}\",\n+                getRequestURL(httpRequest), authHandler.getClass());\n           }\n           token \u003d authHandler.authenticate(httpRequest, httpResponse);\n           if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n             if (token.getMaxInactives() \u003e 0) {\n               token.setMaxInactives(System.currentTimeMillis()\n                   + getMaxInactiveInterval() * 1000);\n             }\n             if (token.getExpires() !\u003d 0) {\n               token.setExpires(System.currentTimeMillis()\n                   + getValidity() * 1000);\n             }\n           }\n           newToken \u003d true;\n         }\n         if (token !\u003d null) {\n           unauthorizedResponse \u003d false;\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] user [{}] authenticated\",\n                 getRequestURL(httpRequest), token.getUserName());\n           }\n           final AuthenticationToken authToken \u003d token;\n           httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n \n             @Override\n             public String getAuthType() {\n               return authToken.getType();\n             }\n \n             @Override\n             public String getRemoteUser() {\n               return authToken.getUserName();\n             }\n \n             @Override\n             public Principal getUserPrincipal() {\n               return (authToken !\u003d AuthenticationToken.ANONYMOUS) ?\n                   authToken : null;\n             }\n           };\n \n           // If cookie persistence is configured to false,\n           // it means the cookie will be a session cookie.\n           // If the token is an old one, renew the its maxInactiveInterval.\n           if (!newToken \u0026\u0026 !isCookiePersistent()\n               \u0026\u0026 getMaxInactiveInterval() \u003e 0) {\n             token.setMaxInactives(System.currentTimeMillis()\n                 + getMaxInactiveInterval() * 1000);\n             token.setExpires(token.getExpires());\n             newToken \u003d true;\n           }\n           if (newToken \u0026\u0026 !token.isExpired()\n               \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n             String signedToken \u003d signer.sign(token.toString());\n             createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                     getCookiePath(), token.getExpires(),\n                     isCookiePersistent(), isHttps);\n           }\n           doFilter(filterChain, httpRequest, httpResponse);\n         }\n       } else {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"managementOperation returned false for request {}.\"\n+                  + \" token: {}\", getRequestURL(httpRequest), token);\n+        }\n         unauthorizedResponse \u003d false;\n       }\n     } catch (AuthenticationException ex) {\n       // exception from the filter itself is fatal\n       errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n       authenticationEx \u003d ex;\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\n       } else {\n         LOG.warn(\"Authentication exception: \" + ex.getMessage());\n       }\n     }\n     if (unauthorizedResponse) {\n       if (!httpResponse.isCommitted()) {\n         createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                 getCookiePath(), 0, isCookiePersistent(), isHttps);\n         // If response code is 401. Then WWW-Authenticate Header should be\n         // present.. reset to 403 if not found..\n         if ((errCode \u003d\u003d HttpServletResponse.SC_UNAUTHORIZED)\n             \u0026\u0026 (!httpResponse.containsHeader(\n                 KerberosAuthenticator.WWW_AUTHENTICATE))) {\n           errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n         }\n         if (authenticationEx \u003d\u003d null) {\n           httpResponse.sendError(errCode, \"Authentication required\");\n         } else {\n           httpResponse.sendError(errCode, authenticationEx.getMessage());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request,\n                       ServletResponse response,\n                       FilterChain filterChain)\n                           throws IOException, ServletException {\n    boolean unauthorizedResponse \u003d true;\n    int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n    AuthenticationException authenticationEx \u003d null;\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Got token {} from httpRequest {}\", token,\n              getRequestURL(httpRequest));\n        }\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        // will be sent back in a 401 unless filter authenticates\n        authenticationEx \u003d ex;\n        token \u003d null;\n      }\n      if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n        if (token \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] triggering authentication. handler: {}\",\n                getRequestURL(httpRequest), authHandler.getClass());\n          }\n          token \u003d authHandler.authenticate(httpRequest, httpResponse);\n          if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            if (token.getMaxInactives() \u003e 0) {\n              token.setMaxInactives(System.currentTimeMillis()\n                  + getMaxInactiveInterval() * 1000);\n            }\n            if (token.getExpires() !\u003d 0) {\n              token.setExpires(System.currentTimeMillis()\n                  + getValidity() * 1000);\n            }\n          }\n          newToken \u003d true;\n        }\n        if (token !\u003d null) {\n          unauthorizedResponse \u003d false;\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] user [{}] authenticated\",\n                getRequestURL(httpRequest), token.getUserName());\n          }\n          final AuthenticationToken authToken \u003d token;\n          httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n            @Override\n            public String getAuthType() {\n              return authToken.getType();\n            }\n\n            @Override\n            public String getRemoteUser() {\n              return authToken.getUserName();\n            }\n\n            @Override\n            public Principal getUserPrincipal() {\n              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ?\n                  authToken : null;\n            }\n          };\n\n          // If cookie persistence is configured to false,\n          // it means the cookie will be a session cookie.\n          // If the token is an old one, renew the its maxInactiveInterval.\n          if (!newToken \u0026\u0026 !isCookiePersistent()\n              \u0026\u0026 getMaxInactiveInterval() \u003e 0) {\n            token.setMaxInactives(System.currentTimeMillis()\n                + getMaxInactiveInterval() * 1000);\n            token.setExpires(token.getExpires());\n            newToken \u003d true;\n          }\n          if (newToken \u0026\u0026 !token.isExpired()\n              \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            String signedToken \u003d signer.sign(token.toString());\n            createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                    getCookiePath(), token.getExpires(),\n                    isCookiePersistent(), isHttps);\n          }\n          doFilter(filterChain, httpRequest, httpResponse);\n        }\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"managementOperation returned false for request {}.\"\n                  + \" token: {}\", getRequestURL(httpRequest), token);\n        }\n        unauthorizedResponse \u003d false;\n      }\n    } catch (AuthenticationException ex) {\n      // exception from the filter itself is fatal\n      errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n      authenticationEx \u003d ex;\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\n      } else {\n        LOG.warn(\"Authentication exception: \" + ex.getMessage());\n      }\n    }\n    if (unauthorizedResponse) {\n      if (!httpResponse.isCommitted()) {\n        createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                getCookiePath(), 0, isCookiePersistent(), isHttps);\n        // If response code is 401. Then WWW-Authenticate Header should be\n        // present.. reset to 403 if not found..\n        if ((errCode \u003d\u003d HttpServletResponse.SC_UNAUTHORIZED)\n            \u0026\u0026 (!httpResponse.containsHeader(\n                KerberosAuthenticator.WWW_AUTHENTICATE))) {\n          errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n        }\n        if (authenticationEx \u003d\u003d null) {\n          httpResponse.sendError(errCode, \"Authentication required\");\n        } else {\n          httpResponse.sendError(errCode, authenticationEx.getMessage());\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "dec8dfdfa66c37f8cc8c0900fd12f98c7529b99e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12587. Hadoop AuthToken refuses to work without a maxinactive attribute in issued token. (Benoy Antony)\n",
      "commitDate": "09/01/16 1:41 PM",
      "commitName": "dec8dfdfa66c37f8cc8c0900fd12f98c7529b99e",
      "commitAuthor": "Benoy Antony",
      "commitDateOld": "18/08/15 1:43 PM",
      "commitNameOld": "71aedfabf39e03104c8d22456e95ef6349aae6c0",
      "commitAuthorOld": "Benoy Antony",
      "daysBetweenCommits": 144.04,
      "commitsBetweenForRepo": 969,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,118 @@\n   public void doFilter(ServletRequest request,\n                        ServletResponse response,\n                        FilterChain filterChain)\n                            throws IOException, ServletException {\n     boolean unauthorizedResponse \u003d true;\n     int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n     AuthenticationException authenticationEx \u003d null;\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n     boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n     try {\n       boolean newToken \u003d false;\n       AuthenticationToken token;\n       try {\n         token \u003d getToken(httpRequest);\n       }\n       catch (AuthenticationException ex) {\n         LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n         // will be sent back in a 401 unless filter authenticates\n         authenticationEx \u003d ex;\n         token \u003d null;\n       }\n       if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n         if (token \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] triggering authentication\",\n                 getRequestURL(httpRequest));\n           }\n           token \u003d authHandler.authenticate(httpRequest, httpResponse);\n           if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n-            if (token.getMaxInactives() !\u003d 0) {\n+            if (token.getMaxInactives() \u003e 0) {\n               token.setMaxInactives(System.currentTimeMillis()\n                   + getMaxInactiveInterval() * 1000);\n             }\n             if (token.getExpires() !\u003d 0) {\n               token.setExpires(System.currentTimeMillis()\n                   + getValidity() * 1000);\n             }\n           }\n           newToken \u003d true;\n         }\n         if (token !\u003d null) {\n           unauthorizedResponse \u003d false;\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] user [{}] authenticated\",\n                 getRequestURL(httpRequest), token.getUserName());\n           }\n           final AuthenticationToken authToken \u003d token;\n           httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n \n             @Override\n             public String getAuthType() {\n               return authToken.getType();\n             }\n \n             @Override\n             public String getRemoteUser() {\n               return authToken.getUserName();\n             }\n \n             @Override\n             public Principal getUserPrincipal() {\n               return (authToken !\u003d AuthenticationToken.ANONYMOUS) ?\n                   authToken : null;\n             }\n           };\n \n           // If cookie persistence is configured to false,\n           // it means the cookie will be a session cookie.\n           // If the token is an old one, renew the its maxInactiveInterval.\n           if (!newToken \u0026\u0026 !isCookiePersistent()\n               \u0026\u0026 getMaxInactiveInterval() \u003e 0) {\n             token.setMaxInactives(System.currentTimeMillis()\n                 + getMaxInactiveInterval() * 1000);\n+            token.setExpires(token.getExpires());\n             newToken \u003d true;\n           }\n           if (newToken \u0026\u0026 !token.isExpired()\n               \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n             String signedToken \u003d signer.sign(token.toString());\n             createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                     getCookiePath(), token.getExpires(),\n                     isCookiePersistent(), isHttps);\n           }\n           doFilter(filterChain, httpRequest, httpResponse);\n         }\n       } else {\n         unauthorizedResponse \u003d false;\n       }\n     } catch (AuthenticationException ex) {\n       // exception from the filter itself is fatal\n       errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n       authenticationEx \u003d ex;\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\n       } else {\n         LOG.warn(\"Authentication exception: \" + ex.getMessage());\n       }\n     }\n     if (unauthorizedResponse) {\n       if (!httpResponse.isCommitted()) {\n         createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                 getCookiePath(), 0, isCookiePersistent(), isHttps);\n         // If response code is 401. Then WWW-Authenticate Header should be\n         // present.. reset to 403 if not found..\n         if ((errCode \u003d\u003d HttpServletResponse.SC_UNAUTHORIZED)\n             \u0026\u0026 (!httpResponse.containsHeader(\n                 KerberosAuthenticator.WWW_AUTHENTICATE))) {\n           errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n         }\n         if (authenticationEx \u003d\u003d null) {\n           httpResponse.sendError(errCode, \"Authentication required\");\n         } else {\n           httpResponse.sendError(errCode, authenticationEx.getMessage());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request,\n                       ServletResponse response,\n                       FilterChain filterChain)\n                           throws IOException, ServletException {\n    boolean unauthorizedResponse \u003d true;\n    int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n    AuthenticationException authenticationEx \u003d null;\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        // will be sent back in a 401 unless filter authenticates\n        authenticationEx \u003d ex;\n        token \u003d null;\n      }\n      if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n        if (token \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] triggering authentication\",\n                getRequestURL(httpRequest));\n          }\n          token \u003d authHandler.authenticate(httpRequest, httpResponse);\n          if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            if (token.getMaxInactives() \u003e 0) {\n              token.setMaxInactives(System.currentTimeMillis()\n                  + getMaxInactiveInterval() * 1000);\n            }\n            if (token.getExpires() !\u003d 0) {\n              token.setExpires(System.currentTimeMillis()\n                  + getValidity() * 1000);\n            }\n          }\n          newToken \u003d true;\n        }\n        if (token !\u003d null) {\n          unauthorizedResponse \u003d false;\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] user [{}] authenticated\",\n                getRequestURL(httpRequest), token.getUserName());\n          }\n          final AuthenticationToken authToken \u003d token;\n          httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n            @Override\n            public String getAuthType() {\n              return authToken.getType();\n            }\n\n            @Override\n            public String getRemoteUser() {\n              return authToken.getUserName();\n            }\n\n            @Override\n            public Principal getUserPrincipal() {\n              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ?\n                  authToken : null;\n            }\n          };\n\n          // If cookie persistence is configured to false,\n          // it means the cookie will be a session cookie.\n          // If the token is an old one, renew the its maxInactiveInterval.\n          if (!newToken \u0026\u0026 !isCookiePersistent()\n              \u0026\u0026 getMaxInactiveInterval() \u003e 0) {\n            token.setMaxInactives(System.currentTimeMillis()\n                + getMaxInactiveInterval() * 1000);\n            token.setExpires(token.getExpires());\n            newToken \u003d true;\n          }\n          if (newToken \u0026\u0026 !token.isExpired()\n              \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            String signedToken \u003d signer.sign(token.toString());\n            createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                    getCookiePath(), token.getExpires(),\n                    isCookiePersistent(), isHttps);\n          }\n          doFilter(filterChain, httpRequest, httpResponse);\n        }\n      } else {\n        unauthorizedResponse \u003d false;\n      }\n    } catch (AuthenticationException ex) {\n      // exception from the filter itself is fatal\n      errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n      authenticationEx \u003d ex;\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\n      } else {\n        LOG.warn(\"Authentication exception: \" + ex.getMessage());\n      }\n    }\n    if (unauthorizedResponse) {\n      if (!httpResponse.isCommitted()) {\n        createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                getCookiePath(), 0, isCookiePersistent(), isHttps);\n        // If response code is 401. Then WWW-Authenticate Header should be\n        // present.. reset to 403 if not found..\n        if ((errCode \u003d\u003d HttpServletResponse.SC_UNAUTHORIZED)\n            \u0026\u0026 (!httpResponse.containsHeader(\n                KerberosAuthenticator.WWW_AUTHENTICATE))) {\n          errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n        }\n        if (authenticationEx \u003d\u003d null) {\n          httpResponse.sendError(errCode, \"Authentication required\");\n        } else {\n          httpResponse.sendError(errCode, authenticationEx.getMessage());\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "71aedfabf39e03104c8d22456e95ef6349aae6c0": {
      "type": "Ybodychange",
      "commitMessage": "hadoop-12050. Enable MaxInactiveInterval for hadoop http auth token. Contributed by Huizhi Lu.\n",
      "commitDate": "18/08/15 1:43 PM",
      "commitName": "71aedfabf39e03104c8d22456e95ef6349aae6c0",
      "commitAuthor": "Benoy Antony",
      "commitDateOld": "24/06/15 3:59 PM",
      "commitNameOld": "a815cc157ceb24e02189634a85abed8e874568e0",
      "commitAuthorOld": "Benoy Antony",
      "daysBetweenCommits": 54.91,
      "commitsBetweenForRepo": 319,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,95 +1,117 @@\n-  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n-      throws IOException, ServletException {\n+  public void doFilter(ServletRequest request,\n+                       ServletResponse response,\n+                       FilterChain filterChain)\n+                           throws IOException, ServletException {\n     boolean unauthorizedResponse \u003d true;\n     int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n     AuthenticationException authenticationEx \u003d null;\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n     boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n     try {\n       boolean newToken \u003d false;\n       AuthenticationToken token;\n       try {\n         token \u003d getToken(httpRequest);\n       }\n       catch (AuthenticationException ex) {\n         LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n         // will be sent back in a 401 unless filter authenticates\n         authenticationEx \u003d ex;\n         token \u003d null;\n       }\n       if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n         if (token \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n+            LOG.debug(\"Request [{}] triggering authentication\",\n+                getRequestURL(httpRequest));\n           }\n           token \u003d authHandler.authenticate(httpRequest, httpResponse);\n-          if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n-              token !\u003d AuthenticationToken.ANONYMOUS) {\n-            token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n+          if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n+            if (token.getMaxInactives() !\u003d 0) {\n+              token.setMaxInactives(System.currentTimeMillis()\n+                  + getMaxInactiveInterval() * 1000);\n+            }\n+            if (token.getExpires() !\u003d 0) {\n+              token.setExpires(System.currentTimeMillis()\n+                  + getValidity() * 1000);\n+            }\n           }\n           newToken \u003d true;\n         }\n         if (token !\u003d null) {\n           unauthorizedResponse \u003d false;\n           if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n+            LOG.debug(\"Request [{}] user [{}] authenticated\",\n+                getRequestURL(httpRequest), token.getUserName());\n           }\n           final AuthenticationToken authToken \u003d token;\n           httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n \n             @Override\n             public String getAuthType() {\n               return authToken.getType();\n             }\n \n             @Override\n             public String getRemoteUser() {\n               return authToken.getUserName();\n             }\n \n             @Override\n             public Principal getUserPrincipal() {\n-              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n+              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ?\n+                  authToken : null;\n             }\n           };\n-          if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n+\n+          // If cookie persistence is configured to false,\n+          // it means the cookie will be a session cookie.\n+          // If the token is an old one, renew the its maxInactiveInterval.\n+          if (!newToken \u0026\u0026 !isCookiePersistent()\n+              \u0026\u0026 getMaxInactiveInterval() \u003e 0) {\n+            token.setMaxInactives(System.currentTimeMillis()\n+                + getMaxInactiveInterval() * 1000);\n+            newToken \u003d true;\n+          }\n+          if (newToken \u0026\u0026 !token.isExpired()\n+              \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n             String signedToken \u003d signer.sign(token.toString());\n             createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                     getCookiePath(), token.getExpires(),\n                     isCookiePersistent(), isHttps);\n           }\n           doFilter(filterChain, httpRequest, httpResponse);\n         }\n       } else {\n         unauthorizedResponse \u003d false;\n       }\n     } catch (AuthenticationException ex) {\n       // exception from the filter itself is fatal\n       errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n       authenticationEx \u003d ex;\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\n       } else {\n         LOG.warn(\"Authentication exception: \" + ex.getMessage());\n       }\n     }\n     if (unauthorizedResponse) {\n       if (!httpResponse.isCommitted()) {\n         createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                 getCookiePath(), 0, isCookiePersistent(), isHttps);\n         // If response code is 401. Then WWW-Authenticate Header should be\n         // present.. reset to 403 if not found..\n         if ((errCode \u003d\u003d HttpServletResponse.SC_UNAUTHORIZED)\n             \u0026\u0026 (!httpResponse.containsHeader(\n                 KerberosAuthenticator.WWW_AUTHENTICATE))) {\n           errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n         }\n         if (authenticationEx \u003d\u003d null) {\n           httpResponse.sendError(errCode, \"Authentication required\");\n         } else {\n           httpResponse.sendError(errCode, authenticationEx.getMessage());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request,\n                       ServletResponse response,\n                       FilterChain filterChain)\n                           throws IOException, ServletException {\n    boolean unauthorizedResponse \u003d true;\n    int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n    AuthenticationException authenticationEx \u003d null;\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        // will be sent back in a 401 unless filter authenticates\n        authenticationEx \u003d ex;\n        token \u003d null;\n      }\n      if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n        if (token \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] triggering authentication\",\n                getRequestURL(httpRequest));\n          }\n          token \u003d authHandler.authenticate(httpRequest, httpResponse);\n          if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            if (token.getMaxInactives() !\u003d 0) {\n              token.setMaxInactives(System.currentTimeMillis()\n                  + getMaxInactiveInterval() * 1000);\n            }\n            if (token.getExpires() !\u003d 0) {\n              token.setExpires(System.currentTimeMillis()\n                  + getValidity() * 1000);\n            }\n          }\n          newToken \u003d true;\n        }\n        if (token !\u003d null) {\n          unauthorizedResponse \u003d false;\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] user [{}] authenticated\",\n                getRequestURL(httpRequest), token.getUserName());\n          }\n          final AuthenticationToken authToken \u003d token;\n          httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n            @Override\n            public String getAuthType() {\n              return authToken.getType();\n            }\n\n            @Override\n            public String getRemoteUser() {\n              return authToken.getUserName();\n            }\n\n            @Override\n            public Principal getUserPrincipal() {\n              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ?\n                  authToken : null;\n            }\n          };\n\n          // If cookie persistence is configured to false,\n          // it means the cookie will be a session cookie.\n          // If the token is an old one, renew the its maxInactiveInterval.\n          if (!newToken \u0026\u0026 !isCookiePersistent()\n              \u0026\u0026 getMaxInactiveInterval() \u003e 0) {\n            token.setMaxInactives(System.currentTimeMillis()\n                + getMaxInactiveInterval() * 1000);\n            newToken \u003d true;\n          }\n          if (newToken \u0026\u0026 !token.isExpired()\n              \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            String signedToken \u003d signer.sign(token.toString());\n            createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                    getCookiePath(), token.getExpires(),\n                    isCookiePersistent(), isHttps);\n          }\n          doFilter(filterChain, httpRequest, httpResponse);\n        }\n      } else {\n        unauthorizedResponse \u003d false;\n      }\n    } catch (AuthenticationException ex) {\n      // exception from the filter itself is fatal\n      errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n      authenticationEx \u003d ex;\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\n      } else {\n        LOG.warn(\"Authentication exception: \" + ex.getMessage());\n      }\n    }\n    if (unauthorizedResponse) {\n      if (!httpResponse.isCommitted()) {\n        createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                getCookiePath(), 0, isCookiePersistent(), isHttps);\n        // If response code is 401. Then WWW-Authenticate Header should be\n        // present.. reset to 403 if not found..\n        if ((errCode \u003d\u003d HttpServletResponse.SC_UNAUTHORIZED)\n            \u0026\u0026 (!httpResponse.containsHeader(\n                KerberosAuthenticator.WWW_AUTHENTICATE))) {\n          errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n        }\n        if (authenticationEx \u003d\u003d null) {\n          httpResponse.sendError(errCode, \"Authentication required\");\n        } else {\n          httpResponse.sendError(errCode, authenticationEx.getMessage());\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "a815cc157ceb24e02189634a85abed8e874568e0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12049. Control http authentication cookie persistence via configuration. Contributed by Huizhi Lu.\n",
      "commitDate": "24/06/15 3:59 PM",
      "commitName": "a815cc157ceb24e02189634a85abed8e874568e0",
      "commitAuthor": "Benoy Antony",
      "commitDateOld": "27/04/15 1:25 PM",
      "commitNameOld": "9fec02c069f9bb24b5ee99031917075b4c7a7682",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 58.11,
      "commitsBetweenForRepo": 520,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,95 @@\n   public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n       throws IOException, ServletException {\n     boolean unauthorizedResponse \u003d true;\n     int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n     AuthenticationException authenticationEx \u003d null;\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n     boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n     try {\n       boolean newToken \u003d false;\n       AuthenticationToken token;\n       try {\n         token \u003d getToken(httpRequest);\n       }\n       catch (AuthenticationException ex) {\n         LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n         // will be sent back in a 401 unless filter authenticates\n         authenticationEx \u003d ex;\n         token \u003d null;\n       }\n       if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n         if (token \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n           }\n           token \u003d authHandler.authenticate(httpRequest, httpResponse);\n           if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n               token !\u003d AuthenticationToken.ANONYMOUS) {\n             token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n           }\n           newToken \u003d true;\n         }\n         if (token !\u003d null) {\n           unauthorizedResponse \u003d false;\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n           }\n           final AuthenticationToken authToken \u003d token;\n           httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n \n             @Override\n             public String getAuthType() {\n               return authToken.getType();\n             }\n \n             @Override\n             public String getRemoteUser() {\n               return authToken.getUserName();\n             }\n \n             @Override\n             public Principal getUserPrincipal() {\n               return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n             }\n           };\n           if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n             String signedToken \u003d signer.sign(token.toString());\n             createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n-                    getCookiePath(), token.getExpires(), isHttps);\n+                    getCookiePath(), token.getExpires(),\n+                    isCookiePersistent(), isHttps);\n           }\n           doFilter(filterChain, httpRequest, httpResponse);\n         }\n       } else {\n         unauthorizedResponse \u003d false;\n       }\n     } catch (AuthenticationException ex) {\n       // exception from the filter itself is fatal\n       errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n       authenticationEx \u003d ex;\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\n       } else {\n         LOG.warn(\"Authentication exception: \" + ex.getMessage());\n       }\n     }\n     if (unauthorizedResponse) {\n       if (!httpResponse.isCommitted()) {\n         createAuthCookie(httpResponse, \"\", getCookieDomain(),\n-                getCookiePath(), 0, isHttps);\n+                getCookiePath(), 0, isCookiePersistent(), isHttps);\n         // If response code is 401. Then WWW-Authenticate Header should be\n         // present.. reset to 403 if not found..\n         if ((errCode \u003d\u003d HttpServletResponse.SC_UNAUTHORIZED)\n             \u0026\u0026 (!httpResponse.containsHeader(\n                 KerberosAuthenticator.WWW_AUTHENTICATE))) {\n           errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n         }\n         if (authenticationEx \u003d\u003d null) {\n           httpResponse.sendError(errCode, \"Authentication required\");\n         } else {\n           httpResponse.sendError(errCode, authenticationEx.getMessage());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    boolean unauthorizedResponse \u003d true;\n    int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n    AuthenticationException authenticationEx \u003d null;\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        // will be sent back in a 401 unless filter authenticates\n        authenticationEx \u003d ex;\n        token \u003d null;\n      }\n      if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n        if (token \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n          }\n          token \u003d authHandler.authenticate(httpRequest, httpResponse);\n          if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n              token !\u003d AuthenticationToken.ANONYMOUS) {\n            token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n          }\n          newToken \u003d true;\n        }\n        if (token !\u003d null) {\n          unauthorizedResponse \u003d false;\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n          }\n          final AuthenticationToken authToken \u003d token;\n          httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n            @Override\n            public String getAuthType() {\n              return authToken.getType();\n            }\n\n            @Override\n            public String getRemoteUser() {\n              return authToken.getUserName();\n            }\n\n            @Override\n            public Principal getUserPrincipal() {\n              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n            }\n          };\n          if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            String signedToken \u003d signer.sign(token.toString());\n            createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                    getCookiePath(), token.getExpires(),\n                    isCookiePersistent(), isHttps);\n          }\n          doFilter(filterChain, httpRequest, httpResponse);\n        }\n      } else {\n        unauthorizedResponse \u003d false;\n      }\n    } catch (AuthenticationException ex) {\n      // exception from the filter itself is fatal\n      errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n      authenticationEx \u003d ex;\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\n      } else {\n        LOG.warn(\"Authentication exception: \" + ex.getMessage());\n      }\n    }\n    if (unauthorizedResponse) {\n      if (!httpResponse.isCommitted()) {\n        createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                getCookiePath(), 0, isCookiePersistent(), isHttps);\n        // If response code is 401. Then WWW-Authenticate Header should be\n        // present.. reset to 403 if not found..\n        if ((errCode \u003d\u003d HttpServletResponse.SC_UNAUTHORIZED)\n            \u0026\u0026 (!httpResponse.containsHeader(\n                KerberosAuthenticator.WWW_AUTHENTICATE))) {\n          errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n        }\n        if (authenticationEx \u003d\u003d null) {\n          httpResponse.sendError(errCode, \"Authentication required\");\n        } else {\n          httpResponse.sendError(errCode, authenticationEx.getMessage());\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "0ebe84d30af2046775884c9fb1e054da31582657": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11868. Invalid user logins trigger large backtraces in server log. Contributed by Chang Li\n",
      "commitDate": "22/04/15 1:56 PM",
      "commitName": "0ebe84d30af2046775884c9fb1e054da31582657",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "17/04/15 10:59 AM",
      "commitNameOld": "c6b5203cfdfccfa22ad5379b7fee75fed850d95e",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 5.12,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,94 @@\n   public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n       throws IOException, ServletException {\n     boolean unauthorizedResponse \u003d true;\n     int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n     AuthenticationException authenticationEx \u003d null;\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n     boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n     try {\n       boolean newToken \u003d false;\n       AuthenticationToken token;\n       try {\n         token \u003d getToken(httpRequest);\n       }\n       catch (AuthenticationException ex) {\n         LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n         // will be sent back in a 401 unless filter authenticates\n         authenticationEx \u003d ex;\n         token \u003d null;\n       }\n       if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n         if (token \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n           }\n           token \u003d authHandler.authenticate(httpRequest, httpResponse);\n           if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n               token !\u003d AuthenticationToken.ANONYMOUS) {\n             token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n           }\n           newToken \u003d true;\n         }\n         if (token !\u003d null) {\n           unauthorizedResponse \u003d false;\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n           }\n           final AuthenticationToken authToken \u003d token;\n           httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n \n             @Override\n             public String getAuthType() {\n               return authToken.getType();\n             }\n \n             @Override\n             public String getRemoteUser() {\n               return authToken.getUserName();\n             }\n \n             @Override\n             public Principal getUserPrincipal() {\n               return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n             }\n           };\n           if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n             String signedToken \u003d signer.sign(token.toString());\n             createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                     getCookiePath(), token.getExpires(), isHttps);\n           }\n           doFilter(filterChain, httpRequest, httpResponse);\n         }\n       } else {\n         unauthorizedResponse \u003d false;\n       }\n     } catch (AuthenticationException ex) {\n       // exception from the filter itself is fatal\n       errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n       authenticationEx \u003d ex;\n-      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\n+      } else {\n+        LOG.warn(\"Authentication exception: \" + ex.getMessage());\n+      }\n     }\n     if (unauthorizedResponse) {\n       if (!httpResponse.isCommitted()) {\n         createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                 getCookiePath(), 0, isHttps);\n         // If response code is 401. Then WWW-Authenticate Header should be\n         // present.. reset to 403 if not found..\n         if ((errCode \u003d\u003d HttpServletResponse.SC_UNAUTHORIZED)\n             \u0026\u0026 (!httpResponse.containsHeader(\n                 KerberosAuthenticator.WWW_AUTHENTICATE))) {\n           errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n         }\n         if (authenticationEx \u003d\u003d null) {\n           httpResponse.sendError(errCode, \"Authentication required\");\n         } else {\n           httpResponse.sendError(errCode, authenticationEx.getMessage());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    boolean unauthorizedResponse \u003d true;\n    int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n    AuthenticationException authenticationEx \u003d null;\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        // will be sent back in a 401 unless filter authenticates\n        authenticationEx \u003d ex;\n        token \u003d null;\n      }\n      if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n        if (token \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n          }\n          token \u003d authHandler.authenticate(httpRequest, httpResponse);\n          if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n              token !\u003d AuthenticationToken.ANONYMOUS) {\n            token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n          }\n          newToken \u003d true;\n        }\n        if (token !\u003d null) {\n          unauthorizedResponse \u003d false;\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n          }\n          final AuthenticationToken authToken \u003d token;\n          httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n            @Override\n            public String getAuthType() {\n              return authToken.getType();\n            }\n\n            @Override\n            public String getRemoteUser() {\n              return authToken.getUserName();\n            }\n\n            @Override\n            public Principal getUserPrincipal() {\n              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n            }\n          };\n          if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            String signedToken \u003d signer.sign(token.toString());\n            createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                    getCookiePath(), token.getExpires(), isHttps);\n          }\n          doFilter(filterChain, httpRequest, httpResponse);\n        }\n      } else {\n        unauthorizedResponse \u003d false;\n      }\n    } catch (AuthenticationException ex) {\n      // exception from the filter itself is fatal\n      errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n      authenticationEx \u003d ex;\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Authentication exception: \" + ex.getMessage(), ex);\n      } else {\n        LOG.warn(\"Authentication exception: \" + ex.getMessage());\n      }\n    }\n    if (unauthorizedResponse) {\n      if (!httpResponse.isCommitted()) {\n        createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                getCookiePath(), 0, isHttps);\n        // If response code is 401. Then WWW-Authenticate Header should be\n        // present.. reset to 403 if not found..\n        if ((errCode \u003d\u003d HttpServletResponse.SC_UNAUTHORIZED)\n            \u0026\u0026 (!httpResponse.containsHeader(\n                KerberosAuthenticator.WWW_AUTHENTICATE))) {\n          errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n        }\n        if (authenticationEx \u003d\u003d null) {\n          httpResponse.sendError(errCode, \"Authentication required\");\n        } else {\n          httpResponse.sendError(errCode, authenticationEx.getMessage());\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "ef5af4f8de91fbe7891ae3471eb03397e74e1811": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11187 NameNode - KMS communication fails after a long period of inactivity. Contributed by Arun Suresh.\n",
      "commitDate": "05/11/14 6:17 PM",
      "commitName": "ef5af4f8de91fbe7891ae3471eb03397e74e1811",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "05/11/14 5:47 PM",
      "commitNameOld": "8a261e68e4177b47be01ceae7310ea56aeb7ca38",
      "commitAuthorOld": "Aaron T. Myers",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,90 @@\n   public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n       throws IOException, ServletException {\n     boolean unauthorizedResponse \u003d true;\n     int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n     AuthenticationException authenticationEx \u003d null;\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n     boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n     try {\n       boolean newToken \u003d false;\n       AuthenticationToken token;\n       try {\n         token \u003d getToken(httpRequest);\n       }\n       catch (AuthenticationException ex) {\n         LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n         // will be sent back in a 401 unless filter authenticates\n         authenticationEx \u003d ex;\n         token \u003d null;\n       }\n       if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n         if (token \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n           }\n           token \u003d authHandler.authenticate(httpRequest, httpResponse);\n           if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n               token !\u003d AuthenticationToken.ANONYMOUS) {\n             token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n           }\n           newToken \u003d true;\n         }\n         if (token !\u003d null) {\n           unauthorizedResponse \u003d false;\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n           }\n           final AuthenticationToken authToken \u003d token;\n           httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n \n             @Override\n             public String getAuthType() {\n               return authToken.getType();\n             }\n \n             @Override\n             public String getRemoteUser() {\n               return authToken.getUserName();\n             }\n \n             @Override\n             public Principal getUserPrincipal() {\n               return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n             }\n           };\n           if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n             String signedToken \u003d signer.sign(token.toString());\n             createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                     getCookiePath(), token.getExpires(), isHttps);\n           }\n           doFilter(filterChain, httpRequest, httpResponse);\n         }\n       } else {\n         unauthorizedResponse \u003d false;\n       }\n     } catch (AuthenticationException ex) {\n       // exception from the filter itself is fatal\n       errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n       authenticationEx \u003d ex;\n       LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n     }\n     if (unauthorizedResponse) {\n       if (!httpResponse.isCommitted()) {\n         createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                 getCookiePath(), 0, isHttps);\n+        // If response code is 401. Then WWW-Authenticate Header should be\n+        // present.. reset to 403 if not found..\n+        if ((errCode \u003d\u003d HttpServletResponse.SC_UNAUTHORIZED)\n+            \u0026\u0026 (!httpResponse.containsHeader(\n+                KerberosAuthenticator.WWW_AUTHENTICATE))) {\n+          errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n+        }\n         if (authenticationEx \u003d\u003d null) {\n           httpResponse.sendError(errCode, \"Authentication required\");\n         } else {\n           httpResponse.sendError(errCode, authenticationEx.getMessage());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    boolean unauthorizedResponse \u003d true;\n    int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n    AuthenticationException authenticationEx \u003d null;\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        // will be sent back in a 401 unless filter authenticates\n        authenticationEx \u003d ex;\n        token \u003d null;\n      }\n      if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n        if (token \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n          }\n          token \u003d authHandler.authenticate(httpRequest, httpResponse);\n          if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n              token !\u003d AuthenticationToken.ANONYMOUS) {\n            token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n          }\n          newToken \u003d true;\n        }\n        if (token !\u003d null) {\n          unauthorizedResponse \u003d false;\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n          }\n          final AuthenticationToken authToken \u003d token;\n          httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n            @Override\n            public String getAuthType() {\n              return authToken.getType();\n            }\n\n            @Override\n            public String getRemoteUser() {\n              return authToken.getUserName();\n            }\n\n            @Override\n            public Principal getUserPrincipal() {\n              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n            }\n          };\n          if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            String signedToken \u003d signer.sign(token.toString());\n            createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                    getCookiePath(), token.getExpires(), isHttps);\n          }\n          doFilter(filterChain, httpRequest, httpResponse);\n        }\n      } else {\n        unauthorizedResponse \u003d false;\n      }\n    } catch (AuthenticationException ex) {\n      // exception from the filter itself is fatal\n      errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n      authenticationEx \u003d ex;\n      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n    }\n    if (unauthorizedResponse) {\n      if (!httpResponse.isCommitted()) {\n        createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                getCookiePath(), 0, isHttps);\n        // If response code is 401. Then WWW-Authenticate Header should be\n        // present.. reset to 403 if not found..\n        if ((errCode \u003d\u003d HttpServletResponse.SC_UNAUTHORIZED)\n            \u0026\u0026 (!httpResponse.containsHeader(\n                KerberosAuthenticator.WWW_AUTHENTICATE))) {\n          errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n        }\n        if (authenticationEx \u003d\u003d null) {\n          httpResponse.sendError(errCode, \"Authentication required\");\n        } else {\n          httpResponse.sendError(errCode, authenticationEx.getMessage());\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "6d7a6766bd55b355e44dbdcc4dfa22b050b1a509": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10835. Implement HTTP proxyuser support in HTTP authentication client/server libraries. (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617384 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "11/08/14 5:10 PM",
      "commitName": "6d7a6766bd55b355e44dbdcc4dfa22b050b1a509",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "05/08/14 2:21 PM",
      "commitNameOld": "2d7dcff6f42020cb91c58c5dd460d030188b8a18",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 6.12,
      "commitsBetweenForRepo": 52,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,83 +1,83 @@\n   public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n       throws IOException, ServletException {\n     boolean unauthorizedResponse \u003d true;\n     int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n     AuthenticationException authenticationEx \u003d null;\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n     boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n     try {\n       boolean newToken \u003d false;\n       AuthenticationToken token;\n       try {\n         token \u003d getToken(httpRequest);\n       }\n       catch (AuthenticationException ex) {\n         LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n         // will be sent back in a 401 unless filter authenticates\n         authenticationEx \u003d ex;\n         token \u003d null;\n       }\n       if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n         if (token \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n           }\n           token \u003d authHandler.authenticate(httpRequest, httpResponse);\n           if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n               token !\u003d AuthenticationToken.ANONYMOUS) {\n             token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n           }\n           newToken \u003d true;\n         }\n         if (token !\u003d null) {\n           unauthorizedResponse \u003d false;\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n           }\n           final AuthenticationToken authToken \u003d token;\n           httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n \n             @Override\n             public String getAuthType() {\n               return authToken.getType();\n             }\n \n             @Override\n             public String getRemoteUser() {\n               return authToken.getUserName();\n             }\n \n             @Override\n             public Principal getUserPrincipal() {\n               return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n             }\n           };\n           if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n             String signedToken \u003d signer.sign(token.toString());\n             createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                     getCookiePath(), token.getExpires(), isHttps);\n           }\n-          filterChain.doFilter(httpRequest, httpResponse);\n+          doFilter(filterChain, httpRequest, httpResponse);\n         }\n       } else {\n         unauthorizedResponse \u003d false;\n       }\n     } catch (AuthenticationException ex) {\n       // exception from the filter itself is fatal\n       errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n       authenticationEx \u003d ex;\n       LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n     }\n     if (unauthorizedResponse) {\n       if (!httpResponse.isCommitted()) {\n         createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                 getCookiePath(), 0, isHttps);\n         if (authenticationEx \u003d\u003d null) {\n           httpResponse.sendError(errCode, \"Authentication required\");\n         } else {\n           httpResponse.sendError(errCode, authenticationEx.getMessage());\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    boolean unauthorizedResponse \u003d true;\n    int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n    AuthenticationException authenticationEx \u003d null;\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        // will be sent back in a 401 unless filter authenticates\n        authenticationEx \u003d ex;\n        token \u003d null;\n      }\n      if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n        if (token \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n          }\n          token \u003d authHandler.authenticate(httpRequest, httpResponse);\n          if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n              token !\u003d AuthenticationToken.ANONYMOUS) {\n            token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n          }\n          newToken \u003d true;\n        }\n        if (token !\u003d null) {\n          unauthorizedResponse \u003d false;\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n          }\n          final AuthenticationToken authToken \u003d token;\n          httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n            @Override\n            public String getAuthType() {\n              return authToken.getType();\n            }\n\n            @Override\n            public String getRemoteUser() {\n              return authToken.getUserName();\n            }\n\n            @Override\n            public Principal getUserPrincipal() {\n              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n            }\n          };\n          if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            String signedToken \u003d signer.sign(token.toString());\n            createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                    getCookiePath(), token.getExpires(), isHttps);\n          }\n          doFilter(filterChain, httpRequest, httpResponse);\n        }\n      } else {\n        unauthorizedResponse \u003d false;\n      }\n    } catch (AuthenticationException ex) {\n      // exception from the filter itself is fatal\n      errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n      authenticationEx \u003d ex;\n      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n    }\n    if (unauthorizedResponse) {\n      if (!httpResponse.isCommitted()) {\n        createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                getCookiePath(), 0, isHttps);\n        if (authenticationEx \u003d\u003d null) {\n          httpResponse.sendError(errCode, \"Authentication required\");\n        } else {\n          httpResponse.sendError(errCode, authenticationEx.getMessage());\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "3c4d44d4cef8f908b76ba9fff28666b9e8ee56b1": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10301. AuthenticationFilter should return Forbidden for failed authentication. Contributed by Daryn Sharp.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1582883 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "28/03/14 2:20 PM",
      "commitName": "3c4d44d4cef8f908b76ba9fff28666b9e8ee56b1",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "04/03/14 5:48 PM",
      "commitNameOld": "95ebf9ecc4809b8a977a0a847515649486a004c4",
      "commitAuthorOld": "Haohui Mai",
      "daysBetweenCommits": 23.81,
      "commitsBetweenForRepo": 205,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,75 +1,83 @@\n   public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n       throws IOException, ServletException {\n     boolean unauthorizedResponse \u003d true;\n-    String unauthorizedMsg \u003d \"\";\n+    int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n+    AuthenticationException authenticationEx \u003d null;\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n     boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n     try {\n       boolean newToken \u003d false;\n       AuthenticationToken token;\n       try {\n         token \u003d getToken(httpRequest);\n       }\n       catch (AuthenticationException ex) {\n         LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n+        // will be sent back in a 401 unless filter authenticates\n+        authenticationEx \u003d ex;\n         token \u003d null;\n       }\n       if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n         if (token \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n           }\n           token \u003d authHandler.authenticate(httpRequest, httpResponse);\n           if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n               token !\u003d AuthenticationToken.ANONYMOUS) {\n             token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n           }\n           newToken \u003d true;\n         }\n         if (token !\u003d null) {\n           unauthorizedResponse \u003d false;\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n           }\n           final AuthenticationToken authToken \u003d token;\n           httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n \n             @Override\n             public String getAuthType() {\n               return authToken.getType();\n             }\n \n             @Override\n             public String getRemoteUser() {\n               return authToken.getUserName();\n             }\n \n             @Override\n             public Principal getUserPrincipal() {\n               return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n             }\n           };\n           if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n             String signedToken \u003d signer.sign(token.toString());\n             createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                     getCookiePath(), token.getExpires(), isHttps);\n           }\n           filterChain.doFilter(httpRequest, httpResponse);\n         }\n       } else {\n         unauthorizedResponse \u003d false;\n       }\n     } catch (AuthenticationException ex) {\n-      unauthorizedMsg \u003d ex.toString();\n+      // exception from the filter itself is fatal\n+      errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n+      authenticationEx \u003d ex;\n       LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n     }\n     if (unauthorizedResponse) {\n       if (!httpResponse.isCommitted()) {\n         createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                 getCookiePath(), 0, isHttps);\n-        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n-                unauthorizedMsg);\n+        if (authenticationEx \u003d\u003d null) {\n+          httpResponse.sendError(errCode, \"Authentication required\");\n+        } else {\n+          httpResponse.sendError(errCode, authenticationEx.getMessage());\n+        }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    boolean unauthorizedResponse \u003d true;\n    int errCode \u003d HttpServletResponse.SC_UNAUTHORIZED;\n    AuthenticationException authenticationEx \u003d null;\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        // will be sent back in a 401 unless filter authenticates\n        authenticationEx \u003d ex;\n        token \u003d null;\n      }\n      if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n        if (token \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n          }\n          token \u003d authHandler.authenticate(httpRequest, httpResponse);\n          if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n              token !\u003d AuthenticationToken.ANONYMOUS) {\n            token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n          }\n          newToken \u003d true;\n        }\n        if (token !\u003d null) {\n          unauthorizedResponse \u003d false;\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n          }\n          final AuthenticationToken authToken \u003d token;\n          httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n            @Override\n            public String getAuthType() {\n              return authToken.getType();\n            }\n\n            @Override\n            public String getRemoteUser() {\n              return authToken.getUserName();\n            }\n\n            @Override\n            public Principal getUserPrincipal() {\n              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n            }\n          };\n          if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            String signedToken \u003d signer.sign(token.toString());\n            createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                    getCookiePath(), token.getExpires(), isHttps);\n          }\n          filterChain.doFilter(httpRequest, httpResponse);\n        }\n      } else {\n        unauthorizedResponse \u003d false;\n      }\n    } catch (AuthenticationException ex) {\n      // exception from the filter itself is fatal\n      errCode \u003d HttpServletResponse.SC_FORBIDDEN;\n      authenticationEx \u003d ex;\n      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n    }\n    if (unauthorizedResponse) {\n      if (!httpResponse.isCommitted()) {\n        createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                getCookiePath(), 0, isHttps);\n        if (authenticationEx \u003d\u003d null) {\n          httpResponse.sendError(errCode, \"Authentication required\");\n        } else {\n          httpResponse.sendError(errCode, authenticationEx.getMessage());\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "95ebf9ecc4809b8a977a0a847515649486a004c4": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10379. Protect authentication cookies with the HttpOnly and Secure flags. Contributed by Haohui Mai.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1574283 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/03/14 5:48 PM",
      "commitName": "95ebf9ecc4809b8a977a0a847515649486a004c4",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "12/06/12 7:22 PM",
      "commitNameOld": "5a2e0ee4d293ed4e5da32edc7331ae350432def6",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 629.98,
      "commitsBetweenForRepo": 3840,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,74 +1,75 @@\n   public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n       throws IOException, ServletException {\n     boolean unauthorizedResponse \u003d true;\n     String unauthorizedMsg \u003d \"\";\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n+    boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n     try {\n       boolean newToken \u003d false;\n       AuthenticationToken token;\n       try {\n         token \u003d getToken(httpRequest);\n       }\n       catch (AuthenticationException ex) {\n         LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n         token \u003d null;\n       }\n       if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n         if (token \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n           }\n           token \u003d authHandler.authenticate(httpRequest, httpResponse);\n           if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n               token !\u003d AuthenticationToken.ANONYMOUS) {\n             token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n           }\n           newToken \u003d true;\n         }\n         if (token !\u003d null) {\n           unauthorizedResponse \u003d false;\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n           }\n           final AuthenticationToken authToken \u003d token;\n           httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n \n             @Override\n             public String getAuthType() {\n               return authToken.getType();\n             }\n \n             @Override\n             public String getRemoteUser() {\n               return authToken.getUserName();\n             }\n \n             @Override\n             public Principal getUserPrincipal() {\n               return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n             }\n           };\n           if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n             String signedToken \u003d signer.sign(token.toString());\n-            Cookie cookie \u003d createCookie(signedToken);\n-            httpResponse.addCookie(cookie);\n+            createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n+                    getCookiePath(), token.getExpires(), isHttps);\n           }\n           filterChain.doFilter(httpRequest, httpResponse);\n         }\n       } else {\n         unauthorizedResponse \u003d false;\n       }\n     } catch (AuthenticationException ex) {\n       unauthorizedMsg \u003d ex.toString();\n       LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n     }\n     if (unauthorizedResponse) {\n       if (!httpResponse.isCommitted()) {\n-        Cookie cookie \u003d createCookie(\"\");\n-        cookie.setMaxAge(0);\n-        httpResponse.addCookie(cookie);\n-        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, unauthorizedMsg);\n+        createAuthCookie(httpResponse, \"\", getCookieDomain(),\n+                getCookiePath(), 0, isHttps);\n+        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n+                unauthorizedMsg);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    boolean unauthorizedResponse \u003d true;\n    String unauthorizedMsg \u003d \"\";\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    boolean isHttps \u003d \"https\".equals(httpRequest.getScheme());\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        token \u003d null;\n      }\n      if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n        if (token \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n          }\n          token \u003d authHandler.authenticate(httpRequest, httpResponse);\n          if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n              token !\u003d AuthenticationToken.ANONYMOUS) {\n            token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n          }\n          newToken \u003d true;\n        }\n        if (token !\u003d null) {\n          unauthorizedResponse \u003d false;\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n          }\n          final AuthenticationToken authToken \u003d token;\n          httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n            @Override\n            public String getAuthType() {\n              return authToken.getType();\n            }\n\n            @Override\n            public String getRemoteUser() {\n              return authToken.getUserName();\n            }\n\n            @Override\n            public Principal getUserPrincipal() {\n              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n            }\n          };\n          if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            String signedToken \u003d signer.sign(token.toString());\n            createAuthCookie(httpResponse, signedToken, getCookieDomain(),\n                    getCookiePath(), token.getExpires(), isHttps);\n          }\n          filterChain.doFilter(httpRequest, httpResponse);\n        }\n      } else {\n        unauthorizedResponse \u003d false;\n      }\n    } catch (AuthenticationException ex) {\n      unauthorizedMsg \u003d ex.toString();\n      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n    }\n    if (unauthorizedResponse) {\n      if (!httpResponse.isCommitted()) {\n        createAuthCookie(httpResponse, \"\", getCookieDomain(),\n                getCookiePath(), 0, isHttps);\n        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED,\n                unauthorizedMsg);\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "5a2e0ee4d293ed4e5da32edc7331ae350432def6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8465. hadoop-auth should support ephemeral authentication (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1349613 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/12 7:22 PM",
      "commitName": "5a2e0ee4d293ed4e5da32edc7331ae350432def6",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "12/06/12 1:45 PM",
      "commitNameOld": "22c65886237ed7c4e8cfa0aff95d751b6d70f7cc",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 0.23,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,74 @@\n   public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n       throws IOException, ServletException {\n     boolean unauthorizedResponse \u003d true;\n     String unauthorizedMsg \u003d \"\";\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n     try {\n       boolean newToken \u003d false;\n       AuthenticationToken token;\n       try {\n         token \u003d getToken(httpRequest);\n       }\n       catch (AuthenticationException ex) {\n         LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n         token \u003d null;\n       }\n       if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n         if (token \u003d\u003d null) {\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n           }\n           token \u003d authHandler.authenticate(httpRequest, httpResponse);\n-          if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n+          if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n+              token !\u003d AuthenticationToken.ANONYMOUS) {\n             token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n           }\n           newToken \u003d true;\n         }\n         if (token !\u003d null) {\n           unauthorizedResponse \u003d false;\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n           }\n           final AuthenticationToken authToken \u003d token;\n           httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n \n             @Override\n             public String getAuthType() {\n               return authToken.getType();\n             }\n \n             @Override\n             public String getRemoteUser() {\n               return authToken.getUserName();\n             }\n \n             @Override\n             public Principal getUserPrincipal() {\n               return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n             }\n           };\n-          if (newToken \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n+          if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n             String signedToken \u003d signer.sign(token.toString());\n             Cookie cookie \u003d createCookie(signedToken);\n             httpResponse.addCookie(cookie);\n           }\n           filterChain.doFilter(httpRequest, httpResponse);\n         }\n       } else {\n         unauthorizedResponse \u003d false;\n       }\n     } catch (AuthenticationException ex) {\n       unauthorizedMsg \u003d ex.toString();\n       LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n     }\n     if (unauthorizedResponse) {\n       if (!httpResponse.isCommitted()) {\n         Cookie cookie \u003d createCookie(\"\");\n         cookie.setMaxAge(0);\n         httpResponse.addCookie(cookie);\n         httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, unauthorizedMsg);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    boolean unauthorizedResponse \u003d true;\n    String unauthorizedMsg \u003d \"\";\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        token \u003d null;\n      }\n      if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n        if (token \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n          }\n          token \u003d authHandler.authenticate(httpRequest, httpResponse);\n          if (token !\u003d null \u0026\u0026 token.getExpires() !\u003d 0 \u0026\u0026\n              token !\u003d AuthenticationToken.ANONYMOUS) {\n            token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n          }\n          newToken \u003d true;\n        }\n        if (token !\u003d null) {\n          unauthorizedResponse \u003d false;\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n          }\n          final AuthenticationToken authToken \u003d token;\n          httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n            @Override\n            public String getAuthType() {\n              return authToken.getType();\n            }\n\n            @Override\n            public String getRemoteUser() {\n              return authToken.getUserName();\n            }\n\n            @Override\n            public Principal getUserPrincipal() {\n              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n            }\n          };\n          if (newToken \u0026\u0026 !token.isExpired() \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            String signedToken \u003d signer.sign(token.toString());\n            Cookie cookie \u003d createCookie(signedToken);\n            httpResponse.addCookie(cookie);\n          }\n          filterChain.doFilter(httpRequest, httpResponse);\n        }\n      } else {\n        unauthorizedResponse \u003d false;\n      }\n    } catch (AuthenticationException ex) {\n      unauthorizedMsg \u003d ex.toString();\n      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n    }\n    if (unauthorizedResponse) {\n      if (!httpResponse.isCommitted()) {\n        Cookie cookie \u003d createCookie(\"\");\n        cookie.setMaxAge(0);\n        httpResponse.addCookie(cookie);\n        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, unauthorizedMsg);\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "22c65886237ed7c4e8cfa0aff95d751b6d70f7cc": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8458. Add management hook to AuthenticationHandler to enable delegation token operations support (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1349514 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/12 1:45 PM",
      "commitName": "22c65886237ed7c4e8cfa0aff95d751b6d70f7cc",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "03/05/12 8:13 PM",
      "commitNameOld": "a7993ef5e8d34c16b1dbaaa562048456770dbf4b",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 39.73,
      "commitsBetweenForRepo": 207,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,73 @@\n   public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n       throws IOException, ServletException {\n     boolean unauthorizedResponse \u003d true;\n     String unauthorizedMsg \u003d \"\";\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n     try {\n       boolean newToken \u003d false;\n       AuthenticationToken token;\n       try {\n         token \u003d getToken(httpRequest);\n       }\n       catch (AuthenticationException ex) {\n         LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n         token \u003d null;\n       }\n-      if (token \u003d\u003d null) {\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n+      if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n+        if (token \u003d\u003d null) {\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n+          }\n+          token \u003d authHandler.authenticate(httpRequest, httpResponse);\n+          if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n+            token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n+          }\n+          newToken \u003d true;\n         }\n-        token \u003d authHandler.authenticate(httpRequest, httpResponse);\n-        if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n-          token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n+        if (token !\u003d null) {\n+          unauthorizedResponse \u003d false;\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n+          }\n+          final AuthenticationToken authToken \u003d token;\n+          httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n+\n+            @Override\n+            public String getAuthType() {\n+              return authToken.getType();\n+            }\n+\n+            @Override\n+            public String getRemoteUser() {\n+              return authToken.getUserName();\n+            }\n+\n+            @Override\n+            public Principal getUserPrincipal() {\n+              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n+            }\n+          };\n+          if (newToken \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n+            String signedToken \u003d signer.sign(token.toString());\n+            Cookie cookie \u003d createCookie(signedToken);\n+            httpResponse.addCookie(cookie);\n+          }\n+          filterChain.doFilter(httpRequest, httpResponse);\n         }\n-        newToken \u003d true;\n-      }\n-      if (token !\u003d null) {\n+      } else {\n         unauthorizedResponse \u003d false;\n-        if (LOG.isDebugEnabled()) {\n-          LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n-        }\n-        final AuthenticationToken authToken \u003d token;\n-        httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n-\n-          @Override\n-          public String getAuthType() {\n-            return authToken.getType();\n-          }\n-\n-          @Override\n-          public String getRemoteUser() {\n-            return authToken.getUserName();\n-          }\n-\n-          @Override\n-          public Principal getUserPrincipal() {\n-            return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n-          }\n-        };\n-        if (newToken \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n-          String signedToken \u003d signer.sign(token.toString());\n-          Cookie cookie \u003d createCookie(signedToken);\n-          httpResponse.addCookie(cookie);\n-        }\n-        filterChain.doFilter(httpRequest, httpResponse);\n       }\n     } catch (AuthenticationException ex) {\n       unauthorizedMsg \u003d ex.toString();\n       LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n     }\n     if (unauthorizedResponse) {\n       if (!httpResponse.isCommitted()) {\n         Cookie cookie \u003d createCookie(\"\");\n         cookie.setMaxAge(0);\n         httpResponse.addCookie(cookie);\n         httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, unauthorizedMsg);\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    boolean unauthorizedResponse \u003d true;\n    String unauthorizedMsg \u003d \"\";\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        token \u003d null;\n      }\n      if (authHandler.managementOperation(token, httpRequest, httpResponse)) {\n        if (token \u003d\u003d null) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n          }\n          token \u003d authHandler.authenticate(httpRequest, httpResponse);\n          if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n          }\n          newToken \u003d true;\n        }\n        if (token !\u003d null) {\n          unauthorizedResponse \u003d false;\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n          }\n          final AuthenticationToken authToken \u003d token;\n          httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n            @Override\n            public String getAuthType() {\n              return authToken.getType();\n            }\n\n            @Override\n            public String getRemoteUser() {\n              return authToken.getUserName();\n            }\n\n            @Override\n            public Principal getUserPrincipal() {\n              return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n            }\n          };\n          if (newToken \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n            String signedToken \u003d signer.sign(token.toString());\n            Cookie cookie \u003d createCookie(signedToken);\n            httpResponse.addCookie(cookie);\n          }\n          filterChain.doFilter(httpRequest, httpResponse);\n        }\n      } else {\n        unauthorizedResponse \u003d false;\n      }\n    } catch (AuthenticationException ex) {\n      unauthorizedMsg \u003d ex.toString();\n      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n    }\n    if (unauthorizedResponse) {\n      if (!httpResponse.isCommitted()) {\n        Cookie cookie \u003d createCookie(\"\");\n        cookie.setMaxAge(0);\n        httpResponse.addCookie(cookie);\n        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, unauthorizedMsg);\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "a7993ef5e8d34c16b1dbaaa562048456770dbf4b": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8355. SPNEGO filter throws/logs exception when authentication fails (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1333746 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/05/12 8:13 PM",
      "commitName": "a7993ef5e8d34c16b1dbaaa562048456770dbf4b",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "06/04/12 1:45 AM",
      "commitNameOld": "90d9cab02e8652c119565230ec6f1bc1cde08195",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 27.77,
      "commitsBetweenForRepo": 197,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,69 @@\n   public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n       throws IOException, ServletException {\n+    boolean unauthorizedResponse \u003d true;\n+    String unauthorizedMsg \u003d \"\";\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n     try {\n       boolean newToken \u003d false;\n       AuthenticationToken token;\n       try {\n         token \u003d getToken(httpRequest);\n       }\n       catch (AuthenticationException ex) {\n         LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n         token \u003d null;\n       }\n       if (token \u003d\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n         }\n         token \u003d authHandler.authenticate(httpRequest, httpResponse);\n         if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n           token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n         }\n         newToken \u003d true;\n       }\n       if (token !\u003d null) {\n+        unauthorizedResponse \u003d false;\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n         }\n         final AuthenticationToken authToken \u003d token;\n         httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n \n           @Override\n           public String getAuthType() {\n             return authToken.getType();\n           }\n \n           @Override\n           public String getRemoteUser() {\n             return authToken.getUserName();\n           }\n \n           @Override\n           public Principal getUserPrincipal() {\n             return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n           }\n         };\n         if (newToken \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n           String signedToken \u003d signer.sign(token.toString());\n           Cookie cookie \u003d createCookie(signedToken);\n           httpResponse.addCookie(cookie);\n         }\n         filterChain.doFilter(httpRequest, httpResponse);\n       }\n-      else {\n-        throw new AuthenticationException(\"Missing AuthenticationToken\");\n-      }\n     } catch (AuthenticationException ex) {\n+      unauthorizedMsg \u003d ex.toString();\n+      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n+    }\n+    if (unauthorizedResponse) {\n       if (!httpResponse.isCommitted()) {\n         Cookie cookie \u003d createCookie(\"\");\n         cookie.setMaxAge(0);\n         httpResponse.addCookie(cookie);\n-        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, ex.getMessage());\n+        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, unauthorizedMsg);\n       }\n-      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    boolean unauthorizedResponse \u003d true;\n    String unauthorizedMsg \u003d \"\";\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        token \u003d null;\n      }\n      if (token \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n        }\n        token \u003d authHandler.authenticate(httpRequest, httpResponse);\n        if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n          token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n        }\n        newToken \u003d true;\n      }\n      if (token !\u003d null) {\n        unauthorizedResponse \u003d false;\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n        }\n        final AuthenticationToken authToken \u003d token;\n        httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n          @Override\n          public String getAuthType() {\n            return authToken.getType();\n          }\n\n          @Override\n          public String getRemoteUser() {\n            return authToken.getUserName();\n          }\n\n          @Override\n          public Principal getUserPrincipal() {\n            return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n          }\n        };\n        if (newToken \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n          String signedToken \u003d signer.sign(token.toString());\n          Cookie cookie \u003d createCookie(signedToken);\n          httpResponse.addCookie(cookie);\n        }\n        filterChain.doFilter(httpRequest, httpResponse);\n      }\n    } catch (AuthenticationException ex) {\n      unauthorizedMsg \u003d ex.toString();\n      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n    }\n    if (unauthorizedResponse) {\n      if (!httpResponse.isCommitted()) {\n        Cookie cookie \u003d createCookie(\"\");\n        cookie.setMaxAge(0);\n        httpResponse.addCookie(cookie);\n        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, unauthorizedMsg);\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "90d9cab02e8652c119565230ec6f1bc1cde08195": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8249. invalid hadoop-auth cookies should trigger authentication if info is avail before returning HTTP 401 (tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1310235 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/04/12 1:45 AM",
      "commitName": "90d9cab02e8652c119565230ec6f1bc1cde08195",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "31/08/11 3:40 PM",
      "commitNameOld": "2b016dac8232e0f5c43293adcbdf7164f5fca74c",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 218.42,
      "commitsBetweenForRepo": 1578,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,56 +1,66 @@\n   public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n       throws IOException, ServletException {\n     HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n     HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n     try {\n       boolean newToken \u003d false;\n-      AuthenticationToken token \u003d getToken(httpRequest);\n+      AuthenticationToken token;\n+      try {\n+        token \u003d getToken(httpRequest);\n+      }\n+      catch (AuthenticationException ex) {\n+        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n+        token \u003d null;\n+      }\n       if (token \u003d\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n         }\n         token \u003d authHandler.authenticate(httpRequest, httpResponse);\n         if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n           token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n         }\n         newToken \u003d true;\n       }\n       if (token !\u003d null) {\n         if (LOG.isDebugEnabled()) {\n           LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n         }\n         final AuthenticationToken authToken \u003d token;\n         httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n \n           @Override\n           public String getAuthType() {\n             return authToken.getType();\n           }\n \n           @Override\n           public String getRemoteUser() {\n             return authToken.getUserName();\n           }\n \n           @Override\n           public Principal getUserPrincipal() {\n             return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n           }\n         };\n         if (newToken \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n           String signedToken \u003d signer.sign(token.toString());\n           Cookie cookie \u003d createCookie(signedToken);\n           httpResponse.addCookie(cookie);\n         }\n         filterChain.doFilter(httpRequest, httpResponse);\n       }\n+      else {\n+        throw new AuthenticationException(\"Missing AuthenticationToken\");\n+      }\n     } catch (AuthenticationException ex) {\n       if (!httpResponse.isCommitted()) {\n         Cookie cookie \u003d createCookie(\"\");\n         cookie.setMaxAge(0);\n         httpResponse.addCookie(cookie);\n         httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, ex.getMessage());\n       }\n       LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token;\n      try {\n        token \u003d getToken(httpRequest);\n      }\n      catch (AuthenticationException ex) {\n        LOG.warn(\"AuthenticationToken ignored: \" + ex.getMessage());\n        token \u003d null;\n      }\n      if (token \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n        }\n        token \u003d authHandler.authenticate(httpRequest, httpResponse);\n        if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n          token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n        }\n        newToken \u003d true;\n      }\n      if (token !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n        }\n        final AuthenticationToken authToken \u003d token;\n        httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n          @Override\n          public String getAuthType() {\n            return authToken.getType();\n          }\n\n          @Override\n          public String getRemoteUser() {\n            return authToken.getUserName();\n          }\n\n          @Override\n          public Principal getUserPrincipal() {\n            return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n          }\n        };\n        if (newToken \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n          String signedToken \u003d signer.sign(token.toString());\n          Cookie cookie \u003d createCookie(signedToken);\n          httpResponse.addCookie(cookie);\n        }\n        filterChain.doFilter(httpRequest, httpResponse);\n      }\n      else {\n        throw new AuthenticationException(\"Missing AuthenticationToken\");\n      }\n    } catch (AuthenticationException ex) {\n      if (!httpResponse.isCommitted()) {\n        Cookie cookie \u003d createCookie(\"\");\n        cookie.setMaxAge(0);\n        httpResponse.addCookie(cookie);\n        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, ex.getMessage());\n      }\n      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {}
    },
    "2b016dac8232e0f5c43293adcbdf7164f5fca74c": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7579. Rename package names from alfredo to auth.  Contributed by Alejandro Abdelnur\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1163852 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/08/11 3:40 PM",
      "commitName": "2b016dac8232e0f5c43293adcbdf7164f5fca74c",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "31/08/11 2:18 PM",
      "commitNameOld": "4f1a0e36fab1f18e6e2c5fcc72cd9a7634967fcd",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token \u003d getToken(httpRequest);\n      if (token \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n        }\n        token \u003d authHandler.authenticate(httpRequest, httpResponse);\n        if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n          token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n        }\n        newToken \u003d true;\n      }\n      if (token !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n        }\n        final AuthenticationToken authToken \u003d token;\n        httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n          @Override\n          public String getAuthType() {\n            return authToken.getType();\n          }\n\n          @Override\n          public String getRemoteUser() {\n            return authToken.getUserName();\n          }\n\n          @Override\n          public Principal getUserPrincipal() {\n            return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n          }\n        };\n        if (newToken \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n          String signedToken \u003d signer.sign(token.toString());\n          Cookie cookie \u003d createCookie(signedToken);\n          httpResponse.addCookie(cookie);\n        }\n        filterChain.doFilter(httpRequest, httpResponse);\n      }\n    } catch (AuthenticationException ex) {\n      if (!httpResponse.isCommitted()) {\n        Cookie cookie \u003d createCookie(\"\");\n        cookie.setMaxAge(0);\n        httpResponse.addCookie(cookie);\n        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, ex.getMessage());\n      }\n      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java",
      "extendedDetails": {
        "oldPath": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/alfredo/server/AuthenticationFilter.java",
        "newPath": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/server/AuthenticationFilter.java"
      }
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token \u003d getToken(httpRequest);\n      if (token \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n        }\n        token \u003d authHandler.authenticate(httpRequest, httpResponse);\n        if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n          token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n        }\n        newToken \u003d true;\n      }\n      if (token !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n        }\n        final AuthenticationToken authToken \u003d token;\n        httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n          @Override\n          public String getAuthType() {\n            return authToken.getType();\n          }\n\n          @Override\n          public String getRemoteUser() {\n            return authToken.getUserName();\n          }\n\n          @Override\n          public Principal getUserPrincipal() {\n            return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n          }\n        };\n        if (newToken \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n          String signedToken \u003d signer.sign(token.toString());\n          Cookie cookie \u003d createCookie(signedToken);\n          httpResponse.addCookie(cookie);\n        }\n        filterChain.doFilter(httpRequest, httpResponse);\n      }\n    } catch (AuthenticationException ex) {\n      if (!httpResponse.isCommitted()) {\n        Cookie cookie \u003d createCookie(\"\");\n        cookie.setMaxAge(0);\n        httpResponse.addCookie(cookie);\n        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, ex.getMessage());\n      }\n      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/alfredo/server/AuthenticationFilter.java",
      "extendedDetails": {
        "oldPath": "hadoop-alfredo/src/main/java/org/apache/hadoop/alfredo/server/AuthenticationFilter.java",
        "newPath": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/alfredo/server/AuthenticationFilter.java"
      }
    },
    "a0f120ce68dddb0cb31b64c89f3224313f3cb5af": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7119. add Kerberos HTTP SPNEGO authentication support to Hadoop JT/NN/DN/TT web-consoles. (Alejandro Abdelnur via atm)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159804 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 3:31 PM",
      "commitName": "a0f120ce68dddb0cb31b64c89f3224313f3cb5af",
      "commitAuthor": "Aaron Myers",
      "diff": "@@ -0,0 +1,56 @@\n+  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n+      throws IOException, ServletException {\n+    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n+    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n+    try {\n+      boolean newToken \u003d false;\n+      AuthenticationToken token \u003d getToken(httpRequest);\n+      if (token \u003d\u003d null) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n+        }\n+        token \u003d authHandler.authenticate(httpRequest, httpResponse);\n+        if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n+          token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n+        }\n+        newToken \u003d true;\n+      }\n+      if (token !\u003d null) {\n+        if (LOG.isDebugEnabled()) {\n+          LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n+        }\n+        final AuthenticationToken authToken \u003d token;\n+        httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n+\n+          @Override\n+          public String getAuthType() {\n+            return authToken.getType();\n+          }\n+\n+          @Override\n+          public String getRemoteUser() {\n+            return authToken.getUserName();\n+          }\n+\n+          @Override\n+          public Principal getUserPrincipal() {\n+            return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n+          }\n+        };\n+        if (newToken \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n+          String signedToken \u003d signer.sign(token.toString());\n+          Cookie cookie \u003d createCookie(signedToken);\n+          httpResponse.addCookie(cookie);\n+        }\n+        filterChain.doFilter(httpRequest, httpResponse);\n+      }\n+    } catch (AuthenticationException ex) {\n+      if (!httpResponse.isCommitted()) {\n+        Cookie cookie \u003d createCookie(\"\");\n+        cookie.setMaxAge(0);\n+        httpResponse.addCookie(cookie);\n+        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, ex.getMessage());\n+      }\n+      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)\n      throws IOException, ServletException {\n    HttpServletRequest httpRequest \u003d (HttpServletRequest) request;\n    HttpServletResponse httpResponse \u003d (HttpServletResponse) response;\n    try {\n      boolean newToken \u003d false;\n      AuthenticationToken token \u003d getToken(httpRequest);\n      if (token \u003d\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Request [{}] triggering authentication\", getRequestURL(httpRequest));\n        }\n        token \u003d authHandler.authenticate(httpRequest, httpResponse);\n        if (token !\u003d null \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n          token.setExpires(System.currentTimeMillis() + getValidity() * 1000);\n        }\n        newToken \u003d true;\n      }\n      if (token !\u003d null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Request [{}] user [{}] authenticated\", getRequestURL(httpRequest), token.getUserName());\n        }\n        final AuthenticationToken authToken \u003d token;\n        httpRequest \u003d new HttpServletRequestWrapper(httpRequest) {\n\n          @Override\n          public String getAuthType() {\n            return authToken.getType();\n          }\n\n          @Override\n          public String getRemoteUser() {\n            return authToken.getUserName();\n          }\n\n          @Override\n          public Principal getUserPrincipal() {\n            return (authToken !\u003d AuthenticationToken.ANONYMOUS) ? authToken : null;\n          }\n        };\n        if (newToken \u0026\u0026 token !\u003d AuthenticationToken.ANONYMOUS) {\n          String signedToken \u003d signer.sign(token.toString());\n          Cookie cookie \u003d createCookie(signedToken);\n          httpResponse.addCookie(cookie);\n        }\n        filterChain.doFilter(httpRequest, httpResponse);\n      }\n    } catch (AuthenticationException ex) {\n      if (!httpResponse.isCommitted()) {\n        Cookie cookie \u003d createCookie(\"\");\n        cookie.setMaxAge(0);\n        httpResponse.addCookie(cookie);\n        httpResponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, ex.getMessage());\n      }\n      LOG.warn(\"Authentication exception: \" + ex.getMessage(), ex);\n    }\n  }",
      "path": "hadoop-alfredo/src/main/java/org/apache/hadoop/alfredo/server/AuthenticationFilter.java"
    }
  }
}