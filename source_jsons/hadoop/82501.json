{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "SysInfoWindows.java",
  "functionName": "refreshIfNeeded",
  "functionId": "refreshIfNeeded",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/SysInfoWindows.java",
  "functionStartLine": 94,
  "functionEndLine": 141,
  "numCommitsSeen": 16,
  "timeTaken": 3475,
  "changeHistory": [
    "689fb2fc661f233367ecbfa26795ff4c01408f3e",
    "1518cb9532cbedeada1b3d880f4ef1059301e828",
    "b2951f9fbccee8aeab04c1f5ee3fc6db1ef6b2da",
    "89d1fd5dac4bccf42d82686e146b02eb60d14736",
    "ac6048372a58b3a3b57cd5f2702b44a3d4667f3d",
    "638801cce16fc1dc3259c541dc30a599faaddda1"
  ],
  "changeHistoryShort": {
    "689fb2fc661f233367ecbfa26795ff4c01408f3e": "Ymodifierchange",
    "1518cb9532cbedeada1b3d880f4ef1059301e828": "Ybodychange",
    "b2951f9fbccee8aeab04c1f5ee3fc6db1ef6b2da": "Ybodychange",
    "89d1fd5dac4bccf42d82686e146b02eb60d14736": "Ybodychange",
    "ac6048372a58b3a3b57cd5f2702b44a3d4667f3d": "Ymultichange(Ymovefromfile,Ybodychange)",
    "638801cce16fc1dc3259c541dc30a599faaddda1": "Yintroduced"
  },
  "changeHistoryDetails": {
    "689fb2fc661f233367ecbfa26795ff4c01408f3e": {
      "type": "Ymodifierchange",
      "commitMessage": "HADOOP-14354. SysInfoWindows is not thread safe. Contributed by Inigo Goiri\n",
      "commitDate": "27/04/17 4:26 PM",
      "commitName": "689fb2fc661f233367ecbfa26795ff4c01408f3e",
      "commitAuthor": "Chris Douglas",
      "commitDateOld": "29/09/16 3:35 AM",
      "commitNameOld": "1518cb9532cbedeada1b3d880f4ef1059301e828",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 210.54,
      "commitsBetweenForRepo": 1298,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n-  void refreshIfNeeded() {\n+  synchronized void refreshIfNeeded() {\n     long now \u003d now();\n     if (now - lastRefreshTime \u003e REFRESH_INTERVAL_MS) {\n       long refreshInterval \u003d now - lastRefreshTime;\n       lastRefreshTime \u003d now;\n       long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n       reset();\n       String sysInfoStr \u003d getSystemInfoInfoFromShell();\n       if (sysInfoStr !\u003d null) {\n         final int sysInfoSplitCount \u003d 11;\n         int index \u003d sysInfoStr.indexOf(\"\\r\\n\");\n         if (index \u003e\u003d 0) {\n           String[] sysInfo \u003d sysInfoStr.substring(0, index).split(\",\");\n           if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n             try {\n               vmemSize \u003d Long.parseLong(sysInfo[0]);\n               memSize \u003d Long.parseLong(sysInfo[1]);\n               vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n               memAvailable \u003d Long.parseLong(sysInfo[3]);\n               numProcessors \u003d Integer.parseInt(sysInfo[4]);\n               cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n               cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n               storageBytesRead \u003d Long.parseLong(sysInfo[7]);\n               storageBytesWritten \u003d Long.parseLong(sysInfo[8]);\n               netBytesRead \u003d Long.parseLong(sysInfo[9]);\n               netBytesWritten \u003d Long.parseLong(sysInfo[10]);\n               if (lastCumCpuTimeMs !\u003d -1) {\n                 /**\n                  * This number will be the aggregated usage across all cores in\n                  * [0.0, 100.0]. For example, it will be 400.0 if there are 8\n                  * cores and each of them is running at 50% utilization.\n                  */\n                 cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n                     * 100F / refreshInterval;\n               }\n             } catch (NumberFormatException nfe) {\n               LOG.warn(\"Error parsing sysInfo\", nfe);\n             }\n           } else {\n             LOG.warn(\"Expected split length of sysInfo to be \"\n                 + sysInfoSplitCount + \". Got \" + sysInfo.length);\n           }\n         } else {\n           LOG.warn(\"Wrong output from sysInfo: \" + sysInfoStr);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  synchronized void refreshIfNeeded() {\n    long now \u003d now();\n    if (now - lastRefreshTime \u003e REFRESH_INTERVAL_MS) {\n      long refreshInterval \u003d now - lastRefreshTime;\n      lastRefreshTime \u003d now;\n      long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n      reset();\n      String sysInfoStr \u003d getSystemInfoInfoFromShell();\n      if (sysInfoStr !\u003d null) {\n        final int sysInfoSplitCount \u003d 11;\n        int index \u003d sysInfoStr.indexOf(\"\\r\\n\");\n        if (index \u003e\u003d 0) {\n          String[] sysInfo \u003d sysInfoStr.substring(0, index).split(\",\");\n          if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n            try {\n              vmemSize \u003d Long.parseLong(sysInfo[0]);\n              memSize \u003d Long.parseLong(sysInfo[1]);\n              vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n              memAvailable \u003d Long.parseLong(sysInfo[3]);\n              numProcessors \u003d Integer.parseInt(sysInfo[4]);\n              cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n              cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n              storageBytesRead \u003d Long.parseLong(sysInfo[7]);\n              storageBytesWritten \u003d Long.parseLong(sysInfo[8]);\n              netBytesRead \u003d Long.parseLong(sysInfo[9]);\n              netBytesWritten \u003d Long.parseLong(sysInfo[10]);\n              if (lastCumCpuTimeMs !\u003d -1) {\n                /**\n                 * This number will be the aggregated usage across all cores in\n                 * [0.0, 100.0]. For example, it will be 400.0 if there are 8\n                 * cores and each of them is running at 50% utilization.\n                 */\n                cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n                    * 100F / refreshInterval;\n              }\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Error parsing sysInfo\", nfe);\n            }\n          } else {\n            LOG.warn(\"Expected split length of sysInfo to be \"\n                + sysInfoSplitCount + \". Got \" + sysInfo.length);\n          }\n        } else {\n          LOG.warn(\"Wrong output from sysInfo: \" + sysInfoStr);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/SysInfoWindows.java",
      "extendedDetails": {
        "oldValue": "[]",
        "newValue": "[synchronized]"
      }
    },
    "1518cb9532cbedeada1b3d880f4ef1059301e828": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13663 Index out of range in SysInfoWindows. Contributed by Inigo Goiri\n",
      "commitDate": "29/09/16 3:35 AM",
      "commitName": "1518cb9532cbedeada1b3d880f4ef1059301e828",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "02/05/16 10:36 PM",
      "commitNameOld": "c1cc6ac667e9e1b2ed58f16cb9fa1584ea54f0ac",
      "commitAuthorOld": "Chris Douglas",
      "daysBetweenCommits": 149.21,
      "commitsBetweenForRepo": 1102,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,48 @@\n   void refreshIfNeeded() {\n     long now \u003d now();\n     if (now - lastRefreshTime \u003e REFRESH_INTERVAL_MS) {\n       long refreshInterval \u003d now - lastRefreshTime;\n       lastRefreshTime \u003d now;\n       long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n       reset();\n       String sysInfoStr \u003d getSystemInfoInfoFromShell();\n       if (sysInfoStr !\u003d null) {\n         final int sysInfoSplitCount \u003d 11;\n-        String[] sysInfo \u003d sysInfoStr.substring(0, sysInfoStr.indexOf(\"\\r\\n\"))\n-            .split(\",\");\n-        if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n-          try {\n-            vmemSize \u003d Long.parseLong(sysInfo[0]);\n-            memSize \u003d Long.parseLong(sysInfo[1]);\n-            vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n-            memAvailable \u003d Long.parseLong(sysInfo[3]);\n-            numProcessors \u003d Integer.parseInt(sysInfo[4]);\n-            cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n-            cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n-            storageBytesRead \u003d Long.parseLong(sysInfo[7]);\n-            storageBytesWritten \u003d Long.parseLong(sysInfo[8]);\n-            netBytesRead \u003d Long.parseLong(sysInfo[9]);\n-            netBytesWritten \u003d Long.parseLong(sysInfo[10]);\n-            if (lastCumCpuTimeMs !\u003d -1) {\n-              /**\n-               * This number will be the aggregated usage across all cores in\n-               * [0.0, 100.0]. For example, it will be 400.0 if there are 8\n-               * cores and each of them is running at 50% utilization.\n-               */\n-              cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n-                  * 100F / refreshInterval;\n+        int index \u003d sysInfoStr.indexOf(\"\\r\\n\");\n+        if (index \u003e\u003d 0) {\n+          String[] sysInfo \u003d sysInfoStr.substring(0, index).split(\",\");\n+          if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n+            try {\n+              vmemSize \u003d Long.parseLong(sysInfo[0]);\n+              memSize \u003d Long.parseLong(sysInfo[1]);\n+              vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n+              memAvailable \u003d Long.parseLong(sysInfo[3]);\n+              numProcessors \u003d Integer.parseInt(sysInfo[4]);\n+              cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n+              cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n+              storageBytesRead \u003d Long.parseLong(sysInfo[7]);\n+              storageBytesWritten \u003d Long.parseLong(sysInfo[8]);\n+              netBytesRead \u003d Long.parseLong(sysInfo[9]);\n+              netBytesWritten \u003d Long.parseLong(sysInfo[10]);\n+              if (lastCumCpuTimeMs !\u003d -1) {\n+                /**\n+                 * This number will be the aggregated usage across all cores in\n+                 * [0.0, 100.0]. For example, it will be 400.0 if there are 8\n+                 * cores and each of them is running at 50% utilization.\n+                 */\n+                cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n+                    * 100F / refreshInterval;\n+              }\n+            } catch (NumberFormatException nfe) {\n+              LOG.warn(\"Error parsing sysInfo\", nfe);\n             }\n-          } catch (NumberFormatException nfe) {\n-            LOG.warn(\"Error parsing sysInfo\", nfe);\n+          } else {\n+            LOG.warn(\"Expected split length of sysInfo to be \"\n+                + sysInfoSplitCount + \". Got \" + sysInfo.length);\n           }\n         } else {\n-          LOG.warn(\"Expected split length of sysInfo to be \"\n-              + sysInfoSplitCount + \". Got \" + sysInfo.length);\n+          LOG.warn(\"Wrong output from sysInfo: \" + sysInfoStr);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void refreshIfNeeded() {\n    long now \u003d now();\n    if (now - lastRefreshTime \u003e REFRESH_INTERVAL_MS) {\n      long refreshInterval \u003d now - lastRefreshTime;\n      lastRefreshTime \u003d now;\n      long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n      reset();\n      String sysInfoStr \u003d getSystemInfoInfoFromShell();\n      if (sysInfoStr !\u003d null) {\n        final int sysInfoSplitCount \u003d 11;\n        int index \u003d sysInfoStr.indexOf(\"\\r\\n\");\n        if (index \u003e\u003d 0) {\n          String[] sysInfo \u003d sysInfoStr.substring(0, index).split(\",\");\n          if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n            try {\n              vmemSize \u003d Long.parseLong(sysInfo[0]);\n              memSize \u003d Long.parseLong(sysInfo[1]);\n              vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n              memAvailable \u003d Long.parseLong(sysInfo[3]);\n              numProcessors \u003d Integer.parseInt(sysInfo[4]);\n              cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n              cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n              storageBytesRead \u003d Long.parseLong(sysInfo[7]);\n              storageBytesWritten \u003d Long.parseLong(sysInfo[8]);\n              netBytesRead \u003d Long.parseLong(sysInfo[9]);\n              netBytesWritten \u003d Long.parseLong(sysInfo[10]);\n              if (lastCumCpuTimeMs !\u003d -1) {\n                /**\n                 * This number will be the aggregated usage across all cores in\n                 * [0.0, 100.0]. For example, it will be 400.0 if there are 8\n                 * cores and each of them is running at 50% utilization.\n                 */\n                cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n                    * 100F / refreshInterval;\n              }\n            } catch (NumberFormatException nfe) {\n              LOG.warn(\"Error parsing sysInfo\", nfe);\n            }\n          } else {\n            LOG.warn(\"Expected split length of sysInfo to be \"\n                + sysInfoSplitCount + \". Got \" + sysInfo.length);\n          }\n        } else {\n          LOG.warn(\"Wrong output from sysInfo: \" + sysInfoStr);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/SysInfoWindows.java",
      "extendedDetails": {}
    },
    "b2951f9fbccee8aeab04c1f5ee3fc6db1ef6b2da": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12824. Collect network and disk usage on the node running Windows. Contributed by Inigo Goiri.\n",
      "commitDate": "25/02/16 3:47 PM",
      "commitName": "b2951f9fbccee8aeab04c1f5ee3fc6db1ef6b2da",
      "commitAuthor": "Xiaoyu Yao",
      "commitDateOld": "19/01/16 5:27 AM",
      "commitNameOld": "89d1fd5dac4bccf42d82686e146b02eb60d14736",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 37.43,
      "commitsBetweenForRepo": 271,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,44 @@\n   void refreshIfNeeded() {\n     long now \u003d now();\n     if (now - lastRefreshTime \u003e REFRESH_INTERVAL_MS) {\n       long refreshInterval \u003d now - lastRefreshTime;\n       lastRefreshTime \u003d now;\n       long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n       reset();\n       String sysInfoStr \u003d getSystemInfoInfoFromShell();\n       if (sysInfoStr !\u003d null) {\n-        final int sysInfoSplitCount \u003d 7;\n+        final int sysInfoSplitCount \u003d 11;\n         String[] sysInfo \u003d sysInfoStr.substring(0, sysInfoStr.indexOf(\"\\r\\n\"))\n             .split(\",\");\n         if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n           try {\n             vmemSize \u003d Long.parseLong(sysInfo[0]);\n             memSize \u003d Long.parseLong(sysInfo[1]);\n             vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n             memAvailable \u003d Long.parseLong(sysInfo[3]);\n             numProcessors \u003d Integer.parseInt(sysInfo[4]);\n             cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n             cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n+            storageBytesRead \u003d Long.parseLong(sysInfo[7]);\n+            storageBytesWritten \u003d Long.parseLong(sysInfo[8]);\n+            netBytesRead \u003d Long.parseLong(sysInfo[9]);\n+            netBytesWritten \u003d Long.parseLong(sysInfo[10]);\n             if (lastCumCpuTimeMs !\u003d -1) {\n               /**\n                * This number will be the aggregated usage across all cores in\n                * [0.0, 100.0]. For example, it will be 400.0 if there are 8\n                * cores and each of them is running at 50% utilization.\n                */\n               cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n                   * 100F / refreshInterval;\n             }\n           } catch (NumberFormatException nfe) {\n             LOG.warn(\"Error parsing sysInfo\", nfe);\n           }\n         } else {\n           LOG.warn(\"Expected split length of sysInfo to be \"\n               + sysInfoSplitCount + \". Got \" + sysInfo.length);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void refreshIfNeeded() {\n    long now \u003d now();\n    if (now - lastRefreshTime \u003e REFRESH_INTERVAL_MS) {\n      long refreshInterval \u003d now - lastRefreshTime;\n      lastRefreshTime \u003d now;\n      long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n      reset();\n      String sysInfoStr \u003d getSystemInfoInfoFromShell();\n      if (sysInfoStr !\u003d null) {\n        final int sysInfoSplitCount \u003d 11;\n        String[] sysInfo \u003d sysInfoStr.substring(0, sysInfoStr.indexOf(\"\\r\\n\"))\n            .split(\",\");\n        if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n          try {\n            vmemSize \u003d Long.parseLong(sysInfo[0]);\n            memSize \u003d Long.parseLong(sysInfo[1]);\n            vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n            memAvailable \u003d Long.parseLong(sysInfo[3]);\n            numProcessors \u003d Integer.parseInt(sysInfo[4]);\n            cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n            cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n            storageBytesRead \u003d Long.parseLong(sysInfo[7]);\n            storageBytesWritten \u003d Long.parseLong(sysInfo[8]);\n            netBytesRead \u003d Long.parseLong(sysInfo[9]);\n            netBytesWritten \u003d Long.parseLong(sysInfo[10]);\n            if (lastCumCpuTimeMs !\u003d -1) {\n              /**\n               * This number will be the aggregated usage across all cores in\n               * [0.0, 100.0]. For example, it will be 400.0 if there are 8\n               * cores and each of them is running at 50% utilization.\n               */\n              cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n                  * 100F / refreshInterval;\n            }\n          } catch (NumberFormatException nfe) {\n            LOG.warn(\"Error parsing sysInfo\", nfe);\n          }\n        } else {\n          LOG.warn(\"Expected split length of sysInfo to be \"\n              + sysInfoSplitCount + \". Got \" + sysInfo.length);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/SysInfoWindows.java",
      "extendedDetails": {}
    },
    "89d1fd5dac4bccf42d82686e146b02eb60d14736": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12356. Fix computing CPU usage statistics on Windows. (Inigo Goiri via wangda)\n",
      "commitDate": "19/01/16 5:27 AM",
      "commitName": "89d1fd5dac4bccf42d82686e146b02eb60d14736",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "14/10/15 12:25 PM",
      "commitNameOld": "dfa78484633b3ce21471d527b9c24671e3ca5df9",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 96.75,
      "commitsBetweenForRepo": 646,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,40 @@\n   void refreshIfNeeded() {\n     long now \u003d now();\n     if (now - lastRefreshTime \u003e REFRESH_INTERVAL_MS) {\n       long refreshInterval \u003d now - lastRefreshTime;\n       lastRefreshTime \u003d now;\n       long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n       reset();\n       String sysInfoStr \u003d getSystemInfoInfoFromShell();\n       if (sysInfoStr !\u003d null) {\n         final int sysInfoSplitCount \u003d 7;\n         String[] sysInfo \u003d sysInfoStr.substring(0, sysInfoStr.indexOf(\"\\r\\n\"))\n             .split(\",\");\n         if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n           try {\n             vmemSize \u003d Long.parseLong(sysInfo[0]);\n             memSize \u003d Long.parseLong(sysInfo[1]);\n             vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n             memAvailable \u003d Long.parseLong(sysInfo[3]);\n             numProcessors \u003d Integer.parseInt(sysInfo[4]);\n             cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n             cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n             if (lastCumCpuTimeMs !\u003d -1) {\n+              /**\n+               * This number will be the aggregated usage across all cores in\n+               * [0.0, 100.0]. For example, it will be 400.0 if there are 8\n+               * cores and each of them is running at 50% utilization.\n+               */\n               cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n-                  / (refreshInterval * 1.0f);\n+                  * 100F / refreshInterval;\n             }\n           } catch (NumberFormatException nfe) {\n             LOG.warn(\"Error parsing sysInfo\", nfe);\n           }\n         } else {\n           LOG.warn(\"Expected split length of sysInfo to be \"\n               + sysInfoSplitCount + \". Got \" + sysInfo.length);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void refreshIfNeeded() {\n    long now \u003d now();\n    if (now - lastRefreshTime \u003e REFRESH_INTERVAL_MS) {\n      long refreshInterval \u003d now - lastRefreshTime;\n      lastRefreshTime \u003d now;\n      long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n      reset();\n      String sysInfoStr \u003d getSystemInfoInfoFromShell();\n      if (sysInfoStr !\u003d null) {\n        final int sysInfoSplitCount \u003d 7;\n        String[] sysInfo \u003d sysInfoStr.substring(0, sysInfoStr.indexOf(\"\\r\\n\"))\n            .split(\",\");\n        if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n          try {\n            vmemSize \u003d Long.parseLong(sysInfo[0]);\n            memSize \u003d Long.parseLong(sysInfo[1]);\n            vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n            memAvailable \u003d Long.parseLong(sysInfo[3]);\n            numProcessors \u003d Integer.parseInt(sysInfo[4]);\n            cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n            cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n            if (lastCumCpuTimeMs !\u003d -1) {\n              /**\n               * This number will be the aggregated usage across all cores in\n               * [0.0, 100.0]. For example, it will be 400.0 if there are 8\n               * cores and each of them is running at 50% utilization.\n               */\n              cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n                  * 100F / refreshInterval;\n            }\n          } catch (NumberFormatException nfe) {\n            LOG.warn(\"Error parsing sysInfo\", nfe);\n          }\n        } else {\n          LOG.warn(\"Expected split length of sysInfo to be \"\n              + sysInfoSplitCount + \". Got \" + sysInfo.length);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/SysInfoWindows.java",
      "extendedDetails": {}
    },
    "ac6048372a58b3a3b57cd5f2702b44a3d4667f3d": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "HADOOP-12180. Move ResourceCalculatorPlugin from YARN to Common. (Chris Douglas via kasha)\n",
      "commitDate": "09/07/15 9:56 AM",
      "commitName": "ac6048372a58b3a3b57cd5f2702b44a3d4667f3d",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HADOOP-12180. Move ResourceCalculatorPlugin from YARN to Common. (Chris Douglas via kasha)\n",
          "commitDate": "09/07/15 9:56 AM",
          "commitName": "ac6048372a58b3a3b57cd5f2702b44a3d4667f3d",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "09/07/15 9:48 AM",
          "commitNameOld": "aa067c6aa47b4c79577096817acc00ad6421180c",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,35 @@\n   void refreshIfNeeded() {\n-    long now \u003d System.currentTimeMillis();\n-    if (now - lastRefreshTime \u003e refreshIntervalMs) {\n+    long now \u003d now();\n+    if (now - lastRefreshTime \u003e REFRESH_INTERVAL_MS) {\n       long refreshInterval \u003d now - lastRefreshTime;\n       lastRefreshTime \u003d now;\n       long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n       reset();\n       String sysInfoStr \u003d getSystemInfoInfoFromShell();\n       if (sysInfoStr !\u003d null) {\n         final int sysInfoSplitCount \u003d 7;\n         String[] sysInfo \u003d sysInfoStr.substring(0, sysInfoStr.indexOf(\"\\r\\n\"))\n             .split(\",\");\n         if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n           try {\n             vmemSize \u003d Long.parseLong(sysInfo[0]);\n             memSize \u003d Long.parseLong(sysInfo[1]);\n             vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n             memAvailable \u003d Long.parseLong(sysInfo[3]);\n             numProcessors \u003d Integer.parseInt(sysInfo[4]);\n             cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n             cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n             if (lastCumCpuTimeMs !\u003d -1) {\n               cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n                   / (refreshInterval * 1.0f);\n             }\n-\n           } catch (NumberFormatException nfe) {\n-            LOG.warn(\"Error parsing sysInfo.\" + nfe);\n+            LOG.warn(\"Error parsing sysInfo\", nfe);\n           }\n         } else {\n           LOG.warn(\"Expected split length of sysInfo to be \"\n               + sysInfoSplitCount + \". Got \" + sysInfo.length);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void refreshIfNeeded() {\n    long now \u003d now();\n    if (now - lastRefreshTime \u003e REFRESH_INTERVAL_MS) {\n      long refreshInterval \u003d now - lastRefreshTime;\n      lastRefreshTime \u003d now;\n      long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n      reset();\n      String sysInfoStr \u003d getSystemInfoInfoFromShell();\n      if (sysInfoStr !\u003d null) {\n        final int sysInfoSplitCount \u003d 7;\n        String[] sysInfo \u003d sysInfoStr.substring(0, sysInfoStr.indexOf(\"\\r\\n\"))\n            .split(\",\");\n        if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n          try {\n            vmemSize \u003d Long.parseLong(sysInfo[0]);\n            memSize \u003d Long.parseLong(sysInfo[1]);\n            vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n            memAvailable \u003d Long.parseLong(sysInfo[3]);\n            numProcessors \u003d Integer.parseInt(sysInfo[4]);\n            cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n            cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n            if (lastCumCpuTimeMs !\u003d -1) {\n              cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n                  / (refreshInterval * 1.0f);\n            }\n          } catch (NumberFormatException nfe) {\n            LOG.warn(\"Error parsing sysInfo\", nfe);\n          }\n        } else {\n          LOG.warn(\"Expected split length of sysInfo to be \"\n              + sysInfoSplitCount + \". Got \" + sysInfo.length);\n        }\n      }\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/SysInfoWindows.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/WindowsResourceCalculatorPlugin.java",
            "newPath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/SysInfoWindows.java",
            "oldMethodName": "refreshIfNeeded",
            "newMethodName": "refreshIfNeeded"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-12180. Move ResourceCalculatorPlugin from YARN to Common. (Chris Douglas via kasha)\n",
          "commitDate": "09/07/15 9:56 AM",
          "commitName": "ac6048372a58b3a3b57cd5f2702b44a3d4667f3d",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "09/07/15 9:48 AM",
          "commitNameOld": "aa067c6aa47b4c79577096817acc00ad6421180c",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 0.01,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,36 +1,35 @@\n   void refreshIfNeeded() {\n-    long now \u003d System.currentTimeMillis();\n-    if (now - lastRefreshTime \u003e refreshIntervalMs) {\n+    long now \u003d now();\n+    if (now - lastRefreshTime \u003e REFRESH_INTERVAL_MS) {\n       long refreshInterval \u003d now - lastRefreshTime;\n       lastRefreshTime \u003d now;\n       long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n       reset();\n       String sysInfoStr \u003d getSystemInfoInfoFromShell();\n       if (sysInfoStr !\u003d null) {\n         final int sysInfoSplitCount \u003d 7;\n         String[] sysInfo \u003d sysInfoStr.substring(0, sysInfoStr.indexOf(\"\\r\\n\"))\n             .split(\",\");\n         if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n           try {\n             vmemSize \u003d Long.parseLong(sysInfo[0]);\n             memSize \u003d Long.parseLong(sysInfo[1]);\n             vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n             memAvailable \u003d Long.parseLong(sysInfo[3]);\n             numProcessors \u003d Integer.parseInt(sysInfo[4]);\n             cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n             cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n             if (lastCumCpuTimeMs !\u003d -1) {\n               cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n                   / (refreshInterval * 1.0f);\n             }\n-\n           } catch (NumberFormatException nfe) {\n-            LOG.warn(\"Error parsing sysInfo.\" + nfe);\n+            LOG.warn(\"Error parsing sysInfo\", nfe);\n           }\n         } else {\n           LOG.warn(\"Expected split length of sysInfo to be \"\n               + sysInfoSplitCount + \". Got \" + sysInfo.length);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void refreshIfNeeded() {\n    long now \u003d now();\n    if (now - lastRefreshTime \u003e REFRESH_INTERVAL_MS) {\n      long refreshInterval \u003d now - lastRefreshTime;\n      lastRefreshTime \u003d now;\n      long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n      reset();\n      String sysInfoStr \u003d getSystemInfoInfoFromShell();\n      if (sysInfoStr !\u003d null) {\n        final int sysInfoSplitCount \u003d 7;\n        String[] sysInfo \u003d sysInfoStr.substring(0, sysInfoStr.indexOf(\"\\r\\n\"))\n            .split(\",\");\n        if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n          try {\n            vmemSize \u003d Long.parseLong(sysInfo[0]);\n            memSize \u003d Long.parseLong(sysInfo[1]);\n            vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n            memAvailable \u003d Long.parseLong(sysInfo[3]);\n            numProcessors \u003d Integer.parseInt(sysInfo[4]);\n            cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n            cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n            if (lastCumCpuTimeMs !\u003d -1) {\n              cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n                  / (refreshInterval * 1.0f);\n            }\n          } catch (NumberFormatException nfe) {\n            LOG.warn(\"Error parsing sysInfo\", nfe);\n          }\n        } else {\n          LOG.warn(\"Expected split length of sysInfo to be \"\n              + sysInfoSplitCount + \". Got \" + sysInfo.length);\n        }\n      }\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/util/SysInfoWindows.java",
          "extendedDetails": {}
        }
      ]
    },
    "638801cce16fc1dc3259c541dc30a599faaddda1": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-8952. Enhancements to support Hadoop on Windows Server and Windows Azure environments. Contributed by Ivan Mitic, Chuan Liu, Ramya Sunil, Bikas Saha, Kanna Karanam, John Gordon, Brandon Li, Chris Nauroth, David Lao, Sumadhur Reddy Bolli, Arpit Agarwal, Ahmed El Baz, Mike Liddell, Jing Zhao, Thejas Nair, Steve Maine, Ganeshan Iyer, Raja Aluri, Giridharan Kesavan, Ramya Bharathi Nimmagadda.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1453486 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/03/13 11:15 AM",
      "commitName": "638801cce16fc1dc3259c541dc30a599faaddda1",
      "commitAuthor": "Suresh Srinivas",
      "diff": "@@ -0,0 +1,36 @@\n+  void refreshIfNeeded() {\n+    long now \u003d System.currentTimeMillis();\n+    if (now - lastRefreshTime \u003e refreshIntervalMs) {\n+      long refreshInterval \u003d now - lastRefreshTime;\n+      lastRefreshTime \u003d now;\n+      long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n+      reset();\n+      String sysInfoStr \u003d getSystemInfoInfoFromShell();\n+      if (sysInfoStr !\u003d null) {\n+        final int sysInfoSplitCount \u003d 7;\n+        String[] sysInfo \u003d sysInfoStr.substring(0, sysInfoStr.indexOf(\"\\r\\n\"))\n+            .split(\",\");\n+        if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n+          try {\n+            vmemSize \u003d Long.parseLong(sysInfo[0]);\n+            memSize \u003d Long.parseLong(sysInfo[1]);\n+            vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n+            memAvailable \u003d Long.parseLong(sysInfo[3]);\n+            numProcessors \u003d Integer.parseInt(sysInfo[4]);\n+            cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n+            cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n+            if (lastCumCpuTimeMs !\u003d -1) {\n+              cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n+                  / (refreshInterval * 1.0f);\n+            }\n+\n+          } catch (NumberFormatException nfe) {\n+            LOG.warn(\"Error parsing sysInfo.\" + nfe);\n+          }\n+        } else {\n+          LOG.warn(\"Expected split length of sysInfo to be \"\n+              + sysInfoSplitCount + \". Got \" + sysInfo.length);\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  void refreshIfNeeded() {\n    long now \u003d System.currentTimeMillis();\n    if (now - lastRefreshTime \u003e refreshIntervalMs) {\n      long refreshInterval \u003d now - lastRefreshTime;\n      lastRefreshTime \u003d now;\n      long lastCumCpuTimeMs \u003d cumulativeCpuTimeMs;\n      reset();\n      String sysInfoStr \u003d getSystemInfoInfoFromShell();\n      if (sysInfoStr !\u003d null) {\n        final int sysInfoSplitCount \u003d 7;\n        String[] sysInfo \u003d sysInfoStr.substring(0, sysInfoStr.indexOf(\"\\r\\n\"))\n            .split(\",\");\n        if (sysInfo.length \u003d\u003d sysInfoSplitCount) {\n          try {\n            vmemSize \u003d Long.parseLong(sysInfo[0]);\n            memSize \u003d Long.parseLong(sysInfo[1]);\n            vmemAvailable \u003d Long.parseLong(sysInfo[2]);\n            memAvailable \u003d Long.parseLong(sysInfo[3]);\n            numProcessors \u003d Integer.parseInt(sysInfo[4]);\n            cpuFrequencyKhz \u003d Long.parseLong(sysInfo[5]);\n            cumulativeCpuTimeMs \u003d Long.parseLong(sysInfo[6]);\n            if (lastCumCpuTimeMs !\u003d -1) {\n              cpuUsage \u003d (cumulativeCpuTimeMs - lastCumCpuTimeMs)\n                  / (refreshInterval * 1.0f);\n            }\n\n          } catch (NumberFormatException nfe) {\n            LOG.warn(\"Error parsing sysInfo.\" + nfe);\n          }\n        } else {\n          LOG.warn(\"Expected split length of sysInfo to be \"\n              + sysInfoSplitCount + \". Got \" + sysInfo.length);\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-common/src/main/java/org/apache/hadoop/yarn/util/WindowsResourceCalculatorPlugin.java"
    }
  }
}