{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "KerberosAuthenticator.java",
  "functionName": "doSpnegoSequence",
  "functionId": "doSpnegoSequence___token-AuthenticatedURL.Token(modifiers-final)",
  "sourceFilePath": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
  "functionStartLine": 292,
  "functionEndLine": 365,
  "numCommitsSeen": 26,
  "timeTaken": 2517,
  "changeHistory": [
    "c3793102121767c46091805eae65ef3919a5f368",
    "e806c6e0ce6026d53227b51d58ec6d5458164571",
    "4feed9b2dbff7bc52871cde7e1ff31b862e4fe9a",
    "d6b181c6faa56e43c9f05d2cc860a0aeb940fd90",
    "9d1a8f5897d585bec96de32116fbd2118f8e0f95",
    "bfce95d463b70c82c33b3bc2b15f7ed90eee592f",
    "a33ae4020d8676e957ee11b239a0876bdc7cc8c9",
    "e3242b95b35844a0877a83032d3a7e3d5e9bd9c2",
    "2a0147f8f698f22e61281c06691107e24a2f139c",
    "d8930feeae116fc53cb0676dad8521992762528c",
    "2b016dac8232e0f5c43293adcbdf7164f5fca74c",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "a0f120ce68dddb0cb31b64c89f3224313f3cb5af"
  ],
  "changeHistoryShort": {
    "c3793102121767c46091805eae65ef3919a5f368": "Ymultichange(Ybodychange,Yparametermetachange)",
    "e806c6e0ce6026d53227b51d58ec6d5458164571": "Ybodychange",
    "4feed9b2dbff7bc52871cde7e1ff31b862e4fe9a": "Ybodychange",
    "d6b181c6faa56e43c9f05d2cc860a0aeb940fd90": "Ybodychange",
    "9d1a8f5897d585bec96de32116fbd2118f8e0f95": "Ybodychange",
    "bfce95d463b70c82c33b3bc2b15f7ed90eee592f": "Ybodychange",
    "a33ae4020d8676e957ee11b239a0876bdc7cc8c9": "Ybodychange",
    "e3242b95b35844a0877a83032d3a7e3d5e9bd9c2": "Ybodychange",
    "2a0147f8f698f22e61281c06691107e24a2f139c": "Ybodychange",
    "d8930feeae116fc53cb0676dad8521992762528c": "Ybodychange",
    "2b016dac8232e0f5c43293adcbdf7164f5fca74c": "Yfilerename",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "a0f120ce68dddb0cb31b64c89f3224313f3cb5af": "Yintroduced"
  },
  "changeHistoryDetails": {
    "c3793102121767c46091805eae65ef3919a5f368": {
      "type": "Ymultichange(Ybodychange,Yparametermetachange)",
      "commitMessage": "HADOOP-14687. AuthenticatedURL will reuse bad/expired session cookies. Contributed by Daryn Sharp\n",
      "commitDate": "22/08/17 2:50 PM",
      "commitName": "c3793102121767c46091805eae65ef3919a5f368",
      "commitAuthor": "Jason Lowe",
      "subchanges": [
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-14687. AuthenticatedURL will reuse bad/expired session cookies. Contributed by Daryn Sharp\n",
          "commitDate": "22/08/17 2:50 PM",
          "commitName": "c3793102121767c46091805eae65ef3919a5f368",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "21/06/17 9:03 AM",
          "commitNameOld": "e806c6e0ce6026d53227b51d58ec6d5458164571",
          "commitAuthorOld": "Daryn Sharp",
          "daysBetweenCommits": 62.24,
          "commitsBetweenForRepo": 389,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,74 @@\n-  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n+  private void doSpnegoSequence(final AuthenticatedURL.Token token)\n+      throws IOException, AuthenticationException {\n     try {\n       AccessControlContext context \u003d AccessController.getContext();\n       Subject subject \u003d Subject.getSubject(context);\n       if (subject \u003d\u003d null\n           || (!KerberosUtil.hasKerberosKeyTab(subject)\n               \u0026\u0026 !KerberosUtil.hasKerberosTicket(subject))) {\n         LOG.debug(\"No subject in context, logging in\");\n         subject \u003d new Subject();\n         LoginContext login \u003d new LoginContext(\"\", subject,\n             null, new KerberosConfiguration());\n         login.login();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Using subject: \" + subject);\n       }\n       Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n         @Override\n         public Void run() throws Exception {\n           GSSContext gssContext \u003d null;\n           try {\n             GSSManager gssManager \u003d GSSManager.getInstance();\n             String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                 KerberosAuthenticator.this.url.getHost());\n             Oid oid \u003d KerberosUtil.NT_GSS_KRB5_PRINCIPAL_OID;\n             GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                         oid);\n             oid \u003d KerberosUtil.GSS_KRB5_MECH_OID;\n             gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                   GSSContext.DEFAULT_LIFETIME);\n             gssContext.requestCredDeleg(true);\n             gssContext.requestMutualAuth(true);\n \n             byte[] inToken \u003d new byte[0];\n             byte[] outToken;\n             boolean established \u003d false;\n \n             // Loop while the context is still not established\n             while (!established) {\n+              HttpURLConnection conn \u003d\n+                  token.openConnection(url, connConfigurator);\n               outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n               if (outToken !\u003d null) {\n-                sendToken(outToken);\n+                sendToken(conn, outToken);\n               }\n \n               if (!gssContext.isEstablished()) {\n-                inToken \u003d readToken();\n+                inToken \u003d readToken(conn);\n               } else {\n                 established \u003d true;\n               }\n             }\n           } finally {\n             if (gssContext !\u003d null) {\n               gssContext.dispose();\n               gssContext \u003d null;\n             }\n           }\n           return null;\n         }\n       });\n     } catch (PrivilegedActionException ex) {\n       if (ex.getException() instanceof IOException) {\n         throw (IOException) ex.getException();\n       } else {\n         throw new AuthenticationException(ex.getException());\n       }\n     } catch (LoginException ex) {\n       throw new AuthenticationException(ex);\n     }\n-    AuthenticatedURL.extractToken(conn, token);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doSpnegoSequence(final AuthenticatedURL.Token token)\n      throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null\n          || (!KerberosUtil.hasKerberosKeyTab(subject)\n              \u0026\u0026 !KerberosUtil.hasKerberosTicket(subject))) {\n        LOG.debug(\"No subject in context, logging in\");\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject,\n            null, new KerberosConfiguration());\n        login.login();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Using subject: \" + subject);\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                KerberosAuthenticator.this.url.getHost());\n            Oid oid \u003d KerberosUtil.NT_GSS_KRB5_PRINCIPAL_OID;\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        oid);\n            oid \u003d KerberosUtil.GSS_KRB5_MECH_OID;\n            gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              HttpURLConnection conn \u003d\n                  token.openConnection(url, connConfigurator);\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(conn, outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken(conn);\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      if (ex.getException() instanceof IOException) {\n        throw (IOException) ex.getException();\n      } else {\n        throw new AuthenticationException(ex.getException());\n      }\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n  }",
          "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparametermetachange",
          "commitMessage": "HADOOP-14687. AuthenticatedURL will reuse bad/expired session cookies. Contributed by Daryn Sharp\n",
          "commitDate": "22/08/17 2:50 PM",
          "commitName": "c3793102121767c46091805eae65ef3919a5f368",
          "commitAuthor": "Jason Lowe",
          "commitDateOld": "21/06/17 9:03 AM",
          "commitNameOld": "e806c6e0ce6026d53227b51d58ec6d5458164571",
          "commitAuthorOld": "Daryn Sharp",
          "daysBetweenCommits": 62.24,
          "commitsBetweenForRepo": 389,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,74 @@\n-  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n+  private void doSpnegoSequence(final AuthenticatedURL.Token token)\n+      throws IOException, AuthenticationException {\n     try {\n       AccessControlContext context \u003d AccessController.getContext();\n       Subject subject \u003d Subject.getSubject(context);\n       if (subject \u003d\u003d null\n           || (!KerberosUtil.hasKerberosKeyTab(subject)\n               \u0026\u0026 !KerberosUtil.hasKerberosTicket(subject))) {\n         LOG.debug(\"No subject in context, logging in\");\n         subject \u003d new Subject();\n         LoginContext login \u003d new LoginContext(\"\", subject,\n             null, new KerberosConfiguration());\n         login.login();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Using subject: \" + subject);\n       }\n       Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n         @Override\n         public Void run() throws Exception {\n           GSSContext gssContext \u003d null;\n           try {\n             GSSManager gssManager \u003d GSSManager.getInstance();\n             String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                 KerberosAuthenticator.this.url.getHost());\n             Oid oid \u003d KerberosUtil.NT_GSS_KRB5_PRINCIPAL_OID;\n             GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                         oid);\n             oid \u003d KerberosUtil.GSS_KRB5_MECH_OID;\n             gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                   GSSContext.DEFAULT_LIFETIME);\n             gssContext.requestCredDeleg(true);\n             gssContext.requestMutualAuth(true);\n \n             byte[] inToken \u003d new byte[0];\n             byte[] outToken;\n             boolean established \u003d false;\n \n             // Loop while the context is still not established\n             while (!established) {\n+              HttpURLConnection conn \u003d\n+                  token.openConnection(url, connConfigurator);\n               outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n               if (outToken !\u003d null) {\n-                sendToken(outToken);\n+                sendToken(conn, outToken);\n               }\n \n               if (!gssContext.isEstablished()) {\n-                inToken \u003d readToken();\n+                inToken \u003d readToken(conn);\n               } else {\n                 established \u003d true;\n               }\n             }\n           } finally {\n             if (gssContext !\u003d null) {\n               gssContext.dispose();\n               gssContext \u003d null;\n             }\n           }\n           return null;\n         }\n       });\n     } catch (PrivilegedActionException ex) {\n       if (ex.getException() instanceof IOException) {\n         throw (IOException) ex.getException();\n       } else {\n         throw new AuthenticationException(ex.getException());\n       }\n     } catch (LoginException ex) {\n       throw new AuthenticationException(ex);\n     }\n-    AuthenticatedURL.extractToken(conn, token);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doSpnegoSequence(final AuthenticatedURL.Token token)\n      throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null\n          || (!KerberosUtil.hasKerberosKeyTab(subject)\n              \u0026\u0026 !KerberosUtil.hasKerberosTicket(subject))) {\n        LOG.debug(\"No subject in context, logging in\");\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject,\n            null, new KerberosConfiguration());\n        login.login();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Using subject: \" + subject);\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                KerberosAuthenticator.this.url.getHost());\n            Oid oid \u003d KerberosUtil.NT_GSS_KRB5_PRINCIPAL_OID;\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        oid);\n            oid \u003d KerberosUtil.GSS_KRB5_MECH_OID;\n            gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              HttpURLConnection conn \u003d\n                  token.openConnection(url, connConfigurator);\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(conn, outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken(conn);\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      if (ex.getException() instanceof IOException) {\n        throw (IOException) ex.getException();\n      } else {\n        throw new AuthenticationException(ex.getException());\n      }\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n  }",
          "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
          "extendedDetails": {
            "oldValue": "[token-AuthenticatedURL.Token]",
            "newValue": "[token-AuthenticatedURL.Token(modifiers-final)]"
          }
        }
      ]
    },
    "e806c6e0ce6026d53227b51d58ec6d5458164571": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14146.  KerberosAuthenticationHandler should authenticate with SPN in AP-REQ.  Contributed by Daryn Sharp\n",
      "commitDate": "21/06/17 9:03 AM",
      "commitName": "e806c6e0ce6026d53227b51d58ec6d5458164571",
      "commitAuthor": "Daryn Sharp",
      "commitDateOld": "18/10/16 6:32 PM",
      "commitNameOld": "4bca385241c0fc8ff168c7b0f2984a7aed2c7492",
      "commitAuthorOld": "Benoy Antony",
      "daysBetweenCommits": 245.61,
      "commitsBetweenForRepo": 1429,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n     try {\n       AccessControlContext context \u003d AccessController.getContext();\n       Subject subject \u003d Subject.getSubject(context);\n       if (subject \u003d\u003d null\n           || (!KerberosUtil.hasKerberosKeyTab(subject)\n               \u0026\u0026 !KerberosUtil.hasKerberosTicket(subject))) {\n         LOG.debug(\"No subject in context, logging in\");\n         subject \u003d new Subject();\n         LoginContext login \u003d new LoginContext(\"\", subject,\n             null, new KerberosConfiguration());\n         login.login();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Using subject: \" + subject);\n       }\n       Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n         @Override\n         public Void run() throws Exception {\n           GSSContext gssContext \u003d null;\n           try {\n             GSSManager gssManager \u003d GSSManager.getInstance();\n             String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                 KerberosAuthenticator.this.url.getHost());\n-            Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n+            Oid oid \u003d KerberosUtil.NT_GSS_KRB5_PRINCIPAL_OID;\n             GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                         oid);\n-            oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n+            oid \u003d KerberosUtil.GSS_KRB5_MECH_OID;\n             gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                   GSSContext.DEFAULT_LIFETIME);\n             gssContext.requestCredDeleg(true);\n             gssContext.requestMutualAuth(true);\n \n             byte[] inToken \u003d new byte[0];\n             byte[] outToken;\n             boolean established \u003d false;\n \n             // Loop while the context is still not established\n             while (!established) {\n               outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n               if (outToken !\u003d null) {\n                 sendToken(outToken);\n               }\n \n               if (!gssContext.isEstablished()) {\n                 inToken \u003d readToken();\n               } else {\n                 established \u003d true;\n               }\n             }\n           } finally {\n             if (gssContext !\u003d null) {\n               gssContext.dispose();\n               gssContext \u003d null;\n             }\n           }\n           return null;\n         }\n       });\n     } catch (PrivilegedActionException ex) {\n       if (ex.getException() instanceof IOException) {\n         throw (IOException) ex.getException();\n       } else {\n         throw new AuthenticationException(ex.getException());\n       }\n     } catch (LoginException ex) {\n       throw new AuthenticationException(ex);\n     }\n     AuthenticatedURL.extractToken(conn, token);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null\n          || (!KerberosUtil.hasKerberosKeyTab(subject)\n              \u0026\u0026 !KerberosUtil.hasKerberosTicket(subject))) {\n        LOG.debug(\"No subject in context, logging in\");\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject,\n            null, new KerberosConfiguration());\n        login.login();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Using subject: \" + subject);\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                KerberosAuthenticator.this.url.getHost());\n            Oid oid \u003d KerberosUtil.NT_GSS_KRB5_PRINCIPAL_OID;\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        oid);\n            oid \u003d KerberosUtil.GSS_KRB5_MECH_OID;\n            gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken();\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      if (ex.getException() instanceof IOException) {\n        throw (IOException) ex.getException();\n      } else {\n        throw new AuthenticationException(ex.getException());\n      }\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n    AuthenticatedURL.extractToken(conn, token);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
      "extendedDetails": {}
    },
    "4feed9b2dbff7bc52871cde7e1ff31b862e4fe9a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13026 Should not wrap IOExceptions into a AuthenticationException in KerberosAuthenticator. Xuan Gong via stevel\n",
      "commitDate": "15/04/16 9:44 AM",
      "commitName": "4feed9b2dbff7bc52871cde7e1ff31b862e4fe9a",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "24/02/16 1:55 PM",
      "commitNameOld": "d6b181c6faa56e43c9f05d2cc860a0aeb940fd90",
      "commitAuthorOld": "cnauroth",
      "daysBetweenCommits": 50.78,
      "commitsBetweenForRepo": 310,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,72 @@\n   private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n     try {\n       AccessControlContext context \u003d AccessController.getContext();\n       Subject subject \u003d Subject.getSubject(context);\n       if (subject \u003d\u003d null\n           || (!KerberosUtil.hasKerberosKeyTab(subject)\n               \u0026\u0026 !KerberosUtil.hasKerberosTicket(subject))) {\n         LOG.debug(\"No subject in context, logging in\");\n         subject \u003d new Subject();\n         LoginContext login \u003d new LoginContext(\"\", subject,\n             null, new KerberosConfiguration());\n         login.login();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Using subject: \" + subject);\n       }\n       Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n         @Override\n         public Void run() throws Exception {\n           GSSContext gssContext \u003d null;\n           try {\n             GSSManager gssManager \u003d GSSManager.getInstance();\n             String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                 KerberosAuthenticator.this.url.getHost());\n             Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n             GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                         oid);\n             oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n             gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                   GSSContext.DEFAULT_LIFETIME);\n             gssContext.requestCredDeleg(true);\n             gssContext.requestMutualAuth(true);\n \n             byte[] inToken \u003d new byte[0];\n             byte[] outToken;\n             boolean established \u003d false;\n \n             // Loop while the context is still not established\n             while (!established) {\n               outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n               if (outToken !\u003d null) {\n                 sendToken(outToken);\n               }\n \n               if (!gssContext.isEstablished()) {\n                 inToken \u003d readToken();\n               } else {\n                 established \u003d true;\n               }\n             }\n           } finally {\n             if (gssContext !\u003d null) {\n               gssContext.dispose();\n               gssContext \u003d null;\n             }\n           }\n           return null;\n         }\n       });\n     } catch (PrivilegedActionException ex) {\n-      throw new AuthenticationException(ex.getException());\n+      if (ex.getException() instanceof IOException) {\n+        throw (IOException) ex.getException();\n+      } else {\n+        throw new AuthenticationException(ex.getException());\n+      }\n     } catch (LoginException ex) {\n       throw new AuthenticationException(ex);\n     }\n     AuthenticatedURL.extractToken(conn, token);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null\n          || (!KerberosUtil.hasKerberosKeyTab(subject)\n              \u0026\u0026 !KerberosUtil.hasKerberosTicket(subject))) {\n        LOG.debug(\"No subject in context, logging in\");\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject,\n            null, new KerberosConfiguration());\n        login.login();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Using subject: \" + subject);\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                KerberosAuthenticator.this.url.getHost());\n            Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        oid);\n            oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n            gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken();\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      if (ex.getException() instanceof IOException) {\n        throw (IOException) ex.getException();\n      } else {\n        throw new AuthenticationException(ex.getException());\n      }\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n    AuthenticatedURL.extractToken(conn, token);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
      "extendedDetails": {}
    },
    "d6b181c6faa56e43c9f05d2cc860a0aeb940fd90": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-12716. KerberosAuthenticator#doSpnegoSequence use incorrect class to determine isKeyTab in JDK8. Contributed by Xiaoyu Yao.\n",
      "commitDate": "24/02/16 1:55 PM",
      "commitName": "d6b181c6faa56e43c9f05d2cc860a0aeb940fd90",
      "commitAuthor": "cnauroth",
      "commitDateOld": "13/02/15 2:01 PM",
      "commitNameOld": "875256834b892b574499d5fe68f95a9aed244f7d",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 376.0,
      "commitsBetweenForRepo": 2962,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n     try {\n       AccessControlContext context \u003d AccessController.getContext();\n       Subject subject \u003d Subject.getSubject(context);\n       if (subject \u003d\u003d null\n-          || (subject.getPrivateCredentials(KerberosKey.class).isEmpty()\n-              \u0026\u0026 subject.getPrivateCredentials(KerberosTicket.class).isEmpty())) {\n+          || (!KerberosUtil.hasKerberosKeyTab(subject)\n+              \u0026\u0026 !KerberosUtil.hasKerberosTicket(subject))) {\n         LOG.debug(\"No subject in context, logging in\");\n         subject \u003d new Subject();\n         LoginContext login \u003d new LoginContext(\"\", subject,\n             null, new KerberosConfiguration());\n         login.login();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Using subject: \" + subject);\n       }\n       Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n         @Override\n         public Void run() throws Exception {\n           GSSContext gssContext \u003d null;\n           try {\n             GSSManager gssManager \u003d GSSManager.getInstance();\n             String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                 KerberosAuthenticator.this.url.getHost());\n             Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n             GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                         oid);\n             oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n             gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                   GSSContext.DEFAULT_LIFETIME);\n             gssContext.requestCredDeleg(true);\n             gssContext.requestMutualAuth(true);\n \n             byte[] inToken \u003d new byte[0];\n             byte[] outToken;\n             boolean established \u003d false;\n \n             // Loop while the context is still not established\n             while (!established) {\n               outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n               if (outToken !\u003d null) {\n                 sendToken(outToken);\n               }\n \n               if (!gssContext.isEstablished()) {\n                 inToken \u003d readToken();\n               } else {\n                 established \u003d true;\n               }\n             }\n           } finally {\n             if (gssContext !\u003d null) {\n               gssContext.dispose();\n               gssContext \u003d null;\n             }\n           }\n           return null;\n         }\n       });\n     } catch (PrivilegedActionException ex) {\n       throw new AuthenticationException(ex.getException());\n     } catch (LoginException ex) {\n       throw new AuthenticationException(ex);\n     }\n     AuthenticatedURL.extractToken(conn, token);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null\n          || (!KerberosUtil.hasKerberosKeyTab(subject)\n              \u0026\u0026 !KerberosUtil.hasKerberosTicket(subject))) {\n        LOG.debug(\"No subject in context, logging in\");\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject,\n            null, new KerberosConfiguration());\n        login.login();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Using subject: \" + subject);\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                KerberosAuthenticator.this.url.getHost());\n            Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        oid);\n            oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n            gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken();\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      throw new AuthenticationException(ex.getException());\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n    AuthenticatedURL.extractToken(conn, token);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
      "extendedDetails": {}
    },
    "9d1a8f5897d585bec96de32116fbd2118f8e0f95": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-11332. KerberosAuthenticator#doSpnegoSequence should check if kerberos TGT is available in the subject. Contributed by Dian Fu.\n",
      "commitDate": "03/12/14 6:53 PM",
      "commitName": "9d1a8f5897d585bec96de32116fbd2118f8e0f95",
      "commitAuthor": "Aaron T. Myers",
      "commitDateOld": "07/03/14 6:16 PM",
      "commitNameOld": "b7428fe63d80ce150a964fae427f13c161f39164",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 271.03,
      "commitsBetweenForRepo": 2182,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,68 @@\n   private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n     try {\n       AccessControlContext context \u003d AccessController.getContext();\n       Subject subject \u003d Subject.getSubject(context);\n-      if (subject \u003d\u003d null) {\n+      if (subject \u003d\u003d null\n+          || (subject.getPrivateCredentials(KerberosKey.class).isEmpty()\n+              \u0026\u0026 subject.getPrivateCredentials(KerberosTicket.class).isEmpty())) {\n         LOG.debug(\"No subject in context, logging in\");\n         subject \u003d new Subject();\n         LoginContext login \u003d new LoginContext(\"\", subject,\n             null, new KerberosConfiguration());\n         login.login();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Using subject: \" + subject);\n       }\n       Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n         @Override\n         public Void run() throws Exception {\n           GSSContext gssContext \u003d null;\n           try {\n             GSSManager gssManager \u003d GSSManager.getInstance();\n             String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                 KerberosAuthenticator.this.url.getHost());\n             Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n             GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                         oid);\n             oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n             gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                   GSSContext.DEFAULT_LIFETIME);\n             gssContext.requestCredDeleg(true);\n             gssContext.requestMutualAuth(true);\n \n             byte[] inToken \u003d new byte[0];\n             byte[] outToken;\n             boolean established \u003d false;\n \n             // Loop while the context is still not established\n             while (!established) {\n               outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n               if (outToken !\u003d null) {\n                 sendToken(outToken);\n               }\n \n               if (!gssContext.isEstablished()) {\n                 inToken \u003d readToken();\n               } else {\n                 established \u003d true;\n               }\n             }\n           } finally {\n             if (gssContext !\u003d null) {\n               gssContext.dispose();\n               gssContext \u003d null;\n             }\n           }\n           return null;\n         }\n       });\n     } catch (PrivilegedActionException ex) {\n       throw new AuthenticationException(ex.getException());\n     } catch (LoginException ex) {\n       throw new AuthenticationException(ex);\n     }\n     AuthenticatedURL.extractToken(conn, token);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null\n          || (subject.getPrivateCredentials(KerberosKey.class).isEmpty()\n              \u0026\u0026 subject.getPrivateCredentials(KerberosTicket.class).isEmpty())) {\n        LOG.debug(\"No subject in context, logging in\");\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject,\n            null, new KerberosConfiguration());\n        login.login();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Using subject: \" + subject);\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                KerberosAuthenticator.this.url.getHost());\n            Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        oid);\n            oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n            gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken();\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      throw new AuthenticationException(ex.getException());\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n    AuthenticatedURL.extractToken(conn, token);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
      "extendedDetails": {}
    },
    "bfce95d463b70c82c33b3bc2b15f7ed90eee592f": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8878. Uppercase namenode hostname causes hadoop dfs calls with webhdfs filesystem and fsck to fail when security is on. Contributed by Arpit Gupta.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1396922 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/10/12 11:30 PM",
      "commitName": "bfce95d463b70c82c33b3bc2b15f7ed90eee592f",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "26/09/12 10:03 PM",
      "commitNameOld": "a33ae4020d8676e957ee11b239a0876bdc7cc8c9",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 14.06,
      "commitsBetweenForRepo": 76,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,66 @@\n   private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n     try {\n       AccessControlContext context \u003d AccessController.getContext();\n       Subject subject \u003d Subject.getSubject(context);\n       if (subject \u003d\u003d null) {\n         LOG.debug(\"No subject in context, logging in\");\n         subject \u003d new Subject();\n         LoginContext login \u003d new LoginContext(\"\", subject,\n             null, new KerberosConfiguration());\n         login.login();\n       }\n \n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Using subject: \" + subject);\n       }\n       Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n         @Override\n         public Void run() throws Exception {\n           GSSContext gssContext \u003d null;\n           try {\n             GSSManager gssManager \u003d GSSManager.getInstance();\n-            String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n+            String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n+                KerberosAuthenticator.this.url.getHost());\n             Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n             GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                         oid);\n             oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n             gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                   GSSContext.DEFAULT_LIFETIME);\n             gssContext.requestCredDeleg(true);\n             gssContext.requestMutualAuth(true);\n \n             byte[] inToken \u003d new byte[0];\n             byte[] outToken;\n             boolean established \u003d false;\n \n             // Loop while the context is still not established\n             while (!established) {\n               outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n               if (outToken !\u003d null) {\n                 sendToken(outToken);\n               }\n \n               if (!gssContext.isEstablished()) {\n                 inToken \u003d readToken();\n               } else {\n                 established \u003d true;\n               }\n             }\n           } finally {\n             if (gssContext !\u003d null) {\n               gssContext.dispose();\n               gssContext \u003d null;\n             }\n           }\n           return null;\n         }\n       });\n     } catch (PrivilegedActionException ex) {\n       throw new AuthenticationException(ex.getException());\n     } catch (LoginException ex) {\n       throw new AuthenticationException(ex);\n     }\n     AuthenticatedURL.extractToken(conn, token);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null) {\n        LOG.debug(\"No subject in context, logging in\");\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject,\n            null, new KerberosConfiguration());\n        login.login();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Using subject: \" + subject);\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d KerberosUtil.getServicePrincipal(\"HTTP\",\n                KerberosAuthenticator.this.url.getHost());\n            Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        oid);\n            oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n            gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken();\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      throw new AuthenticationException(ex.getException());\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n    AuthenticatedURL.extractToken(conn, token);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
      "extendedDetails": {}
    },
    "a33ae4020d8676e957ee11b239a0876bdc7cc8c9": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8855. SSL-based image transfer does not work when Kerberos is disabled. Contributed by Todd Lipcon\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1390841 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/09/12 10:03 PM",
      "commitName": "a33ae4020d8676e957ee11b239a0876bdc7cc8c9",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "06/08/12 3:22 PM",
      "commitNameOld": "5383694df9665cb8eecd1765ab79a7147d9269b0",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 51.28,
      "commitsBetweenForRepo": 295,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,65 @@\n   private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n     try {\n       AccessControlContext context \u003d AccessController.getContext();\n       Subject subject \u003d Subject.getSubject(context);\n       if (subject \u003d\u003d null) {\n+        LOG.debug(\"No subject in context, logging in\");\n         subject \u003d new Subject();\n         LoginContext login \u003d new LoginContext(\"\", subject,\n             null, new KerberosConfiguration());\n         login.login();\n       }\n+\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Using subject: \" + subject);\n+      }\n       Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n         @Override\n         public Void run() throws Exception {\n           GSSContext gssContext \u003d null;\n           try {\n             GSSManager gssManager \u003d GSSManager.getInstance();\n             String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n             Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n             GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                         oid);\n             oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n             gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                   GSSContext.DEFAULT_LIFETIME);\n             gssContext.requestCredDeleg(true);\n             gssContext.requestMutualAuth(true);\n \n             byte[] inToken \u003d new byte[0];\n             byte[] outToken;\n             boolean established \u003d false;\n \n             // Loop while the context is still not established\n             while (!established) {\n               outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n               if (outToken !\u003d null) {\n                 sendToken(outToken);\n               }\n \n               if (!gssContext.isEstablished()) {\n                 inToken \u003d readToken();\n               } else {\n                 established \u003d true;\n               }\n             }\n           } finally {\n             if (gssContext !\u003d null) {\n               gssContext.dispose();\n               gssContext \u003d null;\n             }\n           }\n           return null;\n         }\n       });\n     } catch (PrivilegedActionException ex) {\n       throw new AuthenticationException(ex.getException());\n     } catch (LoginException ex) {\n       throw new AuthenticationException(ex);\n     }\n     AuthenticatedURL.extractToken(conn, token);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null) {\n        LOG.debug(\"No subject in context, logging in\");\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject,\n            null, new KerberosConfiguration());\n        login.login();\n      }\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Using subject: \" + subject);\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n            Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        oid);\n            oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n            gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken();\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      throw new AuthenticationException(ex.getException());\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n    AuthenticatedURL.extractToken(conn, token);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
      "extendedDetails": {}
    },
    "e3242b95b35844a0877a83032d3a7e3d5e9bd9c2": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8346. Makes oid changes to make SPNEGO work. Was broken due to fixes introduced by the IBM JDK compatibility patch. Contributed by Devaraj Das.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1333557 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/05/12 10:16 AM",
      "commitName": "e3242b95b35844a0877a83032d3a7e3d5e9bd9c2",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "15/03/12 6:45 PM",
      "commitNameOld": "2a0147f8f698f22e61281c06691107e24a2f139c",
      "commitAuthorOld": "Devaraj Das",
      "daysBetweenCommits": 48.65,
      "commitsBetweenForRepo": 354,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,60 @@\n   private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n     try {\n       AccessControlContext context \u003d AccessController.getContext();\n       Subject subject \u003d Subject.getSubject(context);\n       if (subject \u003d\u003d null) {\n         subject \u003d new Subject();\n         LoginContext login \u003d new LoginContext(\"\", subject,\n             null, new KerberosConfiguration());\n         login.login();\n       }\n       Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n         @Override\n         public Void run() throws Exception {\n           GSSContext gssContext \u003d null;\n           try {\n             GSSManager gssManager \u003d GSSManager.getInstance();\n             String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n-            \n+            Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n             GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n-                                                        GSSName.NT_HOSTBASED_SERVICE);\n-            Oid oid \u003d KerberosUtil.getOidClassInstance(servicePrincipal, \n-                gssManager);\n+                                                        oid);\n+            oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n             gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                   GSSContext.DEFAULT_LIFETIME);\n             gssContext.requestCredDeleg(true);\n             gssContext.requestMutualAuth(true);\n \n             byte[] inToken \u003d new byte[0];\n             byte[] outToken;\n             boolean established \u003d false;\n \n             // Loop while the context is still not established\n             while (!established) {\n               outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n               if (outToken !\u003d null) {\n                 sendToken(outToken);\n               }\n \n               if (!gssContext.isEstablished()) {\n                 inToken \u003d readToken();\n               } else {\n                 established \u003d true;\n               }\n             }\n           } finally {\n             if (gssContext !\u003d null) {\n               gssContext.dispose();\n               gssContext \u003d null;\n             }\n           }\n           return null;\n         }\n       });\n     } catch (PrivilegedActionException ex) {\n       throw new AuthenticationException(ex.getException());\n     } catch (LoginException ex) {\n       throw new AuthenticationException(ex);\n     }\n     AuthenticatedURL.extractToken(conn, token);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null) {\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject,\n            null, new KerberosConfiguration());\n        login.login();\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n            Oid oid \u003d KerberosUtil.getOidInstance(\"NT_GSS_KRB5_PRINCIPAL\");\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        oid);\n            oid \u003d KerberosUtil.getOidInstance(\"GSS_KRB5_MECH_OID\");\n            gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken();\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      throw new AuthenticationException(ex.getException());\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n    AuthenticatedURL.extractToken(conn, token);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
      "extendedDetails": {}
    },
    "2a0147f8f698f22e61281c06691107e24a2f139c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-6941. Adds support for building Hadoop with IBM\u0027s JDK. Contributed by Stephen Watt, Eli Collins and Devaraj Das.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1301308 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/03/12 6:45 PM",
      "commitName": "2a0147f8f698f22e61281c06691107e24a2f139c",
      "commitAuthor": "Devaraj Das",
      "commitDateOld": "30/11/11 12:26 PM",
      "commitNameOld": "d8930feeae116fc53cb0676dad8521992762528c",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 106.22,
      "commitsBetweenForRepo": 763,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,61 @@\n   private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n     try {\n       AccessControlContext context \u003d AccessController.getContext();\n       Subject subject \u003d Subject.getSubject(context);\n       if (subject \u003d\u003d null) {\n         subject \u003d new Subject();\n         LoginContext login \u003d new LoginContext(\"\", subject,\n             null, new KerberosConfiguration());\n         login.login();\n       }\n       Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n         @Override\n         public Void run() throws Exception {\n           GSSContext gssContext \u003d null;\n           try {\n             GSSManager gssManager \u003d GSSManager.getInstance();\n             String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n+            \n             GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n-                                                        GSSUtil.NT_GSS_KRB5_PRINCIPAL);\n-            gssContext \u003d gssManager.createContext(serviceName, GSSUtil.GSS_KRB5_MECH_OID, null,\n+                                                        GSSName.NT_HOSTBASED_SERVICE);\n+            Oid oid \u003d KerberosUtil.getOidClassInstance(servicePrincipal, \n+                gssManager);\n+            gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                   GSSContext.DEFAULT_LIFETIME);\n             gssContext.requestCredDeleg(true);\n             gssContext.requestMutualAuth(true);\n \n             byte[] inToken \u003d new byte[0];\n             byte[] outToken;\n             boolean established \u003d false;\n \n             // Loop while the context is still not established\n             while (!established) {\n               outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n               if (outToken !\u003d null) {\n                 sendToken(outToken);\n               }\n \n               if (!gssContext.isEstablished()) {\n                 inToken \u003d readToken();\n               } else {\n                 established \u003d true;\n               }\n             }\n           } finally {\n             if (gssContext !\u003d null) {\n               gssContext.dispose();\n               gssContext \u003d null;\n             }\n           }\n           return null;\n         }\n       });\n     } catch (PrivilegedActionException ex) {\n       throw new AuthenticationException(ex.getException());\n     } catch (LoginException ex) {\n       throw new AuthenticationException(ex);\n     }\n     AuthenticatedURL.extractToken(conn, token);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null) {\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject,\n            null, new KerberosConfiguration());\n        login.login();\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n            \n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        GSSName.NT_HOSTBASED_SERVICE);\n            Oid oid \u003d KerberosUtil.getOidClassInstance(servicePrincipal, \n                gssManager);\n            gssContext \u003d gssManager.createContext(serviceName, oid, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken();\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      throw new AuthenticationException(ex.getException());\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n    AuthenticatedURL.extractToken(conn, token);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
      "extendedDetails": {}
    },
    "d8930feeae116fc53cb0676dad8521992762528c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-7853. multiple javax security configurations cause conflicts. (daryn via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1208751 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/11/11 12:26 PM",
      "commitName": "d8930feeae116fc53cb0676dad8521992762528c",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "31/08/11 3:40 PM",
      "commitNameOld": "2b016dac8232e0f5c43293adcbdf7164f5fca74c",
      "commitAuthorOld": "Tsz-wo Sze",
      "daysBetweenCommits": 90.91,
      "commitsBetweenForRepo": 634,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,58 @@\n   private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n     try {\n       AccessControlContext context \u003d AccessController.getContext();\n       Subject subject \u003d Subject.getSubject(context);\n       if (subject \u003d\u003d null) {\n         subject \u003d new Subject();\n-        LoginContext login \u003d new LoginContext(\"\", subject);\n+        LoginContext login \u003d new LoginContext(\"\", subject,\n+            null, new KerberosConfiguration());\n         login.login();\n       }\n       Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n \n         @Override\n         public Void run() throws Exception {\n           GSSContext gssContext \u003d null;\n           try {\n             GSSManager gssManager \u003d GSSManager.getInstance();\n             String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n             GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                         GSSUtil.NT_GSS_KRB5_PRINCIPAL);\n             gssContext \u003d gssManager.createContext(serviceName, GSSUtil.GSS_KRB5_MECH_OID, null,\n                                                   GSSContext.DEFAULT_LIFETIME);\n             gssContext.requestCredDeleg(true);\n             gssContext.requestMutualAuth(true);\n \n             byte[] inToken \u003d new byte[0];\n             byte[] outToken;\n             boolean established \u003d false;\n \n             // Loop while the context is still not established\n             while (!established) {\n               outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n               if (outToken !\u003d null) {\n                 sendToken(outToken);\n               }\n \n               if (!gssContext.isEstablished()) {\n                 inToken \u003d readToken();\n               } else {\n                 established \u003d true;\n               }\n             }\n           } finally {\n             if (gssContext !\u003d null) {\n               gssContext.dispose();\n               gssContext \u003d null;\n             }\n           }\n           return null;\n         }\n       });\n     } catch (PrivilegedActionException ex) {\n       throw new AuthenticationException(ex.getException());\n     } catch (LoginException ex) {\n       throw new AuthenticationException(ex);\n     }\n     AuthenticatedURL.extractToken(conn, token);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null) {\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject,\n            null, new KerberosConfiguration());\n        login.login();\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        GSSUtil.NT_GSS_KRB5_PRINCIPAL);\n            gssContext \u003d gssManager.createContext(serviceName, GSSUtil.GSS_KRB5_MECH_OID, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken();\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      throw new AuthenticationException(ex.getException());\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n    AuthenticatedURL.extractToken(conn, token);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
      "extendedDetails": {}
    },
    "2b016dac8232e0f5c43293adcbdf7164f5fca74c": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7579. Rename package names from alfredo to auth.  Contributed by Alejandro Abdelnur\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1163852 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/08/11 3:40 PM",
      "commitName": "2b016dac8232e0f5c43293adcbdf7164f5fca74c",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "31/08/11 2:18 PM",
      "commitNameOld": "4f1a0e36fab1f18e6e2c5fcc72cd9a7634967fcd",
      "commitAuthorOld": "Konstantin Shvachko",
      "daysBetweenCommits": 0.06,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null) {\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject);\n        login.login();\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        GSSUtil.NT_GSS_KRB5_PRINCIPAL);\n            gssContext \u003d gssManager.createContext(serviceName, GSSUtil.GSS_KRB5_MECH_OID, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken();\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      throw new AuthenticationException(ex.getException());\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n    AuthenticatedURL.extractToken(conn, token);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java",
      "extendedDetails": {
        "oldPath": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/alfredo/client/KerberosAuthenticator.java",
        "newPath": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/security/authentication/client/KerberosAuthenticator.java"
      }
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null) {\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject);\n        login.login();\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        GSSUtil.NT_GSS_KRB5_PRINCIPAL);\n            gssContext \u003d gssManager.createContext(serviceName, GSSUtil.GSS_KRB5_MECH_OID, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken();\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      throw new AuthenticationException(ex.getException());\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n    AuthenticatedURL.extractToken(conn, token);\n  }",
      "path": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/alfredo/client/KerberosAuthenticator.java",
      "extendedDetails": {
        "oldPath": "hadoop-alfredo/src/main/java/org/apache/hadoop/alfredo/client/KerberosAuthenticator.java",
        "newPath": "hadoop-common-project/hadoop-auth/src/main/java/org/apache/hadoop/alfredo/client/KerberosAuthenticator.java"
      }
    },
    "a0f120ce68dddb0cb31b64c89f3224313f3cb5af": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7119. add Kerberos HTTP SPNEGO authentication support to Hadoop JT/NN/DN/TT web-consoles. (Alejandro Abdelnur via atm)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159804 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 3:31 PM",
      "commitName": "a0f120ce68dddb0cb31b64c89f3224313f3cb5af",
      "commitAuthor": "Aaron Myers",
      "diff": "@@ -0,0 +1,57 @@\n+  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n+    try {\n+      AccessControlContext context \u003d AccessController.getContext();\n+      Subject subject \u003d Subject.getSubject(context);\n+      if (subject \u003d\u003d null) {\n+        subject \u003d new Subject();\n+        LoginContext login \u003d new LoginContext(\"\", subject);\n+        login.login();\n+      }\n+      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n+\n+        @Override\n+        public Void run() throws Exception {\n+          GSSContext gssContext \u003d null;\n+          try {\n+            GSSManager gssManager \u003d GSSManager.getInstance();\n+            String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n+            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n+                                                        GSSUtil.NT_GSS_KRB5_PRINCIPAL);\n+            gssContext \u003d gssManager.createContext(serviceName, GSSUtil.GSS_KRB5_MECH_OID, null,\n+                                                  GSSContext.DEFAULT_LIFETIME);\n+            gssContext.requestCredDeleg(true);\n+            gssContext.requestMutualAuth(true);\n+\n+            byte[] inToken \u003d new byte[0];\n+            byte[] outToken;\n+            boolean established \u003d false;\n+\n+            // Loop while the context is still not established\n+            while (!established) {\n+              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n+              if (outToken !\u003d null) {\n+                sendToken(outToken);\n+              }\n+\n+              if (!gssContext.isEstablished()) {\n+                inToken \u003d readToken();\n+              } else {\n+                established \u003d true;\n+              }\n+            }\n+          } finally {\n+            if (gssContext !\u003d null) {\n+              gssContext.dispose();\n+              gssContext \u003d null;\n+            }\n+          }\n+          return null;\n+        }\n+      });\n+    } catch (PrivilegedActionException ex) {\n+      throw new AuthenticationException(ex.getException());\n+    } catch (LoginException ex) {\n+      throw new AuthenticationException(ex);\n+    }\n+    AuthenticatedURL.extractToken(conn, token);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void doSpnegoSequence(AuthenticatedURL.Token token) throws IOException, AuthenticationException {\n    try {\n      AccessControlContext context \u003d AccessController.getContext();\n      Subject subject \u003d Subject.getSubject(context);\n      if (subject \u003d\u003d null) {\n        subject \u003d new Subject();\n        LoginContext login \u003d new LoginContext(\"\", subject);\n        login.login();\n      }\n      Subject.doAs(subject, new PrivilegedExceptionAction\u003cVoid\u003e() {\n\n        @Override\n        public Void run() throws Exception {\n          GSSContext gssContext \u003d null;\n          try {\n            GSSManager gssManager \u003d GSSManager.getInstance();\n            String servicePrincipal \u003d \"HTTP/\" + KerberosAuthenticator.this.url.getHost();\n            GSSName serviceName \u003d gssManager.createName(servicePrincipal,\n                                                        GSSUtil.NT_GSS_KRB5_PRINCIPAL);\n            gssContext \u003d gssManager.createContext(serviceName, GSSUtil.GSS_KRB5_MECH_OID, null,\n                                                  GSSContext.DEFAULT_LIFETIME);\n            gssContext.requestCredDeleg(true);\n            gssContext.requestMutualAuth(true);\n\n            byte[] inToken \u003d new byte[0];\n            byte[] outToken;\n            boolean established \u003d false;\n\n            // Loop while the context is still not established\n            while (!established) {\n              outToken \u003d gssContext.initSecContext(inToken, 0, inToken.length);\n              if (outToken !\u003d null) {\n                sendToken(outToken);\n              }\n\n              if (!gssContext.isEstablished()) {\n                inToken \u003d readToken();\n              } else {\n                established \u003d true;\n              }\n            }\n          } finally {\n            if (gssContext !\u003d null) {\n              gssContext.dispose();\n              gssContext \u003d null;\n            }\n          }\n          return null;\n        }\n      });\n    } catch (PrivilegedActionException ex) {\n      throw new AuthenticationException(ex.getException());\n    } catch (LoginException ex) {\n      throw new AuthenticationException(ex);\n    }\n    AuthenticatedURL.extractToken(conn, token);\n  }",
      "path": "hadoop-alfredo/src/main/java/org/apache/hadoop/alfredo/client/KerberosAuthenticator.java"
    }
  }
}