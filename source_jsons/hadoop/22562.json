{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "UncompressedSplitLineReader.java",
  "functionName": "readLine",
  "functionId": "readLine___str-Text__maxLineLength-int__maxBytesToConsume-int",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/input/UncompressedSplitLineReader.java",
  "functionStartLine": 84,
  "functionEndLine": 97,
  "numCommitsSeen": 5,
  "timeTaken": 915,
  "changeHistory": [
    "58d1a02b8d66b1d2a6ac2158be32bd35ad2e69bd",
    "077250d8d7b4b757543a39a6ce8bb6e3be356c6f"
  ],
  "changeHistoryShort": {
    "58d1a02b8d66b1d2a6ac2158be32bd35ad2e69bd": "Ybodychange",
    "077250d8d7b4b757543a39a6ce8bb6e3be356c6f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "58d1a02b8d66b1d2a6ac2158be32bd35ad2e69bd": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6481. LineRecordReader may give incomplete record and wrong position/key information for uncompressed input sometimes. Contributed by Zhihai Xu\n",
      "commitDate": "17/09/15 7:30 AM",
      "commitName": "58d1a02b8d66b1d2a6ac2158be32bd35ad2e69bd",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "22/06/15 2:59 PM",
      "commitNameOld": "077250d8d7b4b757543a39a6ce8bb6e3be356c6f",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 86.69,
      "commitsBetweenForRepo": 511,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,14 @@\n   public int readLine(Text str, int maxLineLength, int maxBytesToConsume)\n       throws IOException {\n-    long bytesRead \u003d 0;\n+    int bytesRead \u003d 0;\n     if (!finished) {\n       // only allow at most one more record to be read after the stream\n       // reports the split ended\n       if (totalBytesRead \u003e splitLength) {\n         finished \u003d true;\n       }\n-      bytesRead \u003d totalBytesRead;\n-      int bytesConsumed \u003d super.readLine(str, maxLineLength, maxBytesToConsume);\n-      bytesRead \u003d totalBytesRead - bytesRead;\n \n-      // No records left.\n-      if (bytesConsumed \u003d\u003d 0 \u0026\u0026 bytesRead \u003d\u003d 0) {\n-        return 0;\n-      }\n-\n-      int bufferSize \u003d getBufferSize();\n-\n-      // Add the remaining buffer size not used for the last call\n-      // of fillBuffer method.\n-      if (lastBytesRead \u003c\u003d 0) {\n-        bytesRead +\u003d bufferSize;\n-      } else if (bytesRead \u003e 0) {\n-        bytesRead +\u003d bufferSize - lastBytesRead;\n-      }\n-\n-      // Adjust the size of the buffer not used for this record.\n-      // The size is carried over for the next calculation.\n-      bytesRead +\u003d unusedBytes;\n-      unusedBytes \u003d bufferSize - getBufferPosn();\n-      bytesRead -\u003d unusedBytes;\n+      bytesRead \u003d super.readLine(str, maxLineLength, maxBytesToConsume);\n     }\n-    return (int) bytesRead;\n+    return bytesRead;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public int readLine(Text str, int maxLineLength, int maxBytesToConsume)\n      throws IOException {\n    int bytesRead \u003d 0;\n    if (!finished) {\n      // only allow at most one more record to be read after the stream\n      // reports the split ended\n      if (totalBytesRead \u003e splitLength) {\n        finished \u003d true;\n      }\n\n      bytesRead \u003d super.readLine(str, maxLineLength, maxBytesToConsume);\n    }\n    return bytesRead;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/input/UncompressedSplitLineReader.java",
      "extendedDetails": {}
    },
    "077250d8d7b4b757543a39a6ce8bb6e3be356c6f": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-5948. org.apache.hadoop.mapred.LineRecordReader does not handle multibyte record delimiters well. Contributed by Vinayakumar B, Rushabh Shah, and Akira AJISAKA\n",
      "commitDate": "22/06/15 2:59 PM",
      "commitName": "077250d8d7b4b757543a39a6ce8bb6e3be356c6f",
      "commitAuthor": "Jason Lowe",
      "diff": "@@ -0,0 +1,36 @@\n+  public int readLine(Text str, int maxLineLength, int maxBytesToConsume)\n+      throws IOException {\n+    long bytesRead \u003d 0;\n+    if (!finished) {\n+      // only allow at most one more record to be read after the stream\n+      // reports the split ended\n+      if (totalBytesRead \u003e splitLength) {\n+        finished \u003d true;\n+      }\n+      bytesRead \u003d totalBytesRead;\n+      int bytesConsumed \u003d super.readLine(str, maxLineLength, maxBytesToConsume);\n+      bytesRead \u003d totalBytesRead - bytesRead;\n+\n+      // No records left.\n+      if (bytesConsumed \u003d\u003d 0 \u0026\u0026 bytesRead \u003d\u003d 0) {\n+        return 0;\n+      }\n+\n+      int bufferSize \u003d getBufferSize();\n+\n+      // Add the remaining buffer size not used for the last call\n+      // of fillBuffer method.\n+      if (lastBytesRead \u003c\u003d 0) {\n+        bytesRead +\u003d bufferSize;\n+      } else if (bytesRead \u003e 0) {\n+        bytesRead +\u003d bufferSize - lastBytesRead;\n+      }\n+\n+      // Adjust the size of the buffer not used for this record.\n+      // The size is carried over for the next calculation.\n+      bytesRead +\u003d unusedBytes;\n+      unusedBytes \u003d bufferSize - getBufferPosn();\n+      bytesRead -\u003d unusedBytes;\n+    }\n+    return (int) bytesRead;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public int readLine(Text str, int maxLineLength, int maxBytesToConsume)\n      throws IOException {\n    long bytesRead \u003d 0;\n    if (!finished) {\n      // only allow at most one more record to be read after the stream\n      // reports the split ended\n      if (totalBytesRead \u003e splitLength) {\n        finished \u003d true;\n      }\n      bytesRead \u003d totalBytesRead;\n      int bytesConsumed \u003d super.readLine(str, maxLineLength, maxBytesToConsume);\n      bytesRead \u003d totalBytesRead - bytesRead;\n\n      // No records left.\n      if (bytesConsumed \u003d\u003d 0 \u0026\u0026 bytesRead \u003d\u003d 0) {\n        return 0;\n      }\n\n      int bufferSize \u003d getBufferSize();\n\n      // Add the remaining buffer size not used for the last call\n      // of fillBuffer method.\n      if (lastBytesRead \u003c\u003d 0) {\n        bytesRead +\u003d bufferSize;\n      } else if (bytesRead \u003e 0) {\n        bytesRead +\u003d bufferSize - lastBytesRead;\n      }\n\n      // Adjust the size of the buffer not used for this record.\n      // The size is carried over for the next calculation.\n      bytesRead +\u003d unusedBytes;\n      unusedBytes \u003d bufferSize - getBufferPosn();\n      bytesRead -\u003d unusedBytes;\n    }\n    return (int) bytesRead;\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/lib/input/UncompressedSplitLineReader.java"
    }
  }
}