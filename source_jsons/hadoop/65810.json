{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DynamoDBMetadataStore.java",
  "functionName": "addAncestors",
  "functionId": "addAncestors___qualifiedPath-Path(modifiers-final)__operationState-BulkOperationState(annotations-@Nullable__modifiers-final)",
  "sourceFilePath": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
  "functionStartLine": 1008,
  "functionEndLine": 1071,
  "numCommitsSeen": 73,
  "timeTaken": 4214,
  "changeHistory": [
    "49df83899543586bbcaf80f01399ade031cf68b0",
    "ea25f4de236611d388e14a710ebe5d6872c421b6",
    "7b219778e05a50e33cca75d727e62783322b7f80",
    "c58e11bf521d746842ce16724211a2a0339d7b61",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
    "e02eb24e0a9139418120027b694492e0738df20a"
  ],
  "changeHistoryShort": {
    "49df83899543586bbcaf80f01399ade031cf68b0": "Ybodychange",
    "ea25f4de236611d388e14a710ebe5d6872c421b6": "Ybodychange",
    "7b219778e05a50e33cca75d727e62783322b7f80": "Ybodychange",
    "c58e11bf521d746842ce16724211a2a0339d7b61": "Yparameterchange",
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": "Ybodychange",
    "e02eb24e0a9139418120027b694492e0738df20a": "Yintroduced"
  },
  "changeHistoryDetails": {
    "49df83899543586bbcaf80f01399ade031cf68b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16697. Tune/audit S3A authoritative mode.\n\nContains:\n\nHADOOP-16474. S3Guard ProgressiveRenameTracker to mark destination\n              dirirectory as authoritative on success.\nHADOOP-16684. S3guard bucket info to list a bit more about\n              authoritative paths.\nHADOOP-16722. S3GuardTool to support FilterFileSystem.\n\nThis patch improves the marking of newly created/import directory\ntrees in S3Guard DynamoDB tables as authoritative.\n\nSpecific changes:\n\n * Renamed directories are marked as authoritative if the entire\n   operation succeeded (HADOOP-16474).\n * When updating parent table entries as part of any table write,\n   there\u0027s no overwriting of their authoritative flag.\n\ns3guard import changes:\n\n* new -verbose flag to print out what is going on.\n\n* The \"s3guard import\" command lets you declare that a directory tree\nis to be marked as authoritative\n\n  hadoop s3guard import -authoritative -verbose s3a://bucket/path\n\nWhen importing a listing and a file is found, the import tool queries\nthe metastore and only updates the entry if the file is different from\nbefore, where different \u003d\u003d new timestamp, etag, or length. S3Guard can get\ntimestamp differences due to clock skew in PUT operations.\n\nAs the recursive list performed by the import command doesn\u0027t retrieve the\nversionID, the existing entry may in fact be more complete.\nWhen updating an existing due to clock skew the existing version ID\nis propagated to the new entry (note: the etags must match; this is needed\nto deal with inconsistent listings).\n\nThere is a new s3guard command to audit a s3guard bucket/path\u0027s\nauthoritative state:\n\n  hadoop s3guard authoritative -check-config s3a://bucket/path\n\nThis is primarily for testing/auditing.\n\nThe s3guard bucket-info command also provides some more details on the\nauthoritative state of a store (HADOOP-16684).\n\nChange-Id: I58001341c04f6f3597fcb4fcb1581ccefeb77d91\n",
      "commitDate": "10/01/20 3:11 AM",
      "commitName": "49df83899543586bbcaf80f01399ade031cf68b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "26/11/19 7:36 AM",
      "commitNameOld": "ea25f4de236611d388e14a710ebe5d6872c421b6",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 44.82,
      "commitsBetweenForRepo": 155,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   public void addAncestors(final Path qualifiedPath,\n       @Nullable final BulkOperationState operationState) throws IOException {\n \n     Collection\u003cDDBPathMetadata\u003e newDirs \u003d new ArrayList\u003c\u003e();\n     final AncestorState ancestorState \u003d extractOrCreate(operationState,\n-        BulkOperationState.OperationType.Rename);\n+        BulkOperationState.OperationType.Put);\n     Path parent \u003d qualifiedPath.getParent();\n     boolean entryFound \u003d false;\n \n     // Iterate up the parents.\n     // note that only ancestorState get/set operations are synchronized;\n     // the DDB read between them is not. As a result, more than one\n     // thread may probe the state, find the entry missing, do the database\n     // query and add the entry.\n     // This is done to avoid making the remote dynamo query part of the\n     // synchronized block.\n     // If a race does occur, the cost is simply one extra GET and potentially\n     // one extra PUT.\n     while (!parent.isRoot()) {\n       synchronized (ancestorState) {\n         if (ancestorState.contains(parent)) {\n           // the ancestry map contains the key, so no need to even look for it.\n           break;\n         }\n       }\n       // we don\u0027t worry about tombstone expiry here as expired or not,\n       // a directory entry will go in.\n       PathMetadata directory \u003d get(parent);\n       if (directory \u003d\u003d null || directory.isDeleted()) {\n         if (entryFound) {\n           LOG.warn(\"Inconsistent S3Guard table: adding directory {}\", parent);\n         }\n         S3AFileStatus status \u003d makeDirStatus(username, parent);\n         LOG.debug(\"Adding new ancestor entry {}\", status);\n         DDBPathMetadata meta \u003d new DDBPathMetadata(status, Tristate.FALSE,\n             false, ttlTimeProvider.getNow());\n         newDirs.add(meta);\n         // Do not update ancestor state here, as it\n         // will happen in the innerPut() call. Were we to add it\n         // here that put operation would actually (mistakenly) skip\n         // creating the entry.\n       } else {\n         // an entry was found. Check its type\n         entryFound \u003d true;\n         if (directory.getFileStatus().isFile()) {\n           throw new PathIOException(parent.toString(),\n               \"Cannot overwrite parent file: metastore is\"\n                   + \" in an inconsistent state\");\n         }\n         // the directory exists. Add it to the ancestor state for next time.\n         synchronized (ancestorState) {\n           ancestorState.put(parent, new DDBPathMetadata(directory));\n         }\n       }\n       parent \u003d parent.getParent();\n     }\n     // the listing of directories to put is all those parents which we know\n     // are not in the store or BulkOperationState.\n     if (!newDirs.isEmpty()) {\n       // patch up the time.\n       patchLastUpdated(newDirs, ttlTimeProvider);\n       innerPut(newDirs, operationState);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void addAncestors(final Path qualifiedPath,\n      @Nullable final BulkOperationState operationState) throws IOException {\n\n    Collection\u003cDDBPathMetadata\u003e newDirs \u003d new ArrayList\u003c\u003e();\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Put);\n    Path parent \u003d qualifiedPath.getParent();\n    boolean entryFound \u003d false;\n\n    // Iterate up the parents.\n    // note that only ancestorState get/set operations are synchronized;\n    // the DDB read between them is not. As a result, more than one\n    // thread may probe the state, find the entry missing, do the database\n    // query and add the entry.\n    // This is done to avoid making the remote dynamo query part of the\n    // synchronized block.\n    // If a race does occur, the cost is simply one extra GET and potentially\n    // one extra PUT.\n    while (!parent.isRoot()) {\n      synchronized (ancestorState) {\n        if (ancestorState.contains(parent)) {\n          // the ancestry map contains the key, so no need to even look for it.\n          break;\n        }\n      }\n      // we don\u0027t worry about tombstone expiry here as expired or not,\n      // a directory entry will go in.\n      PathMetadata directory \u003d get(parent);\n      if (directory \u003d\u003d null || directory.isDeleted()) {\n        if (entryFound) {\n          LOG.warn(\"Inconsistent S3Guard table: adding directory {}\", parent);\n        }\n        S3AFileStatus status \u003d makeDirStatus(username, parent);\n        LOG.debug(\"Adding new ancestor entry {}\", status);\n        DDBPathMetadata meta \u003d new DDBPathMetadata(status, Tristate.FALSE,\n            false, ttlTimeProvider.getNow());\n        newDirs.add(meta);\n        // Do not update ancestor state here, as it\n        // will happen in the innerPut() call. Were we to add it\n        // here that put operation would actually (mistakenly) skip\n        // creating the entry.\n      } else {\n        // an entry was found. Check its type\n        entryFound \u003d true;\n        if (directory.getFileStatus().isFile()) {\n          throw new PathIOException(parent.toString(),\n              \"Cannot overwrite parent file: metastore is\"\n                  + \" in an inconsistent state\");\n        }\n        // the directory exists. Add it to the ancestor state for next time.\n        synchronized (ancestorState) {\n          ancestorState.put(parent, new DDBPathMetadata(directory));\n        }\n      }\n      parent \u003d parent.getParent();\n    }\n    // the listing of directories to put is all those parents which we know\n    // are not in the store or BulkOperationState.\n    if (!newDirs.isEmpty()) {\n      // patch up the time.\n      patchLastUpdated(newDirs, ttlTimeProvider);\n      innerPut(newDirs, operationState);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "ea25f4de236611d388e14a710ebe5d6872c421b6": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16709. S3Guard: Make authoritative mode exclusive for metadata - don\u0027t check for expiry for authoritative paths (#1721). Contributed by Gabor Bota.\n\n",
      "commitDate": "26/11/19 7:36 AM",
      "commitName": "ea25f4de236611d388e14a710ebe5d6872c421b6",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "16/10/19 1:41 AM",
      "commitNameOld": "bbcf0b91d6f5eb697d09e45505b0e72e193c3d75",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 41.29,
      "commitsBetweenForRepo": 153,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   public void addAncestors(final Path qualifiedPath,\n       @Nullable final BulkOperationState operationState) throws IOException {\n \n     Collection\u003cDDBPathMetadata\u003e newDirs \u003d new ArrayList\u003c\u003e();\n     final AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Rename);\n     Path parent \u003d qualifiedPath.getParent();\n     boolean entryFound \u003d false;\n \n     // Iterate up the parents.\n     // note that only ancestorState get/set operations are synchronized;\n     // the DDB read between them is not. As a result, more than one\n     // thread may probe the state, find the entry missing, do the database\n     // query and add the entry.\n     // This is done to avoid making the remote dynamo query part of the\n     // synchronized block.\n     // If a race does occur, the cost is simply one extra GET and potentially\n     // one extra PUT.\n     while (!parent.isRoot()) {\n       synchronized (ancestorState) {\n         if (ancestorState.contains(parent)) {\n           // the ancestry map contains the key, so no need to even look for it.\n           break;\n         }\n       }\n       // we don\u0027t worry about tombstone expiry here as expired or not,\n       // a directory entry will go in.\n       PathMetadata directory \u003d get(parent);\n       if (directory \u003d\u003d null || directory.isDeleted()) {\n         if (entryFound) {\n           LOG.warn(\"Inconsistent S3Guard table: adding directory {}\", parent);\n         }\n         S3AFileStatus status \u003d makeDirStatus(username, parent);\n         LOG.debug(\"Adding new ancestor entry {}\", status);\n         DDBPathMetadata meta \u003d new DDBPathMetadata(status, Tristate.FALSE,\n             false, ttlTimeProvider.getNow());\n         newDirs.add(meta);\n         // Do not update ancestor state here, as it\n         // will happen in the innerPut() call. Were we to add it\n         // here that put operation would actually (mistakenly) skip\n         // creating the entry.\n       } else {\n         // an entry was found. Check its type\n         entryFound \u003d true;\n         if (directory.getFileStatus().isFile()) {\n           throw new PathIOException(parent.toString(),\n               \"Cannot overwrite parent file: metastore is\"\n                   + \" in an inconsistent state\");\n         }\n         // the directory exists. Add it to the ancestor state for next time.\n         synchronized (ancestorState) {\n           ancestorState.put(parent, new DDBPathMetadata(directory));\n         }\n       }\n       parent \u003d parent.getParent();\n     }\n     // the listing of directories to put is all those parents which we know\n     // are not in the store or BulkOperationState.\n     if (!newDirs.isEmpty()) {\n       // patch up the time.\n       patchLastUpdated(newDirs, ttlTimeProvider);\n-      innerPut(newDirs, operationState, ttlTimeProvider);\n+      innerPut(newDirs, operationState);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void addAncestors(final Path qualifiedPath,\n      @Nullable final BulkOperationState operationState) throws IOException {\n\n    Collection\u003cDDBPathMetadata\u003e newDirs \u003d new ArrayList\u003c\u003e();\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    Path parent \u003d qualifiedPath.getParent();\n    boolean entryFound \u003d false;\n\n    // Iterate up the parents.\n    // note that only ancestorState get/set operations are synchronized;\n    // the DDB read between them is not. As a result, more than one\n    // thread may probe the state, find the entry missing, do the database\n    // query and add the entry.\n    // This is done to avoid making the remote dynamo query part of the\n    // synchronized block.\n    // If a race does occur, the cost is simply one extra GET and potentially\n    // one extra PUT.\n    while (!parent.isRoot()) {\n      synchronized (ancestorState) {\n        if (ancestorState.contains(parent)) {\n          // the ancestry map contains the key, so no need to even look for it.\n          break;\n        }\n      }\n      // we don\u0027t worry about tombstone expiry here as expired or not,\n      // a directory entry will go in.\n      PathMetadata directory \u003d get(parent);\n      if (directory \u003d\u003d null || directory.isDeleted()) {\n        if (entryFound) {\n          LOG.warn(\"Inconsistent S3Guard table: adding directory {}\", parent);\n        }\n        S3AFileStatus status \u003d makeDirStatus(username, parent);\n        LOG.debug(\"Adding new ancestor entry {}\", status);\n        DDBPathMetadata meta \u003d new DDBPathMetadata(status, Tristate.FALSE,\n            false, ttlTimeProvider.getNow());\n        newDirs.add(meta);\n        // Do not update ancestor state here, as it\n        // will happen in the innerPut() call. Were we to add it\n        // here that put operation would actually (mistakenly) skip\n        // creating the entry.\n      } else {\n        // an entry was found. Check its type\n        entryFound \u003d true;\n        if (directory.getFileStatus().isFile()) {\n          throw new PathIOException(parent.toString(),\n              \"Cannot overwrite parent file: metastore is\"\n                  + \" in an inconsistent state\");\n        }\n        // the directory exists. Add it to the ancestor state for next time.\n        synchronized (ancestorState) {\n          ancestorState.put(parent, new DDBPathMetadata(directory));\n        }\n      }\n      parent \u003d parent.getParent();\n    }\n    // the listing of directories to put is all those parents which we know\n    // are not in the store or BulkOperationState.\n    if (!newDirs.isEmpty()) {\n      // patch up the time.\n      patchLastUpdated(newDirs, ttlTimeProvider);\n      innerPut(newDirs, operationState);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "7b219778e05a50e33cca75d727e62783322b7f80": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16433. S3Guard: Filter expired entries and tombstones when listing with MetadataStore.listChildren().\n\nContributed by Gabor Bota.\n\nThis pulls the tracking of the lastUpdated timestamp of metadata entries up from the DDB metastore into all s3guard stores, and then uses this to filter out expired tombstones from listings.\n\nChange-Id: I80f121236b49c75a024116f65a3ef29d3580b462\n",
      "commitDate": "24/07/19 10:11 AM",
      "commitName": "7b219778e05a50e33cca75d727e62783322b7f80",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "17/07/19 7:24 AM",
      "commitNameOld": "c58e11bf521d746842ce16724211a2a0339d7b61",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 7.12,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,64 @@\n   public void addAncestors(final Path qualifiedPath,\n       @Nullable final BulkOperationState operationState) throws IOException {\n \n     Collection\u003cDDBPathMetadata\u003e newDirs \u003d new ArrayList\u003c\u003e();\n     final AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Rename);\n     Path parent \u003d qualifiedPath.getParent();\n     boolean entryFound \u003d false;\n \n     // Iterate up the parents.\n     // note that only ancestorState get/set operations are synchronized;\n     // the DDB read between them is not. As a result, more than one\n     // thread may probe the state, find the entry missing, do the database\n     // query and add the entry.\n     // This is done to avoid making the remote dynamo query part of the\n     // synchronized block.\n     // If a race does occur, the cost is simply one extra GET and potentially\n     // one extra PUT.\n     while (!parent.isRoot()) {\n       synchronized (ancestorState) {\n         if (ancestorState.contains(parent)) {\n           // the ancestry map contains the key, so no need to even look for it.\n           break;\n         }\n       }\n       // we don\u0027t worry about tombstone expiry here as expired or not,\n       // a directory entry will go in.\n       PathMetadata directory \u003d get(parent);\n       if (directory \u003d\u003d null || directory.isDeleted()) {\n         if (entryFound) {\n           LOG.warn(\"Inconsistent S3Guard table: adding directory {}\", parent);\n         }\n         S3AFileStatus status \u003d makeDirStatus(username, parent);\n         LOG.debug(\"Adding new ancestor entry {}\", status);\n         DDBPathMetadata meta \u003d new DDBPathMetadata(status, Tristate.FALSE,\n-            false);\n+            false, ttlTimeProvider.getNow());\n         newDirs.add(meta);\n         // Do not update ancestor state here, as it\n         // will happen in the innerPut() call. Were we to add it\n         // here that put operation would actually (mistakenly) skip\n         // creating the entry.\n       } else {\n         // an entry was found. Check its type\n         entryFound \u003d true;\n         if (directory.getFileStatus().isFile()) {\n           throw new PathIOException(parent.toString(),\n               \"Cannot overwrite parent file: metastore is\"\n                   + \" in an inconsistent state\");\n         }\n         // the directory exists. Add it to the ancestor state for next time.\n         synchronized (ancestorState) {\n           ancestorState.put(parent, new DDBPathMetadata(directory));\n         }\n       }\n       parent \u003d parent.getParent();\n     }\n     // the listing of directories to put is all those parents which we know\n     // are not in the store or BulkOperationState.\n     if (!newDirs.isEmpty()) {\n       // patch up the time.\n       patchLastUpdated(newDirs, ttlTimeProvider);\n       innerPut(newDirs, operationState, ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void addAncestors(final Path qualifiedPath,\n      @Nullable final BulkOperationState operationState) throws IOException {\n\n    Collection\u003cDDBPathMetadata\u003e newDirs \u003d new ArrayList\u003c\u003e();\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    Path parent \u003d qualifiedPath.getParent();\n    boolean entryFound \u003d false;\n\n    // Iterate up the parents.\n    // note that only ancestorState get/set operations are synchronized;\n    // the DDB read between them is not. As a result, more than one\n    // thread may probe the state, find the entry missing, do the database\n    // query and add the entry.\n    // This is done to avoid making the remote dynamo query part of the\n    // synchronized block.\n    // If a race does occur, the cost is simply one extra GET and potentially\n    // one extra PUT.\n    while (!parent.isRoot()) {\n      synchronized (ancestorState) {\n        if (ancestorState.contains(parent)) {\n          // the ancestry map contains the key, so no need to even look for it.\n          break;\n        }\n      }\n      // we don\u0027t worry about tombstone expiry here as expired or not,\n      // a directory entry will go in.\n      PathMetadata directory \u003d get(parent);\n      if (directory \u003d\u003d null || directory.isDeleted()) {\n        if (entryFound) {\n          LOG.warn(\"Inconsistent S3Guard table: adding directory {}\", parent);\n        }\n        S3AFileStatus status \u003d makeDirStatus(username, parent);\n        LOG.debug(\"Adding new ancestor entry {}\", status);\n        DDBPathMetadata meta \u003d new DDBPathMetadata(status, Tristate.FALSE,\n            false, ttlTimeProvider.getNow());\n        newDirs.add(meta);\n        // Do not update ancestor state here, as it\n        // will happen in the innerPut() call. Were we to add it\n        // here that put operation would actually (mistakenly) skip\n        // creating the entry.\n      } else {\n        // an entry was found. Check its type\n        entryFound \u003d true;\n        if (directory.getFileStatus().isFile()) {\n          throw new PathIOException(parent.toString(),\n              \"Cannot overwrite parent file: metastore is\"\n                  + \" in an inconsistent state\");\n        }\n        // the directory exists. Add it to the ancestor state for next time.\n        synchronized (ancestorState) {\n          ancestorState.put(parent, new DDBPathMetadata(directory));\n        }\n      }\n      parent \u003d parent.getParent();\n    }\n    // the listing of directories to put is all those parents which we know\n    // are not in the store or BulkOperationState.\n    if (!newDirs.isEmpty()) {\n      // patch up the time.\n      patchLastUpdated(newDirs, ttlTimeProvider);\n      innerPut(newDirs, operationState, ttlTimeProvider);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "c58e11bf521d746842ce16724211a2a0339d7b61": {
      "type": "Yparameterchange",
      "commitMessage": "HADOOP-16383. Pass ITtlTimeProvider instance in initialize method in MetadataStore interface.  Contributed by Gabor Bota. (#1009) \n\n\r\n",
      "commitDate": "17/07/19 7:24 AM",
      "commitName": "c58e11bf521d746842ce16724211a2a0339d7b61",
      "commitAuthor": "Gabor Bota",
      "commitDateOld": "12/07/19 5:02 AM",
      "commitNameOld": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
      "commitAuthorOld": "Steve Loughran",
      "daysBetweenCommits": 5.1,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,64 @@\n-  public void addAncestors(\n-      final Path qualifiedPath,\n-      final ITtlTimeProvider ttlTimeProvider,\n+  public void addAncestors(final Path qualifiedPath,\n       @Nullable final BulkOperationState operationState) throws IOException {\n \n     Collection\u003cDDBPathMetadata\u003e newDirs \u003d new ArrayList\u003c\u003e();\n     final AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Rename);\n     Path parent \u003d qualifiedPath.getParent();\n     boolean entryFound \u003d false;\n \n     // Iterate up the parents.\n     // note that only ancestorState get/set operations are synchronized;\n     // the DDB read between them is not. As a result, more than one\n     // thread may probe the state, find the entry missing, do the database\n     // query and add the entry.\n     // This is done to avoid making the remote dynamo query part of the\n     // synchronized block.\n     // If a race does occur, the cost is simply one extra GET and potentially\n     // one extra PUT.\n     while (!parent.isRoot()) {\n       synchronized (ancestorState) {\n         if (ancestorState.contains(parent)) {\n           // the ancestry map contains the key, so no need to even look for it.\n           break;\n         }\n       }\n       // we don\u0027t worry about tombstone expiry here as expired or not,\n       // a directory entry will go in.\n       PathMetadata directory \u003d get(parent);\n       if (directory \u003d\u003d null || directory.isDeleted()) {\n         if (entryFound) {\n           LOG.warn(\"Inconsistent S3Guard table: adding directory {}\", parent);\n         }\n         S3AFileStatus status \u003d makeDirStatus(username, parent);\n         LOG.debug(\"Adding new ancestor entry {}\", status);\n         DDBPathMetadata meta \u003d new DDBPathMetadata(status, Tristate.FALSE,\n             false);\n         newDirs.add(meta);\n         // Do not update ancestor state here, as it\n         // will happen in the innerPut() call. Were we to add it\n         // here that put operation would actually (mistakenly) skip\n         // creating the entry.\n       } else {\n         // an entry was found. Check its type\n         entryFound \u003d true;\n         if (directory.getFileStatus().isFile()) {\n           throw new PathIOException(parent.toString(),\n               \"Cannot overwrite parent file: metastore is\"\n                   + \" in an inconsistent state\");\n         }\n         // the directory exists. Add it to the ancestor state for next time.\n         synchronized (ancestorState) {\n           ancestorState.put(parent, new DDBPathMetadata(directory));\n         }\n       }\n       parent \u003d parent.getParent();\n     }\n     // the listing of directories to put is all those parents which we know\n     // are not in the store or BulkOperationState.\n     if (!newDirs.isEmpty()) {\n       // patch up the time.\n       patchLastUpdated(newDirs, ttlTimeProvider);\n       innerPut(newDirs, operationState, ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void addAncestors(final Path qualifiedPath,\n      @Nullable final BulkOperationState operationState) throws IOException {\n\n    Collection\u003cDDBPathMetadata\u003e newDirs \u003d new ArrayList\u003c\u003e();\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    Path parent \u003d qualifiedPath.getParent();\n    boolean entryFound \u003d false;\n\n    // Iterate up the parents.\n    // note that only ancestorState get/set operations are synchronized;\n    // the DDB read between them is not. As a result, more than one\n    // thread may probe the state, find the entry missing, do the database\n    // query and add the entry.\n    // This is done to avoid making the remote dynamo query part of the\n    // synchronized block.\n    // If a race does occur, the cost is simply one extra GET and potentially\n    // one extra PUT.\n    while (!parent.isRoot()) {\n      synchronized (ancestorState) {\n        if (ancestorState.contains(parent)) {\n          // the ancestry map contains the key, so no need to even look for it.\n          break;\n        }\n      }\n      // we don\u0027t worry about tombstone expiry here as expired or not,\n      // a directory entry will go in.\n      PathMetadata directory \u003d get(parent);\n      if (directory \u003d\u003d null || directory.isDeleted()) {\n        if (entryFound) {\n          LOG.warn(\"Inconsistent S3Guard table: adding directory {}\", parent);\n        }\n        S3AFileStatus status \u003d makeDirStatus(username, parent);\n        LOG.debug(\"Adding new ancestor entry {}\", status);\n        DDBPathMetadata meta \u003d new DDBPathMetadata(status, Tristate.FALSE,\n            false);\n        newDirs.add(meta);\n        // Do not update ancestor state here, as it\n        // will happen in the innerPut() call. Were we to add it\n        // here that put operation would actually (mistakenly) skip\n        // creating the entry.\n      } else {\n        // an entry was found. Check its type\n        entryFound \u003d true;\n        if (directory.getFileStatus().isFile()) {\n          throw new PathIOException(parent.toString(),\n              \"Cannot overwrite parent file: metastore is\"\n                  + \" in an inconsistent state\");\n        }\n        // the directory exists. Add it to the ancestor state for next time.\n        synchronized (ancestorState) {\n          ancestorState.put(parent, new DDBPathMetadata(directory));\n        }\n      }\n      parent \u003d parent.getParent();\n    }\n    // the listing of directories to put is all those parents which we know\n    // are not in the store or BulkOperationState.\n    if (!newDirs.isEmpty()) {\n      // patch up the time.\n      patchLastUpdated(newDirs, ttlTimeProvider);\n      innerPut(newDirs, operationState, ttlTimeProvider);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {
        "oldValue": "[qualifiedPath-Path(modifiers-final), ttlTimeProvider-ITtlTimeProvider(modifiers-final), operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]",
        "newValue": "[qualifiedPath-Path(modifiers-final), operationState-BulkOperationState(annotations-@Nullable__modifiers-final)]"
      }
    },
    "b15ef7dc3d91c6d50fa515158104fba29f43e6b0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-16384: S3A: Avoid inconsistencies between DDB and S3.\n\nContributed by Steve Loughran\n\nContains\n\n- HADOOP-16397. Hadoop S3Guard Prune command to support a -tombstone option.\n- HADOOP-16406. ITestDynamoDBMetadataStore.testProvisionTable times out intermittently\n\nThis patch doesn\u0027t fix the underlying problem but it\n\n* changes some tests to clean up better\n* does a lot more in logging operations in against DDB, if enabled\n* adds an entry point to dump the state of the metastore and s3 tables (precursor to fsck)\n* adds a purge entry point to help clean up after a test run has got a store into a mess\n* s3guard prune command adds -tombstone option to only clear tombstones\n\nThe outcome is that tests should pass consistently and if problems occur we have better diagnostics.\n\nChange-Id: I3eca3f5529d7f6fec398c0ff0472919f08f054eb\n",
      "commitDate": "12/07/19 5:02 AM",
      "commitName": "b15ef7dc3d91c6d50fa515158104fba29f43e6b0",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "08/07/19 10:27 AM",
      "commitNameOld": "de6b7bc67ace7744adb0320ee7de79cf28259d2d",
      "commitAuthorOld": "Sean Mackrory",
      "daysBetweenCommits": 3.77,
      "commitsBetweenForRepo": 38,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n   public void addAncestors(\n       final Path qualifiedPath,\n       final ITtlTimeProvider ttlTimeProvider,\n       @Nullable final BulkOperationState operationState) throws IOException {\n \n     Collection\u003cDDBPathMetadata\u003e newDirs \u003d new ArrayList\u003c\u003e();\n     final AncestorState ancestorState \u003d extractOrCreate(operationState,\n         BulkOperationState.OperationType.Rename);\n     Path parent \u003d qualifiedPath.getParent();\n     boolean entryFound \u003d false;\n \n     // Iterate up the parents.\n     // note that only ancestorState get/set operations are synchronized;\n     // the DDB read between them is not. As a result, more than one\n     // thread may probe the state, find the entry missing, do the database\n     // query and add the entry.\n     // This is done to avoid making the remote dynamo query part of the\n     // synchronized block.\n     // If a race does occur, the cost is simply one extra GET and potentially\n     // one extra PUT.\n     while (!parent.isRoot()) {\n       synchronized (ancestorState) {\n         if (ancestorState.contains(parent)) {\n           // the ancestry map contains the key, so no need to even look for it.\n           break;\n         }\n       }\n       // we don\u0027t worry about tombstone expiry here as expired or not,\n       // a directory entry will go in.\n       PathMetadata directory \u003d get(parent);\n       if (directory \u003d\u003d null || directory.isDeleted()) {\n         if (entryFound) {\n           LOG.warn(\"Inconsistent S3Guard table: adding directory {}\", parent);\n         }\n         S3AFileStatus status \u003d makeDirStatus(username, parent);\n         LOG.debug(\"Adding new ancestor entry {}\", status);\n         DDBPathMetadata meta \u003d new DDBPathMetadata(status, Tristate.FALSE,\n             false);\n         newDirs.add(meta);\n         // Do not update ancestor state here, as it\n         // will happen in the innerPut() call. Were we to add it\n         // here that put operation would actually (mistakenly) skip\n         // creating the entry.\n       } else {\n         // an entry was found. Check its type\n         entryFound \u003d true;\n         if (directory.getFileStatus().isFile()) {\n           throw new PathIOException(parent.toString(),\n-              \"Cannot overwrite parent file: metadatstore is\"\n+              \"Cannot overwrite parent file: metastore is\"\n                   + \" in an inconsistent state\");\n         }\n         // the directory exists. Add it to the ancestor state for next time.\n         synchronized (ancestorState) {\n           ancestorState.put(parent, new DDBPathMetadata(directory));\n         }\n       }\n       parent \u003d parent.getParent();\n     }\n     // the listing of directories to put is all those parents which we know\n     // are not in the store or BulkOperationState.\n     if (!newDirs.isEmpty()) {\n       // patch up the time.\n       patchLastUpdated(newDirs, ttlTimeProvider);\n       innerPut(newDirs, operationState, ttlTimeProvider);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void addAncestors(\n      final Path qualifiedPath,\n      final ITtlTimeProvider ttlTimeProvider,\n      @Nullable final BulkOperationState operationState) throws IOException {\n\n    Collection\u003cDDBPathMetadata\u003e newDirs \u003d new ArrayList\u003c\u003e();\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    Path parent \u003d qualifiedPath.getParent();\n    boolean entryFound \u003d false;\n\n    // Iterate up the parents.\n    // note that only ancestorState get/set operations are synchronized;\n    // the DDB read between them is not. As a result, more than one\n    // thread may probe the state, find the entry missing, do the database\n    // query and add the entry.\n    // This is done to avoid making the remote dynamo query part of the\n    // synchronized block.\n    // If a race does occur, the cost is simply one extra GET and potentially\n    // one extra PUT.\n    while (!parent.isRoot()) {\n      synchronized (ancestorState) {\n        if (ancestorState.contains(parent)) {\n          // the ancestry map contains the key, so no need to even look for it.\n          break;\n        }\n      }\n      // we don\u0027t worry about tombstone expiry here as expired or not,\n      // a directory entry will go in.\n      PathMetadata directory \u003d get(parent);\n      if (directory \u003d\u003d null || directory.isDeleted()) {\n        if (entryFound) {\n          LOG.warn(\"Inconsistent S3Guard table: adding directory {}\", parent);\n        }\n        S3AFileStatus status \u003d makeDirStatus(username, parent);\n        LOG.debug(\"Adding new ancestor entry {}\", status);\n        DDBPathMetadata meta \u003d new DDBPathMetadata(status, Tristate.FALSE,\n            false);\n        newDirs.add(meta);\n        // Do not update ancestor state here, as it\n        // will happen in the innerPut() call. Were we to add it\n        // here that put operation would actually (mistakenly) skip\n        // creating the entry.\n      } else {\n        // an entry was found. Check its type\n        entryFound \u003d true;\n        if (directory.getFileStatus().isFile()) {\n          throw new PathIOException(parent.toString(),\n              \"Cannot overwrite parent file: metastore is\"\n                  + \" in an inconsistent state\");\n        }\n        // the directory exists. Add it to the ancestor state for next time.\n        synchronized (ancestorState) {\n          ancestorState.put(parent, new DDBPathMetadata(directory));\n        }\n      }\n      parent \u003d parent.getParent();\n    }\n    // the listing of directories to put is all those parents which we know\n    // are not in the store or BulkOperationState.\n    if (!newDirs.isEmpty()) {\n      // patch up the time.\n      patchLastUpdated(newDirs, ttlTimeProvider);\n      innerPut(newDirs, operationState, ttlTimeProvider);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java",
      "extendedDetails": {}
    },
    "e02eb24e0a9139418120027b694492e0738df20a": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-15183. S3Guard store becomes inconsistent after partial failure of rename.\n\nContributed by Steve Loughran.\n\nChange-Id: I825b0bc36be960475d2d259b1cdab45ae1bb78eb\n",
      "commitDate": "20/06/19 1:56 AM",
      "commitName": "e02eb24e0a9139418120027b694492e0738df20a",
      "commitAuthor": "Steve Loughran",
      "diff": "@@ -0,0 +1,66 @@\n+  public void addAncestors(\n+      final Path qualifiedPath,\n+      final ITtlTimeProvider ttlTimeProvider,\n+      @Nullable final BulkOperationState operationState) throws IOException {\n+\n+    Collection\u003cDDBPathMetadata\u003e newDirs \u003d new ArrayList\u003c\u003e();\n+    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n+        BulkOperationState.OperationType.Rename);\n+    Path parent \u003d qualifiedPath.getParent();\n+    boolean entryFound \u003d false;\n+\n+    // Iterate up the parents.\n+    // note that only ancestorState get/set operations are synchronized;\n+    // the DDB read between them is not. As a result, more than one\n+    // thread may probe the state, find the entry missing, do the database\n+    // query and add the entry.\n+    // This is done to avoid making the remote dynamo query part of the\n+    // synchronized block.\n+    // If a race does occur, the cost is simply one extra GET and potentially\n+    // one extra PUT.\n+    while (!parent.isRoot()) {\n+      synchronized (ancestorState) {\n+        if (ancestorState.contains(parent)) {\n+          // the ancestry map contains the key, so no need to even look for it.\n+          break;\n+        }\n+      }\n+      // we don\u0027t worry about tombstone expiry here as expired or not,\n+      // a directory entry will go in.\n+      PathMetadata directory \u003d get(parent);\n+      if (directory \u003d\u003d null || directory.isDeleted()) {\n+        if (entryFound) {\n+          LOG.warn(\"Inconsistent S3Guard table: adding directory {}\", parent);\n+        }\n+        S3AFileStatus status \u003d makeDirStatus(username, parent);\n+        LOG.debug(\"Adding new ancestor entry {}\", status);\n+        DDBPathMetadata meta \u003d new DDBPathMetadata(status, Tristate.FALSE,\n+            false);\n+        newDirs.add(meta);\n+        // Do not update ancestor state here, as it\n+        // will happen in the innerPut() call. Were we to add it\n+        // here that put operation would actually (mistakenly) skip\n+        // creating the entry.\n+      } else {\n+        // an entry was found. Check its type\n+        entryFound \u003d true;\n+        if (directory.getFileStatus().isFile()) {\n+          throw new PathIOException(parent.toString(),\n+              \"Cannot overwrite parent file: metadatstore is\"\n+                  + \" in an inconsistent state\");\n+        }\n+        // the directory exists. Add it to the ancestor state for next time.\n+        synchronized (ancestorState) {\n+          ancestorState.put(parent, new DDBPathMetadata(directory));\n+        }\n+      }\n+      parent \u003d parent.getParent();\n+    }\n+    // the listing of directories to put is all those parents which we know\n+    // are not in the store or BulkOperationState.\n+    if (!newDirs.isEmpty()) {\n+      // patch up the time.\n+      patchLastUpdated(newDirs, ttlTimeProvider);\n+      innerPut(newDirs, operationState, ttlTimeProvider);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void addAncestors(\n      final Path qualifiedPath,\n      final ITtlTimeProvider ttlTimeProvider,\n      @Nullable final BulkOperationState operationState) throws IOException {\n\n    Collection\u003cDDBPathMetadata\u003e newDirs \u003d new ArrayList\u003c\u003e();\n    final AncestorState ancestorState \u003d extractOrCreate(operationState,\n        BulkOperationState.OperationType.Rename);\n    Path parent \u003d qualifiedPath.getParent();\n    boolean entryFound \u003d false;\n\n    // Iterate up the parents.\n    // note that only ancestorState get/set operations are synchronized;\n    // the DDB read between them is not. As a result, more than one\n    // thread may probe the state, find the entry missing, do the database\n    // query and add the entry.\n    // This is done to avoid making the remote dynamo query part of the\n    // synchronized block.\n    // If a race does occur, the cost is simply one extra GET and potentially\n    // one extra PUT.\n    while (!parent.isRoot()) {\n      synchronized (ancestorState) {\n        if (ancestorState.contains(parent)) {\n          // the ancestry map contains the key, so no need to even look for it.\n          break;\n        }\n      }\n      // we don\u0027t worry about tombstone expiry here as expired or not,\n      // a directory entry will go in.\n      PathMetadata directory \u003d get(parent);\n      if (directory \u003d\u003d null || directory.isDeleted()) {\n        if (entryFound) {\n          LOG.warn(\"Inconsistent S3Guard table: adding directory {}\", parent);\n        }\n        S3AFileStatus status \u003d makeDirStatus(username, parent);\n        LOG.debug(\"Adding new ancestor entry {}\", status);\n        DDBPathMetadata meta \u003d new DDBPathMetadata(status, Tristate.FALSE,\n            false);\n        newDirs.add(meta);\n        // Do not update ancestor state here, as it\n        // will happen in the innerPut() call. Were we to add it\n        // here that put operation would actually (mistakenly) skip\n        // creating the entry.\n      } else {\n        // an entry was found. Check its type\n        entryFound \u003d true;\n        if (directory.getFileStatus().isFile()) {\n          throw new PathIOException(parent.toString(),\n              \"Cannot overwrite parent file: metadatstore is\"\n                  + \" in an inconsistent state\");\n        }\n        // the directory exists. Add it to the ancestor state for next time.\n        synchronized (ancestorState) {\n          ancestorState.put(parent, new DDBPathMetadata(directory));\n        }\n      }\n      parent \u003d parent.getParent();\n    }\n    // the listing of directories to put is all those parents which we know\n    // are not in the store or BulkOperationState.\n    if (!newDirs.isEmpty()) {\n      // patch up the time.\n      patchLastUpdated(newDirs, ttlTimeProvider);\n      innerPut(newDirs, operationState, ttlTimeProvider);\n    }\n  }",
      "path": "hadoop-tools/hadoop-aws/src/main/java/org/apache/hadoop/fs/s3a/s3guard/DynamoDBMetadataStore.java"
    }
  }
}