{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FederationInterceptor.java",
  "functionName": "callback",
  "functionId": "callback___response-AllocateResponse",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
  "functionStartLine": 1693,
  "functionEndLine": 1752,
  "numCommitsSeen": 21,
  "timeTaken": 3442,
  "changeHistory": [
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
    "c3d22d3b4569b7f87af4ee4abfcc284deebe90de",
    "3090922805699b8374a359e92323884a4177dc4e",
    "f1525825623a1307b5aa55c456b6afa3e0c61135",
    "670e8d4ec7e71fc3b054cd3b2826f869b649a788",
    "d5f66888b8d767ee6706fab9950c194a1bf26d32",
    "70b1a757f13b01a9192ea5fb0820ba7babfd974e"
  ],
  "changeHistoryShort": {
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa": "Ybodychange",
    "c3d22d3b4569b7f87af4ee4abfcc284deebe90de": "Ybodychange",
    "3090922805699b8374a359e92323884a4177dc4e": "Ybodychange",
    "f1525825623a1307b5aa55c456b6afa3e0c61135": "Ybodychange",
    "670e8d4ec7e71fc3b054cd3b2826f869b649a788": "Ybodychange",
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": "Ybodychange",
    "70b1a757f13b01a9192ea5fb0820ba7babfd974e": "Yintroduced"
  },
  "changeHistoryDetails": {
    "b5ec85d96615e8214c14b57f8980a1dee6197ffa": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8933. [AMRMProxy] Fix potential empty fields in allocation response, move SubClusterTimeout to FederationInterceptor. Contributed by Botong Huang.\n",
      "commitDate": "11/11/18 11:12 AM",
      "commitName": "b5ec85d96615e8214c14b57f8980a1dee6197ffa",
      "commitAuthor": "Botong Huang",
      "commitDateOld": "02/11/18 3:30 PM",
      "commitNameOld": "989715ec5066c6ac7868e25ad9234dc64723e61e",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 8.86,
      "commitsBetweenForRepo": 50,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,60 @@\n     public void callback(AllocateResponse response) {\n       synchronized (asyncResponseSink) {\n         List\u003cAllocateResponse\u003e responses \u003d null;\n         if (asyncResponseSink.containsKey(subClusterId)) {\n           responses \u003d asyncResponseSink.get(subClusterId);\n         } else {\n           responses \u003d new ArrayList\u003c\u003e();\n           asyncResponseSink.put(subClusterId, responses);\n         }\n         responses.add(response);\n         // Notify main thread about the response arrival\n         asyncResponseSink.notifyAll();\n       }\n+      lastSCResponse.put(subClusterId, response);\n+      lastSCResponseTime.put(subClusterId, clock.getTime());\n \n       // Notify policy of allocate response\n       try {\n         policyInterpreter.notifyOfResponse(subClusterId, response);\n       } catch (YarnException e) {\n         LOG.warn(\"notifyOfResponse for policy failed for sub-cluster \"\n             + subClusterId, e);\n       }\n \n       // Save the new AMRMToken for the UAM if present\n       // Do this last because it can be slow...\n       if (this.isUAM \u0026\u0026 response.getAMRMToken() !\u003d null) {\n         Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n             .convertFromYarn(response.getAMRMToken(), (Text) null);\n         // Do not further propagate the new amrmToken for UAM\n         response.setAMRMToken(null);\n \n         // Update the token in registry or NMSS\n         if (registryClient !\u003d null) {\n           if (registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n               subClusterId.getId(), newToken)) {\n             try {\n               AMRMTokenIdentifier identifier \u003d new AMRMTokenIdentifier();\n               identifier.readFields(new DataInputStream(\n                   new ByteArrayInputStream(newToken.getIdentifier())));\n               LOG.info(\n                   \"Received new UAM amrmToken with keyId {} and \"\n                       + \"service {} from {} for {}, written to Registry\",\n                   identifier.getKeyId(), newToken.getService(), subClusterId,\n                   attemptId);\n             } catch (IOException e) {\n             }\n           }\n         } else if (getNMStateStore() !\u003d null) {\n           try {\n             getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                 NMSS_SECONDARY_SC_PREFIX + subClusterId.getId(),\n                 newToken.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n           } catch (IOException e) {\n             LOG.error(\"Error storing UAM token as AMRMProxy \"\n                 + \"context entry in NMSS for \" + attemptId, e);\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void callback(AllocateResponse response) {\n      synchronized (asyncResponseSink) {\n        List\u003cAllocateResponse\u003e responses \u003d null;\n        if (asyncResponseSink.containsKey(subClusterId)) {\n          responses \u003d asyncResponseSink.get(subClusterId);\n        } else {\n          responses \u003d new ArrayList\u003c\u003e();\n          asyncResponseSink.put(subClusterId, responses);\n        }\n        responses.add(response);\n        // Notify main thread about the response arrival\n        asyncResponseSink.notifyAll();\n      }\n      lastSCResponse.put(subClusterId, response);\n      lastSCResponseTime.put(subClusterId, clock.getTime());\n\n      // Notify policy of allocate response\n      try {\n        policyInterpreter.notifyOfResponse(subClusterId, response);\n      } catch (YarnException e) {\n        LOG.warn(\"notifyOfResponse for policy failed for sub-cluster \"\n            + subClusterId, e);\n      }\n\n      // Save the new AMRMToken for the UAM if present\n      // Do this last because it can be slow...\n      if (this.isUAM \u0026\u0026 response.getAMRMToken() !\u003d null) {\n        Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n            .convertFromYarn(response.getAMRMToken(), (Text) null);\n        // Do not further propagate the new amrmToken for UAM\n        response.setAMRMToken(null);\n\n        // Update the token in registry or NMSS\n        if (registryClient !\u003d null) {\n          if (registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n              subClusterId.getId(), newToken)) {\n            try {\n              AMRMTokenIdentifier identifier \u003d new AMRMTokenIdentifier();\n              identifier.readFields(new DataInputStream(\n                  new ByteArrayInputStream(newToken.getIdentifier())));\n              LOG.info(\n                  \"Received new UAM amrmToken with keyId {} and \"\n                      + \"service {} from {} for {}, written to Registry\",\n                  identifier.getKeyId(), newToken.getService(), subClusterId,\n                  attemptId);\n            } catch (IOException e) {\n            }\n          }\n        } else if (getNMStateStore() !\u003d null) {\n          try {\n            getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                NMSS_SECONDARY_SC_PREFIX + subClusterId.getId(),\n                newToken.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n          } catch (IOException e) {\n            LOG.error(\"Error storing UAM token as AMRMProxy \"\n                + \"context entry in NMSS for \" + attemptId, e);\n          }\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "c3d22d3b4569b7f87af4ee4abfcc284deebe90de": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7652. Handle AM register requests asynchronously in FederationInterceptor. Contributed by Botong Huang.\n",
      "commitDate": "09/10/18 10:29 AM",
      "commitName": "c3d22d3b4569b7f87af4ee4abfcc284deebe90de",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "01/10/18 1:12 PM",
      "commitNameOld": "59d5af21b7a8f52e8c89cbc2d25fe3d449b2657a",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 7.89,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,58 @@\n     public void callback(AllocateResponse response) {\n       synchronized (asyncResponseSink) {\n         List\u003cAllocateResponse\u003e responses \u003d null;\n         if (asyncResponseSink.containsKey(subClusterId)) {\n           responses \u003d asyncResponseSink.get(subClusterId);\n         } else {\n           responses \u003d new ArrayList\u003c\u003e();\n           asyncResponseSink.put(subClusterId, responses);\n         }\n         responses.add(response);\n         // Notify main thread about the response arrival\n         asyncResponseSink.notifyAll();\n       }\n \n+      // Notify policy of allocate response\n+      try {\n+        policyInterpreter.notifyOfResponse(subClusterId, response);\n+      } catch (YarnException e) {\n+        LOG.warn(\"notifyOfResponse for policy failed for sub-cluster \"\n+            + subClusterId, e);\n+      }\n+\n       // Save the new AMRMToken for the UAM if present\n+      // Do this last because it can be slow...\n       if (this.isUAM \u0026\u0026 response.getAMRMToken() !\u003d null) {\n         Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n             .convertFromYarn(response.getAMRMToken(), (Text) null);\n         // Do not further propagate the new amrmToken for UAM\n         response.setAMRMToken(null);\n \n         // Update the token in registry or NMSS\n         if (registryClient !\u003d null) {\n           if (registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n               subClusterId.getId(), newToken)) {\n             try {\n               AMRMTokenIdentifier identifier \u003d new AMRMTokenIdentifier();\n               identifier.readFields(new DataInputStream(\n                   new ByteArrayInputStream(newToken.getIdentifier())));\n               LOG.info(\n                   \"Received new UAM amrmToken with keyId {} and \"\n                       + \"service {} from {} for {}, written to Registry\",\n                   identifier.getKeyId(), newToken.getService(), subClusterId,\n                   attemptId);\n             } catch (IOException e) {\n             }\n           }\n         } else if (getNMStateStore() !\u003d null) {\n           try {\n             getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                 NMSS_SECONDARY_SC_PREFIX + subClusterId.getId(),\n                 newToken.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n           } catch (IOException e) {\n             LOG.error(\"Error storing UAM token as AMRMProxy \"\n                 + \"context entry in NMSS for \" + attemptId, e);\n           }\n         }\n       }\n-\n-      // Notify policy of allocate response\n-      try {\n-        policyInterpreter.notifyOfResponse(subClusterId, response);\n-      } catch (YarnException e) {\n-        LOG.warn(\"notifyOfResponse for policy failed for sub-cluster \"\n-            + subClusterId, e);\n-      }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void callback(AllocateResponse response) {\n      synchronized (asyncResponseSink) {\n        List\u003cAllocateResponse\u003e responses \u003d null;\n        if (asyncResponseSink.containsKey(subClusterId)) {\n          responses \u003d asyncResponseSink.get(subClusterId);\n        } else {\n          responses \u003d new ArrayList\u003c\u003e();\n          asyncResponseSink.put(subClusterId, responses);\n        }\n        responses.add(response);\n        // Notify main thread about the response arrival\n        asyncResponseSink.notifyAll();\n      }\n\n      // Notify policy of allocate response\n      try {\n        policyInterpreter.notifyOfResponse(subClusterId, response);\n      } catch (YarnException e) {\n        LOG.warn(\"notifyOfResponse for policy failed for sub-cluster \"\n            + subClusterId, e);\n      }\n\n      // Save the new AMRMToken for the UAM if present\n      // Do this last because it can be slow...\n      if (this.isUAM \u0026\u0026 response.getAMRMToken() !\u003d null) {\n        Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n            .convertFromYarn(response.getAMRMToken(), (Text) null);\n        // Do not further propagate the new amrmToken for UAM\n        response.setAMRMToken(null);\n\n        // Update the token in registry or NMSS\n        if (registryClient !\u003d null) {\n          if (registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n              subClusterId.getId(), newToken)) {\n            try {\n              AMRMTokenIdentifier identifier \u003d new AMRMTokenIdentifier();\n              identifier.readFields(new DataInputStream(\n                  new ByteArrayInputStream(newToken.getIdentifier())));\n              LOG.info(\n                  \"Received new UAM amrmToken with keyId {} and \"\n                      + \"service {} from {} for {}, written to Registry\",\n                  identifier.getKeyId(), newToken.getService(), subClusterId,\n                  attemptId);\n            } catch (IOException e) {\n            }\n          }\n        } else if (getNMStateStore() !\u003d null) {\n          try {\n            getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                NMSS_SECONDARY_SC_PREFIX + subClusterId.getId(),\n                newToken.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n          } catch (IOException e) {\n            LOG.error(\"Error storing UAM token as AMRMProxy \"\n                + \"context entry in NMSS for \" + attemptId, e);\n          }\n        }\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "3090922805699b8374a359e92323884a4177dc4e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8696. [AMRMProxy] FederationInterceptor upgrade: home sub-cluster heartbeat async. Contributed by Botong Huang.\n",
      "commitDate": "24/09/18 11:37 AM",
      "commitName": "3090922805699b8374a359e92323884a4177dc4e",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "12/09/18 11:46 AM",
      "commitNameOld": "02b9bfdf9e4bd0b3c05ca5fd75399dedcb656e09",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 11.99,
      "commitsBetweenForRepo": 142,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,57 @@\n     public void callback(AllocateResponse response) {\n       synchronized (asyncResponseSink) {\n         List\u003cAllocateResponse\u003e responses \u003d null;\n         if (asyncResponseSink.containsKey(subClusterId)) {\n           responses \u003d asyncResponseSink.get(subClusterId);\n         } else {\n           responses \u003d new ArrayList\u003c\u003e();\n           asyncResponseSink.put(subClusterId, responses);\n         }\n         responses.add(response);\n+        // Notify main thread about the response arrival\n+        asyncResponseSink.notifyAll();\n       }\n \n       // Save the new AMRMToken for the UAM if present\n-      if (response.getAMRMToken() !\u003d null) {\n+      if (this.isUAM \u0026\u0026 response.getAMRMToken() !\u003d null) {\n         Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n             .convertFromYarn(response.getAMRMToken(), (Text) null);\n+        // Do not further propagate the new amrmToken for UAM\n+        response.setAMRMToken(null);\n+\n         // Update the token in registry or NMSS\n         if (registryClient !\u003d null) {\n-          registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n-              subClusterId.getId(), newToken);\n+          if (registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n+              subClusterId.getId(), newToken)) {\n+            try {\n+              AMRMTokenIdentifier identifier \u003d new AMRMTokenIdentifier();\n+              identifier.readFields(new DataInputStream(\n+                  new ByteArrayInputStream(newToken.getIdentifier())));\n+              LOG.info(\n+                  \"Received new UAM amrmToken with keyId {} and \"\n+                      + \"service {} from {} for {}, written to Registry\",\n+                  identifier.getKeyId(), newToken.getService(), subClusterId,\n+                  attemptId);\n+            } catch (IOException e) {\n+            }\n+          }\n         } else if (getNMStateStore() !\u003d null) {\n           try {\n             getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                 NMSS_SECONDARY_SC_PREFIX + subClusterId.getId(),\n                 newToken.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n           } catch (IOException e) {\n             LOG.error(\"Error storing UAM token as AMRMProxy \"\n                 + \"context entry in NMSS for \" + attemptId, e);\n           }\n         }\n       }\n \n-      // Notify policy of secondary sub-cluster responses\n+      // Notify policy of allocate response\n       try {\n         policyInterpreter.notifyOfResponse(subClusterId, response);\n       } catch (YarnException e) {\n-        LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n+        LOG.warn(\"notifyOfResponse for policy failed for sub-cluster \"\n             + subClusterId, e);\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void callback(AllocateResponse response) {\n      synchronized (asyncResponseSink) {\n        List\u003cAllocateResponse\u003e responses \u003d null;\n        if (asyncResponseSink.containsKey(subClusterId)) {\n          responses \u003d asyncResponseSink.get(subClusterId);\n        } else {\n          responses \u003d new ArrayList\u003c\u003e();\n          asyncResponseSink.put(subClusterId, responses);\n        }\n        responses.add(response);\n        // Notify main thread about the response arrival\n        asyncResponseSink.notifyAll();\n      }\n\n      // Save the new AMRMToken for the UAM if present\n      if (this.isUAM \u0026\u0026 response.getAMRMToken() !\u003d null) {\n        Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n            .convertFromYarn(response.getAMRMToken(), (Text) null);\n        // Do not further propagate the new amrmToken for UAM\n        response.setAMRMToken(null);\n\n        // Update the token in registry or NMSS\n        if (registryClient !\u003d null) {\n          if (registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n              subClusterId.getId(), newToken)) {\n            try {\n              AMRMTokenIdentifier identifier \u003d new AMRMTokenIdentifier();\n              identifier.readFields(new DataInputStream(\n                  new ByteArrayInputStream(newToken.getIdentifier())));\n              LOG.info(\n                  \"Received new UAM amrmToken with keyId {} and \"\n                      + \"service {} from {} for {}, written to Registry\",\n                  identifier.getKeyId(), newToken.getService(), subClusterId,\n                  attemptId);\n            } catch (IOException e) {\n            }\n          }\n        } else if (getNMStateStore() !\u003d null) {\n          try {\n            getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                NMSS_SECONDARY_SC_PREFIX + subClusterId.getId(),\n                newToken.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n          } catch (IOException e) {\n            LOG.error(\"Error storing UAM token as AMRMProxy \"\n                + \"context entry in NMSS for \" + attemptId, e);\n          }\n        }\n      }\n\n      // Notify policy of allocate response\n      try {\n        policyInterpreter.notifyOfResponse(subClusterId, response);\n      } catch (YarnException e) {\n        LOG.warn(\"notifyOfResponse for policy failed for sub-cluster \"\n            + subClusterId, e);\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "f1525825623a1307b5aa55c456b6afa3e0c61135": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8705. Refactor the UAM heartbeat thread in preparation for YARN-8696. Contributed by Botong Huang.\n",
      "commitDate": "27/08/18 10:32 AM",
      "commitName": "f1525825623a1307b5aa55c456b6afa3e0c61135",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "20/08/18 12:22 PM",
      "commitNameOld": "8736fc39ac3b3de168d2c216f3d1c0edb48fb3f9",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 6.92,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,50 +1,40 @@\n-            public void callback(AllocateResponse response) {\n-              synchronized (asyncResponseSink) {\n-                List\u003cAllocateResponse\u003e responses \u003d null;\n-                if (asyncResponseSink.containsKey(subClusterId)) {\n-                  responses \u003d asyncResponseSink.get(subClusterId);\n-                } else {\n-                  responses \u003d new ArrayList\u003c\u003e();\n-                  asyncResponseSink.put(subClusterId, responses);\n-                }\n-                responses.add(response);\n-              }\n+    public void callback(AllocateResponse response) {\n+      synchronized (asyncResponseSink) {\n+        List\u003cAllocateResponse\u003e responses \u003d null;\n+        if (asyncResponseSink.containsKey(subClusterId)) {\n+          responses \u003d asyncResponseSink.get(subClusterId);\n+        } else {\n+          responses \u003d new ArrayList\u003c\u003e();\n+          asyncResponseSink.put(subClusterId, responses);\n+        }\n+        responses.add(response);\n+      }\n \n-              // Save the new AMRMToken for the UAM if present\n-              if (response.getAMRMToken() !\u003d null) {\n-                Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n-                    .convertFromYarn(response.getAMRMToken(), (Text) null);\n-                // Update the token in registry or NMSS\n-                if (registryClient !\u003d null) {\n-                  registryClient\n-                      .writeAMRMTokenForUAM(\n-                          getApplicationContext().getApplicationAttemptId()\n-                              .getApplicationId(),\n-                          subClusterId.getId(), newToken);\n-                } else if (getNMStateStore() !\u003d null) {\n-                  try {\n-                    getNMStateStore().storeAMRMProxyAppContextEntry(\n-                        getApplicationContext().getApplicationAttemptId(),\n-                        NMSS_SECONDARY_SC_PREFIX + subClusterId.getId(),\n-                        newToken.encodeToUrlString()\n-                            .getBytes(STRING_TO_BYTE_FORMAT));\n-                  } catch (IOException e) {\n-                    LOG.error(\n-                        \"Error storing UAM token as AMRMProxy \"\n-                            + \"context entry in NMSS for \"\n-                            + getApplicationContext().getApplicationAttemptId(),\n-                        e);\n-                  }\n-                }\n-              }\n+      // Save the new AMRMToken for the UAM if present\n+      if (response.getAMRMToken() !\u003d null) {\n+        Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n+            .convertFromYarn(response.getAMRMToken(), (Text) null);\n+        // Update the token in registry or NMSS\n+        if (registryClient !\u003d null) {\n+          registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n+              subClusterId.getId(), newToken);\n+        } else if (getNMStateStore() !\u003d null) {\n+          try {\n+            getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n+                NMSS_SECONDARY_SC_PREFIX + subClusterId.getId(),\n+                newToken.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n+          } catch (IOException e) {\n+            LOG.error(\"Error storing UAM token as AMRMProxy \"\n+                + \"context entry in NMSS for \" + attemptId, e);\n+          }\n+        }\n+      }\n \n-              // Notify policy of secondary sub-cluster responses\n-              try {\n-                policyInterpreter.notifyOfResponse(subClusterId, response);\n-              } catch (YarnException e) {\n-                LOG.warn(\n-                    \"notifyOfResponse for policy failed for home sub-cluster \"\n-                        + subClusterId,\n-                    e);\n-              }\n-            }\n\\ No newline at end of file\n+      // Notify policy of secondary sub-cluster responses\n+      try {\n+        policyInterpreter.notifyOfResponse(subClusterId, response);\n+      } catch (YarnException e) {\n+        LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n+            + subClusterId, e);\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void callback(AllocateResponse response) {\n      synchronized (asyncResponseSink) {\n        List\u003cAllocateResponse\u003e responses \u003d null;\n        if (asyncResponseSink.containsKey(subClusterId)) {\n          responses \u003d asyncResponseSink.get(subClusterId);\n        } else {\n          responses \u003d new ArrayList\u003c\u003e();\n          asyncResponseSink.put(subClusterId, responses);\n        }\n        responses.add(response);\n      }\n\n      // Save the new AMRMToken for the UAM if present\n      if (response.getAMRMToken() !\u003d null) {\n        Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n            .convertFromYarn(response.getAMRMToken(), (Text) null);\n        // Update the token in registry or NMSS\n        if (registryClient !\u003d null) {\n          registryClient.writeAMRMTokenForUAM(attemptId.getApplicationId(),\n              subClusterId.getId(), newToken);\n        } else if (getNMStateStore() !\u003d null) {\n          try {\n            getNMStateStore().storeAMRMProxyAppContextEntry(attemptId,\n                NMSS_SECONDARY_SC_PREFIX + subClusterId.getId(),\n                newToken.encodeToUrlString().getBytes(STRING_TO_BYTE_FORMAT));\n          } catch (IOException e) {\n            LOG.error(\"Error storing UAM token as AMRMProxy \"\n                + \"context entry in NMSS for \" + attemptId, e);\n          }\n        }\n      }\n\n      // Notify policy of secondary sub-cluster responses\n      try {\n        policyInterpreter.notifyOfResponse(subClusterId, response);\n      } catch (YarnException e) {\n        LOG.warn(\"notifyOfResponse for policy failed for home sub-cluster \"\n            + subClusterId, e);\n      }\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "670e8d4ec7e71fc3b054cd3b2826f869b649a788": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6704. Add support for work preserving NM restart when FederationInterceptor is enabled in AMRMProxyService. (Botong Huang via Subru).\n",
      "commitDate": "08/12/17 3:39 PM",
      "commitName": "670e8d4ec7e71fc3b054cd3b2826f869b649a788",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "17/11/17 5:39 PM",
      "commitNameOld": "d5f66888b8d767ee6706fab9950c194a1bf26d32",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 20.92,
      "commitsBetweenForRepo": 111,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,36 +1,50 @@\n             public void callback(AllocateResponse response) {\n               synchronized (asyncResponseSink) {\n                 List\u003cAllocateResponse\u003e responses \u003d null;\n                 if (asyncResponseSink.containsKey(subClusterId)) {\n                   responses \u003d asyncResponseSink.get(subClusterId);\n                 } else {\n                   responses \u003d new ArrayList\u003c\u003e();\n                   asyncResponseSink.put(subClusterId, responses);\n                 }\n                 responses.add(response);\n               }\n \n-              // Save the new AMRMToken for the UAM in registry if present\n+              // Save the new AMRMToken for the UAM if present\n               if (response.getAMRMToken() !\u003d null) {\n                 Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n                     .convertFromYarn(response.getAMRMToken(), (Text) null);\n-                // Update the token in registry\n+                // Update the token in registry or NMSS\n                 if (registryClient !\u003d null) {\n                   registryClient\n                       .writeAMRMTokenForUAM(\n                           getApplicationContext().getApplicationAttemptId()\n                               .getApplicationId(),\n                           subClusterId.getId(), newToken);\n+                } else if (getNMStateStore() !\u003d null) {\n+                  try {\n+                    getNMStateStore().storeAMRMProxyAppContextEntry(\n+                        getApplicationContext().getApplicationAttemptId(),\n+                        NMSS_SECONDARY_SC_PREFIX + subClusterId.getId(),\n+                        newToken.encodeToUrlString()\n+                            .getBytes(STRING_TO_BYTE_FORMAT));\n+                  } catch (IOException e) {\n+                    LOG.error(\n+                        \"Error storing UAM token as AMRMProxy \"\n+                            + \"context entry in NMSS for \"\n+                            + getApplicationContext().getApplicationAttemptId(),\n+                        e);\n+                  }\n                 }\n               }\n \n               // Notify policy of secondary sub-cluster responses\n               try {\n                 policyInterpreter.notifyOfResponse(subClusterId, response);\n               } catch (YarnException e) {\n                 LOG.warn(\n                     \"notifyOfResponse for policy failed for home sub-cluster \"\n                         + subClusterId,\n                     e);\n               }\n             }\n\\ No newline at end of file\n",
      "actualSource": "            public void callback(AllocateResponse response) {\n              synchronized (asyncResponseSink) {\n                List\u003cAllocateResponse\u003e responses \u003d null;\n                if (asyncResponseSink.containsKey(subClusterId)) {\n                  responses \u003d asyncResponseSink.get(subClusterId);\n                } else {\n                  responses \u003d new ArrayList\u003c\u003e();\n                  asyncResponseSink.put(subClusterId, responses);\n                }\n                responses.add(response);\n              }\n\n              // Save the new AMRMToken for the UAM if present\n              if (response.getAMRMToken() !\u003d null) {\n                Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n                    .convertFromYarn(response.getAMRMToken(), (Text) null);\n                // Update the token in registry or NMSS\n                if (registryClient !\u003d null) {\n                  registryClient\n                      .writeAMRMTokenForUAM(\n                          getApplicationContext().getApplicationAttemptId()\n                              .getApplicationId(),\n                          subClusterId.getId(), newToken);\n                } else if (getNMStateStore() !\u003d null) {\n                  try {\n                    getNMStateStore().storeAMRMProxyAppContextEntry(\n                        getApplicationContext().getApplicationAttemptId(),\n                        NMSS_SECONDARY_SC_PREFIX + subClusterId.getId(),\n                        newToken.encodeToUrlString()\n                            .getBytes(STRING_TO_BYTE_FORMAT));\n                  } catch (IOException e) {\n                    LOG.error(\n                        \"Error storing UAM token as AMRMProxy \"\n                            + \"context entry in NMSS for \"\n                            + getApplicationContext().getApplicationAttemptId(),\n                        e);\n                  }\n                }\n              }\n\n              // Notify policy of secondary sub-cluster responses\n              try {\n                policyInterpreter.notifyOfResponse(subClusterId, response);\n              } catch (YarnException e) {\n                LOG.warn(\n                    \"notifyOfResponse for policy failed for home sub-cluster \"\n                        + subClusterId,\n                    e);\n              }\n            }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "d5f66888b8d767ee6706fab9950c194a1bf26d32": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6128. Add support for AMRMProxy HA. (Botong Huang via Subru).\n",
      "commitDate": "17/11/17 5:39 PM",
      "commitName": "d5f66888b8d767ee6706fab9950c194a1bf26d32",
      "commitAuthor": "Subru Krishnan",
      "commitDateOld": "28/09/17 1:04 PM",
      "commitNameOld": "ca669f9f8bc7abe5b7d4648c589aa1756bd336d1",
      "commitAuthorOld": "Subru Krishnan",
      "daysBetweenCommits": 50.23,
      "commitsBetweenForRepo": 444,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,36 @@\n             public void callback(AllocateResponse response) {\n               synchronized (asyncResponseSink) {\n                 List\u003cAllocateResponse\u003e responses \u003d null;\n                 if (asyncResponseSink.containsKey(subClusterId)) {\n                   responses \u003d asyncResponseSink.get(subClusterId);\n                 } else {\n                   responses \u003d new ArrayList\u003c\u003e();\n                   asyncResponseSink.put(subClusterId, responses);\n                 }\n                 responses.add(response);\n               }\n \n+              // Save the new AMRMToken for the UAM in registry if present\n+              if (response.getAMRMToken() !\u003d null) {\n+                Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n+                    .convertFromYarn(response.getAMRMToken(), (Text) null);\n+                // Update the token in registry\n+                if (registryClient !\u003d null) {\n+                  registryClient\n+                      .writeAMRMTokenForUAM(\n+                          getApplicationContext().getApplicationAttemptId()\n+                              .getApplicationId(),\n+                          subClusterId.getId(), newToken);\n+                }\n+              }\n+\n               // Notify policy of secondary sub-cluster responses\n               try {\n                 policyInterpreter.notifyOfResponse(subClusterId, response);\n               } catch (YarnException e) {\n                 LOG.warn(\n                     \"notifyOfResponse for policy failed for home sub-cluster \"\n                         + subClusterId,\n                     e);\n               }\n             }\n\\ No newline at end of file\n",
      "actualSource": "            public void callback(AllocateResponse response) {\n              synchronized (asyncResponseSink) {\n                List\u003cAllocateResponse\u003e responses \u003d null;\n                if (asyncResponseSink.containsKey(subClusterId)) {\n                  responses \u003d asyncResponseSink.get(subClusterId);\n                } else {\n                  responses \u003d new ArrayList\u003c\u003e();\n                  asyncResponseSink.put(subClusterId, responses);\n                }\n                responses.add(response);\n              }\n\n              // Save the new AMRMToken for the UAM in registry if present\n              if (response.getAMRMToken() !\u003d null) {\n                Token\u003cAMRMTokenIdentifier\u003e newToken \u003d ConverterUtils\n                    .convertFromYarn(response.getAMRMToken(), (Text) null);\n                // Update the token in registry\n                if (registryClient !\u003d null) {\n                  registryClient\n                      .writeAMRMTokenForUAM(\n                          getApplicationContext().getApplicationAttemptId()\n                              .getApplicationId(),\n                          subClusterId.getId(), newToken);\n                }\n              }\n\n              // Notify policy of secondary sub-cluster responses\n              try {\n                policyInterpreter.notifyOfResponse(subClusterId, response);\n              } catch (YarnException e) {\n                LOG.warn(\n                    \"notifyOfResponse for policy failed for home sub-cluster \"\n                        + subClusterId,\n                    e);\n              }\n            }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java",
      "extendedDetails": {}
    },
    "70b1a757f13b01a9192ea5fb0820ba7babfd974e": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6511. Federation: transparently spanning application across multiple sub-clusters. (Botong Huang via Subru).\n\n(cherry picked from commit 8c988d235eaf0972783985b1ab24680d029aea79)\n",
      "commitDate": "01/08/17 5:28 PM",
      "commitName": "70b1a757f13b01a9192ea5fb0820ba7babfd974e",
      "commitAuthor": "Subru Krishnan",
      "diff": "@@ -0,0 +1,22 @@\n+            public void callback(AllocateResponse response) {\n+              synchronized (asyncResponseSink) {\n+                List\u003cAllocateResponse\u003e responses \u003d null;\n+                if (asyncResponseSink.containsKey(subClusterId)) {\n+                  responses \u003d asyncResponseSink.get(subClusterId);\n+                } else {\n+                  responses \u003d new ArrayList\u003c\u003e();\n+                  asyncResponseSink.put(subClusterId, responses);\n+                }\n+                responses.add(response);\n+              }\n+\n+              // Notify policy of secondary sub-cluster responses\n+              try {\n+                policyInterpreter.notifyOfResponse(subClusterId, response);\n+              } catch (YarnException e) {\n+                LOG.warn(\n+                    \"notifyOfResponse for policy failed for home sub-cluster \"\n+                        + subClusterId,\n+                    e);\n+              }\n+            }\n\\ No newline at end of file\n",
      "actualSource": "            public void callback(AllocateResponse response) {\n              synchronized (asyncResponseSink) {\n                List\u003cAllocateResponse\u003e responses \u003d null;\n                if (asyncResponseSink.containsKey(subClusterId)) {\n                  responses \u003d asyncResponseSink.get(subClusterId);\n                } else {\n                  responses \u003d new ArrayList\u003c\u003e();\n                  asyncResponseSink.put(subClusterId, responses);\n                }\n                responses.add(response);\n              }\n\n              // Notify policy of secondary sub-cluster responses\n              try {\n                policyInterpreter.notifyOfResponse(subClusterId, response);\n              } catch (YarnException e) {\n                LOG.warn(\n                    \"notifyOfResponse for policy failed for home sub-cluster \"\n                        + subClusterId,\n                    e);\n              }\n            }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/amrmproxy/FederationInterceptor.java"
    }
  }
}