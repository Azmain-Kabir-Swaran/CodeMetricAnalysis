{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "LoadBalancingKMSClientProvider.java",
  "functionName": "doOp",
  "functionId": "doOp___op-ProviderCallable__T____currPos-int__isIdempotent-boolean",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/LoadBalancingKMSClientProvider.java",
  "functionStartLine": 166,
  "functionEndLine": 233,
  "numCommitsSeen": 31,
  "timeTaken": 4153,
  "changeHistory": [
    "edeb2a356ad671d962764c6e2aee9f9e7d6f394c",
    "81d59506e539673edde12e19c0df5c2edd9d02ad",
    "993ec026d10c7566fd358c022c061bca118c92f0",
    "25f31d9fc47d21ac2f3afd7042e2ced1b849da39",
    "fa6cc43edd3f6e886a40b90b062c9f16189c50d1",
    "0a6d5c0cf1d963da9131aa12326fc576f0e92d2c",
    "a1f6564d31c16582ea949e4448091f1cc56c7dfe",
    "71385f9b70e22618db3f3d2b2c6dca3b1e82c317"
  ],
  "changeHistoryShort": {
    "edeb2a356ad671d962764c6e2aee9f9e7d6f394c": "Ymultichange(Yparameterchange,Ybodychange)",
    "81d59506e539673edde12e19c0df5c2edd9d02ad": "Ybodychange",
    "993ec026d10c7566fd358c022c061bca118c92f0": "Ybodychange",
    "25f31d9fc47d21ac2f3afd7042e2ced1b849da39": "Ybodychange",
    "fa6cc43edd3f6e886a40b90b062c9f16189c50d1": "Ybodychange",
    "0a6d5c0cf1d963da9131aa12326fc576f0e92d2c": "Ybodychange",
    "a1f6564d31c16582ea949e4448091f1cc56c7dfe": "Ybodychange",
    "71385f9b70e22618db3f3d2b2c6dca3b1e82c317": "Yintroduced"
  },
  "changeHistoryDetails": {
    "edeb2a356ad671d962764c6e2aee9f9e7d6f394c": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HADOOP-15655. Enhance KMS client retry behavior. Contributed by Kitti Nanasi.\n",
      "commitDate": "16/08/18 10:42 PM",
      "commitName": "edeb2a356ad671d962764c6e2aee9f9e7d6f394c",
      "commitAuthor": "Xiao Chen",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HADOOP-15655. Enhance KMS client retry behavior. Contributed by Kitti Nanasi.\n",
          "commitDate": "16/08/18 10:42 PM",
          "commitName": "edeb2a356ad671d962764c6e2aee9f9e7d6f394c",
          "commitAuthor": "Xiao Chen",
          "commitDateOld": "24/07/18 9:45 PM",
          "commitNameOld": "81d59506e539673edde12e19c0df5c2edd9d02ad",
          "commitAuthorOld": "Xiao Chen",
          "daysBetweenCommits": 23.04,
          "commitsBetweenForRepo": 220,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,68 @@\n-  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n-      throws IOException {\n+  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos,\n+      boolean isIdempotent) throws IOException {\n     if (providers.length \u003d\u003d 0) {\n       throw new IOException(\"No providers configured !\");\n     }\n     int numFailovers \u003d 0;\n     for (int i \u003d 0;; i++, numFailovers++) {\n       KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n       try {\n         return op.call(provider);\n       } catch (AccessControlException ace) {\n         // No need to retry on AccessControlException\n         // and AuthorizationException.\n         // This assumes all the servers are configured with identical\n         // permissions and identical key acls.\n         throw ace;\n       } catch (IOException ioe) {\n         LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n             provider.getKMSUrl(), ioe);\n         // SSLHandshakeException can occur here because of lost connection\n         // with the KMS server, creating a ConnectException from it,\n         // so that the FailoverOnNetworkExceptionRetry policy will retry\n         if (ioe instanceof SSLHandshakeException) {\n           Exception cause \u003d ioe;\n           ioe \u003d new ConnectException(\"SSLHandshakeException: \"\n               + cause.getMessage());\n           ioe.initCause(cause);\n         }\n         RetryAction action \u003d null;\n         try {\n-          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, false);\n+          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, isIdempotent);\n         } catch (Exception e) {\n           if (e instanceof IOException) {\n             throw (IOException)e;\n           }\n           throw new IOException(e);\n         }\n         // make sure each provider is tried at least once, to keep behavior\n         // compatible with earlier versions of LBKMSCP\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL\n             \u0026\u0026 numFailovers \u003e\u003d providers.length - 1) {\n           LOG.error(\"Aborting since the Request has failed with all KMS\"\n               + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n               + \" in the group OR the exception is not recoverable\",\n               CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n               getConf().getInt(\n                   CommonConfigurationKeysPublic.\n                   KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n               providers.length);\n           throw ioe;\n         }\n         if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n           // Sleep only after we try all the providers for every cycle.\n           try {\n             Thread.sleep(action.delayMillis);\n           } catch (InterruptedException e) {\n             throw new InterruptedIOException(\"Thread Interrupted\");\n           }\n         }\n       } catch (Exception e) {\n         if (e instanceof RuntimeException) {\n           throw (RuntimeException)e;\n         } else {\n           throw new WrapperException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos,\n      boolean isIdempotent) throws IOException {\n    if (providers.length \u003d\u003d 0) {\n      throw new IOException(\"No providers configured !\");\n    }\n    int numFailovers \u003d 0;\n    for (int i \u003d 0;; i++, numFailovers++) {\n      KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n      try {\n        return op.call(provider);\n      } catch (AccessControlException ace) {\n        // No need to retry on AccessControlException\n        // and AuthorizationException.\n        // This assumes all the servers are configured with identical\n        // permissions and identical key acls.\n        throw ace;\n      } catch (IOException ioe) {\n        LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n            provider.getKMSUrl(), ioe);\n        // SSLHandshakeException can occur here because of lost connection\n        // with the KMS server, creating a ConnectException from it,\n        // so that the FailoverOnNetworkExceptionRetry policy will retry\n        if (ioe instanceof SSLHandshakeException) {\n          Exception cause \u003d ioe;\n          ioe \u003d new ConnectException(\"SSLHandshakeException: \"\n              + cause.getMessage());\n          ioe.initCause(cause);\n        }\n        RetryAction action \u003d null;\n        try {\n          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, isIdempotent);\n        } catch (Exception e) {\n          if (e instanceof IOException) {\n            throw (IOException)e;\n          }\n          throw new IOException(e);\n        }\n        // make sure each provider is tried at least once, to keep behavior\n        // compatible with earlier versions of LBKMSCP\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL\n            \u0026\u0026 numFailovers \u003e\u003d providers.length - 1) {\n          LOG.error(\"Aborting since the Request has failed with all KMS\"\n              + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n              + \" in the group OR the exception is not recoverable\",\n              CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n              getConf().getInt(\n                  CommonConfigurationKeysPublic.\n                  KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n              providers.length);\n          throw ioe;\n        }\n        if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n          // Sleep only after we try all the providers for every cycle.\n          try {\n            Thread.sleep(action.delayMillis);\n          } catch (InterruptedException e) {\n            throw new InterruptedIOException(\"Thread Interrupted\");\n          }\n        }\n      } catch (Exception e) {\n        if (e instanceof RuntimeException) {\n          throw (RuntimeException)e;\n        } else {\n          throw new WrapperException(e);\n        }\n      }\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/LoadBalancingKMSClientProvider.java",
          "extendedDetails": {
            "oldValue": "[op-ProviderCallable\u003cT\u003e, currPos-int]",
            "newValue": "[op-ProviderCallable\u003cT\u003e, currPos-int, isIdempotent-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HADOOP-15655. Enhance KMS client retry behavior. Contributed by Kitti Nanasi.\n",
          "commitDate": "16/08/18 10:42 PM",
          "commitName": "edeb2a356ad671d962764c6e2aee9f9e7d6f394c",
          "commitAuthor": "Xiao Chen",
          "commitDateOld": "24/07/18 9:45 PM",
          "commitNameOld": "81d59506e539673edde12e19c0df5c2edd9d02ad",
          "commitAuthorOld": "Xiao Chen",
          "daysBetweenCommits": 23.04,
          "commitsBetweenForRepo": 220,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,68 @@\n-  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n-      throws IOException {\n+  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos,\n+      boolean isIdempotent) throws IOException {\n     if (providers.length \u003d\u003d 0) {\n       throw new IOException(\"No providers configured !\");\n     }\n     int numFailovers \u003d 0;\n     for (int i \u003d 0;; i++, numFailovers++) {\n       KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n       try {\n         return op.call(provider);\n       } catch (AccessControlException ace) {\n         // No need to retry on AccessControlException\n         // and AuthorizationException.\n         // This assumes all the servers are configured with identical\n         // permissions and identical key acls.\n         throw ace;\n       } catch (IOException ioe) {\n         LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n             provider.getKMSUrl(), ioe);\n         // SSLHandshakeException can occur here because of lost connection\n         // with the KMS server, creating a ConnectException from it,\n         // so that the FailoverOnNetworkExceptionRetry policy will retry\n         if (ioe instanceof SSLHandshakeException) {\n           Exception cause \u003d ioe;\n           ioe \u003d new ConnectException(\"SSLHandshakeException: \"\n               + cause.getMessage());\n           ioe.initCause(cause);\n         }\n         RetryAction action \u003d null;\n         try {\n-          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, false);\n+          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, isIdempotent);\n         } catch (Exception e) {\n           if (e instanceof IOException) {\n             throw (IOException)e;\n           }\n           throw new IOException(e);\n         }\n         // make sure each provider is tried at least once, to keep behavior\n         // compatible with earlier versions of LBKMSCP\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL\n             \u0026\u0026 numFailovers \u003e\u003d providers.length - 1) {\n           LOG.error(\"Aborting since the Request has failed with all KMS\"\n               + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n               + \" in the group OR the exception is not recoverable\",\n               CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n               getConf().getInt(\n                   CommonConfigurationKeysPublic.\n                   KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n               providers.length);\n           throw ioe;\n         }\n         if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n           // Sleep only after we try all the providers for every cycle.\n           try {\n             Thread.sleep(action.delayMillis);\n           } catch (InterruptedException e) {\n             throw new InterruptedIOException(\"Thread Interrupted\");\n           }\n         }\n       } catch (Exception e) {\n         if (e instanceof RuntimeException) {\n           throw (RuntimeException)e;\n         } else {\n           throw new WrapperException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos,\n      boolean isIdempotent) throws IOException {\n    if (providers.length \u003d\u003d 0) {\n      throw new IOException(\"No providers configured !\");\n    }\n    int numFailovers \u003d 0;\n    for (int i \u003d 0;; i++, numFailovers++) {\n      KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n      try {\n        return op.call(provider);\n      } catch (AccessControlException ace) {\n        // No need to retry on AccessControlException\n        // and AuthorizationException.\n        // This assumes all the servers are configured with identical\n        // permissions and identical key acls.\n        throw ace;\n      } catch (IOException ioe) {\n        LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n            provider.getKMSUrl(), ioe);\n        // SSLHandshakeException can occur here because of lost connection\n        // with the KMS server, creating a ConnectException from it,\n        // so that the FailoverOnNetworkExceptionRetry policy will retry\n        if (ioe instanceof SSLHandshakeException) {\n          Exception cause \u003d ioe;\n          ioe \u003d new ConnectException(\"SSLHandshakeException: \"\n              + cause.getMessage());\n          ioe.initCause(cause);\n        }\n        RetryAction action \u003d null;\n        try {\n          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, isIdempotent);\n        } catch (Exception e) {\n          if (e instanceof IOException) {\n            throw (IOException)e;\n          }\n          throw new IOException(e);\n        }\n        // make sure each provider is tried at least once, to keep behavior\n        // compatible with earlier versions of LBKMSCP\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL\n            \u0026\u0026 numFailovers \u003e\u003d providers.length - 1) {\n          LOG.error(\"Aborting since the Request has failed with all KMS\"\n              + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n              + \" in the group OR the exception is not recoverable\",\n              CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n              getConf().getInt(\n                  CommonConfigurationKeysPublic.\n                  KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n              providers.length);\n          throw ioe;\n        }\n        if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n          // Sleep only after we try all the providers for every cycle.\n          try {\n            Thread.sleep(action.delayMillis);\n          } catch (InterruptedException e) {\n            throw new InterruptedIOException(\"Thread Interrupted\");\n          }\n        }\n      } catch (Exception e) {\n        if (e instanceof RuntimeException) {\n          throw (RuntimeException)e;\n        } else {\n          throw new WrapperException(e);\n        }\n      }\n    }\n  }",
          "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/LoadBalancingKMSClientProvider.java",
          "extendedDetails": {}
        }
      ]
    },
    "81d59506e539673edde12e19c0df5c2edd9d02ad": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15609. Retry KMS calls when SSLHandshakeException occurs. Contributed by Kitti Nanasi.\n",
      "commitDate": "24/07/18 9:45 PM",
      "commitName": "81d59506e539673edde12e19c0df5c2edd9d02ad",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "20/07/18 7:46 PM",
      "commitNameOld": "993ec026d10c7566fd358c022c061bca118c92f0",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 4.08,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,68 @@\n   private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n       throws IOException {\n     if (providers.length \u003d\u003d 0) {\n       throw new IOException(\"No providers configured !\");\n     }\n-    IOException ex \u003d null;\n     int numFailovers \u003d 0;\n     for (int i \u003d 0;; i++, numFailovers++) {\n       KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n       try {\n         return op.call(provider);\n       } catch (AccessControlException ace) {\n         // No need to retry on AccessControlException\n         // and AuthorizationException.\n         // This assumes all the servers are configured with identical\n         // permissions and identical key acls.\n         throw ace;\n       } catch (IOException ioe) {\n         LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n             provider.getKMSUrl(), ioe);\n-        ex \u003d ioe;\n-\n+        // SSLHandshakeException can occur here because of lost connection\n+        // with the KMS server, creating a ConnectException from it,\n+        // so that the FailoverOnNetworkExceptionRetry policy will retry\n+        if (ioe instanceof SSLHandshakeException) {\n+          Exception cause \u003d ioe;\n+          ioe \u003d new ConnectException(\"SSLHandshakeException: \"\n+              + cause.getMessage());\n+          ioe.initCause(cause);\n+        }\n         RetryAction action \u003d null;\n         try {\n           action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, false);\n         } catch (Exception e) {\n           if (e instanceof IOException) {\n             throw (IOException)e;\n           }\n           throw new IOException(e);\n         }\n         // make sure each provider is tried at least once, to keep behavior\n         // compatible with earlier versions of LBKMSCP\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL\n             \u0026\u0026 numFailovers \u003e\u003d providers.length - 1) {\n           LOG.error(\"Aborting since the Request has failed with all KMS\"\n               + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n               + \" in the group OR the exception is not recoverable\",\n               CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n               getConf().getInt(\n                   CommonConfigurationKeysPublic.\n                   KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n               providers.length);\n-          throw ex;\n+          throw ioe;\n         }\n         if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n           // Sleep only after we try all the providers for every cycle.\n           try {\n             Thread.sleep(action.delayMillis);\n           } catch (InterruptedException e) {\n             throw new InterruptedIOException(\"Thread Interrupted\");\n           }\n         }\n       } catch (Exception e) {\n         if (e instanceof RuntimeException) {\n           throw (RuntimeException)e;\n         } else {\n           throw new WrapperException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n      throws IOException {\n    if (providers.length \u003d\u003d 0) {\n      throw new IOException(\"No providers configured !\");\n    }\n    int numFailovers \u003d 0;\n    for (int i \u003d 0;; i++, numFailovers++) {\n      KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n      try {\n        return op.call(provider);\n      } catch (AccessControlException ace) {\n        // No need to retry on AccessControlException\n        // and AuthorizationException.\n        // This assumes all the servers are configured with identical\n        // permissions and identical key acls.\n        throw ace;\n      } catch (IOException ioe) {\n        LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n            provider.getKMSUrl(), ioe);\n        // SSLHandshakeException can occur here because of lost connection\n        // with the KMS server, creating a ConnectException from it,\n        // so that the FailoverOnNetworkExceptionRetry policy will retry\n        if (ioe instanceof SSLHandshakeException) {\n          Exception cause \u003d ioe;\n          ioe \u003d new ConnectException(\"SSLHandshakeException: \"\n              + cause.getMessage());\n          ioe.initCause(cause);\n        }\n        RetryAction action \u003d null;\n        try {\n          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, false);\n        } catch (Exception e) {\n          if (e instanceof IOException) {\n            throw (IOException)e;\n          }\n          throw new IOException(e);\n        }\n        // make sure each provider is tried at least once, to keep behavior\n        // compatible with earlier versions of LBKMSCP\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL\n            \u0026\u0026 numFailovers \u003e\u003d providers.length - 1) {\n          LOG.error(\"Aborting since the Request has failed with all KMS\"\n              + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n              + \" in the group OR the exception is not recoverable\",\n              CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n              getConf().getInt(\n                  CommonConfigurationKeysPublic.\n                  KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n              providers.length);\n          throw ioe;\n        }\n        if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n          // Sleep only after we try all the providers for every cycle.\n          try {\n            Thread.sleep(action.delayMillis);\n          } catch (InterruptedException e) {\n            throw new InterruptedIOException(\"Thread Interrupted\");\n          }\n        }\n      } catch (Exception e) {\n        if (e instanceof RuntimeException) {\n          throw (RuntimeException)e;\n        } else {\n          throw new WrapperException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/LoadBalancingKMSClientProvider.java",
      "extendedDetails": {}
    },
    "993ec026d10c7566fd358c022c061bca118c92f0": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-15596. Stack trace should not be printed out when running hadoop key commands. Contributed by Kitti Nanasi.\n",
      "commitDate": "20/07/18 7:46 PM",
      "commitName": "993ec026d10c7566fd358c022c061bca118c92f0",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "05/10/17 7:46 PM",
      "commitNameOld": "25f31d9fc47d21ac2f3afd7042e2ced1b849da39",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 288.0,
      "commitsBetweenForRepo": 2613,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,62 +1,62 @@\n   private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n       throws IOException {\n     if (providers.length \u003d\u003d 0) {\n       throw new IOException(\"No providers configured !\");\n     }\n     IOException ex \u003d null;\n     int numFailovers \u003d 0;\n     for (int i \u003d 0;; i++, numFailovers++) {\n       KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n       try {\n         return op.call(provider);\n       } catch (AccessControlException ace) {\n         // No need to retry on AccessControlException\n         // and AuthorizationException.\n         // This assumes all the servers are configured with identical\n         // permissions and identical key acls.\n         throw ace;\n       } catch (IOException ioe) {\n         LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n             provider.getKMSUrl(), ioe);\n         ex \u003d ioe;\n \n         RetryAction action \u003d null;\n         try {\n           action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, false);\n         } catch (Exception e) {\n           if (e instanceof IOException) {\n             throw (IOException)e;\n           }\n           throw new IOException(e);\n         }\n         // make sure each provider is tried at least once, to keep behavior\n         // compatible with earlier versions of LBKMSCP\n         if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL\n             \u0026\u0026 numFailovers \u003e\u003d providers.length - 1) {\n-          LOG.warn(\"Aborting since the Request has failed with all KMS\"\n+          LOG.error(\"Aborting since the Request has failed with all KMS\"\n               + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n               + \" in the group OR the exception is not recoverable\",\n               CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n               getConf().getInt(\n                   CommonConfigurationKeysPublic.\n                   KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n               providers.length);\n           throw ex;\n         }\n         if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n           // Sleep only after we try all the providers for every cycle.\n           try {\n             Thread.sleep(action.delayMillis);\n           } catch (InterruptedException e) {\n             throw new InterruptedIOException(\"Thread Interrupted\");\n           }\n         }\n       } catch (Exception e) {\n         if (e instanceof RuntimeException) {\n           throw (RuntimeException)e;\n         } else {\n           throw new WrapperException(e);\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n      throws IOException {\n    if (providers.length \u003d\u003d 0) {\n      throw new IOException(\"No providers configured !\");\n    }\n    IOException ex \u003d null;\n    int numFailovers \u003d 0;\n    for (int i \u003d 0;; i++, numFailovers++) {\n      KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n      try {\n        return op.call(provider);\n      } catch (AccessControlException ace) {\n        // No need to retry on AccessControlException\n        // and AuthorizationException.\n        // This assumes all the servers are configured with identical\n        // permissions and identical key acls.\n        throw ace;\n      } catch (IOException ioe) {\n        LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n            provider.getKMSUrl(), ioe);\n        ex \u003d ioe;\n\n        RetryAction action \u003d null;\n        try {\n          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, false);\n        } catch (Exception e) {\n          if (e instanceof IOException) {\n            throw (IOException)e;\n          }\n          throw new IOException(e);\n        }\n        // make sure each provider is tried at least once, to keep behavior\n        // compatible with earlier versions of LBKMSCP\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL\n            \u0026\u0026 numFailovers \u003e\u003d providers.length - 1) {\n          LOG.error(\"Aborting since the Request has failed with all KMS\"\n              + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n              + \" in the group OR the exception is not recoverable\",\n              CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n              getConf().getInt(\n                  CommonConfigurationKeysPublic.\n                  KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n              providers.length);\n          throw ex;\n        }\n        if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n          // Sleep only after we try all the providers for every cycle.\n          try {\n            Thread.sleep(action.delayMillis);\n          } catch (InterruptedException e) {\n            throw new InterruptedIOException(\"Thread Interrupted\");\n          }\n        }\n      } catch (Exception e) {\n        if (e instanceof RuntimeException) {\n          throw (RuntimeException)e;\n        } else {\n          throw new WrapperException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/LoadBalancingKMSClientProvider.java",
      "extendedDetails": {}
    },
    "25f31d9fc47d21ac2f3afd7042e2ced1b849da39": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14521. KMS client needs retry logic. Contributed by Rushabh S Shah.\n",
      "commitDate": "05/10/17 7:46 PM",
      "commitName": "25f31d9fc47d21ac2f3afd7042e2ced1b849da39",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "12/09/17 7:53 PM",
      "commitNameOld": "fa6cc43edd3f6e886a40b90b062c9f16189c50d1",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 23.0,
      "commitsBetweenForRepo": 179,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,62 @@\n   private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n       throws IOException {\n+    if (providers.length \u003d\u003d 0) {\n+      throw new IOException(\"No providers configured !\");\n+    }\n     IOException ex \u003d null;\n-    for (int i \u003d 0; i \u003c providers.length; i++) {\n+    int numFailovers \u003d 0;\n+    for (int i \u003d 0;; i++, numFailovers++) {\n       KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n       try {\n         return op.call(provider);\n+      } catch (AccessControlException ace) {\n+        // No need to retry on AccessControlException\n+        // and AuthorizationException.\n+        // This assumes all the servers are configured with identical\n+        // permissions and identical key acls.\n+        throw ace;\n       } catch (IOException ioe) {\n-        LOG.warn(\"KMS provider at [{}] threw an IOException!! {}\",\n-            provider.getKMSUrl(), StringUtils.stringifyException(ioe));\n+        LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n+            provider.getKMSUrl(), ioe);\n         ex \u003d ioe;\n+\n+        RetryAction action \u003d null;\n+        try {\n+          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, false);\n+        } catch (Exception e) {\n+          if (e instanceof IOException) {\n+            throw (IOException)e;\n+          }\n+          throw new IOException(e);\n+        }\n+        // make sure each provider is tried at least once, to keep behavior\n+        // compatible with earlier versions of LBKMSCP\n+        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL\n+            \u0026\u0026 numFailovers \u003e\u003d providers.length - 1) {\n+          LOG.warn(\"Aborting since the Request has failed with all KMS\"\n+              + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n+              + \" in the group OR the exception is not recoverable\",\n+              CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n+              getConf().getInt(\n+                  CommonConfigurationKeysPublic.\n+                  KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n+              providers.length);\n+          throw ex;\n+        }\n+        if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n+          // Sleep only after we try all the providers for every cycle.\n+          try {\n+            Thread.sleep(action.delayMillis);\n+          } catch (InterruptedException e) {\n+            throw new InterruptedIOException(\"Thread Interrupted\");\n+          }\n+        }\n       } catch (Exception e) {\n         if (e instanceof RuntimeException) {\n           throw (RuntimeException)e;\n         } else {\n           throw new WrapperException(e);\n         }\n       }\n     }\n-    if (ex !\u003d null) {\n-      LOG.warn(\"Aborting since the Request has failed with all KMS\"\n-          + \" providers in the group. !!\");\n-      throw ex;\n-    }\n-    throw new IOException(\"No providers configured !!\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n      throws IOException {\n    if (providers.length \u003d\u003d 0) {\n      throw new IOException(\"No providers configured !\");\n    }\n    IOException ex \u003d null;\n    int numFailovers \u003d 0;\n    for (int i \u003d 0;; i++, numFailovers++) {\n      KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n      try {\n        return op.call(provider);\n      } catch (AccessControlException ace) {\n        // No need to retry on AccessControlException\n        // and AuthorizationException.\n        // This assumes all the servers are configured with identical\n        // permissions and identical key acls.\n        throw ace;\n      } catch (IOException ioe) {\n        LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n            provider.getKMSUrl(), ioe);\n        ex \u003d ioe;\n\n        RetryAction action \u003d null;\n        try {\n          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, false);\n        } catch (Exception e) {\n          if (e instanceof IOException) {\n            throw (IOException)e;\n          }\n          throw new IOException(e);\n        }\n        // make sure each provider is tried at least once, to keep behavior\n        // compatible with earlier versions of LBKMSCP\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL\n            \u0026\u0026 numFailovers \u003e\u003d providers.length - 1) {\n          LOG.warn(\"Aborting since the Request has failed with all KMS\"\n              + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n              + \" in the group OR the exception is not recoverable\",\n              CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n              getConf().getInt(\n                  CommonConfigurationKeysPublic.\n                  KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n              providers.length);\n          throw ex;\n        }\n        if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n          // Sleep only after we try all the providers for every cycle.\n          try {\n            Thread.sleep(action.delayMillis);\n          } catch (InterruptedException e) {\n            throw new InterruptedIOException(\"Thread Interrupted\");\n          }\n        }\n      } catch (Exception e) {\n        if (e instanceof RuntimeException) {\n          throw (RuntimeException)e;\n        } else {\n          throw new WrapperException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/LoadBalancingKMSClientProvider.java",
      "extendedDetails": {}
    },
    "fa6cc43edd3f6e886a40b90b062c9f16189c50d1": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HADOOP-14521. KMS client needs retry logic. Contributed by Rushabh S Shah.\"\n\nThis reverts commit 0a6d5c0cf1d963da9131aa12326fc576f0e92d2c.\n",
      "commitDate": "12/09/17 7:53 PM",
      "commitName": "fa6cc43edd3f6e886a40b90b062c9f16189c50d1",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "22/08/17 7:47 AM",
      "commitNameOld": "4ec5acc70418a3f2327cf83ecae1789a057fdd99",
      "commitAuthorOld": "Xiao Chen",
      "daysBetweenCommits": 21.5,
      "commitsBetweenForRepo": 246,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,26 @@\n   private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n       throws IOException {\n-    if (providers.length \u003d\u003d 0) {\n-      throw new IOException(\"No providers configured !\");\n-    }\n     IOException ex \u003d null;\n-    int numFailovers \u003d 0;\n-    for (int i \u003d 0;; i++, numFailovers++) {\n+    for (int i \u003d 0; i \u003c providers.length; i++) {\n       KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n       try {\n         return op.call(provider);\n-      } catch (AccessControlException ace) {\n-        // No need to retry on AccessControlException\n-        // and AuthorizationException.\n-        // This assumes all the servers are configured with identical\n-        // permissions and identical key acls.\n-        throw ace;\n       } catch (IOException ioe) {\n-        LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n-            provider.getKMSUrl(), ioe);\n+        LOG.warn(\"KMS provider at [{}] threw an IOException!! {}\",\n+            provider.getKMSUrl(), StringUtils.stringifyException(ioe));\n         ex \u003d ioe;\n-\n-        RetryAction action \u003d null;\n-        try {\n-          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, false);\n-        } catch (Exception e) {\n-          if (e instanceof IOException) {\n-            throw (IOException)e;\n-          }\n-          throw new IOException(e);\n-        }\n-        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n-          LOG.warn(\"Aborting since the Request has failed with all KMS\"\n-              + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n-              + \" in the group OR the exception is not recoverable\",\n-              CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n-              getConf().getInt(\n-                  CommonConfigurationKeysPublic.\n-                  KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n-              providers.length);\n-          throw ex;\n-        }\n-        if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n-          // Sleep only after we try all the providers for every cycle.\n-          try {\n-            Thread.sleep(action.delayMillis);\n-          } catch (InterruptedException e) {\n-            throw new InterruptedIOException(\"Thread Interrupted\");\n-          }\n-        }\n       } catch (Exception e) {\n         if (e instanceof RuntimeException) {\n           throw (RuntimeException)e;\n         } else {\n           throw new WrapperException(e);\n         }\n       }\n     }\n+    if (ex !\u003d null) {\n+      LOG.warn(\"Aborting since the Request has failed with all KMS\"\n+          + \" providers in the group. !!\");\n+      throw ex;\n+    }\n+    throw new IOException(\"No providers configured !!\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n      throws IOException {\n    IOException ex \u003d null;\n    for (int i \u003d 0; i \u003c providers.length; i++) {\n      KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n      try {\n        return op.call(provider);\n      } catch (IOException ioe) {\n        LOG.warn(\"KMS provider at [{}] threw an IOException!! {}\",\n            provider.getKMSUrl(), StringUtils.stringifyException(ioe));\n        ex \u003d ioe;\n      } catch (Exception e) {\n        if (e instanceof RuntimeException) {\n          throw (RuntimeException)e;\n        } else {\n          throw new WrapperException(e);\n        }\n      }\n    }\n    if (ex !\u003d null) {\n      LOG.warn(\"Aborting since the Request has failed with all KMS\"\n          + \" providers in the group. !!\");\n      throw ex;\n    }\n    throw new IOException(\"No providers configured !!\");\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/LoadBalancingKMSClientProvider.java",
      "extendedDetails": {}
    },
    "0a6d5c0cf1d963da9131aa12326fc576f0e92d2c": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14521. KMS client needs retry logic. Contributed by Rushabh S Shah.\n",
      "commitDate": "14/07/17 10:22 PM",
      "commitName": "0a6d5c0cf1d963da9131aa12326fc576f0e92d2c",
      "commitAuthor": "Xiao Chen",
      "commitDateOld": "07/07/17 6:13 AM",
      "commitNameOld": "8153fe2bd35fb4df0b64f93ac0046e34d4807ac3",
      "commitAuthorOld": "Wei-Chiu Chuang",
      "daysBetweenCommits": 7.67,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,59 @@\n   private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n       throws IOException {\n+    if (providers.length \u003d\u003d 0) {\n+      throw new IOException(\"No providers configured !\");\n+    }\n     IOException ex \u003d null;\n-    for (int i \u003d 0; i \u003c providers.length; i++) {\n+    int numFailovers \u003d 0;\n+    for (int i \u003d 0;; i++, numFailovers++) {\n       KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n       try {\n         return op.call(provider);\n+      } catch (AccessControlException ace) {\n+        // No need to retry on AccessControlException\n+        // and AuthorizationException.\n+        // This assumes all the servers are configured with identical\n+        // permissions and identical key acls.\n+        throw ace;\n       } catch (IOException ioe) {\n-        LOG.warn(\"KMS provider at [{}] threw an IOException!! {}\",\n-            provider.getKMSUrl(), StringUtils.stringifyException(ioe));\n+        LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n+            provider.getKMSUrl(), ioe);\n         ex \u003d ioe;\n+\n+        RetryAction action \u003d null;\n+        try {\n+          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, false);\n+        } catch (Exception e) {\n+          if (e instanceof IOException) {\n+            throw (IOException)e;\n+          }\n+          throw new IOException(e);\n+        }\n+        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n+          LOG.warn(\"Aborting since the Request has failed with all KMS\"\n+              + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n+              + \" in the group OR the exception is not recoverable\",\n+              CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n+              getConf().getInt(\n+                  CommonConfigurationKeysPublic.\n+                  KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n+              providers.length);\n+          throw ex;\n+        }\n+        if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n+          // Sleep only after we try all the providers for every cycle.\n+          try {\n+            Thread.sleep(action.delayMillis);\n+          } catch (InterruptedException e) {\n+            throw new InterruptedIOException(\"Thread Interrupted\");\n+          }\n+        }\n       } catch (Exception e) {\n         if (e instanceof RuntimeException) {\n           throw (RuntimeException)e;\n         } else {\n           throw new WrapperException(e);\n         }\n       }\n     }\n-    if (ex !\u003d null) {\n-      LOG.warn(\"Aborting since the Request has failed with all KMS\"\n-          + \" providers in the group. !!\");\n-      throw ex;\n-    }\n-    throw new IOException(\"No providers configured !!\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n      throws IOException {\n    if (providers.length \u003d\u003d 0) {\n      throw new IOException(\"No providers configured !\");\n    }\n    IOException ex \u003d null;\n    int numFailovers \u003d 0;\n    for (int i \u003d 0;; i++, numFailovers++) {\n      KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n      try {\n        return op.call(provider);\n      } catch (AccessControlException ace) {\n        // No need to retry on AccessControlException\n        // and AuthorizationException.\n        // This assumes all the servers are configured with identical\n        // permissions and identical key acls.\n        throw ace;\n      } catch (IOException ioe) {\n        LOG.warn(\"KMS provider at [{}] threw an IOException: \",\n            provider.getKMSUrl(), ioe);\n        ex \u003d ioe;\n\n        RetryAction action \u003d null;\n        try {\n          action \u003d retryPolicy.shouldRetry(ioe, 0, numFailovers, false);\n        } catch (Exception e) {\n          if (e instanceof IOException) {\n            throw (IOException)e;\n          }\n          throw new IOException(e);\n        }\n        if (action.action \u003d\u003d RetryAction.RetryDecision.FAIL) {\n          LOG.warn(\"Aborting since the Request has failed with all KMS\"\n              + \" providers(depending on {}\u003d{} setting and numProviders\u003d{})\"\n              + \" in the group OR the exception is not recoverable\",\n              CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY,\n              getConf().getInt(\n                  CommonConfigurationKeysPublic.\n                  KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length),\n              providers.length);\n          throw ex;\n        }\n        if (((numFailovers + 1) % providers.length) \u003d\u003d 0) {\n          // Sleep only after we try all the providers for every cycle.\n          try {\n            Thread.sleep(action.delayMillis);\n          } catch (InterruptedException e) {\n            throw new InterruptedIOException(\"Thread Interrupted\");\n          }\n        }\n      } catch (Exception e) {\n        if (e instanceof RuntimeException) {\n          throw (RuntimeException)e;\n        } else {\n          throw new WrapperException(e);\n        }\n      }\n    }\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/LoadBalancingKMSClientProvider.java",
      "extendedDetails": {}
    },
    "a1f6564d31c16582ea949e4448091f1cc56c7dfe": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-13458. LoadBalancingKMSClientProvider#doOp should log IOException stacktrace. Contributed by Chen Liang.\n",
      "commitDate": "03/08/16 2:19 PM",
      "commitName": "a1f6564d31c16582ea949e4448091f1cc56c7dfe",
      "commitAuthor": "Wei-Chiu Chuang",
      "commitDateOld": "03/06/16 4:48 PM",
      "commitNameOld": "713cb71820ad94a5436f35824d07aa12fcba5cc6",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 60.9,
      "commitsBetweenForRepo": 532,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,26 @@\n   private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n       throws IOException {\n     IOException ex \u003d null;\n     for (int i \u003d 0; i \u003c providers.length; i++) {\n       KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n       try {\n         return op.call(provider);\n       } catch (IOException ioe) {\n-        LOG.warn(\"KMS provider at [{}] threw an IOException [{}]!!\",\n-            provider.getKMSUrl(), ioe.getMessage());\n+        LOG.warn(\"KMS provider at [{}] threw an IOException!! {}\",\n+            provider.getKMSUrl(), StringUtils.stringifyException(ioe));\n         ex \u003d ioe;\n       } catch (Exception e) {\n         if (e instanceof RuntimeException) {\n           throw (RuntimeException)e;\n         } else {\n           throw new WrapperException(e);\n         }\n       }\n     }\n     if (ex !\u003d null) {\n       LOG.warn(\"Aborting since the Request has failed with all KMS\"\n           + \" providers in the group. !!\");\n       throw ex;\n     }\n     throw new IOException(\"No providers configured !!\");\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n      throws IOException {\n    IOException ex \u003d null;\n    for (int i \u003d 0; i \u003c providers.length; i++) {\n      KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n      try {\n        return op.call(provider);\n      } catch (IOException ioe) {\n        LOG.warn(\"KMS provider at [{}] threw an IOException!! {}\",\n            provider.getKMSUrl(), StringUtils.stringifyException(ioe));\n        ex \u003d ioe;\n      } catch (Exception e) {\n        if (e instanceof RuntimeException) {\n          throw (RuntimeException)e;\n        } else {\n          throw new WrapperException(e);\n        }\n      }\n    }\n    if (ex !\u003d null) {\n      LOG.warn(\"Aborting since the Request has failed with all KMS\"\n          + \" providers in the group. !!\");\n      throw ex;\n    }\n    throw new IOException(\"No providers configured !!\");\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/LoadBalancingKMSClientProvider.java",
      "extendedDetails": {}
    },
    "71385f9b70e22618db3f3d2b2c6dca3b1e82c317": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-11620. Add support for load balancing across a group of KMS for HA. Contributed by Arun Suresh.\n",
      "commitDate": "25/02/15 9:16 PM",
      "commitName": "71385f9b70e22618db3f3d2b2c6dca3b1e82c317",
      "commitAuthor": "Andrew Wang",
      "diff": "@@ -0,0 +1,26 @@\n+  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n+      throws IOException {\n+    IOException ex \u003d null;\n+    for (int i \u003d 0; i \u003c providers.length; i++) {\n+      KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n+      try {\n+        return op.call(provider);\n+      } catch (IOException ioe) {\n+        LOG.warn(\"KMS provider at [{}] threw an IOException [{}]!!\",\n+            provider.getKMSUrl(), ioe.getMessage());\n+        ex \u003d ioe;\n+      } catch (Exception e) {\n+        if (e instanceof RuntimeException) {\n+          throw (RuntimeException)e;\n+        } else {\n+          throw new WrapperException(e);\n+        }\n+      }\n+    }\n+    if (ex !\u003d null) {\n+      LOG.warn(\"Aborting since the Request has failed with all KMS\"\n+          + \" providers in the group. !!\");\n+      throw ex;\n+    }\n+    throw new IOException(\"No providers configured !!\");\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private \u003cT\u003e T doOp(ProviderCallable\u003cT\u003e op, int currPos)\n      throws IOException {\n    IOException ex \u003d null;\n    for (int i \u003d 0; i \u003c providers.length; i++) {\n      KMSClientProvider provider \u003d providers[(currPos + i) % providers.length];\n      try {\n        return op.call(provider);\n      } catch (IOException ioe) {\n        LOG.warn(\"KMS provider at [{}] threw an IOException [{}]!!\",\n            provider.getKMSUrl(), ioe.getMessage());\n        ex \u003d ioe;\n      } catch (Exception e) {\n        if (e instanceof RuntimeException) {\n          throw (RuntimeException)e;\n        } else {\n          throw new WrapperException(e);\n        }\n      }\n    }\n    if (ex !\u003d null) {\n      LOG.warn(\"Aborting since the Request has failed with all KMS\"\n          + \" providers in the group. !!\");\n      throw ex;\n    }\n    throw new IOException(\"No providers configured !!\");\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/crypto/key/kms/LoadBalancingKMSClientProvider.java"
    }
  }
}