{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ProvidedVolumeImpl.java",
  "functionName": "fetchVolumeMap",
  "functionId": "fetchVolumeMap___volumeMap-ReplicaMap__ramDiskReplicaMap-RamDiskReplicaTracker__remoteFS-FileSystem",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
  "functionStartLine": 159,
  "functionEndLine": 215,
  "numCommitsSeen": 28,
  "timeTaken": 7341,
  "changeHistory": [
    "71ec170107e67e42cdbc5052c3f7b23c64751835",
    "4531588a94dcd2b4141b12828cb60ca3b953a58c",
    "9c35be86e17021202823bfd3c2067ff3b312ce5c",
    "352f994b6484524cdcfcda021046c59905b62f31",
    "3b1d30301bcd35bbe525a7e122d3e5acfab92c88",
    "e1a28f95b8ffcb86300148f10a23b710f8388341",
    "98f5ed5aa377ddd3f35b763b20c499d2ccac2ed5",
    "2407c9b93aabb021b76c802b19c928fb6cbb0a85",
    "663b3c08b131ea2db693e1a5d2f5da98242fa854",
    "b668eb91556b8c85c2b4925808ccb1f769031c20"
  ],
  "changeHistoryShort": {
    "71ec170107e67e42cdbc5052c3f7b23c64751835": "Ybodychange",
    "4531588a94dcd2b4141b12828cb60ca3b953a58c": "Ybodychange",
    "9c35be86e17021202823bfd3c2067ff3b312ce5c": "Ybodychange",
    "352f994b6484524cdcfcda021046c59905b62f31": "Ymultichange(Yrename,Ymodifierchange,Ybodychange)",
    "3b1d30301bcd35bbe525a7e122d3e5acfab92c88": "Ybodychange",
    "e1a28f95b8ffcb86300148f10a23b710f8388341": "Ybodychange",
    "98f5ed5aa377ddd3f35b763b20c499d2ccac2ed5": "Ybodychange",
    "2407c9b93aabb021b76c802b19c928fb6cbb0a85": "Ymultichange(Yparameterchange,Ybodychange)",
    "663b3c08b131ea2db693e1a5d2f5da98242fa854": "Ybodychange",
    "b668eb91556b8c85c2b4925808ccb1f769031c20": "Yintroduced"
  },
  "changeHistoryDetails": {
    "71ec170107e67e42cdbc5052c3f7b23c64751835": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12887. [READ] Allow Datanodes with Provided volumes to start when blocks with the same id exist locally\n",
      "commitDate": "15/12/17 5:51 PM",
      "commitName": "71ec170107e67e42cdbc5052c3f7b23c64751835",
      "commitAuthor": "Virajith Jalaparti",
      "commitDateOld": "15/12/17 5:51 PM",
      "commitNameOld": "4531588a94dcd2b4141b12828cb60ca3b953a58c",
      "commitAuthorOld": "Virajith Jalaparti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,57 @@\n     void fetchVolumeMap(ReplicaMap volumeMap,\n         RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n         throws IOException {\n       BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d null;\n       int tries \u003d 1;\n       do {\n         try {\n           reader \u003d aliasMap.getReader(null, bpid);\n           break;\n         } catch (IOException e) {\n           tries++;\n           reader \u003d null;\n         }\n       } while (tries \u003c\u003d numRetries);\n \n       if (reader \u003d\u003d null) {\n         LOG.error(\"Got null reader from BlockAliasMap \" + aliasMap\n             + \"; no blocks will be populated\");\n         return;\n       }\n       Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n       for (FileRegion region : reader) {\n         if (containsBlock(providedVolume.baseURI,\n             region.getProvidedStorageLocation().getPath().toUri())) {\n           String blockSuffix \u003d getSuffix(blockPrefixPath,\n               new Path(region.getProvidedStorageLocation().getPath().toUri()));\n           PathHandle pathHandle \u003d null;\n           if (region.getProvidedStorageLocation().getNonce().length \u003e 0) {\n             pathHandle \u003d new RawPathHandle(ByteBuffer\n                 .wrap(region.getProvidedStorageLocation().getNonce()));\n           }\n           ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setBlockId(region.getBlock().getBlockId())\n               .setPathPrefix(blockPrefixPath)\n               .setPathSuffix(blockSuffix)\n               .setOffset(region.getProvidedStorageLocation().getOffset())\n               .setLength(region.getBlock().getNumBytes())\n               .setGenerationStamp(region.getBlock().getGenerationStamp())\n               .setPathHandle(pathHandle)\n               .setFsVolume(providedVolume)\n               .setConf(conf)\n               .setRemoteFS(remoteFS)\n               .build();\n           ReplicaInfo oldReplica \u003d\n               volumeMap.get(bpid, newReplica.getBlockId());\n           if (oldReplica \u003d\u003d null) {\n             volumeMap.add(bpid, newReplica);\n             bpVolumeMap.add(bpid, newReplica);\n             incrNumBlocks();\n             incDfsUsed(region.getBlock().getNumBytes());\n           } else {\n-            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n-                + \" already exists in the volumeMap\");\n+            LOG.warn(\"A block with id \" + newReplica.getBlockId()\n+                + \" exists locally. Skipping PROVIDED replica\");\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void fetchVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n        throws IOException {\n      BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d null;\n      int tries \u003d 1;\n      do {\n        try {\n          reader \u003d aliasMap.getReader(null, bpid);\n          break;\n        } catch (IOException e) {\n          tries++;\n          reader \u003d null;\n        }\n      } while (tries \u003c\u003d numRetries);\n\n      if (reader \u003d\u003d null) {\n        LOG.error(\"Got null reader from BlockAliasMap \" + aliasMap\n            + \"; no blocks will be populated\");\n        return;\n      }\n      Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n      for (FileRegion region : reader) {\n        if (containsBlock(providedVolume.baseURI,\n            region.getProvidedStorageLocation().getPath().toUri())) {\n          String blockSuffix \u003d getSuffix(blockPrefixPath,\n              new Path(region.getProvidedStorageLocation().getPath().toUri()));\n          PathHandle pathHandle \u003d null;\n          if (region.getProvidedStorageLocation().getNonce().length \u003e 0) {\n            pathHandle \u003d new RawPathHandle(ByteBuffer\n                .wrap(region.getProvidedStorageLocation().getNonce()));\n          }\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setPathPrefix(blockPrefixPath)\n              .setPathSuffix(blockSuffix)\n              .setOffset(region.getProvidedStorageLocation().getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setPathHandle(pathHandle)\n              .setFsVolume(providedVolume)\n              .setConf(conf)\n              .setRemoteFS(remoteFS)\n              .build();\n          ReplicaInfo oldReplica \u003d\n              volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n            incrNumBlocks();\n            incDfsUsed(region.getBlock().getNumBytes());\n          } else {\n            LOG.warn(\"A block with id \" + newReplica.getBlockId()\n                + \" exists locally. Skipping PROVIDED replica\");\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
      "extendedDetails": {}
    },
    "4531588a94dcd2b4141b12828cb60ca3b953a58c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11640. [READ] Datanodes should use a unique identifier when reading from external stores\n",
      "commitDate": "15/12/17 5:51 PM",
      "commitName": "4531588a94dcd2b4141b12828cb60ca3b953a58c",
      "commitAuthor": "Virajith Jalaparti",
      "commitDateOld": "15/12/17 5:51 PM",
      "commitNameOld": "9c35be86e17021202823bfd3c2067ff3b312ce5c",
      "commitAuthorOld": "Virajith Jalaparti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,57 @@\n     void fetchVolumeMap(ReplicaMap volumeMap,\n         RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n         throws IOException {\n       BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d null;\n       int tries \u003d 1;\n       do {\n         try {\n           reader \u003d aliasMap.getReader(null, bpid);\n           break;\n         } catch (IOException e) {\n           tries++;\n           reader \u003d null;\n         }\n       } while (tries \u003c\u003d numRetries);\n \n       if (reader \u003d\u003d null) {\n         LOG.error(\"Got null reader from BlockAliasMap \" + aliasMap\n             + \"; no blocks will be populated\");\n         return;\n       }\n       Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n       for (FileRegion region : reader) {\n         if (containsBlock(providedVolume.baseURI,\n             region.getProvidedStorageLocation().getPath().toUri())) {\n           String blockSuffix \u003d getSuffix(blockPrefixPath,\n               new Path(region.getProvidedStorageLocation().getPath().toUri()));\n+          PathHandle pathHandle \u003d null;\n+          if (region.getProvidedStorageLocation().getNonce().length \u003e 0) {\n+            pathHandle \u003d new RawPathHandle(ByteBuffer\n+                .wrap(region.getProvidedStorageLocation().getNonce()));\n+          }\n           ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setBlockId(region.getBlock().getBlockId())\n               .setPathPrefix(blockPrefixPath)\n               .setPathSuffix(blockSuffix)\n               .setOffset(region.getProvidedStorageLocation().getOffset())\n               .setLength(region.getBlock().getNumBytes())\n               .setGenerationStamp(region.getBlock().getGenerationStamp())\n+              .setPathHandle(pathHandle)\n               .setFsVolume(providedVolume)\n               .setConf(conf)\n               .setRemoteFS(remoteFS)\n               .build();\n           ReplicaInfo oldReplica \u003d\n               volumeMap.get(bpid, newReplica.getBlockId());\n           if (oldReplica \u003d\u003d null) {\n             volumeMap.add(bpid, newReplica);\n             bpVolumeMap.add(bpid, newReplica);\n             incrNumBlocks();\n             incDfsUsed(region.getBlock().getNumBytes());\n           } else {\n             throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                 + \" already exists in the volumeMap\");\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void fetchVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n        throws IOException {\n      BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d null;\n      int tries \u003d 1;\n      do {\n        try {\n          reader \u003d aliasMap.getReader(null, bpid);\n          break;\n        } catch (IOException e) {\n          tries++;\n          reader \u003d null;\n        }\n      } while (tries \u003c\u003d numRetries);\n\n      if (reader \u003d\u003d null) {\n        LOG.error(\"Got null reader from BlockAliasMap \" + aliasMap\n            + \"; no blocks will be populated\");\n        return;\n      }\n      Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n      for (FileRegion region : reader) {\n        if (containsBlock(providedVolume.baseURI,\n            region.getProvidedStorageLocation().getPath().toUri())) {\n          String blockSuffix \u003d getSuffix(blockPrefixPath,\n              new Path(region.getProvidedStorageLocation().getPath().toUri()));\n          PathHandle pathHandle \u003d null;\n          if (region.getProvidedStorageLocation().getNonce().length \u003e 0) {\n            pathHandle \u003d new RawPathHandle(ByteBuffer\n                .wrap(region.getProvidedStorageLocation().getNonce()));\n          }\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setPathPrefix(blockPrefixPath)\n              .setPathSuffix(blockSuffix)\n              .setOffset(region.getProvidedStorageLocation().getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setPathHandle(pathHandle)\n              .setFsVolume(providedVolume)\n              .setConf(conf)\n              .setRemoteFS(remoteFS)\n              .build();\n          ReplicaInfo oldReplica \u003d\n              volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n            incrNumBlocks();\n            incDfsUsed(region.getBlock().getNumBytes());\n          } else {\n            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                + \" already exists in the volumeMap\");\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
      "extendedDetails": {}
    },
    "9c35be86e17021202823bfd3c2067ff3b312ce5c": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12713. [READ] Refactor FileRegion and BlockAliasMap to separate out HDFS metadata and PROVIDED storage metadata. Contributed by Ewan Higgs\n",
      "commitDate": "15/12/17 5:51 PM",
      "commitName": "9c35be86e17021202823bfd3c2067ff3b312ce5c",
      "commitAuthor": "Virajith Jalaparti",
      "commitDateOld": "15/12/17 5:51 PM",
      "commitNameOld": "a027055dd2bf5009fe272e9ceb08305bd0a8cc31",
      "commitAuthorOld": "Virajith Jalaparti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,51 @@\n     void fetchVolumeMap(ReplicaMap volumeMap,\n         RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n         throws IOException {\n-      BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n+      BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d null;\n+      int tries \u003d 1;\n+      do {\n+        try {\n+          reader \u003d aliasMap.getReader(null, bpid);\n+          break;\n+        } catch (IOException e) {\n+          tries++;\n+          reader \u003d null;\n+        }\n+      } while (tries \u003c\u003d numRetries);\n+\n       if (reader \u003d\u003d null) {\n-        LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n+        LOG.error(\"Got null reader from BlockAliasMap \" + aliasMap\n             + \"; no blocks will be populated\");\n         return;\n       }\n       Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n       for (FileRegion region : reader) {\n-        if (region.getBlockPoolId() !\u003d null\n-            \u0026\u0026 region.getBlockPoolId().equals(bpid)\n-            \u0026\u0026 containsBlock(providedVolume.baseURI,\n-                region.getProvidedStorageLocation().getPath().toUri())) {\n+        if (containsBlock(providedVolume.baseURI,\n+            region.getProvidedStorageLocation().getPath().toUri())) {\n           String blockSuffix \u003d getSuffix(blockPrefixPath,\n               new Path(region.getProvidedStorageLocation().getPath().toUri()));\n           ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setBlockId(region.getBlock().getBlockId())\n               .setPathPrefix(blockPrefixPath)\n               .setPathSuffix(blockSuffix)\n               .setOffset(region.getProvidedStorageLocation().getOffset())\n               .setLength(region.getBlock().getNumBytes())\n               .setGenerationStamp(region.getBlock().getGenerationStamp())\n               .setFsVolume(providedVolume)\n               .setConf(conf)\n               .setRemoteFS(remoteFS)\n               .build();\n           ReplicaInfo oldReplica \u003d\n               volumeMap.get(bpid, newReplica.getBlockId());\n           if (oldReplica \u003d\u003d null) {\n             volumeMap.add(bpid, newReplica);\n             bpVolumeMap.add(bpid, newReplica);\n             incrNumBlocks();\n             incDfsUsed(region.getBlock().getNumBytes());\n           } else {\n             throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                 + \" already exists in the volumeMap\");\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    void fetchVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n        throws IOException {\n      BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d null;\n      int tries \u003d 1;\n      do {\n        try {\n          reader \u003d aliasMap.getReader(null, bpid);\n          break;\n        } catch (IOException e) {\n          tries++;\n          reader \u003d null;\n        }\n      } while (tries \u003c\u003d numRetries);\n\n      if (reader \u003d\u003d null) {\n        LOG.error(\"Got null reader from BlockAliasMap \" + aliasMap\n            + \"; no blocks will be populated\");\n        return;\n      }\n      Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n      for (FileRegion region : reader) {\n        if (containsBlock(providedVolume.baseURI,\n            region.getProvidedStorageLocation().getPath().toUri())) {\n          String blockSuffix \u003d getSuffix(blockPrefixPath,\n              new Path(region.getProvidedStorageLocation().getPath().toUri()));\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setPathPrefix(blockPrefixPath)\n              .setPathSuffix(blockSuffix)\n              .setOffset(region.getProvidedStorageLocation().getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setFsVolume(providedVolume)\n              .setConf(conf)\n              .setRemoteFS(remoteFS)\n              .build();\n          ReplicaInfo oldReplica \u003d\n              volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n            incrNumBlocks();\n            incDfsUsed(region.getBlock().getNumBytes());\n          } else {\n            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                + \" already exists in the volumeMap\");\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
      "extendedDetails": {}
    },
    "352f994b6484524cdcfcda021046c59905b62f31": {
      "type": "Ymultichange(Yrename,Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-12665. [AliasMap] Create a version of the AliasMap that runs in memory in the Namenode (leveldb). Contributed by Ewan Higgs.\n",
      "commitDate": "15/12/17 5:51 PM",
      "commitName": "352f994b6484524cdcfcda021046c59905b62f31",
      "commitAuthor": "Virajith Jalaparti",
      "subchanges": [
        {
          "type": "Yrename",
          "commitMessage": "HDFS-12665. [AliasMap] Create a version of the AliasMap that runs in memory in the Namenode (leveldb). Contributed by Ewan Higgs.\n",
          "commitDate": "15/12/17 5:51 PM",
          "commitName": "352f994b6484524cdcfcda021046c59905b62f31",
          "commitAuthor": "Virajith Jalaparti",
          "commitDateOld": "15/12/17 5:51 PM",
          "commitNameOld": "cc933cba77c147153e463415fc192cee2d53a1ef",
          "commitAuthorOld": "Virajith Jalaparti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,42 @@\n-    public void getVolumeMap(ReplicaMap volumeMap,\n+    void fetchVolumeMap(ReplicaMap volumeMap,\n         RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n         throws IOException {\n       BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n       if (reader \u003d\u003d null) {\n         LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n             + \"; no blocks will be populated\");\n         return;\n       }\n-      Iterator\u003cFileRegion\u003e iter \u003d reader.iterator();\n       Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n-      while (iter.hasNext()) {\n-        FileRegion region \u003d iter.next();\n+      for (FileRegion region : reader) {\n         if (region.getBlockPoolId() !\u003d null\n             \u0026\u0026 region.getBlockPoolId().equals(bpid)\n             \u0026\u0026 containsBlock(providedVolume.baseURI,\n-                region.getPath().toUri())) {\n-          String blockSuffix \u003d\n-              getSuffix(blockPrefixPath, new Path(region.getPath().toUri()));\n+                region.getProvidedStorageLocation().getPath().toUri())) {\n+          String blockSuffix \u003d getSuffix(blockPrefixPath,\n+              new Path(region.getProvidedStorageLocation().getPath().toUri()));\n           ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setBlockId(region.getBlock().getBlockId())\n               .setPathPrefix(blockPrefixPath)\n               .setPathSuffix(blockSuffix)\n-              .setOffset(region.getOffset())\n+              .setOffset(region.getProvidedStorageLocation().getOffset())\n               .setLength(region.getBlock().getNumBytes())\n               .setGenerationStamp(region.getBlock().getGenerationStamp())\n               .setFsVolume(providedVolume)\n               .setConf(conf)\n               .setRemoteFS(remoteFS)\n               .build();\n           ReplicaInfo oldReplica \u003d\n               volumeMap.get(bpid, newReplica.getBlockId());\n           if (oldReplica \u003d\u003d null) {\n             volumeMap.add(bpid, newReplica);\n             bpVolumeMap.add(bpid, newReplica);\n             incrNumBlocks();\n             incDfsUsed(region.getBlock().getNumBytes());\n           } else {\n             throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                 + \" already exists in the volumeMap\");\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    void fetchVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n        throws IOException {\n      BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n      if (reader \u003d\u003d null) {\n        LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n            + \"; no blocks will be populated\");\n        return;\n      }\n      Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n      for (FileRegion region : reader) {\n        if (region.getBlockPoolId() !\u003d null\n            \u0026\u0026 region.getBlockPoolId().equals(bpid)\n            \u0026\u0026 containsBlock(providedVolume.baseURI,\n                region.getProvidedStorageLocation().getPath().toUri())) {\n          String blockSuffix \u003d getSuffix(blockPrefixPath,\n              new Path(region.getProvidedStorageLocation().getPath().toUri()));\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setPathPrefix(blockPrefixPath)\n              .setPathSuffix(blockSuffix)\n              .setOffset(region.getProvidedStorageLocation().getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setFsVolume(providedVolume)\n              .setConf(conf)\n              .setRemoteFS(remoteFS)\n              .build();\n          ReplicaInfo oldReplica \u003d\n              volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n            incrNumBlocks();\n            incDfsUsed(region.getBlock().getNumBytes());\n          } else {\n            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                + \" already exists in the volumeMap\");\n          }\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
          "extendedDetails": {
            "oldValue": "getVolumeMap",
            "newValue": "fetchVolumeMap"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-12665. [AliasMap] Create a version of the AliasMap that runs in memory in the Namenode (leveldb). Contributed by Ewan Higgs.\n",
          "commitDate": "15/12/17 5:51 PM",
          "commitName": "352f994b6484524cdcfcda021046c59905b62f31",
          "commitAuthor": "Virajith Jalaparti",
          "commitDateOld": "15/12/17 5:51 PM",
          "commitNameOld": "cc933cba77c147153e463415fc192cee2d53a1ef",
          "commitAuthorOld": "Virajith Jalaparti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,42 @@\n-    public void getVolumeMap(ReplicaMap volumeMap,\n+    void fetchVolumeMap(ReplicaMap volumeMap,\n         RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n         throws IOException {\n       BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n       if (reader \u003d\u003d null) {\n         LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n             + \"; no blocks will be populated\");\n         return;\n       }\n-      Iterator\u003cFileRegion\u003e iter \u003d reader.iterator();\n       Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n-      while (iter.hasNext()) {\n-        FileRegion region \u003d iter.next();\n+      for (FileRegion region : reader) {\n         if (region.getBlockPoolId() !\u003d null\n             \u0026\u0026 region.getBlockPoolId().equals(bpid)\n             \u0026\u0026 containsBlock(providedVolume.baseURI,\n-                region.getPath().toUri())) {\n-          String blockSuffix \u003d\n-              getSuffix(blockPrefixPath, new Path(region.getPath().toUri()));\n+                region.getProvidedStorageLocation().getPath().toUri())) {\n+          String blockSuffix \u003d getSuffix(blockPrefixPath,\n+              new Path(region.getProvidedStorageLocation().getPath().toUri()));\n           ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setBlockId(region.getBlock().getBlockId())\n               .setPathPrefix(blockPrefixPath)\n               .setPathSuffix(blockSuffix)\n-              .setOffset(region.getOffset())\n+              .setOffset(region.getProvidedStorageLocation().getOffset())\n               .setLength(region.getBlock().getNumBytes())\n               .setGenerationStamp(region.getBlock().getGenerationStamp())\n               .setFsVolume(providedVolume)\n               .setConf(conf)\n               .setRemoteFS(remoteFS)\n               .build();\n           ReplicaInfo oldReplica \u003d\n               volumeMap.get(bpid, newReplica.getBlockId());\n           if (oldReplica \u003d\u003d null) {\n             volumeMap.add(bpid, newReplica);\n             bpVolumeMap.add(bpid, newReplica);\n             incrNumBlocks();\n             incDfsUsed(region.getBlock().getNumBytes());\n           } else {\n             throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                 + \" already exists in the volumeMap\");\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    void fetchVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n        throws IOException {\n      BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n      if (reader \u003d\u003d null) {\n        LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n            + \"; no blocks will be populated\");\n        return;\n      }\n      Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n      for (FileRegion region : reader) {\n        if (region.getBlockPoolId() !\u003d null\n            \u0026\u0026 region.getBlockPoolId().equals(bpid)\n            \u0026\u0026 containsBlock(providedVolume.baseURI,\n                region.getProvidedStorageLocation().getPath().toUri())) {\n          String blockSuffix \u003d getSuffix(blockPrefixPath,\n              new Path(region.getProvidedStorageLocation().getPath().toUri()));\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setPathPrefix(blockPrefixPath)\n              .setPathSuffix(blockSuffix)\n              .setOffset(region.getProvidedStorageLocation().getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setFsVolume(providedVolume)\n              .setConf(conf)\n              .setRemoteFS(remoteFS)\n              .build();\n          ReplicaInfo oldReplica \u003d\n              volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n            incrNumBlocks();\n            incDfsUsed(region.getBlock().getNumBytes());\n          } else {\n            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                + \" already exists in the volumeMap\");\n          }\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
          "extendedDetails": {
            "oldValue": "[public]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12665. [AliasMap] Create a version of the AliasMap that runs in memory in the Namenode (leveldb). Contributed by Ewan Higgs.\n",
          "commitDate": "15/12/17 5:51 PM",
          "commitName": "352f994b6484524cdcfcda021046c59905b62f31",
          "commitAuthor": "Virajith Jalaparti",
          "commitDateOld": "15/12/17 5:51 PM",
          "commitNameOld": "cc933cba77c147153e463415fc192cee2d53a1ef",
          "commitAuthorOld": "Virajith Jalaparti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,42 @@\n-    public void getVolumeMap(ReplicaMap volumeMap,\n+    void fetchVolumeMap(ReplicaMap volumeMap,\n         RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n         throws IOException {\n       BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n       if (reader \u003d\u003d null) {\n         LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n             + \"; no blocks will be populated\");\n         return;\n       }\n-      Iterator\u003cFileRegion\u003e iter \u003d reader.iterator();\n       Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n-      while (iter.hasNext()) {\n-        FileRegion region \u003d iter.next();\n+      for (FileRegion region : reader) {\n         if (region.getBlockPoolId() !\u003d null\n             \u0026\u0026 region.getBlockPoolId().equals(bpid)\n             \u0026\u0026 containsBlock(providedVolume.baseURI,\n-                region.getPath().toUri())) {\n-          String blockSuffix \u003d\n-              getSuffix(blockPrefixPath, new Path(region.getPath().toUri()));\n+                region.getProvidedStorageLocation().getPath().toUri())) {\n+          String blockSuffix \u003d getSuffix(blockPrefixPath,\n+              new Path(region.getProvidedStorageLocation().getPath().toUri()));\n           ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setBlockId(region.getBlock().getBlockId())\n               .setPathPrefix(blockPrefixPath)\n               .setPathSuffix(blockSuffix)\n-              .setOffset(region.getOffset())\n+              .setOffset(region.getProvidedStorageLocation().getOffset())\n               .setLength(region.getBlock().getNumBytes())\n               .setGenerationStamp(region.getBlock().getGenerationStamp())\n               .setFsVolume(providedVolume)\n               .setConf(conf)\n               .setRemoteFS(remoteFS)\n               .build();\n           ReplicaInfo oldReplica \u003d\n               volumeMap.get(bpid, newReplica.getBlockId());\n           if (oldReplica \u003d\u003d null) {\n             volumeMap.add(bpid, newReplica);\n             bpVolumeMap.add(bpid, newReplica);\n             incrNumBlocks();\n             incDfsUsed(region.getBlock().getNumBytes());\n           } else {\n             throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                 + \" already exists in the volumeMap\");\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    void fetchVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n        throws IOException {\n      BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n      if (reader \u003d\u003d null) {\n        LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n            + \"; no blocks will be populated\");\n        return;\n      }\n      Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n      for (FileRegion region : reader) {\n        if (region.getBlockPoolId() !\u003d null\n            \u0026\u0026 region.getBlockPoolId().equals(bpid)\n            \u0026\u0026 containsBlock(providedVolume.baseURI,\n                region.getProvidedStorageLocation().getPath().toUri())) {\n          String blockSuffix \u003d getSuffix(blockPrefixPath,\n              new Path(region.getProvidedStorageLocation().getPath().toUri()));\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setPathPrefix(blockPrefixPath)\n              .setPathSuffix(blockSuffix)\n              .setOffset(region.getProvidedStorageLocation().getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setFsVolume(providedVolume)\n              .setConf(conf)\n              .setRemoteFS(remoteFS)\n              .build();\n          ReplicaInfo oldReplica \u003d\n              volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n            incrNumBlocks();\n            incDfsUsed(region.getBlock().getNumBytes());\n          } else {\n            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                + \" already exists in the volumeMap\");\n          }\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "3b1d30301bcd35bbe525a7e122d3e5acfab92c88": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12775. [READ] Fix reporting of Provided volumes\n",
      "commitDate": "15/12/17 5:51 PM",
      "commitName": "3b1d30301bcd35bbe525a7e122d3e5acfab92c88",
      "commitAuthor": "Virajith Jalaparti",
      "commitDateOld": "15/12/17 5:51 PM",
      "commitNameOld": "e1a28f95b8ffcb86300148f10a23b710f8388341",
      "commitAuthorOld": "Virajith Jalaparti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,42 +1,44 @@\n     public void getVolumeMap(ReplicaMap volumeMap,\n         RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n         throws IOException {\n       BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n       if (reader \u003d\u003d null) {\n         LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n             + \"; no blocks will be populated\");\n         return;\n       }\n       Iterator\u003cFileRegion\u003e iter \u003d reader.iterator();\n       Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n       while (iter.hasNext()) {\n         FileRegion region \u003d iter.next();\n         if (region.getBlockPoolId() !\u003d null\n             \u0026\u0026 region.getBlockPoolId().equals(bpid)\n             \u0026\u0026 containsBlock(providedVolume.baseURI,\n                 region.getPath().toUri())) {\n           String blockSuffix \u003d\n               getSuffix(blockPrefixPath, new Path(region.getPath().toUri()));\n           ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setBlockId(region.getBlock().getBlockId())\n               .setPathPrefix(blockPrefixPath)\n               .setPathSuffix(blockSuffix)\n               .setOffset(region.getOffset())\n               .setLength(region.getBlock().getNumBytes())\n               .setGenerationStamp(region.getBlock().getGenerationStamp())\n               .setFsVolume(providedVolume)\n               .setConf(conf)\n               .setRemoteFS(remoteFS)\n               .build();\n           ReplicaInfo oldReplica \u003d\n               volumeMap.get(bpid, newReplica.getBlockId());\n           if (oldReplica \u003d\u003d null) {\n             volumeMap.add(bpid, newReplica);\n             bpVolumeMap.add(bpid, newReplica);\n+            incrNumBlocks();\n+            incDfsUsed(region.getBlock().getNumBytes());\n           } else {\n             throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                 + \" already exists in the volumeMap\");\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void getVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n        throws IOException {\n      BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n      if (reader \u003d\u003d null) {\n        LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n            + \"; no blocks will be populated\");\n        return;\n      }\n      Iterator\u003cFileRegion\u003e iter \u003d reader.iterator();\n      Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n      while (iter.hasNext()) {\n        FileRegion region \u003d iter.next();\n        if (region.getBlockPoolId() !\u003d null\n            \u0026\u0026 region.getBlockPoolId().equals(bpid)\n            \u0026\u0026 containsBlock(providedVolume.baseURI,\n                region.getPath().toUri())) {\n          String blockSuffix \u003d\n              getSuffix(blockPrefixPath, new Path(region.getPath().toUri()));\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setPathPrefix(blockPrefixPath)\n              .setPathSuffix(blockSuffix)\n              .setOffset(region.getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setFsVolume(providedVolume)\n              .setConf(conf)\n              .setRemoteFS(remoteFS)\n              .build();\n          ReplicaInfo oldReplica \u003d\n              volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n            incrNumBlocks();\n            incDfsUsed(region.getBlock().getNumBytes());\n          } else {\n            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                + \" already exists in the volumeMap\");\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
      "extendedDetails": {}
    },
    "e1a28f95b8ffcb86300148f10a23b710f8388341": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12777. [READ] Reduce memory and CPU footprint for PROVIDED volumes.\n",
      "commitDate": "15/12/17 5:51 PM",
      "commitName": "e1a28f95b8ffcb86300148f10a23b710f8388341",
      "commitAuthor": "Virajith Jalaparti",
      "commitDateOld": "15/12/17 5:51 PM",
      "commitNameOld": "98f5ed5aa377ddd3f35b763b20c499d2ccac2ed5",
      "commitAuthorOld": "Virajith Jalaparti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,42 @@\n     public void getVolumeMap(ReplicaMap volumeMap,\n         RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n         throws IOException {\n       BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n       if (reader \u003d\u003d null) {\n         LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n             + \"; no blocks will be populated\");\n         return;\n       }\n       Iterator\u003cFileRegion\u003e iter \u003d reader.iterator();\n+      Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n       while (iter.hasNext()) {\n         FileRegion region \u003d iter.next();\n         if (region.getBlockPoolId() !\u003d null\n             \u0026\u0026 region.getBlockPoolId().equals(bpid)\n             \u0026\u0026 containsBlock(providedVolume.baseURI,\n                 region.getPath().toUri())) {\n+          String blockSuffix \u003d\n+              getSuffix(blockPrefixPath, new Path(region.getPath().toUri()));\n           ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setBlockId(region.getBlock().getBlockId())\n-              .setURI(region.getPath().toUri())\n+              .setPathPrefix(blockPrefixPath)\n+              .setPathSuffix(blockSuffix)\n               .setOffset(region.getOffset())\n               .setLength(region.getBlock().getNumBytes())\n               .setGenerationStamp(region.getBlock().getGenerationStamp())\n               .setFsVolume(providedVolume)\n               .setConf(conf)\n               .setRemoteFS(remoteFS)\n               .build();\n           ReplicaInfo oldReplica \u003d\n               volumeMap.get(bpid, newReplica.getBlockId());\n           if (oldReplica \u003d\u003d null) {\n             volumeMap.add(bpid, newReplica);\n             bpVolumeMap.add(bpid, newReplica);\n           } else {\n             throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                 + \" already exists in the volumeMap\");\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void getVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n        throws IOException {\n      BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n      if (reader \u003d\u003d null) {\n        LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n            + \"; no blocks will be populated\");\n        return;\n      }\n      Iterator\u003cFileRegion\u003e iter \u003d reader.iterator();\n      Path blockPrefixPath \u003d new Path(providedVolume.getBaseURI());\n      while (iter.hasNext()) {\n        FileRegion region \u003d iter.next();\n        if (region.getBlockPoolId() !\u003d null\n            \u0026\u0026 region.getBlockPoolId().equals(bpid)\n            \u0026\u0026 containsBlock(providedVolume.baseURI,\n                region.getPath().toUri())) {\n          String blockSuffix \u003d\n              getSuffix(blockPrefixPath, new Path(region.getPath().toUri()));\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setPathPrefix(blockPrefixPath)\n              .setPathSuffix(blockSuffix)\n              .setOffset(region.getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setFsVolume(providedVolume)\n              .setConf(conf)\n              .setRemoteFS(remoteFS)\n              .build();\n          ReplicaInfo oldReplica \u003d\n              volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n          } else {\n            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                + \" already exists in the volumeMap\");\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
      "extendedDetails": {}
    },
    "98f5ed5aa377ddd3f35b763b20c499d2ccac2ed5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11902. [READ] Merge BlockFormatProvider and FileRegionProvider.\n",
      "commitDate": "15/12/17 5:51 PM",
      "commitName": "98f5ed5aa377ddd3f35b763b20c499d2ccac2ed5",
      "commitAuthor": "Virajith Jalaparti",
      "commitDateOld": "15/12/17 5:51 PM",
      "commitNameOld": "2407c9b93aabb021b76c802b19c928fb6cbb0a85",
      "commitAuthorOld": "Virajith Jalaparti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,38 @@\n     public void getVolumeMap(ReplicaMap volumeMap,\n         RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n         throws IOException {\n-      Iterator\u003cFileRegion\u003e iter \u003d provider.iterator();\n+      BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n+      if (reader \u003d\u003d null) {\n+        LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n+            + \"; no blocks will be populated\");\n+        return;\n+      }\n+      Iterator\u003cFileRegion\u003e iter \u003d reader.iterator();\n       while (iter.hasNext()) {\n         FileRegion region \u003d iter.next();\n         if (region.getBlockPoolId() !\u003d null\n             \u0026\u0026 region.getBlockPoolId().equals(bpid)\n             \u0026\u0026 containsBlock(providedVolume.baseURI,\n                 region.getPath().toUri())) {\n           ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setBlockId(region.getBlock().getBlockId())\n               .setURI(region.getPath().toUri())\n               .setOffset(region.getOffset())\n               .setLength(region.getBlock().getNumBytes())\n               .setGenerationStamp(region.getBlock().getGenerationStamp())\n               .setFsVolume(providedVolume)\n               .setConf(conf)\n               .setRemoteFS(remoteFS)\n               .build();\n           ReplicaInfo oldReplica \u003d\n               volumeMap.get(bpid, newReplica.getBlockId());\n           if (oldReplica \u003d\u003d null) {\n             volumeMap.add(bpid, newReplica);\n             bpVolumeMap.add(bpid, newReplica);\n           } else {\n             throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                 + \" already exists in the volumeMap\");\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void getVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n        throws IOException {\n      BlockAliasMap.Reader\u003cFileRegion\u003e reader \u003d aliasMap.getReader(null);\n      if (reader \u003d\u003d null) {\n        LOG.warn(\"Got null reader from BlockAliasMap \" + aliasMap\n            + \"; no blocks will be populated\");\n        return;\n      }\n      Iterator\u003cFileRegion\u003e iter \u003d reader.iterator();\n      while (iter.hasNext()) {\n        FileRegion region \u003d iter.next();\n        if (region.getBlockPoolId() !\u003d null\n            \u0026\u0026 region.getBlockPoolId().equals(bpid)\n            \u0026\u0026 containsBlock(providedVolume.baseURI,\n                region.getPath().toUri())) {\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setURI(region.getPath().toUri())\n              .setOffset(region.getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setFsVolume(providedVolume)\n              .setConf(conf)\n              .setRemoteFS(remoteFS)\n              .build();\n          ReplicaInfo oldReplica \u003d\n              volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n          } else {\n            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                + \" already exists in the volumeMap\");\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
      "extendedDetails": {}
    },
    "2407c9b93aabb021b76c802b19c928fb6cbb0a85": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-12093. [READ] Share remoteFS between ProvidedReplica instances.\n",
      "commitDate": "15/12/17 5:51 PM",
      "commitName": "2407c9b93aabb021b76c802b19c928fb6cbb0a85",
      "commitAuthor": "Virajith Jalaparti",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-12093. [READ] Share remoteFS between ProvidedReplica instances.\n",
          "commitDate": "15/12/17 5:51 PM",
          "commitName": "2407c9b93aabb021b76c802b19c928fb6cbb0a85",
          "commitAuthor": "Virajith Jalaparti",
          "commitDateOld": "15/12/17 5:51 PM",
          "commitNameOld": "663b3c08b131ea2db693e1a5d2f5da98242fa854",
          "commitAuthorOld": "Virajith Jalaparti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,32 @@\n     public void getVolumeMap(ReplicaMap volumeMap,\n-        RamDiskReplicaTracker ramDiskReplicaMap) throws IOException {\n+        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n+        throws IOException {\n       Iterator\u003cFileRegion\u003e iter \u003d provider.iterator();\n       while (iter.hasNext()) {\n         FileRegion region \u003d iter.next();\n         if (region.getBlockPoolId() !\u003d null\n             \u0026\u0026 region.getBlockPoolId().equals(bpid)\n             \u0026\u0026 containsBlock(providedVolume.baseURI,\n                 region.getPath().toUri())) {\n           ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setBlockId(region.getBlock().getBlockId())\n               .setURI(region.getPath().toUri())\n               .setOffset(region.getOffset())\n               .setLength(region.getBlock().getNumBytes())\n               .setGenerationStamp(region.getBlock().getGenerationStamp())\n               .setFsVolume(providedVolume)\n               .setConf(conf)\n+              .setRemoteFS(remoteFS)\n               .build();\n-          // check if the replica already exists\n-          ReplicaInfo oldReplica \u003d volumeMap.get(bpid, newReplica.getBlockId());\n+          ReplicaInfo oldReplica \u003d\n+              volumeMap.get(bpid, newReplica.getBlockId());\n           if (oldReplica \u003d\u003d null) {\n             volumeMap.add(bpid, newReplica);\n             bpVolumeMap.add(bpid, newReplica);\n           } else {\n             throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                 + \" already exists in the volumeMap\");\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void getVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n        throws IOException {\n      Iterator\u003cFileRegion\u003e iter \u003d provider.iterator();\n      while (iter.hasNext()) {\n        FileRegion region \u003d iter.next();\n        if (region.getBlockPoolId() !\u003d null\n            \u0026\u0026 region.getBlockPoolId().equals(bpid)\n            \u0026\u0026 containsBlock(providedVolume.baseURI,\n                region.getPath().toUri())) {\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setURI(region.getPath().toUri())\n              .setOffset(region.getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setFsVolume(providedVolume)\n              .setConf(conf)\n              .setRemoteFS(remoteFS)\n              .build();\n          ReplicaInfo oldReplica \u003d\n              volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n          } else {\n            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                + \" already exists in the volumeMap\");\n          }\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
          "extendedDetails": {
            "oldValue": "[volumeMap-ReplicaMap, ramDiskReplicaMap-RamDiskReplicaTracker]",
            "newValue": "[volumeMap-ReplicaMap, ramDiskReplicaMap-RamDiskReplicaTracker, remoteFS-FileSystem]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-12093. [READ] Share remoteFS between ProvidedReplica instances.\n",
          "commitDate": "15/12/17 5:51 PM",
          "commitName": "2407c9b93aabb021b76c802b19c928fb6cbb0a85",
          "commitAuthor": "Virajith Jalaparti",
          "commitDateOld": "15/12/17 5:51 PM",
          "commitNameOld": "663b3c08b131ea2db693e1a5d2f5da98242fa854",
          "commitAuthorOld": "Virajith Jalaparti",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,30 +1,32 @@\n     public void getVolumeMap(ReplicaMap volumeMap,\n-        RamDiskReplicaTracker ramDiskReplicaMap) throws IOException {\n+        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n+        throws IOException {\n       Iterator\u003cFileRegion\u003e iter \u003d provider.iterator();\n       while (iter.hasNext()) {\n         FileRegion region \u003d iter.next();\n         if (region.getBlockPoolId() !\u003d null\n             \u0026\u0026 region.getBlockPoolId().equals(bpid)\n             \u0026\u0026 containsBlock(providedVolume.baseURI,\n                 region.getPath().toUri())) {\n           ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setBlockId(region.getBlock().getBlockId())\n               .setURI(region.getPath().toUri())\n               .setOffset(region.getOffset())\n               .setLength(region.getBlock().getNumBytes())\n               .setGenerationStamp(region.getBlock().getGenerationStamp())\n               .setFsVolume(providedVolume)\n               .setConf(conf)\n+              .setRemoteFS(remoteFS)\n               .build();\n-          // check if the replica already exists\n-          ReplicaInfo oldReplica \u003d volumeMap.get(bpid, newReplica.getBlockId());\n+          ReplicaInfo oldReplica \u003d\n+              volumeMap.get(bpid, newReplica.getBlockId());\n           if (oldReplica \u003d\u003d null) {\n             volumeMap.add(bpid, newReplica);\n             bpVolumeMap.add(bpid, newReplica);\n           } else {\n             throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                 + \" already exists in the volumeMap\");\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
          "actualSource": "    public void getVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap, FileSystem remoteFS)\n        throws IOException {\n      Iterator\u003cFileRegion\u003e iter \u003d provider.iterator();\n      while (iter.hasNext()) {\n        FileRegion region \u003d iter.next();\n        if (region.getBlockPoolId() !\u003d null\n            \u0026\u0026 region.getBlockPoolId().equals(bpid)\n            \u0026\u0026 containsBlock(providedVolume.baseURI,\n                region.getPath().toUri())) {\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setURI(region.getPath().toUri())\n              .setOffset(region.getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setFsVolume(providedVolume)\n              .setConf(conf)\n              .setRemoteFS(remoteFS)\n              .build();\n          ReplicaInfo oldReplica \u003d\n              volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n          } else {\n            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                + \" already exists in the volumeMap\");\n          }\n        }\n      }\n    }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "663b3c08b131ea2db693e1a5d2f5da98242fa854": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12091. [READ] Check that the replicas served from a ProvidedVolumeImpl belong to the correct external storage\n",
      "commitDate": "15/12/17 5:51 PM",
      "commitName": "663b3c08b131ea2db693e1a5d2f5da98242fa854",
      "commitAuthor": "Virajith Jalaparti",
      "commitDateOld": "15/12/17 5:51 PM",
      "commitNameOld": "55ade54b8ed36e18f028f478381a96e7b8c6be50",
      "commitAuthorOld": "Virajith Jalaparti",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,29 +1,30 @@\n     public void getVolumeMap(ReplicaMap volumeMap,\n         RamDiskReplicaTracker ramDiskReplicaMap) throws IOException {\n       Iterator\u003cFileRegion\u003e iter \u003d provider.iterator();\n-      while(iter.hasNext()) {\n+      while (iter.hasNext()) {\n         FileRegion region \u003d iter.next();\n-        if (region.getBlockPoolId() !\u003d null \u0026\u0026\n-            region.getBlockPoolId().equals(bpid)) {\n+        if (region.getBlockPoolId() !\u003d null\n+            \u0026\u0026 region.getBlockPoolId().equals(bpid)\n+            \u0026\u0026 containsBlock(providedVolume.baseURI,\n+                region.getPath().toUri())) {\n           ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n               .setBlockId(region.getBlock().getBlockId())\n               .setURI(region.getPath().toUri())\n               .setOffset(region.getOffset())\n               .setLength(region.getBlock().getNumBytes())\n               .setGenerationStamp(region.getBlock().getGenerationStamp())\n               .setFsVolume(providedVolume)\n-              .setConf(conf).build();\n-\n-          ReplicaInfo oldReplica \u003d\n-              volumeMap.get(bpid, newReplica.getBlockId());\n+              .setConf(conf)\n+              .build();\n+          // check if the replica already exists\n+          ReplicaInfo oldReplica \u003d volumeMap.get(bpid, newReplica.getBlockId());\n           if (oldReplica \u003d\u003d null) {\n             volumeMap.add(bpid, newReplica);\n             bpVolumeMap.add(bpid, newReplica);\n           } else {\n-            throw new IOException(\n-                \"A block with id \" + newReplica.getBlockId() +\n-                \" already exists in the volumeMap\");\n+            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n+                + \" already exists in the volumeMap\");\n           }\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public void getVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap) throws IOException {\n      Iterator\u003cFileRegion\u003e iter \u003d provider.iterator();\n      while (iter.hasNext()) {\n        FileRegion region \u003d iter.next();\n        if (region.getBlockPoolId() !\u003d null\n            \u0026\u0026 region.getBlockPoolId().equals(bpid)\n            \u0026\u0026 containsBlock(providedVolume.baseURI,\n                region.getPath().toUri())) {\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setURI(region.getPath().toUri())\n              .setOffset(region.getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setFsVolume(providedVolume)\n              .setConf(conf)\n              .build();\n          // check if the replica already exists\n          ReplicaInfo oldReplica \u003d volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n          } else {\n            throw new IOException(\"A block with id \" + newReplica.getBlockId()\n                + \" already exists in the volumeMap\");\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java",
      "extendedDetails": {}
    },
    "b668eb91556b8c85c2b4925808ccb1f769031c20": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-10675. Datanode support to read from external stores.\n",
      "commitDate": "15/12/17 5:51 PM",
      "commitName": "b668eb91556b8c85c2b4925808ccb1f769031c20",
      "commitAuthor": "Virajith Jalaparti",
      "diff": "@@ -0,0 +1,29 @@\n+    public void getVolumeMap(ReplicaMap volumeMap,\n+        RamDiskReplicaTracker ramDiskReplicaMap) throws IOException {\n+      Iterator\u003cFileRegion\u003e iter \u003d provider.iterator();\n+      while(iter.hasNext()) {\n+        FileRegion region \u003d iter.next();\n+        if (region.getBlockPoolId() !\u003d null \u0026\u0026\n+            region.getBlockPoolId().equals(bpid)) {\n+          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n+              .setBlockId(region.getBlock().getBlockId())\n+              .setURI(region.getPath().toUri())\n+              .setOffset(region.getOffset())\n+              .setLength(region.getBlock().getNumBytes())\n+              .setGenerationStamp(region.getBlock().getGenerationStamp())\n+              .setFsVolume(providedVolume)\n+              .setConf(conf).build();\n+\n+          ReplicaInfo oldReplica \u003d\n+              volumeMap.get(bpid, newReplica.getBlockId());\n+          if (oldReplica \u003d\u003d null) {\n+            volumeMap.add(bpid, newReplica);\n+            bpVolumeMap.add(bpid, newReplica);\n+          } else {\n+            throw new IOException(\n+                \"A block with id \" + newReplica.getBlockId() +\n+                \" already exists in the volumeMap\");\n+          }\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public void getVolumeMap(ReplicaMap volumeMap,\n        RamDiskReplicaTracker ramDiskReplicaMap) throws IOException {\n      Iterator\u003cFileRegion\u003e iter \u003d provider.iterator();\n      while(iter.hasNext()) {\n        FileRegion region \u003d iter.next();\n        if (region.getBlockPoolId() !\u003d null \u0026\u0026\n            region.getBlockPoolId().equals(bpid)) {\n          ReplicaInfo newReplica \u003d new ReplicaBuilder(ReplicaState.FINALIZED)\n              .setBlockId(region.getBlock().getBlockId())\n              .setURI(region.getPath().toUri())\n              .setOffset(region.getOffset())\n              .setLength(region.getBlock().getNumBytes())\n              .setGenerationStamp(region.getBlock().getGenerationStamp())\n              .setFsVolume(providedVolume)\n              .setConf(conf).build();\n\n          ReplicaInfo oldReplica \u003d\n              volumeMap.get(bpid, newReplica.getBlockId());\n          if (oldReplica \u003d\u003d null) {\n            volumeMap.add(bpid, newReplica);\n            bpVolumeMap.add(bpid, newReplica);\n          } else {\n            throw new IOException(\n                \"A block with id \" + newReplica.getBlockId() +\n                \" already exists in the volumeMap\");\n          }\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/impl/ProvidedVolumeImpl.java"
    }
  }
}