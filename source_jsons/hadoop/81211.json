{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DNS.java",
  "functionName": "getIPsAsInetAddressList",
  "functionId": "getIPsAsInetAddressList___strInterface-String__returnSubinterfaces-boolean",
  "sourceFilePath": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/DNS.java",
  "functionStartLine": 421,
  "functionEndLine": 450,
  "numCommitsSeen": 11,
  "timeTaken": 1522,
  "changeHistory": [
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
    "df31c446bfa628bee9fab88addcfec5a13edda30"
  ],
  "changeHistoryShort": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": "Ybodychange",
    "df31c446bfa628bee9fab88addcfec5a13edda30": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f20dc0d5770d3876954faf0a6e8dcce6539ffc23": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10571. Use Log.*(Object, Throwable) overload to log exceptions.\nContributed by Andras Bokor.\n",
      "commitDate": "14/02/18 8:20 AM",
      "commitName": "f20dc0d5770d3876954faf0a6e8dcce6539ffc23",
      "commitAuthor": "Steve Loughran",
      "commitDateOld": "17/07/17 9:32 PM",
      "commitNameOld": "ccaf036662e22da14583942054898c99fa51dae5",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 211.49,
      "commitsBetweenForRepo": 1578,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,30 +1,30 @@\n   public static List\u003cInetAddress\u003e getIPsAsInetAddressList(String strInterface,\n       boolean returnSubinterfaces) throws UnknownHostException {\n     if (\"default\".equals(strInterface)) {\n       return Arrays.asList(InetAddress.getByName(cachedHostAddress));\n     }\n     NetworkInterface netIf;\n     try {\n       netIf \u003d NetworkInterface.getByName(strInterface);\n       if (netIf \u003d\u003d null) {\n         netIf \u003d getSubinterface(strInterface);\n       }\n     } catch (SocketException e) {\n-      LOG.warn(\"I/O error finding interface \" + strInterface +\n-          \": \" + e.getMessage());\n+      LOG.warn(\"I/O error finding interface {}: {}\",\n+          strInterface, e.getMessage());\n       return Arrays.asList(InetAddress.getByName(cachedHostAddress));\n     }\n     if (netIf \u003d\u003d null) {\n       throw new UnknownHostException(\"No such interface \" + strInterface);\n     }\n \n     // NB: Using a LinkedHashSet to preserve the order for callers\n     // that depend on a particular element being 1st in the array.\n     // For example, getDefaultIP always returns the first element.\n     LinkedHashSet\u003cInetAddress\u003e allAddrs \u003d new LinkedHashSet\u003cInetAddress\u003e();\n     allAddrs.addAll(Collections.list(netIf.getInetAddresses()));\n     if (!returnSubinterfaces) {\n       allAddrs.removeAll(getSubinterfaceInetAddrs(netIf));\n     }\n     return new Vector\u003cInetAddress\u003e(allAddrs);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static List\u003cInetAddress\u003e getIPsAsInetAddressList(String strInterface,\n      boolean returnSubinterfaces) throws UnknownHostException {\n    if (\"default\".equals(strInterface)) {\n      return Arrays.asList(InetAddress.getByName(cachedHostAddress));\n    }\n    NetworkInterface netIf;\n    try {\n      netIf \u003d NetworkInterface.getByName(strInterface);\n      if (netIf \u003d\u003d null) {\n        netIf \u003d getSubinterface(strInterface);\n      }\n    } catch (SocketException e) {\n      LOG.warn(\"I/O error finding interface {}: {}\",\n          strInterface, e.getMessage());\n      return Arrays.asList(InetAddress.getByName(cachedHostAddress));\n    }\n    if (netIf \u003d\u003d null) {\n      throw new UnknownHostException(\"No such interface \" + strInterface);\n    }\n\n    // NB: Using a LinkedHashSet to preserve the order for callers\n    // that depend on a particular element being 1st in the array.\n    // For example, getDefaultIP always returns the first element.\n    LinkedHashSet\u003cInetAddress\u003e allAddrs \u003d new LinkedHashSet\u003cInetAddress\u003e();\n    allAddrs.addAll(Collections.list(netIf.getInetAddresses()));\n    if (!returnSubinterfaces) {\n      allAddrs.removeAll(getSubinterfaceInetAddrs(netIf));\n    }\n    return new Vector\u003cInetAddress\u003e(allAddrs);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/DNS.java",
      "extendedDetails": {}
    },
    "df31c446bfa628bee9fab88addcfec5a13edda30": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-12437. Allow SecurityUtil to lookup alternate hostnames. (Contributed by Arpit Agarwal)\n",
      "commitDate": "24/09/15 11:41 AM",
      "commitName": "df31c446bfa628bee9fab88addcfec5a13edda30",
      "commitAuthor": "Arpit Agarwal",
      "diff": "@@ -0,0 +1,30 @@\n+  public static List\u003cInetAddress\u003e getIPsAsInetAddressList(String strInterface,\n+      boolean returnSubinterfaces) throws UnknownHostException {\n+    if (\"default\".equals(strInterface)) {\n+      return Arrays.asList(InetAddress.getByName(cachedHostAddress));\n+    }\n+    NetworkInterface netIf;\n+    try {\n+      netIf \u003d NetworkInterface.getByName(strInterface);\n+      if (netIf \u003d\u003d null) {\n+        netIf \u003d getSubinterface(strInterface);\n+      }\n+    } catch (SocketException e) {\n+      LOG.warn(\"I/O error finding interface \" + strInterface +\n+          \": \" + e.getMessage());\n+      return Arrays.asList(InetAddress.getByName(cachedHostAddress));\n+    }\n+    if (netIf \u003d\u003d null) {\n+      throw new UnknownHostException(\"No such interface \" + strInterface);\n+    }\n+\n+    // NB: Using a LinkedHashSet to preserve the order for callers\n+    // that depend on a particular element being 1st in the array.\n+    // For example, getDefaultIP always returns the first element.\n+    LinkedHashSet\u003cInetAddress\u003e allAddrs \u003d new LinkedHashSet\u003cInetAddress\u003e();\n+    allAddrs.addAll(Collections.list(netIf.getInetAddresses()));\n+    if (!returnSubinterfaces) {\n+      allAddrs.removeAll(getSubinterfaceInetAddrs(netIf));\n+    }\n+    return new Vector\u003cInetAddress\u003e(allAddrs);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static List\u003cInetAddress\u003e getIPsAsInetAddressList(String strInterface,\n      boolean returnSubinterfaces) throws UnknownHostException {\n    if (\"default\".equals(strInterface)) {\n      return Arrays.asList(InetAddress.getByName(cachedHostAddress));\n    }\n    NetworkInterface netIf;\n    try {\n      netIf \u003d NetworkInterface.getByName(strInterface);\n      if (netIf \u003d\u003d null) {\n        netIf \u003d getSubinterface(strInterface);\n      }\n    } catch (SocketException e) {\n      LOG.warn(\"I/O error finding interface \" + strInterface +\n          \": \" + e.getMessage());\n      return Arrays.asList(InetAddress.getByName(cachedHostAddress));\n    }\n    if (netIf \u003d\u003d null) {\n      throw new UnknownHostException(\"No such interface \" + strInterface);\n    }\n\n    // NB: Using a LinkedHashSet to preserve the order for callers\n    // that depend on a particular element being 1st in the array.\n    // For example, getDefaultIP always returns the first element.\n    LinkedHashSet\u003cInetAddress\u003e allAddrs \u003d new LinkedHashSet\u003cInetAddress\u003e();\n    allAddrs.addAll(Collections.list(netIf.getInetAddresses()));\n    if (!returnSubinterfaces) {\n      allAddrs.removeAll(getSubinterfaceInetAddrs(netIf));\n    }\n    return new Vector\u003cInetAddress\u003e(allAddrs);\n  }",
      "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/net/DNS.java"
    }
  }
}