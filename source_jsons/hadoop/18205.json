{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RouterAdmin.java",
  "functionName": "updateMount",
  "functionId": "updateMount___parameters-String[]__i-int",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/tools/federation/RouterAdmin.java",
  "functionStartLine": 640,
  "functionEndLine": 723,
  "numCommitsSeen": 27,
  "timeTaken": 2129,
  "changeHistory": [
    "dd8c2b92df2d42fe8ee07032988fe1fb68161004",
    "6c42d4050461ab71c88f123569649793dc53aebd",
    "9315db5f5da09c2ef86be168465c16932afa2d85",
    "09c9cf1d43b802dd62b532c3c7be0e21a0c9ad5c"
  ],
  "changeHistoryShort": {
    "dd8c2b92df2d42fe8ee07032988fe1fb68161004": "Ybodychange",
    "6c42d4050461ab71c88f123569649793dc53aebd": "Ybodychange",
    "9315db5f5da09c2ef86be168465c16932afa2d85": "Ybodychange",
    "09c9cf1d43b802dd62b532c3c7be0e21a0c9ad5c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "dd8c2b92df2d42fe8ee07032988fe1fb68161004": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13853. RBF: RouterAdmin update cmd is overwriting the entry not updating the existing. Contributed by Ayush Saxena.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "dd8c2b92df2d42fe8ee07032988fe1fb68161004",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "6c42d4050461ab71c88f123569649793dc53aebd",
      "commitAuthorOld": "Ayush Saxena",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,84 @@\n   public boolean updateMount(String[] parameters, int i) throws IOException {\n-    // Mandatory parameters\n     String mount \u003d parameters[i++];\n-    String[] nss \u003d parameters[i++].split(\",\");\n-    String dest \u003d parameters[i++];\n-\n-    // Optional parameters\n-    boolean readOnly \u003d false;\n-    boolean faultTolerant \u003d false;\n-    String owner \u003d null;\n-    String group \u003d null;\n-    FsPermission mode \u003d null;\n-    DestinationOrder order \u003d null;\n-    while (i \u003c parameters.length) {\n-      if (parameters[i].equals(\"-readonly\")) {\n-        readOnly \u003d true;\n-      } else if (parameters[i].equals(\"-faulttolerant\")) {\n-        faultTolerant \u003d true;\n-      } else if (parameters[i].equals(\"-order\")) {\n-        i++;\n-        try {\n-          order \u003d DestinationOrder.valueOf(parameters[i]);\n-        } catch(Exception e) {\n-          System.err.println(\"Cannot parse order: \" + parameters[i]);\n-        }\n-      } else if (parameters[i].equals(\"-owner\")) {\n-        i++;\n-        owner \u003d parameters[i];\n-      } else if (parameters[i].equals(\"-group\")) {\n-        i++;\n-        group \u003d parameters[i];\n-      } else if (parameters[i].equals(\"-mode\")) {\n-        i++;\n-        short modeValue \u003d Short.parseShort(parameters[i], 8);\n-        mode \u003d new FsPermission(modeValue);\n-      } else {\n-        printUsage(\"-update\");\n-        return false;\n-      }\n-\n-      i++;\n+    mount \u003d normalizeFileSystemPath(mount);\n+    MountTableManager mountTable \u003d client.getMountTableManager();\n+    MountTable existingEntry \u003d getMountEntry(mount, mountTable);\n+    if (existingEntry \u003d\u003d null) {\n+      throw new IOException(mount + \" doesn\u0027t exist.\");\n     }\n+    // Check if the destination needs to be updated.\n \n-    return updateMount(mount, nss, dest, readOnly, faultTolerant, order,\n-        new ACLEntity(owner, group, mode));\n+    if (!parameters[i].startsWith(\"-\")) {\n+      String[] nss \u003d parameters[i++].split(\",\");\n+      String dest \u003d parameters[i++];\n+      Map\u003cString, String\u003e destMap \u003d new LinkedHashMap\u003c\u003e();\n+      for (String ns : nss) {\n+        destMap.put(ns, dest);\n+      }\n+      final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n+      for (Entry\u003cString, String\u003e entry : destMap.entrySet()) {\n+        String nsId \u003d entry.getKey();\n+        String path \u003d normalizeFileSystemPath(entry.getValue());\n+        RemoteLocation location \u003d new RemoteLocation(nsId, path, mount);\n+        locations.add(location);\n+      }\n+      existingEntry.setDestinations(locations);\n+    }\n+    try {\n+      while (i \u003c parameters.length) {\n+        switch (parameters[i]) {\n+        case \"-readonly\":\n+          i++;\n+          existingEntry.setReadOnly(getBooleanValue(parameters[i]));\n+          break;\n+        case \"-faulttolerant\":\n+          i++;\n+          existingEntry.setFaultTolerant(getBooleanValue(parameters[i]));\n+          break;\n+        case \"-order\":\n+          i++;\n+          try {\n+            existingEntry.setDestOrder(DestinationOrder.valueOf(parameters[i]));\n+            break;\n+          } catch (Exception e) {\n+            throw new Exception(\"Cannot parse order: \" + parameters[i]);\n+          }\n+        case \"-owner\":\n+          i++;\n+          existingEntry.setOwnerName(parameters[i]);\n+          break;\n+        case \"-group\":\n+          i++;\n+          existingEntry.setGroupName(parameters[i]);\n+          break;\n+        case \"-mode\":\n+          i++;\n+          short modeValue \u003d Short.parseShort(parameters[i], 8);\n+          existingEntry.setMode(new FsPermission(modeValue));\n+          break;\n+        default:\n+          printUsage(\"-update\");\n+          return false;\n+        }\n+        i++;\n+      }\n+    } catch (IllegalArgumentException iae) {\n+      throw iae;\n+    } catch (Exception e) {\n+      String msg \u003d \"Unable to parse arguments: \" + e.getMessage();\n+      if (e instanceof ArrayIndexOutOfBoundsException) {\n+        msg \u003d \"Unable to parse arguments: no value provided for \"\n+            + parameters[i - 1];\n+      }\n+      throw new IOException(msg);\n+    }\n+    UpdateMountTableEntryRequest updateRequest \u003d\n+        UpdateMountTableEntryRequest.newInstance(existingEntry);\n+    UpdateMountTableEntryResponse updateResponse \u003d\n+        mountTable.updateMountTableEntry(updateRequest);\n+    boolean updated \u003d updateResponse.getStatus();\n+    if (!updated) {\n+      System.err.println(\"Cannot update mount point \" + mount);\n+    }\n+    return updated;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean updateMount(String[] parameters, int i) throws IOException {\n    String mount \u003d parameters[i++];\n    mount \u003d normalizeFileSystemPath(mount);\n    MountTableManager mountTable \u003d client.getMountTableManager();\n    MountTable existingEntry \u003d getMountEntry(mount, mountTable);\n    if (existingEntry \u003d\u003d null) {\n      throw new IOException(mount + \" doesn\u0027t exist.\");\n    }\n    // Check if the destination needs to be updated.\n\n    if (!parameters[i].startsWith(\"-\")) {\n      String[] nss \u003d parameters[i++].split(\",\");\n      String dest \u003d parameters[i++];\n      Map\u003cString, String\u003e destMap \u003d new LinkedHashMap\u003c\u003e();\n      for (String ns : nss) {\n        destMap.put(ns, dest);\n      }\n      final List\u003cRemoteLocation\u003e locations \u003d new LinkedList\u003c\u003e();\n      for (Entry\u003cString, String\u003e entry : destMap.entrySet()) {\n        String nsId \u003d entry.getKey();\n        String path \u003d normalizeFileSystemPath(entry.getValue());\n        RemoteLocation location \u003d new RemoteLocation(nsId, path, mount);\n        locations.add(location);\n      }\n      existingEntry.setDestinations(locations);\n    }\n    try {\n      while (i \u003c parameters.length) {\n        switch (parameters[i]) {\n        case \"-readonly\":\n          i++;\n          existingEntry.setReadOnly(getBooleanValue(parameters[i]));\n          break;\n        case \"-faulttolerant\":\n          i++;\n          existingEntry.setFaultTolerant(getBooleanValue(parameters[i]));\n          break;\n        case \"-order\":\n          i++;\n          try {\n            existingEntry.setDestOrder(DestinationOrder.valueOf(parameters[i]));\n            break;\n          } catch (Exception e) {\n            throw new Exception(\"Cannot parse order: \" + parameters[i]);\n          }\n        case \"-owner\":\n          i++;\n          existingEntry.setOwnerName(parameters[i]);\n          break;\n        case \"-group\":\n          i++;\n          existingEntry.setGroupName(parameters[i]);\n          break;\n        case \"-mode\":\n          i++;\n          short modeValue \u003d Short.parseShort(parameters[i], 8);\n          existingEntry.setMode(new FsPermission(modeValue));\n          break;\n        default:\n          printUsage(\"-update\");\n          return false;\n        }\n        i++;\n      }\n    } catch (IllegalArgumentException iae) {\n      throw iae;\n    } catch (Exception e) {\n      String msg \u003d \"Unable to parse arguments: \" + e.getMessage();\n      if (e instanceof ArrayIndexOutOfBoundsException) {\n        msg \u003d \"Unable to parse arguments: no value provided for \"\n            + parameters[i - 1];\n      }\n      throw new IOException(msg);\n    }\n    UpdateMountTableEntryRequest updateRequest \u003d\n        UpdateMountTableEntryRequest.newInstance(existingEntry);\n    UpdateMountTableEntryResponse updateResponse \u003d\n        mountTable.updateMountTableEntry(updateRequest);\n    boolean updated \u003d updateResponse.getStatus();\n    if (!updated) {\n      System.err.println(\"Cannot update mount point \" + mount);\n    }\n    return updated;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/tools/federation/RouterAdmin.java",
      "extendedDetails": {}
    },
    "6c42d4050461ab71c88f123569649793dc53aebd": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14316. RBF: Support unavailable subclusters for mount points with multiple destinations. Contributed by Inigo Goiri.\n",
      "commitDate": "24/06/19 9:33 AM",
      "commitName": "6c42d4050461ab71c88f123569649793dc53aebd",
      "commitAuthor": "Ayush Saxena",
      "commitDateOld": "24/06/19 9:33 AM",
      "commitNameOld": "8b8ff5ccbc677d98a91092b2fa64999a99d1595d",
      "commitAuthorOld": "Giovanni Matteo Fumarola",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 12,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,43 +1,46 @@\n   public boolean updateMount(String[] parameters, int i) throws IOException {\n     // Mandatory parameters\n     String mount \u003d parameters[i++];\n     String[] nss \u003d parameters[i++].split(\",\");\n     String dest \u003d parameters[i++];\n \n     // Optional parameters\n     boolean readOnly \u003d false;\n+    boolean faultTolerant \u003d false;\n     String owner \u003d null;\n     String group \u003d null;\n     FsPermission mode \u003d null;\n     DestinationOrder order \u003d null;\n     while (i \u003c parameters.length) {\n       if (parameters[i].equals(\"-readonly\")) {\n         readOnly \u003d true;\n+      } else if (parameters[i].equals(\"-faulttolerant\")) {\n+        faultTolerant \u003d true;\n       } else if (parameters[i].equals(\"-order\")) {\n         i++;\n         try {\n           order \u003d DestinationOrder.valueOf(parameters[i]);\n         } catch(Exception e) {\n           System.err.println(\"Cannot parse order: \" + parameters[i]);\n         }\n       } else if (parameters[i].equals(\"-owner\")) {\n         i++;\n         owner \u003d parameters[i];\n       } else if (parameters[i].equals(\"-group\")) {\n         i++;\n         group \u003d parameters[i];\n       } else if (parameters[i].equals(\"-mode\")) {\n         i++;\n         short modeValue \u003d Short.parseShort(parameters[i], 8);\n         mode \u003d new FsPermission(modeValue);\n       } else {\n         printUsage(\"-update\");\n         return false;\n       }\n \n       i++;\n     }\n \n-    return updateMount(mount, nss, dest, readOnly, order,\n+    return updateMount(mount, nss, dest, readOnly, faultTolerant, order,\n         new ACLEntity(owner, group, mode));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean updateMount(String[] parameters, int i) throws IOException {\n    // Mandatory parameters\n    String mount \u003d parameters[i++];\n    String[] nss \u003d parameters[i++].split(\",\");\n    String dest \u003d parameters[i++];\n\n    // Optional parameters\n    boolean readOnly \u003d false;\n    boolean faultTolerant \u003d false;\n    String owner \u003d null;\n    String group \u003d null;\n    FsPermission mode \u003d null;\n    DestinationOrder order \u003d null;\n    while (i \u003c parameters.length) {\n      if (parameters[i].equals(\"-readonly\")) {\n        readOnly \u003d true;\n      } else if (parameters[i].equals(\"-faulttolerant\")) {\n        faultTolerant \u003d true;\n      } else if (parameters[i].equals(\"-order\")) {\n        i++;\n        try {\n          order \u003d DestinationOrder.valueOf(parameters[i]);\n        } catch(Exception e) {\n          System.err.println(\"Cannot parse order: \" + parameters[i]);\n        }\n      } else if (parameters[i].equals(\"-owner\")) {\n        i++;\n        owner \u003d parameters[i];\n      } else if (parameters[i].equals(\"-group\")) {\n        i++;\n        group \u003d parameters[i];\n      } else if (parameters[i].equals(\"-mode\")) {\n        i++;\n        short modeValue \u003d Short.parseShort(parameters[i], 8);\n        mode \u003d new FsPermission(modeValue);\n      } else {\n        printUsage(\"-update\");\n        return false;\n      }\n\n      i++;\n    }\n\n    return updateMount(mount, nss, dest, readOnly, faultTolerant, order,\n        new ACLEntity(owner, group, mode));\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/tools/federation/RouterAdmin.java",
      "extendedDetails": {}
    },
    "9315db5f5da09c2ef86be168465c16932afa2d85": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13815. RBF: Add check to order command. Contributed by Ranith Sardar.\n",
      "commitDate": "05/09/18 8:33 AM",
      "commitName": "9315db5f5da09c2ef86be168465c16932afa2d85",
      "commitAuthor": "Yiqun Lin",
      "commitDateOld": "03/09/18 1:58 AM",
      "commitNameOld": "780df9034f265a8e602856b34cc21d9be02f5c48",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 2.27,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,43 @@\n   public boolean updateMount(String[] parameters, int i) throws IOException {\n     // Mandatory parameters\n     String mount \u003d parameters[i++];\n     String[] nss \u003d parameters[i++].split(\",\");\n     String dest \u003d parameters[i++];\n \n     // Optional parameters\n     boolean readOnly \u003d false;\n     String owner \u003d null;\n     String group \u003d null;\n     FsPermission mode \u003d null;\n     DestinationOrder order \u003d null;\n     while (i \u003c parameters.length) {\n       if (parameters[i].equals(\"-readonly\")) {\n         readOnly \u003d true;\n       } else if (parameters[i].equals(\"-order\")) {\n         i++;\n         try {\n           order \u003d DestinationOrder.valueOf(parameters[i]);\n         } catch(Exception e) {\n           System.err.println(\"Cannot parse order: \" + parameters[i]);\n         }\n       } else if (parameters[i].equals(\"-owner\")) {\n         i++;\n         owner \u003d parameters[i];\n       } else if (parameters[i].equals(\"-group\")) {\n         i++;\n         group \u003d parameters[i];\n       } else if (parameters[i].equals(\"-mode\")) {\n         i++;\n         short modeValue \u003d Short.parseShort(parameters[i], 8);\n         mode \u003d new FsPermission(modeValue);\n+      } else {\n+        printUsage(\"-update\");\n+        return false;\n       }\n \n       i++;\n     }\n \n     return updateMount(mount, nss, dest, readOnly, order,\n         new ACLEntity(owner, group, mode));\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean updateMount(String[] parameters, int i) throws IOException {\n    // Mandatory parameters\n    String mount \u003d parameters[i++];\n    String[] nss \u003d parameters[i++].split(\",\");\n    String dest \u003d parameters[i++];\n\n    // Optional parameters\n    boolean readOnly \u003d false;\n    String owner \u003d null;\n    String group \u003d null;\n    FsPermission mode \u003d null;\n    DestinationOrder order \u003d null;\n    while (i \u003c parameters.length) {\n      if (parameters[i].equals(\"-readonly\")) {\n        readOnly \u003d true;\n      } else if (parameters[i].equals(\"-order\")) {\n        i++;\n        try {\n          order \u003d DestinationOrder.valueOf(parameters[i]);\n        } catch(Exception e) {\n          System.err.println(\"Cannot parse order: \" + parameters[i]);\n        }\n      } else if (parameters[i].equals(\"-owner\")) {\n        i++;\n        owner \u003d parameters[i];\n      } else if (parameters[i].equals(\"-group\")) {\n        i++;\n        group \u003d parameters[i];\n      } else if (parameters[i].equals(\"-mode\")) {\n        i++;\n        short modeValue \u003d Short.parseShort(parameters[i], 8);\n        mode \u003d new FsPermission(modeValue);\n      } else {\n        printUsage(\"-update\");\n        return false;\n      }\n\n      i++;\n    }\n\n    return updateMount(mount, nss, dest, readOnly, order,\n        new ACLEntity(owner, group, mode));\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/tools/federation/RouterAdmin.java",
      "extendedDetails": {}
    },
    "09c9cf1d43b802dd62b532c3c7be0e21a0c9ad5c": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-13326. RBF: Improve the interfaces to modify and view mount tables. Contributed by Gang Li.\n",
      "commitDate": "26/04/18 1:54 PM",
      "commitName": "09c9cf1d43b802dd62b532c3c7be0e21a0c9ad5c",
      "commitAuthor": "Inigo Goiri",
      "diff": "@@ -0,0 +1,40 @@\n+  public boolean updateMount(String[] parameters, int i) throws IOException {\n+    // Mandatory parameters\n+    String mount \u003d parameters[i++];\n+    String[] nss \u003d parameters[i++].split(\",\");\n+    String dest \u003d parameters[i++];\n+\n+    // Optional parameters\n+    boolean readOnly \u003d false;\n+    String owner \u003d null;\n+    String group \u003d null;\n+    FsPermission mode \u003d null;\n+    DestinationOrder order \u003d null;\n+    while (i \u003c parameters.length) {\n+      if (parameters[i].equals(\"-readonly\")) {\n+        readOnly \u003d true;\n+      } else if (parameters[i].equals(\"-order\")) {\n+        i++;\n+        try {\n+          order \u003d DestinationOrder.valueOf(parameters[i]);\n+        } catch(Exception e) {\n+          System.err.println(\"Cannot parse order: \" + parameters[i]);\n+        }\n+      } else if (parameters[i].equals(\"-owner\")) {\n+        i++;\n+        owner \u003d parameters[i];\n+      } else if (parameters[i].equals(\"-group\")) {\n+        i++;\n+        group \u003d parameters[i];\n+      } else if (parameters[i].equals(\"-mode\")) {\n+        i++;\n+        short modeValue \u003d Short.parseShort(parameters[i], 8);\n+        mode \u003d new FsPermission(modeValue);\n+      }\n+\n+      i++;\n+    }\n+\n+    return updateMount(mount, nss, dest, readOnly, order,\n+        new ACLEntity(owner, group, mode));\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean updateMount(String[] parameters, int i) throws IOException {\n    // Mandatory parameters\n    String mount \u003d parameters[i++];\n    String[] nss \u003d parameters[i++].split(\",\");\n    String dest \u003d parameters[i++];\n\n    // Optional parameters\n    boolean readOnly \u003d false;\n    String owner \u003d null;\n    String group \u003d null;\n    FsPermission mode \u003d null;\n    DestinationOrder order \u003d null;\n    while (i \u003c parameters.length) {\n      if (parameters[i].equals(\"-readonly\")) {\n        readOnly \u003d true;\n      } else if (parameters[i].equals(\"-order\")) {\n        i++;\n        try {\n          order \u003d DestinationOrder.valueOf(parameters[i]);\n        } catch(Exception e) {\n          System.err.println(\"Cannot parse order: \" + parameters[i]);\n        }\n      } else if (parameters[i].equals(\"-owner\")) {\n        i++;\n        owner \u003d parameters[i];\n      } else if (parameters[i].equals(\"-group\")) {\n        i++;\n        group \u003d parameters[i];\n      } else if (parameters[i].equals(\"-mode\")) {\n        i++;\n        short modeValue \u003d Short.parseShort(parameters[i], 8);\n        mode \u003d new FsPermission(modeValue);\n      }\n\n      i++;\n    }\n\n    return updateMount(mount, nss, dest, readOnly, order,\n        new ACLEntity(owner, group, mode));\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/tools/federation/RouterAdmin.java"
    }
  }
}