{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "ContainerManagementProtocolProxy.java",
  "functionName": "getProxy",
  "functionId": "getProxy___containerManagerBindAddr-String__containerId-ContainerId",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/ContainerManagementProtocolProxy.java",
  "functionStartLine": 100,
  "functionEndLine": 143,
  "numCommitsSeen": 10,
  "timeTaken": 2357,
  "changeHistory": [
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "b84fb41bb6ca2d69153cf5bd61f88492538ee713",
    "f44cf99599119b5e989be724eeab447b2dc4fe53",
    "b8f1d1350b1f047a16cd6648d2349df41a989e8f",
    "1a06175440eec7994d6b63b0e5ac8b6532870fb3",
    "243bcd367ff3130d74676280233041f88aca62a5"
  ],
  "changeHistoryShort": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "b84fb41bb6ca2d69153cf5bd61f88492538ee713": "Ybodychange",
    "f44cf99599119b5e989be724eeab447b2dc4fe53": "Ybodychange",
    "b8f1d1350b1f047a16cd6648d2349df41a989e8f": "Ybodychange",
    "1a06175440eec7994d6b63b0e5ac8b6532870fb3": "Ybodychange",
    "243bcd367ff3130d74676280233041f88aca62a5": "Yintroduced"
  },
  "changeHistoryDetails": {
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "31/10/17 1:09 AM",
      "commitNameOld": "c02d2ba50db8a355ea03081c3984b2ea0c375a3f",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 500.63,
      "commitsBetweenForRepo": 4349,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,46 +1,44 @@\n   public synchronized ContainerManagementProtocolProxyData getProxy(\n       String containerManagerBindAddr, ContainerId containerId)\n       throws InvalidToken {\n     \n     // This get call will update the map which is working as LRU cache.\n     ContainerManagementProtocolProxyData proxy \u003d\n         cmProxy.get(containerManagerBindAddr);\n \n     while (proxy !\u003d null\n         \u0026\u0026 !proxy.token.getIdentifier().equals(\n             nmTokenCache.getToken(containerManagerBindAddr).getIdentifier())) {\n-      if (LOG.isDebugEnabled()) {\n-        LOG.debug(\"Refreshing proxy as NMToken got updated for node : \"\n-            + containerManagerBindAddr);\n-      }\n+      LOG.debug(\"Refreshing proxy as NMToken got updated for node : {}\",\n+          containerManagerBindAddr);\n       // Token is updated. check if anyone has already tried closing it.\n       if (!proxy.scheduledForClose) {\n         // try closing the proxy. Here if someone is already using it\n         // then we might not close it. In which case we will wait.\n         removeProxy(proxy);\n       } else {\n         try {\n           this.wait();\n         } catch (InterruptedException e) {\n           e.printStackTrace();\n         }\n       }\n       if (proxy.activeCallers \u003c 0) {\n         proxy \u003d cmProxy.get(containerManagerBindAddr);\n       }\n     }\n     \n     if (proxy \u003d\u003d null) {\n       proxy \u003d\n           new ContainerManagementProtocolProxyData(rpc, containerManagerBindAddr,\n               containerId, nmTokenCache.getToken(containerManagerBindAddr));\n       if (maxConnectedNMs \u003e 0) {\n         addProxyToCache(containerManagerBindAddr, proxy);\n       }\n     }\n     // This is to track active users of this proxy.\n     proxy.activeCallers++;\n     updateLRUCache(containerManagerBindAddr);\n     \n     return proxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ContainerManagementProtocolProxyData getProxy(\n      String containerManagerBindAddr, ContainerId containerId)\n      throws InvalidToken {\n    \n    // This get call will update the map which is working as LRU cache.\n    ContainerManagementProtocolProxyData proxy \u003d\n        cmProxy.get(containerManagerBindAddr);\n\n    while (proxy !\u003d null\n        \u0026\u0026 !proxy.token.getIdentifier().equals(\n            nmTokenCache.getToken(containerManagerBindAddr).getIdentifier())) {\n      LOG.debug(\"Refreshing proxy as NMToken got updated for node : {}\",\n          containerManagerBindAddr);\n      // Token is updated. check if anyone has already tried closing it.\n      if (!proxy.scheduledForClose) {\n        // try closing the proxy. Here if someone is already using it\n        // then we might not close it. In which case we will wait.\n        removeProxy(proxy);\n      } else {\n        try {\n          this.wait();\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n      }\n      if (proxy.activeCallers \u003c 0) {\n        proxy \u003d cmProxy.get(containerManagerBindAddr);\n      }\n    }\n    \n    if (proxy \u003d\u003d null) {\n      proxy \u003d\n          new ContainerManagementProtocolProxyData(rpc, containerManagerBindAddr,\n              containerId, nmTokenCache.getToken(containerManagerBindAddr));\n      if (maxConnectedNMs \u003e 0) {\n        addProxyToCache(containerManagerBindAddr, proxy);\n      }\n    }\n    // This is to track active users of this proxy.\n    proxy.activeCallers++;\n    updateLRUCache(containerManagerBindAddr);\n    \n    return proxy;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/ContainerManagementProtocolProxy.java",
      "extendedDetails": {}
    },
    "b84fb41bb6ca2d69153cf5bd61f88492538ee713": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4115. Reduce loglevel of ContainerManagementProtocolProxy to Debug (adhoot via rkanter)\n",
      "commitDate": "11/09/15 11:46 AM",
      "commitName": "b84fb41bb6ca2d69153cf5bd61f88492538ee713",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "20/04/15 10:38 AM",
      "commitNameOld": "f967fd2f21791c5c4a5a090cc14ee88d155d2e2b",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 144.05,
      "commitsBetweenForRepo": 1052,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,44 +1,46 @@\n   public synchronized ContainerManagementProtocolProxyData getProxy(\n       String containerManagerBindAddr, ContainerId containerId)\n       throws InvalidToken {\n     \n     // This get call will update the map which is working as LRU cache.\n     ContainerManagementProtocolProxyData proxy \u003d\n         cmProxy.get(containerManagerBindAddr);\n \n     while (proxy !\u003d null\n         \u0026\u0026 !proxy.token.getIdentifier().equals(\n             nmTokenCache.getToken(containerManagerBindAddr).getIdentifier())) {\n-      LOG.info(\"Refreshing proxy as NMToken got updated for node : \"\n-          + containerManagerBindAddr);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Refreshing proxy as NMToken got updated for node : \"\n+            + containerManagerBindAddr);\n+      }\n       // Token is updated. check if anyone has already tried closing it.\n       if (!proxy.scheduledForClose) {\n         // try closing the proxy. Here if someone is already using it\n         // then we might not close it. In which case we will wait.\n         removeProxy(proxy);\n       } else {\n         try {\n           this.wait();\n         } catch (InterruptedException e) {\n           e.printStackTrace();\n         }\n       }\n       if (proxy.activeCallers \u003c 0) {\n         proxy \u003d cmProxy.get(containerManagerBindAddr);\n       }\n     }\n     \n     if (proxy \u003d\u003d null) {\n       proxy \u003d\n           new ContainerManagementProtocolProxyData(rpc, containerManagerBindAddr,\n               containerId, nmTokenCache.getToken(containerManagerBindAddr));\n       if (maxConnectedNMs \u003e 0) {\n         addProxyToCache(containerManagerBindAddr, proxy);\n       }\n     }\n     // This is to track active users of this proxy.\n     proxy.activeCallers++;\n     updateLRUCache(containerManagerBindAddr);\n     \n     return proxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ContainerManagementProtocolProxyData getProxy(\n      String containerManagerBindAddr, ContainerId containerId)\n      throws InvalidToken {\n    \n    // This get call will update the map which is working as LRU cache.\n    ContainerManagementProtocolProxyData proxy \u003d\n        cmProxy.get(containerManagerBindAddr);\n\n    while (proxy !\u003d null\n        \u0026\u0026 !proxy.token.getIdentifier().equals(\n            nmTokenCache.getToken(containerManagerBindAddr).getIdentifier())) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Refreshing proxy as NMToken got updated for node : \"\n            + containerManagerBindAddr);\n      }\n      // Token is updated. check if anyone has already tried closing it.\n      if (!proxy.scheduledForClose) {\n        // try closing the proxy. Here if someone is already using it\n        // then we might not close it. In which case we will wait.\n        removeProxy(proxy);\n      } else {\n        try {\n          this.wait();\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n      }\n      if (proxy.activeCallers \u003c 0) {\n        proxy \u003d cmProxy.get(containerManagerBindAddr);\n      }\n    }\n    \n    if (proxy \u003d\u003d null) {\n      proxy \u003d\n          new ContainerManagementProtocolProxyData(rpc, containerManagerBindAddr,\n              containerId, nmTokenCache.getToken(containerManagerBindAddr));\n      if (maxConnectedNMs \u003e 0) {\n        addProxyToCache(containerManagerBindAddr, proxy);\n      }\n    }\n    // This is to track active users of this proxy.\n    proxy.activeCallers++;\n    updateLRUCache(containerManagerBindAddr);\n    \n    return proxy;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/ContainerManagementProtocolProxy.java",
      "extendedDetails": {}
    },
    "f44cf99599119b5e989be724eeab447b2dc4fe53": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2314. Disable ContainerManagementProtocolProxy cache by default to prevent creating thousands of threads in a large cluster. Contributed by Jason Lowe\n",
      "commitDate": "24/10/14 11:05 PM",
      "commitName": "f44cf99599119b5e989be724eeab447b2dc4fe53",
      "commitAuthor": "Jian He",
      "commitDateOld": "01/10/14 4:50 PM",
      "commitNameOld": "0708827a935d190d439854e08bb5a655d7daa606",
      "commitAuthorOld": "junping_du",
      "daysBetweenCommits": 23.26,
      "commitsBetweenForRepo": 197,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,44 @@\n   public synchronized ContainerManagementProtocolProxyData getProxy(\n       String containerManagerBindAddr, ContainerId containerId)\n       throws InvalidToken {\n     \n     // This get call will update the map which is working as LRU cache.\n     ContainerManagementProtocolProxyData proxy \u003d\n         cmProxy.get(containerManagerBindAddr);\n \n     while (proxy !\u003d null\n         \u0026\u0026 !proxy.token.getIdentifier().equals(\n             nmTokenCache.getToken(containerManagerBindAddr).getIdentifier())) {\n       LOG.info(\"Refreshing proxy as NMToken got updated for node : \"\n           + containerManagerBindAddr);\n       // Token is updated. check if anyone has already tried closing it.\n       if (!proxy.scheduledForClose) {\n         // try closing the proxy. Here if someone is already using it\n         // then we might not close it. In which case we will wait.\n         removeProxy(proxy);\n       } else {\n         try {\n           this.wait();\n         } catch (InterruptedException e) {\n           e.printStackTrace();\n         }\n       }\n       if (proxy.activeCallers \u003c 0) {\n         proxy \u003d cmProxy.get(containerManagerBindAddr);\n       }\n     }\n     \n     if (proxy \u003d\u003d null) {\n       proxy \u003d\n           new ContainerManagementProtocolProxyData(rpc, containerManagerBindAddr,\n               containerId, nmTokenCache.getToken(containerManagerBindAddr));\n-      if (cmProxy.size() \u003e maxConnectedNMs) {\n-        // Number of existing proxy exceed the limit.\n-        String cmAddr \u003d cmProxy.keySet().iterator().next();\n-        removeProxy(cmProxy.get(cmAddr));\n+      if (maxConnectedNMs \u003e 0) {\n+        addProxyToCache(containerManagerBindAddr, proxy);\n       }\n-      \n-      cmProxy.put(containerManagerBindAddr, proxy);\n     }\n     // This is to track active users of this proxy.\n     proxy.activeCallers++;\n     updateLRUCache(containerManagerBindAddr);\n     \n     return proxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ContainerManagementProtocolProxyData getProxy(\n      String containerManagerBindAddr, ContainerId containerId)\n      throws InvalidToken {\n    \n    // This get call will update the map which is working as LRU cache.\n    ContainerManagementProtocolProxyData proxy \u003d\n        cmProxy.get(containerManagerBindAddr);\n\n    while (proxy !\u003d null\n        \u0026\u0026 !proxy.token.getIdentifier().equals(\n            nmTokenCache.getToken(containerManagerBindAddr).getIdentifier())) {\n      LOG.info(\"Refreshing proxy as NMToken got updated for node : \"\n          + containerManagerBindAddr);\n      // Token is updated. check if anyone has already tried closing it.\n      if (!proxy.scheduledForClose) {\n        // try closing the proxy. Here if someone is already using it\n        // then we might not close it. In which case we will wait.\n        removeProxy(proxy);\n      } else {\n        try {\n          this.wait();\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n      }\n      if (proxy.activeCallers \u003c 0) {\n        proxy \u003d cmProxy.get(containerManagerBindAddr);\n      }\n    }\n    \n    if (proxy \u003d\u003d null) {\n      proxy \u003d\n          new ContainerManagementProtocolProxyData(rpc, containerManagerBindAddr,\n              containerId, nmTokenCache.getToken(containerManagerBindAddr));\n      if (maxConnectedNMs \u003e 0) {\n        addProxyToCache(containerManagerBindAddr, proxy);\n      }\n    }\n    // This is to track active users of this proxy.\n    proxy.activeCallers++;\n    updateLRUCache(containerManagerBindAddr);\n    \n    return proxy;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/ContainerManagementProtocolProxy.java",
      "extendedDetails": {}
    },
    "b8f1d1350b1f047a16cd6648d2349df41a989e8f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1321. Changed NMTokenCache to support both singleton and an instance usage. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1537334 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/10/13 3:37 PM",
      "commitName": "b8f1d1350b1f047a16cd6648d2349df41a989e8f",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "20/06/13 5:08 PM",
      "commitNameOld": "1a06175440eec7994d6b63b0e5ac8b6532870fb3",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 131.94,
      "commitsBetweenForRepo": 801,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   public synchronized ContainerManagementProtocolProxyData getProxy(\n       String containerManagerBindAddr, ContainerId containerId)\n       throws InvalidToken {\n     \n     // This get call will update the map which is working as LRU cache.\n     ContainerManagementProtocolProxyData proxy \u003d\n         cmProxy.get(containerManagerBindAddr);\n \n     while (proxy !\u003d null\n         \u0026\u0026 !proxy.token.getIdentifier().equals(\n-            NMTokenCache.getNMToken(containerManagerBindAddr).getIdentifier())) {\n+            nmTokenCache.getToken(containerManagerBindAddr).getIdentifier())) {\n       LOG.info(\"Refreshing proxy as NMToken got updated for node : \"\n           + containerManagerBindAddr);\n       // Token is updated. check if anyone has already tried closing it.\n       if (!proxy.scheduledForClose) {\n         // try closing the proxy. Here if someone is already using it\n         // then we might not close it. In which case we will wait.\n         removeProxy(proxy);\n       } else {\n         try {\n           this.wait();\n         } catch (InterruptedException e) {\n           e.printStackTrace();\n         }\n       }\n       if (proxy.activeCallers \u003c 0) {\n         proxy \u003d cmProxy.get(containerManagerBindAddr);\n       }\n     }\n     \n     if (proxy \u003d\u003d null) {\n       proxy \u003d\n           new ContainerManagementProtocolProxyData(rpc, containerManagerBindAddr,\n-              containerId, NMTokenCache.getNMToken(containerManagerBindAddr));\n+              containerId, nmTokenCache.getToken(containerManagerBindAddr));\n       if (cmProxy.size() \u003e maxConnectedNMs) {\n         // Number of existing proxy exceed the limit.\n         String cmAddr \u003d cmProxy.keySet().iterator().next();\n         removeProxy(cmProxy.get(cmAddr));\n       }\n       \n       cmProxy.put(containerManagerBindAddr, proxy);\n     }\n     // This is to track active users of this proxy.\n     proxy.activeCallers++;\n     updateLRUCache(containerManagerBindAddr);\n     \n     return proxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ContainerManagementProtocolProxyData getProxy(\n      String containerManagerBindAddr, ContainerId containerId)\n      throws InvalidToken {\n    \n    // This get call will update the map which is working as LRU cache.\n    ContainerManagementProtocolProxyData proxy \u003d\n        cmProxy.get(containerManagerBindAddr);\n\n    while (proxy !\u003d null\n        \u0026\u0026 !proxy.token.getIdentifier().equals(\n            nmTokenCache.getToken(containerManagerBindAddr).getIdentifier())) {\n      LOG.info(\"Refreshing proxy as NMToken got updated for node : \"\n          + containerManagerBindAddr);\n      // Token is updated. check if anyone has already tried closing it.\n      if (!proxy.scheduledForClose) {\n        // try closing the proxy. Here if someone is already using it\n        // then we might not close it. In which case we will wait.\n        removeProxy(proxy);\n      } else {\n        try {\n          this.wait();\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n      }\n      if (proxy.activeCallers \u003c 0) {\n        proxy \u003d cmProxy.get(containerManagerBindAddr);\n      }\n    }\n    \n    if (proxy \u003d\u003d null) {\n      proxy \u003d\n          new ContainerManagementProtocolProxyData(rpc, containerManagerBindAddr,\n              containerId, nmTokenCache.getToken(containerManagerBindAddr));\n      if (cmProxy.size() \u003e maxConnectedNMs) {\n        // Number of existing proxy exceed the limit.\n        String cmAddr \u003d cmProxy.keySet().iterator().next();\n        removeProxy(cmProxy.get(cmAddr));\n      }\n      \n      cmProxy.put(containerManagerBindAddr, proxy);\n    }\n    // This is to track active users of this proxy.\n    proxy.activeCallers++;\n    updateLRUCache(containerManagerBindAddr);\n    \n    return proxy;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/ContainerManagementProtocolProxy.java",
      "extendedDetails": {}
    },
    "1a06175440eec7994d6b63b0e5ac8b6532870fb3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-851. Share NMTokens using NMTokenCache (api-based) between AMRMClient and NMClient instead of memory based approach which is used currently. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1495247 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/06/13 5:08 PM",
      "commitName": "1a06175440eec7994d6b63b0e5ac8b6532870fb3",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "18/06/13 4:19 PM",
      "commitNameOld": "243bcd367ff3130d74676280233041f88aca62a5",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 2.03,
      "commitsBetweenForRepo": 21,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,48 @@\n   public synchronized ContainerManagementProtocolProxyData getProxy(\n       String containerManagerBindAddr, ContainerId containerId)\n       throws InvalidToken {\n     \n     // This get call will update the map which is working as LRU cache.\n     ContainerManagementProtocolProxyData proxy \u003d\n         cmProxy.get(containerManagerBindAddr);\n-    \n+\n     while (proxy !\u003d null\n         \u0026\u0026 !proxy.token.getIdentifier().equals(\n-            nmTokens.get(containerManagerBindAddr).getIdentifier())) {\n+            NMTokenCache.getNMToken(containerManagerBindAddr).getIdentifier())) {\n       LOG.info(\"Refreshing proxy as NMToken got updated for node : \"\n           + containerManagerBindAddr);\n       // Token is updated. check if anyone has already tried closing it.\n       if (!proxy.scheduledForClose) {\n         // try closing the proxy. Here if someone is already using it\n         // then we might not close it. In which case we will wait.\n         removeProxy(proxy);\n       } else {\n         try {\n           this.wait();\n         } catch (InterruptedException e) {\n           e.printStackTrace();\n         }\n       }\n       if (proxy.activeCallers \u003c 0) {\n         proxy \u003d cmProxy.get(containerManagerBindAddr);\n       }\n     }\n     \n     if (proxy \u003d\u003d null) {\n       proxy \u003d\n           new ContainerManagementProtocolProxyData(rpc, containerManagerBindAddr,\n-              containerId, nmTokens.get(containerManagerBindAddr));\n+              containerId, NMTokenCache.getNMToken(containerManagerBindAddr));\n       if (cmProxy.size() \u003e maxConnectedNMs) {\n         // Number of existing proxy exceed the limit.\n         String cmAddr \u003d cmProxy.keySet().iterator().next();\n         removeProxy(cmProxy.get(cmAddr));\n       }\n       \n       cmProxy.put(containerManagerBindAddr, proxy);\n     }\n     // This is to track active users of this proxy.\n     proxy.activeCallers++;\n     updateLRUCache(containerManagerBindAddr);\n     \n     return proxy;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ContainerManagementProtocolProxyData getProxy(\n      String containerManagerBindAddr, ContainerId containerId)\n      throws InvalidToken {\n    \n    // This get call will update the map which is working as LRU cache.\n    ContainerManagementProtocolProxyData proxy \u003d\n        cmProxy.get(containerManagerBindAddr);\n\n    while (proxy !\u003d null\n        \u0026\u0026 !proxy.token.getIdentifier().equals(\n            NMTokenCache.getNMToken(containerManagerBindAddr).getIdentifier())) {\n      LOG.info(\"Refreshing proxy as NMToken got updated for node : \"\n          + containerManagerBindAddr);\n      // Token is updated. check if anyone has already tried closing it.\n      if (!proxy.scheduledForClose) {\n        // try closing the proxy. Here if someone is already using it\n        // then we might not close it. In which case we will wait.\n        removeProxy(proxy);\n      } else {\n        try {\n          this.wait();\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n      }\n      if (proxy.activeCallers \u003c 0) {\n        proxy \u003d cmProxy.get(containerManagerBindAddr);\n      }\n    }\n    \n    if (proxy \u003d\u003d null) {\n      proxy \u003d\n          new ContainerManagementProtocolProxyData(rpc, containerManagerBindAddr,\n              containerId, NMTokenCache.getNMToken(containerManagerBindAddr));\n      if (cmProxy.size() \u003e maxConnectedNMs) {\n        // Number of existing proxy exceed the limit.\n        String cmAddr \u003d cmProxy.keySet().iterator().next();\n        removeProxy(cmProxy.get(cmAddr));\n      }\n      \n      cmProxy.put(containerManagerBindAddr, proxy);\n    }\n    // This is to track active users of this proxy.\n    proxy.activeCallers++;\n    updateLRUCache(containerManagerBindAddr);\n    \n    return proxy;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/ContainerManagementProtocolProxy.java",
      "extendedDetails": {}
    },
    "243bcd367ff3130d74676280233041f88aca62a5": {
      "type": "Yintroduced",
      "commitMessage": "YARN-694. Starting to use NMTokens to authenticate all communication with NodeManagers. Contributed by Omkar Vinit Joshi.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1494369 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/06/13 4:19 PM",
      "commitName": "243bcd367ff3130d74676280233041f88aca62a5",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,48 @@\n+  public synchronized ContainerManagementProtocolProxyData getProxy(\n+      String containerManagerBindAddr, ContainerId containerId)\n+      throws InvalidToken {\n+    \n+    // This get call will update the map which is working as LRU cache.\n+    ContainerManagementProtocolProxyData proxy \u003d\n+        cmProxy.get(containerManagerBindAddr);\n+    \n+    while (proxy !\u003d null\n+        \u0026\u0026 !proxy.token.getIdentifier().equals(\n+            nmTokens.get(containerManagerBindAddr).getIdentifier())) {\n+      LOG.info(\"Refreshing proxy as NMToken got updated for node : \"\n+          + containerManagerBindAddr);\n+      // Token is updated. check if anyone has already tried closing it.\n+      if (!proxy.scheduledForClose) {\n+        // try closing the proxy. Here if someone is already using it\n+        // then we might not close it. In which case we will wait.\n+        removeProxy(proxy);\n+      } else {\n+        try {\n+          this.wait();\n+        } catch (InterruptedException e) {\n+          e.printStackTrace();\n+        }\n+      }\n+      if (proxy.activeCallers \u003c 0) {\n+        proxy \u003d cmProxy.get(containerManagerBindAddr);\n+      }\n+    }\n+    \n+    if (proxy \u003d\u003d null) {\n+      proxy \u003d\n+          new ContainerManagementProtocolProxyData(rpc, containerManagerBindAddr,\n+              containerId, nmTokens.get(containerManagerBindAddr));\n+      if (cmProxy.size() \u003e maxConnectedNMs) {\n+        // Number of existing proxy exceed the limit.\n+        String cmAddr \u003d cmProxy.keySet().iterator().next();\n+        removeProxy(cmProxy.get(cmAddr));\n+      }\n+      \n+      cmProxy.put(containerManagerBindAddr, proxy);\n+    }\n+    // This is to track active users of this proxy.\n+    proxy.activeCallers++;\n+    updateLRUCache(containerManagerBindAddr);\n+    \n+    return proxy;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized ContainerManagementProtocolProxyData getProxy(\n      String containerManagerBindAddr, ContainerId containerId)\n      throws InvalidToken {\n    \n    // This get call will update the map which is working as LRU cache.\n    ContainerManagementProtocolProxyData proxy \u003d\n        cmProxy.get(containerManagerBindAddr);\n    \n    while (proxy !\u003d null\n        \u0026\u0026 !proxy.token.getIdentifier().equals(\n            nmTokens.get(containerManagerBindAddr).getIdentifier())) {\n      LOG.info(\"Refreshing proxy as NMToken got updated for node : \"\n          + containerManagerBindAddr);\n      // Token is updated. check if anyone has already tried closing it.\n      if (!proxy.scheduledForClose) {\n        // try closing the proxy. Here if someone is already using it\n        // then we might not close it. In which case we will wait.\n        removeProxy(proxy);\n      } else {\n        try {\n          this.wait();\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n      }\n      if (proxy.activeCallers \u003c 0) {\n        proxy \u003d cmProxy.get(containerManagerBindAddr);\n      }\n    }\n    \n    if (proxy \u003d\u003d null) {\n      proxy \u003d\n          new ContainerManagementProtocolProxyData(rpc, containerManagerBindAddr,\n              containerId, nmTokens.get(containerManagerBindAddr));\n      if (cmProxy.size() \u003e maxConnectedNMs) {\n        // Number of existing proxy exceed the limit.\n        String cmAddr \u003d cmProxy.keySet().iterator().next();\n        removeProxy(cmProxy.get(cmAddr));\n      }\n      \n      cmProxy.put(containerManagerBindAddr, proxy);\n    }\n    // This is to track active users of this proxy.\n    proxy.activeCallers++;\n    updateLRUCache(containerManagerBindAddr);\n    \n    return proxy;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-client/src/main/java/org/apache/hadoop/yarn/client/api/impl/ContainerManagementProtocolProxy.java"
    }
  }
}