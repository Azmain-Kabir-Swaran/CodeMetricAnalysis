{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "DockerLinuxContainerRuntime.java",
  "functionName": "signalContainer",
  "functionId": "signalContainer___ctx-ContainerRuntimeContext",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
  "functionStartLine": 950,
  "functionEndLine": 968,
  "numCommitsSeen": 91,
  "timeTaken": 4916,
  "changeHistory": [
    "bf8a1750e99cfbfa76021ce51b6514c74c06f498",
    "5cc2541a163591181b80bf2ec42c1e7e7f8929f5",
    "5f11288e41fca2e414dcbea130c7702e29d4d610",
    "3d65dbe032e202361d613344ccc6d9c5f99ba395",
    "e5e1851d803bf8d8b96fec1b5c0058014e9329d0",
    "e5e558b0a34968eaffdd243ce605ef26346c5e85",
    "9d4d30243b0fc9630da51a2c17b543ef671d035c",
    "059caf99891943d9587cac19b48e82efbed06b2d",
    "3e6fce91a471b4a5099de109582e7c6417e8a822"
  ],
  "changeHistoryShort": {
    "bf8a1750e99cfbfa76021ce51b6514c74c06f498": "Ybodychange",
    "5cc2541a163591181b80bf2ec42c1e7e7f8929f5": "Ybodychange",
    "5f11288e41fca2e414dcbea130c7702e29d4d610": "Ybodychange",
    "3d65dbe032e202361d613344ccc6d9c5f99ba395": "Ybodychange",
    "e5e1851d803bf8d8b96fec1b5c0058014e9329d0": "Ybodychange",
    "e5e558b0a34968eaffdd243ce605ef26346c5e85": "Ybodychange",
    "9d4d30243b0fc9630da51a2c17b543ef671d035c": "Ybodychange",
    "059caf99891943d9587cac19b48e82efbed06b2d": "Ybodychange",
    "3e6fce91a471b4a5099de109582e7c6417e8a822": "Yintroduced"
  },
  "changeHistoryDetails": {
    "bf8a1750e99cfbfa76021ce51b6514c74c06f498": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8706. Updated docker container stop logic to avoid double kill.\n           Contributed by Chandni Singh\n",
      "commitDate": "07/09/18 5:18 PM",
      "commitName": "bf8a1750e99cfbfa76021ce51b6514c74c06f498",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "05/09/18 5:47 AM",
      "commitNameOld": "dffb7bfe6cd2292162f08ec0bded736bc5194c3f",
      "commitAuthorOld": "Shane Kumpf",
      "daysBetweenCommits": 2.48,
      "commitsBetweenForRepo": 27,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,19 +1,19 @@\n   public void signalContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     ContainerExecutor.Signal signal \u003d ctx.getExecutionAttribute(SIGNAL);\n     Map\u003cString, String\u003e env \u003d\n         ctx.getContainer().getLaunchContext().getEnvironment();\n     try {\n       if (ContainerExecutor.Signal.NULL.equals(signal)) {\n         executeLivelinessCheck(ctx);\n       } else if (ContainerExecutor.Signal.TERM.equals(signal)) {\n-        String containerId \u003d ctx.getContainer().getContainerId().toString();\n+        ContainerId containerId \u003d ctx.getContainer().getContainerId();\n         handleContainerStop(containerId, env);\n       } else {\n         handleContainerKill(ctx, env, signal);\n       }\n     } catch (ContainerExecutionException e) {\n       throw new ContainerExecutionException(\"Signal docker container failed\",\n           e.getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void signalContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    ContainerExecutor.Signal signal \u003d ctx.getExecutionAttribute(SIGNAL);\n    Map\u003cString, String\u003e env \u003d\n        ctx.getContainer().getLaunchContext().getEnvironment();\n    try {\n      if (ContainerExecutor.Signal.NULL.equals(signal)) {\n        executeLivelinessCheck(ctx);\n      } else if (ContainerExecutor.Signal.TERM.equals(signal)) {\n        ContainerId containerId \u003d ctx.getContainer().getContainerId();\n        handleContainerStop(containerId, env);\n      } else {\n        handleContainerKill(ctx, env, signal);\n      }\n    } catch (ContainerExecutionException e) {\n      throw new ContainerExecutionException(\"Signal docker container failed\",\n          e.getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "5cc2541a163591181b80bf2ec42c1e7e7f8929f5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8465. Fixed docker container status for node manager restart.\n           Contributed by Shane Kumpf\n",
      "commitDate": "02/07/18 10:37 AM",
      "commitName": "5cc2541a163591181b80bf2ec42c1e7e7f8929f5",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "13/06/18 4:24 PM",
      "commitNameOld": "22994889dc449f966fb6462a3ac3d3bbaee3ac6a",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 18.76,
      "commitsBetweenForRepo": 89,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,20 +1,19 @@\n   public void signalContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     ContainerExecutor.Signal signal \u003d ctx.getExecutionAttribute(SIGNAL);\n     Map\u003cString, String\u003e env \u003d\n         ctx.getContainer().getLaunchContext().getEnvironment();\n     try {\n       if (ContainerExecutor.Signal.NULL.equals(signal)) {\n         executeLivelinessCheck(ctx);\n       } else if (ContainerExecutor.Signal.TERM.equals(signal)) {\n         String containerId \u003d ctx.getContainer().getContainerId().toString();\n         handleContainerStop(containerId, env);\n       } else {\n         handleContainerKill(ctx, env, signal);\n       }\n     } catch (ContainerExecutionException e) {\n-      LOG.warn(\"Signal docker container failed. Exception: \", e);\n       throw new ContainerExecutionException(\"Signal docker container failed\",\n           e.getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void signalContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    ContainerExecutor.Signal signal \u003d ctx.getExecutionAttribute(SIGNAL);\n    Map\u003cString, String\u003e env \u003d\n        ctx.getContainer().getLaunchContext().getEnvironment();\n    try {\n      if (ContainerExecutor.Signal.NULL.equals(signal)) {\n        executeLivelinessCheck(ctx);\n      } else if (ContainerExecutor.Signal.TERM.equals(signal)) {\n        String containerId \u003d ctx.getContainer().getContainerId().toString();\n        handleContainerStop(containerId, env);\n      } else {\n        handleContainerKill(ctx, env, signal);\n      }\n    } catch (ContainerExecutionException e) {\n      throw new ContainerExecutionException(\"Signal docker container failed\",\n          e.getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "5f11288e41fca2e414dcbea130c7702e29d4d610": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8206. Sending a kill does not immediately kill docker containers. Contributed by Eric Badger\n",
      "commitDate": "22/05/18 7:27 AM",
      "commitName": "5f11288e41fca2e414dcbea130c7702e29d4d610",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "17/05/18 2:29 PM",
      "commitNameOld": "d45a0b7d73519acb78cd94ac3186bd8481f6c13e",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 4.71,
      "commitsBetweenForRepo": 25,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,20 @@\n   public void signalContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     ContainerExecutor.Signal signal \u003d ctx.getExecutionAttribute(SIGNAL);\n-    String containerId \u003d ctx.getContainer().getContainerId().toString();\n     Map\u003cString, String\u003e env \u003d\n         ctx.getContainer().getLaunchContext().getEnvironment();\n     try {\n       if (ContainerExecutor.Signal.NULL.equals(signal)) {\n         executeLivelinessCheck(ctx);\n+      } else if (ContainerExecutor.Signal.TERM.equals(signal)) {\n+        String containerId \u003d ctx.getContainer().getContainerId().toString();\n+        handleContainerStop(containerId, env);\n       } else {\n-        if (ContainerExecutor.Signal.KILL.equals(signal)\n-            || ContainerExecutor.Signal.TERM.equals(signal)) {\n-          handleContainerStop(containerId, env);\n-        } else {\n-          handleContainerKill(containerId, env, signal);\n-        }\n+        handleContainerKill(ctx, env, signal);\n       }\n     } catch (ContainerExecutionException e) {\n       LOG.warn(\"Signal docker container failed. Exception: \", e);\n       throw new ContainerExecutionException(\"Signal docker container failed\",\n           e.getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void signalContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    ContainerExecutor.Signal signal \u003d ctx.getExecutionAttribute(SIGNAL);\n    Map\u003cString, String\u003e env \u003d\n        ctx.getContainer().getLaunchContext().getEnvironment();\n    try {\n      if (ContainerExecutor.Signal.NULL.equals(signal)) {\n        executeLivelinessCheck(ctx);\n      } else if (ContainerExecutor.Signal.TERM.equals(signal)) {\n        String containerId \u003d ctx.getContainer().getContainerId().toString();\n        handleContainerStop(containerId, env);\n      } else {\n        handleContainerKill(ctx, env, signal);\n      }\n    } catch (ContainerExecutionException e) {\n      LOG.warn(\"Signal docker container failed. Exception: \", e);\n      throw new ContainerExecutionException(\"Signal docker container failed\",\n          e.getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "3d65dbe032e202361d613344ccc6d9c5f99ba395": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5366. Improve signal handling and delete delay for Docker on Yarn.\n           (Contributed by Shane Kumpf)\n",
      "commitDate": "12/01/18 10:41 AM",
      "commitName": "3d65dbe032e202361d613344ccc6d9c5f99ba395",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "01/12/17 12:06 AM",
      "commitNameOld": "556aea3f367bdbd4e4db601bea0ca9bf2adde063",
      "commitAuthorOld": "Sunil G",
      "daysBetweenCommits": 42.44,
      "commitsBetweenForRepo": 239,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,23 @@\n   public void signalContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     ContainerExecutor.Signal signal \u003d ctx.getExecutionAttribute(SIGNAL);\n-\n-    PrivilegedOperation privOp \u003d null;\n-    // Handle liveliness checks, send null signal to pid\n-    if(ContainerExecutor.Signal.NULL.equals(signal)) {\n-      privOp \u003d new PrivilegedOperation(\n-          PrivilegedOperation.OperationType.SIGNAL_CONTAINER);\n-      privOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n-          ctx.getExecutionAttribute(USER),\n-          Integer.toString(PrivilegedOperation.RunAsUserCommand\n-              .SIGNAL_CONTAINER.getValue()),\n-          ctx.getExecutionAttribute(PID),\n-          Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));\n-\n-    // All other signals handled as docker stop\n-    } else {\n-      String containerId \u003d ctx.getContainer().getContainerId().toString();\n-      DockerStopCommand stopCommand \u003d new DockerStopCommand(containerId);\n-      String commandFile \u003d dockerClient.writeCommandToTempFile(stopCommand,\n-          containerId);\n-      privOp \u003d new PrivilegedOperation(\n-          PrivilegedOperation.OperationType.RUN_DOCKER_CMD);\n-      privOp.appendArgs(commandFile);\n-    }\n-\n-    //Some failures here are acceptable. Let the calling executor decide.\n-    privOp.disableFailureLogging();\n-\n+    String containerId \u003d ctx.getContainer().getContainerId().toString();\n+    Map\u003cString, String\u003e env \u003d\n+        ctx.getContainer().getLaunchContext().getEnvironment();\n     try {\n-      privilegedOperationExecutor.executePrivilegedOperation(null,\n-          privOp, null, null, false, false);\n-    } catch (PrivilegedOperationException e) {\n-      throw new ContainerExecutionException(\"Signal container failed\", e\n-          .getExitCode(), e.getOutput(), e.getErrorOutput());\n+      if (ContainerExecutor.Signal.NULL.equals(signal)) {\n+        executeLivelinessCheck(ctx);\n+      } else {\n+        if (ContainerExecutor.Signal.KILL.equals(signal)\n+            || ContainerExecutor.Signal.TERM.equals(signal)) {\n+          handleContainerStop(containerId, env);\n+        } else {\n+          handleContainerKill(containerId, env, signal);\n+        }\n+      }\n+    } catch (ContainerExecutionException e) {\n+      LOG.warn(\"Signal docker container failed. Exception: \", e);\n+      throw new ContainerExecutionException(\"Signal docker container failed\",\n+          e.getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void signalContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    ContainerExecutor.Signal signal \u003d ctx.getExecutionAttribute(SIGNAL);\n    String containerId \u003d ctx.getContainer().getContainerId().toString();\n    Map\u003cString, String\u003e env \u003d\n        ctx.getContainer().getLaunchContext().getEnvironment();\n    try {\n      if (ContainerExecutor.Signal.NULL.equals(signal)) {\n        executeLivelinessCheck(ctx);\n      } else {\n        if (ContainerExecutor.Signal.KILL.equals(signal)\n            || ContainerExecutor.Signal.TERM.equals(signal)) {\n          handleContainerStop(containerId, env);\n        } else {\n          handleContainerKill(containerId, env, signal);\n        }\n      }\n    } catch (ContainerExecutionException e) {\n      LOG.warn(\"Signal docker container failed. Exception: \", e);\n      throw new ContainerExecutionException(\"Signal docker container failed\",\n          e.getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "e5e1851d803bf8d8b96fec1b5c0058014e9329d0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7034. DefaultLinuxContainerRuntime and DockerLinuxContainerRuntime sends client environment variables to container-executor. Contributed by Miklos Szegedi.\n",
      "commitDate": "21/09/17 2:01 PM",
      "commitName": "e5e1851d803bf8d8b96fec1b5c0058014e9329d0",
      "commitAuthor": "Junping Du",
      "commitDateOld": "21/09/17 6:38 AM",
      "commitNameOld": "10d7493587643b52cee5fde87eca9ef99c422a70",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 0.31,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,40 +1,38 @@\n   public void signalContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n-    Container container \u003d ctx.getContainer();\n     ContainerExecutor.Signal signal \u003d ctx.getExecutionAttribute(SIGNAL);\n \n     PrivilegedOperation privOp \u003d null;\n     // Handle liveliness checks, send null signal to pid\n     if(ContainerExecutor.Signal.NULL.equals(signal)) {\n       privOp \u003d new PrivilegedOperation(\n           PrivilegedOperation.OperationType.SIGNAL_CONTAINER);\n       privOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n           ctx.getExecutionAttribute(USER),\n           Integer.toString(PrivilegedOperation.RunAsUserCommand\n               .SIGNAL_CONTAINER.getValue()),\n           ctx.getExecutionAttribute(PID),\n           Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));\n \n     // All other signals handled as docker stop\n     } else {\n       String containerId \u003d ctx.getContainer().getContainerId().toString();\n       DockerStopCommand stopCommand \u003d new DockerStopCommand(containerId);\n       String commandFile \u003d dockerClient.writeCommandToTempFile(stopCommand,\n           containerId);\n       privOp \u003d new PrivilegedOperation(\n           PrivilegedOperation.OperationType.RUN_DOCKER_CMD);\n       privOp.appendArgs(commandFile);\n     }\n \n     //Some failures here are acceptable. Let the calling executor decide.\n     privOp.disableFailureLogging();\n \n     try {\n       privilegedOperationExecutor.executePrivilegedOperation(null,\n-          privOp, null, container.getLaunchContext().getEnvironment(),\n-          false, false);\n+          privOp, null, null, false, false);\n     } catch (PrivilegedOperationException e) {\n       throw new ContainerExecutionException(\"Signal container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void signalContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    ContainerExecutor.Signal signal \u003d ctx.getExecutionAttribute(SIGNAL);\n\n    PrivilegedOperation privOp \u003d null;\n    // Handle liveliness checks, send null signal to pid\n    if(ContainerExecutor.Signal.NULL.equals(signal)) {\n      privOp \u003d new PrivilegedOperation(\n          PrivilegedOperation.OperationType.SIGNAL_CONTAINER);\n      privOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n          ctx.getExecutionAttribute(USER),\n          Integer.toString(PrivilegedOperation.RunAsUserCommand\n              .SIGNAL_CONTAINER.getValue()),\n          ctx.getExecutionAttribute(PID),\n          Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));\n\n    // All other signals handled as docker stop\n    } else {\n      String containerId \u003d ctx.getContainer().getContainerId().toString();\n      DockerStopCommand stopCommand \u003d new DockerStopCommand(containerId);\n      String commandFile \u003d dockerClient.writeCommandToTempFile(stopCommand,\n          containerId);\n      privOp \u003d new PrivilegedOperation(\n          PrivilegedOperation.OperationType.RUN_DOCKER_CMD);\n      privOp.appendArgs(commandFile);\n    }\n\n    //Some failures here are acceptable. Let the calling executor decide.\n    privOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          privOp, null, null, false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Signal container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "e5e558b0a34968eaffdd243ce605ef26346c5e85": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4759. Fix signal handling for docker containers. Contributed by Shane Kumpf.\n",
      "commitDate": "14/07/16 6:57 AM",
      "commitName": "e5e558b0a34968eaffdd243ce605ef26346c5e85",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "14/07/16 3:41 AM",
      "commitNameOld": "58e18508018081b5b5aa7c12cc5af386146cd26b",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,40 @@\n   public void signalContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n-    PrivilegedOperation signalOp \u003d new PrivilegedOperation(\n-        PrivilegedOperation.OperationType.SIGNAL_CONTAINER);\n+    ContainerExecutor.Signal signal \u003d ctx.getExecutionAttribute(SIGNAL);\n \n-    signalOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n-        ctx.getExecutionAttribute(USER),\n-        Integer.toString(PrivilegedOperation\n-            .RunAsUserCommand.SIGNAL_CONTAINER.getValue()),\n-        ctx.getExecutionAttribute(PID),\n-        Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));\n+    PrivilegedOperation privOp \u003d null;\n+    // Handle liveliness checks, send null signal to pid\n+    if(ContainerExecutor.Signal.NULL.equals(signal)) {\n+      privOp \u003d new PrivilegedOperation(\n+          PrivilegedOperation.OperationType.SIGNAL_CONTAINER);\n+      privOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n+          ctx.getExecutionAttribute(USER),\n+          Integer.toString(PrivilegedOperation.RunAsUserCommand\n+              .SIGNAL_CONTAINER.getValue()),\n+          ctx.getExecutionAttribute(PID),\n+          Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));\n+\n+    // All other signals handled as docker stop\n+    } else {\n+      String containerId \u003d ctx.getContainer().getContainerId().toString();\n+      DockerStopCommand stopCommand \u003d new DockerStopCommand(containerId);\n+      String commandFile \u003d dockerClient.writeCommandToTempFile(stopCommand,\n+          containerId);\n+      privOp \u003d new PrivilegedOperation(\n+          PrivilegedOperation.OperationType.RUN_DOCKER_CMD);\n+      privOp.appendArgs(commandFile);\n+    }\n+\n+    //Some failures here are acceptable. Let the calling executor decide.\n+    privOp.disableFailureLogging();\n \n     try {\n-      PrivilegedOperationExecutor executor \u003d PrivilegedOperationExecutor\n-          .getInstance(conf);\n-\n-      executor.executePrivilegedOperation(null,\n-          signalOp, null, container.getLaunchContext().getEnvironment(),\n-          false, true);\n+      privilegedOperationExecutor.executePrivilegedOperation(null,\n+          privOp, null, container.getLaunchContext().getEnvironment(),\n+          false, false);\n     } catch (PrivilegedOperationException e) {\n-      LOG.warn(\"Signal container failed. Exception: \", e);\n-\n       throw new ContainerExecutionException(\"Signal container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void signalContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    ContainerExecutor.Signal signal \u003d ctx.getExecutionAttribute(SIGNAL);\n\n    PrivilegedOperation privOp \u003d null;\n    // Handle liveliness checks, send null signal to pid\n    if(ContainerExecutor.Signal.NULL.equals(signal)) {\n      privOp \u003d new PrivilegedOperation(\n          PrivilegedOperation.OperationType.SIGNAL_CONTAINER);\n      privOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n          ctx.getExecutionAttribute(USER),\n          Integer.toString(PrivilegedOperation.RunAsUserCommand\n              .SIGNAL_CONTAINER.getValue()),\n          ctx.getExecutionAttribute(PID),\n          Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));\n\n    // All other signals handled as docker stop\n    } else {\n      String containerId \u003d ctx.getContainer().getContainerId().toString();\n      DockerStopCommand stopCommand \u003d new DockerStopCommand(containerId);\n      String commandFile \u003d dockerClient.writeCommandToTempFile(stopCommand,\n          containerId);\n      privOp \u003d new PrivilegedOperation(\n          PrivilegedOperation.OperationType.RUN_DOCKER_CMD);\n      privOp.appendArgs(commandFile);\n    }\n\n    //Some failures here are acceptable. Let the calling executor decide.\n    privOp.disableFailureLogging();\n\n    try {\n      privilegedOperationExecutor.executePrivilegedOperation(null,\n          privOp, null, container.getLaunchContext().getEnvironment(),\n          false, false);\n    } catch (PrivilegedOperationException e) {\n      throw new ContainerExecutionException(\"Signal container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "9d4d30243b0fc9630da51a2c17b543ef671d035c": {
      "type": "Ybodychange",
      "commitMessage": "Remove parent\u0027s env vars from child processes\n",
      "commitDate": "29/04/16 9:25 AM",
      "commitName": "9d4d30243b0fc9630da51a2c17b543ef671d035c",
      "commitAuthor": "Robert Kanter",
      "commitDateOld": "07/03/16 11:08 AM",
      "commitNameOld": "b2661765a5a48392a5691cee15904ed2de147b00",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 52.89,
      "commitsBetweenForRepo": 317,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n   public void signalContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     PrivilegedOperation signalOp \u003d new PrivilegedOperation(\n         PrivilegedOperation.OperationType.SIGNAL_CONTAINER);\n \n     signalOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n         ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.SIGNAL_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(PID),\n         Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));\n \n     try {\n       PrivilegedOperationExecutor executor \u003d PrivilegedOperationExecutor\n           .getInstance(conf);\n \n       executor.executePrivilegedOperation(null,\n           signalOp, null, container.getLaunchContext().getEnvironment(),\n-          false);\n+          false, true);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Signal container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Signal container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void signalContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    PrivilegedOperation signalOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.SIGNAL_CONTAINER);\n\n    signalOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n        ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.SIGNAL_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(PID),\n        Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));\n\n    try {\n      PrivilegedOperationExecutor executor \u003d PrivilegedOperationExecutor\n          .getInstance(conf);\n\n      executor.executePrivilegedOperation(null,\n          signalOp, null, container.getLaunchContext().getEnvironment(),\n          false, true);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Signal container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Signal container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "059caf99891943d9587cac19b48e82efbed06b2d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4744. Too many signal to container failure in case of LCE. Contributed by Sidharta Seethana\n",
      "commitDate": "07/03/16 7:40 AM",
      "commitName": "059caf99891943d9587cac19b48e82efbed06b2d",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "22/01/16 1:13 AM",
      "commitNameOld": "b41a7e89d1eb8650975ac7092532ed9563ac60f2",
      "commitAuthorOld": "Varun Vasudev",
      "daysBetweenCommits": 45.27,
      "commitsBetweenForRepo": 308,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,27 @@\n   public void signalContainer(ContainerRuntimeContext ctx)\n       throws ContainerExecutionException {\n     Container container \u003d ctx.getContainer();\n     PrivilegedOperation signalOp \u003d new PrivilegedOperation(\n-        PrivilegedOperation.OperationType.SIGNAL_CONTAINER, (String) null);\n+        PrivilegedOperation.OperationType.SIGNAL_CONTAINER);\n \n     signalOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n         ctx.getExecutionAttribute(USER),\n         Integer.toString(PrivilegedOperation\n             .RunAsUserCommand.SIGNAL_CONTAINER.getValue()),\n         ctx.getExecutionAttribute(PID),\n         Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));\n \n     try {\n       PrivilegedOperationExecutor executor \u003d PrivilegedOperationExecutor\n           .getInstance(conf);\n \n       executor.executePrivilegedOperation(null,\n           signalOp, null, container.getLaunchContext().getEnvironment(),\n           false);\n     } catch (PrivilegedOperationException e) {\n       LOG.warn(\"Signal container failed. Exception: \", e);\n \n       throw new ContainerExecutionException(\"Signal container failed\", e\n           .getExitCode(), e.getOutput(), e.getErrorOutput());\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void signalContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    PrivilegedOperation signalOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.SIGNAL_CONTAINER);\n\n    signalOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n        ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.SIGNAL_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(PID),\n        Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));\n\n    try {\n      PrivilegedOperationExecutor executor \u003d PrivilegedOperationExecutor\n          .getInstance(conf);\n\n      executor.executePrivilegedOperation(null,\n          signalOp, null, container.getLaunchContext().getEnvironment(),\n          false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Signal container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Signal container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java",
      "extendedDetails": {}
    },
    "3e6fce91a471b4a5099de109582e7c6417e8a822": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3853. Add docker container runtime support to LinuxContainterExecutor. Contributed by Sidharta Seethana.\n",
      "commitDate": "27/07/15 11:57 AM",
      "commitName": "3e6fce91a471b4a5099de109582e7c6417e8a822",
      "commitAuthor": "Varun Vasudev",
      "diff": "@@ -0,0 +1,27 @@\n+  public void signalContainer(ContainerRuntimeContext ctx)\n+      throws ContainerExecutionException {\n+    Container container \u003d ctx.getContainer();\n+    PrivilegedOperation signalOp \u003d new PrivilegedOperation(\n+        PrivilegedOperation.OperationType.SIGNAL_CONTAINER, (String) null);\n+\n+    signalOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n+        ctx.getExecutionAttribute(USER),\n+        Integer.toString(PrivilegedOperation\n+            .RunAsUserCommand.SIGNAL_CONTAINER.getValue()),\n+        ctx.getExecutionAttribute(PID),\n+        Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));\n+\n+    try {\n+      PrivilegedOperationExecutor executor \u003d PrivilegedOperationExecutor\n+          .getInstance(conf);\n+\n+      executor.executePrivilegedOperation(null,\n+          signalOp, null, container.getLaunchContext().getEnvironment(),\n+          false);\n+    } catch (PrivilegedOperationException e) {\n+      LOG.warn(\"Signal container failed. Exception: \", e);\n+\n+      throw new ContainerExecutionException(\"Signal container failed\", e\n+          .getExitCode(), e.getOutput(), e.getErrorOutput());\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void signalContainer(ContainerRuntimeContext ctx)\n      throws ContainerExecutionException {\n    Container container \u003d ctx.getContainer();\n    PrivilegedOperation signalOp \u003d new PrivilegedOperation(\n        PrivilegedOperation.OperationType.SIGNAL_CONTAINER, (String) null);\n\n    signalOp.appendArgs(ctx.getExecutionAttribute(RUN_AS_USER),\n        ctx.getExecutionAttribute(USER),\n        Integer.toString(PrivilegedOperation\n            .RunAsUserCommand.SIGNAL_CONTAINER.getValue()),\n        ctx.getExecutionAttribute(PID),\n        Integer.toString(ctx.getExecutionAttribute(SIGNAL).getValue()));\n\n    try {\n      PrivilegedOperationExecutor executor \u003d PrivilegedOperationExecutor\n          .getInstance(conf);\n\n      executor.executePrivilegedOperation(null,\n          signalOp, null, container.getLaunchContext().getEnvironment(),\n          false);\n    } catch (PrivilegedOperationException e) {\n      LOG.warn(\"Signal container failed. Exception: \", e);\n\n      throw new ContainerExecutionException(\"Signal container failed\", e\n          .getExitCode(), e.getOutput(), e.getErrorOutput());\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/linux/runtime/DockerLinuxContainerRuntime.java"
    }
  }
}