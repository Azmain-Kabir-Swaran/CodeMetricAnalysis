{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RMContainerRequestor.java",
  "functionName": "containerFailedOnHost",
  "functionId": "containerFailedOnHost___hostName-String",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
  "functionStartLine": 327,
  "functionEndLine": 390,
  "numCommitsSeen": 39,
  "timeTaken": 7924,
  "changeHistory": [
    "fb3f338c652be737436accd076d2aacfd70c276c",
    "2b14656ab5050dd75935b64681cdc25fb49db94f",
    "f27e484636f9903bb80afac9c9e51a04a7dbce76",
    "643155cbee54809e1a7febd96cbb7d8111689b38",
    "35832053bf46f77a6350ef8e716a67f2a374b1a0",
    "905b17876c44634545a68300ff2f2d73fb86d3b7",
    "28a2eb9d722bb8cbbeee87a1c43b4dc4ef4467ce",
    "e7543b944c2b35d0a1ca0a92efeca47ad414ac7a",
    "2fe343f96348e894e6ed16c447c8c77ba1611d11",
    "74748ec62570f92d57dbad3ba4cca47402990db5",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "fb3f338c652be737436accd076d2aacfd70c276c": "Ybodychange",
    "2b14656ab5050dd75935b64681cdc25fb49db94f": "Ybodychange",
    "f27e484636f9903bb80afac9c9e51a04a7dbce76": "Ybodychange",
    "643155cbee54809e1a7febd96cbb7d8111689b38": "Ybodychange",
    "35832053bf46f77a6350ef8e716a67f2a374b1a0": "Ybodychange",
    "905b17876c44634545a68300ff2f2d73fb86d3b7": "Ybodychange",
    "28a2eb9d722bb8cbbeee87a1c43b4dc4ef4467ce": "Ybodychange",
    "e7543b944c2b35d0a1ca0a92efeca47ad414ac7a": "Ybodychange",
    "2fe343f96348e894e6ed16c447c8c77ba1611d11": "Ybodychange",
    "74748ec62570f92d57dbad3ba4cca47402990db5": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fb3f338c652be737436accd076d2aacfd70c276c": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5489. MR jobs hangs as it does not use the node-blacklisting feature in RM requests (Zhijie Shen via bikas)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1529005 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/10/13 2:14 PM",
      "commitName": "fb3f338c652be737436accd076d2aacfd70c276c",
      "commitAuthor": "Bikas Saha",
      "commitDateOld": "18/07/13 5:57 PM",
      "commitNameOld": "ac914f79bc80b152e71e7de5497b73f22824f4a7",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 76.85,
      "commitsBetweenForRepo": 451,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,64 @@\n   protected void containerFailedOnHost(String hostName) {\n     if (!nodeBlacklistingEnabled) {\n       return;\n     }\n     if (blacklistedNodes.contains(hostName)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n       }\n       return; //already blacklisted\n     }\n     Integer failures \u003d nodeFailures.remove(hostName);\n     failures \u003d failures \u003d\u003d null ? Integer.valueOf(0) : failures;\n     failures++;\n     LOG.info(failures + \" failures on node \" + hostName);\n     if (failures \u003e\u003d maxTaskFailuresPerNode) {\n       blacklistedNodes.add(hostName);\n+      if (!ignoreBlacklisting.get()) {\n+        blacklistAdditions.add(hostName);\n+      }\n       //Even if blacklisting is ignored, continue to remove the host from\n       // the request table. The RM may have additional nodes it can allocate on.\n       LOG.info(\"Blacklisted host \" + hostName);\n \n       //remove all the requests corresponding to this hostname\n       for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n           : remoteRequestsTable.values()){\n         //remove from host if no pending allocations\n         boolean foundAll \u003d true;\n         Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n         if (reqMap !\u003d null) {\n           for (ResourceRequest req : reqMap.values()) {\n             if (!ask.remove(req)) {\n               foundAll \u003d false;\n               // if ask already sent to RM, we can try and overwrite it if possible.\n               // send a new ask to RM with numContainers\n               // specified for the blacklisted host to be 0.\n               ResourceRequest zeroedRequest \u003d\n                   ResourceRequest.newInstance(req.getPriority(),\n                     req.getResourceName(), req.getCapability(),\n                     req.getNumContainers(), req.getRelaxLocality());\n \n               zeroedRequest.setNumContainers(0);\n               // to be sent to RM on next heartbeat\n               addResourceRequestToAsk(zeroedRequest);\n             }\n           }\n           // if all requests were still in ask queue\n           // we can remove this request\n           if (foundAll) {\n             remoteRequests.remove(hostName);\n           }\n         }\n         // TODO handling of rack blacklisting\n         // Removing from rack should be dependent on no. of failures within the rack \n         // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n         // may be overly aggressive. \n         // Node failures could be co-related with other failures on the same rack \n         // but we probably need a better approach at trying to decide how and when \n         // to blacklist a rack\n       }\n     } else {\n       nodeFailures.put(hostName, failures);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void containerFailedOnHost(String hostName) {\n    if (!nodeBlacklistingEnabled) {\n      return;\n    }\n    if (blacklistedNodes.contains(hostName)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n      }\n      return; //already blacklisted\n    }\n    Integer failures \u003d nodeFailures.remove(hostName);\n    failures \u003d failures \u003d\u003d null ? Integer.valueOf(0) : failures;\n    failures++;\n    LOG.info(failures + \" failures on node \" + hostName);\n    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n      blacklistedNodes.add(hostName);\n      if (!ignoreBlacklisting.get()) {\n        blacklistAdditions.add(hostName);\n      }\n      //Even if blacklisting is ignored, continue to remove the host from\n      // the request table. The RM may have additional nodes it can allocate on.\n      LOG.info(\"Blacklisted host \" + hostName);\n\n      //remove all the requests corresponding to this hostname\n      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n          : remoteRequestsTable.values()){\n        //remove from host if no pending allocations\n        boolean foundAll \u003d true;\n        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n        if (reqMap !\u003d null) {\n          for (ResourceRequest req : reqMap.values()) {\n            if (!ask.remove(req)) {\n              foundAll \u003d false;\n              // if ask already sent to RM, we can try and overwrite it if possible.\n              // send a new ask to RM with numContainers\n              // specified for the blacklisted host to be 0.\n              ResourceRequest zeroedRequest \u003d\n                  ResourceRequest.newInstance(req.getPriority(),\n                    req.getResourceName(), req.getCapability(),\n                    req.getNumContainers(), req.getRelaxLocality());\n\n              zeroedRequest.setNumContainers(0);\n              // to be sent to RM on next heartbeat\n              addResourceRequestToAsk(zeroedRequest);\n            }\n          }\n          // if all requests were still in ask queue\n          // we can remove this request\n          if (foundAll) {\n            remoteRequests.remove(hostName);\n          }\n        }\n        // TODO handling of rack blacklisting\n        // Removing from rack should be dependent on no. of failures within the rack \n        // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n        // may be overly aggressive. \n        // Node failures could be co-related with other failures on the same rack \n        // but we probably need a better approach at trying to decide how and when \n        // to blacklist a rack\n      }\n    } else {\n      nodeFailures.put(hostName, failures);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
      "extendedDetails": {}
    },
    "2b14656ab5050dd75935b64681cdc25fb49db94f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-805. Fix javadoc and annotations on classes in the yarn-api package. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1493992 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/06/13 8:10 PM",
      "commitName": "2b14656ab5050dd75935b64681cdc25fb49db94f",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "16/06/13 3:15 PM",
      "commitNameOld": "789c03438c9f5f7fa2212065effade6ca7561099",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 1.2,
      "commitsBetweenForRepo": 18,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n   protected void containerFailedOnHost(String hostName) {\n     if (!nodeBlacklistingEnabled) {\n       return;\n     }\n     if (blacklistedNodes.contains(hostName)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n       }\n       return; //already blacklisted\n     }\n     Integer failures \u003d nodeFailures.remove(hostName);\n     failures \u003d failures \u003d\u003d null ? Integer.valueOf(0) : failures;\n     failures++;\n     LOG.info(failures + \" failures on node \" + hostName);\n     if (failures \u003e\u003d maxTaskFailuresPerNode) {\n       blacklistedNodes.add(hostName);\n       //Even if blacklisting is ignored, continue to remove the host from\n       // the request table. The RM may have additional nodes it can allocate on.\n       LOG.info(\"Blacklisted host \" + hostName);\n \n       //remove all the requests corresponding to this hostname\n       for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n           : remoteRequestsTable.values()){\n         //remove from host if no pending allocations\n         boolean foundAll \u003d true;\n         Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n         if (reqMap !\u003d null) {\n           for (ResourceRequest req : reqMap.values()) {\n             if (!ask.remove(req)) {\n               foundAll \u003d false;\n               // if ask already sent to RM, we can try and overwrite it if possible.\n               // send a new ask to RM with numContainers\n               // specified for the blacklisted host to be 0.\n               ResourceRequest zeroedRequest \u003d\n                   ResourceRequest.newInstance(req.getPriority(),\n                     req.getResourceName(), req.getCapability(),\n-                    req.getNumContainers());\n+                    req.getNumContainers(), req.getRelaxLocality());\n \n               zeroedRequest.setNumContainers(0);\n               // to be sent to RM on next heartbeat\n               addResourceRequestToAsk(zeroedRequest);\n             }\n           }\n           // if all requests were still in ask queue\n           // we can remove this request\n           if (foundAll) {\n             remoteRequests.remove(hostName);\n           }\n         }\n         // TODO handling of rack blacklisting\n         // Removing from rack should be dependent on no. of failures within the rack \n         // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n         // may be overly aggressive. \n         // Node failures could be co-related with other failures on the same rack \n         // but we probably need a better approach at trying to decide how and when \n         // to blacklist a rack\n       }\n     } else {\n       nodeFailures.put(hostName, failures);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void containerFailedOnHost(String hostName) {\n    if (!nodeBlacklistingEnabled) {\n      return;\n    }\n    if (blacklistedNodes.contains(hostName)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n      }\n      return; //already blacklisted\n    }\n    Integer failures \u003d nodeFailures.remove(hostName);\n    failures \u003d failures \u003d\u003d null ? Integer.valueOf(0) : failures;\n    failures++;\n    LOG.info(failures + \" failures on node \" + hostName);\n    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n      blacklistedNodes.add(hostName);\n      //Even if blacklisting is ignored, continue to remove the host from\n      // the request table. The RM may have additional nodes it can allocate on.\n      LOG.info(\"Blacklisted host \" + hostName);\n\n      //remove all the requests corresponding to this hostname\n      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n          : remoteRequestsTable.values()){\n        //remove from host if no pending allocations\n        boolean foundAll \u003d true;\n        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n        if (reqMap !\u003d null) {\n          for (ResourceRequest req : reqMap.values()) {\n            if (!ask.remove(req)) {\n              foundAll \u003d false;\n              // if ask already sent to RM, we can try and overwrite it if possible.\n              // send a new ask to RM with numContainers\n              // specified for the blacklisted host to be 0.\n              ResourceRequest zeroedRequest \u003d\n                  ResourceRequest.newInstance(req.getPriority(),\n                    req.getResourceName(), req.getCapability(),\n                    req.getNumContainers(), req.getRelaxLocality());\n\n              zeroedRequest.setNumContainers(0);\n              // to be sent to RM on next heartbeat\n              addResourceRequestToAsk(zeroedRequest);\n            }\n          }\n          // if all requests were still in ask queue\n          // we can remove this request\n          if (foundAll) {\n            remoteRequests.remove(hostName);\n          }\n        }\n        // TODO handling of rack blacklisting\n        // Removing from rack should be dependent on no. of failures within the rack \n        // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n        // may be overly aggressive. \n        // Node failures could be co-related with other failures on the same rack \n        // but we probably need a better approach at trying to decide how and when \n        // to blacklist a rack\n      }\n    } else {\n      nodeFailures.put(hostName, failures);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
      "extendedDetails": {}
    },
    "f27e484636f9903bb80afac9c9e51a04a7dbce76": {
      "type": "Ybodychange",
      "commitMessage": "YARN-749. Rename ResourceRequest.(get,set)HostName to ResourceRequest.(get,set)ResourceName. Contributed by Arun C. Murthy.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1488806 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/06/13 3:53 PM",
      "commitName": "f27e484636f9903bb80afac9c9e51a04a7dbce76",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/05/13 6:46 PM",
      "commitNameOld": "643155cbee54809e1a7febd96cbb7d8111689b38",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 8.88,
      "commitsBetweenForRepo": 47,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,61 +1,61 @@\n   protected void containerFailedOnHost(String hostName) {\n     if (!nodeBlacklistingEnabled) {\n       return;\n     }\n     if (blacklistedNodes.contains(hostName)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n       }\n       return; //already blacklisted\n     }\n     Integer failures \u003d nodeFailures.remove(hostName);\n     failures \u003d failures \u003d\u003d null ? Integer.valueOf(0) : failures;\n     failures++;\n     LOG.info(failures + \" failures on node \" + hostName);\n     if (failures \u003e\u003d maxTaskFailuresPerNode) {\n       blacklistedNodes.add(hostName);\n       //Even if blacklisting is ignored, continue to remove the host from\n       // the request table. The RM may have additional nodes it can allocate on.\n       LOG.info(\"Blacklisted host \" + hostName);\n \n       //remove all the requests corresponding to this hostname\n       for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n           : remoteRequestsTable.values()){\n         //remove from host if no pending allocations\n         boolean foundAll \u003d true;\n         Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n         if (reqMap !\u003d null) {\n           for (ResourceRequest req : reqMap.values()) {\n             if (!ask.remove(req)) {\n               foundAll \u003d false;\n               // if ask already sent to RM, we can try and overwrite it if possible.\n               // send a new ask to RM with numContainers\n               // specified for the blacklisted host to be 0.\n               ResourceRequest zeroedRequest \u003d\n                   ResourceRequest.newInstance(req.getPriority(),\n-                    req.getHostName(), req.getCapability(),\n+                    req.getResourceName(), req.getCapability(),\n                     req.getNumContainers());\n \n               zeroedRequest.setNumContainers(0);\n               // to be sent to RM on next heartbeat\n               addResourceRequestToAsk(zeroedRequest);\n             }\n           }\n           // if all requests were still in ask queue\n           // we can remove this request\n           if (foundAll) {\n             remoteRequests.remove(hostName);\n           }\n         }\n         // TODO handling of rack blacklisting\n         // Removing from rack should be dependent on no. of failures within the rack \n         // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n         // may be overly aggressive. \n         // Node failures could be co-related with other failures on the same rack \n         // but we probably need a better approach at trying to decide how and when \n         // to blacklist a rack\n       }\n     } else {\n       nodeFailures.put(hostName, failures);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void containerFailedOnHost(String hostName) {\n    if (!nodeBlacklistingEnabled) {\n      return;\n    }\n    if (blacklistedNodes.contains(hostName)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n      }\n      return; //already blacklisted\n    }\n    Integer failures \u003d nodeFailures.remove(hostName);\n    failures \u003d failures \u003d\u003d null ? Integer.valueOf(0) : failures;\n    failures++;\n    LOG.info(failures + \" failures on node \" + hostName);\n    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n      blacklistedNodes.add(hostName);\n      //Even if blacklisting is ignored, continue to remove the host from\n      // the request table. The RM may have additional nodes it can allocate on.\n      LOG.info(\"Blacklisted host \" + hostName);\n\n      //remove all the requests corresponding to this hostname\n      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n          : remoteRequestsTable.values()){\n        //remove from host if no pending allocations\n        boolean foundAll \u003d true;\n        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n        if (reqMap !\u003d null) {\n          for (ResourceRequest req : reqMap.values()) {\n            if (!ask.remove(req)) {\n              foundAll \u003d false;\n              // if ask already sent to RM, we can try and overwrite it if possible.\n              // send a new ask to RM with numContainers\n              // specified for the blacklisted host to be 0.\n              ResourceRequest zeroedRequest \u003d\n                  ResourceRequest.newInstance(req.getPriority(),\n                    req.getResourceName(), req.getCapability(),\n                    req.getNumContainers());\n\n              zeroedRequest.setNumContainers(0);\n              // to be sent to RM on next heartbeat\n              addResourceRequestToAsk(zeroedRequest);\n            }\n          }\n          // if all requests were still in ask queue\n          // we can remove this request\n          if (foundAll) {\n            remoteRequests.remove(hostName);\n          }\n        }\n        // TODO handling of rack blacklisting\n        // Removing from rack should be dependent on no. of failures within the rack \n        // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n        // may be overly aggressive. \n        // Node failures could be co-related with other failures on the same rack \n        // but we probably need a better approach at trying to decide how and when \n        // to blacklist a rack\n      }\n    } else {\n      nodeFailures.put(hostName, failures);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
      "extendedDetails": {}
    },
    "643155cbee54809e1a7febd96cbb7d8111689b38": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5270. Migrated MR app from using BuilderUtil factory methods to individual record factory methods. Contributed by Jian He.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1486271 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/05/13 6:46 PM",
      "commitName": "643155cbee54809e1a7febd96cbb7d8111689b38",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "12/05/13 8:34 PM",
      "commitNameOld": "7359dc32d3781d5318efee4cf6185616c7c00c18",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 11.92,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,61 @@\n   protected void containerFailedOnHost(String hostName) {\n     if (!nodeBlacklistingEnabled) {\n       return;\n     }\n     if (blacklistedNodes.contains(hostName)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n       }\n       return; //already blacklisted\n     }\n     Integer failures \u003d nodeFailures.remove(hostName);\n     failures \u003d failures \u003d\u003d null ? Integer.valueOf(0) : failures;\n     failures++;\n     LOG.info(failures + \" failures on node \" + hostName);\n     if (failures \u003e\u003d maxTaskFailuresPerNode) {\n       blacklistedNodes.add(hostName);\n       //Even if blacklisting is ignored, continue to remove the host from\n       // the request table. The RM may have additional nodes it can allocate on.\n       LOG.info(\"Blacklisted host \" + hostName);\n \n       //remove all the requests corresponding to this hostname\n       for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n           : remoteRequestsTable.values()){\n         //remove from host if no pending allocations\n         boolean foundAll \u003d true;\n         Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n         if (reqMap !\u003d null) {\n           for (ResourceRequest req : reqMap.values()) {\n             if (!ask.remove(req)) {\n               foundAll \u003d false;\n               // if ask already sent to RM, we can try and overwrite it if possible.\n               // send a new ask to RM with numContainers\n               // specified for the blacklisted host to be 0.\n-              ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n+              ResourceRequest zeroedRequest \u003d\n+                  ResourceRequest.newInstance(req.getPriority(),\n+                    req.getHostName(), req.getCapability(),\n+                    req.getNumContainers());\n+\n               zeroedRequest.setNumContainers(0);\n               // to be sent to RM on next heartbeat\n               addResourceRequestToAsk(zeroedRequest);\n             }\n           }\n           // if all requests were still in ask queue\n           // we can remove this request\n           if (foundAll) {\n             remoteRequests.remove(hostName);\n           }\n         }\n         // TODO handling of rack blacklisting\n         // Removing from rack should be dependent on no. of failures within the rack \n         // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n         // may be overly aggressive. \n         // Node failures could be co-related with other failures on the same rack \n         // but we probably need a better approach at trying to decide how and when \n         // to blacklist a rack\n       }\n     } else {\n       nodeFailures.put(hostName, failures);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void containerFailedOnHost(String hostName) {\n    if (!nodeBlacklistingEnabled) {\n      return;\n    }\n    if (blacklistedNodes.contains(hostName)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n      }\n      return; //already blacklisted\n    }\n    Integer failures \u003d nodeFailures.remove(hostName);\n    failures \u003d failures \u003d\u003d null ? Integer.valueOf(0) : failures;\n    failures++;\n    LOG.info(failures + \" failures on node \" + hostName);\n    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n      blacklistedNodes.add(hostName);\n      //Even if blacklisting is ignored, continue to remove the host from\n      // the request table. The RM may have additional nodes it can allocate on.\n      LOG.info(\"Blacklisted host \" + hostName);\n\n      //remove all the requests corresponding to this hostname\n      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n          : remoteRequestsTable.values()){\n        //remove from host if no pending allocations\n        boolean foundAll \u003d true;\n        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n        if (reqMap !\u003d null) {\n          for (ResourceRequest req : reqMap.values()) {\n            if (!ask.remove(req)) {\n              foundAll \u003d false;\n              // if ask already sent to RM, we can try and overwrite it if possible.\n              // send a new ask to RM with numContainers\n              // specified for the blacklisted host to be 0.\n              ResourceRequest zeroedRequest \u003d\n                  ResourceRequest.newInstance(req.getPriority(),\n                    req.getHostName(), req.getCapability(),\n                    req.getNumContainers());\n\n              zeroedRequest.setNumContainers(0);\n              // to be sent to RM on next heartbeat\n              addResourceRequestToAsk(zeroedRequest);\n            }\n          }\n          // if all requests were still in ask queue\n          // we can remove this request\n          if (foundAll) {\n            remoteRequests.remove(hostName);\n          }\n        }\n        // TODO handling of rack blacklisting\n        // Removing from rack should be dependent on no. of failures within the rack \n        // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n        // may be overly aggressive. \n        // Node failures could be co-related with other failures on the same rack \n        // but we probably need a better approach at trying to decide how and when \n        // to blacklist a rack\n      }\n    } else {\n      nodeFailures.put(hostName, failures);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
      "extendedDetails": {}
    },
    "35832053bf46f77a6350ef8e716a67f2a374b1a0": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4671. AM does not tell the RM about container requests which are no longer needed. Contributed by Bikas Saha.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1443323 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/02/13 11:07 PM",
      "commitName": "35832053bf46f77a6350ef8e716a67f2a374b1a0",
      "commitAuthor": "Siddharth Seth",
      "commitDateOld": "14/11/12 4:16 PM",
      "commitNameOld": "905b17876c44634545a68300ff2f2d73fb86d3b7",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 84.29,
      "commitsBetweenForRepo": 365,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,57 @@\n   protected void containerFailedOnHost(String hostName) {\n     if (!nodeBlacklistingEnabled) {\n       return;\n     }\n     if (blacklistedNodes.contains(hostName)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n       }\n       return; //already blacklisted\n     }\n     Integer failures \u003d nodeFailures.remove(hostName);\n     failures \u003d failures \u003d\u003d null ? Integer.valueOf(0) : failures;\n     failures++;\n     LOG.info(failures + \" failures on node \" + hostName);\n     if (failures \u003e\u003d maxTaskFailuresPerNode) {\n       blacklistedNodes.add(hostName);\n       //Even if blacklisting is ignored, continue to remove the host from\n       // the request table. The RM may have additional nodes it can allocate on.\n       LOG.info(\"Blacklisted host \" + hostName);\n \n       //remove all the requests corresponding to this hostname\n       for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n           : remoteRequestsTable.values()){\n         //remove from host if no pending allocations\n         boolean foundAll \u003d true;\n         Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n         if (reqMap !\u003d null) {\n           for (ResourceRequest req : reqMap.values()) {\n             if (!ask.remove(req)) {\n               foundAll \u003d false;\n               // if ask already sent to RM, we can try and overwrite it if possible.\n               // send a new ask to RM with numContainers\n               // specified for the blacklisted host to be 0.\n               ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n               zeroedRequest.setNumContainers(0);\n               // to be sent to RM on next heartbeat\n-              ask.add(zeroedRequest);\n+              addResourceRequestToAsk(zeroedRequest);\n             }\n           }\n           // if all requests were still in ask queue\n           // we can remove this request\n           if (foundAll) {\n             remoteRequests.remove(hostName);\n           }\n         }\n         // TODO handling of rack blacklisting\n         // Removing from rack should be dependent on no. of failures within the rack \n         // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n         // may be overly aggressive. \n         // Node failures could be co-related with other failures on the same rack \n         // but we probably need a better approach at trying to decide how and when \n         // to blacklist a rack\n       }\n     } else {\n       nodeFailures.put(hostName, failures);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void containerFailedOnHost(String hostName) {\n    if (!nodeBlacklistingEnabled) {\n      return;\n    }\n    if (blacklistedNodes.contains(hostName)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n      }\n      return; //already blacklisted\n    }\n    Integer failures \u003d nodeFailures.remove(hostName);\n    failures \u003d failures \u003d\u003d null ? Integer.valueOf(0) : failures;\n    failures++;\n    LOG.info(failures + \" failures on node \" + hostName);\n    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n      blacklistedNodes.add(hostName);\n      //Even if blacklisting is ignored, continue to remove the host from\n      // the request table. The RM may have additional nodes it can allocate on.\n      LOG.info(\"Blacklisted host \" + hostName);\n\n      //remove all the requests corresponding to this hostname\n      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n          : remoteRequestsTable.values()){\n        //remove from host if no pending allocations\n        boolean foundAll \u003d true;\n        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n        if (reqMap !\u003d null) {\n          for (ResourceRequest req : reqMap.values()) {\n            if (!ask.remove(req)) {\n              foundAll \u003d false;\n              // if ask already sent to RM, we can try and overwrite it if possible.\n              // send a new ask to RM with numContainers\n              // specified for the blacklisted host to be 0.\n              ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n              zeroedRequest.setNumContainers(0);\n              // to be sent to RM on next heartbeat\n              addResourceRequestToAsk(zeroedRequest);\n            }\n          }\n          // if all requests were still in ask queue\n          // we can remove this request\n          if (foundAll) {\n            remoteRequests.remove(hostName);\n          }\n        }\n        // TODO handling of rack blacklisting\n        // Removing from rack should be dependent on no. of failures within the rack \n        // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n        // may be overly aggressive. \n        // Node failures could be co-related with other failures on the same rack \n        // but we probably need a better approach at trying to decide how and when \n        // to blacklist a rack\n      }\n    } else {\n      nodeFailures.put(hostName, failures);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
      "extendedDetails": {}
    },
    "905b17876c44634545a68300ff2f2d73fb86d3b7": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4723. Fix warnings found by findbugs 2. Contributed by Sandy Ryza\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1409601 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/11/12 4:16 PM",
      "commitName": "905b17876c44634545a68300ff2f2d73fb86d3b7",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "06/02/12 2:01 PM",
      "commitNameOld": "28a2eb9d722bb8cbbeee87a1c43b4dc4ef4467ce",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 282.09,
      "commitsBetweenForRepo": 1789,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,57 @@\n   protected void containerFailedOnHost(String hostName) {\n     if (!nodeBlacklistingEnabled) {\n       return;\n     }\n     if (blacklistedNodes.contains(hostName)) {\n       if (LOG.isDebugEnabled()) {\n         LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n       }\n       return; //already blacklisted\n     }\n     Integer failures \u003d nodeFailures.remove(hostName);\n-    failures \u003d failures \u003d\u003d null ? 0 : failures;\n+    failures \u003d failures \u003d\u003d null ? Integer.valueOf(0) : failures;\n     failures++;\n     LOG.info(failures + \" failures on node \" + hostName);\n     if (failures \u003e\u003d maxTaskFailuresPerNode) {\n       blacklistedNodes.add(hostName);\n       //Even if blacklisting is ignored, continue to remove the host from\n       // the request table. The RM may have additional nodes it can allocate on.\n       LOG.info(\"Blacklisted host \" + hostName);\n \n       //remove all the requests corresponding to this hostname\n       for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n           : remoteRequestsTable.values()){\n         //remove from host if no pending allocations\n         boolean foundAll \u003d true;\n         Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n         if (reqMap !\u003d null) {\n           for (ResourceRequest req : reqMap.values()) {\n             if (!ask.remove(req)) {\n               foundAll \u003d false;\n               // if ask already sent to RM, we can try and overwrite it if possible.\n               // send a new ask to RM with numContainers\n               // specified for the blacklisted host to be 0.\n               ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n               zeroedRequest.setNumContainers(0);\n               // to be sent to RM on next heartbeat\n               ask.add(zeroedRequest);\n             }\n           }\n           // if all requests were still in ask queue\n           // we can remove this request\n           if (foundAll) {\n             remoteRequests.remove(hostName);\n           }\n         }\n         // TODO handling of rack blacklisting\n         // Removing from rack should be dependent on no. of failures within the rack \n         // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n         // may be overly aggressive. \n         // Node failures could be co-related with other failures on the same rack \n         // but we probably need a better approach at trying to decide how and when \n         // to blacklist a rack\n       }\n     } else {\n       nodeFailures.put(hostName, failures);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void containerFailedOnHost(String hostName) {\n    if (!nodeBlacklistingEnabled) {\n      return;\n    }\n    if (blacklistedNodes.contains(hostName)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n      }\n      return; //already blacklisted\n    }\n    Integer failures \u003d nodeFailures.remove(hostName);\n    failures \u003d failures \u003d\u003d null ? Integer.valueOf(0) : failures;\n    failures++;\n    LOG.info(failures + \" failures on node \" + hostName);\n    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n      blacklistedNodes.add(hostName);\n      //Even if blacklisting is ignored, continue to remove the host from\n      // the request table. The RM may have additional nodes it can allocate on.\n      LOG.info(\"Blacklisted host \" + hostName);\n\n      //remove all the requests corresponding to this hostname\n      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n          : remoteRequestsTable.values()){\n        //remove from host if no pending allocations\n        boolean foundAll \u003d true;\n        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n        if (reqMap !\u003d null) {\n          for (ResourceRequest req : reqMap.values()) {\n            if (!ask.remove(req)) {\n              foundAll \u003d false;\n              // if ask already sent to RM, we can try and overwrite it if possible.\n              // send a new ask to RM with numContainers\n              // specified for the blacklisted host to be 0.\n              ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n              zeroedRequest.setNumContainers(0);\n              // to be sent to RM on next heartbeat\n              ask.add(zeroedRequest);\n            }\n          }\n          // if all requests were still in ask queue\n          // we can remove this request\n          if (foundAll) {\n            remoteRequests.remove(hostName);\n          }\n        }\n        // TODO handling of rack blacklisting\n        // Removing from rack should be dependent on no. of failures within the rack \n        // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n        // may be overly aggressive. \n        // Node failures could be co-related with other failures on the same rack \n        // but we probably need a better approach at trying to decide how and when \n        // to blacklist a rack\n      }\n    } else {\n      nodeFailures.put(hostName, failures);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
      "extendedDetails": {}
    },
    "28a2eb9d722bb8cbbeee87a1c43b4dc4ef4467ce": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3810. Performance tweaks - reduced logging in AM and defined hascode/equals for ResourceRequest \u0026 Priority. Contributed by Vinod K V. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1241205 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "06/02/12 2:01 PM",
      "commitName": "28a2eb9d722bb8cbbeee87a1c43b4dc4ef4467ce",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "27/12/11 11:54 AM",
      "commitNameOld": "fcbad14a3da7fadbb601bf245552ecca2fbc5026",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 41.09,
      "commitsBetweenForRepo": 218,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,57 @@\n   protected void containerFailedOnHost(String hostName) {\n     if (!nodeBlacklistingEnabled) {\n       return;\n     }\n     if (blacklistedNodes.contains(hostName)) {\n-      LOG.info(\"Host \" + hostName + \" is already blacklisted.\");\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n+      }\n       return; //already blacklisted\n     }\n     Integer failures \u003d nodeFailures.remove(hostName);\n     failures \u003d failures \u003d\u003d null ? 0 : failures;\n     failures++;\n     LOG.info(failures + \" failures on node \" + hostName);\n     if (failures \u003e\u003d maxTaskFailuresPerNode) {\n       blacklistedNodes.add(hostName);\n       //Even if blacklisting is ignored, continue to remove the host from\n       // the request table. The RM may have additional nodes it can allocate on.\n       LOG.info(\"Blacklisted host \" + hostName);\n \n       //remove all the requests corresponding to this hostname\n       for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n           : remoteRequestsTable.values()){\n         //remove from host if no pending allocations\n         boolean foundAll \u003d true;\n         Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n         if (reqMap !\u003d null) {\n           for (ResourceRequest req : reqMap.values()) {\n             if (!ask.remove(req)) {\n               foundAll \u003d false;\n               // if ask already sent to RM, we can try and overwrite it if possible.\n               // send a new ask to RM with numContainers\n               // specified for the blacklisted host to be 0.\n               ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n               zeroedRequest.setNumContainers(0);\n               // to be sent to RM on next heartbeat\n               ask.add(zeroedRequest);\n             }\n           }\n           // if all requests were still in ask queue\n           // we can remove this request\n           if (foundAll) {\n             remoteRequests.remove(hostName);\n           }\n         }\n         // TODO handling of rack blacklisting\n         // Removing from rack should be dependent on no. of failures within the rack \n         // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n         // may be overly aggressive. \n         // Node failures could be co-related with other failures on the same rack \n         // but we probably need a better approach at trying to decide how and when \n         // to blacklist a rack\n       }\n     } else {\n       nodeFailures.put(hostName, failures);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void containerFailedOnHost(String hostName) {\n    if (!nodeBlacklistingEnabled) {\n      return;\n    }\n    if (blacklistedNodes.contains(hostName)) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Host \" + hostName + \" is already blacklisted.\");\n      }\n      return; //already blacklisted\n    }\n    Integer failures \u003d nodeFailures.remove(hostName);\n    failures \u003d failures \u003d\u003d null ? 0 : failures;\n    failures++;\n    LOG.info(failures + \" failures on node \" + hostName);\n    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n      blacklistedNodes.add(hostName);\n      //Even if blacklisting is ignored, continue to remove the host from\n      // the request table. The RM may have additional nodes it can allocate on.\n      LOG.info(\"Blacklisted host \" + hostName);\n\n      //remove all the requests corresponding to this hostname\n      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n          : remoteRequestsTable.values()){\n        //remove from host if no pending allocations\n        boolean foundAll \u003d true;\n        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n        if (reqMap !\u003d null) {\n          for (ResourceRequest req : reqMap.values()) {\n            if (!ask.remove(req)) {\n              foundAll \u003d false;\n              // if ask already sent to RM, we can try and overwrite it if possible.\n              // send a new ask to RM with numContainers\n              // specified for the blacklisted host to be 0.\n              ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n              zeroedRequest.setNumContainers(0);\n              // to be sent to RM on next heartbeat\n              ask.add(zeroedRequest);\n            }\n          }\n          // if all requests were still in ask queue\n          // we can remove this request\n          if (foundAll) {\n            remoteRequests.remove(hostName);\n          }\n        }\n        // TODO handling of rack blacklisting\n        // Removing from rack should be dependent on no. of failures within the rack \n        // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n        // may be overly aggressive. \n        // Node failures could be co-related with other failures on the same rack \n        // but we probably need a better approach at trying to decide how and when \n        // to blacklist a rack\n      }\n    } else {\n      nodeFailures.put(hostName, failures);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
      "extendedDetails": {}
    },
    "e7543b944c2b35d0a1ca0a92efeca47ad414ac7a": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3339. Fixed MR AM to stop considering node blacklisting after the number of nodes blacklisted crosses a threshold. Contributed by Siddharth Seth.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1221523 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/12/11 3:27 PM",
      "commitName": "e7543b944c2b35d0a1ca0a92efeca47ad414ac7a",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "02/12/11 2:18 PM",
      "commitNameOld": "a3f37e15f75d01bb342480b0b1035ea16c5fd9aa",
      "commitAuthorOld": "Siddharth Seth",
      "daysBetweenCommits": 18.05,
      "commitsBetweenForRepo": 119,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,53 +1,55 @@\n   protected void containerFailedOnHost(String hostName) {\n     if (!nodeBlacklistingEnabled) {\n       return;\n     }\n     if (blacklistedNodes.contains(hostName)) {\n       LOG.info(\"Host \" + hostName + \" is already blacklisted.\");\n       return; //already blacklisted\n     }\n     Integer failures \u003d nodeFailures.remove(hostName);\n     failures \u003d failures \u003d\u003d null ? 0 : failures;\n     failures++;\n     LOG.info(failures + \" failures on node \" + hostName);\n     if (failures \u003e\u003d maxTaskFailuresPerNode) {\n       blacklistedNodes.add(hostName);\n+      //Even if blacklisting is ignored, continue to remove the host from\n+      // the request table. The RM may have additional nodes it can allocate on.\n       LOG.info(\"Blacklisted host \" + hostName);\n-      \n+\n       //remove all the requests corresponding to this hostname\n       for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n           : remoteRequestsTable.values()){\n         //remove from host if no pending allocations\n         boolean foundAll \u003d true;\n         Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n         if (reqMap !\u003d null) {\n           for (ResourceRequest req : reqMap.values()) {\n             if (!ask.remove(req)) {\n               foundAll \u003d false;\n               // if ask already sent to RM, we can try and overwrite it if possible.\n               // send a new ask to RM with numContainers\n               // specified for the blacklisted host to be 0.\n               ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n               zeroedRequest.setNumContainers(0);\n               // to be sent to RM on next heartbeat\n               ask.add(zeroedRequest);\n             }\n           }\n           // if all requests were still in ask queue\n           // we can remove this request\n           if (foundAll) {\n             remoteRequests.remove(hostName);\n           }\n         }\n         // TODO handling of rack blacklisting\n         // Removing from rack should be dependent on no. of failures within the rack \n         // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n         // may be overly aggressive. \n         // Node failures could be co-related with other failures on the same rack \n         // but we probably need a better approach at trying to decide how and when \n         // to blacklist a rack\n       }\n     } else {\n       nodeFailures.put(hostName, failures);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void containerFailedOnHost(String hostName) {\n    if (!nodeBlacklistingEnabled) {\n      return;\n    }\n    if (blacklistedNodes.contains(hostName)) {\n      LOG.info(\"Host \" + hostName + \" is already blacklisted.\");\n      return; //already blacklisted\n    }\n    Integer failures \u003d nodeFailures.remove(hostName);\n    failures \u003d failures \u003d\u003d null ? 0 : failures;\n    failures++;\n    LOG.info(failures + \" failures on node \" + hostName);\n    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n      blacklistedNodes.add(hostName);\n      //Even if blacklisting is ignored, continue to remove the host from\n      // the request table. The RM may have additional nodes it can allocate on.\n      LOG.info(\"Blacklisted host \" + hostName);\n\n      //remove all the requests corresponding to this hostname\n      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n          : remoteRequestsTable.values()){\n        //remove from host if no pending allocations\n        boolean foundAll \u003d true;\n        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n        if (reqMap !\u003d null) {\n          for (ResourceRequest req : reqMap.values()) {\n            if (!ask.remove(req)) {\n              foundAll \u003d false;\n              // if ask already sent to RM, we can try and overwrite it if possible.\n              // send a new ask to RM with numContainers\n              // specified for the blacklisted host to be 0.\n              ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n              zeroedRequest.setNumContainers(0);\n              // to be sent to RM on next heartbeat\n              ask.add(zeroedRequest);\n            }\n          }\n          // if all requests were still in ask queue\n          // we can remove this request\n          if (foundAll) {\n            remoteRequests.remove(hostName);\n          }\n        }\n        // TODO handling of rack blacklisting\n        // Removing from rack should be dependent on no. of failures within the rack \n        // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n        // may be overly aggressive. \n        // Node failures could be co-related with other failures on the same rack \n        // but we probably need a better approach at trying to decide how and when \n        // to blacklist a rack\n      }\n    } else {\n      nodeFailures.put(hostName, failures);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
      "extendedDetails": {}
    },
    "2fe343f96348e894e6ed16c447c8c77ba1611d11": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3240. Fixed NodeManager to be able to forcefully cleanup its containers (process-trees) irrespective of whether the container succeeded, or killed. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1189711 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "27/10/11 5:03 AM",
      "commitName": "2fe343f96348e894e6ed16c447c8c77ba1611d11",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "19/10/11 3:02 PM",
      "commitNameOld": "74748ec62570f92d57dbad3ba4cca47402990db5",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 7.58,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,53 @@\n   protected void containerFailedOnHost(String hostName) {\n     if (!nodeBlacklistingEnabled) {\n       return;\n     }\n     if (blacklistedNodes.contains(hostName)) {\n       LOG.info(\"Host \" + hostName + \" is already blacklisted.\");\n       return; //already blacklisted\n     }\n     Integer failures \u003d nodeFailures.remove(hostName);\n     failures \u003d failures \u003d\u003d null ? 0 : failures;\n     failures++;\n     LOG.info(failures + \" failures on node \" + hostName);\n     if (failures \u003e\u003d maxTaskFailuresPerNode) {\n       blacklistedNodes.add(hostName);\n       LOG.info(\"Blacklisted host \" + hostName);\n       \n       //remove all the requests corresponding to this hostname\n       for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n           : remoteRequestsTable.values()){\n         //remove from host if no pending allocations\n         boolean foundAll \u003d true;\n         Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n         if (reqMap !\u003d null) {\n           for (ResourceRequest req : reqMap.values()) {\n             if (!ask.remove(req)) {\n               foundAll \u003d false;\n-            }\n-            else {\n               // if ask already sent to RM, we can try and overwrite it if possible.\n               // send a new ask to RM with numContainers\n               // specified for the blacklisted host to be 0.\n               ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n               zeroedRequest.setNumContainers(0);\n               // to be sent to RM on next heartbeat\n               ask.add(zeroedRequest);\n             }\n           }\n           // if all requests were still in ask queue\n           // we can remove this request\n           if (foundAll) {\n             remoteRequests.remove(hostName);\n-          }     \n+          }\n         }\n         // TODO handling of rack blacklisting\n         // Removing from rack should be dependent on no. of failures within the rack \n         // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n         // may be overly aggressive. \n         // Node failures could be co-related with other failures on the same rack \n         // but we probably need a better approach at trying to decide how and when \n         // to blacklist a rack\n       }\n     } else {\n       nodeFailures.put(hostName, failures);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void containerFailedOnHost(String hostName) {\n    if (!nodeBlacklistingEnabled) {\n      return;\n    }\n    if (blacklistedNodes.contains(hostName)) {\n      LOG.info(\"Host \" + hostName + \" is already blacklisted.\");\n      return; //already blacklisted\n    }\n    Integer failures \u003d nodeFailures.remove(hostName);\n    failures \u003d failures \u003d\u003d null ? 0 : failures;\n    failures++;\n    LOG.info(failures + \" failures on node \" + hostName);\n    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n      blacklistedNodes.add(hostName);\n      LOG.info(\"Blacklisted host \" + hostName);\n      \n      //remove all the requests corresponding to this hostname\n      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n          : remoteRequestsTable.values()){\n        //remove from host if no pending allocations\n        boolean foundAll \u003d true;\n        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n        if (reqMap !\u003d null) {\n          for (ResourceRequest req : reqMap.values()) {\n            if (!ask.remove(req)) {\n              foundAll \u003d false;\n              // if ask already sent to RM, we can try and overwrite it if possible.\n              // send a new ask to RM with numContainers\n              // specified for the blacklisted host to be 0.\n              ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n              zeroedRequest.setNumContainers(0);\n              // to be sent to RM on next heartbeat\n              ask.add(zeroedRequest);\n            }\n          }\n          // if all requests were still in ask queue\n          // we can remove this request\n          if (foundAll) {\n            remoteRequests.remove(hostName);\n          }\n        }\n        // TODO handling of rack blacklisting\n        // Removing from rack should be dependent on no. of failures within the rack \n        // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n        // may be overly aggressive. \n        // Node failures could be co-related with other failures on the same rack \n        // but we probably need a better approach at trying to decide how and when \n        // to blacklist a rack\n      }\n    } else {\n      nodeFailures.put(hostName, failures);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
      "extendedDetails": {}
    },
    "74748ec62570f92d57dbad3ba4cca47402990db5": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2693. Fix NPE in job-blacklisting. Contributed by Hitesh Shah.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1186529 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/10/11 3:02 PM",
      "commitName": "74748ec62570f92d57dbad3ba4cca47402990db5",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "28/09/11 12:31 AM",
      "commitNameOld": "312a7e71001d55f88781e56b331ab1b40a72a980",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 21.61,
      "commitsBetweenForRepo": 167,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,55 @@\n   protected void containerFailedOnHost(String hostName) {\n     if (!nodeBlacklistingEnabled) {\n       return;\n     }\n     if (blacklistedNodes.contains(hostName)) {\n       LOG.info(\"Host \" + hostName + \" is already blacklisted.\");\n       return; //already blacklisted\n     }\n     Integer failures \u003d nodeFailures.remove(hostName);\n     failures \u003d failures \u003d\u003d null ? 0 : failures;\n     failures++;\n     LOG.info(failures + \" failures on node \" + hostName);\n     if (failures \u003e\u003d maxTaskFailuresPerNode) {\n       blacklistedNodes.add(hostName);\n       LOG.info(\"Blacklisted host \" + hostName);\n       \n       //remove all the requests corresponding to this hostname\n       for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n           : remoteRequestsTable.values()){\n-        //remove from host\n-        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.remove(hostName);\n+        //remove from host if no pending allocations\n+        boolean foundAll \u003d true;\n+        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n         if (reqMap !\u003d null) {\n           for (ResourceRequest req : reqMap.values()) {\n-            ask.remove(req);\n+            if (!ask.remove(req)) {\n+              foundAll \u003d false;\n+            }\n+            else {\n+              // if ask already sent to RM, we can try and overwrite it if possible.\n+              // send a new ask to RM with numContainers\n+              // specified for the blacklisted host to be 0.\n+              ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n+              zeroedRequest.setNumContainers(0);\n+              // to be sent to RM on next heartbeat\n+              ask.add(zeroedRequest);\n+            }\n           }\n+          // if all requests were still in ask queue\n+          // we can remove this request\n+          if (foundAll) {\n+            remoteRequests.remove(hostName);\n+          }     \n         }\n-        //TODO: remove from rack\n+        // TODO handling of rack blacklisting\n+        // Removing from rack should be dependent on no. of failures within the rack \n+        // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n+        // may be overly aggressive. \n+        // Node failures could be co-related with other failures on the same rack \n+        // but we probably need a better approach at trying to decide how and when \n+        // to blacklist a rack\n       }\n     } else {\n       nodeFailures.put(hostName, failures);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected void containerFailedOnHost(String hostName) {\n    if (!nodeBlacklistingEnabled) {\n      return;\n    }\n    if (blacklistedNodes.contains(hostName)) {\n      LOG.info(\"Host \" + hostName + \" is already blacklisted.\");\n      return; //already blacklisted\n    }\n    Integer failures \u003d nodeFailures.remove(hostName);\n    failures \u003d failures \u003d\u003d null ? 0 : failures;\n    failures++;\n    LOG.info(failures + \" failures on node \" + hostName);\n    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n      blacklistedNodes.add(hostName);\n      LOG.info(\"Blacklisted host \" + hostName);\n      \n      //remove all the requests corresponding to this hostname\n      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n          : remoteRequestsTable.values()){\n        //remove from host if no pending allocations\n        boolean foundAll \u003d true;\n        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.get(hostName);\n        if (reqMap !\u003d null) {\n          for (ResourceRequest req : reqMap.values()) {\n            if (!ask.remove(req)) {\n              foundAll \u003d false;\n            }\n            else {\n              // if ask already sent to RM, we can try and overwrite it if possible.\n              // send a new ask to RM with numContainers\n              // specified for the blacklisted host to be 0.\n              ResourceRequest zeroedRequest \u003d BuilderUtils.newResourceRequest(req);\n              zeroedRequest.setNumContainers(0);\n              // to be sent to RM on next heartbeat\n              ask.add(zeroedRequest);\n            }\n          }\n          // if all requests were still in ask queue\n          // we can remove this request\n          if (foundAll) {\n            remoteRequests.remove(hostName);\n          }     \n        }\n        // TODO handling of rack blacklisting\n        // Removing from rack should be dependent on no. of failures within the rack \n        // Blacklisting a rack on the basis of a single node\u0027s blacklisting \n        // may be overly aggressive. \n        // Node failures could be co-related with other failures on the same rack \n        // but we probably need a better approach at trying to decide how and when \n        // to blacklist a rack\n      }\n    } else {\n      nodeFailures.put(hostName, failures);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected void containerFailedOnHost(String hostName) {\n    if (!nodeBlacklistingEnabled) {\n      return;\n    }\n    if (blacklistedNodes.contains(hostName)) {\n      LOG.info(\"Host \" + hostName + \" is already blacklisted.\");\n      return; //already blacklisted\n    }\n    Integer failures \u003d nodeFailures.remove(hostName);\n    failures \u003d failures \u003d\u003d null ? 0 : failures;\n    failures++;\n    LOG.info(failures + \" failures on node \" + hostName);\n    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n      blacklistedNodes.add(hostName);\n      LOG.info(\"Blacklisted host \" + hostName);\n      \n      //remove all the requests corresponding to this hostname\n      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n          : remoteRequestsTable.values()){\n        //remove from host\n        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.remove(hostName);\n        if (reqMap !\u003d null) {\n          for (ResourceRequest req : reqMap.values()) {\n            ask.remove(req);\n          }\n        }\n        //TODO: remove from rack\n      }\n    } else {\n      nodeFailures.put(hostName, failures);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,32 @@\n+  protected void containerFailedOnHost(String hostName) {\n+    if (!nodeBlacklistingEnabled) {\n+      return;\n+    }\n+    if (blacklistedNodes.contains(hostName)) {\n+      LOG.info(\"Host \" + hostName + \" is already blacklisted.\");\n+      return; //already blacklisted\n+    }\n+    Integer failures \u003d nodeFailures.remove(hostName);\n+    failures \u003d failures \u003d\u003d null ? 0 : failures;\n+    failures++;\n+    LOG.info(failures + \" failures on node \" + hostName);\n+    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n+      blacklistedNodes.add(hostName);\n+      LOG.info(\"Blacklisted host \" + hostName);\n+      \n+      //remove all the requests corresponding to this hostname\n+      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n+          : remoteRequestsTable.values()){\n+        //remove from host\n+        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.remove(hostName);\n+        if (reqMap !\u003d null) {\n+          for (ResourceRequest req : reqMap.values()) {\n+            ask.remove(req);\n+          }\n+        }\n+        //TODO: remove from rack\n+      }\n+    } else {\n+      nodeFailures.put(hostName, failures);\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  protected void containerFailedOnHost(String hostName) {\n    if (!nodeBlacklistingEnabled) {\n      return;\n    }\n    if (blacklistedNodes.contains(hostName)) {\n      LOG.info(\"Host \" + hostName + \" is already blacklisted.\");\n      return; //already blacklisted\n    }\n    Integer failures \u003d nodeFailures.remove(hostName);\n    failures \u003d failures \u003d\u003d null ? 0 : failures;\n    failures++;\n    LOG.info(failures + \" failures on node \" + hostName);\n    if (failures \u003e\u003d maxTaskFailuresPerNode) {\n      blacklistedNodes.add(hostName);\n      LOG.info(\"Blacklisted host \" + hostName);\n      \n      //remove all the requests corresponding to this hostname\n      for (Map\u003cString, Map\u003cResource, ResourceRequest\u003e\u003e remoteRequests \n          : remoteRequestsTable.values()){\n        //remove from host\n        Map\u003cResource, ResourceRequest\u003e reqMap \u003d remoteRequests.remove(hostName);\n        if (reqMap !\u003d null) {\n          for (ResourceRequest req : reqMap.values()) {\n            ask.remove(req);\n          }\n        }\n        //TODO: remove from rack\n      }\n    } else {\n      nodeFailures.put(hostName, failures);\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapreduce/v2/app/rm/RMContainerRequestor.java"
    }
  }
}