{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RequestHedgingProxyProvider.java",
  "functionName": "invoke",
  "functionId": "invoke___proxy-Object__method-Method(modifiers-final)__args-Object[](modifiers-final)",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java",
  "functionStartLine": 82,
  "functionEndLine": 191,
  "numCommitsSeen": 14,
  "timeTaken": 4659,
  "changeHistory": [
    "f858f1855455348f5ac517ebd96c2bbc3bc97489",
    "63803e7051dcfcd8e3d28a8b3217b7735a00b7d8",
    "b5353c75d90b9299f04dba255b9e9af5a8cc19eb",
    "ac32b3576da4cc463dff85118163ccfff02215fc",
    "c30a26abc54df669a77e0219fd9b48a47c179a99",
    "659e85e304d070f9908a96cf6a0e1cbafde6a434",
    "9e0e430f18d45cfe125dda8d85916edddf79e8d6",
    "55796a0946f80a35055701a34379e374399009c5",
    "e68c7b96c76b243da53ae539e7c760bf2c08f26e",
    "9fdfb546fb67526ba261da5cbd005f33e0f1d9e1",
    "030fcfa99c345ad57625486eeabedebf2fd4411f"
  ],
  "changeHistoryShort": {
    "f858f1855455348f5ac517ebd96c2bbc3bc97489": "Ybodychange",
    "63803e7051dcfcd8e3d28a8b3217b7735a00b7d8": "Ybodychange",
    "b5353c75d90b9299f04dba255b9e9af5a8cc19eb": "Ybodychange",
    "ac32b3576da4cc463dff85118163ccfff02215fc": "Ybodychange",
    "c30a26abc54df669a77e0219fd9b48a47c179a99": "Ybodychange",
    "659e85e304d070f9908a96cf6a0e1cbafde6a434": "Ybodychange",
    "9e0e430f18d45cfe125dda8d85916edddf79e8d6": "Yfilerename",
    "55796a0946f80a35055701a34379e374399009c5": "Ybodychange",
    "e68c7b96c76b243da53ae539e7c760bf2c08f26e": "Ybodychange",
    "9fdfb546fb67526ba261da5cbd005f33e0f1d9e1": "Ybodychange",
    "030fcfa99c345ad57625486eeabedebf2fd4411f": "Yintroduced"
  },
  "changeHistoryDetails": {
    "f858f1855455348f5ac517ebd96c2bbc3bc97489": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-14088. RequestHedgingProxyProvider can throw NullPointerException when failover due to no lock on currentUsedProxy. Contributed by Yuxuan Wang.\n",
      "commitDate": "14/12/18 11:04 AM",
      "commitName": "f858f1855455348f5ac517ebd96c2bbc3bc97489",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "22/04/18 7:49 PM",
      "commitNameOld": "63803e7051dcfcd8e3d28a8b3217b7735a00b7d8",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 235.68,
      "commitsBetweenForRepo": 2374,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,96 +1,110 @@\n     invoke(Object proxy, final Method method, final Object[] args)\n             throws Throwable {\n-      if (currentUsedProxy !\u003d null) {\n-        try {\n-          Object retVal \u003d method.invoke(currentUsedProxy.proxy, args);\n-          LOG.debug(\"Invocation successful on [{}]\",\n-              currentUsedProxy.proxyInfo);\n-          return retVal;\n-        } catch (InvocationTargetException ex) {\n-          Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n-          logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n-          LOG.trace(\"Unsuccessful invocation on [{}]\",\n-              currentUsedProxy.proxyInfo);\n-          throw unwrappedException;\n+      // Need double check locking to guarantee thread-safe since\n+      // currentUsedProxy is lazily initialized.\n+      if (currentUsedProxy \u003d\u003d null) {\n+        synchronized (this) {\n+          if (currentUsedProxy \u003d\u003d null) {\n+            Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n+            int numAttempts \u003d 0;\n+\n+            ExecutorService executor \u003d null;\n+            CompletionService\u003cObject\u003e completionService;\n+            try {\n+              // Optimization : if only 2 proxies are configured and one had\n+              // failed\n+              // over, then we dont need to create a threadpool etc.\n+              targetProxies.remove(toIgnore);\n+              if (targetProxies.size() \u003d\u003d 0) {\n+                LOG.trace(\"No valid proxies left\");\n+                throw new RemoteException(IOException.class.getName(),\n+                    \"No valid proxies left. \"\n+                        + \"All NameNode proxies have failed over.\");\n+              }\n+              if (targetProxies.size() \u003d\u003d 1) {\n+                ProxyInfo\u003cT\u003e proxyInfo \u003d\n+                    targetProxies.values().iterator().next();\n+                try {\n+                  currentUsedProxy \u003d proxyInfo;\n+                  Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n+                  LOG.debug(\"Invocation successful on [{}]\",\n+                      currentUsedProxy.proxyInfo);\n+                  return retVal;\n+                } catch (InvocationTargetException ex) {\n+                  Exception unwrappedException \u003d\n+                      unwrapInvocationTargetException(ex);\n+                  logProxyException(unwrappedException,\n+                      currentUsedProxy.proxyInfo);\n+                  LOG.trace(\"Unsuccessful invocation on [{}]\",\n+                      currentUsedProxy.proxyInfo);\n+                  throw unwrappedException;\n+                }\n+              }\n+              executor \u003d Executors.newFixedThreadPool(proxies.size());\n+              completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n+              for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry : targetProxies\n+                  .entrySet()) {\n+                Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n+                  @Override\n+                  public Object call() throws Exception {\n+                    LOG.trace(\"Invoking method {} on proxy {}\", method,\n+                        pEntry.getValue().proxyInfo);\n+                    return method.invoke(pEntry.getValue().proxy, args);\n+                  }\n+                };\n+                proxyMap.put(completionService.submit(c), pEntry.getValue());\n+                numAttempts++;\n+              }\n+\n+              Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n+              while (numAttempts \u003e 0) {\n+                Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n+                Object retVal;\n+                try {\n+                  currentUsedProxy \u003d proxyMap.get(callResultFuture);\n+                  retVal \u003d callResultFuture.get();\n+                  LOG.debug(\"Invocation successful on [{}]\",\n+                      currentUsedProxy.proxyInfo);\n+                  return retVal;\n+                } catch (ExecutionException ex) {\n+                  Exception unwrappedException \u003d unwrapExecutionException(ex);\n+                  ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n+                  logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n+                  badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n+                  LOG.trace(\"Unsuccessful invocation on [{}]\",\n+                      tProxyInfo.proxyInfo);\n+                  numAttempts--;\n+                }\n+              }\n+\n+              // At this point we should have All bad results (Exceptions)\n+              // Or should have returned with successful result.\n+              if (badResults.size() \u003d\u003d 1) {\n+                throw badResults.values().iterator().next();\n+              } else {\n+                throw new MultiException(badResults);\n+              }\n+            } finally {\n+              if (executor !\u003d null) {\n+                LOG.trace(\"Shutting down threadpool executor\");\n+                executor.shutdownNow();\n+              }\n+            }\n+          }\n         }\n       }\n-      Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n-      int numAttempts \u003d 0;\n-\n-      ExecutorService executor \u003d null;\n-      CompletionService\u003cObject\u003e completionService;\n+      // Because the above synchronized block will return or throw an exception,\n+      // so we don\u0027t need to do any check to prevent the first initialized\n+      // thread from stepping to following codes.\n       try {\n-        // Optimization : if only 2 proxies are configured and one had failed\n-        // over, then we dont need to create a threadpool etc.\n-        targetProxies.remove(toIgnore);\n-        if (targetProxies.size() \u003d\u003d 0) {\n-          LOG.trace(\"No valid proxies left\");\n-          throw new RemoteException(IOException.class.getName(),\n-              \"No valid proxies left. All NameNode proxies have failed over.\");\n-        }\n-        if (targetProxies.size() \u003d\u003d 1) {\n-          ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n-          try {\n-            currentUsedProxy \u003d proxyInfo;\n-            Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n-            LOG.debug(\"Invocation successful on [{}]\",\n-                currentUsedProxy.proxyInfo);\n-            return retVal;\n-          } catch (InvocationTargetException ex) {\n-            Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n-            logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n-            LOG.trace(\"Unsuccessful invocation on [{}]\",\n-                currentUsedProxy.proxyInfo);\n-            throw unwrappedException;\n-          }\n-        }\n-        executor \u003d Executors.newFixedThreadPool(proxies.size());\n-        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n-        for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n-                targetProxies.entrySet()) {\n-          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n-            @Override\n-            public Object call() throws Exception {\n-              LOG.trace(\"Invoking method {} on proxy {}\", method,\n-                  pEntry.getValue().proxyInfo);\n-              return method.invoke(pEntry.getValue().proxy, args);\n-            }\n-          };\n-          proxyMap.put(completionService.submit(c), pEntry.getValue());\n-          numAttempts++;\n-        }\n-\n-        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n-        while (numAttempts \u003e 0) {\n-          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n-          Object retVal;\n-          try {\n-            currentUsedProxy \u003d proxyMap.get(callResultFuture);\n-            retVal \u003d callResultFuture.get();\n-            LOG.debug(\"Invocation successful on [{}]\",\n-                currentUsedProxy.proxyInfo);\n-            return retVal;\n-          } catch (ExecutionException ex) {\n-            Exception unwrappedException \u003d unwrapExecutionException(ex);\n-            ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n-            logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n-            badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n-            LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n-            numAttempts--;\n-          }\n-        }\n-\n-        // At this point we should have All bad results (Exceptions)\n-        // Or should have returned with successful result.\n-        if (badResults.size() \u003d\u003d 1) {\n-          throw badResults.values().iterator().next();\n-        } else {\n-          throw new MultiException(badResults);\n-        }\n-      } finally {\n-        if (executor !\u003d null) {\n-          LOG.trace(\"Shutting down threadpool executor\");\n-          executor.shutdownNow();\n-        }\n+        Object retVal \u003d method.invoke(currentUsedProxy.proxy, args);\n+        LOG.debug(\"Invocation successful on [{}]\", currentUsedProxy.proxyInfo);\n+        return retVal;\n+      } catch (InvocationTargetException ex) {\n+        Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n+        logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n+        LOG.trace(\"Unsuccessful invocation on [{}]\",\n+            currentUsedProxy.proxyInfo);\n+        throw unwrappedException;\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    invoke(Object proxy, final Method method, final Object[] args)\n            throws Throwable {\n      // Need double check locking to guarantee thread-safe since\n      // currentUsedProxy is lazily initialized.\n      if (currentUsedProxy \u003d\u003d null) {\n        synchronized (this) {\n          if (currentUsedProxy \u003d\u003d null) {\n            Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n            int numAttempts \u003d 0;\n\n            ExecutorService executor \u003d null;\n            CompletionService\u003cObject\u003e completionService;\n            try {\n              // Optimization : if only 2 proxies are configured and one had\n              // failed\n              // over, then we dont need to create a threadpool etc.\n              targetProxies.remove(toIgnore);\n              if (targetProxies.size() \u003d\u003d 0) {\n                LOG.trace(\"No valid proxies left\");\n                throw new RemoteException(IOException.class.getName(),\n                    \"No valid proxies left. \"\n                        + \"All NameNode proxies have failed over.\");\n              }\n              if (targetProxies.size() \u003d\u003d 1) {\n                ProxyInfo\u003cT\u003e proxyInfo \u003d\n                    targetProxies.values().iterator().next();\n                try {\n                  currentUsedProxy \u003d proxyInfo;\n                  Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n                  LOG.debug(\"Invocation successful on [{}]\",\n                      currentUsedProxy.proxyInfo);\n                  return retVal;\n                } catch (InvocationTargetException ex) {\n                  Exception unwrappedException \u003d\n                      unwrapInvocationTargetException(ex);\n                  logProxyException(unwrappedException,\n                      currentUsedProxy.proxyInfo);\n                  LOG.trace(\"Unsuccessful invocation on [{}]\",\n                      currentUsedProxy.proxyInfo);\n                  throw unwrappedException;\n                }\n              }\n              executor \u003d Executors.newFixedThreadPool(proxies.size());\n              completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n              for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry : targetProxies\n                  .entrySet()) {\n                Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n                  @Override\n                  public Object call() throws Exception {\n                    LOG.trace(\"Invoking method {} on proxy {}\", method,\n                        pEntry.getValue().proxyInfo);\n                    return method.invoke(pEntry.getValue().proxy, args);\n                  }\n                };\n                proxyMap.put(completionService.submit(c), pEntry.getValue());\n                numAttempts++;\n              }\n\n              Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n              while (numAttempts \u003e 0) {\n                Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n                Object retVal;\n                try {\n                  currentUsedProxy \u003d proxyMap.get(callResultFuture);\n                  retVal \u003d callResultFuture.get();\n                  LOG.debug(\"Invocation successful on [{}]\",\n                      currentUsedProxy.proxyInfo);\n                  return retVal;\n                } catch (ExecutionException ex) {\n                  Exception unwrappedException \u003d unwrapExecutionException(ex);\n                  ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n                  logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n                  badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n                  LOG.trace(\"Unsuccessful invocation on [{}]\",\n                      tProxyInfo.proxyInfo);\n                  numAttempts--;\n                }\n              }\n\n              // At this point we should have All bad results (Exceptions)\n              // Or should have returned with successful result.\n              if (badResults.size() \u003d\u003d 1) {\n                throw badResults.values().iterator().next();\n              } else {\n                throw new MultiException(badResults);\n              }\n            } finally {\n              if (executor !\u003d null) {\n                LOG.trace(\"Shutting down threadpool executor\");\n                executor.shutdownNow();\n              }\n            }\n          }\n        }\n      }\n      // Because the above synchronized block will return or throw an exception,\n      // so we don\u0027t need to do any check to prevent the first initialized\n      // thread from stepping to following codes.\n      try {\n        Object retVal \u003d method.invoke(currentUsedProxy.proxy, args);\n        LOG.debug(\"Invocation successful on [{}]\", currentUsedProxy.proxyInfo);\n        return retVal;\n      } catch (InvocationTargetException ex) {\n        Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n        logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n        LOG.trace(\"Unsuccessful invocation on [{}]\",\n            currentUsedProxy.proxyInfo);\n        throw unwrappedException;\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java",
      "extendedDetails": {}
    },
    "63803e7051dcfcd8e3d28a8b3217b7735a00b7d8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13388. RequestHedgingProxyProvider calls multiple configured NNs all the time. Contributed by Jinglun.\n",
      "commitDate": "22/04/18 7:49 PM",
      "commitName": "63803e7051dcfcd8e3d28a8b3217b7735a00b7d8",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "12/04/18 9:28 AM",
      "commitNameOld": "b5353c75d90b9299f04dba255b9e9af5a8cc19eb",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 10.43,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,96 @@\n     invoke(Object proxy, final Method method, final Object[] args)\n             throws Throwable {\n+      if (currentUsedProxy !\u003d null) {\n+        try {\n+          Object retVal \u003d method.invoke(currentUsedProxy.proxy, args);\n+          LOG.debug(\"Invocation successful on [{}]\",\n+              currentUsedProxy.proxyInfo);\n+          return retVal;\n+        } catch (InvocationTargetException ex) {\n+          Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n+          logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n+          LOG.trace(\"Unsuccessful invocation on [{}]\",\n+              currentUsedProxy.proxyInfo);\n+          throw unwrappedException;\n+        }\n+      }\n       Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n       int numAttempts \u003d 0;\n \n       ExecutorService executor \u003d null;\n       CompletionService\u003cObject\u003e completionService;\n       try {\n         // Optimization : if only 2 proxies are configured and one had failed\n         // over, then we dont need to create a threadpool etc.\n         targetProxies.remove(toIgnore);\n         if (targetProxies.size() \u003d\u003d 0) {\n           LOG.trace(\"No valid proxies left\");\n           throw new RemoteException(IOException.class.getName(),\n               \"No valid proxies left. All NameNode proxies have failed over.\");\n         }\n         if (targetProxies.size() \u003d\u003d 1) {\n           ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n           try {\n             currentUsedProxy \u003d proxyInfo;\n             Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n             LOG.debug(\"Invocation successful on [{}]\",\n                 currentUsedProxy.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ex) {\n             Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n             logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n             LOG.trace(\"Unsuccessful invocation on [{}]\",\n                 currentUsedProxy.proxyInfo);\n             throw unwrappedException;\n           }\n         }\n         executor \u003d Executors.newFixedThreadPool(proxies.size());\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n         for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                 targetProxies.entrySet()) {\n           Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n             @Override\n             public Object call() throws Exception {\n               LOG.trace(\"Invoking method {} on proxy {}\", method,\n                   pEntry.getValue().proxyInfo);\n               return method.invoke(pEntry.getValue().proxy, args);\n             }\n           };\n           proxyMap.put(completionService.submit(c), pEntry.getValue());\n           numAttempts++;\n         }\n \n         Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n         while (numAttempts \u003e 0) {\n           Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n           Object retVal;\n           try {\n             currentUsedProxy \u003d proxyMap.get(callResultFuture);\n             retVal \u003d callResultFuture.get();\n             LOG.debug(\"Invocation successful on [{}]\",\n                 currentUsedProxy.proxyInfo);\n             return retVal;\n           } catch (ExecutionException ex) {\n             Exception unwrappedException \u003d unwrapExecutionException(ex);\n             ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n             logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n             badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n             LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n             numAttempts--;\n           }\n         }\n \n         // At this point we should have All bad results (Exceptions)\n         // Or should have returned with successful result.\n         if (badResults.size() \u003d\u003d 1) {\n           throw badResults.values().iterator().next();\n         } else {\n           throw new MultiException(badResults);\n         }\n       } finally {\n         if (executor !\u003d null) {\n           LOG.trace(\"Shutting down threadpool executor\");\n           executor.shutdownNow();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    invoke(Object proxy, final Method method, final Object[] args)\n            throws Throwable {\n      if (currentUsedProxy !\u003d null) {\n        try {\n          Object retVal \u003d method.invoke(currentUsedProxy.proxy, args);\n          LOG.debug(\"Invocation successful on [{}]\",\n              currentUsedProxy.proxyInfo);\n          return retVal;\n        } catch (InvocationTargetException ex) {\n          Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n          logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n          LOG.trace(\"Unsuccessful invocation on [{}]\",\n              currentUsedProxy.proxyInfo);\n          throw unwrappedException;\n        }\n      }\n      Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n      int numAttempts \u003d 0;\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        // Optimization : if only 2 proxies are configured and one had failed\n        // over, then we dont need to create a threadpool etc.\n        targetProxies.remove(toIgnore);\n        if (targetProxies.size() \u003d\u003d 0) {\n          LOG.trace(\"No valid proxies left\");\n          throw new RemoteException(IOException.class.getName(),\n              \"No valid proxies left. All NameNode proxies have failed over.\");\n        }\n        if (targetProxies.size() \u003d\u003d 1) {\n          ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n          try {\n            currentUsedProxy \u003d proxyInfo;\n            Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n            LOG.debug(\"Invocation successful on [{}]\",\n                currentUsedProxy.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ex) {\n            Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n            logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n            LOG.trace(\"Unsuccessful invocation on [{}]\",\n                currentUsedProxy.proxyInfo);\n            throw unwrappedException;\n          }\n        }\n        executor \u003d Executors.newFixedThreadPool(proxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                targetProxies.entrySet()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              LOG.trace(\"Invoking method {} on proxy {}\", method,\n                  pEntry.getValue().proxyInfo);\n              return method.invoke(pEntry.getValue().proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pEntry.getValue());\n          numAttempts++;\n        }\n\n        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n        while (numAttempts \u003e 0) {\n          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n          Object retVal;\n          try {\n            currentUsedProxy \u003d proxyMap.get(callResultFuture);\n            retVal \u003d callResultFuture.get();\n            LOG.debug(\"Invocation successful on [{}]\",\n                currentUsedProxy.proxyInfo);\n            return retVal;\n          } catch (ExecutionException ex) {\n            Exception unwrappedException \u003d unwrapExecutionException(ex);\n            ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n            logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n            badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n            LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n            numAttempts--;\n          }\n        }\n\n        // At this point we should have All bad results (Exceptions)\n        // Or should have returned with successful result.\n        if (badResults.size() \u003d\u003d 1) {\n          throw badResults.values().iterator().next();\n        } else {\n          throw new MultiException(badResults);\n        }\n      } finally {\n        if (executor !\u003d null) {\n          LOG.trace(\"Shutting down threadpool executor\");\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java",
      "extendedDetails": {}
    },
    "b5353c75d90b9299f04dba255b9e9af5a8cc19eb": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"HDFS-13388. RequestHedgingProxyProvider calls multiple configured NNs all the time. Contributed by Jinglun.\"\n\nThis reverts commit ac32b3576da4cc463dff85118163ccfff02215fc.\n",
      "commitDate": "12/04/18 9:28 AM",
      "commitName": "b5353c75d90b9299f04dba255b9e9af5a8cc19eb",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "09/04/18 9:16 AM",
      "commitNameOld": "ac32b3576da4cc463dff85118163ccfff02215fc",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 3.01,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,85 +1,82 @@\n     invoke(Object proxy, final Method method, final Object[] args)\n             throws Throwable {\n-      if (currentUsedProxy !\u003d null) {\n-        return method.invoke(currentUsedProxy.proxy, args);\n-      }\n       Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n       int numAttempts \u003d 0;\n \n       ExecutorService executor \u003d null;\n       CompletionService\u003cObject\u003e completionService;\n       try {\n         // Optimization : if only 2 proxies are configured and one had failed\n         // over, then we dont need to create a threadpool etc.\n         targetProxies.remove(toIgnore);\n         if (targetProxies.size() \u003d\u003d 0) {\n           LOG.trace(\"No valid proxies left\");\n           throw new RemoteException(IOException.class.getName(),\n               \"No valid proxies left. All NameNode proxies have failed over.\");\n         }\n         if (targetProxies.size() \u003d\u003d 1) {\n           ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n           try {\n             currentUsedProxy \u003d proxyInfo;\n             Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n             LOG.debug(\"Invocation successful on [{}]\",\n                 currentUsedProxy.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ex) {\n             Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n             logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n             LOG.trace(\"Unsuccessful invocation on [{}]\",\n                 currentUsedProxy.proxyInfo);\n             throw unwrappedException;\n           }\n         }\n         executor \u003d Executors.newFixedThreadPool(proxies.size());\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n         for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                 targetProxies.entrySet()) {\n           Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n             @Override\n             public Object call() throws Exception {\n               LOG.trace(\"Invoking method {} on proxy {}\", method,\n                   pEntry.getValue().proxyInfo);\n               return method.invoke(pEntry.getValue().proxy, args);\n             }\n           };\n           proxyMap.put(completionService.submit(c), pEntry.getValue());\n           numAttempts++;\n         }\n \n         Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n         while (numAttempts \u003e 0) {\n           Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n           Object retVal;\n           try {\n             currentUsedProxy \u003d proxyMap.get(callResultFuture);\n             retVal \u003d callResultFuture.get();\n             LOG.debug(\"Invocation successful on [{}]\",\n                 currentUsedProxy.proxyInfo);\n             return retVal;\n           } catch (ExecutionException ex) {\n             Exception unwrappedException \u003d unwrapExecutionException(ex);\n             ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n             logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n             badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n             LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n             numAttempts--;\n           }\n         }\n \n         // At this point we should have All bad results (Exceptions)\n         // Or should have returned with successful result.\n         if (badResults.size() \u003d\u003d 1) {\n           throw badResults.values().iterator().next();\n         } else {\n           throw new MultiException(badResults);\n         }\n       } finally {\n         if (executor !\u003d null) {\n           LOG.trace(\"Shutting down threadpool executor\");\n           executor.shutdownNow();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    invoke(Object proxy, final Method method, final Object[] args)\n            throws Throwable {\n      Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n      int numAttempts \u003d 0;\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        // Optimization : if only 2 proxies are configured and one had failed\n        // over, then we dont need to create a threadpool etc.\n        targetProxies.remove(toIgnore);\n        if (targetProxies.size() \u003d\u003d 0) {\n          LOG.trace(\"No valid proxies left\");\n          throw new RemoteException(IOException.class.getName(),\n              \"No valid proxies left. All NameNode proxies have failed over.\");\n        }\n        if (targetProxies.size() \u003d\u003d 1) {\n          ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n          try {\n            currentUsedProxy \u003d proxyInfo;\n            Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n            LOG.debug(\"Invocation successful on [{}]\",\n                currentUsedProxy.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ex) {\n            Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n            logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n            LOG.trace(\"Unsuccessful invocation on [{}]\",\n                currentUsedProxy.proxyInfo);\n            throw unwrappedException;\n          }\n        }\n        executor \u003d Executors.newFixedThreadPool(proxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                targetProxies.entrySet()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              LOG.trace(\"Invoking method {} on proxy {}\", method,\n                  pEntry.getValue().proxyInfo);\n              return method.invoke(pEntry.getValue().proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pEntry.getValue());\n          numAttempts++;\n        }\n\n        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n        while (numAttempts \u003e 0) {\n          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n          Object retVal;\n          try {\n            currentUsedProxy \u003d proxyMap.get(callResultFuture);\n            retVal \u003d callResultFuture.get();\n            LOG.debug(\"Invocation successful on [{}]\",\n                currentUsedProxy.proxyInfo);\n            return retVal;\n          } catch (ExecutionException ex) {\n            Exception unwrappedException \u003d unwrapExecutionException(ex);\n            ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n            logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n            badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n            LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n            numAttempts--;\n          }\n        }\n\n        // At this point we should have All bad results (Exceptions)\n        // Or should have returned with successful result.\n        if (badResults.size() \u003d\u003d 1) {\n          throw badResults.values().iterator().next();\n        } else {\n          throw new MultiException(badResults);\n        }\n      } finally {\n        if (executor !\u003d null) {\n          LOG.trace(\"Shutting down threadpool executor\");\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java",
      "extendedDetails": {}
    },
    "ac32b3576da4cc463dff85118163ccfff02215fc": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13388. RequestHedgingProxyProvider calls multiple configured NNs all the time. Contributed by Jinglun.\n",
      "commitDate": "09/04/18 9:16 AM",
      "commitName": "ac32b3576da4cc463dff85118163ccfff02215fc",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "24/02/18 2:25 PM",
      "commitNameOld": "c30a26abc54df669a77e0219fd9b48a47c179a99",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 43.74,
      "commitsBetweenForRepo": 410,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,82 +1,85 @@\n     invoke(Object proxy, final Method method, final Object[] args)\n             throws Throwable {\n+      if (currentUsedProxy !\u003d null) {\n+        return method.invoke(currentUsedProxy.proxy, args);\n+      }\n       Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n       int numAttempts \u003d 0;\n \n       ExecutorService executor \u003d null;\n       CompletionService\u003cObject\u003e completionService;\n       try {\n         // Optimization : if only 2 proxies are configured and one had failed\n         // over, then we dont need to create a threadpool etc.\n         targetProxies.remove(toIgnore);\n         if (targetProxies.size() \u003d\u003d 0) {\n           LOG.trace(\"No valid proxies left\");\n           throw new RemoteException(IOException.class.getName(),\n               \"No valid proxies left. All NameNode proxies have failed over.\");\n         }\n         if (targetProxies.size() \u003d\u003d 1) {\n           ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n           try {\n             currentUsedProxy \u003d proxyInfo;\n             Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n             LOG.debug(\"Invocation successful on [{}]\",\n                 currentUsedProxy.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ex) {\n             Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n             logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n             LOG.trace(\"Unsuccessful invocation on [{}]\",\n                 currentUsedProxy.proxyInfo);\n             throw unwrappedException;\n           }\n         }\n         executor \u003d Executors.newFixedThreadPool(proxies.size());\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n         for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                 targetProxies.entrySet()) {\n           Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n             @Override\n             public Object call() throws Exception {\n               LOG.trace(\"Invoking method {} on proxy {}\", method,\n                   pEntry.getValue().proxyInfo);\n               return method.invoke(pEntry.getValue().proxy, args);\n             }\n           };\n           proxyMap.put(completionService.submit(c), pEntry.getValue());\n           numAttempts++;\n         }\n \n         Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n         while (numAttempts \u003e 0) {\n           Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n           Object retVal;\n           try {\n             currentUsedProxy \u003d proxyMap.get(callResultFuture);\n             retVal \u003d callResultFuture.get();\n             LOG.debug(\"Invocation successful on [{}]\",\n                 currentUsedProxy.proxyInfo);\n             return retVal;\n           } catch (ExecutionException ex) {\n             Exception unwrappedException \u003d unwrapExecutionException(ex);\n             ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n             logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n             badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n             LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n             numAttempts--;\n           }\n         }\n \n         // At this point we should have All bad results (Exceptions)\n         // Or should have returned with successful result.\n         if (badResults.size() \u003d\u003d 1) {\n           throw badResults.values().iterator().next();\n         } else {\n           throw new MultiException(badResults);\n         }\n       } finally {\n         if (executor !\u003d null) {\n           LOG.trace(\"Shutting down threadpool executor\");\n           executor.shutdownNow();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    invoke(Object proxy, final Method method, final Object[] args)\n            throws Throwable {\n      if (currentUsedProxy !\u003d null) {\n        return method.invoke(currentUsedProxy.proxy, args);\n      }\n      Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n      int numAttempts \u003d 0;\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        // Optimization : if only 2 proxies are configured and one had failed\n        // over, then we dont need to create a threadpool etc.\n        targetProxies.remove(toIgnore);\n        if (targetProxies.size() \u003d\u003d 0) {\n          LOG.trace(\"No valid proxies left\");\n          throw new RemoteException(IOException.class.getName(),\n              \"No valid proxies left. All NameNode proxies have failed over.\");\n        }\n        if (targetProxies.size() \u003d\u003d 1) {\n          ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n          try {\n            currentUsedProxy \u003d proxyInfo;\n            Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n            LOG.debug(\"Invocation successful on [{}]\",\n                currentUsedProxy.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ex) {\n            Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n            logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n            LOG.trace(\"Unsuccessful invocation on [{}]\",\n                currentUsedProxy.proxyInfo);\n            throw unwrappedException;\n          }\n        }\n        executor \u003d Executors.newFixedThreadPool(proxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                targetProxies.entrySet()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              LOG.trace(\"Invoking method {} on proxy {}\", method,\n                  pEntry.getValue().proxyInfo);\n              return method.invoke(pEntry.getValue().proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pEntry.getValue());\n          numAttempts++;\n        }\n\n        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n        while (numAttempts \u003e 0) {\n          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n          Object retVal;\n          try {\n            currentUsedProxy \u003d proxyMap.get(callResultFuture);\n            retVal \u003d callResultFuture.get();\n            LOG.debug(\"Invocation successful on [{}]\",\n                currentUsedProxy.proxyInfo);\n            return retVal;\n          } catch (ExecutionException ex) {\n            Exception unwrappedException \u003d unwrapExecutionException(ex);\n            ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n            logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n            badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n            LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n            numAttempts--;\n          }\n        }\n\n        // At this point we should have All bad results (Exceptions)\n        // Or should have returned with successful result.\n        if (badResults.size() \u003d\u003d 1) {\n          throw badResults.values().iterator().next();\n        } else {\n          throw new MultiException(badResults);\n        }\n      } finally {\n        if (executor !\u003d null) {\n          LOG.trace(\"Shutting down threadpool executor\");\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java",
      "extendedDetails": {}
    },
    "c30a26abc54df669a77e0219fd9b48a47c179a99": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12865. RequestHedgingProxyProvider should handle case when none of the proxies are available. Contributed by Mukul Kumar Singh.\n",
      "commitDate": "24/02/18 2:25 PM",
      "commitName": "c30a26abc54df669a77e0219fd9b48a47c179a99",
      "commitAuthor": "Arpit Agarwal",
      "commitDateOld": "22/02/18 8:55 PM",
      "commitNameOld": "c36b4aa31ce25fbe5fa173bce36da2950d74a475",
      "commitAuthorOld": "Gabor Bota",
      "daysBetweenCommits": 1.73,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,77 +1,82 @@\n     invoke(Object proxy, final Method method, final Object[] args)\n             throws Throwable {\n       Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n       int numAttempts \u003d 0;\n \n       ExecutorService executor \u003d null;\n       CompletionService\u003cObject\u003e completionService;\n       try {\n         // Optimization : if only 2 proxies are configured and one had failed\n         // over, then we dont need to create a threadpool etc.\n         targetProxies.remove(toIgnore);\n+        if (targetProxies.size() \u003d\u003d 0) {\n+          LOG.trace(\"No valid proxies left\");\n+          throw new RemoteException(IOException.class.getName(),\n+              \"No valid proxies left. All NameNode proxies have failed over.\");\n+        }\n         if (targetProxies.size() \u003d\u003d 1) {\n           ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n           try {\n             currentUsedProxy \u003d proxyInfo;\n             Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n             LOG.debug(\"Invocation successful on [{}]\",\n                 currentUsedProxy.proxyInfo);\n             return retVal;\n           } catch (InvocationTargetException ex) {\n             Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n             logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n             LOG.trace(\"Unsuccessful invocation on [{}]\",\n                 currentUsedProxy.proxyInfo);\n             throw unwrappedException;\n           }\n         }\n         executor \u003d Executors.newFixedThreadPool(proxies.size());\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n         for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                 targetProxies.entrySet()) {\n           Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n             @Override\n             public Object call() throws Exception {\n               LOG.trace(\"Invoking method {} on proxy {}\", method,\n                   pEntry.getValue().proxyInfo);\n               return method.invoke(pEntry.getValue().proxy, args);\n             }\n           };\n           proxyMap.put(completionService.submit(c), pEntry.getValue());\n           numAttempts++;\n         }\n \n         Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n         while (numAttempts \u003e 0) {\n           Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n           Object retVal;\n           try {\n             currentUsedProxy \u003d proxyMap.get(callResultFuture);\n             retVal \u003d callResultFuture.get();\n             LOG.debug(\"Invocation successful on [{}]\",\n                 currentUsedProxy.proxyInfo);\n             return retVal;\n           } catch (ExecutionException ex) {\n             Exception unwrappedException \u003d unwrapExecutionException(ex);\n             ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n             logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n             badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n             LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n             numAttempts--;\n           }\n         }\n \n         // At this point we should have All bad results (Exceptions)\n         // Or should have returned with successful result.\n         if (badResults.size() \u003d\u003d 1) {\n           throw badResults.values().iterator().next();\n         } else {\n           throw new MultiException(badResults);\n         }\n       } finally {\n         if (executor !\u003d null) {\n           LOG.trace(\"Shutting down threadpool executor\");\n           executor.shutdownNow();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    invoke(Object proxy, final Method method, final Object[] args)\n            throws Throwable {\n      Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n      int numAttempts \u003d 0;\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        // Optimization : if only 2 proxies are configured and one had failed\n        // over, then we dont need to create a threadpool etc.\n        targetProxies.remove(toIgnore);\n        if (targetProxies.size() \u003d\u003d 0) {\n          LOG.trace(\"No valid proxies left\");\n          throw new RemoteException(IOException.class.getName(),\n              \"No valid proxies left. All NameNode proxies have failed over.\");\n        }\n        if (targetProxies.size() \u003d\u003d 1) {\n          ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n          try {\n            currentUsedProxy \u003d proxyInfo;\n            Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n            LOG.debug(\"Invocation successful on [{}]\",\n                currentUsedProxy.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ex) {\n            Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n            logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n            LOG.trace(\"Unsuccessful invocation on [{}]\",\n                currentUsedProxy.proxyInfo);\n            throw unwrappedException;\n          }\n        }\n        executor \u003d Executors.newFixedThreadPool(proxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                targetProxies.entrySet()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              LOG.trace(\"Invoking method {} on proxy {}\", method,\n                  pEntry.getValue().proxyInfo);\n              return method.invoke(pEntry.getValue().proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pEntry.getValue());\n          numAttempts++;\n        }\n\n        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n        while (numAttempts \u003e 0) {\n          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n          Object retVal;\n          try {\n            currentUsedProxy \u003d proxyMap.get(callResultFuture);\n            retVal \u003d callResultFuture.get();\n            LOG.debug(\"Invocation successful on [{}]\",\n                currentUsedProxy.proxyInfo);\n            return retVal;\n          } catch (ExecutionException ex) {\n            Exception unwrappedException \u003d unwrapExecutionException(ex);\n            ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n            logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n            badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n            LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n            numAttempts--;\n          }\n        }\n\n        // At this point we should have All bad results (Exceptions)\n        // Or should have returned with successful result.\n        if (badResults.size() \u003d\u003d 1) {\n          throw badResults.values().iterator().next();\n        } else {\n          throw new MultiException(badResults);\n        }\n      } finally {\n        if (executor !\u003d null) {\n          LOG.trace(\"Shutting down threadpool executor\");\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java",
      "extendedDetails": {}
    },
    "659e85e304d070f9908a96cf6a0e1cbafde6a434": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-12813.  RequestHedgingProxyProvider can hide Exception thrown from the Namenode for proxy size of 1.  Contributed by Mukul Kumar Singh\n",
      "commitDate": "20/11/17 5:09 PM",
      "commitName": "659e85e304d070f9908a96cf6a0e1cbafde6a434",
      "commitAuthor": "Tsz-Wo Nicholas Sze",
      "commitDateOld": "04/04/17 11:05 PM",
      "commitNameOld": "9e0e430f18d45cfe125dda8d85916edddf79e8d6",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 229.79,
      "commitsBetweenForRepo": 1620,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,77 @@\n     invoke(Object proxy, final Method method, final Object[] args)\n             throws Throwable {\n       Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n       int numAttempts \u003d 0;\n \n       ExecutorService executor \u003d null;\n       CompletionService\u003cObject\u003e completionService;\n       try {\n         // Optimization : if only 2 proxies are configured and one had failed\n         // over, then we dont need to create a threadpool etc.\n         targetProxies.remove(toIgnore);\n         if (targetProxies.size() \u003d\u003d 1) {\n           ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n-          Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n-          successfulProxy \u003d proxyInfo;\n-          return retVal;\n+          try {\n+            currentUsedProxy \u003d proxyInfo;\n+            Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n+            LOG.debug(\"Invocation successful on [{}]\",\n+                currentUsedProxy.proxyInfo);\n+            return retVal;\n+          } catch (InvocationTargetException ex) {\n+            Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n+            logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n+            LOG.trace(\"Unsuccessful invocation on [{}]\",\n+                currentUsedProxy.proxyInfo);\n+            throw unwrappedException;\n+          }\n         }\n         executor \u003d Executors.newFixedThreadPool(proxies.size());\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n         for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                 targetProxies.entrySet()) {\n           Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n             @Override\n             public Object call() throws Exception {\n               LOG.trace(\"Invoking method {} on proxy {}\", method,\n                   pEntry.getValue().proxyInfo);\n               return method.invoke(pEntry.getValue().proxy, args);\n             }\n           };\n           proxyMap.put(completionService.submit(c), pEntry.getValue());\n           numAttempts++;\n         }\n \n         Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n         while (numAttempts \u003e 0) {\n           Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n           Object retVal;\n           try {\n+            currentUsedProxy \u003d proxyMap.get(callResultFuture);\n             retVal \u003d callResultFuture.get();\n-            successfulProxy \u003d proxyMap.get(callResultFuture);\n             LOG.debug(\"Invocation successful on [{}]\",\n-                successfulProxy.proxyInfo);\n+                currentUsedProxy.proxyInfo);\n             return retVal;\n-          } catch (Exception ex) {\n+          } catch (ExecutionException ex) {\n+            Exception unwrappedException \u003d unwrapExecutionException(ex);\n             ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n-            logProxyException(ex, tProxyInfo.proxyInfo);\n-            badResults.put(tProxyInfo.proxyInfo, unwrapException(ex));\n+            logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n+            badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n             LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n             numAttempts--;\n           }\n         }\n \n         // At this point we should have All bad results (Exceptions)\n         // Or should have returned with successful result.\n         if (badResults.size() \u003d\u003d 1) {\n           throw badResults.values().iterator().next();\n         } else {\n           throw new MultiException(badResults);\n         }\n       } finally {\n         if (executor !\u003d null) {\n           LOG.trace(\"Shutting down threadpool executor\");\n           executor.shutdownNow();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    invoke(Object proxy, final Method method, final Object[] args)\n            throws Throwable {\n      Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n      int numAttempts \u003d 0;\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        // Optimization : if only 2 proxies are configured and one had failed\n        // over, then we dont need to create a threadpool etc.\n        targetProxies.remove(toIgnore);\n        if (targetProxies.size() \u003d\u003d 1) {\n          ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n          try {\n            currentUsedProxy \u003d proxyInfo;\n            Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n            LOG.debug(\"Invocation successful on [{}]\",\n                currentUsedProxy.proxyInfo);\n            return retVal;\n          } catch (InvocationTargetException ex) {\n            Exception unwrappedException \u003d unwrapInvocationTargetException(ex);\n            logProxyException(unwrappedException, currentUsedProxy.proxyInfo);\n            LOG.trace(\"Unsuccessful invocation on [{}]\",\n                currentUsedProxy.proxyInfo);\n            throw unwrappedException;\n          }\n        }\n        executor \u003d Executors.newFixedThreadPool(proxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                targetProxies.entrySet()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              LOG.trace(\"Invoking method {} on proxy {}\", method,\n                  pEntry.getValue().proxyInfo);\n              return method.invoke(pEntry.getValue().proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pEntry.getValue());\n          numAttempts++;\n        }\n\n        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n        while (numAttempts \u003e 0) {\n          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n          Object retVal;\n          try {\n            currentUsedProxy \u003d proxyMap.get(callResultFuture);\n            retVal \u003d callResultFuture.get();\n            LOG.debug(\"Invocation successful on [{}]\",\n                currentUsedProxy.proxyInfo);\n            return retVal;\n          } catch (ExecutionException ex) {\n            Exception unwrappedException \u003d unwrapExecutionException(ex);\n            ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n            logProxyException(unwrappedException, tProxyInfo.proxyInfo);\n            badResults.put(tProxyInfo.proxyInfo, unwrappedException);\n            LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n            numAttempts--;\n          }\n        }\n\n        // At this point we should have All bad results (Exceptions)\n        // Or should have returned with successful result.\n        if (badResults.size() \u003d\u003d 1) {\n          throw badResults.values().iterator().next();\n        } else {\n          throw new MultiException(badResults);\n        }\n      } finally {\n        if (executor !\u003d null) {\n          LOG.trace(\"Shutting down threadpool executor\");\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java",
      "extendedDetails": {}
    },
    "9e0e430f18d45cfe125dda8d85916edddf79e8d6": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-11538. Move ClientProtocol HA proxies into hadoop-hdfs-client. Contributed by Huafeng Wang.\n",
      "commitDate": "04/04/17 11:05 PM",
      "commitName": "9e0e430f18d45cfe125dda8d85916edddf79e8d6",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "04/04/17 9:08 PM",
      "commitNameOld": "19b89c4c7be0236aafded560b7bcad7e39d1c4ed",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 0.08,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    invoke(Object proxy, final Method method, final Object[] args)\n            throws Throwable {\n      Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n      int numAttempts \u003d 0;\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        // Optimization : if only 2 proxies are configured and one had failed\n        // over, then we dont need to create a threadpool etc.\n        targetProxies.remove(toIgnore);\n        if (targetProxies.size() \u003d\u003d 1) {\n          ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n          Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n          successfulProxy \u003d proxyInfo;\n          return retVal;\n        }\n        executor \u003d Executors.newFixedThreadPool(proxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                targetProxies.entrySet()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              LOG.trace(\"Invoking method {} on proxy {}\", method,\n                  pEntry.getValue().proxyInfo);\n              return method.invoke(pEntry.getValue().proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pEntry.getValue());\n          numAttempts++;\n        }\n\n        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n        while (numAttempts \u003e 0) {\n          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n          Object retVal;\n          try {\n            retVal \u003d callResultFuture.get();\n            successfulProxy \u003d proxyMap.get(callResultFuture);\n            LOG.debug(\"Invocation successful on [{}]\",\n                successfulProxy.proxyInfo);\n            return retVal;\n          } catch (Exception ex) {\n            ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n            logProxyException(ex, tProxyInfo.proxyInfo);\n            badResults.put(tProxyInfo.proxyInfo, unwrapException(ex));\n            LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n            numAttempts--;\n          }\n        }\n\n        // At this point we should have All bad results (Exceptions)\n        // Or should have returned with successful result.\n        if (badResults.size() \u003d\u003d 1) {\n          throw badResults.values().iterator().next();\n        } else {\n          throw new MultiException(badResults);\n        }\n      } finally {\n        if (executor !\u003d null) {\n          LOG.trace(\"Shutting down threadpool executor\");\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java"
      }
    },
    "55796a0946f80a35055701a34379e374399009c5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11395. RequestHedgingProxyProvider#RequestHedgingInvocationHandler hides the Exception thrown from NameNode. Contributed by Nandakumar.\n",
      "commitDate": "13/03/17 2:24 PM",
      "commitName": "55796a0946f80a35055701a34379e374399009c5",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "05/10/16 3:08 PM",
      "commitNameOld": "e68c7b96c76b243da53ae539e7c760bf2c08f26e",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 158.97,
      "commitsBetweenForRepo": 992,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,66 @@\n     invoke(Object proxy, final Method method, final Object[] args)\n             throws Throwable {\n       Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n       int numAttempts \u003d 0;\n \n       ExecutorService executor \u003d null;\n       CompletionService\u003cObject\u003e completionService;\n       try {\n         // Optimization : if only 2 proxies are configured and one had failed\n         // over, then we dont need to create a threadpool etc.\n         targetProxies.remove(toIgnore);\n         if (targetProxies.size() \u003d\u003d 1) {\n           ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n           Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n           successfulProxy \u003d proxyInfo;\n           return retVal;\n         }\n         executor \u003d Executors.newFixedThreadPool(proxies.size());\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n         for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                 targetProxies.entrySet()) {\n           Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n             @Override\n             public Object call() throws Exception {\n               LOG.trace(\"Invoking method {} on proxy {}\", method,\n                   pEntry.getValue().proxyInfo);\n               return method.invoke(pEntry.getValue().proxy, args);\n             }\n           };\n           proxyMap.put(completionService.submit(c), pEntry.getValue());\n           numAttempts++;\n         }\n \n         Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n         while (numAttempts \u003e 0) {\n           Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n           Object retVal;\n           try {\n             retVal \u003d callResultFuture.get();\n             successfulProxy \u003d proxyMap.get(callResultFuture);\n             LOG.debug(\"Invocation successful on [{}]\",\n                 successfulProxy.proxyInfo);\n             return retVal;\n           } catch (Exception ex) {\n             ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n             logProxyException(ex, tProxyInfo.proxyInfo);\n-            badResults.put(tProxyInfo.proxyInfo, ex);\n+            badResults.put(tProxyInfo.proxyInfo, unwrapException(ex));\n             LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n             numAttempts--;\n           }\n         }\n \n         // At this point we should have All bad results (Exceptions)\n         // Or should have returned with successful result.\n         if (badResults.size() \u003d\u003d 1) {\n           throw badResults.values().iterator().next();\n         } else {\n           throw new MultiException(badResults);\n         }\n       } finally {\n         if (executor !\u003d null) {\n           LOG.trace(\"Shutting down threadpool executor\");\n           executor.shutdownNow();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    invoke(Object proxy, final Method method, final Object[] args)\n            throws Throwable {\n      Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n      int numAttempts \u003d 0;\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        // Optimization : if only 2 proxies are configured and one had failed\n        // over, then we dont need to create a threadpool etc.\n        targetProxies.remove(toIgnore);\n        if (targetProxies.size() \u003d\u003d 1) {\n          ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n          Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n          successfulProxy \u003d proxyInfo;\n          return retVal;\n        }\n        executor \u003d Executors.newFixedThreadPool(proxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                targetProxies.entrySet()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              LOG.trace(\"Invoking method {} on proxy {}\", method,\n                  pEntry.getValue().proxyInfo);\n              return method.invoke(pEntry.getValue().proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pEntry.getValue());\n          numAttempts++;\n        }\n\n        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n        while (numAttempts \u003e 0) {\n          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n          Object retVal;\n          try {\n            retVal \u003d callResultFuture.get();\n            successfulProxy \u003d proxyMap.get(callResultFuture);\n            LOG.debug(\"Invocation successful on [{}]\",\n                successfulProxy.proxyInfo);\n            return retVal;\n          } catch (Exception ex) {\n            ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n            logProxyException(ex, tProxyInfo.proxyInfo);\n            badResults.put(tProxyInfo.proxyInfo, unwrapException(ex));\n            LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n            numAttempts--;\n          }\n        }\n\n        // At this point we should have All bad results (Exceptions)\n        // Or should have returned with successful result.\n        if (badResults.size() \u003d\u003d 1) {\n          throw badResults.values().iterator().next();\n        } else {\n          throw new MultiException(badResults);\n        }\n      } finally {\n        if (executor !\u003d null) {\n          LOG.trace(\"Shutting down threadpool executor\");\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java",
      "extendedDetails": {}
    },
    "e68c7b96c76b243da53ae539e7c760bf2c08f26e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-10962. TestRequestHedgingProxyProvider is flaky.\n",
      "commitDate": "05/10/16 3:08 PM",
      "commitName": "e68c7b96c76b243da53ae539e7c760bf2c08f26e",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "26/04/16 9:45 AM",
      "commitNameOld": "c6a2430b47692a72c500373d6fc1bce78652675b",
      "commitAuthorOld": "Kihwal Lee",
      "daysBetweenCommits": 162.22,
      "commitsBetweenForRepo": 1184,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,66 @@\n     invoke(Object proxy, final Method method, final Object[] args)\n             throws Throwable {\n       Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n       int numAttempts \u003d 0;\n \n       ExecutorService executor \u003d null;\n       CompletionService\u003cObject\u003e completionService;\n       try {\n         // Optimization : if only 2 proxies are configured and one had failed\n         // over, then we dont need to create a threadpool etc.\n         targetProxies.remove(toIgnore);\n         if (targetProxies.size() \u003d\u003d 1) {\n           ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n           Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n           successfulProxy \u003d proxyInfo;\n           return retVal;\n         }\n         executor \u003d Executors.newFixedThreadPool(proxies.size());\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n         for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                 targetProxies.entrySet()) {\n           Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n             @Override\n             public Object call() throws Exception {\n+              LOG.trace(\"Invoking method {} on proxy {}\", method,\n+                  pEntry.getValue().proxyInfo);\n               return method.invoke(pEntry.getValue().proxy, args);\n             }\n           };\n           proxyMap.put(completionService.submit(c), pEntry.getValue());\n           numAttempts++;\n         }\n \n         Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n         while (numAttempts \u003e 0) {\n           Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n           Object retVal;\n           try {\n             retVal \u003d callResultFuture.get();\n             successfulProxy \u003d proxyMap.get(callResultFuture);\n-            if (LOG.isDebugEnabled()) {\n-              LOG.debug(\"Invocation successful on [\"\n-                      + successfulProxy.proxyInfo + \"]\");\n-            }\n+            LOG.debug(\"Invocation successful on [{}]\",\n+                successfulProxy.proxyInfo);\n             return retVal;\n           } catch (Exception ex) {\n             ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n             logProxyException(ex, tProxyInfo.proxyInfo);\n             badResults.put(tProxyInfo.proxyInfo, ex);\n+            LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n             numAttempts--;\n           }\n         }\n \n         // At this point we should have All bad results (Exceptions)\n         // Or should have returned with successful result.\n         if (badResults.size() \u003d\u003d 1) {\n           throw badResults.values().iterator().next();\n         } else {\n           throw new MultiException(badResults);\n         }\n       } finally {\n         if (executor !\u003d null) {\n+          LOG.trace(\"Shutting down threadpool executor\");\n           executor.shutdownNow();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    invoke(Object proxy, final Method method, final Object[] args)\n            throws Throwable {\n      Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n      int numAttempts \u003d 0;\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        // Optimization : if only 2 proxies are configured and one had failed\n        // over, then we dont need to create a threadpool etc.\n        targetProxies.remove(toIgnore);\n        if (targetProxies.size() \u003d\u003d 1) {\n          ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n          Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n          successfulProxy \u003d proxyInfo;\n          return retVal;\n        }\n        executor \u003d Executors.newFixedThreadPool(proxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                targetProxies.entrySet()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              LOG.trace(\"Invoking method {} on proxy {}\", method,\n                  pEntry.getValue().proxyInfo);\n              return method.invoke(pEntry.getValue().proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pEntry.getValue());\n          numAttempts++;\n        }\n\n        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n        while (numAttempts \u003e 0) {\n          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n          Object retVal;\n          try {\n            retVal \u003d callResultFuture.get();\n            successfulProxy \u003d proxyMap.get(callResultFuture);\n            LOG.debug(\"Invocation successful on [{}]\",\n                successfulProxy.proxyInfo);\n            return retVal;\n          } catch (Exception ex) {\n            ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n            logProxyException(ex, tProxyInfo.proxyInfo);\n            badResults.put(tProxyInfo.proxyInfo, ex);\n            LOG.trace(\"Unsuccessful invocation on [{}]\", tProxyInfo.proxyInfo);\n            numAttempts--;\n          }\n        }\n\n        // At this point we should have All bad results (Exceptions)\n        // Or should have returned with successful result.\n        if (badResults.size() \u003d\u003d 1) {\n          throw badResults.values().iterator().next();\n        } else {\n          throw new MultiException(badResults);\n        }\n      } finally {\n        if (executor !\u003d null) {\n          LOG.trace(\"Shutting down threadpool executor\");\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java",
      "extendedDetails": {}
    },
    "9fdfb546fb67526ba261da5cbd005f33e0f1d9e1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-9797. Log Standby exceptions thrown by RequestHedgingProxyProvider at DEBUG Level (Inigo Goiri via asuresh)\n",
      "commitDate": "12/02/16 11:18 AM",
      "commitName": "9fdfb546fb67526ba261da5cbd005f33e0f1d9e1",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "27/07/15 11:02 PM",
      "commitNameOld": "030fcfa99c345ad57625486eeabedebf2fd4411f",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 199.55,
      "commitsBetweenForRepo": 1343,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,64 @@\n     invoke(Object proxy, final Method method, final Object[] args)\n             throws Throwable {\n       Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n       int numAttempts \u003d 0;\n \n       ExecutorService executor \u003d null;\n       CompletionService\u003cObject\u003e completionService;\n       try {\n         // Optimization : if only 2 proxies are configured and one had failed\n         // over, then we dont need to create a threadpool etc.\n         targetProxies.remove(toIgnore);\n         if (targetProxies.size() \u003d\u003d 1) {\n           ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n           Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n           successfulProxy \u003d proxyInfo;\n           return retVal;\n         }\n         executor \u003d Executors.newFixedThreadPool(proxies.size());\n         completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n         for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                 targetProxies.entrySet()) {\n           Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n             @Override\n             public Object call() throws Exception {\n               return method.invoke(pEntry.getValue().proxy, args);\n             }\n           };\n           proxyMap.put(completionService.submit(c), pEntry.getValue());\n           numAttempts++;\n         }\n \n         Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n         while (numAttempts \u003e 0) {\n           Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n           Object retVal;\n           try {\n             retVal \u003d callResultFuture.get();\n             successfulProxy \u003d proxyMap.get(callResultFuture);\n             if (LOG.isDebugEnabled()) {\n               LOG.debug(\"Invocation successful on [\"\n                       + successfulProxy.proxyInfo + \"]\");\n             }\n             return retVal;\n           } catch (Exception ex) {\n             ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n-            LOG.warn(\"Invocation returned exception on \"\n-                    + \"[\" + tProxyInfo.proxyInfo + \"]\");\n+            logProxyException(ex, tProxyInfo.proxyInfo);\n             badResults.put(tProxyInfo.proxyInfo, ex);\n             numAttempts--;\n           }\n         }\n \n         // At this point we should have All bad results (Exceptions)\n         // Or should have returned with successful result.\n         if (badResults.size() \u003d\u003d 1) {\n           throw badResults.values().iterator().next();\n         } else {\n           throw new MultiException(badResults);\n         }\n       } finally {\n         if (executor !\u003d null) {\n           executor.shutdownNow();\n         }\n       }\n     }\n\\ No newline at end of file\n",
      "actualSource": "    invoke(Object proxy, final Method method, final Object[] args)\n            throws Throwable {\n      Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n      int numAttempts \u003d 0;\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        // Optimization : if only 2 proxies are configured and one had failed\n        // over, then we dont need to create a threadpool etc.\n        targetProxies.remove(toIgnore);\n        if (targetProxies.size() \u003d\u003d 1) {\n          ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n          Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n          successfulProxy \u003d proxyInfo;\n          return retVal;\n        }\n        executor \u003d Executors.newFixedThreadPool(proxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                targetProxies.entrySet()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              return method.invoke(pEntry.getValue().proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pEntry.getValue());\n          numAttempts++;\n        }\n\n        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n        while (numAttempts \u003e 0) {\n          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n          Object retVal;\n          try {\n            retVal \u003d callResultFuture.get();\n            successfulProxy \u003d proxyMap.get(callResultFuture);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Invocation successful on [\"\n                      + successfulProxy.proxyInfo + \"]\");\n            }\n            return retVal;\n          } catch (Exception ex) {\n            ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n            logProxyException(ex, tProxyInfo.proxyInfo);\n            badResults.put(tProxyInfo.proxyInfo, ex);\n            numAttempts--;\n          }\n        }\n\n        // At this point we should have All bad results (Exceptions)\n        // Or should have returned with successful result.\n        if (badResults.size() \u003d\u003d 1) {\n          throw badResults.values().iterator().next();\n        } else {\n          throw new MultiException(badResults);\n        }\n      } finally {\n        if (executor !\u003d null) {\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java",
      "extendedDetails": {}
    },
    "030fcfa99c345ad57625486eeabedebf2fd4411f": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-7858. Improve HA Namenode Failover detection on the client. (asuresh)\n",
      "commitDate": "27/07/15 11:02 PM",
      "commitName": "030fcfa99c345ad57625486eeabedebf2fd4411f",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,65 @@\n+    invoke(Object proxy, final Method method, final Object[] args)\n+            throws Throwable {\n+      Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n+      int numAttempts \u003d 0;\n+\n+      ExecutorService executor \u003d null;\n+      CompletionService\u003cObject\u003e completionService;\n+      try {\n+        // Optimization : if only 2 proxies are configured and one had failed\n+        // over, then we dont need to create a threadpool etc.\n+        targetProxies.remove(toIgnore);\n+        if (targetProxies.size() \u003d\u003d 1) {\n+          ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n+          Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n+          successfulProxy \u003d proxyInfo;\n+          return retVal;\n+        }\n+        executor \u003d Executors.newFixedThreadPool(proxies.size());\n+        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n+        for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n+                targetProxies.entrySet()) {\n+          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n+            @Override\n+            public Object call() throws Exception {\n+              return method.invoke(pEntry.getValue().proxy, args);\n+            }\n+          };\n+          proxyMap.put(completionService.submit(c), pEntry.getValue());\n+          numAttempts++;\n+        }\n+\n+        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n+        while (numAttempts \u003e 0) {\n+          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n+          Object retVal;\n+          try {\n+            retVal \u003d callResultFuture.get();\n+            successfulProxy \u003d proxyMap.get(callResultFuture);\n+            if (LOG.isDebugEnabled()) {\n+              LOG.debug(\"Invocation successful on [\"\n+                      + successfulProxy.proxyInfo + \"]\");\n+            }\n+            return retVal;\n+          } catch (Exception ex) {\n+            ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n+            LOG.warn(\"Invocation returned exception on \"\n+                    + \"[\" + tProxyInfo.proxyInfo + \"]\");\n+            badResults.put(tProxyInfo.proxyInfo, ex);\n+            numAttempts--;\n+          }\n+        }\n+\n+        // At this point we should have All bad results (Exceptions)\n+        // Or should have returned with successful result.\n+        if (badResults.size() \u003d\u003d 1) {\n+          throw badResults.values().iterator().next();\n+        } else {\n+          throw new MultiException(badResults);\n+        }\n+      } finally {\n+        if (executor !\u003d null) {\n+          executor.shutdownNow();\n+        }\n+      }\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    invoke(Object proxy, final Method method, final Object[] args)\n            throws Throwable {\n      Map\u003cFuture\u003cObject\u003e, ProxyInfo\u003cT\u003e\u003e proxyMap \u003d new HashMap\u003c\u003e();\n      int numAttempts \u003d 0;\n\n      ExecutorService executor \u003d null;\n      CompletionService\u003cObject\u003e completionService;\n      try {\n        // Optimization : if only 2 proxies are configured and one had failed\n        // over, then we dont need to create a threadpool etc.\n        targetProxies.remove(toIgnore);\n        if (targetProxies.size() \u003d\u003d 1) {\n          ProxyInfo\u003cT\u003e proxyInfo \u003d targetProxies.values().iterator().next();\n          Object retVal \u003d method.invoke(proxyInfo.proxy, args);\n          successfulProxy \u003d proxyInfo;\n          return retVal;\n        }\n        executor \u003d Executors.newFixedThreadPool(proxies.size());\n        completionService \u003d new ExecutorCompletionService\u003c\u003e(executor);\n        for (final Map.Entry\u003cString, ProxyInfo\u003cT\u003e\u003e pEntry :\n                targetProxies.entrySet()) {\n          Callable\u003cObject\u003e c \u003d new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              return method.invoke(pEntry.getValue().proxy, args);\n            }\n          };\n          proxyMap.put(completionService.submit(c), pEntry.getValue());\n          numAttempts++;\n        }\n\n        Map\u003cString, Exception\u003e badResults \u003d new HashMap\u003c\u003e();\n        while (numAttempts \u003e 0) {\n          Future\u003cObject\u003e callResultFuture \u003d completionService.take();\n          Object retVal;\n          try {\n            retVal \u003d callResultFuture.get();\n            successfulProxy \u003d proxyMap.get(callResultFuture);\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"Invocation successful on [\"\n                      + successfulProxy.proxyInfo + \"]\");\n            }\n            return retVal;\n          } catch (Exception ex) {\n            ProxyInfo\u003cT\u003e tProxyInfo \u003d proxyMap.get(callResultFuture);\n            LOG.warn(\"Invocation returned exception on \"\n                    + \"[\" + tProxyInfo.proxyInfo + \"]\");\n            badResults.put(tProxyInfo.proxyInfo, ex);\n            numAttempts--;\n          }\n        }\n\n        // At this point we should have All bad results (Exceptions)\n        // Or should have returned with successful result.\n        if (badResults.size() \u003d\u003d 1) {\n          throw badResults.values().iterator().next();\n        } else {\n          throw new MultiException(badResults);\n        }\n      } finally {\n        if (executor !\u003d null) {\n          executor.shutdownNow();\n        }\n      }\n    }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/ha/RequestHedgingProxyProvider.java"
    }
  }
}