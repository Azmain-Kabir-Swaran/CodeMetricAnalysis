{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "YarnChild.java",
  "functionName": "main",
  "functionId": "main___args-String[]",
  "sourceFilePath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
  "functionStartLine": 77,
  "functionEndLine": 232,
  "numCommitsSeen": 33,
  "timeTaken": 9924,
  "changeHistory": [
    "0b6625a9735f76ab473b41d8ab9b7f3c7678cfff",
    "a37e7f0ad8b68c7ed16c242bedf62f4cde48d6fd",
    "453d48bdfbb67ed3e66c33c4aef239c3d7bdd3bc",
    "8f6e14399a3e77e1bdcc5034f7601e9f62163dea",
    "8676a118a12165ae5a8b80a2a4596c133471ebc1",
    "6b710a42e00acca405e085724c89cda016cf7442",
    "0af1a2b5bc1469ba22edb63cd58f9b436b1dc4d3",
    "549bcc2c02983086ee6694982d5f3503f5f4517f",
    "b7b3a7e0118ccd02105c2435340be70b1c7b9bfa",
    "d1963ad4bd1fb735bfa39e2b70773bdf1f623a87",
    "c09f00771e5f13a091e4bda7bbe8084b4138a379",
    "2cc851a66e86b82ed6f9fc3b86c2df3001519c51",
    "4d8e350750748b919ee2158690a44cd9fd80dcae",
    "009af54d5192c822ba1299c1389e67266dfe7ad1",
    "905b17876c44634545a68300ff2f2d73fb86d3b7",
    "63f941d2ad71bf528c5f565ec206a49571c59169",
    "6f6e170325d39f9f7b543a39791b2cb54692f83d",
    "aeb364d8b57f4de79d3489bef2071cea9c0c840e",
    "11782dd3a5ee5a2f6ad42b335f0386d00baa9ae1",
    "aa60da6c2ec049cc70897afee6c368cb70493773",
    "15150cd997dd2180f5c011fb223c1a8095e441c5",
    "5795fcfd9904431ec075fdce7ab8559ff50eccd2",
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517"
  ],
  "changeHistoryShort": {
    "0b6625a9735f76ab473b41d8ab9b7f3c7678cfff": "Ybodychange",
    "a37e7f0ad8b68c7ed16c242bedf62f4cde48d6fd": "Ybodychange",
    "453d48bdfbb67ed3e66c33c4aef239c3d7bdd3bc": "Ybodychange",
    "8f6e14399a3e77e1bdcc5034f7601e9f62163dea": "Ybodychange",
    "8676a118a12165ae5a8b80a2a4596c133471ebc1": "Ybodychange",
    "6b710a42e00acca405e085724c89cda016cf7442": "Ybodychange",
    "0af1a2b5bc1469ba22edb63cd58f9b436b1dc4d3": "Ybodychange",
    "549bcc2c02983086ee6694982d5f3503f5f4517f": "Ybodychange",
    "b7b3a7e0118ccd02105c2435340be70b1c7b9bfa": "Ybodychange",
    "d1963ad4bd1fb735bfa39e2b70773bdf1f623a87": "Ybodychange",
    "c09f00771e5f13a091e4bda7bbe8084b4138a379": "Ybodychange",
    "2cc851a66e86b82ed6f9fc3b86c2df3001519c51": "Ybodychange",
    "4d8e350750748b919ee2158690a44cd9fd80dcae": "Ybodychange",
    "009af54d5192c822ba1299c1389e67266dfe7ad1": "Ybodychange",
    "905b17876c44634545a68300ff2f2d73fb86d3b7": "Ybodychange",
    "63f941d2ad71bf528c5f565ec206a49571c59169": "Ybodychange",
    "6f6e170325d39f9f7b543a39791b2cb54692f83d": "Ybodychange",
    "aeb364d8b57f4de79d3489bef2071cea9c0c840e": "Ybodychange",
    "11782dd3a5ee5a2f6ad42b335f0386d00baa9ae1": "Ybodychange",
    "aa60da6c2ec049cc70897afee6c368cb70493773": "Ybodychange",
    "15150cd997dd2180f5c011fb223c1a8095e441c5": "Ybodychange",
    "5795fcfd9904431ec075fdce7ab8559ff50eccd2": "Ybodychange",
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0b6625a9735f76ab473b41d8ab9b7f3c7678cfff": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7148. Fast fail jobs when exceeds dfs quota limitation. Contributed by Wang Yan\n",
      "commitDate": "07/11/18 6:20 AM",
      "commitName": "0b6625a9735f76ab473b41d8ab9b7f3c7678cfff",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "26/01/18 12:36 PM",
      "commitNameOld": "a37e7f0ad8b68c7ed16c242bedf62f4cde48d6fd",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 284.74,
      "commitsBetweenForRepo": 2834,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,157 +1,156 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n     // Initing with our JobConf allows us to avoid loading confs twice\n     Limits.init(job);\n     UserGroupInformation.setConfiguration(job);\n     // MAPREDUCE-6565: need to set configuration for SecurityUtil.\n     SecurityUtil.setConfiguration(job);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     long jvmIdLong \u003d Long.parseLong(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n     \n     CallerContext.setCurrent(\n         new CallerContext.Builder(\"mr_\" + firstTaskid.toString()).build());\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens: {}\", credentials.getAllTokens());\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, job);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n     ScheduledExecutorService logSyncer \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       configureTask(job, task, credentials, jt);\n \n       // log the system properties\n       String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n       if (systemPropsToLog !\u003d null) {\n         LOG.info(systemPropsToLog);\n       }\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n       logSyncer \u003d TaskLog.createLogSyncer();\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           setEncryptedSpillKeyIfRequired(taskFinal);\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.error(\"FSError from child\", e);\n       if (!ShutdownHookManager.get().isShutdownInProgress()) {\n         umbilical.fsError(taskid, e.getMessage());\n       }\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n-          umbilical.fatalError(taskid,\n-              StringUtils.stringifyException(exception), false);\n+          reportError(exception, task, umbilical);\n         }\n       }\n     } catch (Throwable throwable) {\n       LOG.error(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           Throwable tCause \u003d throwable.getCause();\n           String cause \u003d\n               tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                   .stringifyException(tCause);\n           umbilical.fatalError(taskid, cause, false);\n         }\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       TaskLog.syncLogsShutdown(logSyncer);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n    // Initing with our JobConf allows us to avoid loading confs twice\n    Limits.init(job);\n    UserGroupInformation.setConfiguration(job);\n    // MAPREDUCE-6565: need to set configuration for SecurityUtil.\n    SecurityUtil.setConfiguration(job);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    long jvmIdLong \u003d Long.parseLong(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n    \n    CallerContext.setCurrent(\n        new CallerContext.Builder(\"mr_\" + firstTaskid.toString()).build());\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens: {}\", credentials.getAllTokens());\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, job);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n    ScheduledExecutorService logSyncer \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      configureTask(job, task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      logSyncer \u003d TaskLog.createLogSyncer();\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          setEncryptedSpillKeyIfRequired(taskFinal);\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.error(\"FSError from child\", e);\n      if (!ShutdownHookManager.get().isShutdownInProgress()) {\n        umbilical.fsError(taskid, e.getMessage());\n      }\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          reportError(exception, task, umbilical);\n        }\n      }\n    } catch (Throwable throwable) {\n      LOG.error(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          Throwable tCause \u003d throwable.getCause();\n          String cause \u003d\n              tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                  .stringifyException(tCause);\n          umbilical.fatalError(taskid, cause, false);\n        }\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      TaskLog.syncLogsShutdown(logSyncer);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "a37e7f0ad8b68c7ed16c242bedf62f4cde48d6fd": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-7022. Fast fail rogue jobs based on task scratch dir size. Contributed by Johan Gustavsson\n",
      "commitDate": "26/01/18 12:36 PM",
      "commitName": "a37e7f0ad8b68c7ed16c242bedf62f4cde48d6fd",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "02/10/17 8:14 PM",
      "commitNameOld": "453d48bdfbb67ed3e66c33c4aef239c3d7bdd3bc",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 115.72,
      "commitsBetweenForRepo": 791,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,157 +1,157 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n     // Initing with our JobConf allows us to avoid loading confs twice\n     Limits.init(job);\n     UserGroupInformation.setConfiguration(job);\n     // MAPREDUCE-6565: need to set configuration for SecurityUtil.\n     SecurityUtil.setConfiguration(job);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     long jvmIdLong \u003d Long.parseLong(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n     \n     CallerContext.setCurrent(\n         new CallerContext.Builder(\"mr_\" + firstTaskid.toString()).build());\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens: {}\", credentials.getAllTokens());\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, job);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n     ScheduledExecutorService logSyncer \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       configureTask(job, task, credentials, jt);\n \n       // log the system properties\n       String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n       if (systemPropsToLog !\u003d null) {\n         LOG.info(systemPropsToLog);\n       }\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n       logSyncer \u003d TaskLog.createLogSyncer();\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           setEncryptedSpillKeyIfRequired(taskFinal);\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.error(\"FSError from child\", e);\n       if (!ShutdownHookManager.get().isShutdownInProgress()) {\n         umbilical.fsError(taskid, e.getMessage());\n       }\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           umbilical.fatalError(taskid,\n-              StringUtils.stringifyException(exception));\n+              StringUtils.stringifyException(exception), false);\n         }\n       }\n     } catch (Throwable throwable) {\n       LOG.error(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           Throwable tCause \u003d throwable.getCause();\n           String cause \u003d\n               tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                   .stringifyException(tCause);\n-          umbilical.fatalError(taskid, cause);\n+          umbilical.fatalError(taskid, cause, false);\n         }\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       TaskLog.syncLogsShutdown(logSyncer);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n    // Initing with our JobConf allows us to avoid loading confs twice\n    Limits.init(job);\n    UserGroupInformation.setConfiguration(job);\n    // MAPREDUCE-6565: need to set configuration for SecurityUtil.\n    SecurityUtil.setConfiguration(job);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    long jvmIdLong \u003d Long.parseLong(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n    \n    CallerContext.setCurrent(\n        new CallerContext.Builder(\"mr_\" + firstTaskid.toString()).build());\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens: {}\", credentials.getAllTokens());\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, job);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n    ScheduledExecutorService logSyncer \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      configureTask(job, task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      logSyncer \u003d TaskLog.createLogSyncer();\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          setEncryptedSpillKeyIfRequired(taskFinal);\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.error(\"FSError from child\", e);\n      if (!ShutdownHookManager.get().isShutdownInProgress()) {\n        umbilical.fsError(taskid, e.getMessage());\n      }\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          umbilical.fatalError(taskid,\n              StringUtils.stringifyException(exception), false);\n        }\n      }\n    } catch (Throwable throwable) {\n      LOG.error(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          Throwable tCause \u003d throwable.getCause();\n          String cause \u003d\n              tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                  .stringifyException(tCause);\n          umbilical.fatalError(taskid, cause, false);\n        }\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      TaskLog.syncLogsShutdown(logSyncer);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "453d48bdfbb67ed3e66c33c4aef239c3d7bdd3bc": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6971. Moving logging APIs over to slf4j in hadoop-mapreduce-client-app. Contributed by Jinjiang Ling.\n",
      "commitDate": "02/10/17 8:14 PM",
      "commitName": "453d48bdfbb67ed3e66c33c4aef239c3d7bdd3bc",
      "commitAuthor": "Akira Ajisaka",
      "commitDateOld": "29/11/16 3:51 PM",
      "commitNameOld": "8f6e14399a3e77e1bdcc5034f7601e9f62163dea",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 307.14,
      "commitsBetweenForRepo": 1863,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,160 +1,157 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n     // Initing with our JobConf allows us to avoid loading confs twice\n     Limits.init(job);\n     UserGroupInformation.setConfiguration(job);\n     // MAPREDUCE-6565: need to set configuration for SecurityUtil.\n     SecurityUtil.setConfiguration(job);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     long jvmIdLong \u003d Long.parseLong(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n     \n     CallerContext.setCurrent(\n         new CallerContext.Builder(\"mr_\" + firstTaskid.toString()).build());\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n-    LOG.info(\"Executing with tokens:\");\n-    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n-      LOG.info(token);\n-    }\n+    LOG.info(\"Executing with tokens: {}\", credentials.getAllTokens());\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, job);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n     ScheduledExecutorService logSyncer \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n-      JvmTask myTask \u003d null;;\n+      JvmTask myTask \u003d null;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       configureTask(job, task, credentials, jt);\n \n       // log the system properties\n       String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n       if (systemPropsToLog !\u003d null) {\n         LOG.info(systemPropsToLog);\n       }\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n       logSyncer \u003d TaskLog.createLogSyncer();\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           setEncryptedSpillKeyIfRequired(taskFinal);\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n-      LOG.fatal(\"FSError from child\", e);\n+      LOG.error(\"FSError from child\", e);\n       if (!ShutdownHookManager.get().isShutdownInProgress()) {\n         umbilical.fsError(taskid, e.getMessage());\n       }\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           umbilical.fatalError(taskid,\n               StringUtils.stringifyException(exception));\n         }\n       }\n     } catch (Throwable throwable) {\n-      LOG.fatal(\"Error running child : \"\n+      LOG.error(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           Throwable tCause \u003d throwable.getCause();\n           String cause \u003d\n               tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                   .stringifyException(tCause);\n           umbilical.fatalError(taskid, cause);\n         }\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       TaskLog.syncLogsShutdown(logSyncer);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n    // Initing with our JobConf allows us to avoid loading confs twice\n    Limits.init(job);\n    UserGroupInformation.setConfiguration(job);\n    // MAPREDUCE-6565: need to set configuration for SecurityUtil.\n    SecurityUtil.setConfiguration(job);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    long jvmIdLong \u003d Long.parseLong(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n    \n    CallerContext.setCurrent(\n        new CallerContext.Builder(\"mr_\" + firstTaskid.toString()).build());\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens: {}\", credentials.getAllTokens());\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, job);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n    ScheduledExecutorService logSyncer \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      configureTask(job, task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      logSyncer \u003d TaskLog.createLogSyncer();\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          setEncryptedSpillKeyIfRequired(taskFinal);\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.error(\"FSError from child\", e);\n      if (!ShutdownHookManager.get().isShutdownInProgress()) {\n        umbilical.fsError(taskid, e.getMessage());\n      }\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          umbilical.fatalError(taskid,\n              StringUtils.stringifyException(exception));\n        }\n      }\n    } catch (Throwable throwable) {\n      LOG.error(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          Throwable tCause \u003d throwable.getCause();\n          String cause \u003d\n              tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                  .stringifyException(tCause);\n          umbilical.fatalError(taskid, cause);\n        }\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      TaskLog.syncLogsShutdown(logSyncer);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "8f6e14399a3e77e1bdcc5034f7601e9f62163dea": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6565. Configuration to use host name in delegation token service is not read from job.xml during MapReduce job execution. Contributed by Li Lu.\n",
      "commitDate": "29/11/16 3:51 PM",
      "commitName": "8f6e14399a3e77e1bdcc5034f7601e9f62163dea",
      "commitAuthor": "Junping Du",
      "commitDateOld": "14/06/16 3:06 PM",
      "commitNameOld": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 168.07,
      "commitsBetweenForRepo": 1323,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,158 +1,160 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n     // Initing with our JobConf allows us to avoid loading confs twice\n     Limits.init(job);\n     UserGroupInformation.setConfiguration(job);\n+    // MAPREDUCE-6565: need to set configuration for SecurityUtil.\n+    SecurityUtil.setConfiguration(job);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     long jvmIdLong \u003d Long.parseLong(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n     \n     CallerContext.setCurrent(\n         new CallerContext.Builder(\"mr_\" + firstTaskid.toString()).build());\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens:\");\n     for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n       LOG.info(token);\n     }\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, job);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n     ScheduledExecutorService logSyncer \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       configureTask(job, task, credentials, jt);\n \n       // log the system properties\n       String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n       if (systemPropsToLog !\u003d null) {\n         LOG.info(systemPropsToLog);\n       }\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n       logSyncer \u003d TaskLog.createLogSyncer();\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           setEncryptedSpillKeyIfRequired(taskFinal);\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       if (!ShutdownHookManager.get().isShutdownInProgress()) {\n         umbilical.fsError(taskid, e.getMessage());\n       }\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           umbilical.fatalError(taskid,\n               StringUtils.stringifyException(exception));\n         }\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           Throwable tCause \u003d throwable.getCause();\n           String cause \u003d\n               tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                   .stringifyException(tCause);\n           umbilical.fatalError(taskid, cause);\n         }\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       TaskLog.syncLogsShutdown(logSyncer);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n    // Initing with our JobConf allows us to avoid loading confs twice\n    Limits.init(job);\n    UserGroupInformation.setConfiguration(job);\n    // MAPREDUCE-6565: need to set configuration for SecurityUtil.\n    SecurityUtil.setConfiguration(job);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    long jvmIdLong \u003d Long.parseLong(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n    \n    CallerContext.setCurrent(\n        new CallerContext.Builder(\"mr_\" + firstTaskid.toString()).build());\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, job);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n    ScheduledExecutorService logSyncer \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      configureTask(job, task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      logSyncer \u003d TaskLog.createLogSyncer();\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          setEncryptedSpillKeyIfRequired(taskFinal);\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      if (!ShutdownHookManager.get().isShutdownInProgress()) {\n        umbilical.fsError(taskid, e.getMessage());\n      }\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          umbilical.fatalError(taskid,\n              StringUtils.stringifyException(exception));\n        }\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          Throwable tCause \u003d throwable.getCause();\n          String cause \u003d\n              tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                  .stringifyException(tCause);\n          umbilical.fatalError(taskid, cause);\n        }\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      TaskLog.syncLogsShutdown(logSyncer);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "8676a118a12165ae5a8b80a2a4596c133471ebc1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4349. Support CallerContext in YARN. Contributed by Wangda Tan\n",
      "commitDate": "23/11/15 5:19 PM",
      "commitName": "8676a118a12165ae5a8b80a2a4596c133471ebc1",
      "commitAuthor": "Jian He",
      "commitDateOld": "14/05/15 4:07 PM",
      "commitNameOld": "6b710a42e00acca405e085724c89cda016cf7442",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 193.09,
      "commitsBetweenForRepo": 1517,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,155 +1,158 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n     // Initing with our JobConf allows us to avoid loading confs twice\n     Limits.init(job);\n     UserGroupInformation.setConfiguration(job);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     long jvmIdLong \u003d Long.parseLong(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n+    \n+    CallerContext.setCurrent(\n+        new CallerContext.Builder(\"mr_\" + firstTaskid.toString()).build());\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens:\");\n     for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n       LOG.info(token);\n     }\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, job);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n     ScheduledExecutorService logSyncer \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       configureTask(job, task, credentials, jt);\n \n       // log the system properties\n       String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n       if (systemPropsToLog !\u003d null) {\n         LOG.info(systemPropsToLog);\n       }\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n       logSyncer \u003d TaskLog.createLogSyncer();\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           setEncryptedSpillKeyIfRequired(taskFinal);\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       if (!ShutdownHookManager.get().isShutdownInProgress()) {\n         umbilical.fsError(taskid, e.getMessage());\n       }\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           umbilical.fatalError(taskid,\n               StringUtils.stringifyException(exception));\n         }\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           Throwable tCause \u003d throwable.getCause();\n           String cause \u003d\n               tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                   .stringifyException(tCause);\n           umbilical.fatalError(taskid, cause);\n         }\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       TaskLog.syncLogsShutdown(logSyncer);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n    // Initing with our JobConf allows us to avoid loading confs twice\n    Limits.init(job);\n    UserGroupInformation.setConfiguration(job);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    long jvmIdLong \u003d Long.parseLong(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n    \n    CallerContext.setCurrent(\n        new CallerContext.Builder(\"mr_\" + firstTaskid.toString()).build());\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, job);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n    ScheduledExecutorService logSyncer \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      configureTask(job, task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      logSyncer \u003d TaskLog.createLogSyncer();\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          setEncryptedSpillKeyIfRequired(taskFinal);\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      if (!ShutdownHookManager.get().isShutdownInProgress()) {\n        umbilical.fsError(taskid, e.getMessage());\n      }\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          umbilical.fatalError(taskid,\n              StringUtils.stringifyException(exception));\n        }\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          Throwable tCause \u003d throwable.getCause();\n          String cause \u003d\n              tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                  .stringifyException(tCause);\n          umbilical.fatalError(taskid, cause);\n        }\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      TaskLog.syncLogsShutdown(logSyncer);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "6b710a42e00acca405e085724c89cda016cf7442": {
      "type": "Ybodychange",
      "commitMessage": "Fixing MR intermediate spills. Contributed by Arun Suresh.\n",
      "commitDate": "14/05/15 4:07 PM",
      "commitName": "6b710a42e00acca405e085724c89cda016cf7442",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "15/10/14 3:22 PM",
      "commitNameOld": "0af1a2b5bc1469ba22edb63cd58f9b436b1dc4d3",
      "commitAuthorOld": "Jian He",
      "daysBetweenCommits": 211.03,
      "commitsBetweenForRepo": 1812,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,154 +1,155 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n     // Initing with our JobConf allows us to avoid loading confs twice\n     Limits.init(job);\n     UserGroupInformation.setConfiguration(job);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     long jvmIdLong \u003d Long.parseLong(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens:\");\n     for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n       LOG.info(token);\n     }\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, job);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n     ScheduledExecutorService logSyncer \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       configureTask(job, task, credentials, jt);\n \n       // log the system properties\n       String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n       if (systemPropsToLog !\u003d null) {\n         LOG.info(systemPropsToLog);\n       }\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n       logSyncer \u003d TaskLog.createLogSyncer();\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n+          setEncryptedSpillKeyIfRequired(taskFinal);\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       if (!ShutdownHookManager.get().isShutdownInProgress()) {\n         umbilical.fsError(taskid, e.getMessage());\n       }\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           umbilical.fatalError(taskid,\n               StringUtils.stringifyException(exception));\n         }\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           Throwable tCause \u003d throwable.getCause();\n           String cause \u003d\n               tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                   .stringifyException(tCause);\n           umbilical.fatalError(taskid, cause);\n         }\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       TaskLog.syncLogsShutdown(logSyncer);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n    // Initing with our JobConf allows us to avoid loading confs twice\n    Limits.init(job);\n    UserGroupInformation.setConfiguration(job);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    long jvmIdLong \u003d Long.parseLong(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, job);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n    ScheduledExecutorService logSyncer \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      configureTask(job, task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      logSyncer \u003d TaskLog.createLogSyncer();\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          setEncryptedSpillKeyIfRequired(taskFinal);\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      if (!ShutdownHookManager.get().isShutdownInProgress()) {\n        umbilical.fsError(taskid, e.getMessage());\n      }\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          umbilical.fatalError(taskid,\n              StringUtils.stringifyException(exception));\n        }\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          Throwable tCause \u003d throwable.getCause();\n          String cause \u003d\n              tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                  .stringifyException(tCause);\n          umbilical.fatalError(taskid, cause);\n        }\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      TaskLog.syncLogsShutdown(logSyncer);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "0af1a2b5bc1469ba22edb63cd58f9b436b1dc4d3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2312. Deprecated old ContainerId#getId API and updated MapReduce to use ContainerId#getContainerId instead. Contributed by Tsuyoshi OZAWA\n",
      "commitDate": "15/10/14 3:22 PM",
      "commitName": "0af1a2b5bc1469ba22edb63cd58f9b436b1dc4d3",
      "commitAuthor": "Jian He",
      "commitDateOld": "22/09/14 8:20 AM",
      "commitNameOld": "7039b98e1c459e9e0d8caa28cdaa2868e2bde2eb",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 23.29,
      "commitsBetweenForRepo": 234,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,154 +1,154 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n     // Initing with our JobConf allows us to avoid loading confs twice\n     Limits.init(job);\n     UserGroupInformation.setConfiguration(job);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n-    int jvmIdInt \u003d Integer.parseInt(args[3]);\n+    long jvmIdLong \u003d Long.parseLong(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n-        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n+        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens:\");\n     for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n       LOG.info(token);\n     }\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, job);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n     ScheduledExecutorService logSyncer \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       configureTask(job, task, credentials, jt);\n \n       // log the system properties\n       String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n       if (systemPropsToLog !\u003d null) {\n         LOG.info(systemPropsToLog);\n       }\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n       logSyncer \u003d TaskLog.createLogSyncer();\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       if (!ShutdownHookManager.get().isShutdownInProgress()) {\n         umbilical.fsError(taskid, e.getMessage());\n       }\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           umbilical.fatalError(taskid,\n               StringUtils.stringifyException(exception));\n         }\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         if (!ShutdownHookManager.get().isShutdownInProgress()) {\n           Throwable tCause \u003d throwable.getCause();\n           String cause \u003d\n               tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                   .stringifyException(tCause);\n           umbilical.fatalError(taskid, cause);\n         }\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       TaskLog.syncLogsShutdown(logSyncer);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n    // Initing with our JobConf allows us to avoid loading confs twice\n    Limits.init(job);\n    UserGroupInformation.setConfiguration(job);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    long jvmIdLong \u003d Long.parseLong(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdLong);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, job);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n    ScheduledExecutorService logSyncer \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      configureTask(job, task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      logSyncer \u003d TaskLog.createLogSyncer();\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      if (!ShutdownHookManager.get().isShutdownInProgress()) {\n        umbilical.fsError(taskid, e.getMessage());\n      }\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          umbilical.fatalError(taskid,\n              StringUtils.stringifyException(exception));\n        }\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          Throwable tCause \u003d throwable.getCause();\n          String cause \u003d\n              tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                  .stringifyException(tCause);\n          umbilical.fatalError(taskid, cause);\n        }\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      TaskLog.syncLogsShutdown(logSyncer);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "549bcc2c02983086ee6694982d5f3503f5f4517f": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-6002. Made MR task avoid reporting error to AM when the task process is shutting down. Contributed by Wangda Tan.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1613743 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "26/07/14 6:37 PM",
      "commitName": "549bcc2c02983086ee6694982d5f3503f5f4517f",
      "commitAuthor": "Zhijie Shen",
      "commitDateOld": "29/03/14 12:14 PM",
      "commitNameOld": "b7b3a7e0118ccd02105c2435340be70b1c7b9bfa",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 119.27,
      "commitsBetweenForRepo": 741,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,147 +1,154 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n     // Initing with our JobConf allows us to avoid loading confs twice\n     Limits.init(job);\n     UserGroupInformation.setConfiguration(job);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens:\");\n     for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n       LOG.info(token);\n     }\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, job);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n     ScheduledExecutorService logSyncer \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       configureTask(job, task, credentials, jt);\n \n       // log the system properties\n       String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n       if (systemPropsToLog !\u003d null) {\n         LOG.info(systemPropsToLog);\n       }\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n       logSyncer \u003d TaskLog.createLogSyncer();\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n-      umbilical.fsError(taskid, e.getMessage());\n+      if (!ShutdownHookManager.get().isShutdownInProgress()) {\n+        umbilical.fsError(taskid, e.getMessage());\n+      }\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n-        umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n+        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n+          umbilical.fatalError(taskid,\n+              StringUtils.stringifyException(exception));\n+        }\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n-        Throwable tCause \u003d throwable.getCause();\n-        String cause \u003d tCause \u003d\u003d null\n-                                 ? throwable.getMessage()\n-                                 : StringUtils.stringifyException(tCause);\n-        umbilical.fatalError(taskid, cause);\n+        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n+          Throwable tCause \u003d throwable.getCause();\n+          String cause \u003d\n+              tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n+                  .stringifyException(tCause);\n+          umbilical.fatalError(taskid, cause);\n+        }\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       TaskLog.syncLogsShutdown(logSyncer);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n    // Initing with our JobConf allows us to avoid loading confs twice\n    Limits.init(job);\n    UserGroupInformation.setConfiguration(job);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, job);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n    ScheduledExecutorService logSyncer \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      configureTask(job, task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      logSyncer \u003d TaskLog.createLogSyncer();\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      if (!ShutdownHookManager.get().isShutdownInProgress()) {\n        umbilical.fsError(taskid, e.getMessage());\n      }\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          umbilical.fatalError(taskid,\n              StringUtils.stringifyException(exception));\n        }\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        if (!ShutdownHookManager.get().isShutdownInProgress()) {\n          Throwable tCause \u003d throwable.getCause();\n          String cause \u003d\n              tCause \u003d\u003d null ? throwable.getMessage() : StringUtils\n                  .stringifyException(tCause);\n          umbilical.fatalError(taskid, cause);\n        }\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      TaskLog.syncLogsShutdown(logSyncer);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "b7b3a7e0118ccd02105c2435340be70b1c7b9bfa": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5813. Fix YarnChild to explicitly load job.xml from the local-filesystem, rather than rely on the classpath. Contributed by Gera Shegalov.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1583050 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/03/14 12:14 PM",
      "commitName": "b7b3a7e0118ccd02105c2435340be70b1c7b9bfa",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "21/01/14 11:23 AM",
      "commitNameOld": "d1963ad4bd1fb735bfa39e2b70773bdf1f623a87",
      "commitAuthorOld": "Jason Darrell Lowe",
      "daysBetweenCommits": 66.99,
      "commitsBetweenForRepo": 601,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,147 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n-    final JobConf job \u003d new JobConf();\n+    final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n     // Initing with our JobConf allows us to avoid loading confs twice\n     Limits.init(job);\n-    job.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(job);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens:\");\n     for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n       LOG.info(token);\n     }\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, job);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n     ScheduledExecutorService logSyncer \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       configureTask(job, task, credentials, jt);\n \n       // log the system properties\n       String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n       if (systemPropsToLog !\u003d null) {\n         LOG.info(systemPropsToLog);\n       }\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n       logSyncer \u003d TaskLog.createLogSyncer();\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       TaskLog.syncLogsShutdown(logSyncer);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf job \u003d new JobConf(MRJobConfig.JOB_CONF_FILE);\n    // Initing with our JobConf allows us to avoid loading confs twice\n    Limits.init(job);\n    UserGroupInformation.setConfiguration(job);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, job);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n    ScheduledExecutorService logSyncer \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      configureTask(job, task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      logSyncer \u003d TaskLog.createLogSyncer();\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      TaskLog.syncLogsShutdown(logSyncer);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "d1963ad4bd1fb735bfa39e2b70773bdf1f623a87": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5693. Restore MRv1 behavior for log flush. Contributed by Gera Shegalov\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1560148 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/01/14 11:23 AM",
      "commitName": "d1963ad4bd1fb735bfa39e2b70773bdf1f623a87",
      "commitAuthor": "Jason Darrell Lowe",
      "commitDateOld": "18/09/13 6:44 AM",
      "commitNameOld": "c09f00771e5f13a091e4bda7bbe8084b4138a379",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 125.24,
      "commitsBetweenForRepo": 749,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,148 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf job \u003d new JobConf();\n     // Initing with our JobConf allows us to avoid loading confs twice\n     Limits.init(job);\n     job.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(job);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens:\");\n     for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n       LOG.info(token);\n     }\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, job);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n+    ScheduledExecutorService logSyncer \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       configureTask(job, task, credentials, jt);\n \n       // log the system properties\n       String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n       if (systemPropsToLog !\u003d null) {\n         LOG.info(systemPropsToLog);\n       }\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n+      logSyncer \u003d TaskLog.createLogSyncer();\n+\n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n-      // Shutting down log4j of the child-vm...\n-      // This assumes that on return from Task.run()\n-      // there is no more logging done.\n-      LogManager.shutdown();\n+      TaskLog.syncLogsShutdown(logSyncer);\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf job \u003d new JobConf();\n    // Initing with our JobConf allows us to avoid loading confs twice\n    Limits.init(job);\n    job.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(job);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, job);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n    ScheduledExecutorService logSyncer \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      configureTask(job, task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      logSyncer \u003d TaskLog.createLogSyncer();\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      TaskLog.syncLogsShutdown(logSyncer);\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "c09f00771e5f13a091e4bda7bbe8084b4138a379": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5487. In task processes, JobConf is unnecessarily loaded again in Limits (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1524408 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/09/13 6:44 AM",
      "commitName": "c09f00771e5f13a091e4bda7bbe8084b4138a379",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "29/08/13 4:45 PM",
      "commitNameOld": "2cc851a66e86b82ed6f9fc3b86c2df3001519c51",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 19.58,
      "commitsBetweenForRepo": 91,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,148 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf job \u003d new JobConf();\n+    // Initing with our JobConf allows us to avoid loading confs twice\n+    Limits.init(job);\n     job.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(job);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens:\");\n     for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n       LOG.info(token);\n     }\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, job);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       configureTask(job, task, credentials, jt);\n \n       // log the system properties\n       String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n       if (systemPropsToLog !\u003d null) {\n         LOG.info(systemPropsToLog);\n       }\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf job \u003d new JobConf();\n    // Initing with our JobConf allows us to avoid loading confs twice\n    Limits.init(job);\n    job.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(job);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, job);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      configureTask(job, task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "2cc851a66e86b82ed6f9fc3b86c2df3001519c51": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5484. YarnChild unnecessarily loads job conf twice (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1518857 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/08/13 4:45 PM",
      "commitName": "2cc851a66e86b82ed6f9fc3b86c2df3001519c51",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "14/05/13 4:43 PM",
      "commitNameOld": "4d8e350750748b919ee2158690a44cd9fd80dcae",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 107.0,
      "commitsBetweenForRepo": 650,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,146 +1,146 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n-    final JobConf defaultConf \u003d new JobConf();\n-    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n-    UserGroupInformation.setConfiguration(defaultConf);\n+    final JobConf job \u003d new JobConf();\n+    job.addResource(MRJobConfig.JOB_CONF_FILE);\n+    UserGroupInformation.setConfiguration(job);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens:\");\n     for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n       LOG.info(token);\n     }\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n-            TaskUmbilicalProtocol.versionID, address, defaultConf);\n+            TaskUmbilicalProtocol.versionID, address, job);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n-      final JobConf job \u003d configureTask(task, credentials, jt);\n+      configureTask(job, task, credentials, jt);\n \n       // log the system properties\n       String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n       if (systemPropsToLog !\u003d null) {\n         LOG.info(systemPropsToLog);\n       }\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf job \u003d new JobConf();\n    job.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(job);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, job);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      configureTask(job, task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "4d8e350750748b919ee2158690a44cd9fd80dcae": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5232. Add a configuration to be able to log classpath and other system properties on mapreduce JVMs startup. Contributed by Sangjin Lee.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1482643 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/05/13 4:43 PM",
      "commitName": "4d8e350750748b919ee2158690a44cd9fd80dcae",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "23/04/13 2:39 PM",
      "commitNameOld": "27e8c86999bc6a972a99216060b11ef35b7de858",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 21.09,
      "commitsBetweenForRepo": 153,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,140 +1,146 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf defaultConf \u003d new JobConf();\n     defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(defaultConf);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens:\");\n     for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n       LOG.info(token);\n     }\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, defaultConf);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       final JobConf job \u003d configureTask(task, credentials, jt);\n \n+      // log the system properties\n+      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n+      if (systemPropsToLog !\u003d null) {\n+        LOG.info(systemPropsToLog);\n+      }\n+\n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // set job classloader if configured before invoking the task\n       MRApps.setJobClassLoader(job);\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d configureTask(task, credentials, jt);\n\n      // log the system properties\n      String systemPropsToLog \u003d MRApps.getSystemPropertiesToLog(job);\n      if (systemPropsToLog !\u003d null) {\n        LOG.info(systemPropsToLog);\n      }\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "009af54d5192c822ba1299c1389e67266dfe7ad1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-5146. application classloader may be used too early to load classes. Contributed by Sangjin Lee.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1470694 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "22/04/13 1:07 PM",
      "commitName": "009af54d5192c822ba1299c1389e67266dfe7ad1",
      "commitAuthor": "Thomas White",
      "commitDateOld": "15/03/13 2:09 PM",
      "commitNameOld": "7d7553c4eb7d9a282410a3213d26a89fea9b7865",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 37.96,
      "commitsBetweenForRepo": 195,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,137 +1,140 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf defaultConf \u003d new JobConf();\n     defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(defaultConf);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens:\");\n     for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n       LOG.info(token);\n     }\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, defaultConf);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       final JobConf job \u003d configureTask(task, credentials, jt);\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n+      // set job classloader if configured before invoking the task\n+      MRApps.setJobClassLoader(job);\n+\n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       if (taskid !\u003d null) {\n         umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d configureTask(task, credentials, jt);\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // set job classloader if configured before invoking the task\n      MRApps.setJobClassLoader(job);\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "905b17876c44634545a68300ff2f2d73fb86d3b7": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4723. Fix warnings found by findbugs 2. Contributed by Sandy Ryza\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1409601 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "14/11/12 4:16 PM",
      "commitName": "905b17876c44634545a68300ff2f2d73fb86d3b7",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "31/08/12 1:37 PM",
      "commitNameOld": "63f941d2ad71bf528c5f565ec206a49571c59169",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 75.15,
      "commitsBetweenForRepo": 447,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,139 +1,137 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf defaultConf \u003d new JobConf();\n     defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(defaultConf);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     LOG.info(\"Executing with tokens:\");\n     for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n       LOG.info(token);\n     }\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, defaultConf);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       final JobConf job \u003d configureTask(task, credentials, jt);\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n-      ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n-      exception.printStackTrace(new PrintStream(baos));\n       if (taskid !\u003d null) {\n-        umbilical.fatalError(taskid, baos.toString());\n+        umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d configureTask(task, credentials, jt);\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, StringUtils.stringifyException(exception));\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "63f941d2ad71bf528c5f565ec206a49571c59169": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4614. Simplify debugging a job\u0027s tokens (daryn via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1379595 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/08/12 1:37 PM",
      "commitName": "63f941d2ad71bf528c5f565ec206a49571c59169",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "30/08/12 12:58 PM",
      "commitNameOld": "6f6e170325d39f9f7b543a39791b2cb54692f83d",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 1.03,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,139 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf defaultConf \u003d new JobConf();\n     defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(defaultConf);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n-    \n+    LOG.info(\"Executing with tokens:\");\n+    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n+      LOG.info(token);\n+    }\n+\n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, defaultConf);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       final JobConf job \u003d configureTask(task, credentials, jt);\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       childUGI.addCredentials(credentials);\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n       exception.printStackTrace(new PrintStream(baos));\n       if (taskid !\u003d null) {\n         umbilical.fatalError(taskid, baos.toString());\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    LOG.info(\"Executing with tokens:\");\n    for (Token\u003c?\u003e token: credentials.getAllTokens()) {\n      LOG.info(token);\n    }\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d configureTask(task, credentials, jt);\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n      exception.printStackTrace(new PrintStream(baos));\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, baos.toString());\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "6f6e170325d39f9f7b543a39791b2cb54692f83d": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8726. The Secrets in Credentials are not available to MR tasks (daryn and Benoy Antony via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1379100 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/08/12 12:58 PM",
      "commitName": "6f6e170325d39f9f7b543a39791b2cb54692f83d",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "23/08/12 11:06 AM",
      "commitNameOld": "aeb364d8b57f4de79d3489bef2071cea9c0c840e",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 7.08,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,135 +1,135 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf defaultConf \u003d new JobConf();\n     defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(defaultConf);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     // Security framework already loaded the tokens into current ugi\n     Credentials credentials \u003d\n         UserGroupInformation.getCurrentUser().getCredentials();\n     \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n     SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, defaultConf);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       final JobConf job \u003d configureTask(task, credentials, jt);\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n-      job.getCredentials().addTokensToUGI(childUGI);\n+      childUGI.addCredentials(credentials);\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n       exception.printStackTrace(new PrintStream(baos));\n       if (taskid !\u003d null) {\n         umbilical.fatalError(taskid, baos.toString());\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    \n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d configureTask(task, credentials, jt);\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      childUGI.addCredentials(credentials);\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n      exception.printStackTrace(new PrintStream(baos));\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, baos.toString());\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "aeb364d8b57f4de79d3489bef2071cea9c0c840e": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-8225. DistCp fails when invoked by Oozie (daryn via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1376618 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/08/12 11:06 AM",
      "commitName": "aeb364d8b57f4de79d3489bef2071cea9c0c840e",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "09/07/12 2:08 PM",
      "commitNameOld": "11782dd3a5ee5a2f6ad42b335f0386d00baa9ae1",
      "commitAuthorOld": "Thomas Graves",
      "daysBetweenCommits": 44.87,
      "commitsBetweenForRepo": 260,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,134 +1,135 @@\n   public static void main(String[] args) throws Throwable {\n     Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf defaultConf \u003d new JobConf();\n     defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(defaultConf);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n-    Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n-\n+    // Security framework already loaded the tokens into current ugi\n+    Credentials credentials \u003d\n+        UserGroupInformation.getCurrentUser().getCredentials();\n+    \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n+    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n+    SecurityUtil.setTokenService(jt, address);\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, defaultConf);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n-      final JobConf job \u003d\n-        configureTask(task, defaultConf.getCredentials(), jt);\n+      final JobConf job \u003d configureTask(task, credentials, jt);\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n-      for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n-        childUGI.addToken(token);\n-      }\n+      job.getCredentials().addTokensToUGI(childUGI);\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n       exception.printStackTrace(new PrintStream(baos));\n       if (taskid !\u003d null) {\n         umbilical.fatalError(taskid, baos.toString());\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    // Security framework already loaded the tokens into current ugi\n    Credentials credentials \u003d\n        UserGroupInformation.getCurrentUser().getCredentials();\n    \n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    Token\u003cJobTokenIdentifier\u003e jt \u003d TokenCache.getJobToken(credentials);\n    SecurityUtil.setTokenService(jt, address);\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d configureTask(task, credentials, jt);\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      job.getCredentials().addTokensToUGI(childUGI);\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n      exception.printStackTrace(new PrintStream(baos));\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, baos.toString());\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "11782dd3a5ee5a2f6ad42b335f0386d00baa9ae1": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4300. OOM in AM can turn it into a zombie. (Robert Evans via tgraves)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1359399 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/07/12 2:08 PM",
      "commitName": "11782dd3a5ee5a2f6ad42b335f0386d00baa9ae1",
      "commitAuthor": "Thomas Graves",
      "commitDateOld": "08/05/12 8:07 AM",
      "commitNameOld": "aa60da6c2ec049cc70897afee6c368cb70493773",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 62.25,
      "commitsBetweenForRepo": 305,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,133 +1,134 @@\n   public static void main(String[] args) throws Throwable {\n+    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n     LOG.debug(\"Child starting\");\n \n     final JobConf defaultConf \u003d new JobConf();\n     defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(defaultConf);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d\n         NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, defaultConf);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       final JobConf job \u003d\n         configureTask(task, defaultConf.getCredentials(), jt);\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n         childUGI.addToken(token);\n       }\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n       exception.printStackTrace(new PrintStream(baos));\n       if (taskid !\u003d null) {\n         umbilical.fatalError(taskid, baos.toString());\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    Thread.setDefaultUncaughtExceptionHandler(new YarnUncaughtExceptionHandler());\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d\n        configureTask(task, defaultConf.getCredentials(), jt);\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n        childUGI.addToken(token);\n      }\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n      exception.printStackTrace(new PrintStream(baos));\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, baos.toString());\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "aa60da6c2ec049cc70897afee6c368cb70493773": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-4162. Correctly set token service (Daryn Sharp via bobby)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1335567 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/12 8:07 AM",
      "commitName": "aa60da6c2ec049cc70897afee6c368cb70493773",
      "commitAuthor": "Robert Joseph Evans",
      "commitDateOld": "03/04/12 11:29 AM",
      "commitNameOld": "b45c4500269ed3ece9a3f61aa08acf9b0af71011",
      "commitAuthorOld": "Robert Joseph Evans",
      "daysBetweenCommits": 34.86,
      "commitsBetweenForRepo": 260,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,133 @@\n   public static void main(String[] args) throws Throwable {\n     LOG.debug(\"Child starting\");\n \n     final JobConf defaultConf \u003d new JobConf();\n     defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(defaultConf);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n-    final InetSocketAddress address \u003d new InetSocketAddress(host, port);\n+    final InetSocketAddress address \u003d\n+        NetUtils.createSocketAddrForHost(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, defaultConf);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       final JobConf job \u003d\n         configureTask(task, defaultConf.getCredentials(), jt);\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       childUGI \u003d UserGroupInformation.createRemoteUser(System\n           .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n         childUGI.addToken(token);\n       }\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n       exception.printStackTrace(new PrintStream(baos));\n       if (taskid !\u003d null) {\n         umbilical.fatalError(taskid, baos.toString());\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d\n        NetUtils.createSocketAddrForHost(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d\n        configureTask(task, defaultConf.getCredentials(), jt);\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n        childUGI.addToken(token);\n      }\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n      exception.printStackTrace(new PrintStream(baos));\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, baos.toString());\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "15150cd997dd2180f5c011fb223c1a8095e441c5": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3280. Removed the unnecessary job user-name configuration in mapred-site.xml. (vinodkv)  \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1200441 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/11/11 9:28 AM",
      "commitName": "15150cd997dd2180f5c011fb223c1a8095e441c5",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/10/11 1:41 AM",
      "commitNameOld": "408656614495674992349fbda3981559ada3de0b",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 17.37,
      "commitsBetweenForRepo": 161,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,132 @@\n   public static void main(String[] args) throws Throwable {\n     LOG.debug(\"Child starting\");\n \n     final JobConf defaultConf \u003d new JobConf();\n     defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(defaultConf);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d new InetSocketAddress(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, defaultConf);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       final JobConf job \u003d\n         configureTask(task, defaultConf.getCredentials(), jt);\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n-      LOG.debug(\"Remote user: \" + job.get(\"user.name\"));\n-      childUGI \u003d UserGroupInformation.createRemoteUser(job.get(\"user.name\"));\n+      childUGI \u003d UserGroupInformation.createRemoteUser(System\n+          .getenv(ApplicationConstants.Environment.USER.toString()));\n       // Add tokens to new user so that it may execute its task correctly.\n       for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n         childUGI.addToken(token);\n       }\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n       exception.printStackTrace(new PrintStream(baos));\n       if (taskid !\u003d null) {\n         umbilical.fatalError(taskid, baos.toString());\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d new InetSocketAddress(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d\n        configureTask(task, defaultConf.getCredentials(), jt);\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      childUGI \u003d UserGroupInformation.createRemoteUser(System\n          .getenv(ApplicationConstants.Environment.USER.toString()));\n      // Add tokens to new user so that it may execute its task correctly.\n      for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n        childUGI.addToken(token);\n      }\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n      exception.printStackTrace(new PrintStream(baos));\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, baos.toString());\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "5795fcfd9904431ec075fdce7ab8559ff50eccd2": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-3058. Fixed MR YarnChild to report failure when task throws an error and thus prevent a hanging task and job. (vinodkv)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1187654 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/10/11 11:14 PM",
      "commitName": "5795fcfd9904431ec075fdce7ab8559ff50eccd2",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "21/09/11 11:28 AM",
      "commitNameOld": "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 30.49,
      "commitsBetweenForRepo": 235,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,132 @@\n   public static void main(String[] args) throws Throwable {\n     LOG.debug(\"Child starting\");\n \n     final JobConf defaultConf \u003d new JobConf();\n     defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(defaultConf);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d new InetSocketAddress(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, defaultConf);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       final JobConf job \u003d\n         configureTask(task, defaultConf.getCredentials(), jt);\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       LOG.debug(\"Remote user: \" + job.get(\"user.name\"));\n       childUGI \u003d UserGroupInformation.createRemoteUser(job.get(\"user.name\"));\n       // Add tokens to new user so that it may execute its task correctly.\n       for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n         childUGI.addToken(token);\n       }\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n       exception.printStackTrace(new PrintStream(baos));\n       if (taskid !\u003d null) {\n-        umbilical.reportDiagnosticInfo(taskid, baos.toString());\n+        umbilical.fatalError(taskid, baos.toString());\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d new InetSocketAddress(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d\n        configureTask(task, defaultConf.getCredentials(), jt);\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      LOG.debug(\"Remote user: \" + job.get(\"user.name\"));\n      childUGI \u003d UserGroupInformation.createRemoteUser(job.get(\"user.name\"));\n      // Add tokens to new user so that it may execute its task correctly.\n      for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n        childUGI.addToken(token);\n      }\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n      exception.printStackTrace(new PrintStream(baos));\n      if (taskid !\u003d null) {\n        umbilical.fatalError(taskid, baos.toString());\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "d00b3c49f6fb3f6a617add6203c6b55f6c345940": {
      "type": "Ybodychange",
      "commitMessage": "MAPREDUCE-2880. Improved classpath-construction for mapreduce AM and containers. Contributed by Arun C Murthy.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1173783 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/09/11 11:28 AM",
      "commitName": "d00b3c49f6fb3f6a617add6203c6b55f6c345940",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 27.76,
      "commitsBetweenForRepo": 171,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,132 +1,132 @@\n   public static void main(String[] args) throws Throwable {\n     LOG.debug(\"Child starting\");\n \n     final JobConf defaultConf \u003d new JobConf();\n-    defaultConf.addResource(MRConstants.JOB_CONF_FILE);\n+    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n     UserGroupInformation.setConfiguration(defaultConf);\n \n     String host \u003d args[0];\n     int port \u003d Integer.parseInt(args[1]);\n     final InetSocketAddress address \u003d new InetSocketAddress(host, port);\n     final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n     int jvmIdInt \u003d Integer.parseInt(args[3]);\n     JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n         firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n \n     // initialize metrics\n     DefaultMetricsSystem.initialize(\n         StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n \n     Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n \n     // Create TaskUmbilicalProtocol as actual task owner.\n     UserGroupInformation taskOwner \u003d\n       UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n     taskOwner.addToken(jt);\n     final TaskUmbilicalProtocol umbilical \u003d\n       taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n       @Override\n       public TaskUmbilicalProtocol run() throws Exception {\n         return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n             TaskUmbilicalProtocol.versionID, address, defaultConf);\n       }\n     });\n \n     // report non-pid to application master\n     JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n     LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n     Task task \u003d null;\n     UserGroupInformation childUGI \u003d null;\n \n     try {\n       int idleLoopCount \u003d 0;\n       JvmTask myTask \u003d null;;\n       // poll for new task\n       for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n         long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n         LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n             + \"ms before retrying again. Got null now.\");\n         MILLISECONDS.sleep(sleepTimeMilliSecs);\n         myTask \u003d umbilical.getTask(context);\n       }\n       if (myTask.shouldDie()) {\n         return;\n       }\n \n       task \u003d myTask.getTask();\n       YarnChild.taskid \u003d task.getTaskID();\n \n       // Create the job-conf and set credentials\n       final JobConf job \u003d\n         configureTask(task, defaultConf.getCredentials(), jt);\n \n       // Initiate Java VM metrics\n       JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n       LOG.debug(\"Remote user: \" + job.get(\"user.name\"));\n       childUGI \u003d UserGroupInformation.createRemoteUser(job.get(\"user.name\"));\n       // Add tokens to new user so that it may execute its task correctly.\n       for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n         childUGI.addToken(token);\n       }\n \n       // Create a final reference to the task for the doAs block\n       final Task taskFinal \u003d task;\n       childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n         @Override\n         public Object run() throws Exception {\n           // use job-specified working directory\n           FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n           taskFinal.run(job, umbilical); // run the task\n           return null;\n         }\n       });\n     } catch (FSError e) {\n       LOG.fatal(\"FSError from child\", e);\n       umbilical.fsError(taskid, e.getMessage());\n     } catch (Exception exception) {\n       LOG.warn(\"Exception running child : \"\n           + StringUtils.stringifyException(exception));\n       try {\n         if (task !\u003d null) {\n           // do cleanup for the task\n           if (childUGI \u003d\u003d null) { // no need to job into doAs block\n             task.taskCleanup(umbilical);\n           } else {\n             final Task taskFinal \u003d task;\n             childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n               @Override\n               public Object run() throws Exception {\n                 taskFinal.taskCleanup(umbilical);\n                 return null;\n               }\n             });\n           }\n         }\n       } catch (Exception e) {\n         LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n       }\n       // Report back any failures, for diagnostic purposes\n       ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n       exception.printStackTrace(new PrintStream(baos));\n       if (taskid !\u003d null) {\n         umbilical.reportDiagnosticInfo(taskid, baos.toString());\n       }\n     } catch (Throwable throwable) {\n       LOG.fatal(\"Error running child : \"\n     \t        + StringUtils.stringifyException(throwable));\n       if (taskid !\u003d null) {\n         Throwable tCause \u003d throwable.getCause();\n         String cause \u003d tCause \u003d\u003d null\n                                  ? throwable.getMessage()\n                                  : StringUtils.stringifyException(tCause);\n         umbilical.fatalError(taskid, cause);\n       }\n     } finally {\n       RPC.stopProxy(umbilical);\n       DefaultMetricsSystem.shutdown();\n       // Shutting down log4j of the child-vm...\n       // This assumes that on return from Task.run()\n       // there is no more logging done.\n       LogManager.shutdown();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRJobConfig.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d new InetSocketAddress(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d\n        configureTask(task, defaultConf.getCredentials(), jt);\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      LOG.debug(\"Remote user: \" + job.get(\"user.name\"));\n      childUGI \u003d UserGroupInformation.createRemoteUser(job.get(\"user.name\"));\n      // Add tokens to new user so that it may execute its task correctly.\n      for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n        childUGI.addToken(token);\n      }\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n      exception.printStackTrace(new PrintStream(baos));\n      if (taskid !\u003d null) {\n        umbilical.reportDiagnosticInfo(taskid, baos.toString());\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRConstants.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d new InetSocketAddress(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d\n        configureTask(task, defaultConf.getCredentials(), jt);\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      LOG.debug(\"Remote user: \" + job.get(\"user.name\"));\n      childUGI \u003d UserGroupInformation.createRemoteUser(job.get(\"user.name\"));\n      // Add tokens to new user so that it may execute its task correctly.\n      for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n        childUGI.addToken(token);\n      }\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n      exception.printStackTrace(new PrintStream(baos));\n      if (taskid !\u003d null) {\n        umbilical.reportDiagnosticInfo(taskid, baos.toString());\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java",
        "newPath": "hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java"
      }
    },
    "dbecbe5dfe50f834fc3b8401709079e9470cc517": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-279. MapReduce 2.0. Merging MR-279 branch into trunk. Contributed by Arun C Murthy, Christopher Douglas, Devaraj Das, Greg Roelofs, Jeffrey Naisbitt, Josh Wills, Jonathan Eagles, Krishna Ramachandran, Luke Lu, Mahadev Konar, Robert Evans, Sharad Agarwal, Siddharth Seth, Thomas Graves, and Vinod Kumar Vavilapalli.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159166 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/08/11 4:07 AM",
      "commitName": "dbecbe5dfe50f834fc3b8401709079e9470cc517",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "diff": "@@ -0,0 +1,132 @@\n+  public static void main(String[] args) throws Throwable {\n+    LOG.debug(\"Child starting\");\n+\n+    final JobConf defaultConf \u003d new JobConf();\n+    defaultConf.addResource(MRConstants.JOB_CONF_FILE);\n+    UserGroupInformation.setConfiguration(defaultConf);\n+\n+    String host \u003d args[0];\n+    int port \u003d Integer.parseInt(args[1]);\n+    final InetSocketAddress address \u003d new InetSocketAddress(host, port);\n+    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n+    int jvmIdInt \u003d Integer.parseInt(args[3]);\n+    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n+        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n+\n+    // initialize metrics\n+    DefaultMetricsSystem.initialize(\n+        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n+\n+    Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n+\n+    // Create TaskUmbilicalProtocol as actual task owner.\n+    UserGroupInformation taskOwner \u003d\n+      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n+    taskOwner.addToken(jt);\n+    final TaskUmbilicalProtocol umbilical \u003d\n+      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n+      @Override\n+      public TaskUmbilicalProtocol run() throws Exception {\n+        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n+            TaskUmbilicalProtocol.versionID, address, defaultConf);\n+      }\n+    });\n+\n+    // report non-pid to application master\n+    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n+    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n+    Task task \u003d null;\n+    UserGroupInformation childUGI \u003d null;\n+\n+    try {\n+      int idleLoopCount \u003d 0;\n+      JvmTask myTask \u003d null;;\n+      // poll for new task\n+      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n+        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n+        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n+            + \"ms before retrying again. Got null now.\");\n+        MILLISECONDS.sleep(sleepTimeMilliSecs);\n+        myTask \u003d umbilical.getTask(context);\n+      }\n+      if (myTask.shouldDie()) {\n+        return;\n+      }\n+\n+      task \u003d myTask.getTask();\n+      YarnChild.taskid \u003d task.getTaskID();\n+\n+      // Create the job-conf and set credentials\n+      final JobConf job \u003d\n+        configureTask(task, defaultConf.getCredentials(), jt);\n+\n+      // Initiate Java VM metrics\n+      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n+      LOG.debug(\"Remote user: \" + job.get(\"user.name\"));\n+      childUGI \u003d UserGroupInformation.createRemoteUser(job.get(\"user.name\"));\n+      // Add tokens to new user so that it may execute its task correctly.\n+      for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n+        childUGI.addToken(token);\n+      }\n+\n+      // Create a final reference to the task for the doAs block\n+      final Task taskFinal \u003d task;\n+      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+        @Override\n+        public Object run() throws Exception {\n+          // use job-specified working directory\n+          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n+          taskFinal.run(job, umbilical); // run the task\n+          return null;\n+        }\n+      });\n+    } catch (FSError e) {\n+      LOG.fatal(\"FSError from child\", e);\n+      umbilical.fsError(taskid, e.getMessage());\n+    } catch (Exception exception) {\n+      LOG.warn(\"Exception running child : \"\n+          + StringUtils.stringifyException(exception));\n+      try {\n+        if (task !\u003d null) {\n+          // do cleanup for the task\n+          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n+            task.taskCleanup(umbilical);\n+          } else {\n+            final Task taskFinal \u003d task;\n+            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n+              @Override\n+              public Object run() throws Exception {\n+                taskFinal.taskCleanup(umbilical);\n+                return null;\n+              }\n+            });\n+          }\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n+      }\n+      // Report back any failures, for diagnostic purposes\n+      ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n+      exception.printStackTrace(new PrintStream(baos));\n+      if (taskid !\u003d null) {\n+        umbilical.reportDiagnosticInfo(taskid, baos.toString());\n+      }\n+    } catch (Throwable throwable) {\n+      LOG.fatal(\"Error running child : \"\n+    \t        + StringUtils.stringifyException(throwable));\n+      if (taskid !\u003d null) {\n+        Throwable tCause \u003d throwable.getCause();\n+        String cause \u003d tCause \u003d\u003d null\n+                                 ? throwable.getMessage()\n+                                 : StringUtils.stringifyException(tCause);\n+        umbilical.fatalError(taskid, cause);\n+      }\n+    } finally {\n+      RPC.stopProxy(umbilical);\n+      DefaultMetricsSystem.shutdown();\n+      // Shutting down log4j of the child-vm...\n+      // This assumes that on return from Task.run()\n+      // there is no more logging done.\n+      LogManager.shutdown();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public static void main(String[] args) throws Throwable {\n    LOG.debug(\"Child starting\");\n\n    final JobConf defaultConf \u003d new JobConf();\n    defaultConf.addResource(MRConstants.JOB_CONF_FILE);\n    UserGroupInformation.setConfiguration(defaultConf);\n\n    String host \u003d args[0];\n    int port \u003d Integer.parseInt(args[1]);\n    final InetSocketAddress address \u003d new InetSocketAddress(host, port);\n    final TaskAttemptID firstTaskid \u003d TaskAttemptID.forName(args[2]);\n    int jvmIdInt \u003d Integer.parseInt(args[3]);\n    JVMId jvmId \u003d new JVMId(firstTaskid.getJobID(),\n        firstTaskid.getTaskType() \u003d\u003d TaskType.MAP, jvmIdInt);\n\n    // initialize metrics\n    DefaultMetricsSystem.initialize(\n        StringUtils.camelize(firstTaskid.getTaskType().name()) +\"Task\");\n\n    Token\u003cJobTokenIdentifier\u003e jt \u003d loadCredentials(defaultConf, address);\n\n    // Create TaskUmbilicalProtocol as actual task owner.\n    UserGroupInformation taskOwner \u003d\n      UserGroupInformation.createRemoteUser(firstTaskid.getJobID().toString());\n    taskOwner.addToken(jt);\n    final TaskUmbilicalProtocol umbilical \u003d\n      taskOwner.doAs(new PrivilegedExceptionAction\u003cTaskUmbilicalProtocol\u003e() {\n      @Override\n      public TaskUmbilicalProtocol run() throws Exception {\n        return (TaskUmbilicalProtocol)RPC.getProxy(TaskUmbilicalProtocol.class,\n            TaskUmbilicalProtocol.versionID, address, defaultConf);\n      }\n    });\n\n    // report non-pid to application master\n    JvmContext context \u003d new JvmContext(jvmId, \"-1000\");\n    LOG.debug(\"PID: \" + System.getenv().get(\"JVM_PID\"));\n    Task task \u003d null;\n    UserGroupInformation childUGI \u003d null;\n\n    try {\n      int idleLoopCount \u003d 0;\n      JvmTask myTask \u003d null;;\n      // poll for new task\n      for (int idle \u003d 0; null \u003d\u003d myTask; ++idle) {\n        long sleepTimeMilliSecs \u003d Math.min(idle * 500, 1500);\n        LOG.info(\"Sleeping for \" + sleepTimeMilliSecs\n            + \"ms before retrying again. Got null now.\");\n        MILLISECONDS.sleep(sleepTimeMilliSecs);\n        myTask \u003d umbilical.getTask(context);\n      }\n      if (myTask.shouldDie()) {\n        return;\n      }\n\n      task \u003d myTask.getTask();\n      YarnChild.taskid \u003d task.getTaskID();\n\n      // Create the job-conf and set credentials\n      final JobConf job \u003d\n        configureTask(task, defaultConf.getCredentials(), jt);\n\n      // Initiate Java VM metrics\n      JvmMetrics.initSingleton(jvmId.toString(), job.getSessionId());\n      LOG.debug(\"Remote user: \" + job.get(\"user.name\"));\n      childUGI \u003d UserGroupInformation.createRemoteUser(job.get(\"user.name\"));\n      // Add tokens to new user so that it may execute its task correctly.\n      for(Token\u003c?\u003e token : UserGroupInformation.getCurrentUser().getTokens()) {\n        childUGI.addToken(token);\n      }\n\n      // Create a final reference to the task for the doAs block\n      final Task taskFinal \u003d task;\n      childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n        @Override\n        public Object run() throws Exception {\n          // use job-specified working directory\n          FileSystem.get(job).setWorkingDirectory(job.getWorkingDirectory());\n          taskFinal.run(job, umbilical); // run the task\n          return null;\n        }\n      });\n    } catch (FSError e) {\n      LOG.fatal(\"FSError from child\", e);\n      umbilical.fsError(taskid, e.getMessage());\n    } catch (Exception exception) {\n      LOG.warn(\"Exception running child : \"\n          + StringUtils.stringifyException(exception));\n      try {\n        if (task !\u003d null) {\n          // do cleanup for the task\n          if (childUGI \u003d\u003d null) { // no need to job into doAs block\n            task.taskCleanup(umbilical);\n          } else {\n            final Task taskFinal \u003d task;\n            childUGI.doAs(new PrivilegedExceptionAction\u003cObject\u003e() {\n              @Override\n              public Object run() throws Exception {\n                taskFinal.taskCleanup(umbilical);\n                return null;\n              }\n            });\n          }\n        }\n      } catch (Exception e) {\n        LOG.info(\"Exception cleaning up: \" + StringUtils.stringifyException(e));\n      }\n      // Report back any failures, for diagnostic purposes\n      ByteArrayOutputStream baos \u003d new ByteArrayOutputStream();\n      exception.printStackTrace(new PrintStream(baos));\n      if (taskid !\u003d null) {\n        umbilical.reportDiagnosticInfo(taskid, baos.toString());\n      }\n    } catch (Throwable throwable) {\n      LOG.fatal(\"Error running child : \"\n    \t        + StringUtils.stringifyException(throwable));\n      if (taskid !\u003d null) {\n        Throwable tCause \u003d throwable.getCause();\n        String cause \u003d tCause \u003d\u003d null\n                                 ? throwable.getMessage()\n                                 : StringUtils.stringifyException(tCause);\n        umbilical.fatalError(taskid, cause);\n      }\n    } finally {\n      RPC.stopProxy(umbilical);\n      DefaultMetricsSystem.shutdown();\n      // Shutting down log4j of the child-vm...\n      // This assumes that on return from Task.run()\n      // there is no more logging done.\n      LogManager.shutdown();\n    }\n  }",
      "path": "hadoop-mapreduce/hadoop-mr-client/hadoop-mapreduce-client-app/src/main/java/org/apache/hadoop/mapred/YarnChild.java"
    }
  }
}