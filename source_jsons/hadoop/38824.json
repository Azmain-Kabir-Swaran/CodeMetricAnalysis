{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "NodeQueueLoadMonitor.java",
  "functionName": "updateNode",
  "functionId": "updateNode___rmNode-RMNode",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/distributed/NodeQueueLoadMonitor.java",
  "functionStartLine": 255,
  "functionEndLine": 313,
  "numCommitsSeen": 12,
  "timeTaken": 4001,
  "changeHistory": [
    "548997d6c9c5a1b9734ee00d065ce48a189458e6",
    "2064ca015d1584263aac0cc20c60b925a3aff612",
    "37ca4169508c3003dbe9044fefd37eb8cd8c0503",
    "f49843a9888ad8fe5c1bb4c16bfb5217d693009d",
    "0aafc122d401a2f49d0f9ca556343f9ba871e979",
    "10be45986cdf86a89055065b752959bd6369d54f",
    "1597630681c784a3d59f5605b87e96197b8139d7",
    "f0ac18d001d97914a9ee810b1fab56c5cebff830"
  ],
  "changeHistoryShort": {
    "548997d6c9c5a1b9734ee00d065ce48a189458e6": "Ybodychange",
    "2064ca015d1584263aac0cc20c60b925a3aff612": "Ybodychange",
    "37ca4169508c3003dbe9044fefd37eb8cd8c0503": "Ybodychange",
    "f49843a9888ad8fe5c1bb4c16bfb5217d693009d": "Ybodychange",
    "0aafc122d401a2f49d0f9ca556343f9ba871e979": "Ybodychange",
    "10be45986cdf86a89055065b752959bd6369d54f": "Ybodychange",
    "1597630681c784a3d59f5605b87e96197b8139d7": "Ybodychange",
    "f0ac18d001d97914a9ee810b1fab56c5cebff830": "Yintroduced"
  },
  "changeHistoryDetails": {
    "548997d6c9c5a1b9734ee00d065ce48a189458e6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9402. Opportunistic containers should not be scheduled on Decommissioning nodes. Contributed by Abhishek Modi.\n",
      "commitDate": "21/03/19 12:04 PM",
      "commitName": "548997d6c9c5a1b9734ee00d065ce48a189458e6",
      "commitAuthor": "Giovanni Matteo Fumarola",
      "commitDateOld": "15/03/19 4:20 PM",
      "commitNameOld": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthorOld": "Eric Yang",
      "daysBetweenCommits": 5.82,
      "commitsBetweenForRepo": 35,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,57 +1,59 @@\n   public void updateNode(RMNode rmNode) {\n     LOG.debug(\"Node update event from: {}\", rmNode.getNodeID());\n     OpportunisticContainersStatus opportunisticContainersStatus \u003d\n         rmNode.getOpportunisticContainersStatus();\n     if (opportunisticContainersStatus \u003d\u003d null) {\n       opportunisticContainersStatus \u003d\n           OpportunisticContainersStatus.newInstance();\n     }\n     int opportQueueCapacity \u003d\n         opportunisticContainersStatus.getOpportQueueCapacity();\n     int estimatedQueueWaitTime \u003d\n         opportunisticContainersStatus.getEstimatedQueueWaitTime();\n     int waitQueueLength \u003d opportunisticContainersStatus.getWaitQueueLength();\n     // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n     // UNLESS comparator is based on queue length.\n     ReentrantReadWriteLock.WriteLock writeLock \u003d clusterNodesLock.writeLock();\n     writeLock.lock();\n     try {\n       ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n       if (currentNode \u003d\u003d null) {\n-        if (estimatedQueueWaitTime !\u003d -1\n-            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n+        if (rmNode.getState() !\u003d NodeState.DECOMMISSIONING \u0026\u0026\n+            (estimatedQueueWaitTime !\u003d -1 ||\n+                comparator \u003d\u003d LoadComparator.QUEUE_LENGTH)) {\n           this.clusterNodes.put(rmNode.getNodeID(),\n               new ClusterNode(rmNode.getNodeID())\n                   .setQueueWaitTime(estimatedQueueWaitTime)\n                   .setQueueLength(waitQueueLength)\n                   .setQueueCapacity(opportQueueCapacity));\n           LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         } else {\n           LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         }\n       } else {\n-        if (estimatedQueueWaitTime !\u003d -1\n-            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n+        if (rmNode.getState() !\u003d NodeState.DECOMMISSIONING \u0026\u0026\n+            (estimatedQueueWaitTime !\u003d -1 ||\n+                comparator \u003d\u003d LoadComparator.QUEUE_LENGTH)) {\n           currentNode\n               .setQueueWaitTime(estimatedQueueWaitTime)\n               .setQueueLength(waitQueueLength)\n               .updateTimestamp();\n           LOG.debug(\"Updating ClusterNode [{}] with queue wait time [{}] and\"\n               + \" wait queue length [{}]\", rmNode.getNodeID(),\n               estimatedQueueWaitTime, waitQueueLength);\n \n         } else {\n           this.clusterNodes.remove(rmNode.getNodeID());\n           LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n               \"wait queue length [\" + currentNode.queueLength + \"]\");\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateNode(RMNode rmNode) {\n    LOG.debug(\"Node update event from: {}\", rmNode.getNodeID());\n    OpportunisticContainersStatus opportunisticContainersStatus \u003d\n        rmNode.getOpportunisticContainersStatus();\n    if (opportunisticContainersStatus \u003d\u003d null) {\n      opportunisticContainersStatus \u003d\n          OpportunisticContainersStatus.newInstance();\n    }\n    int opportQueueCapacity \u003d\n        opportunisticContainersStatus.getOpportQueueCapacity();\n    int estimatedQueueWaitTime \u003d\n        opportunisticContainersStatus.getEstimatedQueueWaitTime();\n    int waitQueueLength \u003d opportunisticContainersStatus.getWaitQueueLength();\n    // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n    // UNLESS comparator is based on queue length.\n    ReentrantReadWriteLock.WriteLock writeLock \u003d clusterNodesLock.writeLock();\n    writeLock.lock();\n    try {\n      ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n      if (currentNode \u003d\u003d null) {\n        if (rmNode.getState() !\u003d NodeState.DECOMMISSIONING \u0026\u0026\n            (estimatedQueueWaitTime !\u003d -1 ||\n                comparator \u003d\u003d LoadComparator.QUEUE_LENGTH)) {\n          this.clusterNodes.put(rmNode.getNodeID(),\n              new ClusterNode(rmNode.getNodeID())\n                  .setQueueWaitTime(estimatedQueueWaitTime)\n                  .setQueueLength(waitQueueLength)\n                  .setQueueCapacity(opportQueueCapacity));\n          LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        } else {\n          LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        }\n      } else {\n        if (rmNode.getState() !\u003d NodeState.DECOMMISSIONING \u0026\u0026\n            (estimatedQueueWaitTime !\u003d -1 ||\n                comparator \u003d\u003d LoadComparator.QUEUE_LENGTH)) {\n          currentNode\n              .setQueueWaitTime(estimatedQueueWaitTime)\n              .setQueueLength(waitQueueLength)\n              .updateTimestamp();\n          LOG.debug(\"Updating ClusterNode [{}] with queue wait time [{}] and\"\n              + \" wait queue length [{}]\", rmNode.getNodeID(),\n              estimatedQueueWaitTime, waitQueueLength);\n\n        } else {\n          this.clusterNodes.remove(rmNode.getNodeID());\n          LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n              \"wait queue length [\" + currentNode.queueLength + \"]\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/distributed/NodeQueueLoadMonitor.java",
      "extendedDetails": {}
    },
    "2064ca015d1584263aac0cc20c60b925a3aff612": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9349.  Changed logging to use slf4j api.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "15/03/19 4:20 PM",
      "commitName": "2064ca015d1584263aac0cc20c60b925a3aff612",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 10.76,
      "commitsBetweenForRepo": 108,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,57 @@\n   public void updateNode(RMNode rmNode) {\n-    LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n+    LOG.debug(\"Node update event from: {}\", rmNode.getNodeID());\n     OpportunisticContainersStatus opportunisticContainersStatus \u003d\n         rmNode.getOpportunisticContainersStatus();\n     if (opportunisticContainersStatus \u003d\u003d null) {\n       opportunisticContainersStatus \u003d\n           OpportunisticContainersStatus.newInstance();\n     }\n     int opportQueueCapacity \u003d\n         opportunisticContainersStatus.getOpportQueueCapacity();\n     int estimatedQueueWaitTime \u003d\n         opportunisticContainersStatus.getEstimatedQueueWaitTime();\n     int waitQueueLength \u003d opportunisticContainersStatus.getWaitQueueLength();\n     // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n     // UNLESS comparator is based on queue length.\n     ReentrantReadWriteLock.WriteLock writeLock \u003d clusterNodesLock.writeLock();\n     writeLock.lock();\n     try {\n       ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n       if (currentNode \u003d\u003d null) {\n         if (estimatedQueueWaitTime !\u003d -1\n             || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n           this.clusterNodes.put(rmNode.getNodeID(),\n               new ClusterNode(rmNode.getNodeID())\n                   .setQueueWaitTime(estimatedQueueWaitTime)\n                   .setQueueLength(waitQueueLength)\n                   .setQueueCapacity(opportQueueCapacity));\n           LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         } else {\n           LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         }\n       } else {\n         if (estimatedQueueWaitTime !\u003d -1\n             || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n           currentNode\n               .setQueueWaitTime(estimatedQueueWaitTime)\n               .setQueueLength(waitQueueLength)\n               .updateTimestamp();\n-          if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n-                \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n-                \"wait queue length [\" + waitQueueLength + \"]\");\n-          }\n+          LOG.debug(\"Updating ClusterNode [{}] with queue wait time [{}] and\"\n+              + \" wait queue length [{}]\", rmNode.getNodeID(),\n+              estimatedQueueWaitTime, waitQueueLength);\n+\n         } else {\n           this.clusterNodes.remove(rmNode.getNodeID());\n           LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n               \"wait queue length [\" + currentNode.queueLength + \"]\");\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateNode(RMNode rmNode) {\n    LOG.debug(\"Node update event from: {}\", rmNode.getNodeID());\n    OpportunisticContainersStatus opportunisticContainersStatus \u003d\n        rmNode.getOpportunisticContainersStatus();\n    if (opportunisticContainersStatus \u003d\u003d null) {\n      opportunisticContainersStatus \u003d\n          OpportunisticContainersStatus.newInstance();\n    }\n    int opportQueueCapacity \u003d\n        opportunisticContainersStatus.getOpportQueueCapacity();\n    int estimatedQueueWaitTime \u003d\n        opportunisticContainersStatus.getEstimatedQueueWaitTime();\n    int waitQueueLength \u003d opportunisticContainersStatus.getWaitQueueLength();\n    // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n    // UNLESS comparator is based on queue length.\n    ReentrantReadWriteLock.WriteLock writeLock \u003d clusterNodesLock.writeLock();\n    writeLock.lock();\n    try {\n      ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n      if (currentNode \u003d\u003d null) {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          this.clusterNodes.put(rmNode.getNodeID(),\n              new ClusterNode(rmNode.getNodeID())\n                  .setQueueWaitTime(estimatedQueueWaitTime)\n                  .setQueueLength(waitQueueLength)\n                  .setQueueCapacity(opportQueueCapacity));\n          LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        } else {\n          LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        }\n      } else {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          currentNode\n              .setQueueWaitTime(estimatedQueueWaitTime)\n              .setQueueLength(waitQueueLength)\n              .updateTimestamp();\n          LOG.debug(\"Updating ClusterNode [{}] with queue wait time [{}] and\"\n              + \" wait queue length [{}]\", rmNode.getNodeID(),\n              estimatedQueueWaitTime, waitQueueLength);\n\n        } else {\n          this.clusterNodes.remove(rmNode.getNodeID());\n          LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n              \"wait queue length [\" + currentNode.queueLength + \"]\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/distributed/NodeQueueLoadMonitor.java",
      "extendedDetails": {}
    },
    "37ca4169508c3003dbe9044fefd37eb8cd8c0503": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7587. Skip dispatching opportunistic containers to nodes whose queue is already full. (Weiwei Yang via asuresh)\n",
      "commitDate": "03/12/17 10:22 PM",
      "commitName": "37ca4169508c3003dbe9044fefd37eb8cd8c0503",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "23/08/17 9:56 AM",
      "commitNameOld": "f49843a9888ad8fe5c1bb4c16bfb5217d693009d",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 102.56,
      "commitsBetweenForRepo": 880,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,58 @@\n   public void updateNode(RMNode rmNode) {\n     LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n     OpportunisticContainersStatus opportunisticContainersStatus \u003d\n         rmNode.getOpportunisticContainersStatus();\n     if (opportunisticContainersStatus \u003d\u003d null) {\n       opportunisticContainersStatus \u003d\n           OpportunisticContainersStatus.newInstance();\n     }\n+    int opportQueueCapacity \u003d\n+        opportunisticContainersStatus.getOpportQueueCapacity();\n     int estimatedQueueWaitTime \u003d\n         opportunisticContainersStatus.getEstimatedQueueWaitTime();\n     int waitQueueLength \u003d opportunisticContainersStatus.getWaitQueueLength();\n     // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n     // UNLESS comparator is based on queue length.\n     ReentrantReadWriteLock.WriteLock writeLock \u003d clusterNodesLock.writeLock();\n     writeLock.lock();\n     try {\n       ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n       if (currentNode \u003d\u003d null) {\n         if (estimatedQueueWaitTime !\u003d -1\n             || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n           this.clusterNodes.put(rmNode.getNodeID(),\n               new ClusterNode(rmNode.getNodeID())\n                   .setQueueWaitTime(estimatedQueueWaitTime)\n-                  .setQueueLength(waitQueueLength));\n+                  .setQueueLength(waitQueueLength)\n+                  .setQueueCapacity(opportQueueCapacity));\n           LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         } else {\n           LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         }\n       } else {\n         if (estimatedQueueWaitTime !\u003d -1\n             || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n           currentNode\n               .setQueueWaitTime(estimatedQueueWaitTime)\n               .setQueueLength(waitQueueLength)\n               .updateTimestamp();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n                 \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n                 \"wait queue length [\" + waitQueueLength + \"]\");\n           }\n         } else {\n           this.clusterNodes.remove(rmNode.getNodeID());\n           LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n               \"wait queue length [\" + currentNode.queueLength + \"]\");\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateNode(RMNode rmNode) {\n    LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n    OpportunisticContainersStatus opportunisticContainersStatus \u003d\n        rmNode.getOpportunisticContainersStatus();\n    if (opportunisticContainersStatus \u003d\u003d null) {\n      opportunisticContainersStatus \u003d\n          OpportunisticContainersStatus.newInstance();\n    }\n    int opportQueueCapacity \u003d\n        opportunisticContainersStatus.getOpportQueueCapacity();\n    int estimatedQueueWaitTime \u003d\n        opportunisticContainersStatus.getEstimatedQueueWaitTime();\n    int waitQueueLength \u003d opportunisticContainersStatus.getWaitQueueLength();\n    // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n    // UNLESS comparator is based on queue length.\n    ReentrantReadWriteLock.WriteLock writeLock \u003d clusterNodesLock.writeLock();\n    writeLock.lock();\n    try {\n      ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n      if (currentNode \u003d\u003d null) {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          this.clusterNodes.put(rmNode.getNodeID(),\n              new ClusterNode(rmNode.getNodeID())\n                  .setQueueWaitTime(estimatedQueueWaitTime)\n                  .setQueueLength(waitQueueLength)\n                  .setQueueCapacity(opportQueueCapacity));\n          LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        } else {\n          LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        }\n      } else {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          currentNode\n              .setQueueWaitTime(estimatedQueueWaitTime)\n              .setQueueLength(waitQueueLength)\n              .updateTimestamp();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n                \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n                \"wait queue length [\" + waitQueueLength + \"]\");\n          }\n        } else {\n          this.clusterNodes.remove(rmNode.getNodeID());\n          LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n              \"wait queue length [\" + currentNode.queueLength + \"]\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/distributed/NodeQueueLoadMonitor.java",
      "extendedDetails": {}
    },
    "f49843a9888ad8fe5c1bb4c16bfb5217d693009d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6251. Do async container release to prevent deadlock during container updates. (Arun Suresh via wangda)\n\nChange-Id: I6c67d20c5dd4d22752830ebf0ed2340824976ecb\n",
      "commitDate": "23/08/17 9:56 AM",
      "commitName": "f49843a9888ad8fe5c1bb4c16bfb5217d693009d",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "27/12/16 12:40 PM",
      "commitNameOld": "ac1e5d4f77e3b9df8dcacb0b1f72eecc27931eb8",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 238.84,
      "commitsBetweenForRepo": 1325,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,55 @@\n   public void updateNode(RMNode rmNode) {\n     LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n     OpportunisticContainersStatus opportunisticContainersStatus \u003d\n         rmNode.getOpportunisticContainersStatus();\n+    if (opportunisticContainersStatus \u003d\u003d null) {\n+      opportunisticContainersStatus \u003d\n+          OpportunisticContainersStatus.newInstance();\n+    }\n     int estimatedQueueWaitTime \u003d\n         opportunisticContainersStatus.getEstimatedQueueWaitTime();\n     int waitQueueLength \u003d opportunisticContainersStatus.getWaitQueueLength();\n     // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n     // UNLESS comparator is based on queue length.\n     ReentrantReadWriteLock.WriteLock writeLock \u003d clusterNodesLock.writeLock();\n     writeLock.lock();\n     try {\n       ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n       if (currentNode \u003d\u003d null) {\n         if (estimatedQueueWaitTime !\u003d -1\n             || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n           this.clusterNodes.put(rmNode.getNodeID(),\n               new ClusterNode(rmNode.getNodeID())\n                   .setQueueWaitTime(estimatedQueueWaitTime)\n                   .setQueueLength(waitQueueLength));\n           LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         } else {\n           LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         }\n       } else {\n         if (estimatedQueueWaitTime !\u003d -1\n             || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n           currentNode\n               .setQueueWaitTime(estimatedQueueWaitTime)\n               .setQueueLength(waitQueueLength)\n               .updateTimestamp();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n                 \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n                 \"wait queue length [\" + waitQueueLength + \"]\");\n           }\n         } else {\n           this.clusterNodes.remove(rmNode.getNodeID());\n           LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n               \"wait queue length [\" + currentNode.queueLength + \"]\");\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateNode(RMNode rmNode) {\n    LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n    OpportunisticContainersStatus opportunisticContainersStatus \u003d\n        rmNode.getOpportunisticContainersStatus();\n    if (opportunisticContainersStatus \u003d\u003d null) {\n      opportunisticContainersStatus \u003d\n          OpportunisticContainersStatus.newInstance();\n    }\n    int estimatedQueueWaitTime \u003d\n        opportunisticContainersStatus.getEstimatedQueueWaitTime();\n    int waitQueueLength \u003d opportunisticContainersStatus.getWaitQueueLength();\n    // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n    // UNLESS comparator is based on queue length.\n    ReentrantReadWriteLock.WriteLock writeLock \u003d clusterNodesLock.writeLock();\n    writeLock.lock();\n    try {\n      ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n      if (currentNode \u003d\u003d null) {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          this.clusterNodes.put(rmNode.getNodeID(),\n              new ClusterNode(rmNode.getNodeID())\n                  .setQueueWaitTime(estimatedQueueWaitTime)\n                  .setQueueLength(waitQueueLength));\n          LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        } else {\n          LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        }\n      } else {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          currentNode\n              .setQueueWaitTime(estimatedQueueWaitTime)\n              .setQueueLength(waitQueueLength)\n              .updateTimestamp();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n                \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n                \"wait queue length [\" + waitQueueLength + \"]\");\n          }\n        } else {\n          this.clusterNodes.remove(rmNode.getNodeID());\n          LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n              \"wait queue length [\" + currentNode.queueLength + \"]\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/distributed/NodeQueueLoadMonitor.java",
      "extendedDetails": {}
    },
    "0aafc122d401a2f49d0f9ca556343f9ba871e979": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2995. Enhance UI to show cluster resource utilization of various container Execution types. (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "04/11/16 7:31 AM",
      "commitName": "0aafc122d401a2f49d0f9ca556343f9ba871e979",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "29/09/16 3:11 PM",
      "commitNameOld": "10be45986cdf86a89055065b752959bd6369d54f",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 35.68,
      "commitsBetweenForRepo": 306,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,51 @@\n   public void updateNode(RMNode rmNode) {\n     LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n-    QueuedContainersStatus queuedContainersStatus \u003d\n-        rmNode.getQueuedContainersStatus();\n+    OpportunisticContainersStatus opportunisticContainersStatus \u003d\n+        rmNode.getOpportunisticContainersStatus();\n     int estimatedQueueWaitTime \u003d\n-        queuedContainersStatus.getEstimatedQueueWaitTime();\n-    int waitQueueLength \u003d queuedContainersStatus.getWaitQueueLength();\n+        opportunisticContainersStatus.getEstimatedQueueWaitTime();\n+    int waitQueueLength \u003d opportunisticContainersStatus.getWaitQueueLength();\n     // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n     // UNLESS comparator is based on queue length.\n     ReentrantReadWriteLock.WriteLock writeLock \u003d clusterNodesLock.writeLock();\n     writeLock.lock();\n     try {\n       ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n       if (currentNode \u003d\u003d null) {\n         if (estimatedQueueWaitTime !\u003d -1\n             || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n           this.clusterNodes.put(rmNode.getNodeID(),\n               new ClusterNode(rmNode.getNodeID())\n                   .setQueueWaitTime(estimatedQueueWaitTime)\n                   .setQueueLength(waitQueueLength));\n           LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         } else {\n           LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         }\n       } else {\n         if (estimatedQueueWaitTime !\u003d -1\n             || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n           currentNode\n               .setQueueWaitTime(estimatedQueueWaitTime)\n               .setQueueLength(waitQueueLength)\n               .updateTimestamp();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n                 \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n                 \"wait queue length [\" + waitQueueLength + \"]\");\n           }\n         } else {\n           this.clusterNodes.remove(rmNode.getNodeID());\n           LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n               \"wait queue length [\" + currentNode.queueLength + \"]\");\n         }\n       }\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateNode(RMNode rmNode) {\n    LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n    OpportunisticContainersStatus opportunisticContainersStatus \u003d\n        rmNode.getOpportunisticContainersStatus();\n    int estimatedQueueWaitTime \u003d\n        opportunisticContainersStatus.getEstimatedQueueWaitTime();\n    int waitQueueLength \u003d opportunisticContainersStatus.getWaitQueueLength();\n    // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n    // UNLESS comparator is based on queue length.\n    ReentrantReadWriteLock.WriteLock writeLock \u003d clusterNodesLock.writeLock();\n    writeLock.lock();\n    try {\n      ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n      if (currentNode \u003d\u003d null) {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          this.clusterNodes.put(rmNode.getNodeID(),\n              new ClusterNode(rmNode.getNodeID())\n                  .setQueueWaitTime(estimatedQueueWaitTime)\n                  .setQueueLength(waitQueueLength));\n          LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        } else {\n          LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        }\n      } else {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          currentNode\n              .setQueueWaitTime(estimatedQueueWaitTime)\n              .setQueueLength(waitQueueLength)\n              .updateTimestamp();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n                \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n                \"wait queue length [\" + waitQueueLength + \"]\");\n          }\n        } else {\n          this.clusterNodes.remove(rmNode.getNodeID());\n          LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n              \"wait queue length [\" + currentNode.queueLength + \"]\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/distributed/NodeQueueLoadMonitor.java",
      "extendedDetails": {}
    },
    "10be45986cdf86a89055065b752959bd6369d54f": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5486. Update OpportunisticContainerAllocatorAMService::allocate method to handle OPPORTUNISTIC container requests. (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "29/09/16 3:11 PM",
      "commitName": "10be45986cdf86a89055065b752959bd6369d54f",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "18/05/16 6:46 PM",
      "commitNameOld": "1597630681c784a3d59f5605b87e96197b8139d7",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 133.85,
      "commitsBetweenForRepo": 988,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,51 @@\n   public void updateNode(RMNode rmNode) {\n     LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n     QueuedContainersStatus queuedContainersStatus \u003d\n         rmNode.getQueuedContainersStatus();\n     int estimatedQueueWaitTime \u003d\n         queuedContainersStatus.getEstimatedQueueWaitTime();\n     int waitQueueLength \u003d queuedContainersStatus.getWaitQueueLength();\n     // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n     // UNLESS comparator is based on queue length.\n-    synchronized (this.clusterNodes) {\n+    ReentrantReadWriteLock.WriteLock writeLock \u003d clusterNodesLock.writeLock();\n+    writeLock.lock();\n+    try {\n       ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n       if (currentNode \u003d\u003d null) {\n         if (estimatedQueueWaitTime !\u003d -1\n             || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n           this.clusterNodes.put(rmNode.getNodeID(),\n               new ClusterNode(rmNode.getNodeID())\n                   .setQueueWaitTime(estimatedQueueWaitTime)\n                   .setQueueLength(waitQueueLength));\n           LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         } else {\n           LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         }\n       } else {\n         if (estimatedQueueWaitTime !\u003d -1\n             || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n           currentNode\n               .setQueueWaitTime(estimatedQueueWaitTime)\n               .setQueueLength(waitQueueLength)\n               .updateTimestamp();\n           if (LOG.isDebugEnabled()) {\n             LOG.debug(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n                 \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n                 \"wait queue length [\" + waitQueueLength + \"]\");\n           }\n         } else {\n           this.clusterNodes.remove(rmNode.getNodeID());\n           LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n               \"wait queue length [\" + currentNode.queueLength + \"]\");\n         }\n       }\n+    } finally {\n+      writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateNode(RMNode rmNode) {\n    LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n    QueuedContainersStatus queuedContainersStatus \u003d\n        rmNode.getQueuedContainersStatus();\n    int estimatedQueueWaitTime \u003d\n        queuedContainersStatus.getEstimatedQueueWaitTime();\n    int waitQueueLength \u003d queuedContainersStatus.getWaitQueueLength();\n    // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n    // UNLESS comparator is based on queue length.\n    ReentrantReadWriteLock.WriteLock writeLock \u003d clusterNodesLock.writeLock();\n    writeLock.lock();\n    try {\n      ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n      if (currentNode \u003d\u003d null) {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          this.clusterNodes.put(rmNode.getNodeID(),\n              new ClusterNode(rmNode.getNodeID())\n                  .setQueueWaitTime(estimatedQueueWaitTime)\n                  .setQueueLength(waitQueueLength));\n          LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        } else {\n          LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        }\n      } else {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          currentNode\n              .setQueueWaitTime(estimatedQueueWaitTime)\n              .setQueueLength(waitQueueLength)\n              .updateTimestamp();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n                \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n                \"wait queue length [\" + waitQueueLength + \"]\");\n          }\n        } else {\n          this.clusterNodes.remove(rmNode.getNodeID());\n          LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n              \"wait queue length [\" + currentNode.queueLength + \"]\");\n        }\n      }\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/distributed/NodeQueueLoadMonitor.java",
      "extendedDetails": {}
    },
    "1597630681c784a3d59f5605b87e96197b8139d7": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5110. Fix OpportunisticContainerAllocator to insert complete HostAddress in issued ContainerTokenIds. (Konstantinos Karanasos via asuresh)\n",
      "commitDate": "18/05/16 6:46 PM",
      "commitName": "1597630681c784a3d59f5605b87e96197b8139d7",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "13/05/16 1:38 PM",
      "commitNameOld": "f0ac18d001d97914a9ee810b1fab56c5cebff830",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 5.21,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,45 +1,47 @@\n   public void updateNode(RMNode rmNode) {\n     LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n     QueuedContainersStatus queuedContainersStatus \u003d\n         rmNode.getQueuedContainersStatus();\n     int estimatedQueueWaitTime \u003d\n         queuedContainersStatus.getEstimatedQueueWaitTime();\n     int waitQueueLength \u003d queuedContainersStatus.getWaitQueueLength();\n     // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n     // UNLESS comparator is based on queue length.\n     synchronized (this.clusterNodes) {\n       ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n       if (currentNode \u003d\u003d null) {\n         if (estimatedQueueWaitTime !\u003d -1\n             || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n           this.clusterNodes.put(rmNode.getNodeID(),\n               new ClusterNode(rmNode.getNodeID())\n                   .setQueueWaitTime(estimatedQueueWaitTime)\n                   .setQueueLength(waitQueueLength));\n-          LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"]\" +\n+          LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         } else {\n-          LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"]\" +\n+          LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n               \"wait queue length [\" + waitQueueLength + \"]\");\n         }\n       } else {\n         if (estimatedQueueWaitTime !\u003d -1\n             || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n           currentNode\n               .setQueueWaitTime(estimatedQueueWaitTime)\n               .setQueueLength(waitQueueLength)\n               .updateTimestamp();\n-          LOG.info(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"]\" +\n-              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n-              \"wait queue length [\" + waitQueueLength + \"]\");\n+          if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n+                \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n+                \"wait queue length [\" + waitQueueLength + \"]\");\n+          }\n         } else {\n           this.clusterNodes.remove(rmNode.getNodeID());\n-          LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"]\" +\n+          LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n               \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n               \"wait queue length [\" + currentNode.queueLength + \"]\");\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateNode(RMNode rmNode) {\n    LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n    QueuedContainersStatus queuedContainersStatus \u003d\n        rmNode.getQueuedContainersStatus();\n    int estimatedQueueWaitTime \u003d\n        queuedContainersStatus.getEstimatedQueueWaitTime();\n    int waitQueueLength \u003d queuedContainersStatus.getWaitQueueLength();\n    // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n    // UNLESS comparator is based on queue length.\n    synchronized (this.clusterNodes) {\n      ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n      if (currentNode \u003d\u003d null) {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          this.clusterNodes.put(rmNode.getNodeID(),\n              new ClusterNode(rmNode.getNodeID())\n                  .setQueueWaitTime(estimatedQueueWaitTime)\n                  .setQueueLength(waitQueueLength));\n          LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        } else {\n          LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        }\n      } else {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          currentNode\n              .setQueueWaitTime(estimatedQueueWaitTime)\n              .setQueueLength(waitQueueLength)\n              .updateTimestamp();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n                \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n                \"wait queue length [\" + waitQueueLength + \"]\");\n          }\n        } else {\n          this.clusterNodes.remove(rmNode.getNodeID());\n          LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"] \" +\n              \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n              \"wait queue length [\" + currentNode.queueLength + \"]\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/distributed/NodeQueueLoadMonitor.java",
      "extendedDetails": {}
    },
    "f0ac18d001d97914a9ee810b1fab56c5cebff830": {
      "type": "Yintroduced",
      "commitMessage": "YARN-2888. Corrective mechanisms for rebalancing NM container queues. (asuresh)\n",
      "commitDate": "13/05/16 1:38 PM",
      "commitName": "f0ac18d001d97914a9ee810b1fab56c5cebff830",
      "commitAuthor": "Arun Suresh",
      "diff": "@@ -0,0 +1,45 @@\n+  public void updateNode(RMNode rmNode) {\n+    LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n+    QueuedContainersStatus queuedContainersStatus \u003d\n+        rmNode.getQueuedContainersStatus();\n+    int estimatedQueueWaitTime \u003d\n+        queuedContainersStatus.getEstimatedQueueWaitTime();\n+    int waitQueueLength \u003d queuedContainersStatus.getWaitQueueLength();\n+    // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n+    // UNLESS comparator is based on queue length.\n+    synchronized (this.clusterNodes) {\n+      ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n+      if (currentNode \u003d\u003d null) {\n+        if (estimatedQueueWaitTime !\u003d -1\n+            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n+          this.clusterNodes.put(rmNode.getNodeID(),\n+              new ClusterNode(rmNode.getNodeID())\n+                  .setQueueWaitTime(estimatedQueueWaitTime)\n+                  .setQueueLength(waitQueueLength));\n+          LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"]\" +\n+              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n+              \"wait queue length [\" + waitQueueLength + \"]\");\n+        } else {\n+          LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"]\" +\n+              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n+              \"wait queue length [\" + waitQueueLength + \"]\");\n+        }\n+      } else {\n+        if (estimatedQueueWaitTime !\u003d -1\n+            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n+          currentNode\n+              .setQueueWaitTime(estimatedQueueWaitTime)\n+              .setQueueLength(waitQueueLength)\n+              .updateTimestamp();\n+          LOG.info(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"]\" +\n+              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n+              \"wait queue length [\" + waitQueueLength + \"]\");\n+        } else {\n+          this.clusterNodes.remove(rmNode.getNodeID());\n+          LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"]\" +\n+              \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n+              \"wait queue length [\" + currentNode.queueLength + \"]\");\n+        }\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void updateNode(RMNode rmNode) {\n    LOG.debug(\"Node update event from: \" + rmNode.getNodeID());\n    QueuedContainersStatus queuedContainersStatus \u003d\n        rmNode.getQueuedContainersStatus();\n    int estimatedQueueWaitTime \u003d\n        queuedContainersStatus.getEstimatedQueueWaitTime();\n    int waitQueueLength \u003d queuedContainersStatus.getWaitQueueLength();\n    // Add nodes to clusterNodes. If estimatedQueueTime is -1, ignore node\n    // UNLESS comparator is based on queue length.\n    synchronized (this.clusterNodes) {\n      ClusterNode currentNode \u003d this.clusterNodes.get(rmNode.getNodeID());\n      if (currentNode \u003d\u003d null) {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          this.clusterNodes.put(rmNode.getNodeID(),\n              new ClusterNode(rmNode.getNodeID())\n                  .setQueueWaitTime(estimatedQueueWaitTime)\n                  .setQueueLength(waitQueueLength));\n          LOG.info(\"Inserting ClusterNode [\" + rmNode.getNodeID() + \"]\" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        } else {\n          LOG.warn(\"IGNORING ClusterNode [\" + rmNode.getNodeID() + \"]\" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        }\n      } else {\n        if (estimatedQueueWaitTime !\u003d -1\n            || comparator \u003d\u003d LoadComparator.QUEUE_LENGTH) {\n          currentNode\n              .setQueueWaitTime(estimatedQueueWaitTime)\n              .setQueueLength(waitQueueLength)\n              .updateTimestamp();\n          LOG.info(\"Updating ClusterNode [\" + rmNode.getNodeID() + \"]\" +\n              \"with queue wait time [\" + estimatedQueueWaitTime + \"] and \" +\n              \"wait queue length [\" + waitQueueLength + \"]\");\n        } else {\n          this.clusterNodes.remove(rmNode.getNodeID());\n          LOG.info(\"Deleting ClusterNode [\" + rmNode.getNodeID() + \"]\" +\n              \"with queue wait time [\" + currentNode.queueWaitTime + \"] and \" +\n              \"wait queue length [\" + currentNode.queueLength + \"]\");\n        }\n      }\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/distributed/NodeQueueLoadMonitor.java"
    }
  }
}