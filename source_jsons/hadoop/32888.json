{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RecoveredContainerLaunch.java",
  "functionName": "call",
  "functionId": "call",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/RecoveredContainerLaunch.java",
  "functionStartLine": 67,
  "functionEndLine": 126,
  "numCommitsSeen": 12,
  "timeTaken": 3408,
  "changeHistory": [
    "a55884c68eb175f1c9f61771386c086bf1ee65a9",
    "a50be1b8f432f50c940b66d12c7de87b95ea47c0",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
    "d1df0266cf4e9ff0ec70813c156556ca4e74f791",
    "61382ff8fabc76b3a51f227646573cdf367fea1a",
    "53fafcf061616516c24e2e2007a66a93d23d3e25",
    "33ea5ae92b9dd3abace104903d9a94d17dd75af5",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b"
  ],
  "changeHistoryShort": {
    "a55884c68eb175f1c9f61771386c086bf1ee65a9": "Ybodychange",
    "a50be1b8f432f50c940b66d12c7de87b95ea47c0": "Ybodychange",
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": "Ybodychange",
    "d1df0266cf4e9ff0ec70813c156556ca4e74f791": "Ybodychange",
    "61382ff8fabc76b3a51f227646573cdf367fea1a": "Ybodychange",
    "53fafcf061616516c24e2e2007a66a93d23d3e25": "Ybodychange",
    "33ea5ae92b9dd3abace104903d9a94d17dd75af5": "Ybodychange",
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": "Yintroduced"
  },
  "changeHistoryDetails": {
    "a55884c68eb175f1c9f61771386c086bf1ee65a9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7542. Fix issue that causes some Running Opportunistic Containers to be recovered as PAUSED. (Sampada Dehankar via asuresh)\n",
      "commitDate": "28/12/17 10:20 PM",
      "commitName": "a55884c68eb175f1c9f61771386c086bf1ee65a9",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "16/10/17 1:12 PM",
      "commitNameOld": "a50be1b8f432f50c940b66d12c7de87b95ea47c0",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 73.42,
      "commitsBetweenForRepo": 530,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public Integer call() {\n     int retCode \u003d ExitCode.LOST.getExitCode();\n     ContainerId containerId \u003d container.getContainerId();\n     String appIdStr \u003d\n         containerId.getApplicationAttemptId().getApplicationId().toString();\n     String containerIdStr \u003d containerId.toString();\n \n     dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n-        ContainerEventType.RECOVER_PAUSED_CONTAINER));\n+        ContainerEventType.CONTAINER_LAUNCHED));\n \n     boolean notInterrupted \u003d true;\n     try {\n       File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n       if (pidFile !\u003d null) {\n         String pidPathStr \u003d pidFile.getPath();\n         pidFilePath \u003d new Path(pidPathStr);\n         exec.activateContainer(containerId, pidFilePath);\n         retCode \u003d exec.reacquireContainer(\n             new ContainerReacquisitionContext.Builder()\n                 .setContainer(container)\n                 .setUser(container.getUser())\n                 .setContainerId(containerId)\n                 .build());\n       } else {\n         LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n       }\n     } catch (InterruptedException | InterruptedIOException e) {\n       LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n       notInterrupted \u003d false;\n     } catch (IOException e) {\n       LOG.error(\"Unable to recover container \" + containerIdStr, e);\n     } finally {\n       if (notInterrupted) {\n         this.completed.set(true);\n         exec.deactivateContainer(containerId);\n         try {\n           getContext().getNMStateStore().storeContainerCompleted(containerId,\n               retCode);\n         } catch (IOException e) {\n           LOG.error(\"Unable to set exit code for container \" + containerId);\n         }\n       }\n     }\n \n     if (retCode !\u003d 0) {\n       LOG.warn(\"Recovered container exited with a non-zero exit code \"\n           + retCode);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerId,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n           \"Container exited with a non-zero exit code \" + retCode));\n       return retCode;\n     }\n \n     LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerId,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    int retCode \u003d ExitCode.LOST.getExitCode();\n    ContainerId containerId \u003d container.getContainerId();\n    String appIdStr \u003d\n        containerId.getApplicationAttemptId().getApplicationId().toString();\n    String containerIdStr \u003d containerId.toString();\n\n    dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n        ContainerEventType.CONTAINER_LAUNCHED));\n\n    boolean notInterrupted \u003d true;\n    try {\n      File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n      if (pidFile !\u003d null) {\n        String pidPathStr \u003d pidFile.getPath();\n        pidFilePath \u003d new Path(pidPathStr);\n        exec.activateContainer(containerId, pidFilePath);\n        retCode \u003d exec.reacquireContainer(\n            new ContainerReacquisitionContext.Builder()\n                .setContainer(container)\n                .setUser(container.getUser())\n                .setContainerId(containerId)\n                .build());\n      } else {\n        LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n      }\n    } catch (InterruptedException | InterruptedIOException e) {\n      LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n      notInterrupted \u003d false;\n    } catch (IOException e) {\n      LOG.error(\"Unable to recover container \" + containerIdStr, e);\n    } finally {\n      if (notInterrupted) {\n        this.completed.set(true);\n        exec.deactivateContainer(containerId);\n        try {\n          getContext().getNMStateStore().storeContainerCompleted(containerId,\n              retCode);\n        } catch (IOException e) {\n          LOG.error(\"Unable to set exit code for container \" + containerId);\n        }\n      }\n    }\n\n    if (retCode !\u003d 0) {\n      LOG.warn(\"Recovered container exited with a non-zero exit code \"\n          + retCode);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerId,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n          \"Container exited with a non-zero exit code \" + retCode));\n      return retCode;\n    }\n\n    LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerId,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/RecoveredContainerLaunch.java",
      "extendedDetails": {}
    },
    "a50be1b8f432f50c940b66d12c7de87b95ea47c0": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7275. NM Statestore cleanup for Container updates. (Kartheek Muthyala via asuresh)\n",
      "commitDate": "16/10/17 1:12 PM",
      "commitName": "a50be1b8f432f50c940b66d12c7de87b95ea47c0",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "14/09/17 8:51 AM",
      "commitNameOld": "66ca0a65408521d5f9b080dd16b353b49fb8eaea",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 32.18,
      "commitsBetweenForRepo": 252,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public Integer call() {\n     int retCode \u003d ExitCode.LOST.getExitCode();\n     ContainerId containerId \u003d container.getContainerId();\n     String appIdStr \u003d\n         containerId.getApplicationAttemptId().getApplicationId().toString();\n     String containerIdStr \u003d containerId.toString();\n \n     dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n-        ContainerEventType.CONTAINER_LAUNCHED));\n+        ContainerEventType.RECOVER_PAUSED_CONTAINER));\n \n     boolean notInterrupted \u003d true;\n     try {\n       File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n       if (pidFile !\u003d null) {\n         String pidPathStr \u003d pidFile.getPath();\n         pidFilePath \u003d new Path(pidPathStr);\n         exec.activateContainer(containerId, pidFilePath);\n         retCode \u003d exec.reacquireContainer(\n             new ContainerReacquisitionContext.Builder()\n                 .setContainer(container)\n                 .setUser(container.getUser())\n                 .setContainerId(containerId)\n                 .build());\n       } else {\n         LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n       }\n     } catch (InterruptedException | InterruptedIOException e) {\n       LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n       notInterrupted \u003d false;\n     } catch (IOException e) {\n       LOG.error(\"Unable to recover container \" + containerIdStr, e);\n     } finally {\n       if (notInterrupted) {\n         this.completed.set(true);\n         exec.deactivateContainer(containerId);\n         try {\n           getContext().getNMStateStore().storeContainerCompleted(containerId,\n               retCode);\n         } catch (IOException e) {\n           LOG.error(\"Unable to set exit code for container \" + containerId);\n         }\n       }\n     }\n \n     if (retCode !\u003d 0) {\n       LOG.warn(\"Recovered container exited with a non-zero exit code \"\n           + retCode);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerId,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n           \"Container exited with a non-zero exit code \" + retCode));\n       return retCode;\n     }\n \n     LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerId,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    int retCode \u003d ExitCode.LOST.getExitCode();\n    ContainerId containerId \u003d container.getContainerId();\n    String appIdStr \u003d\n        containerId.getApplicationAttemptId().getApplicationId().toString();\n    String containerIdStr \u003d containerId.toString();\n\n    dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n        ContainerEventType.RECOVER_PAUSED_CONTAINER));\n\n    boolean notInterrupted \u003d true;\n    try {\n      File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n      if (pidFile !\u003d null) {\n        String pidPathStr \u003d pidFile.getPath();\n        pidFilePath \u003d new Path(pidPathStr);\n        exec.activateContainer(containerId, pidFilePath);\n        retCode \u003d exec.reacquireContainer(\n            new ContainerReacquisitionContext.Builder()\n                .setContainer(container)\n                .setUser(container.getUser())\n                .setContainerId(containerId)\n                .build());\n      } else {\n        LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n      }\n    } catch (InterruptedException | InterruptedIOException e) {\n      LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n      notInterrupted \u003d false;\n    } catch (IOException e) {\n      LOG.error(\"Unable to recover container \" + containerIdStr, e);\n    } finally {\n      if (notInterrupted) {\n        this.completed.set(true);\n        exec.deactivateContainer(containerId);\n        try {\n          getContext().getNMStateStore().storeContainerCompleted(containerId,\n              retCode);\n        } catch (IOException e) {\n          LOG.error(\"Unable to set exit code for container \" + containerId);\n        }\n      }\n    }\n\n    if (retCode !\u003d 0) {\n      LOG.warn(\"Recovered container exited with a non-zero exit code \"\n          + retCode);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerId,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n          \"Container exited with a non-zero exit code \" + retCode));\n      return retCode;\n    }\n\n    LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerId,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/RecoveredContainerLaunch.java",
      "extendedDetails": {}
    },
    "c77a1095dc556e8bea87df6d8ddf36e898f27e86": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1942. Deprecate toString/fromString methods from ConverterUtils and move them to records classes like ContainerId/ApplicationId, etc. (wangda)\n",
      "commitDate": "14/06/16 3:06 PM",
      "commitName": "c77a1095dc556e8bea87df6d8ddf36e898f27e86",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "23/05/16 8:15 AM",
      "commitNameOld": "d1df0266cf4e9ff0ec70813c156556ca4e74f791",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 22.29,
      "commitsBetweenForRepo": 145,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public Integer call() {\n     int retCode \u003d ExitCode.LOST.getExitCode();\n     ContainerId containerId \u003d container.getContainerId();\n-    String appIdStr \u003d ConverterUtils.toString(\n-        containerId.getApplicationAttemptId().getApplicationId());\n-    String containerIdStr \u003d ConverterUtils.toString(containerId);\n+    String appIdStr \u003d\n+        containerId.getApplicationAttemptId().getApplicationId().toString();\n+    String containerIdStr \u003d containerId.toString();\n \n     dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n         ContainerEventType.CONTAINER_LAUNCHED));\n \n     boolean notInterrupted \u003d true;\n     try {\n       File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n       if (pidFile !\u003d null) {\n         String pidPathStr \u003d pidFile.getPath();\n         pidFilePath \u003d new Path(pidPathStr);\n         exec.activateContainer(containerId, pidFilePath);\n         retCode \u003d exec.reacquireContainer(\n             new ContainerReacquisitionContext.Builder()\n                 .setContainer(container)\n                 .setUser(container.getUser())\n                 .setContainerId(containerId)\n                 .build());\n       } else {\n         LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n       }\n     } catch (InterruptedException | InterruptedIOException e) {\n       LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n       notInterrupted \u003d false;\n     } catch (IOException e) {\n       LOG.error(\"Unable to recover container \" + containerIdStr, e);\n     } finally {\n       if (notInterrupted) {\n         this.completed.set(true);\n         exec.deactivateContainer(containerId);\n         try {\n           getContext().getNMStateStore().storeContainerCompleted(containerId,\n               retCode);\n         } catch (IOException e) {\n           LOG.error(\"Unable to set exit code for container \" + containerId);\n         }\n       }\n     }\n \n     if (retCode !\u003d 0) {\n       LOG.warn(\"Recovered container exited with a non-zero exit code \"\n           + retCode);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerId,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n           \"Container exited with a non-zero exit code \" + retCode));\n       return retCode;\n     }\n \n     LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerId,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    int retCode \u003d ExitCode.LOST.getExitCode();\n    ContainerId containerId \u003d container.getContainerId();\n    String appIdStr \u003d\n        containerId.getApplicationAttemptId().getApplicationId().toString();\n    String containerIdStr \u003d containerId.toString();\n\n    dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n        ContainerEventType.CONTAINER_LAUNCHED));\n\n    boolean notInterrupted \u003d true;\n    try {\n      File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n      if (pidFile !\u003d null) {\n        String pidPathStr \u003d pidFile.getPath();\n        pidFilePath \u003d new Path(pidPathStr);\n        exec.activateContainer(containerId, pidFilePath);\n        retCode \u003d exec.reacquireContainer(\n            new ContainerReacquisitionContext.Builder()\n                .setContainer(container)\n                .setUser(container.getUser())\n                .setContainerId(containerId)\n                .build());\n      } else {\n        LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n      }\n    } catch (InterruptedException | InterruptedIOException e) {\n      LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n      notInterrupted \u003d false;\n    } catch (IOException e) {\n      LOG.error(\"Unable to recover container \" + containerIdStr, e);\n    } finally {\n      if (notInterrupted) {\n        this.completed.set(true);\n        exec.deactivateContainer(containerId);\n        try {\n          getContext().getNMStateStore().storeContainerCompleted(containerId,\n              retCode);\n        } catch (IOException e) {\n          LOG.error(\"Unable to set exit code for container \" + containerId);\n        }\n      }\n    }\n\n    if (retCode !\u003d 0) {\n      LOG.warn(\"Recovered container exited with a non-zero exit code \"\n          + retCode);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerId,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n          \"Container exited with a non-zero exit code \" + retCode));\n      return retCode;\n    }\n\n    LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerId,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/RecoveredContainerLaunch.java",
      "extendedDetails": {}
    },
    "d1df0266cf4e9ff0ec70813c156556ca4e74f791": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5103. With NM recovery enabled, restarting NM multiple times results in AM restart. Contributed by Junping Du\n",
      "commitDate": "23/05/16 8:15 AM",
      "commitName": "d1df0266cf4e9ff0ec70813c156556ca4e74f791",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "28/01/16 10:59 AM",
      "commitNameOld": "61382ff8fabc76b3a51f227646573cdf367fea1a",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 115.84,
      "commitsBetweenForRepo": 740,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,60 +1,60 @@\n   public Integer call() {\n     int retCode \u003d ExitCode.LOST.getExitCode();\n     ContainerId containerId \u003d container.getContainerId();\n     String appIdStr \u003d ConverterUtils.toString(\n         containerId.getApplicationAttemptId().getApplicationId());\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n \n     dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n         ContainerEventType.CONTAINER_LAUNCHED));\n \n     boolean notInterrupted \u003d true;\n     try {\n       File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n       if (pidFile !\u003d null) {\n         String pidPathStr \u003d pidFile.getPath();\n         pidFilePath \u003d new Path(pidPathStr);\n         exec.activateContainer(containerId, pidFilePath);\n         retCode \u003d exec.reacquireContainer(\n             new ContainerReacquisitionContext.Builder()\n                 .setContainer(container)\n                 .setUser(container.getUser())\n                 .setContainerId(containerId)\n                 .build());\n       } else {\n         LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n       }\n-    } catch (IOException e) {\n-        LOG.error(\"Unable to recover container \" + containerIdStr, e);\n-    } catch (InterruptedException e) {\n+    } catch (InterruptedException | InterruptedIOException e) {\n       LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n       notInterrupted \u003d false;\n+    } catch (IOException e) {\n+      LOG.error(\"Unable to recover container \" + containerIdStr, e);\n     } finally {\n       if (notInterrupted) {\n         this.completed.set(true);\n         exec.deactivateContainer(containerId);\n         try {\n           getContext().getNMStateStore().storeContainerCompleted(containerId,\n               retCode);\n         } catch (IOException e) {\n           LOG.error(\"Unable to set exit code for container \" + containerId);\n         }\n       }\n     }\n \n     if (retCode !\u003d 0) {\n       LOG.warn(\"Recovered container exited with a non-zero exit code \"\n           + retCode);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerId,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n           \"Container exited with a non-zero exit code \" + retCode));\n       return retCode;\n     }\n \n     LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerId,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    int retCode \u003d ExitCode.LOST.getExitCode();\n    ContainerId containerId \u003d container.getContainerId();\n    String appIdStr \u003d ConverterUtils.toString(\n        containerId.getApplicationAttemptId().getApplicationId());\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n\n    dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n        ContainerEventType.CONTAINER_LAUNCHED));\n\n    boolean notInterrupted \u003d true;\n    try {\n      File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n      if (pidFile !\u003d null) {\n        String pidPathStr \u003d pidFile.getPath();\n        pidFilePath \u003d new Path(pidPathStr);\n        exec.activateContainer(containerId, pidFilePath);\n        retCode \u003d exec.reacquireContainer(\n            new ContainerReacquisitionContext.Builder()\n                .setContainer(container)\n                .setUser(container.getUser())\n                .setContainerId(containerId)\n                .build());\n      } else {\n        LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n      }\n    } catch (InterruptedException | InterruptedIOException e) {\n      LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n      notInterrupted \u003d false;\n    } catch (IOException e) {\n      LOG.error(\"Unable to recover container \" + containerIdStr, e);\n    } finally {\n      if (notInterrupted) {\n        this.completed.set(true);\n        exec.deactivateContainer(containerId);\n        try {\n          getContext().getNMStateStore().storeContainerCompleted(containerId,\n              retCode);\n        } catch (IOException e) {\n          LOG.error(\"Unable to set exit code for container \" + containerId);\n        }\n      }\n    }\n\n    if (retCode !\u003d 0) {\n      LOG.warn(\"Recovered container exited with a non-zero exit code \"\n          + retCode);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerId,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n          \"Container exited with a non-zero exit code \" + retCode));\n      return retCode;\n    }\n\n    LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerId,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/RecoveredContainerLaunch.java",
      "extendedDetails": {}
    },
    "61382ff8fabc76b3a51f227646573cdf367fea1a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4643. Container recovery is broken with delegating container runtime. Contributed by Sidharta Seethana\n",
      "commitDate": "28/01/16 10:59 AM",
      "commitName": "61382ff8fabc76b3a51f227646573cdf367fea1a",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "26/06/15 8:47 AM",
      "commitNameOld": "40b256949ad6f6e0dbdd248f2d257b05899f4332",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 216.13,
      "commitsBetweenForRepo": 1449,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,60 @@\n   public Integer call() {\n     int retCode \u003d ExitCode.LOST.getExitCode();\n     ContainerId containerId \u003d container.getContainerId();\n     String appIdStr \u003d ConverterUtils.toString(\n         containerId.getApplicationAttemptId().getApplicationId());\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n \n     dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n         ContainerEventType.CONTAINER_LAUNCHED));\n \n     boolean notInterrupted \u003d true;\n     try {\n       File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n       if (pidFile !\u003d null) {\n         String pidPathStr \u003d pidFile.getPath();\n         pidFilePath \u003d new Path(pidPathStr);\n         exec.activateContainer(containerId, pidFilePath);\n         retCode \u003d exec.reacquireContainer(\n             new ContainerReacquisitionContext.Builder()\n-            .setUser(container.getUser())\n-            .setContainerId(containerId)\n-            .build());\n+                .setContainer(container)\n+                .setUser(container.getUser())\n+                .setContainerId(containerId)\n+                .build());\n       } else {\n         LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n       }\n     } catch (IOException e) {\n         LOG.error(\"Unable to recover container \" + containerIdStr, e);\n     } catch (InterruptedException e) {\n       LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n       notInterrupted \u003d false;\n     } finally {\n       if (notInterrupted) {\n         this.completed.set(true);\n         exec.deactivateContainer(containerId);\n         try {\n           getContext().getNMStateStore().storeContainerCompleted(containerId,\n               retCode);\n         } catch (IOException e) {\n           LOG.error(\"Unable to set exit code for container \" + containerId);\n         }\n       }\n     }\n \n     if (retCode !\u003d 0) {\n       LOG.warn(\"Recovered container exited with a non-zero exit code \"\n           + retCode);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerId,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n           \"Container exited with a non-zero exit code \" + retCode));\n       return retCode;\n     }\n \n     LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerId,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    int retCode \u003d ExitCode.LOST.getExitCode();\n    ContainerId containerId \u003d container.getContainerId();\n    String appIdStr \u003d ConverterUtils.toString(\n        containerId.getApplicationAttemptId().getApplicationId());\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n\n    dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n        ContainerEventType.CONTAINER_LAUNCHED));\n\n    boolean notInterrupted \u003d true;\n    try {\n      File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n      if (pidFile !\u003d null) {\n        String pidPathStr \u003d pidFile.getPath();\n        pidFilePath \u003d new Path(pidPathStr);\n        exec.activateContainer(containerId, pidFilePath);\n        retCode \u003d exec.reacquireContainer(\n            new ContainerReacquisitionContext.Builder()\n                .setContainer(container)\n                .setUser(container.getUser())\n                .setContainerId(containerId)\n                .build());\n      } else {\n        LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n      }\n    } catch (IOException e) {\n        LOG.error(\"Unable to recover container \" + containerIdStr, e);\n    } catch (InterruptedException e) {\n      LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n      notInterrupted \u003d false;\n    } finally {\n      if (notInterrupted) {\n        this.completed.set(true);\n        exec.deactivateContainer(containerId);\n        try {\n          getContext().getNMStateStore().storeContainerCompleted(containerId,\n              retCode);\n        } catch (IOException e) {\n          LOG.error(\"Unable to set exit code for container \" + containerId);\n        }\n      }\n    }\n\n    if (retCode !\u003d 0) {\n      LOG.warn(\"Recovered container exited with a non-zero exit code \"\n          + retCode);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerId,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n          \"Container exited with a non-zero exit code \" + retCode));\n      return retCode;\n    }\n\n    LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerId,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/RecoveredContainerLaunch.java",
      "extendedDetails": {}
    },
    "53fafcf061616516c24e2e2007a66a93d23d3e25": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3684. Changed ContainerExecutor\u0027s primary lifecycle methods to use a more extensible mechanism of context objects. Contributed by Sidharta Seethana.\n",
      "commitDate": "21/05/15 3:50 PM",
      "commitName": "53fafcf061616516c24e2e2007a66a93d23d3e25",
      "commitAuthor": "Vinod Kumar Vavilapalli",
      "commitDateOld": "13/11/14 8:11 AM",
      "commitNameOld": "33ea5ae92b9dd3abace104903d9a94d17dd75af5",
      "commitAuthorOld": "Jason Lowe",
      "daysBetweenCommits": 189.28,
      "commitsBetweenForRepo": 1584,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,59 @@\n   public Integer call() {\n     int retCode \u003d ExitCode.LOST.getExitCode();\n     ContainerId containerId \u003d container.getContainerId();\n     String appIdStr \u003d ConverterUtils.toString(\n         containerId.getApplicationAttemptId().getApplicationId());\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n \n     dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n         ContainerEventType.CONTAINER_LAUNCHED));\n \n     boolean notInterrupted \u003d true;\n     try {\n       File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n       if (pidFile !\u003d null) {\n         String pidPathStr \u003d pidFile.getPath();\n         pidFilePath \u003d new Path(pidPathStr);\n         exec.activateContainer(containerId, pidFilePath);\n-        retCode \u003d exec.reacquireContainer(container.getUser(), containerId);\n+        retCode \u003d exec.reacquireContainer(\n+            new ContainerReacquisitionContext.Builder()\n+            .setUser(container.getUser())\n+            .setContainerId(containerId)\n+            .build());\n       } else {\n         LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n       }\n     } catch (IOException e) {\n         LOG.error(\"Unable to recover container \" + containerIdStr, e);\n     } catch (InterruptedException e) {\n       LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n       notInterrupted \u003d false;\n     } finally {\n       if (notInterrupted) {\n         this.completed.set(true);\n         exec.deactivateContainer(containerId);\n         try {\n           getContext().getNMStateStore().storeContainerCompleted(containerId,\n               retCode);\n         } catch (IOException e) {\n           LOG.error(\"Unable to set exit code for container \" + containerId);\n         }\n       }\n     }\n \n     if (retCode !\u003d 0) {\n       LOG.warn(\"Recovered container exited with a non-zero exit code \"\n           + retCode);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerId,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n           \"Container exited with a non-zero exit code \" + retCode));\n       return retCode;\n     }\n \n     LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerId,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    int retCode \u003d ExitCode.LOST.getExitCode();\n    ContainerId containerId \u003d container.getContainerId();\n    String appIdStr \u003d ConverterUtils.toString(\n        containerId.getApplicationAttemptId().getApplicationId());\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n\n    dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n        ContainerEventType.CONTAINER_LAUNCHED));\n\n    boolean notInterrupted \u003d true;\n    try {\n      File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n      if (pidFile !\u003d null) {\n        String pidPathStr \u003d pidFile.getPath();\n        pidFilePath \u003d new Path(pidPathStr);\n        exec.activateContainer(containerId, pidFilePath);\n        retCode \u003d exec.reacquireContainer(\n            new ContainerReacquisitionContext.Builder()\n            .setUser(container.getUser())\n            .setContainerId(containerId)\n            .build());\n      } else {\n        LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n      }\n    } catch (IOException e) {\n        LOG.error(\"Unable to recover container \" + containerIdStr, e);\n    } catch (InterruptedException e) {\n      LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n      notInterrupted \u003d false;\n    } finally {\n      if (notInterrupted) {\n        this.completed.set(true);\n        exec.deactivateContainer(containerId);\n        try {\n          getContext().getNMStateStore().storeContainerCompleted(containerId,\n              retCode);\n        } catch (IOException e) {\n          LOG.error(\"Unable to set exit code for container \" + containerId);\n        }\n      }\n    }\n\n    if (retCode !\u003d 0) {\n      LOG.warn(\"Recovered container exited with a non-zero exit code \"\n          + retCode);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerId,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n          \"Container exited with a non-zero exit code \" + retCode));\n      return retCode;\n    }\n\n    LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerId,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/RecoveredContainerLaunch.java",
      "extendedDetails": {}
    },
    "33ea5ae92b9dd3abace104903d9a94d17dd75af5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2846. Incorrect persist exit code for running containers in reacquireContainer() that interrupted by NodeManager restart. Contributed by Junping Du\n",
      "commitDate": "13/11/14 8:11 AM",
      "commitName": "33ea5ae92b9dd3abace104903d9a94d17dd75af5",
      "commitAuthor": "Jason Lowe",
      "commitDateOld": "12/08/14 3:56 AM",
      "commitNameOld": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthorOld": "Junping Du",
      "daysBetweenCommits": 93.22,
      "commitsBetweenForRepo": 949,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,55 @@\n   public Integer call() {\n     int retCode \u003d ExitCode.LOST.getExitCode();\n     ContainerId containerId \u003d container.getContainerId();\n     String appIdStr \u003d ConverterUtils.toString(\n         containerId.getApplicationAttemptId().getApplicationId());\n     String containerIdStr \u003d ConverterUtils.toString(containerId);\n \n     dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n         ContainerEventType.CONTAINER_LAUNCHED));\n \n+    boolean notInterrupted \u003d true;\n     try {\n       File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n       if (pidFile !\u003d null) {\n         String pidPathStr \u003d pidFile.getPath();\n         pidFilePath \u003d new Path(pidPathStr);\n         exec.activateContainer(containerId, pidFilePath);\n         retCode \u003d exec.reacquireContainer(container.getUser(), containerId);\n       } else {\n         LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n       }\n     } catch (IOException e) {\n         LOG.error(\"Unable to recover container \" + containerIdStr, e);\n+    } catch (InterruptedException e) {\n+      LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n+      notInterrupted \u003d false;\n     } finally {\n-      this.completed.set(true);\n-      exec.deactivateContainer(containerId);\n-      try {\n-        getContext().getNMStateStore().storeContainerCompleted(containerId,\n-            retCode);\n-      } catch (IOException e) {\n-        LOG.error(\"Unable to set exit code for container \" + containerId);\n+      if (notInterrupted) {\n+        this.completed.set(true);\n+        exec.deactivateContainer(containerId);\n+        try {\n+          getContext().getNMStateStore().storeContainerCompleted(containerId,\n+              retCode);\n+        } catch (IOException e) {\n+          LOG.error(\"Unable to set exit code for container \" + containerId);\n+        }\n       }\n     }\n \n     if (retCode !\u003d 0) {\n       LOG.warn(\"Recovered container exited with a non-zero exit code \"\n           + retCode);\n       this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n           containerId,\n           ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n           \"Container exited with a non-zero exit code \" + retCode));\n       return retCode;\n     }\n \n     LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n     dispatcher.getEventHandler().handle(\n         new ContainerEvent(containerId,\n             ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n     return 0;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    int retCode \u003d ExitCode.LOST.getExitCode();\n    ContainerId containerId \u003d container.getContainerId();\n    String appIdStr \u003d ConverterUtils.toString(\n        containerId.getApplicationAttemptId().getApplicationId());\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n\n    dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n        ContainerEventType.CONTAINER_LAUNCHED));\n\n    boolean notInterrupted \u003d true;\n    try {\n      File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n      if (pidFile !\u003d null) {\n        String pidPathStr \u003d pidFile.getPath();\n        pidFilePath \u003d new Path(pidPathStr);\n        exec.activateContainer(containerId, pidFilePath);\n        retCode \u003d exec.reacquireContainer(container.getUser(), containerId);\n      } else {\n        LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n      }\n    } catch (IOException e) {\n        LOG.error(\"Unable to recover container \" + containerIdStr, e);\n    } catch (InterruptedException e) {\n      LOG.warn(\"Interrupted while waiting for exit code from \" + containerId);\n      notInterrupted \u003d false;\n    } finally {\n      if (notInterrupted) {\n        this.completed.set(true);\n        exec.deactivateContainer(containerId);\n        try {\n          getContext().getNMStateStore().storeContainerCompleted(containerId,\n              retCode);\n        } catch (IOException e) {\n          LOG.error(\"Unable to set exit code for container \" + containerId);\n        }\n      }\n    }\n\n    if (retCode !\u003d 0) {\n      LOG.warn(\"Recovered container exited with a non-zero exit code \"\n          + retCode);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerId,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n          \"Container exited with a non-zero exit code \" + retCode));\n      return retCode;\n    }\n\n    LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerId,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/RecoveredContainerLaunch.java",
      "extendedDetails": {}
    },
    "c2febdcbaa12078db42403fe8fd74180fb58a84b": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1337. Recover containers upon nodemanager restart. (Contributed by Jason Lowe)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1617448 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/08/14 3:56 AM",
      "commitName": "c2febdcbaa12078db42403fe8fd74180fb58a84b",
      "commitAuthor": "Junping Du",
      "diff": "@@ -0,0 +1,49 @@\n+  public Integer call() {\n+    int retCode \u003d ExitCode.LOST.getExitCode();\n+    ContainerId containerId \u003d container.getContainerId();\n+    String appIdStr \u003d ConverterUtils.toString(\n+        containerId.getApplicationAttemptId().getApplicationId());\n+    String containerIdStr \u003d ConverterUtils.toString(containerId);\n+\n+    dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n+        ContainerEventType.CONTAINER_LAUNCHED));\n+\n+    try {\n+      File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n+      if (pidFile !\u003d null) {\n+        String pidPathStr \u003d pidFile.getPath();\n+        pidFilePath \u003d new Path(pidPathStr);\n+        exec.activateContainer(containerId, pidFilePath);\n+        retCode \u003d exec.reacquireContainer(container.getUser(), containerId);\n+      } else {\n+        LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n+      }\n+    } catch (IOException e) {\n+        LOG.error(\"Unable to recover container \" + containerIdStr, e);\n+    } finally {\n+      this.completed.set(true);\n+      exec.deactivateContainer(containerId);\n+      try {\n+        getContext().getNMStateStore().storeContainerCompleted(containerId,\n+            retCode);\n+      } catch (IOException e) {\n+        LOG.error(\"Unable to set exit code for container \" + containerId);\n+      }\n+    }\n+\n+    if (retCode !\u003d 0) {\n+      LOG.warn(\"Recovered container exited with a non-zero exit code \"\n+          + retCode);\n+      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n+          containerId,\n+          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n+          \"Container exited with a non-zero exit code \" + retCode));\n+      return retCode;\n+    }\n+\n+    LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n+    dispatcher.getEventHandler().handle(\n+        new ContainerEvent(containerId,\n+            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n+    return 0;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public Integer call() {\n    int retCode \u003d ExitCode.LOST.getExitCode();\n    ContainerId containerId \u003d container.getContainerId();\n    String appIdStr \u003d ConverterUtils.toString(\n        containerId.getApplicationAttemptId().getApplicationId());\n    String containerIdStr \u003d ConverterUtils.toString(containerId);\n\n    dispatcher.getEventHandler().handle(new ContainerEvent(containerId,\n        ContainerEventType.CONTAINER_LAUNCHED));\n\n    try {\n      File pidFile \u003d locatePidFile(appIdStr, containerIdStr);\n      if (pidFile !\u003d null) {\n        String pidPathStr \u003d pidFile.getPath();\n        pidFilePath \u003d new Path(pidPathStr);\n        exec.activateContainer(containerId, pidFilePath);\n        retCode \u003d exec.reacquireContainer(container.getUser(), containerId);\n      } else {\n        LOG.warn(\"Unable to locate pid file for container \" + containerIdStr);\n      }\n    } catch (IOException e) {\n        LOG.error(\"Unable to recover container \" + containerIdStr, e);\n    } finally {\n      this.completed.set(true);\n      exec.deactivateContainer(containerId);\n      try {\n        getContext().getNMStateStore().storeContainerCompleted(containerId,\n            retCode);\n      } catch (IOException e) {\n        LOG.error(\"Unable to set exit code for container \" + containerId);\n      }\n    }\n\n    if (retCode !\u003d 0) {\n      LOG.warn(\"Recovered container exited with a non-zero exit code \"\n          + retCode);\n      this.dispatcher.getEventHandler().handle(new ContainerExitEvent(\n          containerId,\n          ContainerEventType.CONTAINER_EXITED_WITH_FAILURE, retCode,\n          \"Container exited with a non-zero exit code \" + retCode));\n      return retCode;\n    }\n\n    LOG.info(\"Recovered container \" + containerId + \" succeeded\");\n    dispatcher.getEventHandler().handle(\n        new ContainerEvent(containerId,\n            ContainerEventType.CONTAINER_EXITED_WITH_SUCCESS));\n    return 0;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-nodemanager/src/main/java/org/apache/hadoop/yarn/server/nodemanager/containermanager/launcher/RecoveredContainerLaunch.java"
    }
  }
}