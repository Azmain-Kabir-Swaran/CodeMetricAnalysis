{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RLESparseResourceAllocation.java",
  "functionName": "removeInterval",
  "functionId": "removeInterval___reservationInterval-ReservationInterval__totCap-Resource",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/RLESparseResourceAllocation.java",
  "functionStartLine": 105,
  "functionEndLine": 127,
  "numCommitsSeen": 13,
  "timeTaken": 2560,
  "changeHistory": [
    "da1016365aba1cee9c06771ab142d077379f27af",
    "0e602fa3a1529134214452fba10a90307d9c2072",
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168"
  ],
  "changeHistoryShort": {
    "da1016365aba1cee9c06771ab142d077379f27af": "Ybodychange",
    "0e602fa3a1529134214452fba10a90307d9c2072": "Ymultichange(Yparameterchange,Ybodychange)",
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168": "Yintroduced"
  },
  "changeHistoryDetails": {
    "da1016365aba1cee9c06771ab142d077379f27af": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3454. Add efficient merge operation to RLESparseResourceAllocation (Carlo Curino via asuresh)\n",
      "commitDate": "21/11/15 9:59 AM",
      "commitName": "da1016365aba1cee9c06771ab142d077379f27af",
      "commitAuthor": "Arun Suresh",
      "commitDateOld": "25/07/15 7:39 AM",
      "commitNameOld": "156f24ead00436faad5d4aeef327a546392cd265",
      "commitAuthorOld": "ccurino",
      "daysBetweenCommits": 119.14,
      "commitsBetweenForRepo": 803,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,23 @@\n   public boolean removeInterval(ReservationInterval reservationInterval,\n       Resource totCap) {\n     if (totCap.equals(ZERO_RESOURCE)) {\n       return true;\n     }\n     writeLock.lock();\n     try {\n-      long startKey \u003d reservationInterval.getStartTime();\n-      long endKey \u003d reservationInterval.getEndTime();\n-      // update the start key\n-      NavigableMap\u003cLong, Resource\u003e ticks \u003d\n-          cumulativeCapacity.headMap(endKey, false);\n-      // Decrease all the capacities of overlapping intervals\n-      SortedMap\u003cLong, Resource\u003e overlapSet \u003d ticks.tailMap(startKey);\n-      if (overlapSet !\u003d null \u0026\u0026 !overlapSet.isEmpty()) {\n-        Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n-        long currentKey \u003d -1;\n-        for (Iterator\u003cEntry\u003cLong, Resource\u003e\u003e overlapEntries \u003d\n-            overlapSet.entrySet().iterator(); overlapEntries.hasNext();) {\n-          Entry\u003cLong, Resource\u003e entry \u003d overlapEntries.next();\n-          currentKey \u003d entry.getKey();\n-          updatedCapacity \u003d Resources.subtract(entry.getValue(), totCap);\n-          // update each entry between start and end key\n-          cumulativeCapacity.put(currentKey, updatedCapacity);\n-        }\n-        // Remove the first overlap entry if it is same as previous after\n-        // updation\n-        Long firstKey \u003d overlapSet.firstKey();\n-        if (isSameAsPrevious(firstKey, overlapSet.get(firstKey))) {\n-          cumulativeCapacity.remove(firstKey);\n-        }\n-        // Remove the next entry if it is same as end entry after updation\n-        if ((currentKey !\u003d -1) \u0026\u0026 (isSameAsNext(currentKey, updatedCapacity))) {\n-          cumulativeCapacity.remove(cumulativeCapacity.higherKey(currentKey));\n-        }\n+\n+      NavigableMap\u003cLong, Resource\u003e removeInt \u003d new TreeMap\u003cLong, Resource\u003e();\n+      removeInt.put(reservationInterval.getStartTime(), totCap);\n+      removeInt.put(reservationInterval.getEndTime(), ZERO_RESOURCE);\n+      try {\n+        cumulativeCapacity \u003d\n+            merge(resourceCalculator, totCap, cumulativeCapacity, removeInt,\n+                Long.MIN_VALUE, Long.MAX_VALUE, RLEOperator.subtract);\n+      } catch (PlanningException e) {\n+        // never happens for subtract\n       }\n       return true;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean removeInterval(ReservationInterval reservationInterval,\n      Resource totCap) {\n    if (totCap.equals(ZERO_RESOURCE)) {\n      return true;\n    }\n    writeLock.lock();\n    try {\n\n      NavigableMap\u003cLong, Resource\u003e removeInt \u003d new TreeMap\u003cLong, Resource\u003e();\n      removeInt.put(reservationInterval.getStartTime(), totCap);\n      removeInt.put(reservationInterval.getEndTime(), ZERO_RESOURCE);\n      try {\n        cumulativeCapacity \u003d\n            merge(resourceCalculator, totCap, cumulativeCapacity, removeInt,\n                Long.MIN_VALUE, Long.MAX_VALUE, RLEOperator.subtract);\n      } catch (PlanningException e) {\n        // never happens for subtract\n      }\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/RLESparseResourceAllocation.java",
      "extendedDetails": {}
    },
    "0e602fa3a1529134214452fba10a90307d9c2072": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3800. Reduce storage footprint for ReservationAllocation. Contributed by Anubhav Dhoot.\n",
      "commitDate": "09/07/15 4:51 PM",
      "commitName": "0e602fa3a1529134214452fba10a90307d9c2072",
      "commitAuthor": "carlo curino",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3800. Reduce storage footprint for ReservationAllocation. Contributed by Anubhav Dhoot.\n",
          "commitDate": "09/07/15 4:51 PM",
          "commitName": "0e602fa3a1529134214452fba10a90307d9c2072",
          "commitAuthor": "carlo curino",
          "commitDateOld": "03/10/14 3:43 PM",
          "commitNameOld": "5e10a13bb4759984494c6a870c7f08fb6693c9c0",
          "commitAuthorOld": "subru",
          "daysBetweenCommits": 279.05,
          "commitsBetweenForRepo": 2292,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,41 @@\n   public boolean removeInterval(ReservationInterval reservationInterval,\n-      ReservationRequest capacity) {\n-    Resource totCap \u003d\n-        Resources.multiply(capacity.getCapability(),\n-            (float) capacity.getNumContainers());\n+      Resource totCap) {\n     if (totCap.equals(ZERO_RESOURCE)) {\n       return true;\n     }\n     writeLock.lock();\n     try {\n       long startKey \u003d reservationInterval.getStartTime();\n       long endKey \u003d reservationInterval.getEndTime();\n       // update the start key\n       NavigableMap\u003cLong, Resource\u003e ticks \u003d\n           cumulativeCapacity.headMap(endKey, false);\n       // Decrease all the capacities of overlapping intervals\n       SortedMap\u003cLong, Resource\u003e overlapSet \u003d ticks.tailMap(startKey);\n       if (overlapSet !\u003d null \u0026\u0026 !overlapSet.isEmpty()) {\n         Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n         long currentKey \u003d -1;\n         for (Iterator\u003cEntry\u003cLong, Resource\u003e\u003e overlapEntries \u003d\n             overlapSet.entrySet().iterator(); overlapEntries.hasNext();) {\n           Entry\u003cLong, Resource\u003e entry \u003d overlapEntries.next();\n           currentKey \u003d entry.getKey();\n           updatedCapacity \u003d Resources.subtract(entry.getValue(), totCap);\n           // update each entry between start and end key\n           cumulativeCapacity.put(currentKey, updatedCapacity);\n         }\n         // Remove the first overlap entry if it is same as previous after\n         // updation\n         Long firstKey \u003d overlapSet.firstKey();\n         if (isSameAsPrevious(firstKey, overlapSet.get(firstKey))) {\n           cumulativeCapacity.remove(firstKey);\n         }\n         // Remove the next entry if it is same as end entry after updation\n         if ((currentKey !\u003d -1) \u0026\u0026 (isSameAsNext(currentKey, updatedCapacity))) {\n           cumulativeCapacity.remove(cumulativeCapacity.higherKey(currentKey));\n         }\n       }\n       return true;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean removeInterval(ReservationInterval reservationInterval,\n      Resource totCap) {\n    if (totCap.equals(ZERO_RESOURCE)) {\n      return true;\n    }\n    writeLock.lock();\n    try {\n      long startKey \u003d reservationInterval.getStartTime();\n      long endKey \u003d reservationInterval.getEndTime();\n      // update the start key\n      NavigableMap\u003cLong, Resource\u003e ticks \u003d\n          cumulativeCapacity.headMap(endKey, false);\n      // Decrease all the capacities of overlapping intervals\n      SortedMap\u003cLong, Resource\u003e overlapSet \u003d ticks.tailMap(startKey);\n      if (overlapSet !\u003d null \u0026\u0026 !overlapSet.isEmpty()) {\n        Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n        long currentKey \u003d -1;\n        for (Iterator\u003cEntry\u003cLong, Resource\u003e\u003e overlapEntries \u003d\n            overlapSet.entrySet().iterator(); overlapEntries.hasNext();) {\n          Entry\u003cLong, Resource\u003e entry \u003d overlapEntries.next();\n          currentKey \u003d entry.getKey();\n          updatedCapacity \u003d Resources.subtract(entry.getValue(), totCap);\n          // update each entry between start and end key\n          cumulativeCapacity.put(currentKey, updatedCapacity);\n        }\n        // Remove the first overlap entry if it is same as previous after\n        // updation\n        Long firstKey \u003d overlapSet.firstKey();\n        if (isSameAsPrevious(firstKey, overlapSet.get(firstKey))) {\n          cumulativeCapacity.remove(firstKey);\n        }\n        // Remove the next entry if it is same as end entry after updation\n        if ((currentKey !\u003d -1) \u0026\u0026 (isSameAsNext(currentKey, updatedCapacity))) {\n          cumulativeCapacity.remove(cumulativeCapacity.higherKey(currentKey));\n        }\n      }\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/RLESparseResourceAllocation.java",
          "extendedDetails": {
            "oldValue": "[reservationInterval-ReservationInterval, capacity-ReservationRequest]",
            "newValue": "[reservationInterval-ReservationInterval, totCap-Resource]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3800. Reduce storage footprint for ReservationAllocation. Contributed by Anubhav Dhoot.\n",
          "commitDate": "09/07/15 4:51 PM",
          "commitName": "0e602fa3a1529134214452fba10a90307d9c2072",
          "commitAuthor": "carlo curino",
          "commitDateOld": "03/10/14 3:43 PM",
          "commitNameOld": "5e10a13bb4759984494c6a870c7f08fb6693c9c0",
          "commitAuthorOld": "subru",
          "daysBetweenCommits": 279.05,
          "commitsBetweenForRepo": 2292,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,44 +1,41 @@\n   public boolean removeInterval(ReservationInterval reservationInterval,\n-      ReservationRequest capacity) {\n-    Resource totCap \u003d\n-        Resources.multiply(capacity.getCapability(),\n-            (float) capacity.getNumContainers());\n+      Resource totCap) {\n     if (totCap.equals(ZERO_RESOURCE)) {\n       return true;\n     }\n     writeLock.lock();\n     try {\n       long startKey \u003d reservationInterval.getStartTime();\n       long endKey \u003d reservationInterval.getEndTime();\n       // update the start key\n       NavigableMap\u003cLong, Resource\u003e ticks \u003d\n           cumulativeCapacity.headMap(endKey, false);\n       // Decrease all the capacities of overlapping intervals\n       SortedMap\u003cLong, Resource\u003e overlapSet \u003d ticks.tailMap(startKey);\n       if (overlapSet !\u003d null \u0026\u0026 !overlapSet.isEmpty()) {\n         Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n         long currentKey \u003d -1;\n         for (Iterator\u003cEntry\u003cLong, Resource\u003e\u003e overlapEntries \u003d\n             overlapSet.entrySet().iterator(); overlapEntries.hasNext();) {\n           Entry\u003cLong, Resource\u003e entry \u003d overlapEntries.next();\n           currentKey \u003d entry.getKey();\n           updatedCapacity \u003d Resources.subtract(entry.getValue(), totCap);\n           // update each entry between start and end key\n           cumulativeCapacity.put(currentKey, updatedCapacity);\n         }\n         // Remove the first overlap entry if it is same as previous after\n         // updation\n         Long firstKey \u003d overlapSet.firstKey();\n         if (isSameAsPrevious(firstKey, overlapSet.get(firstKey))) {\n           cumulativeCapacity.remove(firstKey);\n         }\n         // Remove the next entry if it is same as end entry after updation\n         if ((currentKey !\u003d -1) \u0026\u0026 (isSameAsNext(currentKey, updatedCapacity))) {\n           cumulativeCapacity.remove(cumulativeCapacity.higherKey(currentKey));\n         }\n       }\n       return true;\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public boolean removeInterval(ReservationInterval reservationInterval,\n      Resource totCap) {\n    if (totCap.equals(ZERO_RESOURCE)) {\n      return true;\n    }\n    writeLock.lock();\n    try {\n      long startKey \u003d reservationInterval.getStartTime();\n      long endKey \u003d reservationInterval.getEndTime();\n      // update the start key\n      NavigableMap\u003cLong, Resource\u003e ticks \u003d\n          cumulativeCapacity.headMap(endKey, false);\n      // Decrease all the capacities of overlapping intervals\n      SortedMap\u003cLong, Resource\u003e overlapSet \u003d ticks.tailMap(startKey);\n      if (overlapSet !\u003d null \u0026\u0026 !overlapSet.isEmpty()) {\n        Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n        long currentKey \u003d -1;\n        for (Iterator\u003cEntry\u003cLong, Resource\u003e\u003e overlapEntries \u003d\n            overlapSet.entrySet().iterator(); overlapEntries.hasNext();) {\n          Entry\u003cLong, Resource\u003e entry \u003d overlapEntries.next();\n          currentKey \u003d entry.getKey();\n          updatedCapacity \u003d Resources.subtract(entry.getValue(), totCap);\n          // update each entry between start and end key\n          cumulativeCapacity.put(currentKey, updatedCapacity);\n        }\n        // Remove the first overlap entry if it is same as previous after\n        // updation\n        Long firstKey \u003d overlapSet.firstKey();\n        if (isSameAsPrevious(firstKey, overlapSet.get(firstKey))) {\n          cumulativeCapacity.remove(firstKey);\n        }\n        // Remove the next entry if it is same as end entry after updation\n        if ((currentKey !\u003d -1) \u0026\u0026 (isSameAsNext(currentKey, updatedCapacity))) {\n          cumulativeCapacity.remove(cumulativeCapacity.higherKey(currentKey));\n        }\n      }\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/RLESparseResourceAllocation.java",
          "extendedDetails": {}
        }
      ]
    },
    "cf4b34282aafee9f6b09d3433c4de1ae4b359168": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1709. In-memory data structures used to track resources over time to enable reservations.\n(cherry picked from commit 0d8b2cd88b958b1e602fd4ea4078ef8d4742a7c3)\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "cf4b34282aafee9f6b09d3433c4de1ae4b359168",
      "commitAuthor": "subru",
      "diff": "@@ -0,0 +1,44 @@\n+  public boolean removeInterval(ReservationInterval reservationInterval,\n+      ReservationRequest capacity) {\n+    Resource totCap \u003d\n+        Resources.multiply(capacity.getCapability(),\n+            (float) capacity.getNumContainers());\n+    if (totCap.equals(ZERO_RESOURCE)) {\n+      return true;\n+    }\n+    writeLock.lock();\n+    try {\n+      long startKey \u003d reservationInterval.getStartTime();\n+      long endKey \u003d reservationInterval.getEndTime();\n+      // update the start key\n+      NavigableMap\u003cLong, Resource\u003e ticks \u003d\n+          cumulativeCapacity.headMap(endKey, false);\n+      // Decrease all the capacities of overlapping intervals\n+      SortedMap\u003cLong, Resource\u003e overlapSet \u003d ticks.tailMap(startKey);\n+      if (overlapSet !\u003d null \u0026\u0026 !overlapSet.isEmpty()) {\n+        Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n+        long currentKey \u003d -1;\n+        for (Iterator\u003cEntry\u003cLong, Resource\u003e\u003e overlapEntries \u003d\n+            overlapSet.entrySet().iterator(); overlapEntries.hasNext();) {\n+          Entry\u003cLong, Resource\u003e entry \u003d overlapEntries.next();\n+          currentKey \u003d entry.getKey();\n+          updatedCapacity \u003d Resources.subtract(entry.getValue(), totCap);\n+          // update each entry between start and end key\n+          cumulativeCapacity.put(currentKey, updatedCapacity);\n+        }\n+        // Remove the first overlap entry if it is same as previous after\n+        // updation\n+        Long firstKey \u003d overlapSet.firstKey();\n+        if (isSameAsPrevious(firstKey, overlapSet.get(firstKey))) {\n+          cumulativeCapacity.remove(firstKey);\n+        }\n+        // Remove the next entry if it is same as end entry after updation\n+        if ((currentKey !\u003d -1) \u0026\u0026 (isSameAsNext(currentKey, updatedCapacity))) {\n+          cumulativeCapacity.remove(cumulativeCapacity.higherKey(currentKey));\n+        }\n+      }\n+      return true;\n+    } finally {\n+      writeLock.unlock();\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public boolean removeInterval(ReservationInterval reservationInterval,\n      ReservationRequest capacity) {\n    Resource totCap \u003d\n        Resources.multiply(capacity.getCapability(),\n            (float) capacity.getNumContainers());\n    if (totCap.equals(ZERO_RESOURCE)) {\n      return true;\n    }\n    writeLock.lock();\n    try {\n      long startKey \u003d reservationInterval.getStartTime();\n      long endKey \u003d reservationInterval.getEndTime();\n      // update the start key\n      NavigableMap\u003cLong, Resource\u003e ticks \u003d\n          cumulativeCapacity.headMap(endKey, false);\n      // Decrease all the capacities of overlapping intervals\n      SortedMap\u003cLong, Resource\u003e overlapSet \u003d ticks.tailMap(startKey);\n      if (overlapSet !\u003d null \u0026\u0026 !overlapSet.isEmpty()) {\n        Resource updatedCapacity \u003d Resource.newInstance(0, 0);\n        long currentKey \u003d -1;\n        for (Iterator\u003cEntry\u003cLong, Resource\u003e\u003e overlapEntries \u003d\n            overlapSet.entrySet().iterator(); overlapEntries.hasNext();) {\n          Entry\u003cLong, Resource\u003e entry \u003d overlapEntries.next();\n          currentKey \u003d entry.getKey();\n          updatedCapacity \u003d Resources.subtract(entry.getValue(), totCap);\n          // update each entry between start and end key\n          cumulativeCapacity.put(currentKey, updatedCapacity);\n        }\n        // Remove the first overlap entry if it is same as previous after\n        // updation\n        Long firstKey \u003d overlapSet.firstKey();\n        if (isSameAsPrevious(firstKey, overlapSet.get(firstKey))) {\n          cumulativeCapacity.remove(firstKey);\n        }\n        // Remove the next entry if it is same as end entry after updation\n        if ((currentKey !\u003d -1) \u0026\u0026 (isSameAsNext(currentKey, updatedCapacity))) {\n          cumulativeCapacity.remove(cumulativeCapacity.higherKey(currentKey));\n        }\n      }\n      return true;\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/reservation/RLESparseResourceAllocation.java"
    }
  }
}