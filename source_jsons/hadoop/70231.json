{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "BandwidthGaugeUpdater.java",
  "functionName": "triggerUpdate",
  "functionId": "triggerUpdate___updateWrite-boolean",
  "sourceFilePath": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/metrics/BandwidthGaugeUpdater.java",
  "functionStartLine": 168,
  "functionEndLine": 236,
  "numCommitsSeen": 1,
  "timeTaken": 762,
  "changeHistory": [
    "0d91576ec31f63402f2db6107a04155368e2632d"
  ],
  "changeHistoryShort": {
    "0d91576ec31f63402f2db6107a04155368e2632d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "0d91576ec31f63402f2db6107a04155368e2632d": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-10728. Metrics system for Windows Azure Storage Filesystem. Contributed by Dexter Bradshaw, Mostafa Elhemali, Xi Fang, Johannes Klein, David Lao, Mike Liddell, Chuan Liu, Lengning Liu, Ivan Mitic, Michael Rys, Alexander Stojanovic, Brian Swan, and Min Wei.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1605187 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/06/14 1:52 PM",
      "commitName": "0d91576ec31f63402f2db6107a04155368e2632d",
      "commitAuthor": "Chris Nauroth",
      "diff": "@@ -0,0 +1,69 @@\n+  public void triggerUpdate(boolean updateWrite) {\n+    ArrayList\u003cBlockTransferWindow\u003e toProcess \u003d null;\n+    synchronized (updateWrite ? blocksWrittenLock : blocksReadLock) {\n+      if (updateWrite \u0026\u0026 !allBlocksWritten.isEmpty()) {\n+        toProcess \u003d allBlocksWritten;\n+        allBlocksWritten \u003d createNewToProcessQueue();\n+      } else if (!updateWrite \u0026\u0026 !allBlocksRead.isEmpty()) {\n+        toProcess \u003d allBlocksRead;\n+        allBlocksRead \u003d createNewToProcessQueue();        \n+      }\n+    }\n+\n+    // Check to see if we have any blocks to process.\n+    if (toProcess \u003d\u003d null) {\n+      // Nothing to process, set the current bytes and rate to zero.\n+      updateBytesTransferred(updateWrite, 0);\n+      updateBytesTransferRate(updateWrite, 0);\n+      return;\n+    }\n+\n+    // The cut-off time for when we want to calculate rates is one\n+    // window size ago from now.\n+    long cutoffTime \u003d new Date().getTime() - windowSizeMs;\n+\n+    // Go through all the blocks we\u0027re processing, and calculate the\n+    // total number of bytes processed as well as the maximum transfer\n+    // rate we experienced for any single block during our time window.\n+    long maxSingleBlockTransferRate \u003d 0;\n+    long bytesInLastSecond \u003d 0;\n+    for (BlockTransferWindow currentWindow : toProcess) {\n+      long windowDuration \u003d currentWindow.getEndDate().getTime() \n+          - currentWindow.getStartDate().getTime();\n+      if (windowDuration \u003d\u003d 0) {\n+        // Edge case, assume it took 1 ms but we were too fast\n+        windowDuration \u003d 1;\n+      }\n+      if (currentWindow.getStartDate().getTime() \u003e cutoffTime) {\n+        // This block was transferred fully within our time window,\n+        // just add its bytes to the total.\n+        bytesInLastSecond +\u003d currentWindow.bytesTransferred;\n+      } else if (currentWindow.getEndDate().getTime() \u003e cutoffTime) {\n+        // This block started its transfer before our time window,\n+        // interpolate to estimate how many bytes from that block\n+        // were actually transferred during our time window.\n+        long adjustedBytes \u003d (currentWindow.getBytesTransferred() \n+            * (currentWindow.getEndDate().getTime() - cutoffTime)) \n+            / windowDuration;\n+        bytesInLastSecond +\u003d adjustedBytes;\n+      }\n+      // Calculate the transfer rate for this block.\n+      long currentBlockTransferRate \u003d\n+          (currentWindow.getBytesTransferred() * 1000) / windowDuration;\n+      maxSingleBlockTransferRate \u003d\n+          Math.max(maxSingleBlockTransferRate, currentBlockTransferRate);\n+    }\n+    updateBytesTransferred(updateWrite, bytesInLastSecond);\n+    // The transfer rate we saw in the last second is a tricky concept to\n+    // define: If we saw two blocks, one 2 MB block transferred in 0.2 seconds,\n+    // and one 4 MB block transferred in 0.2 seconds, then the maximum rate\n+    // is 20 MB/s (the 4 MB block), the average of the two blocks is 15 MB/s,\n+    // and the aggregate rate is 6 MB/s (total of 6 MB transferred in one\n+    // second). As a first cut, I\u0027m taking the definition to be the maximum\n+    // of aggregate or of any single block\u0027s rate (so in the example case it\u0027s\n+    // 6 MB/s).\n+    long aggregateTransferRate \u003d bytesInLastSecond;\n+    long maxObservedTransferRate \u003d\n+        Math.max(aggregateTransferRate, maxSingleBlockTransferRate);\n+    updateBytesTransferRate(updateWrite, maxObservedTransferRate);\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public void triggerUpdate(boolean updateWrite) {\n    ArrayList\u003cBlockTransferWindow\u003e toProcess \u003d null;\n    synchronized (updateWrite ? blocksWrittenLock : blocksReadLock) {\n      if (updateWrite \u0026\u0026 !allBlocksWritten.isEmpty()) {\n        toProcess \u003d allBlocksWritten;\n        allBlocksWritten \u003d createNewToProcessQueue();\n      } else if (!updateWrite \u0026\u0026 !allBlocksRead.isEmpty()) {\n        toProcess \u003d allBlocksRead;\n        allBlocksRead \u003d createNewToProcessQueue();        \n      }\n    }\n\n    // Check to see if we have any blocks to process.\n    if (toProcess \u003d\u003d null) {\n      // Nothing to process, set the current bytes and rate to zero.\n      updateBytesTransferred(updateWrite, 0);\n      updateBytesTransferRate(updateWrite, 0);\n      return;\n    }\n\n    // The cut-off time for when we want to calculate rates is one\n    // window size ago from now.\n    long cutoffTime \u003d new Date().getTime() - windowSizeMs;\n\n    // Go through all the blocks we\u0027re processing, and calculate the\n    // total number of bytes processed as well as the maximum transfer\n    // rate we experienced for any single block during our time window.\n    long maxSingleBlockTransferRate \u003d 0;\n    long bytesInLastSecond \u003d 0;\n    for (BlockTransferWindow currentWindow : toProcess) {\n      long windowDuration \u003d currentWindow.getEndDate().getTime() \n          - currentWindow.getStartDate().getTime();\n      if (windowDuration \u003d\u003d 0) {\n        // Edge case, assume it took 1 ms but we were too fast\n        windowDuration \u003d 1;\n      }\n      if (currentWindow.getStartDate().getTime() \u003e cutoffTime) {\n        // This block was transferred fully within our time window,\n        // just add its bytes to the total.\n        bytesInLastSecond +\u003d currentWindow.bytesTransferred;\n      } else if (currentWindow.getEndDate().getTime() \u003e cutoffTime) {\n        // This block started its transfer before our time window,\n        // interpolate to estimate how many bytes from that block\n        // were actually transferred during our time window.\n        long adjustedBytes \u003d (currentWindow.getBytesTransferred() \n            * (currentWindow.getEndDate().getTime() - cutoffTime)) \n            / windowDuration;\n        bytesInLastSecond +\u003d adjustedBytes;\n      }\n      // Calculate the transfer rate for this block.\n      long currentBlockTransferRate \u003d\n          (currentWindow.getBytesTransferred() * 1000) / windowDuration;\n      maxSingleBlockTransferRate \u003d\n          Math.max(maxSingleBlockTransferRate, currentBlockTransferRate);\n    }\n    updateBytesTransferred(updateWrite, bytesInLastSecond);\n    // The transfer rate we saw in the last second is a tricky concept to\n    // define: If we saw two blocks, one 2 MB block transferred in 0.2 seconds,\n    // and one 4 MB block transferred in 0.2 seconds, then the maximum rate\n    // is 20 MB/s (the 4 MB block), the average of the two blocks is 15 MB/s,\n    // and the aggregate rate is 6 MB/s (total of 6 MB transferred in one\n    // second). As a first cut, I\u0027m taking the definition to be the maximum\n    // of aggregate or of any single block\u0027s rate (so in the example case it\u0027s\n    // 6 MB/s).\n    long aggregateTransferRate \u003d bytesInLastSecond;\n    long maxObservedTransferRate \u003d\n        Math.max(aggregateTransferRate, maxSingleBlockTransferRate);\n    updateBytesTransferRate(updateWrite, maxObservedTransferRate);\n  }",
      "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azure/metrics/BandwidthGaugeUpdater.java"
    }
  }
}