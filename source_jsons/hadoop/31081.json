{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FederationInterceptorREST.java",
  "functionName": "getApps",
  "functionId": "getApps___hsr-HttpServletRequest__stateQuery-String__statesQuery-Set__String____finalStatusQuery-String__userQuery-String__queueQuery-String__count-String__startedBegin-String__startedEnd-String__finishBegin-String__finishEnd-String__applicationTypes-Set__String____applicationTags-Set__String____name-String__unselectedFields-Set__String__",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-router/src/main/java/org/apache/hadoop/yarn/server/router/webapp/FederationInterceptorREST.java",
  "functionStartLine": 675,
  "functionEndLine": 746,
  "numCommitsSeen": 38,
  "timeTaken": 4089,
  "changeHistory": [
    "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
    "6fc09beac497b40928b6b0524d83ecf6e7abf932",
    "8be5707067509b78bde5fcf60072ae988d5a9f32",
    "cc8893edc0b7960e958723c81062986c12f06ade",
    "cc59b5fb26ccf58dffcd8850fa12ec65250f127d"
  ],
  "changeHistoryShort": {
    "768ee22e9e73543d2fb193d9b6ec34a247cb0411": "Ymultichange(Yparameterchange,Ybodychange)",
    "6fc09beac497b40928b6b0524d83ecf6e7abf932": "Ybodychange",
    "8be5707067509b78bde5fcf60072ae988d5a9f32": "Ybodychange",
    "cc8893edc0b7960e958723c81062986c12f06ade": "Ybodychange",
    "cc59b5fb26ccf58dffcd8850fa12ec65250f127d": "Yintroduced"
  },
  "changeHistoryDetails": {
    "768ee22e9e73543d2fb193d9b6ec34a247cb0411": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-10035. Add ability to filter the Cluster Applications API request by name. Contributed by Adam Antal\n",
      "commitDate": "06/01/20 7:26 AM",
      "commitName": "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
      "commitAuthor": "Szilard Nemeth",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-10035. Add ability to filter the Cluster Applications API request by name. Contributed by Adam Antal\n",
          "commitDate": "06/01/20 7:26 AM",
          "commitName": "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "12/06/19 7:44 PM",
          "commitNameOld": "970b0b0c02bb8fbe8ff227c78e2332df623d1aea",
          "commitAuthorOld": "Weiwei Yang",
          "daysBetweenCommits": 207.53,
          "commitsBetweenForRepo": 1352,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,72 @@\n   public AppsInfo getApps(HttpServletRequest hsr, String stateQuery,\n       Set\u003cString\u003e statesQuery, String finalStatusQuery, String userQuery,\n       String queueQuery, String count, String startedBegin, String startedEnd,\n       String finishBegin, String finishEnd, Set\u003cString\u003e applicationTypes,\n-      Set\u003cString\u003e applicationTags, Set\u003cString\u003e unselectedFields) {\n+      Set\u003cString\u003e applicationTags, String name, Set\u003cString\u003e unselectedFields) {\n     AppsInfo apps \u003d new AppsInfo();\n     long startTime \u003d clock.getTime();\n \n     Map\u003cSubClusterId, SubClusterInfo\u003e subClustersActive \u003d null;\n     try {\n       subClustersActive \u003d federationFacade.getSubClusters(true);\n     } catch (YarnException e) {\n       routerMetrics.incrMultipleAppsFailedRetrieved();\n       return null;\n     }\n \n     // Send the requests in parallel\n     CompletionService\u003cAppsInfo\u003e compSvc \u003d\n         new ExecutorCompletionService\u003c\u003e(this.threadpool);\n \n     // HttpServletRequest does not work with ExecutorCompletionService.\n     // Create a duplicate hsr.\n     final HttpServletRequest hsrCopy \u003d clone(hsr);\n     for (final SubClusterInfo info : subClustersActive.values()) {\n       compSvc.submit(new Callable\u003cAppsInfo\u003e() {\n         @Override\n         public AppsInfo call() {\n           DefaultRequestInterceptorREST interceptor \u003d\n               getOrCreateInterceptorForSubCluster(\n                   info.getSubClusterId(), info.getRMWebServiceAddress());\n           AppsInfo rmApps \u003d interceptor.getApps(hsrCopy, stateQuery,\n               statesQuery, finalStatusQuery, userQuery, queueQuery, count,\n               startedBegin, startedEnd, finishBegin, finishEnd,\n-              applicationTypes, applicationTags, unselectedFields);\n+              applicationTypes, applicationTags, name, unselectedFields);\n \n           if (rmApps \u003d\u003d null) {\n             routerMetrics.incrMultipleAppsFailedRetrieved();\n             LOG.error(\"Subcluster {} failed to return appReport.\",\n                 info.getSubClusterId());\n             return null;\n           }\n           return rmApps;\n         }\n       });\n     }\n \n     // Collect all the responses in parallel\n     for (int i \u003d 0; i \u003c subClustersActive.size(); i++) {\n       try {\n         Future\u003cAppsInfo\u003e future \u003d compSvc.take();\n         AppsInfo appsResponse \u003d future.get();\n \n         long stopTime \u003d clock.getTime();\n         routerMetrics.succeededMultipleAppsRetrieved(stopTime - startTime);\n \n         if (appsResponse !\u003d null) {\n           apps.addAll(appsResponse.getApps());\n         }\n       } catch (Throwable e) {\n         routerMetrics.incrMultipleAppsFailedRetrieved();\n         LOG.warn(\"Failed to get application report\", e);\n       }\n     }\n \n     if (apps.getApps().isEmpty()) {\n       return null;\n     }\n \n     // Merge all the application reports got from all the available YARN RMs\n     return RouterWebServiceUtil.mergeAppsInfo(\n         apps.getApps(), returnPartialReport);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(HttpServletRequest hsr, String stateQuery,\n      Set\u003cString\u003e statesQuery, String finalStatusQuery, String userQuery,\n      String queueQuery, String count, String startedBegin, String startedEnd,\n      String finishBegin, String finishEnd, Set\u003cString\u003e applicationTypes,\n      Set\u003cString\u003e applicationTags, String name, Set\u003cString\u003e unselectedFields) {\n    AppsInfo apps \u003d new AppsInfo();\n    long startTime \u003d clock.getTime();\n\n    Map\u003cSubClusterId, SubClusterInfo\u003e subClustersActive \u003d null;\n    try {\n      subClustersActive \u003d federationFacade.getSubClusters(true);\n    } catch (YarnException e) {\n      routerMetrics.incrMultipleAppsFailedRetrieved();\n      return null;\n    }\n\n    // Send the requests in parallel\n    CompletionService\u003cAppsInfo\u003e compSvc \u003d\n        new ExecutorCompletionService\u003c\u003e(this.threadpool);\n\n    // HttpServletRequest does not work with ExecutorCompletionService.\n    // Create a duplicate hsr.\n    final HttpServletRequest hsrCopy \u003d clone(hsr);\n    for (final SubClusterInfo info : subClustersActive.values()) {\n      compSvc.submit(new Callable\u003cAppsInfo\u003e() {\n        @Override\n        public AppsInfo call() {\n          DefaultRequestInterceptorREST interceptor \u003d\n              getOrCreateInterceptorForSubCluster(\n                  info.getSubClusterId(), info.getRMWebServiceAddress());\n          AppsInfo rmApps \u003d interceptor.getApps(hsrCopy, stateQuery,\n              statesQuery, finalStatusQuery, userQuery, queueQuery, count,\n              startedBegin, startedEnd, finishBegin, finishEnd,\n              applicationTypes, applicationTags, name, unselectedFields);\n\n          if (rmApps \u003d\u003d null) {\n            routerMetrics.incrMultipleAppsFailedRetrieved();\n            LOG.error(\"Subcluster {} failed to return appReport.\",\n                info.getSubClusterId());\n            return null;\n          }\n          return rmApps;\n        }\n      });\n    }\n\n    // Collect all the responses in parallel\n    for (int i \u003d 0; i \u003c subClustersActive.size(); i++) {\n      try {\n        Future\u003cAppsInfo\u003e future \u003d compSvc.take();\n        AppsInfo appsResponse \u003d future.get();\n\n        long stopTime \u003d clock.getTime();\n        routerMetrics.succeededMultipleAppsRetrieved(stopTime - startTime);\n\n        if (appsResponse !\u003d null) {\n          apps.addAll(appsResponse.getApps());\n        }\n      } catch (Throwable e) {\n        routerMetrics.incrMultipleAppsFailedRetrieved();\n        LOG.warn(\"Failed to get application report\", e);\n      }\n    }\n\n    if (apps.getApps().isEmpty()) {\n      return null;\n    }\n\n    // Merge all the application reports got from all the available YARN RMs\n    return RouterWebServiceUtil.mergeAppsInfo(\n        apps.getApps(), returnPartialReport);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-router/src/main/java/org/apache/hadoop/yarn/server/router/webapp/FederationInterceptorREST.java",
          "extendedDetails": {
            "oldValue": "[hsr-HttpServletRequest, stateQuery-String, statesQuery-Set\u003cString\u003e, finalStatusQuery-String, userQuery-String, queueQuery-String, count-String, startedBegin-String, startedEnd-String, finishBegin-String, finishEnd-String, applicationTypes-Set\u003cString\u003e, applicationTags-Set\u003cString\u003e, unselectedFields-Set\u003cString\u003e]",
            "newValue": "[hsr-HttpServletRequest, stateQuery-String, statesQuery-Set\u003cString\u003e, finalStatusQuery-String, userQuery-String, queueQuery-String, count-String, startedBegin-String, startedEnd-String, finishBegin-String, finishEnd-String, applicationTypes-Set\u003cString\u003e, applicationTags-Set\u003cString\u003e, name-String, unselectedFields-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-10035. Add ability to filter the Cluster Applications API request by name. Contributed by Adam Antal\n",
          "commitDate": "06/01/20 7:26 AM",
          "commitName": "768ee22e9e73543d2fb193d9b6ec34a247cb0411",
          "commitAuthor": "Szilard Nemeth",
          "commitDateOld": "12/06/19 7:44 PM",
          "commitNameOld": "970b0b0c02bb8fbe8ff227c78e2332df623d1aea",
          "commitAuthorOld": "Weiwei Yang",
          "daysBetweenCommits": 207.53,
          "commitsBetweenForRepo": 1352,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,72 @@\n   public AppsInfo getApps(HttpServletRequest hsr, String stateQuery,\n       Set\u003cString\u003e statesQuery, String finalStatusQuery, String userQuery,\n       String queueQuery, String count, String startedBegin, String startedEnd,\n       String finishBegin, String finishEnd, Set\u003cString\u003e applicationTypes,\n-      Set\u003cString\u003e applicationTags, Set\u003cString\u003e unselectedFields) {\n+      Set\u003cString\u003e applicationTags, String name, Set\u003cString\u003e unselectedFields) {\n     AppsInfo apps \u003d new AppsInfo();\n     long startTime \u003d clock.getTime();\n \n     Map\u003cSubClusterId, SubClusterInfo\u003e subClustersActive \u003d null;\n     try {\n       subClustersActive \u003d federationFacade.getSubClusters(true);\n     } catch (YarnException e) {\n       routerMetrics.incrMultipleAppsFailedRetrieved();\n       return null;\n     }\n \n     // Send the requests in parallel\n     CompletionService\u003cAppsInfo\u003e compSvc \u003d\n         new ExecutorCompletionService\u003c\u003e(this.threadpool);\n \n     // HttpServletRequest does not work with ExecutorCompletionService.\n     // Create a duplicate hsr.\n     final HttpServletRequest hsrCopy \u003d clone(hsr);\n     for (final SubClusterInfo info : subClustersActive.values()) {\n       compSvc.submit(new Callable\u003cAppsInfo\u003e() {\n         @Override\n         public AppsInfo call() {\n           DefaultRequestInterceptorREST interceptor \u003d\n               getOrCreateInterceptorForSubCluster(\n                   info.getSubClusterId(), info.getRMWebServiceAddress());\n           AppsInfo rmApps \u003d interceptor.getApps(hsrCopy, stateQuery,\n               statesQuery, finalStatusQuery, userQuery, queueQuery, count,\n               startedBegin, startedEnd, finishBegin, finishEnd,\n-              applicationTypes, applicationTags, unselectedFields);\n+              applicationTypes, applicationTags, name, unselectedFields);\n \n           if (rmApps \u003d\u003d null) {\n             routerMetrics.incrMultipleAppsFailedRetrieved();\n             LOG.error(\"Subcluster {} failed to return appReport.\",\n                 info.getSubClusterId());\n             return null;\n           }\n           return rmApps;\n         }\n       });\n     }\n \n     // Collect all the responses in parallel\n     for (int i \u003d 0; i \u003c subClustersActive.size(); i++) {\n       try {\n         Future\u003cAppsInfo\u003e future \u003d compSvc.take();\n         AppsInfo appsResponse \u003d future.get();\n \n         long stopTime \u003d clock.getTime();\n         routerMetrics.succeededMultipleAppsRetrieved(stopTime - startTime);\n \n         if (appsResponse !\u003d null) {\n           apps.addAll(appsResponse.getApps());\n         }\n       } catch (Throwable e) {\n         routerMetrics.incrMultipleAppsFailedRetrieved();\n         LOG.warn(\"Failed to get application report\", e);\n       }\n     }\n \n     if (apps.getApps().isEmpty()) {\n       return null;\n     }\n \n     // Merge all the application reports got from all the available YARN RMs\n     return RouterWebServiceUtil.mergeAppsInfo(\n         apps.getApps(), returnPartialReport);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public AppsInfo getApps(HttpServletRequest hsr, String stateQuery,\n      Set\u003cString\u003e statesQuery, String finalStatusQuery, String userQuery,\n      String queueQuery, String count, String startedBegin, String startedEnd,\n      String finishBegin, String finishEnd, Set\u003cString\u003e applicationTypes,\n      Set\u003cString\u003e applicationTags, String name, Set\u003cString\u003e unselectedFields) {\n    AppsInfo apps \u003d new AppsInfo();\n    long startTime \u003d clock.getTime();\n\n    Map\u003cSubClusterId, SubClusterInfo\u003e subClustersActive \u003d null;\n    try {\n      subClustersActive \u003d federationFacade.getSubClusters(true);\n    } catch (YarnException e) {\n      routerMetrics.incrMultipleAppsFailedRetrieved();\n      return null;\n    }\n\n    // Send the requests in parallel\n    CompletionService\u003cAppsInfo\u003e compSvc \u003d\n        new ExecutorCompletionService\u003c\u003e(this.threadpool);\n\n    // HttpServletRequest does not work with ExecutorCompletionService.\n    // Create a duplicate hsr.\n    final HttpServletRequest hsrCopy \u003d clone(hsr);\n    for (final SubClusterInfo info : subClustersActive.values()) {\n      compSvc.submit(new Callable\u003cAppsInfo\u003e() {\n        @Override\n        public AppsInfo call() {\n          DefaultRequestInterceptorREST interceptor \u003d\n              getOrCreateInterceptorForSubCluster(\n                  info.getSubClusterId(), info.getRMWebServiceAddress());\n          AppsInfo rmApps \u003d interceptor.getApps(hsrCopy, stateQuery,\n              statesQuery, finalStatusQuery, userQuery, queueQuery, count,\n              startedBegin, startedEnd, finishBegin, finishEnd,\n              applicationTypes, applicationTags, name, unselectedFields);\n\n          if (rmApps \u003d\u003d null) {\n            routerMetrics.incrMultipleAppsFailedRetrieved();\n            LOG.error(\"Subcluster {} failed to return appReport.\",\n                info.getSubClusterId());\n            return null;\n          }\n          return rmApps;\n        }\n      });\n    }\n\n    // Collect all the responses in parallel\n    for (int i \u003d 0; i \u003c subClustersActive.size(); i++) {\n      try {\n        Future\u003cAppsInfo\u003e future \u003d compSvc.take();\n        AppsInfo appsResponse \u003d future.get();\n\n        long stopTime \u003d clock.getTime();\n        routerMetrics.succeededMultipleAppsRetrieved(stopTime - startTime);\n\n        if (appsResponse !\u003d null) {\n          apps.addAll(appsResponse.getApps());\n        }\n      } catch (Throwable e) {\n        routerMetrics.incrMultipleAppsFailedRetrieved();\n        LOG.warn(\"Failed to get application report\", e);\n      }\n    }\n\n    if (apps.getApps().isEmpty()) {\n      return null;\n    }\n\n    // Merge all the application reports got from all the available YARN RMs\n    return RouterWebServiceUtil.mergeAppsInfo(\n        apps.getApps(), returnPartialReport);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-router/src/main/java/org/apache/hadoop/yarn/server/router/webapp/FederationInterceptorREST.java",
          "extendedDetails": {}
        }
      ]
    },
    "6fc09beac497b40928b6b0524d83ecf6e7abf932": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7434. Router getApps REST invocation fails with multiple RMs. Contributed by Inigo Goiri.\n",
      "commitDate": "02/11/17 9:29 PM",
      "commitName": "6fc09beac497b40928b6b0524d83ecf6e7abf932",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "27/10/17 4:46 PM",
      "commitNameOld": "8be5707067509b78bde5fcf60072ae988d5a9f32",
      "commitAuthorOld": "Inigo Goiri",
      "daysBetweenCommits": 6.2,
      "commitsBetweenForRepo": 44,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   public AppsInfo getApps(HttpServletRequest hsr, String stateQuery,\n       Set\u003cString\u003e statesQuery, String finalStatusQuery, String userQuery,\n       String queueQuery, String count, String startedBegin, String startedEnd,\n       String finishBegin, String finishEnd, Set\u003cString\u003e applicationTypes,\n       Set\u003cString\u003e applicationTags, Set\u003cString\u003e unselectedFields) {\n     AppsInfo apps \u003d new AppsInfo();\n     long startTime \u003d clock.getTime();\n \n     Map\u003cSubClusterId, SubClusterInfo\u003e subClustersActive \u003d null;\n     try {\n       subClustersActive \u003d federationFacade.getSubClusters(true);\n     } catch (YarnException e) {\n       routerMetrics.incrMultipleAppsFailedRetrieved();\n       return null;\n     }\n \n     // Send the requests in parallel\n     CompletionService\u003cAppsInfo\u003e compSvc \u003d\n         new ExecutorCompletionService\u003c\u003e(this.threadpool);\n \n+    // HttpServletRequest does not work with ExecutorCompletionService.\n+    // Create a duplicate hsr.\n+    final HttpServletRequest hsrCopy \u003d clone(hsr);\n     for (final SubClusterInfo info : subClustersActive.values()) {\n-      // HttpServletRequest does not work with ExecutorCompletionService.\n-      // Create a duplicate hsr.\n-      final HttpServletRequest hsrCopy \u003d clone(hsr);\n       compSvc.submit(new Callable\u003cAppsInfo\u003e() {\n         @Override\n         public AppsInfo call() {\n           DefaultRequestInterceptorREST interceptor \u003d\n               getOrCreateInterceptorForSubCluster(\n                   info.getSubClusterId(), info.getRMWebServiceAddress());\n           AppsInfo rmApps \u003d interceptor.getApps(hsrCopy, stateQuery,\n               statesQuery, finalStatusQuery, userQuery, queueQuery, count,\n               startedBegin, startedEnd, finishBegin, finishEnd,\n               applicationTypes, applicationTags, unselectedFields);\n \n           if (rmApps \u003d\u003d null) {\n             routerMetrics.incrMultipleAppsFailedRetrieved();\n             LOG.error(\"Subcluster {} failed to return appReport.\",\n                 info.getSubClusterId());\n             return null;\n           }\n           return rmApps;\n         }\n       });\n     }\n \n     // Collect all the responses in parallel\n     for (int i \u003d 0; i \u003c subClustersActive.size(); i++) {\n       try {\n         Future\u003cAppsInfo\u003e future \u003d compSvc.take();\n         AppsInfo appsResponse \u003d future.get();\n \n         long stopTime \u003d clock.getTime();\n         routerMetrics.succeededMultipleAppsRetrieved(stopTime - startTime);\n \n         if (appsResponse !\u003d null) {\n           apps.addAll(appsResponse.getApps());\n         }\n       } catch (Throwable e) {\n         routerMetrics.incrMultipleAppsFailedRetrieved();\n         LOG.warn(\"Failed to get application report\", e);\n       }\n     }\n \n     if (apps.getApps().isEmpty()) {\n       return null;\n     }\n \n     // Merge all the application reports got from all the available YARN RMs\n     return RouterWebServiceUtil.mergeAppsInfo(\n         apps.getApps(), returnPartialReport);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest hsr, String stateQuery,\n      Set\u003cString\u003e statesQuery, String finalStatusQuery, String userQuery,\n      String queueQuery, String count, String startedBegin, String startedEnd,\n      String finishBegin, String finishEnd, Set\u003cString\u003e applicationTypes,\n      Set\u003cString\u003e applicationTags, Set\u003cString\u003e unselectedFields) {\n    AppsInfo apps \u003d new AppsInfo();\n    long startTime \u003d clock.getTime();\n\n    Map\u003cSubClusterId, SubClusterInfo\u003e subClustersActive \u003d null;\n    try {\n      subClustersActive \u003d federationFacade.getSubClusters(true);\n    } catch (YarnException e) {\n      routerMetrics.incrMultipleAppsFailedRetrieved();\n      return null;\n    }\n\n    // Send the requests in parallel\n    CompletionService\u003cAppsInfo\u003e compSvc \u003d\n        new ExecutorCompletionService\u003c\u003e(this.threadpool);\n\n    // HttpServletRequest does not work with ExecutorCompletionService.\n    // Create a duplicate hsr.\n    final HttpServletRequest hsrCopy \u003d clone(hsr);\n    for (final SubClusterInfo info : subClustersActive.values()) {\n      compSvc.submit(new Callable\u003cAppsInfo\u003e() {\n        @Override\n        public AppsInfo call() {\n          DefaultRequestInterceptorREST interceptor \u003d\n              getOrCreateInterceptorForSubCluster(\n                  info.getSubClusterId(), info.getRMWebServiceAddress());\n          AppsInfo rmApps \u003d interceptor.getApps(hsrCopy, stateQuery,\n              statesQuery, finalStatusQuery, userQuery, queueQuery, count,\n              startedBegin, startedEnd, finishBegin, finishEnd,\n              applicationTypes, applicationTags, unselectedFields);\n\n          if (rmApps \u003d\u003d null) {\n            routerMetrics.incrMultipleAppsFailedRetrieved();\n            LOG.error(\"Subcluster {} failed to return appReport.\",\n                info.getSubClusterId());\n            return null;\n          }\n          return rmApps;\n        }\n      });\n    }\n\n    // Collect all the responses in parallel\n    for (int i \u003d 0; i \u003c subClustersActive.size(); i++) {\n      try {\n        Future\u003cAppsInfo\u003e future \u003d compSvc.take();\n        AppsInfo appsResponse \u003d future.get();\n\n        long stopTime \u003d clock.getTime();\n        routerMetrics.succeededMultipleAppsRetrieved(stopTime - startTime);\n\n        if (appsResponse !\u003d null) {\n          apps.addAll(appsResponse.getApps());\n        }\n      } catch (Throwable e) {\n        routerMetrics.incrMultipleAppsFailedRetrieved();\n        LOG.warn(\"Failed to get application report\", e);\n      }\n    }\n\n    if (apps.getApps().isEmpty()) {\n      return null;\n    }\n\n    // Merge all the application reports got from all the available YARN RMs\n    return RouterWebServiceUtil.mergeAppsInfo(\n        apps.getApps(), returnPartialReport);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-router/src/main/java/org/apache/hadoop/yarn/server/router/webapp/FederationInterceptorREST.java",
      "extendedDetails": {}
    },
    "8be5707067509b78bde5fcf60072ae988d5a9f32": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7276. Federation Router Web Service fixes. Contributed by Inigo Goiri.\n",
      "commitDate": "27/10/17 4:46 PM",
      "commitName": "8be5707067509b78bde5fcf60072ae988d5a9f32",
      "commitAuthor": "Inigo Goiri",
      "commitDateOld": "03/10/17 3:01 PM",
      "commitNameOld": "c9b525bd943fe7e098e72fb9be5623862c7ab5ff",
      "commitAuthorOld": "Akira Ajisaka",
      "daysBetweenCommits": 24.07,
      "commitsBetweenForRepo": 186,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   public AppsInfo getApps(HttpServletRequest hsr, String stateQuery,\n       Set\u003cString\u003e statesQuery, String finalStatusQuery, String userQuery,\n       String queueQuery, String count, String startedBegin, String startedEnd,\n       String finishBegin, String finishEnd, Set\u003cString\u003e applicationTypes,\n       Set\u003cString\u003e applicationTags, Set\u003cString\u003e unselectedFields) {\n     AppsInfo apps \u003d new AppsInfo();\n     long startTime \u003d clock.getTime();\n \n     Map\u003cSubClusterId, SubClusterInfo\u003e subClustersActive \u003d null;\n     try {\n       subClustersActive \u003d federationFacade.getSubClusters(true);\n     } catch (YarnException e) {\n       routerMetrics.incrMultipleAppsFailedRetrieved();\n       return null;\n     }\n \n     // Send the requests in parallel\n-\n-    ExecutorCompletionService\u003cAppsInfo\u003e compSvc \u003d\n-        new ExecutorCompletionService\u003cAppsInfo\u003e(this.threadpool);\n+    CompletionService\u003cAppsInfo\u003e compSvc \u003d\n+        new ExecutorCompletionService\u003c\u003e(this.threadpool);\n \n     for (final SubClusterInfo info : subClustersActive.values()) {\n+      // HttpServletRequest does not work with ExecutorCompletionService.\n+      // Create a duplicate hsr.\n+      final HttpServletRequest hsrCopy \u003d clone(hsr);\n       compSvc.submit(new Callable\u003cAppsInfo\u003e() {\n         @Override\n         public AppsInfo call() {\n           DefaultRequestInterceptorREST interceptor \u003d\n-              getOrCreateInterceptorForSubCluster(info.getSubClusterId(),\n-                  info.getClientRMServiceAddress());\n-          AppsInfo rmApps \u003d interceptor.getApps(hsr, stateQuery, statesQuery,\n-              finalStatusQuery, userQuery, queueQuery, count, startedBegin,\n-              startedEnd, finishBegin, finishEnd, applicationTypes,\n-              applicationTags, unselectedFields);\n+              getOrCreateInterceptorForSubCluster(\n+                  info.getSubClusterId(), info.getRMWebServiceAddress());\n+          AppsInfo rmApps \u003d interceptor.getApps(hsrCopy, stateQuery,\n+              statesQuery, finalStatusQuery, userQuery, queueQuery, count,\n+              startedBegin, startedEnd, finishBegin, finishEnd,\n+              applicationTypes, applicationTags, unselectedFields);\n \n           if (rmApps \u003d\u003d null) {\n             routerMetrics.incrMultipleAppsFailedRetrieved();\n-            LOG.error(\"Subcluster \" + info.getSubClusterId()\n-                + \" failed to return appReport.\");\n+            LOG.error(\"Subcluster {} failed to return appReport.\",\n+                info.getSubClusterId());\n             return null;\n           }\n           return rmApps;\n         }\n       });\n     }\n \n     // Collect all the responses in parallel\n-\n-    for (int i \u003d 0; i \u003c subClustersActive.values().size(); i++) {\n+    for (int i \u003d 0; i \u003c subClustersActive.size(); i++) {\n       try {\n         Future\u003cAppsInfo\u003e future \u003d compSvc.take();\n         AppsInfo appsResponse \u003d future.get();\n \n         long stopTime \u003d clock.getTime();\n         routerMetrics.succeededMultipleAppsRetrieved(stopTime - startTime);\n \n         if (appsResponse !\u003d null) {\n           apps.addAll(appsResponse.getApps());\n         }\n       } catch (Throwable e) {\n         routerMetrics.incrMultipleAppsFailedRetrieved();\n-        LOG.warn(\"Failed to get application report \", e);\n+        LOG.warn(\"Failed to get application report\", e);\n       }\n     }\n \n     if (apps.getApps().isEmpty()) {\n       return null;\n     }\n \n     // Merge all the application reports got from all the available YARN RMs\n-\n-    return RouterWebServiceUtil.mergeAppsInfo(apps.getApps(),\n-        returnPartialReport);\n+    return RouterWebServiceUtil.mergeAppsInfo(\n+        apps.getApps(), returnPartialReport);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest hsr, String stateQuery,\n      Set\u003cString\u003e statesQuery, String finalStatusQuery, String userQuery,\n      String queueQuery, String count, String startedBegin, String startedEnd,\n      String finishBegin, String finishEnd, Set\u003cString\u003e applicationTypes,\n      Set\u003cString\u003e applicationTags, Set\u003cString\u003e unselectedFields) {\n    AppsInfo apps \u003d new AppsInfo();\n    long startTime \u003d clock.getTime();\n\n    Map\u003cSubClusterId, SubClusterInfo\u003e subClustersActive \u003d null;\n    try {\n      subClustersActive \u003d federationFacade.getSubClusters(true);\n    } catch (YarnException e) {\n      routerMetrics.incrMultipleAppsFailedRetrieved();\n      return null;\n    }\n\n    // Send the requests in parallel\n    CompletionService\u003cAppsInfo\u003e compSvc \u003d\n        new ExecutorCompletionService\u003c\u003e(this.threadpool);\n\n    for (final SubClusterInfo info : subClustersActive.values()) {\n      // HttpServletRequest does not work with ExecutorCompletionService.\n      // Create a duplicate hsr.\n      final HttpServletRequest hsrCopy \u003d clone(hsr);\n      compSvc.submit(new Callable\u003cAppsInfo\u003e() {\n        @Override\n        public AppsInfo call() {\n          DefaultRequestInterceptorREST interceptor \u003d\n              getOrCreateInterceptorForSubCluster(\n                  info.getSubClusterId(), info.getRMWebServiceAddress());\n          AppsInfo rmApps \u003d interceptor.getApps(hsrCopy, stateQuery,\n              statesQuery, finalStatusQuery, userQuery, queueQuery, count,\n              startedBegin, startedEnd, finishBegin, finishEnd,\n              applicationTypes, applicationTags, unselectedFields);\n\n          if (rmApps \u003d\u003d null) {\n            routerMetrics.incrMultipleAppsFailedRetrieved();\n            LOG.error(\"Subcluster {} failed to return appReport.\",\n                info.getSubClusterId());\n            return null;\n          }\n          return rmApps;\n        }\n      });\n    }\n\n    // Collect all the responses in parallel\n    for (int i \u003d 0; i \u003c subClustersActive.size(); i++) {\n      try {\n        Future\u003cAppsInfo\u003e future \u003d compSvc.take();\n        AppsInfo appsResponse \u003d future.get();\n\n        long stopTime \u003d clock.getTime();\n        routerMetrics.succeededMultipleAppsRetrieved(stopTime - startTime);\n\n        if (appsResponse !\u003d null) {\n          apps.addAll(appsResponse.getApps());\n        }\n      } catch (Throwable e) {\n        routerMetrics.incrMultipleAppsFailedRetrieved();\n        LOG.warn(\"Failed to get application report\", e);\n      }\n    }\n\n    if (apps.getApps().isEmpty()) {\n      return null;\n    }\n\n    // Merge all the application reports got from all the available YARN RMs\n    return RouterWebServiceUtil.mergeAppsInfo(\n        apps.getApps(), returnPartialReport);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-router/src/main/java/org/apache/hadoop/yarn/server/router/webapp/FederationInterceptorREST.java",
      "extendedDetails": {}
    },
    "cc8893edc0b7960e958723c81062986c12f06ade": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7010. Federation: routing REST invocations transparently to multiple RMs (part 2 - getApps). (Contributed by Giovanni Matteo Fumarola via curino)\n",
      "commitDate": "29/08/17 2:53 PM",
      "commitName": "cc8893edc0b7960e958723c81062986c12f06ade",
      "commitAuthor": "Carlo Curino",
      "commitDateOld": "21/08/17 10:50 PM",
      "commitNameOld": "ae8fb13b312b30de50d65b5450b565d50d690e9e",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 7.67,
      "commitsBetweenForRepo": 42,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,7 +1,72 @@\n   public AppsInfo getApps(HttpServletRequest hsr, String stateQuery,\n       Set\u003cString\u003e statesQuery, String finalStatusQuery, String userQuery,\n       String queueQuery, String count, String startedBegin, String startedEnd,\n       String finishBegin, String finishEnd, Set\u003cString\u003e applicationTypes,\n       Set\u003cString\u003e applicationTags, Set\u003cString\u003e unselectedFields) {\n-    throw new NotImplementedException();\n+    AppsInfo apps \u003d new AppsInfo();\n+    long startTime \u003d clock.getTime();\n+\n+    Map\u003cSubClusterId, SubClusterInfo\u003e subClustersActive \u003d null;\n+    try {\n+      subClustersActive \u003d federationFacade.getSubClusters(true);\n+    } catch (YarnException e) {\n+      routerMetrics.incrMultipleAppsFailedRetrieved();\n+      return null;\n+    }\n+\n+    // Send the requests in parallel\n+\n+    ExecutorCompletionService\u003cAppsInfo\u003e compSvc \u003d\n+        new ExecutorCompletionService\u003cAppsInfo\u003e(this.threadpool);\n+\n+    for (final SubClusterInfo info : subClustersActive.values()) {\n+      compSvc.submit(new Callable\u003cAppsInfo\u003e() {\n+        @Override\n+        public AppsInfo call() {\n+          DefaultRequestInterceptorREST interceptor \u003d\n+              getOrCreateInterceptorForSubCluster(info.getSubClusterId(),\n+                  info.getClientRMServiceAddress());\n+          AppsInfo rmApps \u003d interceptor.getApps(hsr, stateQuery, statesQuery,\n+              finalStatusQuery, userQuery, queueQuery, count, startedBegin,\n+              startedEnd, finishBegin, finishEnd, applicationTypes,\n+              applicationTags, unselectedFields);\n+\n+          if (rmApps \u003d\u003d null) {\n+            routerMetrics.incrMultipleAppsFailedRetrieved();\n+            LOG.error(\"Subcluster \" + info.getSubClusterId()\n+                + \" failed to return appReport.\");\n+            return null;\n+          }\n+          return rmApps;\n+        }\n+      });\n+    }\n+\n+    // Collect all the responses in parallel\n+\n+    for (int i \u003d 0; i \u003c subClustersActive.values().size(); i++) {\n+      try {\n+        Future\u003cAppsInfo\u003e future \u003d compSvc.take();\n+        AppsInfo appsResponse \u003d future.get();\n+\n+        long stopTime \u003d clock.getTime();\n+        routerMetrics.succeededMultipleAppsRetrieved(stopTime - startTime);\n+\n+        if (appsResponse !\u003d null) {\n+          apps.addAll(appsResponse.getApps());\n+        }\n+      } catch (Throwable e) {\n+        routerMetrics.incrMultipleAppsFailedRetrieved();\n+        LOG.warn(\"Failed to get application report \", e);\n+      }\n+    }\n+\n+    if (apps.getApps().isEmpty()) {\n+      return null;\n+    }\n+\n+    // Merge all the application reports got from all the available Yarn RMs\n+\n+    return RouterWebServiceUtil.mergeAppsInfo(apps.getApps(),\n+        returnPartialReport);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest hsr, String stateQuery,\n      Set\u003cString\u003e statesQuery, String finalStatusQuery, String userQuery,\n      String queueQuery, String count, String startedBegin, String startedEnd,\n      String finishBegin, String finishEnd, Set\u003cString\u003e applicationTypes,\n      Set\u003cString\u003e applicationTags, Set\u003cString\u003e unselectedFields) {\n    AppsInfo apps \u003d new AppsInfo();\n    long startTime \u003d clock.getTime();\n\n    Map\u003cSubClusterId, SubClusterInfo\u003e subClustersActive \u003d null;\n    try {\n      subClustersActive \u003d federationFacade.getSubClusters(true);\n    } catch (YarnException e) {\n      routerMetrics.incrMultipleAppsFailedRetrieved();\n      return null;\n    }\n\n    // Send the requests in parallel\n\n    ExecutorCompletionService\u003cAppsInfo\u003e compSvc \u003d\n        new ExecutorCompletionService\u003cAppsInfo\u003e(this.threadpool);\n\n    for (final SubClusterInfo info : subClustersActive.values()) {\n      compSvc.submit(new Callable\u003cAppsInfo\u003e() {\n        @Override\n        public AppsInfo call() {\n          DefaultRequestInterceptorREST interceptor \u003d\n              getOrCreateInterceptorForSubCluster(info.getSubClusterId(),\n                  info.getClientRMServiceAddress());\n          AppsInfo rmApps \u003d interceptor.getApps(hsr, stateQuery, statesQuery,\n              finalStatusQuery, userQuery, queueQuery, count, startedBegin,\n              startedEnd, finishBegin, finishEnd, applicationTypes,\n              applicationTags, unselectedFields);\n\n          if (rmApps \u003d\u003d null) {\n            routerMetrics.incrMultipleAppsFailedRetrieved();\n            LOG.error(\"Subcluster \" + info.getSubClusterId()\n                + \" failed to return appReport.\");\n            return null;\n          }\n          return rmApps;\n        }\n      });\n    }\n\n    // Collect all the responses in parallel\n\n    for (int i \u003d 0; i \u003c subClustersActive.values().size(); i++) {\n      try {\n        Future\u003cAppsInfo\u003e future \u003d compSvc.take();\n        AppsInfo appsResponse \u003d future.get();\n\n        long stopTime \u003d clock.getTime();\n        routerMetrics.succeededMultipleAppsRetrieved(stopTime - startTime);\n\n        if (appsResponse !\u003d null) {\n          apps.addAll(appsResponse.getApps());\n        }\n      } catch (Throwable e) {\n        routerMetrics.incrMultipleAppsFailedRetrieved();\n        LOG.warn(\"Failed to get application report \", e);\n      }\n    }\n\n    if (apps.getApps().isEmpty()) {\n      return null;\n    }\n\n    // Merge all the application reports got from all the available Yarn RMs\n\n    return RouterWebServiceUtil.mergeAppsInfo(apps.getApps(),\n        returnPartialReport);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-router/src/main/java/org/apache/hadoop/yarn/server/router/webapp/FederationInterceptorREST.java",
      "extendedDetails": {}
    },
    "cc59b5fb26ccf58dffcd8850fa12ec65250f127d": {
      "type": "Yintroduced",
      "commitMessage": "YARN-6896. Federation: routing REST invocations transparently to multiple RMs (part 1 - basic execution). (Contributed by Giovanni Matteo Fumarola via curino)\n",
      "commitDate": "11/08/17 3:58 PM",
      "commitName": "cc59b5fb26ccf58dffcd8850fa12ec65250f127d",
      "commitAuthor": "Carlo Curino",
      "diff": "@@ -0,0 +1,7 @@\n+  public AppsInfo getApps(HttpServletRequest hsr, String stateQuery,\n+      Set\u003cString\u003e statesQuery, String finalStatusQuery, String userQuery,\n+      String queueQuery, String count, String startedBegin, String startedEnd,\n+      String finishBegin, String finishEnd, Set\u003cString\u003e applicationTypes,\n+      Set\u003cString\u003e applicationTags, Set\u003cString\u003e unselectedFields) {\n+    throw new NotImplementedException();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public AppsInfo getApps(HttpServletRequest hsr, String stateQuery,\n      Set\u003cString\u003e statesQuery, String finalStatusQuery, String userQuery,\n      String queueQuery, String count, String startedBegin, String startedEnd,\n      String finishBegin, String finishEnd, Set\u003cString\u003e applicationTypes,\n      Set\u003cString\u003e applicationTags, Set\u003cString\u003e unselectedFields) {\n    throw new NotImplementedException();\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-router/src/main/java/org/apache/hadoop/yarn/server/router/webapp/FederationInterceptorREST.java"
    }
  }
}