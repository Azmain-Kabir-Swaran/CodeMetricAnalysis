{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "CapacityScheduler.java",
  "functionName": "setEntitlement",
  "functionId": "setEntitlement___inQueue-String__entitlement-QueueEntitlement",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
  "functionStartLine": 2431,
  "functionEndLine": 2465,
  "numCommitsSeen": 239,
  "timeTaken": 8185,
  "changeHistory": [
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
    "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
    "eb3e40b833b9d82c1556843f960194dc42e482f3"
  ],
  "changeHistoryShort": {
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": "Ybodychange",
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": "Ybodychange",
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": "Ybodychange",
    "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9": "Ybodychange",
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": "Ybodychange",
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": "Ymultichange(Ymodifierchange,Yexceptionschange,Ybodychange)",
    "eb3e40b833b9d82c1556843f960194dc42e482f3": "Yintroduced"
  },
  "changeHistoryDetails": {
    "39b4a37e02e929a698fcf9e32f1f71bb6b977635": {
      "type": "Ybodychange",
      "commitMessage": "YARN-9341.  Fixed enentrant lock usage in YARN project.\n            Contributed by Prabhu Joseph\n",
      "commitDate": "07/03/19 1:47 PM",
      "commitName": "39b4a37e02e929a698fcf9e32f1f71bb6b977635",
      "commitAuthor": "Eric Yang",
      "commitDateOld": "04/03/19 9:10 PM",
      "commitNameOld": "e40e2d6ad5cbe782c3a067229270738b501ed27e",
      "commitAuthorOld": "Prabhu Joseph",
      "daysBetweenCommits": 2.69,
      "commitsBetweenForRepo": 39,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n       throws YarnException {\n+    writeLock.lock();\n     try {\n-      writeLock.lock();\n       LeafQueue queue \u003d this.queueManager.getAndCheckLeafQueue(inQueue);\n       AbstractManagedParentQueue parent \u003d\n           (AbstractManagedParentQueue) queue.getParent();\n \n       if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(\n           queue.getClass()))) {\n         throw new SchedulerDynamicEditException(\n             \"Entitlement can not be\" + \" modified dynamically since queue \"\n                 + inQueue + \" is not a AutoCreatedLeafQueue\");\n       }\n \n       if (parent \u003d\u003d null || !(AbstractManagedParentQueue.class.isAssignableFrom(\n           parent.getClass()))) {\n         throw new SchedulerDynamicEditException(\n             \"The parent of AutoCreatedLeafQueue \" + inQueue\n                 + \" must be a PlanQueue/ManagedParentQueue\");\n       }\n \n       AbstractAutoCreatedLeafQueue newQueue \u003d\n           (AbstractAutoCreatedLeafQueue) queue;\n       parent.validateQueueEntitlementChange(newQueue, entitlement);\n \n       newQueue.setEntitlement(entitlement);\n \n       LOG.info(\"Set entitlement for AutoCreatedLeafQueue \" + inQueue + \"  to \"\n           + queue.getCapacity() + \" request was (\" + entitlement.getCapacity()\n           + \")\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n      throws YarnException {\n    writeLock.lock();\n    try {\n      LeafQueue queue \u003d this.queueManager.getAndCheckLeafQueue(inQueue);\n      AbstractManagedParentQueue parent \u003d\n          (AbstractManagedParentQueue) queue.getParent();\n\n      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(\n          queue.getClass()))) {\n        throw new SchedulerDynamicEditException(\n            \"Entitlement can not be\" + \" modified dynamically since queue \"\n                + inQueue + \" is not a AutoCreatedLeafQueue\");\n      }\n\n      if (parent \u003d\u003d null || !(AbstractManagedParentQueue.class.isAssignableFrom(\n          parent.getClass()))) {\n        throw new SchedulerDynamicEditException(\n            \"The parent of AutoCreatedLeafQueue \" + inQueue\n                + \" must be a PlanQueue/ManagedParentQueue\");\n      }\n\n      AbstractAutoCreatedLeafQueue newQueue \u003d\n          (AbstractAutoCreatedLeafQueue) queue;\n      parent.validateQueueEntitlementChange(newQueue, entitlement);\n\n      newQueue.setEntitlement(entitlement);\n\n      LOG.info(\"Set entitlement for AutoCreatedLeafQueue \" + inQueue + \"  to \"\n          + queue.getCapacity() + \" request was (\" + entitlement.getCapacity()\n          + \")\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "b38643c9a8dd2c53024ae830b9565a550d0ec39c": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7473. Implement Framework and policy for capacity management of auto created queues. (Suma Shivaprasad via wangda)\n\nChange-Id: Icca7805fe12f6f7fb335effff4b121b6f7f6337b\n",
      "commitDate": "08/12/17 3:10 PM",
      "commitName": "b38643c9a8dd2c53024ae830b9565a550d0ec39c",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "30/11/17 3:57 PM",
      "commitNameOld": "a63d19d36520fa55bf523483f14329756f6eadd3",
      "commitAuthorOld": "Wangda Tan",
      "daysBetweenCommits": 7.97,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,51 +1,35 @@\n   public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n       throws YarnException {\n     try {\n       writeLock.lock();\n       LeafQueue queue \u003d this.queueManager.getAndCheckLeafQueue(inQueue);\n-      AbstractManagedParentQueue parent \u003d (AbstractManagedParentQueue) queue\n-          .getParent();\n+      AbstractManagedParentQueue parent \u003d\n+          (AbstractManagedParentQueue) queue.getParent();\n \n-      if (!(queue instanceof AutoCreatedLeafQueue)) {\n+      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(\n+          queue.getClass()))) {\n         throw new SchedulerDynamicEditException(\n             \"Entitlement can not be\" + \" modified dynamically since queue \"\n                 + inQueue + \" is not a AutoCreatedLeafQueue\");\n       }\n \n-      if (parent \u003d\u003d null\n-          || !(AbstractManagedParentQueue.class.isAssignableFrom(\n-              parent.getClass()))) {\n+      if (parent \u003d\u003d null || !(AbstractManagedParentQueue.class.isAssignableFrom(\n+          parent.getClass()))) {\n         throw new SchedulerDynamicEditException(\n             \"The parent of AutoCreatedLeafQueue \" + inQueue\n                 + \" must be a PlanQueue/ManagedParentQueue\");\n       }\n \n-      AutoCreatedLeafQueue newQueue \u003d (AutoCreatedLeafQueue) queue;\n+      AbstractAutoCreatedLeafQueue newQueue \u003d\n+          (AbstractAutoCreatedLeafQueue) queue;\n+      parent.validateQueueEntitlementChange(newQueue, entitlement);\n \n-      float sumChilds \u003d parent.sumOfChildCapacities();\n-      float newChildCap \u003d\n-          sumChilds - queue.getCapacity() + entitlement.getCapacity();\n+      newQueue.setEntitlement(entitlement);\n \n-      if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n-        // note: epsilon checks here are not ok, as the epsilons might\n-        // accumulate and become a problem in aggregate\n-        if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n-            \u0026\u0026 Math.abs(\n-            entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n-          return;\n-        }\n-        newQueue.setEntitlement(entitlement);\n-      } else{\n-        throw new SchedulerDynamicEditException(\n-            \"Sum of child queues should exceed 100% for auto creating parent \"\n-                + \"queue : \" + parent.getQueueName());\n-      }\n-      LOG.info(\n-          \"Set entitlement for AutoCreatedLeafQueue \" + inQueue\n-              + \"  to \" + queue.getCapacity() +\n-              \" request was (\" + entitlement.getCapacity()\n-              + \")\");\n+      LOG.info(\"Set entitlement for AutoCreatedLeafQueue \" + inQueue + \"  to \"\n+          + queue.getCapacity() + \" request was (\" + entitlement.getCapacity()\n+          + \")\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      LeafQueue queue \u003d this.queueManager.getAndCheckLeafQueue(inQueue);\n      AbstractManagedParentQueue parent \u003d\n          (AbstractManagedParentQueue) queue.getParent();\n\n      if (!(AbstractAutoCreatedLeafQueue.class.isAssignableFrom(\n          queue.getClass()))) {\n        throw new SchedulerDynamicEditException(\n            \"Entitlement can not be\" + \" modified dynamically since queue \"\n                + inQueue + \" is not a AutoCreatedLeafQueue\");\n      }\n\n      if (parent \u003d\u003d null || !(AbstractManagedParentQueue.class.isAssignableFrom(\n          parent.getClass()))) {\n        throw new SchedulerDynamicEditException(\n            \"The parent of AutoCreatedLeafQueue \" + inQueue\n                + \" must be a PlanQueue/ManagedParentQueue\");\n      }\n\n      AbstractAutoCreatedLeafQueue newQueue \u003d\n          (AbstractAutoCreatedLeafQueue) queue;\n      parent.validateQueueEntitlementChange(newQueue, entitlement);\n\n      newQueue.setEntitlement(entitlement);\n\n      LOG.info(\"Set entitlement for AutoCreatedLeafQueue \" + inQueue + \"  to \"\n          + queue.getCapacity() + \" request was (\" + entitlement.getCapacity()\n          + \")\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "0987a7b8cbbbb2c1e4c2095821d98a7db19644df": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7419. CapacityScheduler: Allow auto leaf queue creation after queue mapping. (Suma Shivaprasad via wangda)\n\nChange-Id: Ia1704bb8cb5070e5b180b5a85787d7b9ca57ebc6\n",
      "commitDate": "16/11/17 11:25 AM",
      "commitName": "0987a7b8cbbbb2c1e4c2095821d98a7db19644df",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "09/11/17 1:01 PM",
      "commitNameOld": "ac4d2b1081d8836a21bc70e77f4e6cd2071a9949",
      "commitAuthorOld": "Konstantinos Karanasos",
      "daysBetweenCommits": 6.93,
      "commitsBetweenForRepo": 43,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,49 +1,51 @@\n   public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n       throws YarnException {\n     try {\n       writeLock.lock();\n       LeafQueue queue \u003d this.queueManager.getAndCheckLeafQueue(inQueue);\n-      ParentQueue parent \u003d (ParentQueue) queue.getParent();\n+      AbstractManagedParentQueue parent \u003d (AbstractManagedParentQueue) queue\n+          .getParent();\n \n       if (!(queue instanceof AutoCreatedLeafQueue)) {\n         throw new SchedulerDynamicEditException(\n             \"Entitlement can not be\" + \" modified dynamically since queue \"\n                 + inQueue + \" is not a AutoCreatedLeafQueue\");\n       }\n \n       if (parent \u003d\u003d null\n-          || !(AbstractManagedParentQueue.class.isAssignableFrom(parent.getClass()))) {\n+          || !(AbstractManagedParentQueue.class.isAssignableFrom(\n+              parent.getClass()))) {\n         throw new SchedulerDynamicEditException(\n             \"The parent of AutoCreatedLeafQueue \" + inQueue\n                 + \" must be a PlanQueue/ManagedParentQueue\");\n       }\n \n       AutoCreatedLeafQueue newQueue \u003d (AutoCreatedLeafQueue) queue;\n \n       float sumChilds \u003d parent.sumOfChildCapacities();\n       float newChildCap \u003d\n           sumChilds - queue.getCapacity() + entitlement.getCapacity();\n \n       if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n         // note: epsilon checks here are not ok, as the epsilons might\n         // accumulate and become a problem in aggregate\n         if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n             \u0026\u0026 Math.abs(\n             entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n           return;\n         }\n         newQueue.setEntitlement(entitlement);\n       } else{\n         throw new SchedulerDynamicEditException(\n             \"Sum of child queues should exceed 100% for auto creating parent \"\n                 + \"queue : \" + parent.getQueueName());\n       }\n       LOG.info(\n           \"Set entitlement for AutoCreatedLeafQueue \" + inQueue\n               + \"  to \" + queue.getCapacity() +\n               \" request was (\" + entitlement.getCapacity()\n               + \")\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      LeafQueue queue \u003d this.queueManager.getAndCheckLeafQueue(inQueue);\n      AbstractManagedParentQueue parent \u003d (AbstractManagedParentQueue) queue\n          .getParent();\n\n      if (!(queue instanceof AutoCreatedLeafQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"Entitlement can not be\" + \" modified dynamically since queue \"\n                + inQueue + \" is not a AutoCreatedLeafQueue\");\n      }\n\n      if (parent \u003d\u003d null\n          || !(AbstractManagedParentQueue.class.isAssignableFrom(\n              parent.getClass()))) {\n        throw new SchedulerDynamicEditException(\n            \"The parent of AutoCreatedLeafQueue \" + inQueue\n                + \" must be a PlanQueue/ManagedParentQueue\");\n      }\n\n      AutoCreatedLeafQueue newQueue \u003d (AutoCreatedLeafQueue) queue;\n\n      float sumChilds \u003d parent.sumOfChildCapacities();\n      float newChildCap \u003d\n          sumChilds - queue.getCapacity() + entitlement.getCapacity();\n\n      if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n        // note: epsilon checks here are not ok, as the epsilons might\n        // accumulate and become a problem in aggregate\n        if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n            \u0026\u0026 Math.abs(\n            entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n          return;\n        }\n        newQueue.setEntitlement(entitlement);\n      } else{\n        throw new SchedulerDynamicEditException(\n            \"Sum of child queues should exceed 100% for auto creating parent \"\n                + \"queue : \" + parent.getQueueName());\n      }\n      LOG.info(\n          \"Set entitlement for AutoCreatedLeafQueue \" + inQueue\n              + \"  to \" + queue.getCapacity() +\n              \" request was (\" + entitlement.getCapacity()\n              + \")\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7394. Merge code paths for Reservation/Plan queues and Auto Created queues. (Suma Shivaprasad via wangda)\n",
      "commitDate": "06/11/17 9:38 PM",
      "commitName": "13fa2d4e3e55a849dcd7e472750f3e0422cc2ac9",
      "commitAuthor": "Wangda Tan",
      "commitDateOld": "02/11/17 1:25 AM",
      "commitNameOld": "940ffe3f9ce74286a8863e3743faf88a33c817a3",
      "commitAuthorOld": "Rohith Sharma K S",
      "daysBetweenCommits": 4.88,
      "commitsBetweenForRepo": 130,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,49 @@\n   public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n       throws YarnException {\n     try {\n       writeLock.lock();\n       LeafQueue queue \u003d this.queueManager.getAndCheckLeafQueue(inQueue);\n       ParentQueue parent \u003d (ParentQueue) queue.getParent();\n \n-      if (!(queue instanceof ReservationQueue)) {\n+      if (!(queue instanceof AutoCreatedLeafQueue)) {\n         throw new SchedulerDynamicEditException(\n             \"Entitlement can not be\" + \" modified dynamically since queue \"\n-                + inQueue + \" is not a ReservationQueue\");\n+                + inQueue + \" is not a AutoCreatedLeafQueue\");\n       }\n \n-      if (!(parent instanceof PlanQueue)) {\n+      if (parent \u003d\u003d null\n+          || !(AbstractManagedParentQueue.class.isAssignableFrom(parent.getClass()))) {\n         throw new SchedulerDynamicEditException(\n-            \"The parent of ReservationQueue \" + inQueue\n-                + \" must be an PlanQueue\");\n+            \"The parent of AutoCreatedLeafQueue \" + inQueue\n+                + \" must be a PlanQueue/ManagedParentQueue\");\n       }\n \n-      ReservationQueue newQueue \u003d (ReservationQueue) queue;\n+      AutoCreatedLeafQueue newQueue \u003d (AutoCreatedLeafQueue) queue;\n \n-      float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n+      float sumChilds \u003d parent.sumOfChildCapacities();\n       float newChildCap \u003d\n           sumChilds - queue.getCapacity() + entitlement.getCapacity();\n \n       if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n         // note: epsilon checks here are not ok, as the epsilons might\n         // accumulate and become a problem in aggregate\n         if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n             \u0026\u0026 Math.abs(\n             entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n           return;\n         }\n         newQueue.setEntitlement(entitlement);\n       } else{\n         throw new SchedulerDynamicEditException(\n-            \"Sum of child queues would exceed 100% for PlanQueue: \" + parent\n-                .getQueueName());\n+            \"Sum of child queues should exceed 100% for auto creating parent \"\n+                + \"queue : \" + parent.getQueueName());\n       }\n       LOG.info(\n-          \"Set entitlement for ReservationQueue \" + inQueue + \"  to \" + queue\n-              .getCapacity() + \" request was (\" + entitlement.getCapacity()\n+          \"Set entitlement for AutoCreatedLeafQueue \" + inQueue\n+              + \"  to \" + queue.getCapacity() +\n+              \" request was (\" + entitlement.getCapacity()\n               + \")\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      LeafQueue queue \u003d this.queueManager.getAndCheckLeafQueue(inQueue);\n      ParentQueue parent \u003d (ParentQueue) queue.getParent();\n\n      if (!(queue instanceof AutoCreatedLeafQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"Entitlement can not be\" + \" modified dynamically since queue \"\n                + inQueue + \" is not a AutoCreatedLeafQueue\");\n      }\n\n      if (parent \u003d\u003d null\n          || !(AbstractManagedParentQueue.class.isAssignableFrom(parent.getClass()))) {\n        throw new SchedulerDynamicEditException(\n            \"The parent of AutoCreatedLeafQueue \" + inQueue\n                + \" must be a PlanQueue/ManagedParentQueue\");\n      }\n\n      AutoCreatedLeafQueue newQueue \u003d (AutoCreatedLeafQueue) queue;\n\n      float sumChilds \u003d parent.sumOfChildCapacities();\n      float newChildCap \u003d\n          sumChilds - queue.getCapacity() + entitlement.getCapacity();\n\n      if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n        // note: epsilon checks here are not ok, as the epsilons might\n        // accumulate and become a problem in aggregate\n        if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n            \u0026\u0026 Math.abs(\n            entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n          return;\n        }\n        newQueue.setEntitlement(entitlement);\n      } else{\n        throw new SchedulerDynamicEditException(\n            \"Sum of child queues should exceed 100% for auto creating parent \"\n                + \"queue : \" + parent.getQueueName());\n      }\n      LOG.info(\n          \"Set entitlement for AutoCreatedLeafQueue \" + inQueue\n              + \"  to \" + queue.getCapacity() +\n              \" request was (\" + entitlement.getCapacity()\n              + \")\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "69fb70c31aa277f7fb14b05c0185ddc5cd90793d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5761. Separate QueueManager from Scheduler. (Xuan Gong via gtcarrera9)\n",
      "commitDate": "30/11/16 1:38 PM",
      "commitName": "69fb70c31aa277f7fb14b05c0185ddc5cd90793d",
      "commitAuthor": "Li Lu",
      "commitDateOld": "29/11/16 9:40 AM",
      "commitNameOld": "25f9872be63423ada6a18481eaad2888e731fdac",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 1.17,
      "commitsBetweenForRepo": 16,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,47 +1,47 @@\n   public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n       throws YarnException {\n     try {\n       writeLock.lock();\n-      LeafQueue queue \u003d getAndCheckLeafQueue(inQueue);\n+      LeafQueue queue \u003d this.queueManager.getAndCheckLeafQueue(inQueue);\n       ParentQueue parent \u003d (ParentQueue) queue.getParent();\n \n       if (!(queue instanceof ReservationQueue)) {\n         throw new SchedulerDynamicEditException(\n             \"Entitlement can not be\" + \" modified dynamically since queue \"\n                 + inQueue + \" is not a ReservationQueue\");\n       }\n \n       if (!(parent instanceof PlanQueue)) {\n         throw new SchedulerDynamicEditException(\n             \"The parent of ReservationQueue \" + inQueue\n                 + \" must be an PlanQueue\");\n       }\n \n       ReservationQueue newQueue \u003d (ReservationQueue) queue;\n \n       float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n       float newChildCap \u003d\n           sumChilds - queue.getCapacity() + entitlement.getCapacity();\n \n       if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n         // note: epsilon checks here are not ok, as the epsilons might\n         // accumulate and become a problem in aggregate\n         if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n             \u0026\u0026 Math.abs(\n             entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n           return;\n         }\n         newQueue.setEntitlement(entitlement);\n       } else{\n         throw new SchedulerDynamicEditException(\n             \"Sum of child queues would exceed 100% for PlanQueue: \" + parent\n                 .getQueueName());\n       }\n       LOG.info(\n           \"Set entitlement for ReservationQueue \" + inQueue + \"  to \" + queue\n               .getCapacity() + \" request was (\" + entitlement.getCapacity()\n               + \")\");\n     } finally {\n       writeLock.unlock();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      LeafQueue queue \u003d this.queueManager.getAndCheckLeafQueue(inQueue);\n      ParentQueue parent \u003d (ParentQueue) queue.getParent();\n\n      if (!(queue instanceof ReservationQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"Entitlement can not be\" + \" modified dynamically since queue \"\n                + inQueue + \" is not a ReservationQueue\");\n      }\n\n      if (!(parent instanceof PlanQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"The parent of ReservationQueue \" + inQueue\n                + \" must be an PlanQueue\");\n      }\n\n      ReservationQueue newQueue \u003d (ReservationQueue) queue;\n\n      float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n      float newChildCap \u003d\n          sumChilds - queue.getCapacity() + entitlement.getCapacity();\n\n      if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n        // note: epsilon checks here are not ok, as the epsilons might\n        // accumulate and become a problem in aggregate\n        if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n            \u0026\u0026 Math.abs(\n            entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n          return;\n        }\n        newQueue.setEntitlement(entitlement);\n      } else{\n        throw new SchedulerDynamicEditException(\n            \"Sum of child queues would exceed 100% for PlanQueue: \" + parent\n                .getQueueName());\n      }\n      LOG.info(\n          \"Set entitlement for ReservationQueue \" + inQueue + \"  to \" + queue\n              .getCapacity() + \" request was (\" + entitlement.getCapacity()\n              + \")\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
      "extendedDetails": {}
    },
    "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f": {
      "type": "Ymultichange(Ymodifierchange,Yexceptionschange,Ybodychange)",
      "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
      "commitDate": "04/10/16 5:23 PM",
      "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
      "commitAuthor": "Jian He",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,47 @@\n-  public synchronized void setEntitlement(String inQueue,\n-      QueueEntitlement entitlement) throws SchedulerDynamicEditException,\n-      YarnException {\n-    LeafQueue queue \u003d getAndCheckLeafQueue(inQueue);\n-    ParentQueue parent \u003d (ParentQueue) queue.getParent();\n+  public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n+      throws YarnException {\n+    try {\n+      writeLock.lock();\n+      LeafQueue queue \u003d getAndCheckLeafQueue(inQueue);\n+      ParentQueue parent \u003d (ParentQueue) queue.getParent();\n \n-    if (!(queue instanceof ReservationQueue)) {\n-      throw new SchedulerDynamicEditException(\"Entitlement can not be\"\n-          + \" modified dynamically since queue \" + inQueue\n-          + \" is not a ReservationQueue\");\n-    }\n-\n-    if (!(parent instanceof PlanQueue)) {\n-      throw new SchedulerDynamicEditException(\"The parent of ReservationQueue \"\n-          + inQueue + \" must be an PlanQueue\");\n-    }\n-\n-    ReservationQueue newQueue \u003d (ReservationQueue) queue;\n-\n-    float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n-    float newChildCap \u003d sumChilds - queue.getCapacity() + entitlement.getCapacity();\n-\n-    if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n-      // note: epsilon checks here are not ok, as the epsilons might accumulate\n-      // and become a problem in aggregate\n-      if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n-          \u0026\u0026 Math.abs(entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n-        return;\n+      if (!(queue instanceof ReservationQueue)) {\n+        throw new SchedulerDynamicEditException(\n+            \"Entitlement can not be\" + \" modified dynamically since queue \"\n+                + inQueue + \" is not a ReservationQueue\");\n       }\n-      newQueue.setEntitlement(entitlement);\n-    } else {\n-      throw new SchedulerDynamicEditException(\n-          \"Sum of child queues would exceed 100% for PlanQueue: \"\n-              + parent.getQueueName());\n+\n+      if (!(parent instanceof PlanQueue)) {\n+        throw new SchedulerDynamicEditException(\n+            \"The parent of ReservationQueue \" + inQueue\n+                + \" must be an PlanQueue\");\n+      }\n+\n+      ReservationQueue newQueue \u003d (ReservationQueue) queue;\n+\n+      float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n+      float newChildCap \u003d\n+          sumChilds - queue.getCapacity() + entitlement.getCapacity();\n+\n+      if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n+        // note: epsilon checks here are not ok, as the epsilons might\n+        // accumulate and become a problem in aggregate\n+        if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n+            \u0026\u0026 Math.abs(\n+            entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n+          return;\n+        }\n+        newQueue.setEntitlement(entitlement);\n+      } else{\n+        throw new SchedulerDynamicEditException(\n+            \"Sum of child queues would exceed 100% for PlanQueue: \" + parent\n+                .getQueueName());\n+      }\n+      LOG.info(\n+          \"Set entitlement for ReservationQueue \" + inQueue + \"  to \" + queue\n+              .getCapacity() + \" request was (\" + entitlement.getCapacity()\n+              + \")\");\n+    } finally {\n+      writeLock.unlock();\n     }\n-    LOG.info(\"Set entitlement for ReservationQueue \" + inQueue + \"  to \"\n-        + queue.getCapacity() + \" request was (\" + entitlement.getCapacity() + \")\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      LeafQueue queue \u003d getAndCheckLeafQueue(inQueue);\n      ParentQueue parent \u003d (ParentQueue) queue.getParent();\n\n      if (!(queue instanceof ReservationQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"Entitlement can not be\" + \" modified dynamically since queue \"\n                + inQueue + \" is not a ReservationQueue\");\n      }\n\n      if (!(parent instanceof PlanQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"The parent of ReservationQueue \" + inQueue\n                + \" must be an PlanQueue\");\n      }\n\n      ReservationQueue newQueue \u003d (ReservationQueue) queue;\n\n      float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n      float newChildCap \u003d\n          sumChilds - queue.getCapacity() + entitlement.getCapacity();\n\n      if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n        // note: epsilon checks here are not ok, as the epsilons might\n        // accumulate and become a problem in aggregate\n        if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n            \u0026\u0026 Math.abs(\n            entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n          return;\n        }\n        newQueue.setEntitlement(entitlement);\n      } else{\n        throw new SchedulerDynamicEditException(\n            \"Sum of child queues would exceed 100% for PlanQueue: \" + parent\n                .getQueueName());\n      }\n      LOG.info(\n          \"Set entitlement for ReservationQueue \" + inQueue + \"  to \" + queue\n              .getCapacity() + \" request was (\" + entitlement.getCapacity()\n              + \")\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[public, synchronized]",
            "newValue": "[public]"
          }
        },
        {
          "type": "Yexceptionschange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,47 @@\n-  public synchronized void setEntitlement(String inQueue,\n-      QueueEntitlement entitlement) throws SchedulerDynamicEditException,\n-      YarnException {\n-    LeafQueue queue \u003d getAndCheckLeafQueue(inQueue);\n-    ParentQueue parent \u003d (ParentQueue) queue.getParent();\n+  public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n+      throws YarnException {\n+    try {\n+      writeLock.lock();\n+      LeafQueue queue \u003d getAndCheckLeafQueue(inQueue);\n+      ParentQueue parent \u003d (ParentQueue) queue.getParent();\n \n-    if (!(queue instanceof ReservationQueue)) {\n-      throw new SchedulerDynamicEditException(\"Entitlement can not be\"\n-          + \" modified dynamically since queue \" + inQueue\n-          + \" is not a ReservationQueue\");\n-    }\n-\n-    if (!(parent instanceof PlanQueue)) {\n-      throw new SchedulerDynamicEditException(\"The parent of ReservationQueue \"\n-          + inQueue + \" must be an PlanQueue\");\n-    }\n-\n-    ReservationQueue newQueue \u003d (ReservationQueue) queue;\n-\n-    float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n-    float newChildCap \u003d sumChilds - queue.getCapacity() + entitlement.getCapacity();\n-\n-    if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n-      // note: epsilon checks here are not ok, as the epsilons might accumulate\n-      // and become a problem in aggregate\n-      if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n-          \u0026\u0026 Math.abs(entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n-        return;\n+      if (!(queue instanceof ReservationQueue)) {\n+        throw new SchedulerDynamicEditException(\n+            \"Entitlement can not be\" + \" modified dynamically since queue \"\n+                + inQueue + \" is not a ReservationQueue\");\n       }\n-      newQueue.setEntitlement(entitlement);\n-    } else {\n-      throw new SchedulerDynamicEditException(\n-          \"Sum of child queues would exceed 100% for PlanQueue: \"\n-              + parent.getQueueName());\n+\n+      if (!(parent instanceof PlanQueue)) {\n+        throw new SchedulerDynamicEditException(\n+            \"The parent of ReservationQueue \" + inQueue\n+                + \" must be an PlanQueue\");\n+      }\n+\n+      ReservationQueue newQueue \u003d (ReservationQueue) queue;\n+\n+      float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n+      float newChildCap \u003d\n+          sumChilds - queue.getCapacity() + entitlement.getCapacity();\n+\n+      if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n+        // note: epsilon checks here are not ok, as the epsilons might\n+        // accumulate and become a problem in aggregate\n+        if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n+            \u0026\u0026 Math.abs(\n+            entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n+          return;\n+        }\n+        newQueue.setEntitlement(entitlement);\n+      } else{\n+        throw new SchedulerDynamicEditException(\n+            \"Sum of child queues would exceed 100% for PlanQueue: \" + parent\n+                .getQueueName());\n+      }\n+      LOG.info(\n+          \"Set entitlement for ReservationQueue \" + inQueue + \"  to \" + queue\n+              .getCapacity() + \" request was (\" + entitlement.getCapacity()\n+              + \")\");\n+    } finally {\n+      writeLock.unlock();\n     }\n-    LOG.info(\"Set entitlement for ReservationQueue \" + inQueue + \"  to \"\n-        + queue.getCapacity() + \" request was (\" + entitlement.getCapacity() + \")\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      LeafQueue queue \u003d getAndCheckLeafQueue(inQueue);\n      ParentQueue parent \u003d (ParentQueue) queue.getParent();\n\n      if (!(queue instanceof ReservationQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"Entitlement can not be\" + \" modified dynamically since queue \"\n                + inQueue + \" is not a ReservationQueue\");\n      }\n\n      if (!(parent instanceof PlanQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"The parent of ReservationQueue \" + inQueue\n                + \" must be an PlanQueue\");\n      }\n\n      ReservationQueue newQueue \u003d (ReservationQueue) queue;\n\n      float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n      float newChildCap \u003d\n          sumChilds - queue.getCapacity() + entitlement.getCapacity();\n\n      if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n        // note: epsilon checks here are not ok, as the epsilons might\n        // accumulate and become a problem in aggregate\n        if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n            \u0026\u0026 Math.abs(\n            entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n          return;\n        }\n        newQueue.setEntitlement(entitlement);\n      } else{\n        throw new SchedulerDynamicEditException(\n            \"Sum of child queues would exceed 100% for PlanQueue: \" + parent\n                .getQueueName());\n      }\n      LOG.info(\n          \"Set entitlement for ReservationQueue \" + inQueue + \"  to \" + queue\n              .getCapacity() + \" request was (\" + entitlement.getCapacity()\n              + \")\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {
            "oldValue": "[SchedulerDynamicEditException, YarnException]",
            "newValue": "[YarnException]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3139. Improve locks in AbstractYarnScheduler/CapacityScheduler/FairScheduler. Contributed by Wangda Tan\n",
          "commitDate": "04/10/16 5:23 PM",
          "commitName": "31f8da22d0b8d2dcce5fbc8e45d832f40acf056f",
          "commitAuthor": "Jian He",
          "commitDateOld": "30/08/16 3:52 PM",
          "commitNameOld": "d6d9cff21b7b6141ed88359652cf22e8973c0661",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 35.06,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,38 +1,47 @@\n-  public synchronized void setEntitlement(String inQueue,\n-      QueueEntitlement entitlement) throws SchedulerDynamicEditException,\n-      YarnException {\n-    LeafQueue queue \u003d getAndCheckLeafQueue(inQueue);\n-    ParentQueue parent \u003d (ParentQueue) queue.getParent();\n+  public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n+      throws YarnException {\n+    try {\n+      writeLock.lock();\n+      LeafQueue queue \u003d getAndCheckLeafQueue(inQueue);\n+      ParentQueue parent \u003d (ParentQueue) queue.getParent();\n \n-    if (!(queue instanceof ReservationQueue)) {\n-      throw new SchedulerDynamicEditException(\"Entitlement can not be\"\n-          + \" modified dynamically since queue \" + inQueue\n-          + \" is not a ReservationQueue\");\n-    }\n-\n-    if (!(parent instanceof PlanQueue)) {\n-      throw new SchedulerDynamicEditException(\"The parent of ReservationQueue \"\n-          + inQueue + \" must be an PlanQueue\");\n-    }\n-\n-    ReservationQueue newQueue \u003d (ReservationQueue) queue;\n-\n-    float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n-    float newChildCap \u003d sumChilds - queue.getCapacity() + entitlement.getCapacity();\n-\n-    if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n-      // note: epsilon checks here are not ok, as the epsilons might accumulate\n-      // and become a problem in aggregate\n-      if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n-          \u0026\u0026 Math.abs(entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n-        return;\n+      if (!(queue instanceof ReservationQueue)) {\n+        throw new SchedulerDynamicEditException(\n+            \"Entitlement can not be\" + \" modified dynamically since queue \"\n+                + inQueue + \" is not a ReservationQueue\");\n       }\n-      newQueue.setEntitlement(entitlement);\n-    } else {\n-      throw new SchedulerDynamicEditException(\n-          \"Sum of child queues would exceed 100% for PlanQueue: \"\n-              + parent.getQueueName());\n+\n+      if (!(parent instanceof PlanQueue)) {\n+        throw new SchedulerDynamicEditException(\n+            \"The parent of ReservationQueue \" + inQueue\n+                + \" must be an PlanQueue\");\n+      }\n+\n+      ReservationQueue newQueue \u003d (ReservationQueue) queue;\n+\n+      float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n+      float newChildCap \u003d\n+          sumChilds - queue.getCapacity() + entitlement.getCapacity();\n+\n+      if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n+        // note: epsilon checks here are not ok, as the epsilons might\n+        // accumulate and become a problem in aggregate\n+        if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n+            \u0026\u0026 Math.abs(\n+            entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n+          return;\n+        }\n+        newQueue.setEntitlement(entitlement);\n+      } else{\n+        throw new SchedulerDynamicEditException(\n+            \"Sum of child queues would exceed 100% for PlanQueue: \" + parent\n+                .getQueueName());\n+      }\n+      LOG.info(\n+          \"Set entitlement for ReservationQueue \" + inQueue + \"  to \" + queue\n+              .getCapacity() + \" request was (\" + entitlement.getCapacity()\n+              + \")\");\n+    } finally {\n+      writeLock.unlock();\n     }\n-    LOG.info(\"Set entitlement for ReservationQueue \" + inQueue + \"  to \"\n-        + queue.getCapacity() + \" request was (\" + entitlement.getCapacity() + \")\");\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void setEntitlement(String inQueue, QueueEntitlement entitlement)\n      throws YarnException {\n    try {\n      writeLock.lock();\n      LeafQueue queue \u003d getAndCheckLeafQueue(inQueue);\n      ParentQueue parent \u003d (ParentQueue) queue.getParent();\n\n      if (!(queue instanceof ReservationQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"Entitlement can not be\" + \" modified dynamically since queue \"\n                + inQueue + \" is not a ReservationQueue\");\n      }\n\n      if (!(parent instanceof PlanQueue)) {\n        throw new SchedulerDynamicEditException(\n            \"The parent of ReservationQueue \" + inQueue\n                + \" must be an PlanQueue\");\n      }\n\n      ReservationQueue newQueue \u003d (ReservationQueue) queue;\n\n      float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n      float newChildCap \u003d\n          sumChilds - queue.getCapacity() + entitlement.getCapacity();\n\n      if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n        // note: epsilon checks here are not ok, as the epsilons might\n        // accumulate and become a problem in aggregate\n        if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n            \u0026\u0026 Math.abs(\n            entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n          return;\n        }\n        newQueue.setEntitlement(entitlement);\n      } else{\n        throw new SchedulerDynamicEditException(\n            \"Sum of child queues would exceed 100% for PlanQueue: \" + parent\n                .getQueueName());\n      }\n      LOG.info(\n          \"Set entitlement for ReservationQueue \" + inQueue + \"  to \" + queue\n              .getCapacity() + \" request was (\" + entitlement.getCapacity()\n              + \")\");\n    } finally {\n      writeLock.unlock();\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java",
          "extendedDetails": {}
        }
      ]
    },
    "eb3e40b833b9d82c1556843f960194dc42e482f3": {
      "type": "Yintroduced",
      "commitMessage": "YARN-1707. Introduce APIs to add/remove/resize queues in the CapacityScheduler. Contributed by Carlo Curino and Subru Krishnan\n(cherry picked from commit aac47fda7fecda9fc18ade34d633eca895865a70)\n\nConflicts:\n\thadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java\n",
      "commitDate": "03/10/14 3:41 PM",
      "commitName": "eb3e40b833b9d82c1556843f960194dc42e482f3",
      "commitAuthor": "carlo curino",
      "diff": "@@ -0,0 +1,38 @@\n+  public synchronized void setEntitlement(String inQueue,\n+      QueueEntitlement entitlement) throws SchedulerDynamicEditException,\n+      YarnException {\n+    LeafQueue queue \u003d getAndCheckLeafQueue(inQueue);\n+    ParentQueue parent \u003d (ParentQueue) queue.getParent();\n+\n+    if (!(queue instanceof ReservationQueue)) {\n+      throw new SchedulerDynamicEditException(\"Entitlement can not be\"\n+          + \" modified dynamically since queue \" + inQueue\n+          + \" is not a ReservationQueue\");\n+    }\n+\n+    if (!(parent instanceof PlanQueue)) {\n+      throw new SchedulerDynamicEditException(\"The parent of ReservationQueue \"\n+          + inQueue + \" must be an PlanQueue\");\n+    }\n+\n+    ReservationQueue newQueue \u003d (ReservationQueue) queue;\n+\n+    float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n+    float newChildCap \u003d sumChilds - queue.getCapacity() + entitlement.getCapacity();\n+\n+    if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n+      // note: epsilon checks here are not ok, as the epsilons might accumulate\n+      // and become a problem in aggregate\n+      if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n+          \u0026\u0026 Math.abs(entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n+        return;\n+      }\n+      newQueue.setEntitlement(entitlement);\n+    } else {\n+      throw new SchedulerDynamicEditException(\n+          \"Sum of child queues would exceed 100% for PlanQueue: \"\n+              + parent.getQueueName());\n+    }\n+    LOG.info(\"Set entitlement for ReservationQueue \" + inQueue + \"  to \"\n+        + queue.getCapacity() + \" request was (\" + entitlement.getCapacity() + \")\");\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public synchronized void setEntitlement(String inQueue,\n      QueueEntitlement entitlement) throws SchedulerDynamicEditException,\n      YarnException {\n    LeafQueue queue \u003d getAndCheckLeafQueue(inQueue);\n    ParentQueue parent \u003d (ParentQueue) queue.getParent();\n\n    if (!(queue instanceof ReservationQueue)) {\n      throw new SchedulerDynamicEditException(\"Entitlement can not be\"\n          + \" modified dynamically since queue \" + inQueue\n          + \" is not a ReservationQueue\");\n    }\n\n    if (!(parent instanceof PlanQueue)) {\n      throw new SchedulerDynamicEditException(\"The parent of ReservationQueue \"\n          + inQueue + \" must be an PlanQueue\");\n    }\n\n    ReservationQueue newQueue \u003d (ReservationQueue) queue;\n\n    float sumChilds \u003d ((PlanQueue) parent).sumOfChildCapacities();\n    float newChildCap \u003d sumChilds - queue.getCapacity() + entitlement.getCapacity();\n\n    if (newChildCap \u003e\u003d 0 \u0026\u0026 newChildCap \u003c 1.0f + CSQueueUtils.EPSILON) {\n      // note: epsilon checks here are not ok, as the epsilons might accumulate\n      // and become a problem in aggregate\n      if (Math.abs(entitlement.getCapacity() - queue.getCapacity()) \u003d\u003d 0\n          \u0026\u0026 Math.abs(entitlement.getMaxCapacity() - queue.getMaximumCapacity()) \u003d\u003d 0) {\n        return;\n      }\n      newQueue.setEntitlement(entitlement);\n    } else {\n      throw new SchedulerDynamicEditException(\n          \"Sum of child queues would exceed 100% for PlanQueue: \"\n              + parent.getQueueName());\n    }\n    LOG.info(\"Set entitlement for ReservationQueue \" + inQueue + \"  to \"\n        + queue.getCapacity() + \" request was (\" + entitlement.getCapacity() + \")\");\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/capacity/CapacityScheduler.java"
    }
  }
}