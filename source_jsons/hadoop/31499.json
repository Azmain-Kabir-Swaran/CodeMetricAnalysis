{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "GenericEntityReader.java",
  "functionName": "parseEntity",
  "functionId": "parseEntity___result-Result",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/hadoop-yarn-server-timelineservice-hbase-client/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
  "functionStartLine": 542,
  "functionEndLine": 635,
  "numCommitsSeen": 31,
  "timeTaken": 7411,
  "changeHistory": [
    "9af30d46c6e82332a8eda20cb3eb5f987e25e7a2",
    "c3bd8d6ad3e30c08865cc1a5f374d1d2a485f844",
    "02a9710a099fc9572122d87dd3e90c78522f5836",
    "b01514f65bc6090a50a583f67d1ecb5d74b6d276",
    "892b193bd77c15932b4c084c1d525b7017def0d4",
    "8c8183e515b42b7fff7d56a14ea7af78d3fdc772",
    "c2efdc415a13496da43a9a8d13c73d88ca8565a1",
    "960af7d4717b8a8949d0b2e43949e7daab45aa88",
    "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3",
    "6934b05c7117a12286fb2ba7a47f75e227cacb22",
    "88f02941144824187b70fa2aaf0c6d90bcb77d8f",
    "b51d0fef56a59b15489f5b932025718b4e9613d2",
    "10fa6da7d8a6013698767c6136ae20f0e04415e9",
    "00e85e7a2b9446dc37265feba07473b156d66367",
    "9e5155be363c6610ccf41fe08b7f1394f353ea65"
  ],
  "changeHistoryShort": {
    "9af30d46c6e82332a8eda20cb3eb5f987e25e7a2": "Ymultichange(Yfilerename,Ybodychange)",
    "c3bd8d6ad3e30c08865cc1a5f374d1d2a485f844": "Ybodychange",
    "02a9710a099fc9572122d87dd3e90c78522f5836": "Ybodychange",
    "b01514f65bc6090a50a583f67d1ecb5d74b6d276": "Yfilerename",
    "892b193bd77c15932b4c084c1d525b7017def0d4": "Ybodychange",
    "8c8183e515b42b7fff7d56a14ea7af78d3fdc772": "Ybodychange",
    "c2efdc415a13496da43a9a8d13c73d88ca8565a1": "Ybodychange",
    "960af7d4717b8a8949d0b2e43949e7daab45aa88": "Ybodychange",
    "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3": "Ybodychange",
    "6934b05c7117a12286fb2ba7a47f75e227cacb22": "Ybodychange",
    "88f02941144824187b70fa2aaf0c6d90bcb77d8f": "Yfilerename",
    "b51d0fef56a59b15489f5b932025718b4e9613d2": "Ybodychange",
    "10fa6da7d8a6013698767c6136ae20f0e04415e9": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
    "00e85e7a2b9446dc37265feba07473b156d66367": "Ymultichange(Yparameterchange,Ybodychange)",
    "9e5155be363c6610ccf41fe08b7f1394f353ea65": "Yintroduced"
  },
  "changeHistoryDetails": {
    "9af30d46c6e82332a8eda20cb3eb5f987e25e7a2": {
      "type": "Ymultichange(Yfilerename,Ybodychange)",
      "commitMessage": "YARN-7919. Refactor timelineservice-hbase module into submodules. Contributed by Haibo Chen.\n",
      "commitDate": "17/02/18 7:00 AM",
      "commitName": "9af30d46c6e82332a8eda20cb3eb5f987e25e7a2",
      "commitAuthor": "Rohith Sharma K S",
      "subchanges": [
        {
          "type": "Yfilerename",
          "commitMessage": "YARN-7919. Refactor timelineservice-hbase module into submodules. Contributed by Haibo Chen.\n",
          "commitDate": "17/02/18 7:00 AM",
          "commitName": "9af30d46c6e82332a8eda20cb3eb5f987e25e7a2",
          "commitAuthor": "Rohith Sharma K S",
          "commitDateOld": "17/02/18 3:24 AM",
          "commitNameOld": "a1e56a62863d8d494af309ec5f476c4b7e4d5ef9",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 0.15,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,94 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n     EntityRowKey parseRowKey \u003d EntityRowKey.parseRowKey(result.getRow());\n     entity.setType(parseRowKey.getEntityType());\n     entity.setId(parseRowKey.getEntityId());\n     entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n \n     TimelineEntityFilters filters \u003d getFilters();\n     // fetch created time\n-    Long createdTime \u003d (Long) EntityColumn.CREATED_TIME.readResult(result);\n+    Long createdTime \u003d (Long) ColumnRWHelper.readResult(result,\n+        EntityColumn.CREATED_TIME);\n     entity.setCreatedTime(createdTime);\n \n     EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n     // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // isRelatedTo are not set in HBase scan.\n     boolean checkIsRelatedTo \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null\n             \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n       readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n       if (checkIsRelatedTo\n           \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n               filters.getIsRelatedTo())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities and match relatesTo filter. If relatesTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // relatesTo are not set in HBase scan.\n     boolean checkRelatesTo \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n             \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.RELATES_TO)\n         || checkRelatesTo) {\n       readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n       if (checkRelatesTo\n           \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n               filters.getRelatesTo())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info if fieldsToRetrieve contains INFO or ALL.\n     if (hasField(fieldsToRetrieve, Field.INFO)) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n     }\n \n     // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n     if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n     }\n \n     // fetch events and match event filters if they exist. If event filters do\n     // not match, entity would be dropped. We have to match filters locally\n     // as relevant HBase filters to filter out rows on the basis of events\n     // are not set in HBase scan.\n     boolean checkEvents \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n             \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n       readEvents(entity, result, EntityColumnPrefix.EVENT);\n       if (checkEvents\n           \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n               filters.getEventFilters())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n     if (hasField(fieldsToRetrieve, Field.METRICS)) {\n       readMetrics(entity, result, EntityColumnPrefix.METRIC);\n     }\n \n     entity.getInfo().put(TimelineReaderUtils.FROMID_KEY,\n         parseRowKey.getRowKeyAsString());\n     return entity;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    EntityRowKey parseRowKey \u003d EntityRowKey.parseRowKey(result.getRow());\n    entity.setType(parseRowKey.getEntityType());\n    entity.setId(parseRowKey.getEntityId());\n    entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Long createdTime \u003d (Long) ColumnRWHelper.readResult(result,\n        EntityColumn.CREATED_TIME);\n    entity.setCreatedTime(createdTime);\n\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // isRelatedTo are not set in HBase scan.\n    boolean checkIsRelatedTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null\n            \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo\n          \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n              filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities and match relatesTo filter. If relatesTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // relatesTo are not set in HBase scan.\n    boolean checkRelatesTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n            \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.RELATES_TO)\n        || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo\n          \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n              filters.getRelatesTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info if fieldsToRetrieve contains INFO or ALL.\n    if (hasField(fieldsToRetrieve, Field.INFO)) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n    }\n\n    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n    if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n    }\n\n    // fetch events and match event filters if they exist. If event filters do\n    // not match, entity would be dropped. We have to match filters locally\n    // as relevant HBase filters to filter out rows on the basis of events\n    // are not set in HBase scan.\n    boolean checkEvents \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n            \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, EntityColumnPrefix.EVENT);\n      if (checkEvents\n          \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n              filters.getEventFilters())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n    if (hasField(fieldsToRetrieve, Field.METRICS)) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n    }\n\n    entity.getInfo().put(TimelineReaderUtils.FROMID_KEY,\n        parseRowKey.getRowKeyAsString());\n    return entity;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/hadoop-yarn-server-timelineservice-hbase-client/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/hadoop-yarn-server-timelineservice-hbase-client/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7919. Refactor timelineservice-hbase module into submodules. Contributed by Haibo Chen.\n",
          "commitDate": "17/02/18 7:00 AM",
          "commitName": "9af30d46c6e82332a8eda20cb3eb5f987e25e7a2",
          "commitAuthor": "Rohith Sharma K S",
          "commitDateOld": "17/02/18 3:24 AM",
          "commitNameOld": "a1e56a62863d8d494af309ec5f476c4b7e4d5ef9",
          "commitAuthorOld": "Arun Suresh",
          "daysBetweenCommits": 0.15,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,93 +1,94 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n     EntityRowKey parseRowKey \u003d EntityRowKey.parseRowKey(result.getRow());\n     entity.setType(parseRowKey.getEntityType());\n     entity.setId(parseRowKey.getEntityId());\n     entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n \n     TimelineEntityFilters filters \u003d getFilters();\n     // fetch created time\n-    Long createdTime \u003d (Long) EntityColumn.CREATED_TIME.readResult(result);\n+    Long createdTime \u003d (Long) ColumnRWHelper.readResult(result,\n+        EntityColumn.CREATED_TIME);\n     entity.setCreatedTime(createdTime);\n \n     EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n     // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // isRelatedTo are not set in HBase scan.\n     boolean checkIsRelatedTo \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null\n             \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n       readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n       if (checkIsRelatedTo\n           \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n               filters.getIsRelatedTo())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities and match relatesTo filter. If relatesTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // relatesTo are not set in HBase scan.\n     boolean checkRelatesTo \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n             \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.RELATES_TO)\n         || checkRelatesTo) {\n       readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n       if (checkRelatesTo\n           \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n               filters.getRelatesTo())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info if fieldsToRetrieve contains INFO or ALL.\n     if (hasField(fieldsToRetrieve, Field.INFO)) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n     }\n \n     // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n     if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n     }\n \n     // fetch events and match event filters if they exist. If event filters do\n     // not match, entity would be dropped. We have to match filters locally\n     // as relevant HBase filters to filter out rows on the basis of events\n     // are not set in HBase scan.\n     boolean checkEvents \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n             \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n       readEvents(entity, result, EntityColumnPrefix.EVENT);\n       if (checkEvents\n           \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n               filters.getEventFilters())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n     if (hasField(fieldsToRetrieve, Field.METRICS)) {\n       readMetrics(entity, result, EntityColumnPrefix.METRIC);\n     }\n \n     entity.getInfo().put(TimelineReaderUtils.FROMID_KEY,\n         parseRowKey.getRowKeyAsString());\n     return entity;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    EntityRowKey parseRowKey \u003d EntityRowKey.parseRowKey(result.getRow());\n    entity.setType(parseRowKey.getEntityType());\n    entity.setId(parseRowKey.getEntityId());\n    entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Long createdTime \u003d (Long) ColumnRWHelper.readResult(result,\n        EntityColumn.CREATED_TIME);\n    entity.setCreatedTime(createdTime);\n\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // isRelatedTo are not set in HBase scan.\n    boolean checkIsRelatedTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null\n            \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo\n          \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n              filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities and match relatesTo filter. If relatesTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // relatesTo are not set in HBase scan.\n    boolean checkRelatesTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n            \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.RELATES_TO)\n        || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo\n          \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n              filters.getRelatesTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info if fieldsToRetrieve contains INFO or ALL.\n    if (hasField(fieldsToRetrieve, Field.INFO)) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n    }\n\n    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n    if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n    }\n\n    // fetch events and match event filters if they exist. If event filters do\n    // not match, entity would be dropped. We have to match filters locally\n    // as relevant HBase filters to filter out rows on the basis of events\n    // are not set in HBase scan.\n    boolean checkEvents \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n            \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, EntityColumnPrefix.EVENT);\n      if (checkEvents\n          \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n              filters.getEventFilters())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n    if (hasField(fieldsToRetrieve, Field.METRICS)) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n    }\n\n    entity.getInfo().put(TimelineReaderUtils.FROMID_KEY,\n        parseRowKey.getRowKeyAsString());\n    return entity;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/hadoop-yarn-server-timelineservice-hbase-client/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
          "extendedDetails": {}
        }
      ]
    },
    "c3bd8d6ad3e30c08865cc1a5f374d1d2a485f844": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6256. Add FROM_ID info key for timeline entities in reader response (Rohith Sharma K S via Varun Saxena)\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "c3bd8d6ad3e30c08865cc1a5f374d1d2a485f844",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "02a9710a099fc9572122d87dd3e90c78522f5836",
      "commitAuthorOld": "Varun Saxena",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 11,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,93 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n     EntityRowKey parseRowKey \u003d EntityRowKey.parseRowKey(result.getRow());\n     entity.setType(parseRowKey.getEntityType());\n     entity.setId(parseRowKey.getEntityId());\n     entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n \n     TimelineEntityFilters filters \u003d getFilters();\n     // fetch created time\n     Long createdTime \u003d (Long) EntityColumn.CREATED_TIME.readResult(result);\n     entity.setCreatedTime(createdTime);\n \n     EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n     // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // isRelatedTo are not set in HBase scan.\n     boolean checkIsRelatedTo \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null\n             \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n       readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n       if (checkIsRelatedTo\n           \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n               filters.getIsRelatedTo())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities and match relatesTo filter. If relatesTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // relatesTo are not set in HBase scan.\n     boolean checkRelatesTo \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n             \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.RELATES_TO)\n         || checkRelatesTo) {\n       readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n       if (checkRelatesTo\n           \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n               filters.getRelatesTo())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info if fieldsToRetrieve contains INFO or ALL.\n     if (hasField(fieldsToRetrieve, Field.INFO)) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n     }\n \n     // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n     if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n     }\n \n     // fetch events and match event filters if they exist. If event filters do\n     // not match, entity would be dropped. We have to match filters locally\n     // as relevant HBase filters to filter out rows on the basis of events\n     // are not set in HBase scan.\n     boolean checkEvents \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n             \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n       readEvents(entity, result, EntityColumnPrefix.EVENT);\n       if (checkEvents\n           \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n               filters.getEventFilters())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n     if (hasField(fieldsToRetrieve, Field.METRICS)) {\n       readMetrics(entity, result, EntityColumnPrefix.METRIC);\n     }\n+\n+    entity.getInfo().put(TimelineReaderUtils.FROMID_KEY,\n+        parseRowKey.getRowKeyAsString());\n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    EntityRowKey parseRowKey \u003d EntityRowKey.parseRowKey(result.getRow());\n    entity.setType(parseRowKey.getEntityType());\n    entity.setId(parseRowKey.getEntityId());\n    entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Long createdTime \u003d (Long) EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime);\n\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // isRelatedTo are not set in HBase scan.\n    boolean checkIsRelatedTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null\n            \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo\n          \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n              filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities and match relatesTo filter. If relatesTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // relatesTo are not set in HBase scan.\n    boolean checkRelatesTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n            \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.RELATES_TO)\n        || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo\n          \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n              filters.getRelatesTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info if fieldsToRetrieve contains INFO or ALL.\n    if (hasField(fieldsToRetrieve, Field.INFO)) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n    }\n\n    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n    if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n    }\n\n    // fetch events and match event filters if they exist. If event filters do\n    // not match, entity would be dropped. We have to match filters locally\n    // as relevant HBase filters to filter out rows on the basis of events\n    // are not set in HBase scan.\n    boolean checkEvents \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n            \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, EntityColumnPrefix.EVENT);\n      if (checkEvents\n          \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n              filters.getEventFilters())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n    if (hasField(fieldsToRetrieve, Field.METRICS)) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n    }\n\n    entity.getInfo().put(TimelineReaderUtils.FROMID_KEY,\n        parseRowKey.getRowKeyAsString());\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
      "extendedDetails": {}
    },
    "02a9710a099fc9572122d87dd3e90c78522f5836": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5585. [Atsv2] Reader side changes for entity prefix and support for pagination via additional filters (Rohith Sharma K S via Varun Saxena)\n",
      "commitDate": "29/08/17 10:59 PM",
      "commitName": "02a9710a099fc9572122d87dd3e90c78522f5836",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "29/08/17 10:59 PM",
      "commitNameOld": "4481561e4a3433197dd8e73f38856eef84f0fd03",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 4,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,90 +1,90 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n-    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n-    entity.setType(entityType);\n-    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n-    entity.setId(entityId);\n+    EntityRowKey parseRowKey \u003d EntityRowKey.parseRowKey(result.getRow());\n+    entity.setType(parseRowKey.getEntityType());\n+    entity.setId(parseRowKey.getEntityId());\n+    entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n \n     TimelineEntityFilters filters \u003d getFilters();\n     // fetch created time\n     Long createdTime \u003d (Long) EntityColumn.CREATED_TIME.readResult(result);\n     entity.setCreatedTime(createdTime);\n \n     EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n     // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // isRelatedTo are not set in HBase scan.\n     boolean checkIsRelatedTo \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null\n             \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n       readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n       if (checkIsRelatedTo\n           \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n               filters.getIsRelatedTo())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities and match relatesTo filter. If relatesTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // relatesTo are not set in HBase scan.\n     boolean checkRelatesTo \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n             \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.RELATES_TO)\n         || checkRelatesTo) {\n       readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n       if (checkRelatesTo\n           \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n               filters.getRelatesTo())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info if fieldsToRetrieve contains INFO or ALL.\n     if (hasField(fieldsToRetrieve, Field.INFO)) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n     }\n \n     // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n     if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n     }\n \n     // fetch events and match event filters if they exist. If event filters do\n     // not match, entity would be dropped. We have to match filters locally\n     // as relevant HBase filters to filter out rows on the basis of events\n     // are not set in HBase scan.\n     boolean checkEvents \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n             \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n     if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n       readEvents(entity, result, EntityColumnPrefix.EVENT);\n       if (checkEvents\n           \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n               filters.getEventFilters())) {\n         return null;\n       }\n       if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n     if (hasField(fieldsToRetrieve, Field.METRICS)) {\n       readMetrics(entity, result, EntityColumnPrefix.METRIC);\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    EntityRowKey parseRowKey \u003d EntityRowKey.parseRowKey(result.getRow());\n    entity.setType(parseRowKey.getEntityType());\n    entity.setId(parseRowKey.getEntityId());\n    entity.setIdPrefix(parseRowKey.getEntityIdPrefix().longValue());\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Long createdTime \u003d (Long) EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime);\n\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // isRelatedTo are not set in HBase scan.\n    boolean checkIsRelatedTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null\n            \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo\n          \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n              filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities and match relatesTo filter. If relatesTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // relatesTo are not set in HBase scan.\n    boolean checkRelatesTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n            \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.RELATES_TO)\n        || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo\n          \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n              filters.getRelatesTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info if fieldsToRetrieve contains INFO or ALL.\n    if (hasField(fieldsToRetrieve, Field.INFO)) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n    }\n\n    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n    if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n    }\n\n    // fetch events and match event filters if they exist. If event filters do\n    // not match, entity would be dropped. We have to match filters locally\n    // as relevant HBase filters to filter out rows on the basis of events\n    // are not set in HBase scan.\n    boolean checkEvents \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n            \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, EntityColumnPrefix.EVENT);\n      if (checkEvents\n          \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n              filters.getEventFilters())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n    if (hasField(fieldsToRetrieve, Field.METRICS)) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n    }\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
      "extendedDetails": {}
    },
    "b01514f65bc6090a50a583f67d1ecb5d74b6d276": {
      "type": "Yfilerename",
      "commitMessage": "YARN-5928. Move ATSv2 HBase backend code into a new module that is only dependent at runtime by yarn servers. Contributed by Haibo Chen.\n",
      "commitDate": "19/01/17 8:52 PM",
      "commitName": "b01514f65bc6090a50a583f67d1ecb5d74b6d276",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "19/01/17 5:32 PM",
      "commitNameOld": "60865c8ea08053f3d6ac23f81c3376a3de3ca996",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 0.14,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Long createdTime \u003d (Long) EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime);\n\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // isRelatedTo are not set in HBase scan.\n    boolean checkIsRelatedTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null\n            \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo\n          \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n              filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities and match relatesTo filter. If relatesTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // relatesTo are not set in HBase scan.\n    boolean checkRelatesTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n            \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.RELATES_TO)\n        || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo\n          \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n              filters.getRelatesTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info if fieldsToRetrieve contains INFO or ALL.\n    if (hasField(fieldsToRetrieve, Field.INFO)) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n    }\n\n    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n    if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n    }\n\n    // fetch events and match event filters if they exist. If event filters do\n    // not match, entity would be dropped. We have to match filters locally\n    // as relevant HBase filters to filter out rows on the basis of events\n    // are not set in HBase scan.\n    boolean checkEvents \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n            \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, EntityColumnPrefix.EVENT);\n      if (checkEvents\n          \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n              filters.getEventFilters())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n    if (hasField(fieldsToRetrieve, Field.METRICS)) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n    }\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice-hbase/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java"
      }
    },
    "892b193bd77c15932b4c084c1d525b7017def0d4": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5170. Eliminate singleton converters and static method access. (Joep Rottinghuis via Varun Saxena)\n",
      "commitDate": "10/07/16 8:46 AM",
      "commitName": "892b193bd77c15932b4c084c1d525b7017def0d4",
      "commitAuthor": "Varun Saxena",
      "commitDateOld": "10/07/16 8:46 AM",
      "commitNameOld": "c81a2e1d197b9995103797348cb5cc4bcf9a015b",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,90 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n     String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n     entity.setType(entityType);\n     String entityId \u003d EntityColumn.ID.readResult(result).toString();\n     entity.setId(entityId);\n \n     TimelineEntityFilters filters \u003d getFilters();\n     // fetch created time\n     Long createdTime \u003d (Long) EntityColumn.CREATED_TIME.readResult(result);\n     entity.setCreatedTime(createdTime);\n \n     EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n     // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // isRelatedTo are not set in HBase scan.\n     boolean checkIsRelatedTo \u003d\n-        !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null \u0026\u0026\n-        filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n-    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.IS_RELATED_TO) ||\n-        checkIsRelatedTo) {\n-      TimelineStorageUtils.readRelationship(\n-          entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n-      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n-          filters.getIsRelatedTo())) {\n+        !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null\n+            \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n+    if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n+      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n+      if (checkIsRelatedTo\n+          \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n+              filters.getIsRelatedTo())) {\n         return null;\n       }\n-      if (!TimelineStorageUtils.hasField(fieldsToRetrieve,\n-          Field.IS_RELATED_TO)) {\n+      if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities and match relatesTo filter. If relatesTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // relatesTo are not set in HBase scan.\n     boolean checkRelatesTo \u003d\n-        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null \u0026\u0026\n-        filters.getRelatesTo().getFilterList().size() \u003e 0;\n-    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO) ||\n-        checkRelatesTo) {\n-      TimelineStorageUtils.readRelationship(\n-          entity, result, EntityColumnPrefix.RELATES_TO, false);\n-      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n-          filters.getRelatesTo())) {\n+        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n+            \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n+    if (hasField(fieldsToRetrieve, Field.RELATES_TO)\n+        || checkRelatesTo) {\n+      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n+      if (checkRelatesTo\n+          \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n+              filters.getRelatesTo())) {\n         return null;\n       }\n-      if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n+      if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info if fieldsToRetrieve contains INFO or ALL.\n-    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.INFO)) {\n-      TimelineStorageUtils.readKeyValuePairs(\n-          entity, result, EntityColumnPrefix.INFO, false);\n+    if (hasField(fieldsToRetrieve, Field.INFO)) {\n+      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n     }\n \n     // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n-    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.CONFIGS)) {\n-      TimelineStorageUtils.readKeyValuePairs(\n-          entity, result, EntityColumnPrefix.CONFIG, true);\n+    if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n+      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n     }\n \n     // fetch events and match event filters if they exist. If event filters do\n     // not match, entity would be dropped. We have to match filters locally\n     // as relevant HBase filters to filter out rows on the basis of events\n     // are not set in HBase scan.\n     boolean checkEvents \u003d\n-        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null \u0026\u0026\n-        filters.getEventFilters().getFilterList().size() \u003e 0;\n-    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS) ||\n-        checkEvents) {\n-      TimelineStorageUtils.readEvents(entity, result, EntityColumnPrefix.EVENT);\n-      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n-          filters.getEventFilters())) {\n+        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n+            \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n+    if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n+      readEvents(entity, result, EntityColumnPrefix.EVENT);\n+      if (checkEvents\n+          \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n+              filters.getEventFilters())) {\n         return null;\n       }\n-      if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS)) {\n+      if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n-    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.METRICS)) {\n+    if (hasField(fieldsToRetrieve, Field.METRICS)) {\n       readMetrics(entity, result, EntityColumnPrefix.METRIC);\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Long createdTime \u003d (Long) EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime);\n\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // isRelatedTo are not set in HBase scan.\n    boolean checkIsRelatedTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null\n            \u0026\u0026 filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo\n          \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n              filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities and match relatesTo filter. If relatesTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // relatesTo are not set in HBase scan.\n    boolean checkRelatesTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null\n            \u0026\u0026 filters.getRelatesTo().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.RELATES_TO)\n        || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo\n          \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n              filters.getRelatesTo())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info if fieldsToRetrieve contains INFO or ALL.\n    if (hasField(fieldsToRetrieve, Field.INFO)) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n    }\n\n    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n    if (hasField(fieldsToRetrieve, Field.CONFIGS)) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n    }\n\n    // fetch events and match event filters if they exist. If event filters do\n    // not match, entity would be dropped. We have to match filters locally\n    // as relevant HBase filters to filter out rows on the basis of events\n    // are not set in HBase scan.\n    boolean checkEvents \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null\n            \u0026\u0026 filters.getEventFilters().getFilterList().size() \u003e 0;\n    if (hasField(fieldsToRetrieve, Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, EntityColumnPrefix.EVENT);\n      if (checkEvents\n          \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n              filters.getEventFilters())) {\n        return null;\n      }\n      if (!hasField(fieldsToRetrieve, Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n    if (hasField(fieldsToRetrieve, Field.METRICS)) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n    }\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
      "extendedDetails": {}
    },
    "8c8183e515b42b7fff7d56a14ea7af78d3fdc772": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5093. created time shows 0 in most REST output (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "8c8183e515b42b7fff7d56a14ea7af78d3fdc772",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "c2efdc415a13496da43a9a8d13c73d88ca8565a1",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 13,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,94 +1,94 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n     String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n     entity.setType(entityType);\n     String entityId \u003d EntityColumn.ID.readResult(result).toString();\n     entity.setId(entityId);\n \n     TimelineEntityFilters filters \u003d getFilters();\n     // fetch created time\n-    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n-    entity.setCreatedTime(createdTime.longValue());\n+    Long createdTime \u003d (Long) EntityColumn.CREATED_TIME.readResult(result);\n+    entity.setCreatedTime(createdTime);\n \n     EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n     // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // isRelatedTo are not set in HBase scan.\n     boolean checkIsRelatedTo \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null \u0026\u0026\n         filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n     if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.IS_RELATED_TO) ||\n         checkIsRelatedTo) {\n       TimelineStorageUtils.readRelationship(\n           entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n       if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n           filters.getIsRelatedTo())) {\n         return null;\n       }\n       if (!TimelineStorageUtils.hasField(fieldsToRetrieve,\n           Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities and match relatesTo filter. If relatesTo\n     // filters do not match, entity would be dropped. We have to match filters\n     // locally as relevant HBase filters to filter out rows on the basis of\n     // relatesTo are not set in HBase scan.\n     boolean checkRelatesTo \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null \u0026\u0026\n         filters.getRelatesTo().getFilterList().size() \u003e 0;\n     if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO) ||\n         checkRelatesTo) {\n       TimelineStorageUtils.readRelationship(\n           entity, result, EntityColumnPrefix.RELATES_TO, false);\n       if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n           filters.getRelatesTo())) {\n         return null;\n       }\n       if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info if fieldsToRetrieve contains INFO or ALL.\n     if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.INFO)) {\n       TimelineStorageUtils.readKeyValuePairs(\n           entity, result, EntityColumnPrefix.INFO, false);\n     }\n \n     // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n     if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.CONFIGS)) {\n       TimelineStorageUtils.readKeyValuePairs(\n           entity, result, EntityColumnPrefix.CONFIG, true);\n     }\n \n     // fetch events and match event filters if they exist. If event filters do\n     // not match, entity would be dropped. We have to match filters locally\n     // as relevant HBase filters to filter out rows on the basis of events\n     // are not set in HBase scan.\n     boolean checkEvents \u003d\n         !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null \u0026\u0026\n         filters.getEventFilters().getFilterList().size() \u003e 0;\n     if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS) ||\n         checkEvents) {\n       TimelineStorageUtils.readEvents(entity, result, EntityColumnPrefix.EVENT);\n       if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n           filters.getEventFilters())) {\n         return null;\n       }\n       if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n     if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.METRICS)) {\n       readMetrics(entity, result, EntityColumnPrefix.METRIC);\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Long createdTime \u003d (Long) EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime);\n\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // isRelatedTo are not set in HBase scan.\n    boolean checkIsRelatedTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null \u0026\u0026\n        filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.IS_RELATED_TO) ||\n        checkIsRelatedTo) {\n      TimelineStorageUtils.readRelationship(\n          entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n          filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!TimelineStorageUtils.hasField(fieldsToRetrieve,\n          Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities and match relatesTo filter. If relatesTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // relatesTo are not set in HBase scan.\n    boolean checkRelatesTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null \u0026\u0026\n        filters.getRelatesTo().getFilterList().size() \u003e 0;\n    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO) ||\n        checkRelatesTo) {\n      TimelineStorageUtils.readRelationship(\n          entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n          filters.getRelatesTo())) {\n        return null;\n      }\n      if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info if fieldsToRetrieve contains INFO or ALL.\n    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.INFO)) {\n      TimelineStorageUtils.readKeyValuePairs(\n          entity, result, EntityColumnPrefix.INFO, false);\n    }\n\n    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.CONFIGS)) {\n      TimelineStorageUtils.readKeyValuePairs(\n          entity, result, EntityColumnPrefix.CONFIG, true);\n    }\n\n    // fetch events and match event filters if they exist. If event filters do\n    // not match, entity would be dropped. We have to match filters locally\n    // as relevant HBase filters to filter out rows on the basis of events\n    // are not set in HBase scan.\n    boolean checkEvents \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null \u0026\u0026\n        filters.getEventFilters().getFilterList().size() \u003e 0;\n    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS) ||\n        checkEvents) {\n      TimelineStorageUtils.readEvents(entity, result, EntityColumnPrefix.EVENT);\n      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n          filters.getEventFilters())) {\n        return null;\n      }\n      if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.METRICS)) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n    }\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
      "extendedDetails": {}
    },
    "c2efdc415a13496da43a9a8d13c73d88ca8565a1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3863. Support complex filters in TimelineReader (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "c2efdc415a13496da43a9a8d13c73d88ca8565a1",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "960af7d4717b8a8949d0b2e43949e7daab45aa88",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 8,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,94 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n     String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n     entity.setType(entityType);\n     String entityId \u003d EntityColumn.ID.readResult(result).toString();\n     entity.setId(entityId);\n \n     TimelineEntityFilters filters \u003d getFilters();\n     // fetch created time\n     Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n     entity.setCreatedTime(createdTime.longValue());\n-    if (!isSingleEntityRead() \u0026\u0026\n-        (entity.getCreatedTime() \u003c filters.getCreatedTimeBegin() ||\n-        entity.getCreatedTime() \u003e filters.getCreatedTimeEnd())) {\n-      return null;\n-    }\n+\n     EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n-    // fetch is related to entities\n+    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n+    // filters do not match, entity would be dropped. We have to match filters\n+    // locally as relevant HBase filters to filter out rows on the basis of\n+    // isRelatedTo are not set in HBase scan.\n     boolean checkIsRelatedTo \u003d\n-        filters !\u003d null \u0026\u0026 filters.getIsRelatedTo() !\u003d null \u0026\u0026\n-        filters.getIsRelatedTo().size() \u003e 0;\n-    if (fieldsToRetrieve.contains(Field.ALL) ||\n-        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n-      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n-      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n-          entity.getIsRelatedToEntities(), filters.getIsRelatedTo())) {\n+        !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null \u0026\u0026\n+        filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.IS_RELATED_TO) ||\n+        checkIsRelatedTo) {\n+      TimelineStorageUtils.readRelationship(\n+          entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n+      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n+          filters.getIsRelatedTo())) {\n         return null;\n       }\n-      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n-          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n+      if (!TimelineStorageUtils.hasField(fieldsToRetrieve,\n+          Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n-    // fetch relates to entities\n+    // fetch relates to entities and match relatesTo filter. If relatesTo\n+    // filters do not match, entity would be dropped. We have to match filters\n+    // locally as relevant HBase filters to filter out rows on the basis of\n+    // relatesTo are not set in HBase scan.\n     boolean checkRelatesTo \u003d\n-        filters !\u003d null \u0026\u0026 filters.getRelatesTo() !\u003d null \u0026\u0026\n-        filters.getRelatesTo().size() \u003e 0;\n-    if (fieldsToRetrieve.contains(Field.ALL) ||\n-        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n-      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n-      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n-          entity.getRelatesToEntities(), filters.getRelatesTo())) {\n+        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null \u0026\u0026\n+        filters.getRelatesTo().getFilterList().size() \u003e 0;\n+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO) ||\n+        checkRelatesTo) {\n+      TimelineStorageUtils.readRelationship(\n+          entity, result, EntityColumnPrefix.RELATES_TO, false);\n+      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n+          filters.getRelatesTo())) {\n         return null;\n       }\n-      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n-          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n+      if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n-    // fetch info\n-    boolean checkInfo \u003d filters !\u003d null \u0026\u0026 filters.getInfoFilters() !\u003d null \u0026\u0026\n-        filters.getInfoFilters().size() \u003e 0;\n-    if (fieldsToRetrieve.contains(Field.ALL) ||\n-        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n-      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n-      if (checkInfo \u0026\u0026\n-          !TimelineStorageUtils.matchFilters(\n-          entity.getInfo(), filters.getInfoFilters())) {\n-        return null;\n-      }\n-      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n-          !fieldsToRetrieve.contains(Field.INFO)) {\n-        entity.getInfo().clear();\n-      }\n+    // fetch info if fieldsToRetrieve contains INFO or ALL.\n+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.INFO)) {\n+      TimelineStorageUtils.readKeyValuePairs(\n+          entity, result, EntityColumnPrefix.INFO, false);\n     }\n \n-    // fetch configs\n-    boolean checkConfigs \u003d\n-        filters !\u003d null \u0026\u0026 filters.getConfigFilters() !\u003d null \u0026\u0026\n-        filters.getConfigFilters().size() \u003e 0;\n-    if (fieldsToRetrieve.contains(Field.ALL) ||\n-        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n-      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n-      if (checkConfigs \u0026\u0026 !TimelineStorageUtils.matchFilters(\n-          entity.getConfigs(), filters.getConfigFilters())) {\n-        return null;\n-      }\n-      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n-          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n-        entity.getConfigs().clear();\n-      }\n+    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.CONFIGS)) {\n+      TimelineStorageUtils.readKeyValuePairs(\n+          entity, result, EntityColumnPrefix.CONFIG, true);\n     }\n \n-    // fetch events\n+    // fetch events and match event filters if they exist. If event filters do\n+    // not match, entity would be dropped. We have to match filters locally\n+    // as relevant HBase filters to filter out rows on the basis of events\n+    // are not set in HBase scan.\n     boolean checkEvents \u003d\n-        filters !\u003d null \u0026\u0026 filters.getEventFilters() !\u003d null \u0026\u0026\n-        filters.getEventFilters().size() \u003e 0;\n-    if (fieldsToRetrieve.contains(Field.ALL) ||\n-        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n-      readEvents(entity, result, false);\n-      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(\n-          entity.getEvents(), filters.getEventFilters())) {\n+        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null \u0026\u0026\n+        filters.getEventFilters().getFilterList().size() \u003e 0;\n+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS) ||\n+        checkEvents) {\n+      TimelineStorageUtils.readEvents(entity, result, EntityColumnPrefix.EVENT);\n+      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n+          filters.getEventFilters())) {\n         return null;\n       }\n-      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n-          !fieldsToRetrieve.contains(Field.EVENTS)) {\n+      if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n-    // fetch metrics\n-    boolean checkMetrics \u003d\n-        filters !\u003d null \u0026\u0026 filters.getMetricFilters() !\u003d null \u0026\u0026\n-        filters.getMetricFilters().size() \u003e 0;\n-    if (fieldsToRetrieve.contains(Field.ALL) ||\n-        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n+    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n+    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.METRICS)) {\n       readMetrics(entity, result, EntityColumnPrefix.METRIC);\n-      if (checkMetrics \u0026\u0026 !TimelineStorageUtils.matchMetricFilters(\n-          entity.getMetrics(), filters.getMetricFilters())) {\n-        return null;\n-      }\n-      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n-          !fieldsToRetrieve.contains(Field.METRICS)) {\n-        entity.getMetrics().clear();\n-      }\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime.longValue());\n\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities and match isRelatedTo filter. If isRelatedTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // isRelatedTo are not set in HBase scan.\n    boolean checkIsRelatedTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getIsRelatedTo() !\u003d null \u0026\u0026\n        filters.getIsRelatedTo().getFilterList().size() \u003e 0;\n    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.IS_RELATED_TO) ||\n        checkIsRelatedTo) {\n      TimelineStorageUtils.readRelationship(\n          entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchIsRelatedTo(entity,\n          filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!TimelineStorageUtils.hasField(fieldsToRetrieve,\n          Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities and match relatesTo filter. If relatesTo\n    // filters do not match, entity would be dropped. We have to match filters\n    // locally as relevant HBase filters to filter out rows on the basis of\n    // relatesTo are not set in HBase scan.\n    boolean checkRelatesTo \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getRelatesTo() !\u003d null \u0026\u0026\n        filters.getRelatesTo().getFilterList().size() \u003e 0;\n    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO) ||\n        checkRelatesTo) {\n      TimelineStorageUtils.readRelationship(\n          entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelatesTo(entity,\n          filters.getRelatesTo())) {\n        return null;\n      }\n      if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info if fieldsToRetrieve contains INFO or ALL.\n    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.INFO)) {\n      TimelineStorageUtils.readKeyValuePairs(\n          entity, result, EntityColumnPrefix.INFO, false);\n    }\n\n    // fetch configs if fieldsToRetrieve contains CONFIGS or ALL.\n    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.CONFIGS)) {\n      TimelineStorageUtils.readKeyValuePairs(\n          entity, result, EntityColumnPrefix.CONFIG, true);\n    }\n\n    // fetch events and match event filters if they exist. If event filters do\n    // not match, entity would be dropped. We have to match filters locally\n    // as relevant HBase filters to filter out rows on the basis of events\n    // are not set in HBase scan.\n    boolean checkEvents \u003d\n        !isSingleEntityRead() \u0026\u0026 filters.getEventFilters() !\u003d null \u0026\u0026\n        filters.getEventFilters().getFilterList().size() \u003e 0;\n    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS) ||\n        checkEvents) {\n      TimelineStorageUtils.readEvents(entity, result, EntityColumnPrefix.EVENT);\n      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(entity,\n          filters.getEventFilters())) {\n        return null;\n      }\n      if (!TimelineStorageUtils.hasField(fieldsToRetrieve, Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics if fieldsToRetrieve contains METRICS or ALL.\n    if (TimelineStorageUtils.hasField(fieldsToRetrieve, Field.METRICS)) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n    }\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
      "extendedDetails": {}
    },
    "960af7d4717b8a8949d0b2e43949e7daab45aa88": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4409. Fix javadoc and checkstyle issues in timelineservice code (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "960af7d4717b8a8949d0b2e43949e7daab45aa88",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,123 +1,123 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n     String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n     entity.setType(entityType);\n     String entityId \u003d EntityColumn.ID.readResult(result).toString();\n     entity.setId(entityId);\n \n     TimelineEntityFilters filters \u003d getFilters();\n     // fetch created time\n     Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n     entity.setCreatedTime(createdTime.longValue());\n-    if (!singleEntityRead \u0026\u0026\n+    if (!isSingleEntityRead() \u0026\u0026\n         (entity.getCreatedTime() \u003c filters.getCreatedTimeBegin() ||\n         entity.getCreatedTime() \u003e filters.getCreatedTimeEnd())) {\n       return null;\n     }\n     EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n     // fetch is related to entities\n     boolean checkIsRelatedTo \u003d\n         filters !\u003d null \u0026\u0026 filters.getIsRelatedTo() !\u003d null \u0026\u0026\n         filters.getIsRelatedTo().size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n       readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n       if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n           entity.getIsRelatedToEntities(), filters.getIsRelatedTo())) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities\n     boolean checkRelatesTo \u003d\n         filters !\u003d null \u0026\u0026 filters.getRelatesTo() !\u003d null \u0026\u0026\n         filters.getRelatesTo().size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n       readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n       if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n           entity.getRelatesToEntities(), filters.getRelatesTo())) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info\n     boolean checkInfo \u003d filters !\u003d null \u0026\u0026 filters.getInfoFilters() !\u003d null \u0026\u0026\n         filters.getInfoFilters().size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n       if (checkInfo \u0026\u0026\n           !TimelineStorageUtils.matchFilters(\n           entity.getInfo(), filters.getInfoFilters())) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.INFO)) {\n         entity.getInfo().clear();\n       }\n     }\n \n     // fetch configs\n     boolean checkConfigs \u003d\n         filters !\u003d null \u0026\u0026 filters.getConfigFilters() !\u003d null \u0026\u0026\n         filters.getConfigFilters().size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n       if (checkConfigs \u0026\u0026 !TimelineStorageUtils.matchFilters(\n           entity.getConfigs(), filters.getConfigFilters())) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.CONFIGS)) {\n         entity.getConfigs().clear();\n       }\n     }\n \n     // fetch events\n     boolean checkEvents \u003d\n         filters !\u003d null \u0026\u0026 filters.getEventFilters() !\u003d null \u0026\u0026\n         filters.getEventFilters().size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n       readEvents(entity, result, false);\n       if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(\n           entity.getEvents(), filters.getEventFilters())) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics\n     boolean checkMetrics \u003d\n         filters !\u003d null \u0026\u0026 filters.getMetricFilters() !\u003d null \u0026\u0026\n         filters.getMetricFilters().size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n       readMetrics(entity, result, EntityColumnPrefix.METRIC);\n       if (checkMetrics \u0026\u0026 !TimelineStorageUtils.matchMetricFilters(\n           entity.getMetrics(), filters.getMetricFilters())) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.METRICS)) {\n         entity.getMetrics().clear();\n       }\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime.longValue());\n    if (!isSingleEntityRead() \u0026\u0026\n        (entity.getCreatedTime() \u003c filters.getCreatedTimeBegin() ||\n        entity.getCreatedTime() \u003e filters.getCreatedTimeEnd())) {\n      return null;\n    }\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities\n    boolean checkIsRelatedTo \u003d\n        filters !\u003d null \u0026\u0026 filters.getIsRelatedTo() !\u003d null \u0026\u0026\n        filters.getIsRelatedTo().size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n          entity.getIsRelatedToEntities(), filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities\n    boolean checkRelatesTo \u003d\n        filters !\u003d null \u0026\u0026 filters.getRelatesTo() !\u003d null \u0026\u0026\n        filters.getRelatesTo().size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n          entity.getRelatesToEntities(), filters.getRelatesTo())) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info\n    boolean checkInfo \u003d filters !\u003d null \u0026\u0026 filters.getInfoFilters() !\u003d null \u0026\u0026\n        filters.getInfoFilters().size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n      if (checkInfo \u0026\u0026\n          !TimelineStorageUtils.matchFilters(\n          entity.getInfo(), filters.getInfoFilters())) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.INFO)) {\n        entity.getInfo().clear();\n      }\n    }\n\n    // fetch configs\n    boolean checkConfigs \u003d\n        filters !\u003d null \u0026\u0026 filters.getConfigFilters() !\u003d null \u0026\u0026\n        filters.getConfigFilters().size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n      if (checkConfigs \u0026\u0026 !TimelineStorageUtils.matchFilters(\n          entity.getConfigs(), filters.getConfigFilters())) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n        entity.getConfigs().clear();\n      }\n    }\n\n    // fetch events\n    boolean checkEvents \u003d\n        filters !\u003d null \u0026\u0026 filters.getEventFilters() !\u003d null \u0026\u0026\n        filters.getEventFilters().size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, false);\n      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(\n          entity.getEvents(), filters.getEventFilters())) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics\n    boolean checkMetrics \u003d\n        filters !\u003d null \u0026\u0026 filters.getMetricFilters() !\u003d null \u0026\u0026\n        filters.getMetricFilters().size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n      if (checkMetrics \u0026\u0026 !TimelineStorageUtils.matchMetricFilters(\n          entity.getMetrics(), filters.getMetricFilters())) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.METRICS)) {\n        entity.getMetrics().clear();\n      }\n    }\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
      "extendedDetails": {}
    },
    "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4446. Refactor reader API for better extensibility (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "9cb1287e9b8425f91de925f411c3c2a8fa9fe2a3",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "9d40d9d34ce3b88e868ae91fcc09377107c094c7",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,109 +1,123 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n     String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n     entity.setType(entityType);\n     String entityId \u003d EntityColumn.ID.readResult(result).toString();\n     entity.setId(entityId);\n \n+    TimelineEntityFilters filters \u003d getFilters();\n     // fetch created time\n     Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n     entity.setCreatedTime(createdTime.longValue());\n-    if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n-        entity.getCreatedTime() \u003e createdTimeEnd)) {\n+    if (!singleEntityRead \u0026\u0026\n+        (entity.getCreatedTime() \u003c filters.getCreatedTimeBegin() ||\n+        entity.getCreatedTime() \u003e filters.getCreatedTimeEnd())) {\n       return null;\n     }\n-\n+    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n     // fetch is related to entities\n-    boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n+    boolean checkIsRelatedTo \u003d\n+        filters !\u003d null \u0026\u0026 filters.getIsRelatedTo() !\u003d null \u0026\u0026\n+        filters.getIsRelatedTo().size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n       readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n       if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n-          entity.getIsRelatedToEntities(), isRelatedTo)) {\n+          entity.getIsRelatedToEntities(), filters.getIsRelatedTo())) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities\n-    boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n+    boolean checkRelatesTo \u003d\n+        filters !\u003d null \u0026\u0026 filters.getRelatesTo() !\u003d null \u0026\u0026\n+        filters.getRelatesTo().size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n       readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n       if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n-          entity.getRelatesToEntities(), relatesTo)) {\n+          entity.getRelatesToEntities(), filters.getRelatesTo())) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info\n-    boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n+    boolean checkInfo \u003d filters !\u003d null \u0026\u0026 filters.getInfoFilters() !\u003d null \u0026\u0026\n+        filters.getInfoFilters().size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n       if (checkInfo \u0026\u0026\n-          !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n+          !TimelineStorageUtils.matchFilters(\n+          entity.getInfo(), filters.getInfoFilters())) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.INFO)) {\n         entity.getInfo().clear();\n       }\n     }\n \n     // fetch configs\n-    boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n+    boolean checkConfigs \u003d\n+        filters !\u003d null \u0026\u0026 filters.getConfigFilters() !\u003d null \u0026\u0026\n+        filters.getConfigFilters().size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n       if (checkConfigs \u0026\u0026 !TimelineStorageUtils.matchFilters(\n-          entity.getConfigs(), configFilters)) {\n+          entity.getConfigs(), filters.getConfigFilters())) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.CONFIGS)) {\n         entity.getConfigs().clear();\n       }\n     }\n \n     // fetch events\n-    boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n+    boolean checkEvents \u003d\n+        filters !\u003d null \u0026\u0026 filters.getEventFilters() !\u003d null \u0026\u0026\n+        filters.getEventFilters().size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n       readEvents(entity, result, false);\n       if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(\n-          entity.getEvents(), eventFilters)) {\n+          entity.getEvents(), filters.getEventFilters())) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics\n-    boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n+    boolean checkMetrics \u003d\n+        filters !\u003d null \u0026\u0026 filters.getMetricFilters() !\u003d null \u0026\u0026\n+        filters.getMetricFilters().size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n       readMetrics(entity, result, EntityColumnPrefix.METRIC);\n       if (checkMetrics \u0026\u0026 !TimelineStorageUtils.matchMetricFilters(\n-          entity.getMetrics(), metricFilters)) {\n+          entity.getMetrics(), filters.getMetricFilters())) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.METRICS)) {\n         entity.getMetrics().clear();\n       }\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    TimelineEntityFilters filters \u003d getFilters();\n    // fetch created time\n    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime.longValue());\n    if (!singleEntityRead \u0026\u0026\n        (entity.getCreatedTime() \u003c filters.getCreatedTimeBegin() ||\n        entity.getCreatedTime() \u003e filters.getCreatedTimeEnd())) {\n      return null;\n    }\n    EnumSet\u003cField\u003e fieldsToRetrieve \u003d getDataToRetrieve().getFieldsToRetrieve();\n    // fetch is related to entities\n    boolean checkIsRelatedTo \u003d\n        filters !\u003d null \u0026\u0026 filters.getIsRelatedTo() !\u003d null \u0026\u0026\n        filters.getIsRelatedTo().size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n          entity.getIsRelatedToEntities(), filters.getIsRelatedTo())) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities\n    boolean checkRelatesTo \u003d\n        filters !\u003d null \u0026\u0026 filters.getRelatesTo() !\u003d null \u0026\u0026\n        filters.getRelatesTo().size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n          entity.getRelatesToEntities(), filters.getRelatesTo())) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info\n    boolean checkInfo \u003d filters !\u003d null \u0026\u0026 filters.getInfoFilters() !\u003d null \u0026\u0026\n        filters.getInfoFilters().size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n      if (checkInfo \u0026\u0026\n          !TimelineStorageUtils.matchFilters(\n          entity.getInfo(), filters.getInfoFilters())) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.INFO)) {\n        entity.getInfo().clear();\n      }\n    }\n\n    // fetch configs\n    boolean checkConfigs \u003d\n        filters !\u003d null \u0026\u0026 filters.getConfigFilters() !\u003d null \u0026\u0026\n        filters.getConfigFilters().size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n      if (checkConfigs \u0026\u0026 !TimelineStorageUtils.matchFilters(\n          entity.getConfigs(), filters.getConfigFilters())) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n        entity.getConfigs().clear();\n      }\n    }\n\n    // fetch events\n    boolean checkEvents \u003d\n        filters !\u003d null \u0026\u0026 filters.getEventFilters() !\u003d null \u0026\u0026\n        filters.getEventFilters().size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, false);\n      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(\n          entity.getEvents(), filters.getEventFilters())) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics\n    boolean checkMetrics \u003d\n        filters !\u003d null \u0026\u0026 filters.getMetricFilters() !\u003d null \u0026\u0026\n        filters.getMetricFilters().size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n      if (checkMetrics \u0026\u0026 !TimelineStorageUtils.matchMetricFilters(\n          entity.getMetrics(), filters.getMetricFilters())) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.METRICS)) {\n        entity.getMetrics().clear();\n      }\n    }\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
      "extendedDetails": {}
    },
    "6934b05c7117a12286fb2ba7a47f75e227cacb22": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4238. createdTime and modifiedTime is not reported while publishing entities to ATSv2. (Varun Saxena via Naganarasimha G R)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "6934b05c7117a12286fb2ba7a47f75e227cacb22",
      "commitAuthor": "Naganarasimha",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "88f02941144824187b70fa2aaf0c6d90bcb77d8f",
      "commitAuthorOld": "Li Lu",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,109 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n     String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n     entity.setType(entityType);\n     String entityId \u003d EntityColumn.ID.readResult(result).toString();\n     entity.setId(entityId);\n \n     // fetch created time\n     Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n     entity.setCreatedTime(createdTime.longValue());\n     if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n         entity.getCreatedTime() \u003e createdTimeEnd)) {\n       return null;\n     }\n \n-    // fetch modified time\n-    Number modifiedTime \u003d (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n-    entity.setModifiedTime(modifiedTime.longValue());\n-    if (!singleEntityRead \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n-        entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n-      return null;\n-    }\n-\n     // fetch is related to entities\n     boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n       readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n       if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n           entity.getIsRelatedToEntities(), isRelatedTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities\n     boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n       readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n       if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n           entity.getRelatesToEntities(), relatesTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info\n     boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n       if (checkInfo \u0026\u0026\n           !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.INFO)) {\n         entity.getInfo().clear();\n       }\n     }\n \n     // fetch configs\n     boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n       if (checkConfigs \u0026\u0026 !TimelineStorageUtils.matchFilters(\n           entity.getConfigs(), configFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.CONFIGS)) {\n         entity.getConfigs().clear();\n       }\n     }\n \n     // fetch events\n     boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n       readEvents(entity, result, false);\n       if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(\n           entity.getEvents(), eventFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics\n     boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n       readMetrics(entity, result, EntityColumnPrefix.METRIC);\n       if (checkMetrics \u0026\u0026 !TimelineStorageUtils.matchMetricFilters(\n           entity.getMetrics(), metricFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.METRICS)) {\n         entity.getMetrics().clear();\n       }\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    // fetch created time\n    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n        entity.getCreatedTime() \u003e createdTimeEnd)) {\n      return null;\n    }\n\n    // fetch is related to entities\n    boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n          entity.getIsRelatedToEntities(), isRelatedTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities\n    boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n          entity.getRelatesToEntities(), relatesTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info\n    boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n      if (checkInfo \u0026\u0026\n          !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.INFO)) {\n        entity.getInfo().clear();\n      }\n    }\n\n    // fetch configs\n    boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n      if (checkConfigs \u0026\u0026 !TimelineStorageUtils.matchFilters(\n          entity.getConfigs(), configFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n        entity.getConfigs().clear();\n      }\n    }\n\n    // fetch events\n    boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, false);\n      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(\n          entity.getEvents(), eventFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics\n    boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n      if (checkMetrics \u0026\u0026 !TimelineStorageUtils.matchMetricFilters(\n          entity.getMetrics(), metricFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.METRICS)) {\n        entity.getMetrics().clear();\n      }\n    }\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
      "extendedDetails": {}
    },
    "88f02941144824187b70fa2aaf0c6d90bcb77d8f": {
      "type": "Yfilerename",
      "commitMessage": "YARN-4200. Refactor reader classes in storage to nest under hbase\nspecific package name. Contributed by Li Lu.\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "88f02941144824187b70fa2aaf0c6d90bcb77d8f",
      "commitAuthor": "Li Lu",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "cc16683cefe2611cf4de7819496aa54854f5394c",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    // fetch created time\n    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n        entity.getCreatedTime() \u003e createdTimeEnd)) {\n      return null;\n    }\n\n    // fetch modified time\n    Number modifiedTime \u003d (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n    entity.setModifiedTime(modifiedTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n        entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n      return null;\n    }\n\n    // fetch is related to entities\n    boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n          entity.getIsRelatedToEntities(), isRelatedTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities\n    boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n          entity.getRelatesToEntities(), relatesTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info\n    boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n      if (checkInfo \u0026\u0026\n          !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.INFO)) {\n        entity.getInfo().clear();\n      }\n    }\n\n    // fetch configs\n    boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n      if (checkConfigs \u0026\u0026 !TimelineStorageUtils.matchFilters(\n          entity.getConfigs(), configFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n        entity.getConfigs().clear();\n      }\n    }\n\n    // fetch events\n    boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, false);\n      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(\n          entity.getEvents(), eventFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics\n    boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n      if (checkMetrics \u0026\u0026 !TimelineStorageUtils.matchMetricFilters(\n          entity.getMetrics(), metricFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.METRICS)) {\n        entity.getMetrics().clear();\n      }\n    }\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/GenericEntityReader.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/reader/GenericEntityReader.java"
      }
    },
    "b51d0fef56a59b15489f5b932025718b4e9613d2": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4178. [storage implementation] app id as string in row keys can cause incorrect ordering (Varun Saxena via sjlee)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "b51d0fef56a59b15489f5b932025718b4e9613d2",
      "commitAuthor": "Sangjin Lee",
      "commitDateOld": "10/07/16 8:45 AM",
      "commitNameOld": "0f44b5508d2ffcae08f130b6535a9832d37e2b38",
      "commitAuthorOld": "Sangjin Lee",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,117 +1,117 @@\n   protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n     String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n     entity.setType(entityType);\n     String entityId \u003d EntityColumn.ID.readResult(result).toString();\n     entity.setId(entityId);\n \n     // fetch created time\n     Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n     entity.setCreatedTime(createdTime.longValue());\n     if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n         entity.getCreatedTime() \u003e createdTimeEnd)) {\n       return null;\n     }\n \n     // fetch modified time\n     Number modifiedTime \u003d (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n     entity.setModifiedTime(modifiedTime.longValue());\n     if (!singleEntityRead \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n         entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n       return null;\n     }\n \n     // fetch is related to entities\n     boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n       readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n-      if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n+      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n           entity.getIsRelatedToEntities(), isRelatedTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities\n     boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n       readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n-      if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n+      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n           entity.getRelatesToEntities(), relatesTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info\n     boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n       if (checkInfo \u0026\u0026\n-          !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n+          !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.INFO)) {\n         entity.getInfo().clear();\n       }\n     }\n \n     // fetch configs\n     boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n       readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n-      if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n+      if (checkConfigs \u0026\u0026 !TimelineStorageUtils.matchFilters(\n           entity.getConfigs(), configFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.CONFIGS)) {\n         entity.getConfigs().clear();\n       }\n     }\n \n     // fetch events\n     boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n       readEvents(entity, result, false);\n-      if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n+      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(\n           entity.getEvents(), eventFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics\n     boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n       readMetrics(entity, result, EntityColumnPrefix.METRIC);\n-      if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n+      if (checkMetrics \u0026\u0026 !TimelineStorageUtils.matchMetricFilters(\n           entity.getMetrics(), metricFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.METRICS)) {\n         entity.getMetrics().clear();\n       }\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    // fetch created time\n    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n        entity.getCreatedTime() \u003e createdTimeEnd)) {\n      return null;\n    }\n\n    // fetch modified time\n    Number modifiedTime \u003d (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n    entity.setModifiedTime(modifiedTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n        entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n      return null;\n    }\n\n    // fetch is related to entities\n    boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n          entity.getIsRelatedToEntities(), isRelatedTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities\n    boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo \u0026\u0026 !TimelineStorageUtils.matchRelations(\n          entity.getRelatesToEntities(), relatesTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info\n    boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n      if (checkInfo \u0026\u0026\n          !TimelineStorageUtils.matchFilters(entity.getInfo(), infoFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.INFO)) {\n        entity.getInfo().clear();\n      }\n    }\n\n    // fetch configs\n    boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n      if (checkConfigs \u0026\u0026 !TimelineStorageUtils.matchFilters(\n          entity.getConfigs(), configFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n        entity.getConfigs().clear();\n      }\n    }\n\n    // fetch events\n    boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, false);\n      if (checkEvents \u0026\u0026 !TimelineStorageUtils.matchEventFilters(\n          entity.getEvents(), eventFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics\n    boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n      if (checkMetrics \u0026\u0026 !TimelineStorageUtils.matchMetricFilters(\n          entity.getMetrics(), metricFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.METRICS)) {\n        entity.getMetrics().clear();\n      }\n    }\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/GenericEntityReader.java",
      "extendedDetails": {}
    },
    "10fa6da7d8a6013698767c6136ae20f0e04415e9": {
      "type": "Ymultichange(Ymovefromfile,Ymodifierchange,Ybodychange,Yparameterchange)",
      "commitMessage": "YARN-4074. [timeline reader] implement support for querying for flows and flow runs (sjlee via vrushali)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "10fa6da7d8a6013698767c6136ae20f0e04415e9",
      "commitAuthor": "Vrushali",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-4074. [timeline reader] implement support for querying for flows and flow runs (sjlee via vrushali)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "10fa6da7d8a6013698767c6136ae20f0e04415e9",
          "commitAuthor": "Vrushali",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "a68e3839218523403f42acd7bdd7ce1da59a5e60",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,152 +1,117 @@\n-  private static TimelineEntity parseEntity(\n-      Result result, EnumSet\u003cField\u003e fieldsToRetrieve,\n-      boolean checkCreatedTime, long createdTimeBegin, long createdTimeEnd,\n-      boolean checkModifiedTime, long modifiedTimeBegin, long modifiedTimeEnd,\n-      Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo, Map\u003cString, Set\u003cString\u003e\u003e relatesTo,\n-      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n-      Set\u003cString\u003e eventFilters, Set\u003cString\u003e metricFilters,\n-      boolean isApplication)\n-          throws IOException {\n+  protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n-    String entityType \u003d isApplication ?\n-        TimelineEntityType.YARN_APPLICATION.toString() :\n-        EntityColumn.TYPE.readResult(result).toString();\n+    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n     entity.setType(entityType);\n-    String entityId \u003d isApplication ?\n-        ApplicationColumn.ID.readResult(result).toString() :\n-        EntityColumn.ID.readResult(result).toString();\n+    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n     entity.setId(entityId);\n \n     // fetch created time\n-    Number createdTime \u003d isApplication ?\n-        (Number)ApplicationColumn.CREATED_TIME.readResult(result) :\n-        (Number)EntityColumn.CREATED_TIME.readResult(result);\n+    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n     entity.setCreatedTime(createdTime.longValue());\n-    if (checkCreatedTime \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n+    if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n         entity.getCreatedTime() \u003e createdTimeEnd)) {\n       return null;\n     }\n \n     // fetch modified time\n-    Number modifiedTime \u003d isApplication ?\n-        (Number)ApplicationColumn.MODIFIED_TIME.readResult(result) :\n-        (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n+    Number modifiedTime \u003d (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n     entity.setModifiedTime(modifiedTime.longValue());\n-    if (checkModifiedTime \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n+    if (!singleEntityRead \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n         entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n       return null;\n     }\n \n     // fetch is related to entities\n     boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n-      if (isApplication) {\n-        readRelationship(entity, result, ApplicationColumnPrefix.IS_RELATED_TO,\n-            true);\n-      } else {\n-        readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO,\n-            true);\n-      }\n+      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n       if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n           entity.getIsRelatedToEntities(), isRelatedTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities\n     boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n-      if (isApplication) {\n-        readRelationship(entity, result, ApplicationColumnPrefix.RELATES_TO,\n-            false);\n-      } else {\n-        readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n-      }\n+      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n       if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n           entity.getRelatesToEntities(), relatesTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info\n     boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n-      if (isApplication) {\n-        readKeyValuePairs(entity, result, ApplicationColumnPrefix.INFO, false);\n-      } else {\n-        readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n-      }\n+      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n       if (checkInfo \u0026\u0026\n           !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.INFO)) {\n         entity.getInfo().clear();\n       }\n     }\n \n     // fetch configs\n     boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n-      if (isApplication) {\n-        readKeyValuePairs(entity, result, ApplicationColumnPrefix.CONFIG, true);\n-      } else {\n-        readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n-      }\n+      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n       if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n           entity.getConfigs(), configFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.CONFIGS)) {\n         entity.getConfigs().clear();\n       }\n     }\n \n     // fetch events\n     boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n-      readEvents(entity, result, isApplication);\n+      readEvents(entity, result, false);\n       if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n           entity.getEvents(), eventFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics\n     boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n-      readMetrics(entity, result, isApplication);\n+      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n       if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n           entity.getMetrics(), metricFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.METRICS)) {\n         entity.getMetrics().clear();\n       }\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    // fetch created time\n    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n        entity.getCreatedTime() \u003e createdTimeEnd)) {\n      return null;\n    }\n\n    // fetch modified time\n    Number modifiedTime \u003d (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n    entity.setModifiedTime(modifiedTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n        entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n      return null;\n    }\n\n    // fetch is related to entities\n    boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getIsRelatedToEntities(), isRelatedTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities\n    boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getRelatesToEntities(), relatesTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info\n    boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n      if (checkInfo \u0026\u0026\n          !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.INFO)) {\n        entity.getInfo().clear();\n      }\n    }\n\n    // fetch configs\n    boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n      if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n          entity.getConfigs(), configFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n        entity.getConfigs().clear();\n      }\n    }\n\n    // fetch events\n    boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, false);\n      if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n          entity.getEvents(), eventFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics\n    boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n      if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n          entity.getMetrics(), metricFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.METRICS)) {\n        entity.getMetrics().clear();\n      }\n    }\n    return entity;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/GenericEntityReader.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/HBaseTimelineReaderImpl.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/GenericEntityReader.java",
            "oldMethodName": "parseEntity",
            "newMethodName": "parseEntity"
          }
        },
        {
          "type": "Ymodifierchange",
          "commitMessage": "YARN-4074. [timeline reader] implement support for querying for flows and flow runs (sjlee via vrushali)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "10fa6da7d8a6013698767c6136ae20f0e04415e9",
          "commitAuthor": "Vrushali",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "a68e3839218523403f42acd7bdd7ce1da59a5e60",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,152 +1,117 @@\n-  private static TimelineEntity parseEntity(\n-      Result result, EnumSet\u003cField\u003e fieldsToRetrieve,\n-      boolean checkCreatedTime, long createdTimeBegin, long createdTimeEnd,\n-      boolean checkModifiedTime, long modifiedTimeBegin, long modifiedTimeEnd,\n-      Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo, Map\u003cString, Set\u003cString\u003e\u003e relatesTo,\n-      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n-      Set\u003cString\u003e eventFilters, Set\u003cString\u003e metricFilters,\n-      boolean isApplication)\n-          throws IOException {\n+  protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n-    String entityType \u003d isApplication ?\n-        TimelineEntityType.YARN_APPLICATION.toString() :\n-        EntityColumn.TYPE.readResult(result).toString();\n+    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n     entity.setType(entityType);\n-    String entityId \u003d isApplication ?\n-        ApplicationColumn.ID.readResult(result).toString() :\n-        EntityColumn.ID.readResult(result).toString();\n+    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n     entity.setId(entityId);\n \n     // fetch created time\n-    Number createdTime \u003d isApplication ?\n-        (Number)ApplicationColumn.CREATED_TIME.readResult(result) :\n-        (Number)EntityColumn.CREATED_TIME.readResult(result);\n+    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n     entity.setCreatedTime(createdTime.longValue());\n-    if (checkCreatedTime \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n+    if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n         entity.getCreatedTime() \u003e createdTimeEnd)) {\n       return null;\n     }\n \n     // fetch modified time\n-    Number modifiedTime \u003d isApplication ?\n-        (Number)ApplicationColumn.MODIFIED_TIME.readResult(result) :\n-        (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n+    Number modifiedTime \u003d (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n     entity.setModifiedTime(modifiedTime.longValue());\n-    if (checkModifiedTime \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n+    if (!singleEntityRead \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n         entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n       return null;\n     }\n \n     // fetch is related to entities\n     boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n-      if (isApplication) {\n-        readRelationship(entity, result, ApplicationColumnPrefix.IS_RELATED_TO,\n-            true);\n-      } else {\n-        readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO,\n-            true);\n-      }\n+      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n       if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n           entity.getIsRelatedToEntities(), isRelatedTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities\n     boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n-      if (isApplication) {\n-        readRelationship(entity, result, ApplicationColumnPrefix.RELATES_TO,\n-            false);\n-      } else {\n-        readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n-      }\n+      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n       if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n           entity.getRelatesToEntities(), relatesTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info\n     boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n-      if (isApplication) {\n-        readKeyValuePairs(entity, result, ApplicationColumnPrefix.INFO, false);\n-      } else {\n-        readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n-      }\n+      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n       if (checkInfo \u0026\u0026\n           !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.INFO)) {\n         entity.getInfo().clear();\n       }\n     }\n \n     // fetch configs\n     boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n-      if (isApplication) {\n-        readKeyValuePairs(entity, result, ApplicationColumnPrefix.CONFIG, true);\n-      } else {\n-        readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n-      }\n+      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n       if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n           entity.getConfigs(), configFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.CONFIGS)) {\n         entity.getConfigs().clear();\n       }\n     }\n \n     // fetch events\n     boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n-      readEvents(entity, result, isApplication);\n+      readEvents(entity, result, false);\n       if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n           entity.getEvents(), eventFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics\n     boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n-      readMetrics(entity, result, isApplication);\n+      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n       if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n           entity.getMetrics(), metricFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.METRICS)) {\n         entity.getMetrics().clear();\n       }\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    // fetch created time\n    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n        entity.getCreatedTime() \u003e createdTimeEnd)) {\n      return null;\n    }\n\n    // fetch modified time\n    Number modifiedTime \u003d (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n    entity.setModifiedTime(modifiedTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n        entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n      return null;\n    }\n\n    // fetch is related to entities\n    boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getIsRelatedToEntities(), isRelatedTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities\n    boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getRelatesToEntities(), relatesTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info\n    boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n      if (checkInfo \u0026\u0026\n          !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.INFO)) {\n        entity.getInfo().clear();\n      }\n    }\n\n    // fetch configs\n    boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n      if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n          entity.getConfigs(), configFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n        entity.getConfigs().clear();\n      }\n    }\n\n    // fetch events\n    boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, false);\n      if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n          entity.getEvents(), eventFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics\n    boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n      if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n          entity.getMetrics(), metricFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.METRICS)) {\n        entity.getMetrics().clear();\n      }\n    }\n    return entity;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/GenericEntityReader.java",
          "extendedDetails": {
            "oldValue": "[private, static]",
            "newValue": "[protected]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4074. [timeline reader] implement support for querying for flows and flow runs (sjlee via vrushali)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "10fa6da7d8a6013698767c6136ae20f0e04415e9",
          "commitAuthor": "Vrushali",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "a68e3839218523403f42acd7bdd7ce1da59a5e60",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,152 +1,117 @@\n-  private static TimelineEntity parseEntity(\n-      Result result, EnumSet\u003cField\u003e fieldsToRetrieve,\n-      boolean checkCreatedTime, long createdTimeBegin, long createdTimeEnd,\n-      boolean checkModifiedTime, long modifiedTimeBegin, long modifiedTimeEnd,\n-      Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo, Map\u003cString, Set\u003cString\u003e\u003e relatesTo,\n-      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n-      Set\u003cString\u003e eventFilters, Set\u003cString\u003e metricFilters,\n-      boolean isApplication)\n-          throws IOException {\n+  protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n-    String entityType \u003d isApplication ?\n-        TimelineEntityType.YARN_APPLICATION.toString() :\n-        EntityColumn.TYPE.readResult(result).toString();\n+    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n     entity.setType(entityType);\n-    String entityId \u003d isApplication ?\n-        ApplicationColumn.ID.readResult(result).toString() :\n-        EntityColumn.ID.readResult(result).toString();\n+    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n     entity.setId(entityId);\n \n     // fetch created time\n-    Number createdTime \u003d isApplication ?\n-        (Number)ApplicationColumn.CREATED_TIME.readResult(result) :\n-        (Number)EntityColumn.CREATED_TIME.readResult(result);\n+    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n     entity.setCreatedTime(createdTime.longValue());\n-    if (checkCreatedTime \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n+    if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n         entity.getCreatedTime() \u003e createdTimeEnd)) {\n       return null;\n     }\n \n     // fetch modified time\n-    Number modifiedTime \u003d isApplication ?\n-        (Number)ApplicationColumn.MODIFIED_TIME.readResult(result) :\n-        (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n+    Number modifiedTime \u003d (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n     entity.setModifiedTime(modifiedTime.longValue());\n-    if (checkModifiedTime \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n+    if (!singleEntityRead \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n         entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n       return null;\n     }\n \n     // fetch is related to entities\n     boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n-      if (isApplication) {\n-        readRelationship(entity, result, ApplicationColumnPrefix.IS_RELATED_TO,\n-            true);\n-      } else {\n-        readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO,\n-            true);\n-      }\n+      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n       if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n           entity.getIsRelatedToEntities(), isRelatedTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities\n     boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n-      if (isApplication) {\n-        readRelationship(entity, result, ApplicationColumnPrefix.RELATES_TO,\n-            false);\n-      } else {\n-        readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n-      }\n+      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n       if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n           entity.getRelatesToEntities(), relatesTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info\n     boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n-      if (isApplication) {\n-        readKeyValuePairs(entity, result, ApplicationColumnPrefix.INFO, false);\n-      } else {\n-        readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n-      }\n+      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n       if (checkInfo \u0026\u0026\n           !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.INFO)) {\n         entity.getInfo().clear();\n       }\n     }\n \n     // fetch configs\n     boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n-      if (isApplication) {\n-        readKeyValuePairs(entity, result, ApplicationColumnPrefix.CONFIG, true);\n-      } else {\n-        readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n-      }\n+      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n       if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n           entity.getConfigs(), configFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.CONFIGS)) {\n         entity.getConfigs().clear();\n       }\n     }\n \n     // fetch events\n     boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n-      readEvents(entity, result, isApplication);\n+      readEvents(entity, result, false);\n       if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n           entity.getEvents(), eventFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics\n     boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n-      readMetrics(entity, result, isApplication);\n+      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n       if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n           entity.getMetrics(), metricFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.METRICS)) {\n         entity.getMetrics().clear();\n       }\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    // fetch created time\n    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n        entity.getCreatedTime() \u003e createdTimeEnd)) {\n      return null;\n    }\n\n    // fetch modified time\n    Number modifiedTime \u003d (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n    entity.setModifiedTime(modifiedTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n        entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n      return null;\n    }\n\n    // fetch is related to entities\n    boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getIsRelatedToEntities(), isRelatedTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities\n    boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getRelatesToEntities(), relatesTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info\n    boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n      if (checkInfo \u0026\u0026\n          !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.INFO)) {\n        entity.getInfo().clear();\n      }\n    }\n\n    // fetch configs\n    boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n      if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n          entity.getConfigs(), configFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n        entity.getConfigs().clear();\n      }\n    }\n\n    // fetch events\n    boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, false);\n      if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n          entity.getEvents(), eventFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics\n    boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n      if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n          entity.getMetrics(), metricFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.METRICS)) {\n        entity.getMetrics().clear();\n      }\n    }\n    return entity;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/GenericEntityReader.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4074. [timeline reader] implement support for querying for flows and flow runs (sjlee via vrushali)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "10fa6da7d8a6013698767c6136ae20f0e04415e9",
          "commitAuthor": "Vrushali",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "a68e3839218523403f42acd7bdd7ce1da59a5e60",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,152 +1,117 @@\n-  private static TimelineEntity parseEntity(\n-      Result result, EnumSet\u003cField\u003e fieldsToRetrieve,\n-      boolean checkCreatedTime, long createdTimeBegin, long createdTimeEnd,\n-      boolean checkModifiedTime, long modifiedTimeBegin, long modifiedTimeEnd,\n-      Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo, Map\u003cString, Set\u003cString\u003e\u003e relatesTo,\n-      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n-      Set\u003cString\u003e eventFilters, Set\u003cString\u003e metricFilters,\n-      boolean isApplication)\n-          throws IOException {\n+  protected TimelineEntity parseEntity(Result result) throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n-    String entityType \u003d isApplication ?\n-        TimelineEntityType.YARN_APPLICATION.toString() :\n-        EntityColumn.TYPE.readResult(result).toString();\n+    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n     entity.setType(entityType);\n-    String entityId \u003d isApplication ?\n-        ApplicationColumn.ID.readResult(result).toString() :\n-        EntityColumn.ID.readResult(result).toString();\n+    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n     entity.setId(entityId);\n \n     // fetch created time\n-    Number createdTime \u003d isApplication ?\n-        (Number)ApplicationColumn.CREATED_TIME.readResult(result) :\n-        (Number)EntityColumn.CREATED_TIME.readResult(result);\n+    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n     entity.setCreatedTime(createdTime.longValue());\n-    if (checkCreatedTime \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n+    if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n         entity.getCreatedTime() \u003e createdTimeEnd)) {\n       return null;\n     }\n \n     // fetch modified time\n-    Number modifiedTime \u003d isApplication ?\n-        (Number)ApplicationColumn.MODIFIED_TIME.readResult(result) :\n-        (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n+    Number modifiedTime \u003d (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n     entity.setModifiedTime(modifiedTime.longValue());\n-    if (checkModifiedTime \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n+    if (!singleEntityRead \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n         entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n       return null;\n     }\n \n     // fetch is related to entities\n     boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n-      if (isApplication) {\n-        readRelationship(entity, result, ApplicationColumnPrefix.IS_RELATED_TO,\n-            true);\n-      } else {\n-        readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO,\n-            true);\n-      }\n+      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n       if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n           entity.getIsRelatedToEntities(), isRelatedTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities\n     boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n-      if (isApplication) {\n-        readRelationship(entity, result, ApplicationColumnPrefix.RELATES_TO,\n-            false);\n-      } else {\n-        readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n-      }\n+      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n       if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n           entity.getRelatesToEntities(), relatesTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info\n     boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n-      if (isApplication) {\n-        readKeyValuePairs(entity, result, ApplicationColumnPrefix.INFO, false);\n-      } else {\n-        readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n-      }\n+      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n       if (checkInfo \u0026\u0026\n           !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.INFO)) {\n         entity.getInfo().clear();\n       }\n     }\n \n     // fetch configs\n     boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n-      if (isApplication) {\n-        readKeyValuePairs(entity, result, ApplicationColumnPrefix.CONFIG, true);\n-      } else {\n-        readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n-      }\n+      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n       if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n           entity.getConfigs(), configFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.CONFIGS)) {\n         entity.getConfigs().clear();\n       }\n     }\n \n     // fetch events\n     boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n-      readEvents(entity, result, isApplication);\n+      readEvents(entity, result, false);\n       if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n           entity.getEvents(), eventFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics\n     boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n-      readMetrics(entity, result, isApplication);\n+      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n       if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n           entity.getMetrics(), metricFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.METRICS)) {\n         entity.getMetrics().clear();\n       }\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  protected TimelineEntity parseEntity(Result result) throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    // fetch created time\n    Number createdTime \u003d (Number)EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n        entity.getCreatedTime() \u003e createdTimeEnd)) {\n      return null;\n    }\n\n    // fetch modified time\n    Number modifiedTime \u003d (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n    entity.setModifiedTime(modifiedTime.longValue());\n    if (!singleEntityRead \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n        entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n      return null;\n    }\n\n    // fetch is related to entities\n    boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO, true);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getIsRelatedToEntities(), isRelatedTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities\n    boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getRelatesToEntities(), relatesTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info\n    boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n      if (checkInfo \u0026\u0026\n          !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.INFO)) {\n        entity.getInfo().clear();\n      }\n    }\n\n    // fetch configs\n    boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n      if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n          entity.getConfigs(), configFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n        entity.getConfigs().clear();\n      }\n    }\n\n    // fetch events\n    boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, false);\n      if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n          entity.getEvents(), eventFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics\n    boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n      readMetrics(entity, result, EntityColumnPrefix.METRIC);\n      if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n          entity.getMetrics(), metricFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.METRICS)) {\n        entity.getMetrics().clear();\n      }\n    }\n    return entity;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/GenericEntityReader.java",
          "extendedDetails": {
            "oldValue": "[result-Result, fieldsToRetrieve-EnumSet\u003cField\u003e, checkCreatedTime-boolean, createdTimeBegin-long, createdTimeEnd-long, checkModifiedTime-boolean, modifiedTimeBegin-long, modifiedTimeEnd-long, isRelatedTo-Map\u003cString,Set\u003cString\u003e\u003e, relatesTo-Map\u003cString,Set\u003cString\u003e\u003e, infoFilters-Map\u003cString,Object\u003e, configFilters-Map\u003cString,String\u003e, eventFilters-Set\u003cString\u003e, metricFilters-Set\u003cString\u003e, isApplication-boolean]",
            "newValue": "[result-Result]"
          }
        }
      ]
    },
    "00e85e7a2b9446dc37265feba07473b156d66367": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-3906. Split the application table from the entity table. Contributed by Sangjin Lee.\n\n(cherry picked from commit bcd755eba9466ce277d3c14192c31da6462c4ab3)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "00e85e7a2b9446dc37265feba07473b156d66367",
      "commitAuthor": "Junping Du",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-3906. Split the application table from the entity table. Contributed by Sangjin Lee.\n\n(cherry picked from commit bcd755eba9466ce277d3c14192c31da6462c4ab3)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "00e85e7a2b9446dc37265feba07473b156d66367",
          "commitAuthor": "Junping Du",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "9e5155be363c6610ccf41fe08b7f1394f353ea65",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,122 +1,152 @@\n   private static TimelineEntity parseEntity(\n       Result result, EnumSet\u003cField\u003e fieldsToRetrieve,\n       boolean checkCreatedTime, long createdTimeBegin, long createdTimeEnd,\n       boolean checkModifiedTime, long modifiedTimeBegin, long modifiedTimeEnd,\n       Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo, Map\u003cString, Set\u003cString\u003e\u003e relatesTo,\n       Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n-      Set\u003cString\u003e eventFilters, Set\u003cString\u003e metricFilters)\n+      Set\u003cString\u003e eventFilters, Set\u003cString\u003e metricFilters,\n+      boolean isApplication)\n           throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n-    entity.setType(EntityColumn.TYPE.readResult(result).toString());\n-    entity.setId(EntityColumn.ID.readResult(result).toString());\n+    String entityType \u003d isApplication ?\n+        TimelineEntityType.YARN_APPLICATION.toString() :\n+        EntityColumn.TYPE.readResult(result).toString();\n+    entity.setType(entityType);\n+    String entityId \u003d isApplication ?\n+        ApplicationColumn.ID.readResult(result).toString() :\n+        EntityColumn.ID.readResult(result).toString();\n+    entity.setId(entityId);\n \n     // fetch created time\n-    entity.setCreatedTime(\n-        ((Number) EntityColumn.CREATED_TIME.readResult(result)).longValue());\n+    Number createdTime \u003d isApplication ?\n+        (Number)ApplicationColumn.CREATED_TIME.readResult(result) :\n+        (Number)EntityColumn.CREATED_TIME.readResult(result);\n+    entity.setCreatedTime(createdTime.longValue());\n     if (checkCreatedTime \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n         entity.getCreatedTime() \u003e createdTimeEnd)) {\n       return null;\n     }\n \n     // fetch modified time\n-    entity.setCreatedTime(\n-        ((Number) EntityColumn.MODIFIED_TIME.readResult(result)).longValue());\n+    Number modifiedTime \u003d isApplication ?\n+        (Number)ApplicationColumn.MODIFIED_TIME.readResult(result) :\n+        (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n+    entity.setModifiedTime(modifiedTime.longValue());\n     if (checkModifiedTime \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n         entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n       return null;\n     }\n \n     // fetch is related to entities\n     boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n-      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO);\n+      if (isApplication) {\n+        readRelationship(entity, result, ApplicationColumnPrefix.IS_RELATED_TO,\n+            true);\n+      } else {\n+        readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO,\n+            true);\n+      }\n       if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n           entity.getIsRelatedToEntities(), isRelatedTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities\n     boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n-      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO);\n+      if (isApplication) {\n+        readRelationship(entity, result, ApplicationColumnPrefix.RELATES_TO,\n+            false);\n+      } else {\n+        readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n+      }\n       if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n           entity.getRelatesToEntities(), relatesTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info\n     boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n-      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO);\n+      if (isApplication) {\n+        readKeyValuePairs(entity, result, ApplicationColumnPrefix.INFO, false);\n+      } else {\n+        readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n+      }\n       if (checkInfo \u0026\u0026\n           !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.INFO)) {\n         entity.getInfo().clear();\n       }\n     }\n \n     // fetch configs\n     boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n-      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG);\n+      if (isApplication) {\n+        readKeyValuePairs(entity, result, ApplicationColumnPrefix.CONFIG, true);\n+      } else {\n+        readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n+      }\n       if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n           entity.getConfigs(), configFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.CONFIGS)) {\n         entity.getConfigs().clear();\n       }\n     }\n \n     // fetch events\n     boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n-      readEvents(entity, result);\n+      readEvents(entity, result, isApplication);\n       if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n           entity.getEvents(), eventFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics\n     boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n-      readMetrics(entity, result);\n+      readMetrics(entity, result, isApplication);\n       if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n           entity.getMetrics(), metricFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.METRICS)) {\n         entity.getMetrics().clear();\n       }\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static TimelineEntity parseEntity(\n      Result result, EnumSet\u003cField\u003e fieldsToRetrieve,\n      boolean checkCreatedTime, long createdTimeBegin, long createdTimeEnd,\n      boolean checkModifiedTime, long modifiedTimeBegin, long modifiedTimeEnd,\n      Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo, Map\u003cString, Set\u003cString\u003e\u003e relatesTo,\n      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n      Set\u003cString\u003e eventFilters, Set\u003cString\u003e metricFilters,\n      boolean isApplication)\n          throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d isApplication ?\n        TimelineEntityType.YARN_APPLICATION.toString() :\n        EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d isApplication ?\n        ApplicationColumn.ID.readResult(result).toString() :\n        EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    // fetch created time\n    Number createdTime \u003d isApplication ?\n        (Number)ApplicationColumn.CREATED_TIME.readResult(result) :\n        (Number)EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime.longValue());\n    if (checkCreatedTime \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n        entity.getCreatedTime() \u003e createdTimeEnd)) {\n      return null;\n    }\n\n    // fetch modified time\n    Number modifiedTime \u003d isApplication ?\n        (Number)ApplicationColumn.MODIFIED_TIME.readResult(result) :\n        (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n    entity.setModifiedTime(modifiedTime.longValue());\n    if (checkModifiedTime \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n        entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n      return null;\n    }\n\n    // fetch is related to entities\n    boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      if (isApplication) {\n        readRelationship(entity, result, ApplicationColumnPrefix.IS_RELATED_TO,\n            true);\n      } else {\n        readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO,\n            true);\n      }\n      if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getIsRelatedToEntities(), isRelatedTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities\n    boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n      if (isApplication) {\n        readRelationship(entity, result, ApplicationColumnPrefix.RELATES_TO,\n            false);\n      } else {\n        readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      }\n      if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getRelatesToEntities(), relatesTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info\n    boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n      if (isApplication) {\n        readKeyValuePairs(entity, result, ApplicationColumnPrefix.INFO, false);\n      } else {\n        readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n      }\n      if (checkInfo \u0026\u0026\n          !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.INFO)) {\n        entity.getInfo().clear();\n      }\n    }\n\n    // fetch configs\n    boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n      if (isApplication) {\n        readKeyValuePairs(entity, result, ApplicationColumnPrefix.CONFIG, true);\n      } else {\n        readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n      }\n      if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n          entity.getConfigs(), configFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n        entity.getConfigs().clear();\n      }\n    }\n\n    // fetch events\n    boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, isApplication);\n      if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n          entity.getEvents(), eventFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics\n    boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n      readMetrics(entity, result, isApplication);\n      if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n          entity.getMetrics(), metricFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.METRICS)) {\n        entity.getMetrics().clear();\n      }\n    }\n    return entity;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/HBaseTimelineReaderImpl.java",
          "extendedDetails": {
            "oldValue": "[result-Result, fieldsToRetrieve-EnumSet\u003cField\u003e, checkCreatedTime-boolean, createdTimeBegin-long, createdTimeEnd-long, checkModifiedTime-boolean, modifiedTimeBegin-long, modifiedTimeEnd-long, isRelatedTo-Map\u003cString,Set\u003cString\u003e\u003e, relatesTo-Map\u003cString,Set\u003cString\u003e\u003e, infoFilters-Map\u003cString,Object\u003e, configFilters-Map\u003cString,String\u003e, eventFilters-Set\u003cString\u003e, metricFilters-Set\u003cString\u003e]",
            "newValue": "[result-Result, fieldsToRetrieve-EnumSet\u003cField\u003e, checkCreatedTime-boolean, createdTimeBegin-long, createdTimeEnd-long, checkModifiedTime-boolean, modifiedTimeBegin-long, modifiedTimeEnd-long, isRelatedTo-Map\u003cString,Set\u003cString\u003e\u003e, relatesTo-Map\u003cString,Set\u003cString\u003e\u003e, infoFilters-Map\u003cString,Object\u003e, configFilters-Map\u003cString,String\u003e, eventFilters-Set\u003cString\u003e, metricFilters-Set\u003cString\u003e, isApplication-boolean]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-3906. Split the application table from the entity table. Contributed by Sangjin Lee.\n\n(cherry picked from commit bcd755eba9466ce277d3c14192c31da6462c4ab3)\n",
          "commitDate": "10/07/16 8:45 AM",
          "commitName": "00e85e7a2b9446dc37265feba07473b156d66367",
          "commitAuthor": "Junping Du",
          "commitDateOld": "10/07/16 8:45 AM",
          "commitNameOld": "9e5155be363c6610ccf41fe08b7f1394f353ea65",
          "commitAuthorOld": "Sangjin Lee",
          "daysBetweenCommits": 0.0,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,122 +1,152 @@\n   private static TimelineEntity parseEntity(\n       Result result, EnumSet\u003cField\u003e fieldsToRetrieve,\n       boolean checkCreatedTime, long createdTimeBegin, long createdTimeEnd,\n       boolean checkModifiedTime, long modifiedTimeBegin, long modifiedTimeEnd,\n       Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo, Map\u003cString, Set\u003cString\u003e\u003e relatesTo,\n       Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n-      Set\u003cString\u003e eventFilters, Set\u003cString\u003e metricFilters)\n+      Set\u003cString\u003e eventFilters, Set\u003cString\u003e metricFilters,\n+      boolean isApplication)\n           throws IOException {\n     if (result \u003d\u003d null || result.isEmpty()) {\n       return null;\n     }\n     TimelineEntity entity \u003d new TimelineEntity();\n-    entity.setType(EntityColumn.TYPE.readResult(result).toString());\n-    entity.setId(EntityColumn.ID.readResult(result).toString());\n+    String entityType \u003d isApplication ?\n+        TimelineEntityType.YARN_APPLICATION.toString() :\n+        EntityColumn.TYPE.readResult(result).toString();\n+    entity.setType(entityType);\n+    String entityId \u003d isApplication ?\n+        ApplicationColumn.ID.readResult(result).toString() :\n+        EntityColumn.ID.readResult(result).toString();\n+    entity.setId(entityId);\n \n     // fetch created time\n-    entity.setCreatedTime(\n-        ((Number) EntityColumn.CREATED_TIME.readResult(result)).longValue());\n+    Number createdTime \u003d isApplication ?\n+        (Number)ApplicationColumn.CREATED_TIME.readResult(result) :\n+        (Number)EntityColumn.CREATED_TIME.readResult(result);\n+    entity.setCreatedTime(createdTime.longValue());\n     if (checkCreatedTime \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n         entity.getCreatedTime() \u003e createdTimeEnd)) {\n       return null;\n     }\n \n     // fetch modified time\n-    entity.setCreatedTime(\n-        ((Number) EntityColumn.MODIFIED_TIME.readResult(result)).longValue());\n+    Number modifiedTime \u003d isApplication ?\n+        (Number)ApplicationColumn.MODIFIED_TIME.readResult(result) :\n+        (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n+    entity.setModifiedTime(modifiedTime.longValue());\n     if (checkModifiedTime \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n         entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n       return null;\n     }\n \n     // fetch is related to entities\n     boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n-      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO);\n+      if (isApplication) {\n+        readRelationship(entity, result, ApplicationColumnPrefix.IS_RELATED_TO,\n+            true);\n+      } else {\n+        readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO,\n+            true);\n+      }\n       if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n           entity.getIsRelatedToEntities(), isRelatedTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n         entity.getIsRelatedToEntities().clear();\n       }\n     }\n \n     // fetch relates to entities\n     boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n-      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO);\n+      if (isApplication) {\n+        readRelationship(entity, result, ApplicationColumnPrefix.RELATES_TO,\n+            false);\n+      } else {\n+        readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n+      }\n       if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n           entity.getRelatesToEntities(), relatesTo)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n         entity.getRelatesToEntities().clear();\n       }\n     }\n \n     // fetch info\n     boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n-      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO);\n+      if (isApplication) {\n+        readKeyValuePairs(entity, result, ApplicationColumnPrefix.INFO, false);\n+      } else {\n+        readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n+      }\n       if (checkInfo \u0026\u0026\n           !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.INFO)) {\n         entity.getInfo().clear();\n       }\n     }\n \n     // fetch configs\n     boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n-      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG);\n+      if (isApplication) {\n+        readKeyValuePairs(entity, result, ApplicationColumnPrefix.CONFIG, true);\n+      } else {\n+        readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n+      }\n       if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n           entity.getConfigs(), configFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.CONFIGS)) {\n         entity.getConfigs().clear();\n       }\n     }\n \n     // fetch events\n     boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n-      readEvents(entity, result);\n+      readEvents(entity, result, isApplication);\n       if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n           entity.getEvents(), eventFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.EVENTS)) {\n         entity.getEvents().clear();\n       }\n     }\n \n     // fetch metrics\n     boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n     if (fieldsToRetrieve.contains(Field.ALL) ||\n         fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n-      readMetrics(entity, result);\n+      readMetrics(entity, result, isApplication);\n       if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n           entity.getMetrics(), metricFilters)) {\n         return null;\n       }\n       if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n           !fieldsToRetrieve.contains(Field.METRICS)) {\n         entity.getMetrics().clear();\n       }\n     }\n     return entity;\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private static TimelineEntity parseEntity(\n      Result result, EnumSet\u003cField\u003e fieldsToRetrieve,\n      boolean checkCreatedTime, long createdTimeBegin, long createdTimeEnd,\n      boolean checkModifiedTime, long modifiedTimeBegin, long modifiedTimeEnd,\n      Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo, Map\u003cString, Set\u003cString\u003e\u003e relatesTo,\n      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n      Set\u003cString\u003e eventFilters, Set\u003cString\u003e metricFilters,\n      boolean isApplication)\n          throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    String entityType \u003d isApplication ?\n        TimelineEntityType.YARN_APPLICATION.toString() :\n        EntityColumn.TYPE.readResult(result).toString();\n    entity.setType(entityType);\n    String entityId \u003d isApplication ?\n        ApplicationColumn.ID.readResult(result).toString() :\n        EntityColumn.ID.readResult(result).toString();\n    entity.setId(entityId);\n\n    // fetch created time\n    Number createdTime \u003d isApplication ?\n        (Number)ApplicationColumn.CREATED_TIME.readResult(result) :\n        (Number)EntityColumn.CREATED_TIME.readResult(result);\n    entity.setCreatedTime(createdTime.longValue());\n    if (checkCreatedTime \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n        entity.getCreatedTime() \u003e createdTimeEnd)) {\n      return null;\n    }\n\n    // fetch modified time\n    Number modifiedTime \u003d isApplication ?\n        (Number)ApplicationColumn.MODIFIED_TIME.readResult(result) :\n        (Number)EntityColumn.MODIFIED_TIME.readResult(result);\n    entity.setModifiedTime(modifiedTime.longValue());\n    if (checkModifiedTime \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n        entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n      return null;\n    }\n\n    // fetch is related to entities\n    boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      if (isApplication) {\n        readRelationship(entity, result, ApplicationColumnPrefix.IS_RELATED_TO,\n            true);\n      } else {\n        readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO,\n            true);\n      }\n      if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getIsRelatedToEntities(), isRelatedTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities\n    boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n      if (isApplication) {\n        readRelationship(entity, result, ApplicationColumnPrefix.RELATES_TO,\n            false);\n      } else {\n        readRelationship(entity, result, EntityColumnPrefix.RELATES_TO, false);\n      }\n      if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getRelatesToEntities(), relatesTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info\n    boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n      if (isApplication) {\n        readKeyValuePairs(entity, result, ApplicationColumnPrefix.INFO, false);\n      } else {\n        readKeyValuePairs(entity, result, EntityColumnPrefix.INFO, false);\n      }\n      if (checkInfo \u0026\u0026\n          !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.INFO)) {\n        entity.getInfo().clear();\n      }\n    }\n\n    // fetch configs\n    boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n      if (isApplication) {\n        readKeyValuePairs(entity, result, ApplicationColumnPrefix.CONFIG, true);\n      } else {\n        readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG, true);\n      }\n      if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n          entity.getConfigs(), configFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n        entity.getConfigs().clear();\n      }\n    }\n\n    // fetch events\n    boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n      readEvents(entity, result, isApplication);\n      if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n          entity.getEvents(), eventFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics\n    boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n      readMetrics(entity, result, isApplication);\n      if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n          entity.getMetrics(), metricFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.METRICS)) {\n        entity.getMetrics().clear();\n      }\n    }\n    return entity;\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/HBaseTimelineReaderImpl.java",
          "extendedDetails": {}
        }
      ]
    },
    "9e5155be363c6610ccf41fe08b7f1394f353ea65": {
      "type": "Yintroduced",
      "commitMessage": "YARN-3049. [Storage Implementation] Implement storage reader interface to fetch raw data from HBase backend (Zhijie Shen via sjlee)\n\n(cherry picked from commit 07433c2ad52df9e844dbd90020c277d3df844dcd)\n",
      "commitDate": "10/07/16 8:45 AM",
      "commitName": "9e5155be363c6610ccf41fe08b7f1394f353ea65",
      "commitAuthor": "Sangjin Lee",
      "diff": "@@ -0,0 +1,122 @@\n+  private static TimelineEntity parseEntity(\n+      Result result, EnumSet\u003cField\u003e fieldsToRetrieve,\n+      boolean checkCreatedTime, long createdTimeBegin, long createdTimeEnd,\n+      boolean checkModifiedTime, long modifiedTimeBegin, long modifiedTimeEnd,\n+      Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo, Map\u003cString, Set\u003cString\u003e\u003e relatesTo,\n+      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n+      Set\u003cString\u003e eventFilters, Set\u003cString\u003e metricFilters)\n+          throws IOException {\n+    if (result \u003d\u003d null || result.isEmpty()) {\n+      return null;\n+    }\n+    TimelineEntity entity \u003d new TimelineEntity();\n+    entity.setType(EntityColumn.TYPE.readResult(result).toString());\n+    entity.setId(EntityColumn.ID.readResult(result).toString());\n+\n+    // fetch created time\n+    entity.setCreatedTime(\n+        ((Number) EntityColumn.CREATED_TIME.readResult(result)).longValue());\n+    if (checkCreatedTime \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n+        entity.getCreatedTime() \u003e createdTimeEnd)) {\n+      return null;\n+    }\n+\n+    // fetch modified time\n+    entity.setCreatedTime(\n+        ((Number) EntityColumn.MODIFIED_TIME.readResult(result)).longValue());\n+    if (checkModifiedTime \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n+        entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n+      return null;\n+    }\n+\n+    // fetch is related to entities\n+    boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n+    if (fieldsToRetrieve.contains(Field.ALL) ||\n+        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n+      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO);\n+      if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n+          entity.getIsRelatedToEntities(), isRelatedTo)) {\n+        return null;\n+      }\n+      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n+          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n+        entity.getIsRelatedToEntities().clear();\n+      }\n+    }\n+\n+    // fetch relates to entities\n+    boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n+    if (fieldsToRetrieve.contains(Field.ALL) ||\n+        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n+      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO);\n+      if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n+          entity.getRelatesToEntities(), relatesTo)) {\n+        return null;\n+      }\n+      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n+          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n+        entity.getRelatesToEntities().clear();\n+      }\n+    }\n+\n+    // fetch info\n+    boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n+    if (fieldsToRetrieve.contains(Field.ALL) ||\n+        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n+      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO);\n+      if (checkInfo \u0026\u0026\n+          !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n+        return null;\n+      }\n+      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n+          !fieldsToRetrieve.contains(Field.INFO)) {\n+        entity.getInfo().clear();\n+      }\n+    }\n+\n+    // fetch configs\n+    boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n+    if (fieldsToRetrieve.contains(Field.ALL) ||\n+        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n+      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG);\n+      if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n+          entity.getConfigs(), configFilters)) {\n+        return null;\n+      }\n+      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n+          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n+        entity.getConfigs().clear();\n+      }\n+    }\n+\n+    // fetch events\n+    boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n+    if (fieldsToRetrieve.contains(Field.ALL) ||\n+        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n+      readEvents(entity, result);\n+      if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n+          entity.getEvents(), eventFilters)) {\n+        return null;\n+      }\n+      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n+          !fieldsToRetrieve.contains(Field.EVENTS)) {\n+        entity.getEvents().clear();\n+      }\n+    }\n+\n+    // fetch metrics\n+    boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n+    if (fieldsToRetrieve.contains(Field.ALL) ||\n+        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n+      readMetrics(entity, result);\n+      if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n+          entity.getMetrics(), metricFilters)) {\n+        return null;\n+      }\n+      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n+          !fieldsToRetrieve.contains(Field.METRICS)) {\n+        entity.getMetrics().clear();\n+      }\n+    }\n+    return entity;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private static TimelineEntity parseEntity(\n      Result result, EnumSet\u003cField\u003e fieldsToRetrieve,\n      boolean checkCreatedTime, long createdTimeBegin, long createdTimeEnd,\n      boolean checkModifiedTime, long modifiedTimeBegin, long modifiedTimeEnd,\n      Map\u003cString, Set\u003cString\u003e\u003e isRelatedTo, Map\u003cString, Set\u003cString\u003e\u003e relatesTo,\n      Map\u003cString, Object\u003e infoFilters, Map\u003cString, String\u003e configFilters,\n      Set\u003cString\u003e eventFilters, Set\u003cString\u003e metricFilters)\n          throws IOException {\n    if (result \u003d\u003d null || result.isEmpty()) {\n      return null;\n    }\n    TimelineEntity entity \u003d new TimelineEntity();\n    entity.setType(EntityColumn.TYPE.readResult(result).toString());\n    entity.setId(EntityColumn.ID.readResult(result).toString());\n\n    // fetch created time\n    entity.setCreatedTime(\n        ((Number) EntityColumn.CREATED_TIME.readResult(result)).longValue());\n    if (checkCreatedTime \u0026\u0026 (entity.getCreatedTime() \u003c createdTimeBegin ||\n        entity.getCreatedTime() \u003e createdTimeEnd)) {\n      return null;\n    }\n\n    // fetch modified time\n    entity.setCreatedTime(\n        ((Number) EntityColumn.MODIFIED_TIME.readResult(result)).longValue());\n    if (checkModifiedTime \u0026\u0026 (entity.getModifiedTime() \u003c modifiedTimeBegin ||\n        entity.getModifiedTime() \u003e modifiedTimeEnd)) {\n      return null;\n    }\n\n    // fetch is related to entities\n    boolean checkIsRelatedTo \u003d isRelatedTo !\u003d null \u0026\u0026 isRelatedTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.IS_RELATED_TO) || checkIsRelatedTo) {\n      readRelationship(entity, result, EntityColumnPrefix.IS_RELATED_TO);\n      if (checkIsRelatedTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getIsRelatedToEntities(), isRelatedTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.IS_RELATED_TO)) {\n        entity.getIsRelatedToEntities().clear();\n      }\n    }\n\n    // fetch relates to entities\n    boolean checkRelatesTo \u003d relatesTo !\u003d null \u0026\u0026 relatesTo.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.RELATES_TO) || checkRelatesTo) {\n      readRelationship(entity, result, EntityColumnPrefix.RELATES_TO);\n      if (checkRelatesTo \u0026\u0026 !TimelineReaderUtils.matchRelations(\n          entity.getRelatesToEntities(), relatesTo)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.RELATES_TO)) {\n        entity.getRelatesToEntities().clear();\n      }\n    }\n\n    // fetch info\n    boolean checkInfo \u003d infoFilters !\u003d null \u0026\u0026 infoFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.INFO) || checkInfo) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.INFO);\n      if (checkInfo \u0026\u0026\n          !TimelineReaderUtils.matchFilters(entity.getInfo(), infoFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.INFO)) {\n        entity.getInfo().clear();\n      }\n    }\n\n    // fetch configs\n    boolean checkConfigs \u003d configFilters !\u003d null \u0026\u0026 configFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.CONFIGS) || checkConfigs) {\n      readKeyValuePairs(entity, result, EntityColumnPrefix.CONFIG);\n      if (checkConfigs \u0026\u0026 !TimelineReaderUtils.matchFilters(\n          entity.getConfigs(), configFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.CONFIGS)) {\n        entity.getConfigs().clear();\n      }\n    }\n\n    // fetch events\n    boolean checkEvents \u003d eventFilters !\u003d null \u0026\u0026 eventFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.EVENTS) || checkEvents) {\n      readEvents(entity, result);\n      if (checkEvents \u0026\u0026 !TimelineReaderUtils.matchEventFilters(\n          entity.getEvents(), eventFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.EVENTS)) {\n        entity.getEvents().clear();\n      }\n    }\n\n    // fetch metrics\n    boolean checkMetrics \u003d metricFilters !\u003d null \u0026\u0026 metricFilters.size() \u003e 0;\n    if (fieldsToRetrieve.contains(Field.ALL) ||\n        fieldsToRetrieve.contains(Field.METRICS) || checkMetrics) {\n      readMetrics(entity, result);\n      if (checkMetrics \u0026\u0026 !TimelineReaderUtils.matchMetricFilters(\n          entity.getMetrics(), metricFilters)) {\n        return null;\n      }\n      if (!fieldsToRetrieve.contains(Field.ALL) \u0026\u0026\n          !fieldsToRetrieve.contains(Field.METRICS)) {\n        entity.getMetrics().clear();\n      }\n    }\n    return entity;\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-timelineservice/src/main/java/org/apache/hadoop/yarn/server/timelineservice/storage/HBaseTimelineReaderImpl.java"
    }
  }
}