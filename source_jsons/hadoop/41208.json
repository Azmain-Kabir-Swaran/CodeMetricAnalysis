{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "AllocationFileQueueParser.java",
  "functionName": "loadQueue",
  "functionId": "loadQueue___parentName-String__element-Element__builder-QueueProperties.Builder",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/allocation/AllocationFileQueueParser.java",
  "functionStartLine": 106,
  "functionEndLine": 254,
  "numCommitsSeen": 253,
  "timeTaken": 19683,
  "changeHistory": [
    "fd6be5898ad1a650e3bceacb8169a53520da57e5",
    "9edc74f64a31450af3c55c0dadf352862e4b359d",
    "39ad98903a5f042573b97a2e5438bc57af7cc7a1",
    "17262470246232d0f0651d627a4961e55b1efe6a",
    "1f10a360219c91ac13d31bdb5c8d302b1b45afc3",
    "814d701d46b4ff87f6ec94ba39667c80475c38d7",
    "99292adcefdc6b8f280b8e100605fb39f755c38a",
    "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
    "c7680d4cc4d9302a5b5efcf2467bd32ecea99585",
    "543aac9f281871a40473e83061f6deadc0bbdab7",
    "84ddedc0b2d58257d45c16ee5e83b15f94a7ba3a",
    "f85b74ccf9f1c1c1444cc00750b03468cbf40fb9",
    "b3befc021b0e2d63d1a3710ea450797d1129f1f5",
    "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
    "f5f1c81e7dcae0272e71ef4e6bedfc00b8c677d6",
    "23f937e3b718f607d4fc975610ab3a03265f0f7e",
    "fb238d7e5dcd96466c8938b13ca7f13cedecb08a",
    "2bc097cd14692e6ceb06bff959f28531534eb307",
    "a22ffc318801698e86cd0e316b4824015f2486ac",
    "a128cca305cecb215a2eef2ef543d1bf9b23a41b",
    "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7",
    "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
    "16caa3fd18424a67fc01b1ae3a8fcdbc99c8cbc4",
    "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
    "7274b5ff93afc6e6e96fb6fcd43f2955960f2644",
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
    "dc523bd18247df232fe814aed7062a116242ab04",
    "881d1d5c7e2810ed001fe4ca5dfdc375599d37cf",
    "65bda6d168e47106f5542e15bb7b21522478626e",
    "643b1a401968a21d902b602e76a53c1f98b1a950",
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
    "a43c344eee888f2a2488c8c9dca7e25a2cce10bf",
    "df55edd5dec9c944a6c38f08d6f1f0fdb901c880",
    "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3",
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21"
  ],
  "changeHistoryShort": {
    "fd6be5898ad1a650e3bceacb8169a53520da57e5": "Ybodychange",
    "9edc74f64a31450af3c55c0dadf352862e4b359d": "Ybodychange",
    "39ad98903a5f042573b97a2e5438bc57af7cc7a1": "Ybodychange",
    "17262470246232d0f0651d627a4961e55b1efe6a": "Ybodychange",
    "1f10a360219c91ac13d31bdb5c8d302b1b45afc3": "Ybodychange",
    "814d701d46b4ff87f6ec94ba39667c80475c38d7": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
    "99292adcefdc6b8f280b8e100605fb39f755c38a": "Ymultichange(Yparameterchange,Ybodychange)",
    "09b476e6dabe8039a41dde7930c8a9c0d14bb750": "Ymultichange(Yparameterchange,Ybodychange)",
    "c7680d4cc4d9302a5b5efcf2467bd32ecea99585": "Ybodychange",
    "543aac9f281871a40473e83061f6deadc0bbdab7": "Ybodychange",
    "84ddedc0b2d58257d45c16ee5e83b15f94a7ba3a": "Ybodychange",
    "f85b74ccf9f1c1c1444cc00750b03468cbf40fb9": "Ybodychange",
    "b3befc021b0e2d63d1a3710ea450797d1129f1f5": "Ymultichange(Yparameterchange,Ybodychange)",
    "20f0eb871c57cc4c5a6d19aae0e3745b6175509b": "Ymultichange(Yparameterchange,Ybodychange)",
    "f5f1c81e7dcae0272e71ef4e6bedfc00b8c677d6": "Ybodychange",
    "23f937e3b718f607d4fc975610ab3a03265f0f7e": "Ymultichange(Yparameterchange,Ybodychange)",
    "fb238d7e5dcd96466c8938b13ca7f13cedecb08a": "Ymultichange(Yparameterchange,Ybodychange)",
    "2bc097cd14692e6ceb06bff959f28531534eb307": "Ybodychange",
    "a22ffc318801698e86cd0e316b4824015f2486ac": "Ymultichange(Yparameterchange,Ybodychange)",
    "a128cca305cecb215a2eef2ef543d1bf9b23a41b": "Ybodychange",
    "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7": "Ymultichange(Yparameterchange,Ybodychange)",
    "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9": "Ymultichange(Yparameterchange,Ybodychange)",
    "16caa3fd18424a67fc01b1ae3a8fcdbc99c8cbc4": "Ymultichange(Yparameterchange,Ybodychange)",
    "cfc97a4e88dcebb3e1098e8915e57aaff072414d": "Ymultichange(Yparameterchange,Ybodychange)",
    "7274b5ff93afc6e6e96fb6fcd43f2955960f2644": "Ybodychange",
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
    "dc523bd18247df232fe814aed7062a116242ab04": "Ybodychange",
    "881d1d5c7e2810ed001fe4ca5dfdc375599d37cf": "Ybodychange",
    "65bda6d168e47106f5542e15bb7b21522478626e": "Ybodychange",
    "643b1a401968a21d902b602e76a53c1f98b1a950": "Ybodychange",
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650": "Ymultichange(Yparameterchange,Ybodychange)",
    "a43c344eee888f2a2488c8c9dca7e25a2cce10bf": "Ybodychange",
    "df55edd5dec9c944a6c38f08d6f1f0fdb901c880": "Ymultichange(Yparameterchange,Ybodychange)",
    "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3": "Ybodychange",
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21": "Yintroduced"
  },
  "changeHistoryDetails": {
    "fd6be5898ad1a650e3bceacb8169a53520da57e5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8468. Enable the use of queue based maximum container allocation limit and implement it in FairScheduler. Contributed by Antal BÃ¡lint Steinbach.\n",
      "commitDate": "29/09/18 2:47 AM",
      "commitName": "fd6be5898ad1a650e3bceacb8169a53520da57e5",
      "commitAuthor": "Weiwei Yang",
      "commitDateOld": "06/07/18 11:03 AM",
      "commitNameOld": "9edc74f64a31450af3c55c0dadf352862e4b359d",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 84.66,
      "commitsBetweenForRepo": 714,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,149 @@\n   private void loadQueue(String parentName, Element element,\n       QueueProperties.Builder builder) throws AllocationConfigurationException {\n     String queueName \u003d\n         FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element)) {\n         continue;\n       }\n       Element field \u003d (Element) fieldNode;\n       if (MIN_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text, 0L);\n         builder.minQueueResources(queueName, val.getResource());\n       } else if (MAX_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         builder.maxQueueResources(queueName, val);\n       } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         builder.maxChildQueueResources(queueName, val);\n       } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         int val \u003d Integer.parseInt(text);\n         builder.queueMaxApps(queueName, val);\n       } else if (MAX_AMSHARE.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         builder.queueMaxAMShares(queueName, val);\n+      } else if (MAX_CONTAINER_ALLOCATION.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n+        ConfigurableResource val \u003d\n+            FairSchedulerConfiguration.parseResourceConfigValue(text);\n+        builder.queueMaxContainerAllocation(queueName, val.getResource());\n       } else if (WEIGHT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         double val \u003d Double.parseDouble(text);\n         builder.queueWeights(queueName, (float) val);\n       } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n         builder.minSharePreemptionTimeouts(queueName, val);\n       } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n         builder.fairSharePreemptionTimeouts(queueName, val);\n       } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         builder.fairSharePreemptionThresholds(queueName, val);\n       } else if (SCHEDULING_POLICY.equals(field.getTagName())\n           || SCHEDULING_MODE.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         builder.queuePolicies(queueName, policy);\n       } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n             new AccessControlList(text));\n       } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n             new AccessControlList(text));\n       } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName,\n             ReservationACL.ADMINISTER_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (RESERVATION.equals(field.getTagName())) {\n         isReservable \u003d true;\n         builder.reservableQueues(queueName);\n         builder.configuredQueues(FSQueueType.PARENT, queueName);\n       } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         if (!Boolean.parseBoolean(text)) {\n           builder.nonPreemptableQueues(queueName);\n         }\n       } else if (QUEUE.endsWith(field.getTagName())\n           || POOL.equals(field.getTagName())) {\n         loadQueue(queueName, field, builder);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n       // reservable queue has been already configured as parent\n       if (!isReservable) {\n         builder.configuredQueues(FSQueueType.LEAF, queueName);\n       }\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n       builder.configuredQueues(FSQueueType.PARENT, queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n         AccessControlList defaultAcl \u003d\n             queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n         builder.queueAcls(queueName, accessType, defaultAcl);\n       }\n     }\n \n     checkMinAndMaxResource(builder.getMinQueueResources(),\n         builder.getMaxQueueResources(), queueName);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element,\n      QueueProperties.Builder builder) throws AllocationConfigurationException {\n    String queueName \u003d\n        FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (MIN_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text, 0L);\n        builder.minQueueResources(queueName, val.getResource());\n      } else if (MAX_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxQueueResources(queueName, val);\n      } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxChildQueueResources(queueName, val);\n      } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        int val \u003d Integer.parseInt(text);\n        builder.queueMaxApps(queueName, val);\n      } else if (MAX_AMSHARE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        builder.queueMaxAMShares(queueName, val);\n      } else if (MAX_CONTAINER_ALLOCATION.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.queueMaxContainerAllocation(queueName, val.getResource());\n      } else if (WEIGHT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        double val \u003d Double.parseDouble(text);\n        builder.queueWeights(queueName, (float) val);\n      } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.minSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.fairSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        builder.fairSharePreemptionThresholds(queueName, val);\n      } else if (SCHEDULING_POLICY.equals(field.getTagName())\n          || SCHEDULING_MODE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        builder.queuePolicies(queueName, policy);\n      } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName,\n            ReservationACL.ADMINISTER_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (RESERVATION.equals(field.getTagName())) {\n        isReservable \u003d true;\n        builder.reservableQueues(queueName);\n        builder.configuredQueues(FSQueueType.PARENT, queueName);\n      } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        if (!Boolean.parseBoolean(text)) {\n          builder.nonPreemptableQueues(queueName);\n        }\n      } else if (QUEUE.endsWith(field.getTagName())\n          || POOL.equals(field.getTagName())) {\n        loadQueue(queueName, field, builder);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      // reservable queue has been already configured as parent\n      if (!isReservable) {\n        builder.configuredQueues(FSQueueType.LEAF, queueName);\n      }\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      builder.configuredQueues(FSQueueType.PARENT, queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n        AccessControlList defaultAcl \u003d\n            queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n        builder.queueAcls(queueName, accessType, defaultAcl);\n      }\n    }\n\n    checkMinAndMaxResource(builder.getMinQueueResources(),\n        builder.getMaxQueueResources(), queueName);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/allocation/AllocationFileQueueParser.java",
      "extendedDetails": {}
    },
    "9edc74f64a31450af3c55c0dadf352862e4b359d": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7556. Fair scheduler configuration should allow resource types in the minResources and maxResources properties. (Daniel Templeton and Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "06/07/18 11:03 AM",
      "commitName": "9edc74f64a31450af3c55c0dadf352862e4b359d",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "05/07/18 12:22 PM",
      "commitNameOld": "39ad98903a5f042573b97a2e5438bc57af7cc7a1",
      "commitAuthorOld": "Anu Engineer",
      "daysBetweenCommits": 0.95,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   private void loadQueue(String parentName, Element element,\n       QueueProperties.Builder builder) throws AllocationConfigurationException {\n     String queueName \u003d\n         FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element)) {\n         continue;\n       }\n       Element field \u003d (Element) fieldNode;\n       if (MIN_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n-            FairSchedulerConfiguration.parseResourceConfigValue(text);\n+            FairSchedulerConfiguration.parseResourceConfigValue(text, 0L);\n         builder.minQueueResources(queueName, val.getResource());\n       } else if (MAX_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         builder.maxQueueResources(queueName, val);\n       } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         builder.maxChildQueueResources(queueName, val);\n       } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         int val \u003d Integer.parseInt(text);\n         builder.queueMaxApps(queueName, val);\n       } else if (MAX_AMSHARE.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         builder.queueMaxAMShares(queueName, val);\n       } else if (WEIGHT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         double val \u003d Double.parseDouble(text);\n         builder.queueWeights(queueName, (float) val);\n       } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n         builder.minSharePreemptionTimeouts(queueName, val);\n       } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n         builder.fairSharePreemptionTimeouts(queueName, val);\n       } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         builder.fairSharePreemptionThresholds(queueName, val);\n       } else if (SCHEDULING_POLICY.equals(field.getTagName())\n           || SCHEDULING_MODE.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         builder.queuePolicies(queueName, policy);\n       } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n             new AccessControlList(text));\n       } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n             new AccessControlList(text));\n       } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName,\n             ReservationACL.ADMINISTER_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (RESERVATION.equals(field.getTagName())) {\n         isReservable \u003d true;\n         builder.reservableQueues(queueName);\n         builder.configuredQueues(FSQueueType.PARENT, queueName);\n       } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         if (!Boolean.parseBoolean(text)) {\n           builder.nonPreemptableQueues(queueName);\n         }\n       } else if (QUEUE.endsWith(field.getTagName())\n           || POOL.equals(field.getTagName())) {\n         loadQueue(queueName, field, builder);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n       // reservable queue has been already configured as parent\n       if (!isReservable) {\n         builder.configuredQueues(FSQueueType.LEAF, queueName);\n       }\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n       builder.configuredQueues(FSQueueType.PARENT, queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n         AccessControlList defaultAcl \u003d\n             queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n         builder.queueAcls(queueName, accessType, defaultAcl);\n       }\n     }\n \n     checkMinAndMaxResource(builder.getMinQueueResources(),\n         builder.getMaxQueueResources(), queueName);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element,\n      QueueProperties.Builder builder) throws AllocationConfigurationException {\n    String queueName \u003d\n        FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (MIN_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text, 0L);\n        builder.minQueueResources(queueName, val.getResource());\n      } else if (MAX_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxQueueResources(queueName, val);\n      } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxChildQueueResources(queueName, val);\n      } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        int val \u003d Integer.parseInt(text);\n        builder.queueMaxApps(queueName, val);\n      } else if (MAX_AMSHARE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        builder.queueMaxAMShares(queueName, val);\n      } else if (WEIGHT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        double val \u003d Double.parseDouble(text);\n        builder.queueWeights(queueName, (float) val);\n      } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.minSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.fairSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        builder.fairSharePreemptionThresholds(queueName, val);\n      } else if (SCHEDULING_POLICY.equals(field.getTagName())\n          || SCHEDULING_MODE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        builder.queuePolicies(queueName, policy);\n      } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName,\n            ReservationACL.ADMINISTER_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (RESERVATION.equals(field.getTagName())) {\n        isReservable \u003d true;\n        builder.reservableQueues(queueName);\n        builder.configuredQueues(FSQueueType.PARENT, queueName);\n      } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        if (!Boolean.parseBoolean(text)) {\n          builder.nonPreemptableQueues(queueName);\n        }\n      } else if (QUEUE.endsWith(field.getTagName())\n          || POOL.equals(field.getTagName())) {\n        loadQueue(queueName, field, builder);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      // reservable queue has been already configured as parent\n      if (!isReservable) {\n        builder.configuredQueues(FSQueueType.LEAF, queueName);\n      }\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      builder.configuredQueues(FSQueueType.PARENT, queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n        AccessControlList defaultAcl \u003d\n            queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n        builder.queueAcls(queueName, accessType, defaultAcl);\n      }\n    }\n\n    checkMinAndMaxResource(builder.getMinQueueResources(),\n        builder.getMaxQueueResources(), queueName);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/allocation/AllocationFileQueueParser.java",
      "extendedDetails": {}
    },
    "39ad98903a5f042573b97a2e5438bc57af7cc7a1": {
      "type": "Ybodychange",
      "commitMessage": "Revert \"Merge branch \u0027trunk\u0027 of https://git-wip-us.apache.org/repos/asf/hadoop into trunk\"\n\nThis reverts commit c163d1797ade0f47d35b4a44381b8ef1dfec5b60, reversing\nchanges made to 0d9804dcef2eab5ebf84667d9ca49bb035d9a731.\n",
      "commitDate": "05/07/18 12:22 PM",
      "commitName": "39ad98903a5f042573b97a2e5438bc57af7cc7a1",
      "commitAuthor": "Anu Engineer",
      "commitDateOld": "05/07/18 10:42 AM",
      "commitNameOld": "17262470246232d0f0651d627a4961e55b1efe6a",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 0.07,
      "commitsBetweenForRepo": 3,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   private void loadQueue(String parentName, Element element,\n       QueueProperties.Builder builder) throws AllocationConfigurationException {\n     String queueName \u003d\n         FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element)) {\n         continue;\n       }\n       Element field \u003d (Element) fieldNode;\n       if (MIN_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n-            FairSchedulerConfiguration.parseResourceConfigValue(text, 0L);\n+            FairSchedulerConfiguration.parseResourceConfigValue(text);\n         builder.minQueueResources(queueName, val.getResource());\n       } else if (MAX_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         builder.maxQueueResources(queueName, val);\n       } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         builder.maxChildQueueResources(queueName, val);\n       } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         int val \u003d Integer.parseInt(text);\n         builder.queueMaxApps(queueName, val);\n       } else if (MAX_AMSHARE.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         builder.queueMaxAMShares(queueName, val);\n       } else if (WEIGHT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         double val \u003d Double.parseDouble(text);\n         builder.queueWeights(queueName, (float) val);\n       } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n         builder.minSharePreemptionTimeouts(queueName, val);\n       } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n         builder.fairSharePreemptionTimeouts(queueName, val);\n       } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         builder.fairSharePreemptionThresholds(queueName, val);\n       } else if (SCHEDULING_POLICY.equals(field.getTagName())\n           || SCHEDULING_MODE.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         builder.queuePolicies(queueName, policy);\n       } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n             new AccessControlList(text));\n       } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n             new AccessControlList(text));\n       } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName,\n             ReservationACL.ADMINISTER_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (RESERVATION.equals(field.getTagName())) {\n         isReservable \u003d true;\n         builder.reservableQueues(queueName);\n         builder.configuredQueues(FSQueueType.PARENT, queueName);\n       } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         if (!Boolean.parseBoolean(text)) {\n           builder.nonPreemptableQueues(queueName);\n         }\n       } else if (QUEUE.endsWith(field.getTagName())\n           || POOL.equals(field.getTagName())) {\n         loadQueue(queueName, field, builder);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n       // reservable queue has been already configured as parent\n       if (!isReservable) {\n         builder.configuredQueues(FSQueueType.LEAF, queueName);\n       }\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n       builder.configuredQueues(FSQueueType.PARENT, queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n         AccessControlList defaultAcl \u003d\n             queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n         builder.queueAcls(queueName, accessType, defaultAcl);\n       }\n     }\n \n     checkMinAndMaxResource(builder.getMinQueueResources(),\n         builder.getMaxQueueResources(), queueName);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element,\n      QueueProperties.Builder builder) throws AllocationConfigurationException {\n    String queueName \u003d\n        FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (MIN_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.minQueueResources(queueName, val.getResource());\n      } else if (MAX_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxQueueResources(queueName, val);\n      } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxChildQueueResources(queueName, val);\n      } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        int val \u003d Integer.parseInt(text);\n        builder.queueMaxApps(queueName, val);\n      } else if (MAX_AMSHARE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        builder.queueMaxAMShares(queueName, val);\n      } else if (WEIGHT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        double val \u003d Double.parseDouble(text);\n        builder.queueWeights(queueName, (float) val);\n      } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.minSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.fairSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        builder.fairSharePreemptionThresholds(queueName, val);\n      } else if (SCHEDULING_POLICY.equals(field.getTagName())\n          || SCHEDULING_MODE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        builder.queuePolicies(queueName, policy);\n      } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName,\n            ReservationACL.ADMINISTER_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (RESERVATION.equals(field.getTagName())) {\n        isReservable \u003d true;\n        builder.reservableQueues(queueName);\n        builder.configuredQueues(FSQueueType.PARENT, queueName);\n      } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        if (!Boolean.parseBoolean(text)) {\n          builder.nonPreemptableQueues(queueName);\n        }\n      } else if (QUEUE.endsWith(field.getTagName())\n          || POOL.equals(field.getTagName())) {\n        loadQueue(queueName, field, builder);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      // reservable queue has been already configured as parent\n      if (!isReservable) {\n        builder.configuredQueues(FSQueueType.LEAF, queueName);\n      }\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      builder.configuredQueues(FSQueueType.PARENT, queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n        AccessControlList defaultAcl \u003d\n            queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n        builder.queueAcls(queueName, accessType, defaultAcl);\n      }\n    }\n\n    checkMinAndMaxResource(builder.getMinQueueResources(),\n        builder.getMaxQueueResources(), queueName);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/allocation/AllocationFileQueueParser.java",
      "extendedDetails": {}
    },
    "17262470246232d0f0651d627a4961e55b1efe6a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-7556. Fair scheduler configuration should allow resource types in the minResources and maxResources properties. (Daniel Templeton and Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "05/07/18 10:42 AM",
      "commitName": "17262470246232d0f0651d627a4961e55b1efe6a",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "11/05/18 11:34 AM",
      "commitNameOld": "1f10a360219c91ac13d31bdb5c8d302b1b45afc3",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 54.96,
      "commitsBetweenForRepo": 382,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,144 +1,144 @@\n   private void loadQueue(String parentName, Element element,\n       QueueProperties.Builder builder) throws AllocationConfigurationException {\n     String queueName \u003d\n         FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element)) {\n         continue;\n       }\n       Element field \u003d (Element) fieldNode;\n       if (MIN_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n-            FairSchedulerConfiguration.parseResourceConfigValue(text);\n+            FairSchedulerConfiguration.parseResourceConfigValue(text, 0L);\n         builder.minQueueResources(queueName, val.getResource());\n       } else if (MAX_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         builder.maxQueueResources(queueName, val);\n       } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         builder.maxChildQueueResources(queueName, val);\n       } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         int val \u003d Integer.parseInt(text);\n         builder.queueMaxApps(queueName, val);\n       } else if (MAX_AMSHARE.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         builder.queueMaxAMShares(queueName, val);\n       } else if (WEIGHT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         double val \u003d Double.parseDouble(text);\n         builder.queueWeights(queueName, (float) val);\n       } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n         builder.minSharePreemptionTimeouts(queueName, val);\n       } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n         builder.fairSharePreemptionTimeouts(queueName, val);\n       } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         builder.fairSharePreemptionThresholds(queueName, val);\n       } else if (SCHEDULING_POLICY.equals(field.getTagName())\n           || SCHEDULING_MODE.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         builder.queuePolicies(queueName, policy);\n       } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n             new AccessControlList(text));\n       } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n             new AccessControlList(text));\n       } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName,\n             ReservationACL.ADMINISTER_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (RESERVATION.equals(field.getTagName())) {\n         isReservable \u003d true;\n         builder.reservableQueues(queueName);\n         builder.configuredQueues(FSQueueType.PARENT, queueName);\n       } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         if (!Boolean.parseBoolean(text)) {\n           builder.nonPreemptableQueues(queueName);\n         }\n       } else if (QUEUE.endsWith(field.getTagName())\n           || POOL.equals(field.getTagName())) {\n         loadQueue(queueName, field, builder);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n       // reservable queue has been already configured as parent\n       if (!isReservable) {\n         builder.configuredQueues(FSQueueType.LEAF, queueName);\n       }\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n       builder.configuredQueues(FSQueueType.PARENT, queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n         AccessControlList defaultAcl \u003d\n             queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n         builder.queueAcls(queueName, accessType, defaultAcl);\n       }\n     }\n \n     checkMinAndMaxResource(builder.getMinQueueResources(),\n         builder.getMaxQueueResources(), queueName);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element,\n      QueueProperties.Builder builder) throws AllocationConfigurationException {\n    String queueName \u003d\n        FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (MIN_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text, 0L);\n        builder.minQueueResources(queueName, val.getResource());\n      } else if (MAX_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxQueueResources(queueName, val);\n      } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxChildQueueResources(queueName, val);\n      } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        int val \u003d Integer.parseInt(text);\n        builder.queueMaxApps(queueName, val);\n      } else if (MAX_AMSHARE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        builder.queueMaxAMShares(queueName, val);\n      } else if (WEIGHT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        double val \u003d Double.parseDouble(text);\n        builder.queueWeights(queueName, (float) val);\n      } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.minSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.fairSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        builder.fairSharePreemptionThresholds(queueName, val);\n      } else if (SCHEDULING_POLICY.equals(field.getTagName())\n          || SCHEDULING_MODE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        builder.queuePolicies(queueName, policy);\n      } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName,\n            ReservationACL.ADMINISTER_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (RESERVATION.equals(field.getTagName())) {\n        isReservable \u003d true;\n        builder.reservableQueues(queueName);\n        builder.configuredQueues(FSQueueType.PARENT, queueName);\n      } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        if (!Boolean.parseBoolean(text)) {\n          builder.nonPreemptableQueues(queueName);\n        }\n      } else if (QUEUE.endsWith(field.getTagName())\n          || POOL.equals(field.getTagName())) {\n        loadQueue(queueName, field, builder);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      // reservable queue has been already configured as parent\n      if (!isReservable) {\n        builder.configuredQueues(FSQueueType.LEAF, queueName);\n      }\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      builder.configuredQueues(FSQueueType.PARENT, queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n        AccessControlList defaultAcl \u003d\n            queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n        builder.queueAcls(queueName, accessType, defaultAcl);\n      }\n    }\n\n    checkMinAndMaxResource(builder.getMinQueueResources(),\n        builder.getMaxQueueResources(), queueName);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/allocation/AllocationFileQueueParser.java",
      "extendedDetails": {}
    },
    "1f10a360219c91ac13d31bdb5c8d302b1b45afc3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-8268. Fair scheduler: reservable queue is configured both as parent and leaf queue. (Gergo Repas via Haibo Chen)\n",
      "commitDate": "11/05/18 11:34 AM",
      "commitName": "1f10a360219c91ac13d31bdb5c8d302b1b45afc3",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "06/02/18 2:36 PM",
      "commitNameOld": "814d701d46b4ff87f6ec94ba39667c80475c38d7",
      "commitAuthorOld": "Robert Kanter",
      "daysBetweenCommits": 93.83,
      "commitsBetweenForRepo": 1256,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,141 +1,144 @@\n   private void loadQueue(String parentName, Element element,\n       QueueProperties.Builder builder) throws AllocationConfigurationException {\n     String queueName \u003d\n         FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element)) {\n         continue;\n       }\n       Element field \u003d (Element) fieldNode;\n       if (MIN_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         builder.minQueueResources(queueName, val.getResource());\n       } else if (MAX_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         builder.maxQueueResources(queueName, val);\n       } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         builder.maxChildQueueResources(queueName, val);\n       } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         int val \u003d Integer.parseInt(text);\n         builder.queueMaxApps(queueName, val);\n       } else if (MAX_AMSHARE.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         builder.queueMaxAMShares(queueName, val);\n       } else if (WEIGHT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         double val \u003d Double.parseDouble(text);\n         builder.queueWeights(queueName, (float) val);\n       } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n         builder.minSharePreemptionTimeouts(queueName, val);\n       } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n         builder.fairSharePreemptionTimeouts(queueName, val);\n       } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         builder.fairSharePreemptionThresholds(queueName, val);\n       } else if (SCHEDULING_POLICY.equals(field.getTagName())\n           || SCHEDULING_MODE.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         builder.queuePolicies(queueName, policy);\n       } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n             new AccessControlList(text));\n       } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n             new AccessControlList(text));\n       } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName,\n             ReservationACL.ADMINISTER_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n         String text \u003d ((Text) field.getFirstChild()).getData();\n         builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n             new AccessControlList(text));\n       } else if (RESERVATION.equals(field.getTagName())) {\n         isReservable \u003d true;\n         builder.reservableQueues(queueName);\n         builder.configuredQueues(FSQueueType.PARENT, queueName);\n       } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n         String text \u003d getTrimmedTextData(field);\n         if (!Boolean.parseBoolean(text)) {\n           builder.nonPreemptableQueues(queueName);\n         }\n       } else if (QUEUE.endsWith(field.getTagName())\n           || POOL.equals(field.getTagName())) {\n         loadQueue(queueName, field, builder);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n-      builder.configuredQueues(FSQueueType.LEAF, queueName);\n+      // reservable queue has been already configured as parent\n+      if (!isReservable) {\n+        builder.configuredQueues(FSQueueType.LEAF, queueName);\n+      }\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n       builder.configuredQueues(FSQueueType.PARENT, queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n         AccessControlList defaultAcl \u003d\n             queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n         builder.queueAcls(queueName, accessType, defaultAcl);\n       }\n     }\n \n     checkMinAndMaxResource(builder.getMinQueueResources(),\n         builder.getMaxQueueResources(), queueName);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element,\n      QueueProperties.Builder builder) throws AllocationConfigurationException {\n    String queueName \u003d\n        FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (MIN_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.minQueueResources(queueName, val.getResource());\n      } else if (MAX_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxQueueResources(queueName, val);\n      } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxChildQueueResources(queueName, val);\n      } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        int val \u003d Integer.parseInt(text);\n        builder.queueMaxApps(queueName, val);\n      } else if (MAX_AMSHARE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        builder.queueMaxAMShares(queueName, val);\n      } else if (WEIGHT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        double val \u003d Double.parseDouble(text);\n        builder.queueWeights(queueName, (float) val);\n      } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.minSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.fairSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        builder.fairSharePreemptionThresholds(queueName, val);\n      } else if (SCHEDULING_POLICY.equals(field.getTagName())\n          || SCHEDULING_MODE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        builder.queuePolicies(queueName, policy);\n      } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName,\n            ReservationACL.ADMINISTER_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (RESERVATION.equals(field.getTagName())) {\n        isReservable \u003d true;\n        builder.reservableQueues(queueName);\n        builder.configuredQueues(FSQueueType.PARENT, queueName);\n      } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        if (!Boolean.parseBoolean(text)) {\n          builder.nonPreemptableQueues(queueName);\n        }\n      } else if (QUEUE.endsWith(field.getTagName())\n          || POOL.equals(field.getTagName())) {\n        loadQueue(queueName, field, builder);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      // reservable queue has been already configured as parent\n      if (!isReservable) {\n        builder.configuredQueues(FSQueueType.LEAF, queueName);\n      }\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      builder.configuredQueues(FSQueueType.PARENT, queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n        AccessControlList defaultAcl \u003d\n            queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n        builder.queueAcls(queueName, accessType, defaultAcl);\n      }\n    }\n\n    checkMinAndMaxResource(builder.getMinQueueResources(),\n        builder.getMaxQueueResources(), queueName);\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/allocation/AllocationFileQueueParser.java",
      "extendedDetails": {}
    },
    "814d701d46b4ff87f6ec94ba39667c80475c38d7": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
      "commitMessage": "YARN-7841. Cleanup AllocationFileLoaderService\u0027s reloadAllocations method (snemeth via rkanter)\n",
      "commitDate": "06/02/18 2:36 PM",
      "commitName": "814d701d46b4ff87f6ec94ba39667c80475c38d7",
      "commitAuthor": "Robert Kanter",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-7841. Cleanup AllocationFileLoaderService\u0027s reloadAllocations method (snemeth via rkanter)\n",
          "commitDate": "06/02/18 2:36 PM",
          "commitName": "814d701d46b4ff87f6ec94ba39667c80475c38d7",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "06/02/18 1:43 PM",
          "commitNameOld": "4304fcd5bdf9fb7aa9181e866eea383f89bf171f",
          "commitAuthorOld": "Anu Engineer",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,162 +1,141 @@\n   private void loadQueue(String parentName, Element element,\n-      Map\u003cString, Resource\u003e minQueueResources,\n-      Map\u003cString, ConfigurableResource\u003e maxQueueResources,\n-      Map\u003cString, ConfigurableResource\u003e maxChildQueueResources,\n-      Map\u003cString, Integer\u003e queueMaxApps,\n-      Map\u003cString, Integer\u003e userMaxApps,\n-      Map\u003cString, Float\u003e queueMaxAMShares,\n-      Map\u003cString, Float\u003e queueWeights,\n-      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n-      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n-      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n-      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n-      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n-      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n-      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n-      Set\u003cString\u003e reservableQueues,\n-      Set\u003cString\u003e nonPreemptableQueues)\n-      throws AllocationConfigurationException {\n-    String queueName \u003d FairSchedulerUtilities.trimQueueName(\n-        element.getAttribute(\"name\"));\n+      QueueProperties.Builder builder) throws AllocationConfigurationException {\n+    String queueName \u003d\n+        FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n-    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n-    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element)) {\n         continue;\n       }\n       Element field \u003d (Element) fieldNode;\n-      if (\"minResources\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+      if (MIN_RESOURCES.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n-        minQueueResources.put(queueName, val.getResource());\n-      } else if (\"maxResources\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.minQueueResources(queueName, val.getResource());\n+      } else if (MAX_RESOURCES.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n-        maxQueueResources.put(queueName, val);\n-      } else if (\"maxChildResources\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.maxQueueResources(queueName, val);\n+      } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n-        maxChildQueueResources.put(queueName, val);\n-      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.maxChildQueueResources(queueName, val);\n+      } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         int val \u003d Integer.parseInt(text);\n-        queueMaxApps.put(queueName, val);\n-      } else if (\"maxAMShare\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.queueMaxApps(queueName, val);\n+      } else if (MAX_AMSHARE.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n-        queueMaxAMShares.put(queueName, val);\n-      } else if (\"weight\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.queueMaxAMShares(queueName, val);\n+      } else if (WEIGHT.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         double val \u003d Double.parseDouble(text);\n-        queueWeights.put(queueName, (float)val);\n-      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.queueWeights(queueName, (float) val);\n+      } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n-        minSharePreemptionTimeouts.put(queueName, val);\n-      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.minSharePreemptionTimeouts(queueName, val);\n+      } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n-        fairSharePreemptionTimeouts.put(queueName, val);\n-      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.fairSharePreemptionTimeouts(queueName, val);\n+      } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n-        fairSharePreemptionThresholds.put(queueName, val);\n-      } else if (\"schedulingPolicy\".equals(field.getTagName())\n-          || \"schedulingMode\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.fairSharePreemptionThresholds(queueName, val);\n+      } else if (SCHEDULING_POLICY.equals(field.getTagName())\n+          || SCHEDULING_MODE.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n-        queuePolicies.put(queueName, policy);\n-      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n-      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n-      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n-                new AccessControlList(text));\n-      } else if (\"aclListReservations\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n-                text));\n-      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n-                new AccessControlList(text));\n-      } else if (\"reservation\".equals(field.getTagName())) {\n+        builder.queuePolicies(queueName, policy);\n+      } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n+            new AccessControlList(text));\n+      } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n+            new AccessControlList(text));\n+      } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.reservationAcls(queueName,\n+            ReservationACL.ADMINISTER_RESERVATIONS,\n+            new AccessControlList(text));\n+      } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n+            new AccessControlList(text));\n+      } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n+            new AccessControlList(text));\n+      } else if (RESERVATION.equals(field.getTagName())) {\n         isReservable \u003d true;\n-        reservableQueues.add(queueName);\n-        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n-      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.reservableQueues(queueName);\n+        builder.configuredQueues(FSQueueType.PARENT, queueName);\n+      } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         if (!Boolean.parseBoolean(text)) {\n-          nonPreemptableQueues.add(queueName);\n+          builder.nonPreemptableQueues(queueName);\n         }\n-      } else if (\"queue\".endsWith(field.getTagName()) || \n-          \"pool\".equals(field.getTagName())) {\n-        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n-            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n-            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n-            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n-            queueAcls, resAcls, configuredQueues, reservableQueues,\n-            nonPreemptableQueues);\n+      } else if (QUEUE.endsWith(field.getTagName())\n+          || POOL.equals(field.getTagName())) {\n+        loadQueue(queueName, field, builder);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n-      configuredQueues.get(FSQueueType.LEAF).add(queueName);\n+      builder.configuredQueues(FSQueueType.LEAF, queueName);\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n-      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n+      builder.configuredQueues(FSQueueType.PARENT, queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n-      if (acls.get(accessType) \u003d\u003d null){\n-        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n-            EVERYBODY_ACL : NOBODY_ACL;\n-        acls.put(accessType, defaultAcl);\n+      if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n+        AccessControlList defaultAcl \u003d\n+            queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n+        builder.queueAcls(queueName, accessType, defaultAcl);\n       }\n     }\n \n-    queueAcls.put(queueName, acls);\n-    resAcls.put(queueName, racls);\n-    checkMinAndMaxResource(minQueueResources, maxQueueResources, queueName);\n+    checkMinAndMaxResource(builder.getMinQueueResources(),\n+        builder.getMaxQueueResources(), queueName);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      QueueProperties.Builder builder) throws AllocationConfigurationException {\n    String queueName \u003d\n        FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (MIN_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.minQueueResources(queueName, val.getResource());\n      } else if (MAX_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxQueueResources(queueName, val);\n      } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxChildQueueResources(queueName, val);\n      } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        int val \u003d Integer.parseInt(text);\n        builder.queueMaxApps(queueName, val);\n      } else if (MAX_AMSHARE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        builder.queueMaxAMShares(queueName, val);\n      } else if (WEIGHT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        double val \u003d Double.parseDouble(text);\n        builder.queueWeights(queueName, (float) val);\n      } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.minSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.fairSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        builder.fairSharePreemptionThresholds(queueName, val);\n      } else if (SCHEDULING_POLICY.equals(field.getTagName())\n          || SCHEDULING_MODE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        builder.queuePolicies(queueName, policy);\n      } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName,\n            ReservationACL.ADMINISTER_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (RESERVATION.equals(field.getTagName())) {\n        isReservable \u003d true;\n        builder.reservableQueues(queueName);\n        builder.configuredQueues(FSQueueType.PARENT, queueName);\n      } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        if (!Boolean.parseBoolean(text)) {\n          builder.nonPreemptableQueues(queueName);\n        }\n      } else if (QUEUE.endsWith(field.getTagName())\n          || POOL.equals(field.getTagName())) {\n        loadQueue(queueName, field, builder);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      builder.configuredQueues(FSQueueType.LEAF, queueName);\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      builder.configuredQueues(FSQueueType.PARENT, queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n        AccessControlList defaultAcl \u003d\n            queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n        builder.queueAcls(queueName, accessType, defaultAcl);\n      }\n    }\n\n    checkMinAndMaxResource(builder.getMinQueueResources(),\n        builder.getMaxQueueResources(), queueName);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/allocation/AllocationFileQueueParser.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/allocation/AllocationFileQueueParser.java",
            "oldMethodName": "loadQueue",
            "newMethodName": "loadQueue"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-7841. Cleanup AllocationFileLoaderService\u0027s reloadAllocations method (snemeth via rkanter)\n",
          "commitDate": "06/02/18 2:36 PM",
          "commitName": "814d701d46b4ff87f6ec94ba39667c80475c38d7",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "06/02/18 1:43 PM",
          "commitNameOld": "4304fcd5bdf9fb7aa9181e866eea383f89bf171f",
          "commitAuthorOld": "Anu Engineer",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,162 +1,141 @@\n   private void loadQueue(String parentName, Element element,\n-      Map\u003cString, Resource\u003e minQueueResources,\n-      Map\u003cString, ConfigurableResource\u003e maxQueueResources,\n-      Map\u003cString, ConfigurableResource\u003e maxChildQueueResources,\n-      Map\u003cString, Integer\u003e queueMaxApps,\n-      Map\u003cString, Integer\u003e userMaxApps,\n-      Map\u003cString, Float\u003e queueMaxAMShares,\n-      Map\u003cString, Float\u003e queueWeights,\n-      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n-      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n-      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n-      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n-      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n-      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n-      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n-      Set\u003cString\u003e reservableQueues,\n-      Set\u003cString\u003e nonPreemptableQueues)\n-      throws AllocationConfigurationException {\n-    String queueName \u003d FairSchedulerUtilities.trimQueueName(\n-        element.getAttribute(\"name\"));\n+      QueueProperties.Builder builder) throws AllocationConfigurationException {\n+    String queueName \u003d\n+        FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n-    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n-    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element)) {\n         continue;\n       }\n       Element field \u003d (Element) fieldNode;\n-      if (\"minResources\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+      if (MIN_RESOURCES.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n-        minQueueResources.put(queueName, val.getResource());\n-      } else if (\"maxResources\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.minQueueResources(queueName, val.getResource());\n+      } else if (MAX_RESOURCES.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n-        maxQueueResources.put(queueName, val);\n-      } else if (\"maxChildResources\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.maxQueueResources(queueName, val);\n+      } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n-        maxChildQueueResources.put(queueName, val);\n-      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.maxChildQueueResources(queueName, val);\n+      } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         int val \u003d Integer.parseInt(text);\n-        queueMaxApps.put(queueName, val);\n-      } else if (\"maxAMShare\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.queueMaxApps(queueName, val);\n+      } else if (MAX_AMSHARE.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n-        queueMaxAMShares.put(queueName, val);\n-      } else if (\"weight\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.queueMaxAMShares(queueName, val);\n+      } else if (WEIGHT.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         double val \u003d Double.parseDouble(text);\n-        queueWeights.put(queueName, (float)val);\n-      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.queueWeights(queueName, (float) val);\n+      } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n-        minSharePreemptionTimeouts.put(queueName, val);\n-      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.minSharePreemptionTimeouts(queueName, val);\n+      } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n-        fairSharePreemptionTimeouts.put(queueName, val);\n-      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.fairSharePreemptionTimeouts(queueName, val);\n+      } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n-        fairSharePreemptionThresholds.put(queueName, val);\n-      } else if (\"schedulingPolicy\".equals(field.getTagName())\n-          || \"schedulingMode\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.fairSharePreemptionThresholds(queueName, val);\n+      } else if (SCHEDULING_POLICY.equals(field.getTagName())\n+          || SCHEDULING_MODE.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n-        queuePolicies.put(queueName, policy);\n-      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n-      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n-      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n-                new AccessControlList(text));\n-      } else if (\"aclListReservations\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n-                text));\n-      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n-                new AccessControlList(text));\n-      } else if (\"reservation\".equals(field.getTagName())) {\n+        builder.queuePolicies(queueName, policy);\n+      } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n+            new AccessControlList(text));\n+      } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n+            new AccessControlList(text));\n+      } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.reservationAcls(queueName,\n+            ReservationACL.ADMINISTER_RESERVATIONS,\n+            new AccessControlList(text));\n+      } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n+            new AccessControlList(text));\n+      } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n+            new AccessControlList(text));\n+      } else if (RESERVATION.equals(field.getTagName())) {\n         isReservable \u003d true;\n-        reservableQueues.add(queueName);\n-        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n-      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.reservableQueues(queueName);\n+        builder.configuredQueues(FSQueueType.PARENT, queueName);\n+      } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         if (!Boolean.parseBoolean(text)) {\n-          nonPreemptableQueues.add(queueName);\n+          builder.nonPreemptableQueues(queueName);\n         }\n-      } else if (\"queue\".endsWith(field.getTagName()) || \n-          \"pool\".equals(field.getTagName())) {\n-        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n-            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n-            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n-            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n-            queueAcls, resAcls, configuredQueues, reservableQueues,\n-            nonPreemptableQueues);\n+      } else if (QUEUE.endsWith(field.getTagName())\n+          || POOL.equals(field.getTagName())) {\n+        loadQueue(queueName, field, builder);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n-      configuredQueues.get(FSQueueType.LEAF).add(queueName);\n+      builder.configuredQueues(FSQueueType.LEAF, queueName);\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n-      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n+      builder.configuredQueues(FSQueueType.PARENT, queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n-      if (acls.get(accessType) \u003d\u003d null){\n-        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n-            EVERYBODY_ACL : NOBODY_ACL;\n-        acls.put(accessType, defaultAcl);\n+      if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n+        AccessControlList defaultAcl \u003d\n+            queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n+        builder.queueAcls(queueName, accessType, defaultAcl);\n       }\n     }\n \n-    queueAcls.put(queueName, acls);\n-    resAcls.put(queueName, racls);\n-    checkMinAndMaxResource(minQueueResources, maxQueueResources, queueName);\n+    checkMinAndMaxResource(builder.getMinQueueResources(),\n+        builder.getMaxQueueResources(), queueName);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      QueueProperties.Builder builder) throws AllocationConfigurationException {\n    String queueName \u003d\n        FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (MIN_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.minQueueResources(queueName, val.getResource());\n      } else if (MAX_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxQueueResources(queueName, val);\n      } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxChildQueueResources(queueName, val);\n      } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        int val \u003d Integer.parseInt(text);\n        builder.queueMaxApps(queueName, val);\n      } else if (MAX_AMSHARE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        builder.queueMaxAMShares(queueName, val);\n      } else if (WEIGHT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        double val \u003d Double.parseDouble(text);\n        builder.queueWeights(queueName, (float) val);\n      } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.minSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.fairSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        builder.fairSharePreemptionThresholds(queueName, val);\n      } else if (SCHEDULING_POLICY.equals(field.getTagName())\n          || SCHEDULING_MODE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        builder.queuePolicies(queueName, policy);\n      } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName,\n            ReservationACL.ADMINISTER_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (RESERVATION.equals(field.getTagName())) {\n        isReservable \u003d true;\n        builder.reservableQueues(queueName);\n        builder.configuredQueues(FSQueueType.PARENT, queueName);\n      } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        if (!Boolean.parseBoolean(text)) {\n          builder.nonPreemptableQueues(queueName);\n        }\n      } else if (QUEUE.endsWith(field.getTagName())\n          || POOL.equals(field.getTagName())) {\n        loadQueue(queueName, field, builder);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      builder.configuredQueues(FSQueueType.LEAF, queueName);\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      builder.configuredQueues(FSQueueType.PARENT, queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n        AccessControlList defaultAcl \u003d\n            queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n        builder.queueAcls(queueName, accessType, defaultAcl);\n      }\n    }\n\n    checkMinAndMaxResource(builder.getMinQueueResources(),\n        builder.getMaxQueueResources(), queueName);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/allocation/AllocationFileQueueParser.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-7841. Cleanup AllocationFileLoaderService\u0027s reloadAllocations method (snemeth via rkanter)\n",
          "commitDate": "06/02/18 2:36 PM",
          "commitName": "814d701d46b4ff87f6ec94ba39667c80475c38d7",
          "commitAuthor": "Robert Kanter",
          "commitDateOld": "06/02/18 1:43 PM",
          "commitNameOld": "4304fcd5bdf9fb7aa9181e866eea383f89bf171f",
          "commitAuthorOld": "Anu Engineer",
          "daysBetweenCommits": 0.04,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,162 +1,141 @@\n   private void loadQueue(String parentName, Element element,\n-      Map\u003cString, Resource\u003e minQueueResources,\n-      Map\u003cString, ConfigurableResource\u003e maxQueueResources,\n-      Map\u003cString, ConfigurableResource\u003e maxChildQueueResources,\n-      Map\u003cString, Integer\u003e queueMaxApps,\n-      Map\u003cString, Integer\u003e userMaxApps,\n-      Map\u003cString, Float\u003e queueMaxAMShares,\n-      Map\u003cString, Float\u003e queueWeights,\n-      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n-      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n-      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n-      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n-      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n-      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n-      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n-      Set\u003cString\u003e reservableQueues,\n-      Set\u003cString\u003e nonPreemptableQueues)\n-      throws AllocationConfigurationException {\n-    String queueName \u003d FairSchedulerUtilities.trimQueueName(\n-        element.getAttribute(\"name\"));\n+      QueueProperties.Builder builder) throws AllocationConfigurationException {\n+    String queueName \u003d\n+        FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n-    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n-    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element)) {\n         continue;\n       }\n       Element field \u003d (Element) fieldNode;\n-      if (\"minResources\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+      if (MIN_RESOURCES.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n-        minQueueResources.put(queueName, val.getResource());\n-      } else if (\"maxResources\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.minQueueResources(queueName, val.getResource());\n+      } else if (MAX_RESOURCES.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n-        maxQueueResources.put(queueName, val);\n-      } else if (\"maxChildResources\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.maxQueueResources(queueName, val);\n+      } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n-        maxChildQueueResources.put(queueName, val);\n-      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.maxChildQueueResources(queueName, val);\n+      } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         int val \u003d Integer.parseInt(text);\n-        queueMaxApps.put(queueName, val);\n-      } else if (\"maxAMShare\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.queueMaxApps(queueName, val);\n+      } else if (MAX_AMSHARE.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n-        queueMaxAMShares.put(queueName, val);\n-      } else if (\"weight\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.queueMaxAMShares(queueName, val);\n+      } else if (WEIGHT.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         double val \u003d Double.parseDouble(text);\n-        queueWeights.put(queueName, (float)val);\n-      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.queueWeights(queueName, (float) val);\n+      } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n-        minSharePreemptionTimeouts.put(queueName, val);\n-      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.minSharePreemptionTimeouts(queueName, val);\n+      } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         long val \u003d Long.parseLong(text) * 1000L;\n-        fairSharePreemptionTimeouts.put(queueName, val);\n-      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.fairSharePreemptionTimeouts(queueName, val);\n+      } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n-        fairSharePreemptionThresholds.put(queueName, val);\n-      } else if (\"schedulingPolicy\".equals(field.getTagName())\n-          || \"schedulingMode\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.fairSharePreemptionThresholds(queueName, val);\n+      } else if (SCHEDULING_POLICY.equals(field.getTagName())\n+          || SCHEDULING_MODE.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n-        queuePolicies.put(queueName, policy);\n-      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n-      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n-      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n-                new AccessControlList(text));\n-      } else if (\"aclListReservations\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n-                text));\n-      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n-        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n-                new AccessControlList(text));\n-      } else if (\"reservation\".equals(field.getTagName())) {\n+        builder.queuePolicies(queueName, policy);\n+      } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n+            new AccessControlList(text));\n+      } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n+            new AccessControlList(text));\n+      } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.reservationAcls(queueName,\n+            ReservationACL.ADMINISTER_RESERVATIONS,\n+            new AccessControlList(text));\n+      } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n+            new AccessControlList(text));\n+      } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n+        String text \u003d ((Text) field.getFirstChild()).getData();\n+        builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n+            new AccessControlList(text));\n+      } else if (RESERVATION.equals(field.getTagName())) {\n         isReservable \u003d true;\n-        reservableQueues.add(queueName);\n-        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n-      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        builder.reservableQueues(queueName);\n+        builder.configuredQueues(FSQueueType.PARENT, queueName);\n+      } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n+        String text \u003d getTrimmedTextData(field);\n         if (!Boolean.parseBoolean(text)) {\n-          nonPreemptableQueues.add(queueName);\n+          builder.nonPreemptableQueues(queueName);\n         }\n-      } else if (\"queue\".endsWith(field.getTagName()) || \n-          \"pool\".equals(field.getTagName())) {\n-        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n-            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n-            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n-            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n-            queueAcls, resAcls, configuredQueues, reservableQueues,\n-            nonPreemptableQueues);\n+      } else if (QUEUE.endsWith(field.getTagName())\n+          || POOL.equals(field.getTagName())) {\n+        loadQueue(queueName, field, builder);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n-      configuredQueues.get(FSQueueType.LEAF).add(queueName);\n+      builder.configuredQueues(FSQueueType.LEAF, queueName);\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n-      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n+      builder.configuredQueues(FSQueueType.PARENT, queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n-      if (acls.get(accessType) \u003d\u003d null){\n-        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n-            EVERYBODY_ACL : NOBODY_ACL;\n-        acls.put(accessType, defaultAcl);\n+      if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n+        AccessControlList defaultAcl \u003d\n+            queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n+        builder.queueAcls(queueName, accessType, defaultAcl);\n       }\n     }\n \n-    queueAcls.put(queueName, acls);\n-    resAcls.put(queueName, racls);\n-    checkMinAndMaxResource(minQueueResources, maxQueueResources, queueName);\n+    checkMinAndMaxResource(builder.getMinQueueResources(),\n+        builder.getMaxQueueResources(), queueName);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      QueueProperties.Builder builder) throws AllocationConfigurationException {\n    String queueName \u003d\n        FairSchedulerUtilities.trimQueueName(element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (MIN_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.minQueueResources(queueName, val.getResource());\n      } else if (MAX_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxQueueResources(queueName, val);\n      } else if (MAX_CHILD_RESOURCES.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        builder.maxChildQueueResources(queueName, val);\n      } else if (MAX_RUNNING_APPS.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        int val \u003d Integer.parseInt(text);\n        builder.queueMaxApps(queueName, val);\n      } else if (MAX_AMSHARE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        builder.queueMaxAMShares(queueName, val);\n      } else if (WEIGHT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        double val \u003d Double.parseDouble(text);\n        builder.queueWeights(queueName, (float) val);\n      } else if (MIN_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.minSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_TIMEOUT.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        long val \u003d Long.parseLong(text) * 1000L;\n        builder.fairSharePreemptionTimeouts(queueName, val);\n      } else if (FAIR_SHARE_PREEMPTION_THRESHOLD.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        builder.fairSharePreemptionThresholds(queueName, val);\n      } else if (SCHEDULING_POLICY.equals(field.getTagName())\n          || SCHEDULING_MODE.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        builder.queuePolicies(queueName, policy);\n      } else if (ACL_SUBMIT_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.SUBMIT_APP,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_APPS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.queueAcls(queueName, AccessType.ADMINISTER_QUEUE,\n            new AccessControlList(text));\n      } else if (ACL_ADMINISTER_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName,\n            ReservationACL.ADMINISTER_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_LIST_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.LIST_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (ACL_SUBMIT_RESERVATIONS.equals(field.getTagName())) {\n        String text \u003d ((Text) field.getFirstChild()).getData();\n        builder.reservationAcls(queueName, ReservationACL.SUBMIT_RESERVATIONS,\n            new AccessControlList(text));\n      } else if (RESERVATION.equals(field.getTagName())) {\n        isReservable \u003d true;\n        builder.reservableQueues(queueName);\n        builder.configuredQueues(FSQueueType.PARENT, queueName);\n      } else if (ALLOW_PREEMPTION_FROM.equals(field.getTagName())) {\n        String text \u003d getTrimmedTextData(field);\n        if (!Boolean.parseBoolean(text)) {\n          builder.nonPreemptableQueues(queueName);\n        }\n      } else if (QUEUE.endsWith(field.getTagName())\n          || POOL.equals(field.getTagName())) {\n        loadQueue(queueName, field, builder);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      builder.configuredQueues(FSQueueType.LEAF, queueName);\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      builder.configuredQueues(FSQueueType.PARENT, queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (!builder.isAclDefinedForAccessType(queueName, accessType)) {\n        AccessControlList defaultAcl \u003d\n            queueName.equals(ROOT) ? EVERYBODY_ACL : NOBODY_ACL;\n        builder.queueAcls(queueName, accessType, defaultAcl);\n      }\n    }\n\n    checkMinAndMaxResource(builder.getMinQueueResources(),\n        builder.getMaxQueueResources(), queueName);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/allocation/AllocationFileQueueParser.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,ConfigurableResource\u003e, maxChildQueueResources-Map\u003cString,ConfigurableResource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,Float\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cAccessType,AccessControlList\u003e\u003e, resAcls-Map\u003cString,Map\u003cReservationACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e, nonPreemptableQueues-Set\u003cString\u003e]",
            "newValue": "[parentName-String, element-Element, builder-QueueProperties.Builder]"
          }
        }
      ]
    },
    "99292adcefdc6b8f280b8e100605fb39f755c38a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2162. Add ability in Fair Scheduler to optionally configure maxResources in terms of percentage. (Yufei Gu)\n",
      "commitDate": "05/10/17 11:51 PM",
      "commitName": "99292adcefdc6b8f280b8e100605fb39f755c38a",
      "commitAuthor": "Yufei Gu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2162. Add ability in Fair Scheduler to optionally configure maxResources in terms of percentage. (Yufei Gu)\n",
          "commitDate": "05/10/17 11:51 PM",
          "commitName": "99292adcefdc6b8f280b8e100605fb39f755c38a",
          "commitAuthor": "Yufei Gu",
          "commitDateOld": "14/09/17 11:23 AM",
          "commitNameOld": "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
          "commitAuthorOld": "Yufei Gu",
          "daysBetweenCommits": 21.52,
          "commitsBetweenForRepo": 160,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,170 +1,162 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n-      Map\u003cString, Resource\u003e maxQueueResources,\n-      Map\u003cString, Resource\u003e maxChildQueueResources,\n+      Map\u003cString, ConfigurableResource\u003e maxQueueResources,\n+      Map\u003cString, ConfigurableResource\u003e maxChildQueueResources,\n       Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps,\n       Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, Float\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d FairSchedulerUtilities.trimQueueName(\n         element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element)) {\n         continue;\n       }\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        Resource val \u003d\n+        ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n-        minQueueResources.put(queueName, val);\n+        minQueueResources.put(queueName, val.getResource());\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        Resource val \u003d\n+        ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxChildResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        Resource val \u003d\n+        ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxChildQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, (float)val);\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isReservable \u003d true;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n             queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n       configuredQueues.get(FSQueueType.LEAF).add(queueName);\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (acls.get(accessType) \u003d\u003d null){\n         AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n             EVERYBODY_ACL : NOBODY_ACL;\n         acls.put(accessType, defaultAcl);\n       }\n     }\n \n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n-    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n-        minQueueResources.containsKey(queueName)\n-        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n-            maxQueueResources.get(queueName))) {\n-      LOG.warn(\n-          String.format(\"Queue %s has max resources %s less than \"\n-              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n-              minQueueResources.get(queueName)));\n-    }\n+    checkMinAndMaxResource(minQueueResources, maxQueueResources, queueName);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, ConfigurableResource\u003e maxQueueResources,\n      Map\u003cString, ConfigurableResource\u003e maxChildQueueResources,\n      Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps,\n      Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, Float\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d FairSchedulerUtilities.trimQueueName(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val.getResource());\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxChildResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxChildQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, (float)val);\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isReservable \u003d true;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      configuredQueues.get(FSQueueType.LEAF).add(queueName);\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (acls.get(accessType) \u003d\u003d null){\n        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n            EVERYBODY_ACL : NOBODY_ACL;\n        acls.put(accessType, defaultAcl);\n      }\n    }\n\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    checkMinAndMaxResource(minQueueResources, maxQueueResources, queueName);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, maxChildQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,Float\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cAccessType,AccessControlList\u003e\u003e, resAcls-Map\u003cString,Map\u003cReservationACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e, nonPreemptableQueues-Set\u003cString\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,ConfigurableResource\u003e, maxChildQueueResources-Map\u003cString,ConfigurableResource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,Float\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cAccessType,AccessControlList\u003e\u003e, resAcls-Map\u003cString,Map\u003cReservationACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e, nonPreemptableQueues-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2162. Add ability in Fair Scheduler to optionally configure maxResources in terms of percentage. (Yufei Gu)\n",
          "commitDate": "05/10/17 11:51 PM",
          "commitName": "99292adcefdc6b8f280b8e100605fb39f755c38a",
          "commitAuthor": "Yufei Gu",
          "commitDateOld": "14/09/17 11:23 AM",
          "commitNameOld": "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
          "commitAuthorOld": "Yufei Gu",
          "daysBetweenCommits": 21.52,
          "commitsBetweenForRepo": 160,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,170 +1,162 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n-      Map\u003cString, Resource\u003e maxQueueResources,\n-      Map\u003cString, Resource\u003e maxChildQueueResources,\n+      Map\u003cString, ConfigurableResource\u003e maxQueueResources,\n+      Map\u003cString, ConfigurableResource\u003e maxChildQueueResources,\n       Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps,\n       Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, Float\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d FairSchedulerUtilities.trimQueueName(\n         element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element)) {\n         continue;\n       }\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        Resource val \u003d\n+        ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n-        minQueueResources.put(queueName, val);\n+        minQueueResources.put(queueName, val.getResource());\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        Resource val \u003d\n+        ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxChildResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        Resource val \u003d\n+        ConfigurableResource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxChildQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, (float)val);\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isReservable \u003d true;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n             queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n       configuredQueues.get(FSQueueType.LEAF).add(queueName);\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (acls.get(accessType) \u003d\u003d null){\n         AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n             EVERYBODY_ACL : NOBODY_ACL;\n         acls.put(accessType, defaultAcl);\n       }\n     }\n \n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n-    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n-        minQueueResources.containsKey(queueName)\n-        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n-            maxQueueResources.get(queueName))) {\n-      LOG.warn(\n-          String.format(\"Queue %s has max resources %s less than \"\n-              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n-              minQueueResources.get(queueName)));\n-    }\n+    checkMinAndMaxResource(minQueueResources, maxQueueResources, queueName);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, ConfigurableResource\u003e maxQueueResources,\n      Map\u003cString, ConfigurableResource\u003e maxChildQueueResources,\n      Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps,\n      Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, Float\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d FairSchedulerUtilities.trimQueueName(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val.getResource());\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxChildResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        ConfigurableResource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxChildQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, (float)val);\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isReservable \u003d true;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      configuredQueues.get(FSQueueType.LEAF).add(queueName);\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (acls.get(accessType) \u003d\u003d null){\n        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n            EVERYBODY_ACL : NOBODY_ACL;\n        acls.put(accessType, defaultAcl);\n      }\n    }\n\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    checkMinAndMaxResource(minQueueResources, maxQueueResources, queueName);\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        }
      ]
    },
    "09b476e6dabe8039a41dde7930c8a9c0d14bb750": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-6612. Update fair scheduler policies to be aware of resource types. (Contributed by Daniel Templeton via Yufei Gu)\n",
      "commitDate": "14/09/17 11:23 AM",
      "commitName": "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
      "commitAuthor": "Yufei Gu",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-6612. Update fair scheduler policies to be aware of resource types. (Contributed by Daniel Templeton via Yufei Gu)\n",
          "commitDate": "14/09/17 11:23 AM",
          "commitName": "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
          "commitAuthor": "Yufei Gu",
          "commitDateOld": "11/08/17 2:50 PM",
          "commitNameOld": "0996acde6c325667aa19ae0740eb6b40bf4a682a",
          "commitAuthorOld": "Daniel Templeton",
          "daysBetweenCommits": 33.86,
          "commitsBetweenForRepo": 320,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,170 +1,170 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources,\n       Map\u003cString, Resource\u003e maxChildQueueResources,\n       Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps,\n       Map\u003cString, Float\u003e queueMaxAMShares,\n-      Map\u003cString, ResourceWeights\u003e queueWeights,\n+      Map\u003cString, Float\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d FairSchedulerUtilities.trimQueueName(\n         element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element)) {\n         continue;\n       }\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxChildResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxChildQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n-        queueWeights.put(queueName, new ResourceWeights((float)val));\n+        queueWeights.put(queueName, (float)val);\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isReservable \u003d true;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n             queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n       configuredQueues.get(FSQueueType.LEAF).add(queueName);\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (acls.get(accessType) \u003d\u003d null){\n         AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n             EVERYBODY_ACL : NOBODY_ACL;\n         acls.put(accessType, defaultAcl);\n       }\n     }\n \n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\"Queue %s has max resources %s less than \"\n               + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources,\n      Map\u003cString, Resource\u003e maxChildQueueResources,\n      Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps,\n      Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, Float\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d FairSchedulerUtilities.trimQueueName(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxChildResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxChildQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, (float)val);\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isReservable \u003d true;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      configuredQueues.get(FSQueueType.LEAF).add(queueName);\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (acls.get(accessType) \u003d\u003d null){\n        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n            EVERYBODY_ACL : NOBODY_ACL;\n        acls.put(accessType, defaultAcl);\n      }\n    }\n\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\"Queue %s has max resources %s less than \"\n              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, maxChildQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cAccessType,AccessControlList\u003e\u003e, resAcls-Map\u003cString,Map\u003cReservationACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e, nonPreemptableQueues-Set\u003cString\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, maxChildQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,Float\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cAccessType,AccessControlList\u003e\u003e, resAcls-Map\u003cString,Map\u003cReservationACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e, nonPreemptableQueues-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-6612. Update fair scheduler policies to be aware of resource types. (Contributed by Daniel Templeton via Yufei Gu)\n",
          "commitDate": "14/09/17 11:23 AM",
          "commitName": "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
          "commitAuthor": "Yufei Gu",
          "commitDateOld": "11/08/17 2:50 PM",
          "commitNameOld": "0996acde6c325667aa19ae0740eb6b40bf4a682a",
          "commitAuthorOld": "Daniel Templeton",
          "daysBetweenCommits": 33.86,
          "commitsBetweenForRepo": 320,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,170 +1,170 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources,\n       Map\u003cString, Resource\u003e maxChildQueueResources,\n       Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps,\n       Map\u003cString, Float\u003e queueMaxAMShares,\n-      Map\u003cString, ResourceWeights\u003e queueWeights,\n+      Map\u003cString, Float\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d FairSchedulerUtilities.trimQueueName(\n         element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element)) {\n         continue;\n       }\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxChildResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxChildQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n-        queueWeights.put(queueName, new ResourceWeights((float)val));\n+        queueWeights.put(queueName, (float)val);\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isReservable \u003d true;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n             queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n       configuredQueues.get(FSQueueType.LEAF).add(queueName);\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (acls.get(accessType) \u003d\u003d null){\n         AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n             EVERYBODY_ACL : NOBODY_ACL;\n         acls.put(accessType, defaultAcl);\n       }\n     }\n \n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\"Queue %s has max resources %s less than \"\n               + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources,\n      Map\u003cString, Resource\u003e maxChildQueueResources,\n      Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps,\n      Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, Float\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d FairSchedulerUtilities.trimQueueName(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxChildResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxChildQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, (float)val);\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isReservable \u003d true;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      configuredQueues.get(FSQueueType.LEAF).add(queueName);\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (acls.get(accessType) \u003d\u003d null){\n        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n            EVERYBODY_ACL : NOBODY_ACL;\n        acls.put(accessType, defaultAcl);\n      }\n    }\n\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\"Queue %s has max resources %s less than \"\n              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        }
      ]
    },
    "c7680d4cc4d9302a5b5efcf2467bd32ecea99585": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6884. AllocationFileLoaderService.loadQueue() has an if without braces\n(Contributed by weiyuan via Daniel Templeton)\n",
      "commitDate": "11/08/17 2:22 PM",
      "commitName": "c7680d4cc4d9302a5b5efcf2467bd32ecea99585",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "09/05/17 9:22 AM",
      "commitNameOld": "543aac9f281871a40473e83061f6deadc0bbdab7",
      "commitAuthorOld": "Andrew Wang",
      "daysBetweenCommits": 94.21,
      "commitsBetweenForRepo": 546,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,169 +1,170 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources,\n       Map\u003cString, Resource\u003e maxChildQueueResources,\n       Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps,\n       Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d FairSchedulerUtilities.trimQueueName(\n         element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n-      if (!(fieldNode instanceof Element))\n+      if (!(fieldNode instanceof Element)) {\n         continue;\n+      }\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxChildResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxChildQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isReservable \u003d true;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n             queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n       configuredQueues.get(FSQueueType.LEAF).add(queueName);\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (acls.get(accessType) \u003d\u003d null){\n         AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n             EVERYBODY_ACL : NOBODY_ACL;\n         acls.put(accessType, defaultAcl);\n       }\n     }\n \n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\"Queue %s has max resources %s less than \"\n               + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources,\n      Map\u003cString, Resource\u003e maxChildQueueResources,\n      Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps,\n      Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d FairSchedulerUtilities.trimQueueName(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element)) {\n        continue;\n      }\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxChildResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxChildQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isReservable \u003d true;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      configuredQueues.get(FSQueueType.LEAF).add(queueName);\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (acls.get(accessType) \u003d\u003d null){\n        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n            EVERYBODY_ACL : NOBODY_ACL;\n        acls.put(accessType, defaultAcl);\n      }\n    }\n\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\"Queue %s has max resources %s less than \"\n              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "543aac9f281871a40473e83061f6deadc0bbdab7": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-14386. Rewind trunk from Guava 21.0 back to Guava 11.0.2.\n",
      "commitDate": "09/05/17 9:22 AM",
      "commitName": "543aac9f281871a40473e83061f6deadc0bbdab7",
      "commitAuthor": "Andrew Wang",
      "commitDateOld": "24/03/17 6:06 PM",
      "commitNameOld": "84ddedc0b2d58257d45c16ee5e83b15f94a7ba3a",
      "commitAuthorOld": "Tsuyoshi Ozawa",
      "daysBetweenCommits": 45.64,
      "commitsBetweenForRepo": 254,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,169 +1,169 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources,\n       Map\u003cString, Resource\u003e maxChildQueueResources,\n       Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps,\n       Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n-    String queueName \u003d CharMatcher.whitespace().trimFrom(\n+    String queueName \u003d FairSchedulerUtilities.trimQueueName(\n         element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxChildResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxChildQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isReservable \u003d true;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n             queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n       configuredQueues.get(FSQueueType.LEAF).add(queueName);\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (acls.get(accessType) \u003d\u003d null){\n         AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n             EVERYBODY_ACL : NOBODY_ACL;\n         acls.put(accessType, defaultAcl);\n       }\n     }\n \n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\"Queue %s has max resources %s less than \"\n               + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources,\n      Map\u003cString, Resource\u003e maxChildQueueResources,\n      Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps,\n      Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d FairSchedulerUtilities.trimQueueName(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxChildResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxChildQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isReservable \u003d true;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      configuredQueues.get(FSQueueType.LEAF).add(queueName);\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (acls.get(accessType) \u003d\u003d null){\n        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n            EVERYBODY_ACL : NOBODY_ACL;\n        acls.put(accessType, defaultAcl);\n      }\n    }\n\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\"Queue %s has max resources %s less than \"\n              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "84ddedc0b2d58257d45c16ee5e83b15f94a7ba3a": {
      "type": "Ybodychange",
      "commitMessage": "HADOOP-10101. Update guava dependency to the latest version. (ozawa)\n",
      "commitDate": "24/03/17 6:06 PM",
      "commitName": "84ddedc0b2d58257d45c16ee5e83b15f94a7ba3a",
      "commitAuthor": "Tsuyoshi Ozawa",
      "commitDateOld": "26/01/17 10:31 AM",
      "commitNameOld": "f85b74ccf9f1c1c1444cc00750b03468cbf40fb9",
      "commitAuthorOld": "Daniel Templeton",
      "daysBetweenCommits": 57.27,
      "commitsBetweenForRepo": 309,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,169 +1,169 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources,\n       Map\u003cString, Resource\u003e maxChildQueueResources,\n       Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps,\n       Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n-    String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n+    String queueName \u003d CharMatcher.whitespace().trimFrom(\n         element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n     boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxChildResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxChildQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isReservable \u003d true;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n             queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n \n     // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n     // then store it as a parent queue\n     if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n       configuredQueues.get(FSQueueType.LEAF).add(queueName);\n     } else {\n       if (isReservable) {\n         throw new AllocationConfigurationException(\"The configuration settings\"\n             + \" for \" + queueName + \" are invalid. A queue element that \"\n             + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n             + \"attribute cannot also include a reservation element.\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n \n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (acls.get(accessType) \u003d\u003d null){\n         AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n             EVERYBODY_ACL : NOBODY_ACL;\n         acls.put(accessType, defaultAcl);\n       }\n     }\n \n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\"Queue %s has max resources %s less than \"\n               + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources,\n      Map\u003cString, Resource\u003e maxChildQueueResources,\n      Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps,\n      Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d CharMatcher.whitespace().trimFrom(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxChildResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxChildQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isReservable \u003d true;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      configuredQueues.get(FSQueueType.LEAF).add(queueName);\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (acls.get(accessType) \u003d\u003d null){\n        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n            EVERYBODY_ACL : NOBODY_ACL;\n        acls.put(accessType, defaultAcl);\n      }\n    }\n\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\"Queue %s has max resources %s less than \"\n              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "f85b74ccf9f1c1c1444cc00750b03468cbf40fb9": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4975. Fair Scheduler: exception thrown when a parent queue marked \u0027parent\u0027 has configured child queues\n(Contributed by Yufei Gu via Daniel Templeton)\n",
      "commitDate": "26/01/17 10:31 AM",
      "commitName": "f85b74ccf9f1c1c1444cc00750b03468cbf40fb9",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "23/12/16 11:40 AM",
      "commitNameOld": "4d3f73acc0a5cabc748132889dbe670bea178a3f",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 33.95,
      "commitsBetweenForRepo": 164,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,169 +1,169 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources,\n       Map\u003cString, Resource\u003e maxChildQueueResources,\n       Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps,\n       Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n         element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n     Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n+    boolean isReservable \u003d false;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxChildResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxChildQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n-        isLeaf \u003d false;\n+        isReservable \u003d true;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n             queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n-    if (isLeaf) {\n-      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n-      // then store it under \u0027parent\u0027\n-      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n-        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n-      } else {\n-        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n-      }\n+\n+    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n+    // then store it as a parent queue\n+    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n+      configuredQueues.get(FSQueueType.LEAF).add(queueName);\n     } else {\n-      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n-        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n-            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n-            \"unsupported\");\n+      if (isReservable) {\n+        throw new AllocationConfigurationException(\"The configuration settings\"\n+            + \" for \" + queueName + \" are invalid. A queue element that \"\n+            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n+            + \"attribute cannot also include a reservation element.\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n+\n     // Set default acls if not defined\n     // The root queue defaults to all access\n     for (QueueACL acl : QueueACL.values()) {\n       AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n       if (acls.get(accessType) \u003d\u003d null){\n         AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n             EVERYBODY_ACL : NOBODY_ACL;\n         acls.put(accessType, defaultAcl);\n       }\n     }\n \n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\"Queue %s has max resources %s less than \"\n               + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources,\n      Map\u003cString, Resource\u003e maxChildQueueResources,\n      Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps,\n      Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n    boolean isReservable \u003d false;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxChildResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxChildQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isReservable \u003d true;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n\n    // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n    // then store it as a parent queue\n    if (isLeaf \u0026\u0026 !\"parent\".equals(element.getAttribute(\"type\"))) {\n      configuredQueues.get(FSQueueType.LEAF).add(queueName);\n    } else {\n      if (isReservable) {\n        throw new AllocationConfigurationException(\"The configuration settings\"\n            + \" for \" + queueName + \" are invalid. A queue element that \"\n            + \"contains child queue elements or that has the type\u003d\u0027parent\u0027 \"\n            + \"attribute cannot also include a reservation element.\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (acls.get(accessType) \u003d\u003d null){\n        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n            EVERYBODY_ACL : NOBODY_ACL;\n        acls.put(accessType, defaultAcl);\n      }\n    }\n\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\"Queue %s has max resources %s less than \"\n              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "b3befc021b0e2d63d1a3710ea450797d1129f1f5": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4997. Update fair scheduler to use pluggable auth provider (Contributed by Tao Jie via Daniel Templeton)\n",
      "commitDate": "30/11/16 9:50 AM",
      "commitName": "b3befc021b0e2d63d1a3710ea450797d1129f1f5",
      "commitAuthor": "Daniel Templeton",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4997. Update fair scheduler to use pluggable auth provider (Contributed by Tao Jie via Daniel Templeton)\n",
          "commitDate": "30/11/16 9:50 AM",
          "commitName": "b3befc021b0e2d63d1a3710ea450797d1129f1f5",
          "commitAuthor": "Daniel Templeton",
          "commitDateOld": "17/08/16 5:40 PM",
          "commitNameOld": "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 104.72,
          "commitsBetweenForRepo": 759,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,158 +1,169 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources,\n       Map\u003cString, Resource\u003e maxChildQueueResources,\n       Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps,\n       Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n-      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n+      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n         element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n-    Map\u003cQueueACL, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n+    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxChildResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxChildQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n-        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n+        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n-        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n+        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isLeaf \u003d false;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n             queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     } else {\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n             \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n             \"unsupported\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n+    // Set default acls if not defined\n+    // The root queue defaults to all access\n+    for (QueueACL acl : QueueACL.values()) {\n+      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n+      if (acls.get(accessType) \u003d\u003d null){\n+        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n+            EVERYBODY_ACL : NOBODY_ACL;\n+        acls.put(accessType, defaultAcl);\n+      }\n+    }\n+\n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\"Queue %s has max resources %s less than \"\n               + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources,\n      Map\u003cString, Resource\u003e maxChildQueueResources,\n      Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps,\n      Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxChildResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxChildQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isLeaf \u003d false;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    } else {\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n            \"unsupported\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (acls.get(accessType) \u003d\u003d null){\n        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n            EVERYBODY_ACL : NOBODY_ACL;\n        acls.put(accessType, defaultAcl);\n      }\n    }\n\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\"Queue %s has max resources %s less than \"\n              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, maxChildQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, resAcls-Map\u003cString,Map\u003cReservationACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e, nonPreemptableQueues-Set\u003cString\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, maxChildQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cAccessType,AccessControlList\u003e\u003e, resAcls-Map\u003cString,Map\u003cReservationACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e, nonPreemptableQueues-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4997. Update fair scheduler to use pluggable auth provider (Contributed by Tao Jie via Daniel Templeton)\n",
          "commitDate": "30/11/16 9:50 AM",
          "commitName": "b3befc021b0e2d63d1a3710ea450797d1129f1f5",
          "commitAuthor": "Daniel Templeton",
          "commitDateOld": "17/08/16 5:40 PM",
          "commitNameOld": "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 104.72,
          "commitsBetweenForRepo": 759,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,158 +1,169 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources,\n       Map\u003cString, Resource\u003e maxChildQueueResources,\n       Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps,\n       Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n-      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n+      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n         element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n \n-    Map\u003cQueueACL, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n+    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxChildResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d\n             FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxChildQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n-        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n+        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n-        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n+        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isLeaf \u003d false;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n             queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     } else {\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n             \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n             \"unsupported\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n+    // Set default acls if not defined\n+    // The root queue defaults to all access\n+    for (QueueACL acl : QueueACL.values()) {\n+      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n+      if (acls.get(accessType) \u003d\u003d null){\n+        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n+            EVERYBODY_ACL : NOBODY_ACL;\n+        acls.put(accessType, defaultAcl);\n+      }\n+    }\n+\n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\"Queue %s has max resources %s less than \"\n               + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources,\n      Map\u003cString, Resource\u003e maxChildQueueResources,\n      Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps,\n      Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cAccessType, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    Map\u003cAccessType, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxChildResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxChildQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.SUBMIT_APP, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(AccessType.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isLeaf \u003d false;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    } else {\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n            \"unsupported\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n    // Set default acls if not defined\n    // The root queue defaults to all access\n    for (QueueACL acl : QueueACL.values()) {\n      AccessType accessType \u003d SchedulerUtils.toAccessType(acl);\n      if (acls.get(accessType) \u003d\u003d null){\n        AccessControlList defaultAcl \u003d queueName.equals(ROOT) ?\n            EVERYBODY_ACL : NOBODY_ACL;\n        acls.put(accessType, defaultAcl);\n      }\n    }\n\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\"Queue %s has max resources %s less than \"\n              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        }
      ]
    },
    "20f0eb871c57cc4c5a6d19aae0e3745b6175509b": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4702. FairScheduler: Allow setting maxResources for ad hoc queues. (Daniel Templeton via kasha)\n",
      "commitDate": "17/08/16 5:40 PM",
      "commitName": "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4702. FairScheduler: Allow setting maxResources for ad hoc queues. (Daniel Templeton via kasha)\n",
          "commitDate": "17/08/16 5:40 PM",
          "commitName": "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "15/07/16 2:38 PM",
          "commitNameOld": "f5f1c81e7dcae0272e71ef4e6bedfc00b8c677d6",
          "commitAuthorOld": "Ray Chiang",
          "daysBetweenCommits": 33.13,
          "commitsBetweenForRepo": 222,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,149 +1,158 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n-      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n-      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n+      Map\u003cString, Resource\u003e maxQueueResources,\n+      Map\u003cString, Resource\u003e maxChildQueueResources,\n+      Map\u003cString, Integer\u003e queueMaxApps,\n+      Map\u003cString, Integer\u003e userMaxApps,\n+      Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n         element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n-    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n-        new HashMap\u003cQueueACL, AccessControlList\u003e();\n+\n+    Map\u003cQueueACL, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n+        Resource val \u003d\n+            FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n+        Resource val \u003d\n+            FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n+      } else if (\"maxChildResources\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        Resource val \u003d\n+            FairSchedulerConfiguration.parseResourceConfigValue(text);\n+        maxChildQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isLeaf \u003d false;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n-            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n-            queuePolicies, minSharePreemptionTimeouts,\n+            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n+            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     } else {\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n             \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n             \"unsupported\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n-          String.format(\n-              \"Queue %s has max resources %s less than min resources %s\",\n-          queueName, maxQueueResources.get(queueName),\n+          String.format(\"Queue %s has max resources %s less than \"\n+              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources,\n      Map\u003cString, Resource\u003e maxChildQueueResources,\n      Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps,\n      Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxChildResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxChildQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isLeaf \u003d false;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    } else {\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n            \"unsupported\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\"Queue %s has max resources %s less than \"\n              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, resAcls-Map\u003cString,Map\u003cReservationACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e, nonPreemptableQueues-Set\u003cString\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, maxChildQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, resAcls-Map\u003cString,Map\u003cReservationACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e, nonPreemptableQueues-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4702. FairScheduler: Allow setting maxResources for ad hoc queues. (Daniel Templeton via kasha)\n",
          "commitDate": "17/08/16 5:40 PM",
          "commitName": "20f0eb871c57cc4c5a6d19aae0e3745b6175509b",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "15/07/16 2:38 PM",
          "commitNameOld": "f5f1c81e7dcae0272e71ef4e6bedfc00b8c677d6",
          "commitAuthorOld": "Ray Chiang",
          "daysBetweenCommits": 33.13,
          "commitsBetweenForRepo": 222,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,149 +1,158 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n-      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n-      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n+      Map\u003cString, Resource\u003e maxQueueResources,\n+      Map\u003cString, Resource\u003e maxChildQueueResources,\n+      Map\u003cString, Integer\u003e queueMaxApps,\n+      Map\u003cString, Integer\u003e userMaxApps,\n+      Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n         element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n-    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n-        new HashMap\u003cQueueACL, AccessControlList\u003e();\n+\n+    Map\u003cQueueACL, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n+        Resource val \u003d\n+            FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n+        Resource val \u003d\n+            FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n+      } else if (\"maxChildResources\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        Resource val \u003d\n+            FairSchedulerConfiguration.parseResourceConfigValue(text);\n+        maxChildQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isLeaf \u003d false;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n-            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n-            queuePolicies, minSharePreemptionTimeouts,\n+            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n+            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     } else {\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n             \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n             \"unsupported\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n-          String.format(\n-              \"Queue %s has max resources %s less than min resources %s\",\n-          queueName, maxQueueResources.get(queueName),\n+          String.format(\"Queue %s has max resources %s less than \"\n+              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources,\n      Map\u003cString, Resource\u003e maxChildQueueResources,\n      Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps,\n      Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d new HashMap\u003c\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxChildResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d\n            FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxChildQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isLeaf \u003d false;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            maxChildQueueResources, queueMaxApps, userMaxApps, queueMaxAMShares,\n            queueWeights, queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    } else {\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n            \"unsupported\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\"Queue %s has max resources %s less than \"\n              + \"min resources %s\", queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        }
      ]
    },
    "f5f1c81e7dcae0272e71ef4e6bedfc00b8c677d6": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5272. Handle queue names consistently in FairScheduler. (Wilfred Spiegelenburg via rchiang)\n",
      "commitDate": "15/07/16 2:38 PM",
      "commitName": "f5f1c81e7dcae0272e71ef4e6bedfc00b8c677d6",
      "commitAuthor": "Ray Chiang",
      "commitDateOld": "20/04/16 11:58 PM",
      "commitNameOld": "170c4fd4cdbb8b4c1c4bb219e4c74fa0ba81b055",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 85.61,
      "commitsBetweenForRepo": 706,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,148 +1,149 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n-    String queueName \u003d element.getAttribute(\"name\").trim();\n+    String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n+        element.getAttribute(\"name\"));\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"aclListReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                 text));\n       } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                 new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isLeaf \u003d false;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n             queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     } else {\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n             \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n             \"unsupported\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\n               \"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d CharMatcher.WHITESPACE.trimFrom(\n        element.getAttribute(\"name\"));\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isLeaf \u003d false;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    } else {\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n            \"unsupported\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\n              \"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "23f937e3b718f607d4fc975610ab3a03265f0f7e": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2575. Create separate ACLs for Reservation create/update/delete/list ops (Sean Po via asuresh)\n",
      "commitDate": "11/02/16 10:47 AM",
      "commitName": "23f937e3b718f607d4fc975610ab3a03265f0f7e",
      "commitAuthor": "Arun Suresh",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2575. Create separate ACLs for Reservation create/update/delete/list ops (Sean Po via asuresh)\n",
          "commitDate": "11/02/16 10:47 AM",
          "commitName": "23f937e3b718f607d4fc975610ab3a03265f0f7e",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "27/01/16 12:29 PM",
          "commitNameOld": "fb238d7e5dcd96466c8938b13ca7f13cedecb08a",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 14.93,
          "commitsBetweenForRepo": 111,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,133 +1,148 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n+      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\").trim();\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n+    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n+      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData();\n+        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n+                new AccessControlList(text));\n+      } else if (\"aclListReservations\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData();\n+        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n+                text));\n+      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData();\n+        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n+                new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isLeaf \u003d false;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n             queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n-            queueAcls, configuredQueues, reservableQueues,\n+            queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     } else {\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n             \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n             \"unsupported\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n+    resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\n               \"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\").trim();\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isLeaf \u003d false;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    } else {\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n            \"unsupported\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\n              \"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e, nonPreemptableQueues-Set\u003cString\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, resAcls-Map\u003cString,Map\u003cReservationACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e, nonPreemptableQueues-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2575. Create separate ACLs for Reservation create/update/delete/list ops (Sean Po via asuresh)\n",
          "commitDate": "11/02/16 10:47 AM",
          "commitName": "23f937e3b718f607d4fc975610ab3a03265f0f7e",
          "commitAuthor": "Arun Suresh",
          "commitDateOld": "27/01/16 12:29 PM",
          "commitNameOld": "fb238d7e5dcd96466c8938b13ca7f13cedecb08a",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 14.93,
          "commitsBetweenForRepo": 111,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,133 +1,148 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n+      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues,\n       Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\").trim();\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n+    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n+      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData();\n+        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n+                new AccessControlList(text));\n+      } else if (\"aclListReservations\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData();\n+        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n+                text));\n+      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData();\n+        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n+                new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isLeaf \u003d false;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         if (!Boolean.parseBoolean(text)) {\n           nonPreemptableQueues.add(queueName);\n         }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n             queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n-            queueAcls, configuredQueues, reservableQueues,\n+            queueAcls, resAcls, configuredQueues, reservableQueues,\n             nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     } else {\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n             \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n             \"unsupported\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n+    resAcls.put(queueName, racls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\n               \"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cString, Map\u003cReservationACL, AccessControlList\u003e\u003e resAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\").trim();\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    Map\u003cReservationACL, AccessControlList\u003e racls \u003d new HashMap\u003c\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"aclAdministerReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.ADMINISTER_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"aclListReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.LIST_RESERVATIONS, new AccessControlList(\n                text));\n      } else if (\"aclSubmitReservations\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        racls.put(ReservationACL.SUBMIT_RESERVATIONS,\n                new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isLeaf \u003d false;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, resAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    } else {\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n            \"unsupported\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    resAcls.put(queueName, racls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\n              \"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        }
      ]
    },
    "fb238d7e5dcd96466c8938b13ca7f13cedecb08a": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-4462. FairScheduler: Disallow preemption from a queue. (Tao Jie via kasha)\n",
      "commitDate": "27/01/16 12:29 PM",
      "commitName": "fb238d7e5dcd96466c8938b13ca7f13cedecb08a",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-4462. FairScheduler: Disallow preemption from a queue. (Tao Jie via kasha)\n",
          "commitDate": "27/01/16 12:29 PM",
          "commitName": "fb238d7e5dcd96466c8938b13ca7f13cedecb08a",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "18/01/16 1:58 AM",
          "commitNameOld": "d40859fab1ad977636457a6cc96b6a4f9b903afc",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 9.44,
          "commitsBetweenForRepo": 70,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,126 +1,133 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n-      Set\u003cString\u003e reservableQueues)\n+      Set\u003cString\u003e reservableQueues,\n+      Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\").trim();\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isLeaf \u003d false;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n+      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        if (!Boolean.parseBoolean(text)) {\n+          nonPreemptableQueues.add(queueName);\n+        }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n             queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n-            queueAcls, configuredQueues, reservableQueues);\n+            queueAcls, configuredQueues, reservableQueues,\n+            nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     } else {\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n             \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n             \"unsupported\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\n               \"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\").trim();\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isLeaf \u003d false;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    } else {\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n            \"unsupported\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\n              \"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e, nonPreemptableQueues-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-4462. FairScheduler: Disallow preemption from a queue. (Tao Jie via kasha)\n",
          "commitDate": "27/01/16 12:29 PM",
          "commitName": "fb238d7e5dcd96466c8938b13ca7f13cedecb08a",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "18/01/16 1:58 AM",
          "commitNameOld": "d40859fab1ad977636457a6cc96b6a4f9b903afc",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 9.44,
          "commitsBetweenForRepo": 70,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,126 +1,133 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n-      Set\u003cString\u003e reservableQueues)\n+      Set\u003cString\u003e reservableQueues,\n+      Set\u003cString\u003e nonPreemptableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\").trim();\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (queueName.isEmpty()) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name shouldn\u0027t be empty or \"\n           + \"consist only of whitespace.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isLeaf \u003d false;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n+      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        if (!Boolean.parseBoolean(text)) {\n+          nonPreemptableQueues.add(queueName);\n+        }\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n             queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n-            queueAcls, configuredQueues, reservableQueues);\n+            queueAcls, configuredQueues, reservableQueues,\n+            nonPreemptableQueues);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     } else {\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n             \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n             \"unsupported\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\n               \"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues,\n      Set\u003cString\u003e nonPreemptableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\").trim();\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isLeaf \u003d false;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"allowPreemptionFrom\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        if (!Boolean.parseBoolean(text)) {\n          nonPreemptableQueues.add(queueName);\n        }\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, configuredQueues, reservableQueues,\n            nonPreemptableQueues);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    } else {\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n            \"unsupported\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\n              \"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        }
      ]
    },
    "2bc097cd14692e6ceb06bff959f28531534eb307": {
      "type": "Ybodychange",
      "commitMessage": "YARN-3241. FairScheduler handles invalid queue names inconsistently. (Zhihai Xu via kasha)\n",
      "commitDate": "23/03/15 1:22 PM",
      "commitName": "2bc097cd14692e6ceb06bff959f28531534eb307",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "17/03/15 12:31 PM",
      "commitNameOld": "32b43304563c2430c00bc3e142a962d2bc5f4d58",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 6.04,
      "commitsBetweenForRepo": 63,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,120 +1,126 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n       Set\u003cString\u003e reservableQueues)\n       throws AllocationConfigurationException {\n-    String queueName \u003d element.getAttribute(\"name\");\n+    String queueName \u003d element.getAttribute(\"name\").trim();\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n+    if (queueName.isEmpty()) {\n+      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n+          + \"file: queue name shouldn\u0027t be empty or \"\n+          + \"consist only of whitespace.\");\n+    }\n+\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"reservation\".equals(field.getTagName())) {\n         isLeaf \u003d false;\n         reservableQueues.add(queueName);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n             queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, configuredQueues, reservableQueues);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     } else {\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n             \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n             \"unsupported\");\n       }\n       configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\n               \"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\").trim();\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (queueName.isEmpty()) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name shouldn\u0027t be empty or \"\n          + \"consist only of whitespace.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isLeaf \u003d false;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, configuredQueues, reservableQueues);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    } else {\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n            \"unsupported\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\n              \"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "a22ffc318801698e86cd0e316b4824015f2486ac": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2738. [YARN-2574] Add FairReservationSystem for FairScheduler. (Anubhav Dhoot via kasha)\n",
      "commitDate": "19/12/14 3:37 PM",
      "commitName": "a22ffc318801698e86cd0e316b4824015f2486ac",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2738. [YARN-2574] Add FairReservationSystem for FairScheduler. (Anubhav Dhoot via kasha)\n",
          "commitDate": "19/12/14 3:37 PM",
          "commitName": "a22ffc318801698e86cd0e316b4824015f2486ac",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "21/11/14 4:06 PM",
          "commitNameOld": "a128cca305cecb215a2eef2ef543d1bf9b23a41b",
          "commitAuthorOld": "Sandy Ryza",
          "daysBetweenCommits": 27.98,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,109 +1,120 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n-      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n-      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n+      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n+      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n+      Set\u003cString\u003e reservableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n+      } else if (\"reservation\".equals(field.getTagName())) {\n+        isLeaf \u003d false;\n+        reservableQueues.add(queueName);\n+        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n             queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n-            queueAcls, configuredQueues);\n-        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n+            queueAcls, configuredQueues, reservableQueues);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n+    } else {\n+      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n+        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n+            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n+            \"unsupported\");\n+      }\n+      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\n               \"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isLeaf \u003d false;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, configuredQueues, reservableQueues);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    } else {\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n            \"unsupported\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\n              \"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e, reservableQueues-Set\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2738. [YARN-2574] Add FairReservationSystem for FairScheduler. (Anubhav Dhoot via kasha)\n",
          "commitDate": "19/12/14 3:37 PM",
          "commitName": "a22ffc318801698e86cd0e316b4824015f2486ac",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "21/11/14 4:06 PM",
          "commitNameOld": "a128cca305cecb215a2eef2ef543d1bf9b23a41b",
          "commitAuthorOld": "Sandy Ryza",
          "daysBetweenCommits": 27.98,
          "commitsBetweenForRepo": 195,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,109 +1,120 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n-      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n-      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n+      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n+      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n+      Set\u003cString\u003e reservableQueues)\n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n \n     if (queueName.contains(\".\")) {\n       throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n           + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n     }\n \n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n+      } else if (\"reservation\".equals(field.getTagName())) {\n+        isLeaf \u003d false;\n+        reservableQueues.add(queueName);\n+        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n             queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n-            queueAcls, configuredQueues);\n-        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n+            queueAcls, configuredQueues, reservableQueues);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n+    } else {\n+      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n+        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n+            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n+            \"unsupported\");\n+      }\n+      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\n               \"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls,\n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues,\n      Set\u003cString\u003e reservableQueues)\n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"reservation\".equals(field.getTagName())) {\n        isLeaf \u003d false;\n        reservableQueues.add(queueName);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, configuredQueues, reservableQueues);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    } else {\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        throw new AllocationConfigurationException(\"Both \u003creservation\u003e and \" +\n            \"type\u003d\\\"parent\\\" found for queue \" + queueName + \" which is \" +\n            \"unsupported\");\n      }\n      configuredQueues.get(FSQueueType.PARENT).add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\n              \"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        }
      ]
    },
    "a128cca305cecb215a2eef2ef543d1bf9b23a41b": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2669. FairScheduler: queue names shouldn\u0027t allow periods (Wei Yan via Sandy Ryza)\n",
      "commitDate": "21/11/14 4:06 PM",
      "commitName": "a128cca305cecb215a2eef2ef543d1bf9b23a41b",
      "commitAuthor": "Sandy Ryza",
      "commitDateOld": "22/09/14 4:09 PM",
      "commitNameOld": "43efdd30b52f4ee8967a03dac4d548095d6cafdb",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 60.04,
      "commitsBetweenForRepo": 578,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,103 +1,109 @@\n   private void loadQueue(String parentName, Element element,\n       Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n+\n+    if (queueName.contains(\".\")) {\n+      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n+          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n+    }\n+\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n         fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n             queuePolicies, minSharePreemptionTimeouts,\n             fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n             queueAcls, configuredQueues);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026\n         minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(\n           String.format(\n               \"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName),\n               minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n\n    if (queueName.contains(\".\")) {\n      throw new AllocationConfigurationException(\"Bad fair scheduler config \"\n          + \"file: queue name (\" + queueName + \") shouldn\u0027t contain period.\");\n    }\n\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, configuredQueues);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\n              \"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2394. FairScheduler: Configure fairSharePreemptionThreshold per queue. (Wei Yan via kasha)\n",
      "commitDate": "03/09/14 10:27 AM",
      "commitName": "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2394. FairScheduler: Configure fairSharePreemptionThreshold per queue. (Wei Yan via kasha)\n",
          "commitDate": "03/09/14 10:27 AM",
          "commitName": "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "30/08/14 1:17 AM",
          "commitNameOld": "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 4.38,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,91 +1,103 @@\n-  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n+  private void loadQueue(String parentName, Element element,\n+      Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n+      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n+      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        float val \u003d Float.parseFloat(text);\n+        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n+        fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n             queuePolicies, minSharePreemptionTimeouts,\n-            fairSharePreemptionTimeouts, queueAcls, configuredQueues);\n+            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n+            queueAcls, configuredQueues);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     }\n     queueAcls.put(queueName, acls);\n-    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n+    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n+        minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n-      LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n-          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n+      LOG.warn(\n+          String.format(\n+              \"Queue %s has max resources %s less than min resources %s\",\n+          queueName, maxQueueResources.get(queueName),\n+              minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, configuredQueues);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\n              \"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionThresholds-Map\u003cString,Float\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2394. FairScheduler: Configure fairSharePreemptionThreshold per queue. (Wei Yan via kasha)\n",
          "commitDate": "03/09/14 10:27 AM",
          "commitName": "1dcaba9a7aa27f7ca4ba693e3abb56ab3c59c8a7",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "30/08/14 1:17 AM",
          "commitNameOld": "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 4.38,
          "commitsBetweenForRepo": 15,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,91 +1,103 @@\n-  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n+  private void loadQueue(String parentName, Element element,\n+      Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n+      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         fairSharePreemptionTimeouts.put(queueName, val);\n+      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        float val \u003d Float.parseFloat(text);\n+        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n+        fairSharePreemptionThresholds.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n             queuePolicies, minSharePreemptionTimeouts,\n-            fairSharePreemptionTimeouts, queueAcls, configuredQueues);\n+            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n+            queueAcls, configuredQueues);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     }\n     queueAcls.put(queueName, acls);\n-    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n+    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n+        minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n-      LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n-          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n+      LOG.warn(\n+          String.format(\n+              \"Queue %s has max resources %s less than min resources %s\",\n+          queueName, maxQueueResources.get(queueName),\n+              minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element,\n      Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Float\u003e fairSharePreemptionThresholds,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionThreshold\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.max(Math.min(val, 1.0f), 0.0f);\n        fairSharePreemptionThresholds.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, fairSharePreemptionThresholds,\n            queueAcls, configuredQueues);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026\n        minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(\n          String.format(\n              \"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName),\n              minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        }
      ]
    },
    "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-2395. FairScheduler: Preemption timeout should be configurable per queue. (Wei Yan via kasha)\n",
      "commitDate": "30/08/14 1:17 AM",
      "commitName": "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
      "commitAuthor": "Karthik Kambatla",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-2395. FairScheduler: Preemption timeout should be configurable per queue. (Wei Yan via kasha)\n",
          "commitDate": "30/08/14 1:17 AM",
          "commitName": "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "21/06/14 12:30 AM",
          "commitNameOld": "6fcbf9b848c63465d26a40387a9be212e708f80b",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 70.03,
          "commitsBetweenForRepo": 561,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,86 +1,91 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n+      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n+      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        long val \u003d Long.parseLong(text) * 1000L;\n+        fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n-            queuePolicies, minSharePreemptionTimeouts, queueAcls,\n-            configuredQueues);\n+            queuePolicies, minSharePreemptionTimeouts,\n+            fairSharePreemptionTimeouts, queueAcls, configuredQueues);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, queueAcls, configuredQueues);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, fairSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-2395. FairScheduler: Preemption timeout should be configurable per queue. (Wei Yan via kasha)\n",
          "commitDate": "30/08/14 1:17 AM",
          "commitName": "0f34e6f3873aee0f4932740ca790c6dd2a13b5d9",
          "commitAuthor": "Karthik Kambatla",
          "commitDateOld": "21/06/14 12:30 AM",
          "commitNameOld": "6fcbf9b848c63465d26a40387a9be212e708f80b",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 70.03,
          "commitsBetweenForRepo": 561,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,86 +1,91 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n       Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n+      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"maxAMShare\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         float val \u003d Float.parseFloat(text);\n         val \u003d Math.min(val, 1.0f);\n         queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n+      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        long val \u003d Long.parseLong(text) * 1000L;\n+        fairSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n-            queuePolicies, minSharePreemptionTimeouts, queueAcls,\n-            configuredQueues);\n+            queuePolicies, minSharePreemptionTimeouts,\n+            fairSharePreemptionTimeouts, queueAcls, configuredQueues);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Long\u003e fairSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"fairSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        fairSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts,\n            fairSharePreemptionTimeouts, queueAcls, configuredQueues);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        }
      ]
    },
    "16caa3fd18424a67fc01b1ae3a8fcdbc99c8cbc4": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1913. With Fair Scheduler, cluster can logjam when all resources are consumed by AMs (Wei Yan via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1599400 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/06/14 5:56 PM",
      "commitName": "16caa3fd18424a67fc01b1ae3a8fcdbc99c8cbc4",
      "commitAuthor": "Sanford Ryza",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1913. With Fair Scheduler, cluster can logjam when all resources are consumed by AMs (Wei Yan via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1599400 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/06/14 5:56 PM",
          "commitName": "16caa3fd18424a67fc01b1ae3a8fcdbc99c8cbc4",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "31/05/14 12:33 PM",
          "commitNameOld": "a4ba451802c6c61a0c804809740d46dd76059f25",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 2.22,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,86 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n-      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n+      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n+      Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n+      } else if (\"maxAMShare\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        float val \u003d Float.parseFloat(text);\n+        val \u003d Math.min(val, 1.0f);\n+        queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n-            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n-            minSharePreemptionTimeouts, queueAcls, configuredQueues);\n+            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n+            queuePolicies, minSharePreemptionTimeouts, queueAcls,\n+            configuredQueues);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts, queueAcls,\n            configuredQueues);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueMaxAMShares-Map\u003cString,Float\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1913. With Fair Scheduler, cluster can logjam when all resources are consumed by AMs (Wei Yan via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1599400 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "02/06/14 5:56 PM",
          "commitName": "16caa3fd18424a67fc01b1ae3a8fcdbc99c8cbc4",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "31/05/14 12:33 PM",
          "commitNameOld": "a4ba451802c6c61a0c804809740d46dd76059f25",
          "commitAuthorOld": "Karthik Kambatla",
          "daysBetweenCommits": 2.22,
          "commitsBetweenForRepo": 7,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,79 +1,86 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n-      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n+      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n+      Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n       Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n+      } else if (\"maxAMShare\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        float val \u003d Float.parseFloat(text);\n+        val \u003d Math.min(val, 1.0f);\n+        queueMaxAMShares.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n-            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n-            minSharePreemptionTimeouts, queueAcls, configuredQueues);\n+            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n+            queuePolicies, minSharePreemptionTimeouts, queueAcls,\n+            configuredQueues);\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n       // then store it under \u0027parent\u0027\n       if (\"parent\".equals(element.getAttribute(\"type\"))) {\n         configuredQueues.get(FSQueueType.PARENT).add(queueName);\n       } else {\n         configuredQueues.get(FSQueueType.LEAF).add(queueName);\n       }\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Float\u003e queueMaxAMShares,\n      Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"maxAMShare\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        float val \u003d Float.parseFloat(text);\n        val \u003d Math.min(val, 1.0f);\n        queueMaxAMShares.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueMaxAMShares, queueWeights,\n            queuePolicies, minSharePreemptionTimeouts, queueAcls,\n            configuredQueues);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        }
      ]
    },
    "cfc97a4e88dcebb3e1098e8915e57aaff072414d": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-1864. Fair Scheduler Dynamic Hierarchical User Queues (Ashwin Shankar via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593190 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/05/14 12:21 AM",
      "commitName": "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
      "commitAuthor": "Sanford Ryza",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1864. Fair Scheduler Dynamic Hierarchical User Queues (Ashwin Shankar via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593190 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/05/14 12:21 AM",
          "commitName": "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "15/01/14 3:09 PM",
          "commitNameOld": "7274b5ff93afc6e6e96fb6fcd43f2955960f2644",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 112.34,
          "commitsBetweenForRepo": 846,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,79 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n-      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, Set\u003cString\u003e queueNamesInAllocFile) \n+      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n+      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n-            minSharePreemptionTimeouts,\n-            queueAcls, queueNamesInAllocFile);\n+            minSharePreemptionTimeouts, queueAcls, configuredQueues);\n+        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n-      queueNamesInAllocFile.add(queueName);\n+      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n+      // then store it under \u0027parent\u0027\n+      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n+        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n+      } else {\n+        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n+      }\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts, queueAcls, configuredQueues);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, queueNamesInAllocFile-Set\u003cString\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, configuredQueues-Map\u003cFSQueueType,Set\u003cString\u003e\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1864. Fair Scheduler Dynamic Hierarchical User Queues (Ashwin Shankar via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1593190 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "08/05/14 12:21 AM",
          "commitName": "cfc97a4e88dcebb3e1098e8915e57aaff072414d",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "15/01/14 3:09 PM",
          "commitNameOld": "7274b5ff93afc6e6e96fb6fcd43f2955960f2644",
          "commitAuthorOld": "Sanford Ryza",
          "daysBetweenCommits": 112.34,
          "commitsBetweenForRepo": 846,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,72 +1,79 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n-      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, Set\u003cString\u003e queueNamesInAllocFile) \n+      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n+      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n-            minSharePreemptionTimeouts,\n-            queueAcls, queueNamesInAllocFile);\n+            minSharePreemptionTimeouts, queueAcls, configuredQueues);\n+        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n-      queueNamesInAllocFile.add(queueName);\n+      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n+      // then store it under \u0027parent\u0027\n+      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n+        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n+      } else {\n+        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n+      }\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, \n      Map\u003cFSQueueType, Set\u003cString\u003e\u003e configuredQueues) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts, queueAcls, configuredQueues);\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      // if a leaf in the alloc file is marked as type\u003d\u0027parent\u0027\n      // then store it under \u0027parent\u0027\n      if (\"parent\".equals(element.getAttribute(\"type\"))) {\n        configuredQueues.get(FSQueueType.PARENT).add(queueName);\n      } else {\n        configuredQueues.get(FSQueueType.LEAF).add(queueName);\n      }\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        }
      ]
    },
    "7274b5ff93afc6e6e96fb6fcd43f2955960f2644": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1351. Invalid string format in Fair Scheduler log warn message (Konstantin Weitz via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1558597 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "15/01/14 3:09 PM",
      "commitName": "7274b5ff93afc6e6e96fb6fcd43f2955960f2644",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "04/12/13 7:26 PM",
      "commitNameOld": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 41.82,
      "commitsBetweenForRepo": 199,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,72 +1,72 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, Set\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n             minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n-      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n+      LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, Set\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %s less than min resources %s\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
      "extendedDetails": {}
    },
    "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange,Yparameterchange)",
      "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/12/13 7:26 PM",
      "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
      "commitAuthor": "Sanford Ryza",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/12/13 7:26 PM",
          "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "04/12/13 6:59 PM",
          "commitNameOld": "950e0644b79e0c0514dd036dcf19b9645df0982f",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,72 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n-      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n+      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, Set\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n-        policy.initialize(scheduler.getClusterCapacity());\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n             minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, Set\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
            "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
            "oldMethodName": "loadQueue",
            "newMethodName": "loadQueue"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/12/13 7:26 PM",
          "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "04/12/13 6:59 PM",
          "commitNameOld": "950e0644b79e0c0514dd036dcf19b9645df0982f",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,72 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n-      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n+      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, Set\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n-        policy.initialize(scheduler.getClusterCapacity());\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n             minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, Set\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {}
        },
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-1403. Separate out configuration loading from QueueManager in the Fair Scheduler (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1548006 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "04/12/13 7:26 PM",
          "commitName": "6d5f8ebed60e59d772e0dcee0b069f8db95f6ccc",
          "commitAuthor": "Sanford Ryza",
          "commitDateOld": "04/12/13 6:59 PM",
          "commitNameOld": "950e0644b79e0c0514dd036dcf19b9645df0982f",
          "commitAuthorOld": "Colin McCabe",
          "daysBetweenCommits": 0.02,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,73 +1,72 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n-      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n+      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, Set\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n-        policy.initialize(scheduler.getClusterCapacity());\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n             minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, Set\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/AllocationFileLoaderService.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, queueNamesInAllocFile-List\u003cString\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, queueNamesInAllocFile-Set\u003cString\u003e]"
          }
        }
      ]
    },
    "dc523bd18247df232fe814aed7062a116242ab04": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1288. Make Fair Scheduler ACLs more user friendly (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1534315 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/10/13 11:45 AM",
      "commitName": "dc523bd18247df232fe814aed7062a116242ab04",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "21/10/13 11:37 AM",
      "commitNameOld": "881d1d5c7e2810ed001fe4ca5dfdc375599d37cf",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 2,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         policy.initialize(scheduler.getClusterCapacity());\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n             minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        policy.initialize(scheduler.getClusterCapacity());\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "881d1d5c7e2810ed001fe4ca5dfdc375599d37cf": {
      "type": "Ybodychange",
      "commitMessage": "Reverting \"YARN-1258: Move to 2.2.1 in CHANGES.txt\" because it contained unintended changes\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1534308 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/10/13 11:37 AM",
      "commitName": "881d1d5c7e2810ed001fe4ca5dfdc375599d37cf",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "21/10/13 11:31 AM",
      "commitNameOld": "65bda6d168e47106f5542e15bb7b21522478626e",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 0.0,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         policy.initialize(scheduler.getClusterCapacity());\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData();\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n             minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        policy.initialize(scheduler.getClusterCapacity());\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "65bda6d168e47106f5542e15bb7b21522478626e": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1258: Move to 2.2.1 in CHANGES.txt\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1534307 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/10/13 11:31 AM",
      "commitName": "65bda6d168e47106f5542e15bb7b21522478626e",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "09/10/13 2:19 AM",
      "commitNameOld": "643b1a401968a21d902b602e76a53c1f98b1a950",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 12.38,
      "commitsBetweenForRepo": 71,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,73 +1,73 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d element.getAttribute(\"name\");\n     if (parentName !\u003d null) {\n       queueName \u003d parentName + \".\" + queueName;\n     }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         policy.initialize(scheduler.getClusterCapacity());\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n-        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        String text \u003d ((Text)field.getFirstChild()).getData();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n             minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        policy.initialize(scheduler.getClusterCapacity());\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "643b1a401968a21d902b602e76a53c1f98b1a950": {
      "type": "Ybodychange",
      "commitMessage": "YARN-1258. Allow configuring the Fair Scheduler root queue (Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1530542 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/10/13 2:19 AM",
      "commitName": "643b1a401968a21d902b602e76a53c1f98b1a950",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "02/10/13 6:17 PM",
      "commitNameOld": "2db1d4d4ee7838f2a8c0b3999b6055456798321d",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 6.33,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,70 +1,73 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n-    String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n+    String queueName \u003d element.getAttribute(\"name\");\n+    if (parentName !\u003d null) {\n+      queueName \u003d parentName + \".\" + queueName;\n+    }\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n         maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n         policy.initialize(scheduler.getClusterCapacity());\n         queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n             minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d element.getAttribute(\"name\");\n    if (parentName !\u003d null) {\n      queueName \u003d parentName + \".\" + queueName;\n    }\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        policy.initialize(scheduler.getClusterCapacity());\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-326. Add multi-resource scheduling to the fair scheduler. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489070 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 10:33 AM",
      "commitName": "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
      "commitAuthor": "Alejandro Abdelnur",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-326. Add multi-resource scheduling to the fair scheduler. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489070 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/06/13 10:33 AM",
          "commitName": "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
          "commitAuthor": "Alejandro Abdelnur",
          "commitDateOld": "25/04/13 1:33 AM",
          "commitNameOld": "a43c344eee888f2a2488c8c9dca7e25a2cce10bf",
          "commitAuthorOld": "Thomas White",
          "daysBetweenCommits": 39.38,
          "commitsBetweenForRepo": 232,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,70 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n-      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Double\u003e queueWeights,\n+      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        int val \u003d Integer.parseInt(text);\n-        minQueueResources.put(queueName, Resources.createResource(val));\n+        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n+        minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        int val \u003d Integer.parseInt(text);\n-        maxQueueResources.put(queueName, Resources.createResource(val));\n+        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n+        maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n-        queueWeights.put(queueName, val);\n+        queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        queuePolicies.put(queueName, SchedulingPolicy.parse(text));\n+        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n+        policy.initialize(scheduler.getClusterCapacity());\n+        queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n             minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        policy.initialize(scheduler.getClusterCapacity());\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueWeights-Map\u003cString,Double\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, queueNamesInAllocFile-List\u003cString\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueWeights-Map\u003cString,ResourceWeights\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, queueNamesInAllocFile-List\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-326. Add multi-resource scheduling to the fair scheduler. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489070 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "03/06/13 10:33 AM",
          "commitName": "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
          "commitAuthor": "Alejandro Abdelnur",
          "commitDateOld": "25/04/13 1:33 AM",
          "commitNameOld": "a43c344eee888f2a2488c8c9dca7e25a2cce10bf",
          "commitAuthorOld": "Thomas White",
          "daysBetweenCommits": 39.38,
          "commitsBetweenForRepo": 232,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,68 +1,70 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n-      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Double\u003e queueWeights,\n+      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        int val \u003d Integer.parseInt(text);\n-        minQueueResources.put(queueName, Resources.createResource(val));\n+        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n+        minQueueResources.put(queueName, val);\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        int val \u003d Integer.parseInt(text);\n-        maxQueueResources.put(queueName, Resources.createResource(val));\n+        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n+        maxQueueResources.put(queueName, val);\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n-        queueWeights.put(queueName, val);\n+        queueWeights.put(queueName, new ResourceWeights((float)val));\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        queuePolicies.put(queueName, SchedulingPolicy.parse(text));\n+        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n+        policy.initialize(scheduler.getClusterCapacity());\n+        queuePolicies.put(queueName, policy);\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n             minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n             maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, ResourceWeights\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        minQueueResources.put(queueName, val);\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        Resource val \u003d FairSchedulerConfiguration.parseResourceConfigValue(text);\n        maxQueueResources.put(queueName, val);\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, new ResourceWeights((float)val));\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        SchedulingPolicy policy \u003d SchedulingPolicy.parse(text);\n        policy.initialize(scheduler.getClusterCapacity());\n        queuePolicies.put(queueName, policy);\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "a43c344eee888f2a2488c8c9dca7e25a2cce10bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-595. Refactor fair scheduler to use common Resources. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1475670 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/04/13 1:33 AM",
      "commitName": "a43c344eee888f2a2488c8c9dca7e25a2cce10bf",
      "commitAuthor": "Thomas White",
      "commitDateOld": "18/04/13 11:11 AM",
      "commitNameOld": "df55edd5dec9c944a6c38f08d6f1f0fdb901c880",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 6.6,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,68 +1,68 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Double\u003e queueWeights,\n       Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n       Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         minQueueResources.put(queueName, Resources.createResource(val));\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         maxQueueResources.put(queueName, Resources.createResource(val));\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, val);\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingPolicy\".equals(field.getTagName())\n           || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         queuePolicies.put(queueName, SchedulingPolicy.parse(text));\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources,\n             queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n             minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n-        \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n-            minQueueResources.get(queueName))) {\n+        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n+            maxQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Double\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        minQueueResources.put(queueName, Resources.createResource(val));\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        maxQueueResources.put(queueName, Resources.createResource(val));\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, val);\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        queuePolicies.put(queueName, SchedulingPolicy.parse(text));\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 !Resources.fitsIn(minQueueResources.get(queueName),\n            maxQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "df55edd5dec9c944a6c38f08d6f1f0fdb901c880": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "YARN-482. FS: Extend SchedulingMode to intermediate queues. (kkambatl via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469506 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/04/13 11:11 AM",
      "commitName": "df55edd5dec9c944a6c38f08d6f1f0fdb901c880",
      "commitAuthor": "Alejandro Abdelnur",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "YARN-482. FS: Extend SchedulingMode to intermediate queues. (kkambatl via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469506 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/04/13 11:11 AM",
          "commitName": "df55edd5dec9c944a6c38f08d6f1f0fdb901c880",
          "commitAuthor": "Alejandro Abdelnur",
          "commitDateOld": "25/03/13 8:25 PM",
          "commitNameOld": "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 23.62,
          "commitsBetweenForRepo": 127,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,68 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Double\u003e queueWeights,\n-      Map\u003cString, SchedulingMode\u003e queueModes, Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n+      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n+      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         minQueueResources.put(queueName, Resources.createResource(val));\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         maxQueueResources.put(queueName, Resources.createResource(val));\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, val);\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n-      } else if (\"schedulingMode\".equals(field.getTagName())) {\n+      } else if (\"schedulingPolicy\".equals(field.getTagName())\n+          || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        queueModes.put(queueName, SchedulingMode.parse(text));\n+        queuePolicies.put(queueName, SchedulingPolicy.parse(text));\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n-        loadQueue(queueName, field, minQueueResources, maxQueueResources, queueMaxApps,\n-            userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n+        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n+            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n+            minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n             minQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Double\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        minQueueResources.put(queueName, Resources.createResource(val));\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        maxQueueResources.put(queueName, Resources.createResource(val));\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, val);\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        queuePolicies.put(queueName, SchedulingPolicy.parse(text));\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n            minQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
          "extendedDetails": {
            "oldValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueWeights-Map\u003cString,Double\u003e, queueModes-Map\u003cString,SchedulingMode\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, queueNamesInAllocFile-List\u003cString\u003e]",
            "newValue": "[parentName-String, element-Element, minQueueResources-Map\u003cString,Resource\u003e, maxQueueResources-Map\u003cString,Resource\u003e, queueMaxApps-Map\u003cString,Integer\u003e, userMaxApps-Map\u003cString,Integer\u003e, queueWeights-Map\u003cString,Double\u003e, queuePolicies-Map\u003cString,SchedulingPolicy\u003e, minSharePreemptionTimeouts-Map\u003cString,Long\u003e, queueAcls-Map\u003cString,Map\u003cQueueACL,AccessControlList\u003e\u003e, queueNamesInAllocFile-List\u003cString\u003e]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "YARN-482. FS: Extend SchedulingMode to intermediate queues. (kkambatl via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469506 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "18/04/13 11:11 AM",
          "commitName": "df55edd5dec9c944a6c38f08d6f1f0fdb901c880",
          "commitAuthor": "Alejandro Abdelnur",
          "commitDateOld": "25/03/13 8:25 PM",
          "commitNameOld": "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3",
          "commitAuthorOld": "Alejandro Abdelnur",
          "daysBetweenCommits": 23.62,
          "commitsBetweenForRepo": 127,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,65 +1,68 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Double\u003e queueWeights,\n-      Map\u003cString, SchedulingMode\u003e queueModes, Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n+      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n+      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         minQueueResources.put(queueName, Resources.createResource(val));\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         maxQueueResources.put(queueName, Resources.createResource(val));\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, val);\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n-      } else if (\"schedulingMode\".equals(field.getTagName())) {\n+      } else if (\"schedulingPolicy\".equals(field.getTagName())\n+          || \"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        queueModes.put(queueName, SchedulingMode.parse(text));\n+        queuePolicies.put(queueName, SchedulingPolicy.parse(text));\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n-        loadQueue(queueName, field, minQueueResources, maxQueueResources, queueMaxApps,\n-            userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n+        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n+            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n+            minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n             minQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Double\u003e queueWeights,\n      Map\u003cString, SchedulingPolicy\u003e queuePolicies,\n      Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        minQueueResources.put(queueName, Resources.createResource(val));\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        maxQueueResources.put(queueName, Resources.createResource(val));\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, val);\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingPolicy\".equals(field.getTagName())\n          || \"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        queuePolicies.put(queueName, SchedulingPolicy.parse(text));\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources,\n            queueMaxApps, userMaxApps, queueWeights, queuePolicies,\n            minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n            minQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
          "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
          "extendedDetails": {}
        }
      ]
    },
    "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3": {
      "type": "Ybodychange",
      "commitMessage": "YARN-469. Make scheduling mode in FS pluggable. (kkambatl via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460961 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/13 8:25 PM",
      "commitName": "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "08/01/13 9:08 PM",
      "commitNameOld": "453926397182078c65a4428eb5de5a90d6af6448",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 75.93,
      "commitsBetweenForRepo": 364,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n       Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n       Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Double\u003e queueWeights,\n       Map\u003cString, SchedulingMode\u003e queueModes, Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n       Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n       throws AllocationConfigurationException {\n     String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n     Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n         new HashMap\u003cQueueACL, AccessControlList\u003e();\n     NodeList fields \u003d element.getChildNodes();\n     boolean isLeaf \u003d true;\n \n     for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n       Node fieldNode \u003d fields.item(j);\n       if (!(fieldNode instanceof Element))\n         continue;\n       Element field \u003d (Element) fieldNode;\n       if (\"minResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         minQueueResources.put(queueName, Resources.createResource(val));\n       } else if (\"maxResources\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         maxQueueResources.put(queueName, Resources.createResource(val));\n       } else if (\"maxRunningApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         int val \u003d Integer.parseInt(text);\n         queueMaxApps.put(queueName, val);\n       } else if (\"weight\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         double val \u003d Double.parseDouble(text);\n         queueWeights.put(queueName, val);\n       } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         long val \u003d Long.parseLong(text) * 1000L;\n         minSharePreemptionTimeouts.put(queueName, val);\n       } else if (\"schedulingMode\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n-        queueModes.put(queueName, parseSchedulingMode(text));\n+        queueModes.put(queueName, SchedulingMode.parse(text));\n       } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n       } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n         String text \u003d ((Text)field.getFirstChild()).getData().trim();\n         acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n       } else if (\"queue\".endsWith(field.getTagName()) || \n           \"pool\".equals(field.getTagName())) {\n         loadQueue(queueName, field, minQueueResources, maxQueueResources, queueMaxApps,\n             userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n             queueAcls, queueNamesInAllocFile);\n         isLeaf \u003d false;\n       }\n     }\n     if (isLeaf) {\n       queueNamesInAllocFile.add(queueName);\n     }\n     queueAcls.put(queueName, acls);\n     if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n         \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n             minQueueResources.get(queueName))) {\n       LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n           queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Double\u003e queueWeights,\n      Map\u003cString, SchedulingMode\u003e queueModes, Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        minQueueResources.put(queueName, Resources.createResource(val));\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        maxQueueResources.put(queueName, Resources.createResource(val));\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, val);\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        queueModes.put(queueName, SchedulingMode.parse(text));\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources, queueMaxApps,\n            userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n            minQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java",
      "extendedDetails": {}
    },
    "ae6f1123f57c09a9cf5eed3e8c4659481417dc21": {
      "type": "Yintroduced",
      "commitMessage": "YARN-187. Add hierarchical queues to the fair scheduler. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1415592 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/11/12 4:03 AM",
      "commitName": "ae6f1123f57c09a9cf5eed3e8c4659481417dc21",
      "commitAuthor": "Thomas White",
      "diff": "@@ -0,0 +1,65 @@\n+  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n+      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n+      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Double\u003e queueWeights,\n+      Map\u003cString, SchedulingMode\u003e queueModes, Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n+      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n+      throws AllocationConfigurationException {\n+    String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n+    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n+        new HashMap\u003cQueueACL, AccessControlList\u003e();\n+    NodeList fields \u003d element.getChildNodes();\n+    boolean isLeaf \u003d true;\n+\n+    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n+      Node fieldNode \u003d fields.item(j);\n+      if (!(fieldNode instanceof Element))\n+        continue;\n+      Element field \u003d (Element) fieldNode;\n+      if (\"minResources\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        int val \u003d Integer.parseInt(text);\n+        minQueueResources.put(queueName, Resources.createResource(val));\n+      } else if (\"maxResources\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        int val \u003d Integer.parseInt(text);\n+        maxQueueResources.put(queueName, Resources.createResource(val));\n+      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        int val \u003d Integer.parseInt(text);\n+        queueMaxApps.put(queueName, val);\n+      } else if (\"weight\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        double val \u003d Double.parseDouble(text);\n+        queueWeights.put(queueName, val);\n+      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        long val \u003d Long.parseLong(text) * 1000L;\n+        minSharePreemptionTimeouts.put(queueName, val);\n+      } else if (\"schedulingMode\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        queueModes.put(queueName, parseSchedulingMode(text));\n+      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n+      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n+        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n+        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n+      } else if (\"queue\".endsWith(field.getTagName()) || \n+          \"pool\".equals(field.getTagName())) {\n+        loadQueue(queueName, field, minQueueResources, maxQueueResources, queueMaxApps,\n+            userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n+            queueAcls, queueNamesInAllocFile);\n+        isLeaf \u003d false;\n+      }\n+    }\n+    if (isLeaf) {\n+      queueNamesInAllocFile.add(queueName);\n+    }\n+    queueAcls.put(queueName, acls);\n+    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n+        \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n+            minQueueResources.get(queueName))) {\n+      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n+          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n+    }\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void loadQueue(String parentName, Element element, Map\u003cString, Resource\u003e minQueueResources,\n      Map\u003cString, Resource\u003e maxQueueResources, Map\u003cString, Integer\u003e queueMaxApps,\n      Map\u003cString, Integer\u003e userMaxApps, Map\u003cString, Double\u003e queueWeights,\n      Map\u003cString, SchedulingMode\u003e queueModes, Map\u003cString, Long\u003e minSharePreemptionTimeouts,\n      Map\u003cString, Map\u003cQueueACL, AccessControlList\u003e\u003e queueAcls, List\u003cString\u003e queueNamesInAllocFile) \n      throws AllocationConfigurationException {\n    String queueName \u003d parentName + \".\" + element.getAttribute(\"name\");\n    Map\u003cQueueACL, AccessControlList\u003e acls \u003d\n        new HashMap\u003cQueueACL, AccessControlList\u003e();\n    NodeList fields \u003d element.getChildNodes();\n    boolean isLeaf \u003d true;\n\n    for (int j \u003d 0; j \u003c fields.getLength(); j++) {\n      Node fieldNode \u003d fields.item(j);\n      if (!(fieldNode instanceof Element))\n        continue;\n      Element field \u003d (Element) fieldNode;\n      if (\"minResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        minQueueResources.put(queueName, Resources.createResource(val));\n      } else if (\"maxResources\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        maxQueueResources.put(queueName, Resources.createResource(val));\n      } else if (\"maxRunningApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        int val \u003d Integer.parseInt(text);\n        queueMaxApps.put(queueName, val);\n      } else if (\"weight\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        double val \u003d Double.parseDouble(text);\n        queueWeights.put(queueName, val);\n      } else if (\"minSharePreemptionTimeout\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        long val \u003d Long.parseLong(text) * 1000L;\n        minSharePreemptionTimeouts.put(queueName, val);\n      } else if (\"schedulingMode\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        queueModes.put(queueName, parseSchedulingMode(text));\n      } else if (\"aclSubmitApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.SUBMIT_APPLICATIONS, new AccessControlList(text));\n      } else if (\"aclAdministerApps\".equals(field.getTagName())) {\n        String text \u003d ((Text)field.getFirstChild()).getData().trim();\n        acls.put(QueueACL.ADMINISTER_QUEUE, new AccessControlList(text));\n      } else if (\"queue\".endsWith(field.getTagName()) || \n          \"pool\".equals(field.getTagName())) {\n        loadQueue(queueName, field, minQueueResources, maxQueueResources, queueMaxApps,\n            userMaxApps, queueWeights, queueModes, minSharePreemptionTimeouts,\n            queueAcls, queueNamesInAllocFile);\n        isLeaf \u003d false;\n      }\n    }\n    if (isLeaf) {\n      queueNamesInAllocFile.add(queueName);\n    }\n    queueAcls.put(queueName, acls);\n    if (maxQueueResources.containsKey(queueName) \u0026\u0026 minQueueResources.containsKey(queueName)\n        \u0026\u0026 Resources.lessThan(maxQueueResources.get(queueName),\n            minQueueResources.get(queueName))) {\n      LOG.warn(String.format(\"Queue %s has max resources %d less than min resources %d\",\n          queueName, maxQueueResources.get(queueName), minQueueResources.get(queueName)));\n    }\n  }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/QueueManager.java"
    }
  }
}