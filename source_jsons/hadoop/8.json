{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "RpcProgramMountd.java",
  "functionName": "handleInternal",
  "functionId": "handleInternal___ctx-ChannelHandlerContext__info-RpcInfo",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/mount/RpcProgramMountd.java",
  "functionStartLine": 216,
  "functionEndLine": 269,
  "numCommitsSeen": 28,
  "timeTaken": 2294,
  "changeHistory": [
    "d6602b5f39833611b4afa4581552f6c4c37e23a8",
    "2a5f1029a5221c42ab61b22f99d79251ed069ca4",
    "2ecab65e3e290a1ee192b39ec70868863853543a",
    "ec9ec0084eccdd45a8c3e37ef8121fb8bd44ecd0",
    "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
    "5e18410e06dd63113c49029894007e0878312903",
    "cbca1668317f3f2d295eea53d7bd020bda4a810f",
    "58d75576c4d2a03d4954174bc223ed0334b34fee",
    "37f587563a943a827fbff865f5302bac6d202415"
  ],
  "changeHistoryShort": {
    "d6602b5f39833611b4afa4581552f6c4c37e23a8": "Ybodychange",
    "2a5f1029a5221c42ab61b22f99d79251ed069ca4": "Ybodychange",
    "2ecab65e3e290a1ee192b39ec70868863853543a": "Ybodychange",
    "ec9ec0084eccdd45a8c3e37ef8121fb8bd44ecd0": "Ybodychange",
    "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
    "5e18410e06dd63113c49029894007e0878312903": "Ybodychange",
    "cbca1668317f3f2d295eea53d7bd020bda4a810f": "Ybodychange",
    "58d75576c4d2a03d4954174bc223ed0334b34fee": "Ybodychange",
    "37f587563a943a827fbff865f5302bac6d202415": "Yintroduced"
  },
  "changeHistoryDetails": {
    "d6602b5f39833611b4afa4581552f6c4c37e23a8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-11575. Supporting HDFS NFS gateway with Federated HDFS. Contributed by Mukul Kumar Singh.\n",
      "commitDate": "10/10/17 10:38 AM",
      "commitName": "d6602b5f39833611b4afa4581552f6c4c37e23a8",
      "commitAuthor": "Jitendra Pandey",
      "commitDateOld": "16/01/17 2:53 PM",
      "commitNameOld": "d1d0b3e1fd593d590aaf2e3db8f730a296b20aa1",
      "commitAuthorOld": "Jitendra Pandey",
      "daysBetweenCommits": 266.78,
      "commitsBetweenForRepo": 1716,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,48 +1,54 @@\n   public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n     RpcCall rpcCall \u003d (RpcCall) info.header();\n     final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n     byte[] data \u003d new byte[info.data().readableBytes()];\n     info.data().readBytes(data);\n     XDR xdr \u003d new XDR(data);\n     XDR out \u003d new XDR();\n-    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n+    InetAddress client \u003d\n+        ((InetSocketAddress) info.remoteAddress()).getAddress();\n \n     if (mntproc \u003d\u003d MNTPROC.NULL) {\n       out \u003d nullOp(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n       // Only do port monitoring for MNT\n       if (!doPortMonitoring(info.remoteAddress())) {\n         out \u003d MountResponse.writeMNTResponse(Nfs3Status.NFS3ERR_ACCES, out,\n             xid, null);\n       } else {\n         out \u003d mnt(xdr, out, xid, client);\n       }\n     } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n       out \u003d dump(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n       out \u003d umnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n       umntall(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n-      // Currently only support one NFS export\n+      // Currently only support one NFS export per namenode\n       List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n       if (hostsMatcher !\u003d null) {\n-        hostsMatchers.add(hostsMatcher);\n-        out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n+        List exportsList \u003d getExports();\n+        for (int i \u003d 0; i \u003c exportsList.size(); i++) {\n+          hostsMatchers.add(hostsMatcher);\n+        }\n+        out \u003d MountResponse.writeExportList(out, xid,\n+                                            exportsList, hostsMatchers);\n       } else {\n         // This means there are no valid exports provided.\n         RpcAcceptedReply.getInstance(xid,\n-          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n-          out);\n+            RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone())\n+            .write(out);\n       }\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }\n-    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n+    ChannelBuffer buf \u003d\n+        ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n     RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n     RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d\n        ((InetSocketAddress) info.remoteAddress()).getAddress();\n\n    if (mntproc \u003d\u003d MNTPROC.NULL) {\n      out \u003d nullOp(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n      // Only do port monitoring for MNT\n      if (!doPortMonitoring(info.remoteAddress())) {\n        out \u003d MountResponse.writeMNTResponse(Nfs3Status.NFS3ERR_ACCES, out,\n            xid, null);\n      } else {\n        out \u003d mnt(xdr, out, xid, client);\n      }\n    } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n      out \u003d dump(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n      out \u003d umnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n      umntall(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n      // Currently only support one NFS export per namenode\n      List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n      if (hostsMatcher !\u003d null) {\n        List exportsList \u003d getExports();\n        for (int i \u003d 0; i \u003c exportsList.size(); i++) {\n          hostsMatchers.add(hostsMatcher);\n        }\n        out \u003d MountResponse.writeExportList(out, xid,\n                                            exportsList, hostsMatchers);\n      } else {\n        // This means there are no valid exports provided.\n        RpcAcceptedReply.getInstance(xid,\n            RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone())\n            .write(out);\n      }\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }\n    ChannelBuffer buf \u003d\n        ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/mount/RpcProgramMountd.java",
      "extendedDetails": {}
    },
    "2a5f1029a5221c42ab61b22f99d79251ed069ca4": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6455. NFS: Exception should be added in NFS log for invalid separator in nfs.exports.allowed.hosts. Contributed by Abhiraj Butala\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612947 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "23/07/14 2:22 PM",
      "commitName": "2a5f1029a5221c42ab61b22f99d79251ed069ca4",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "18/06/14 1:45 PM",
      "commitNameOld": "2ecab65e3e290a1ee192b39ec70868863853543a",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 35.03,
      "commitsBetweenForRepo": 253,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,41 +1,48 @@\n   public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n     RpcCall rpcCall \u003d (RpcCall) info.header();\n     final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n     byte[] data \u003d new byte[info.data().readableBytes()];\n     info.data().readBytes(data);\n     XDR xdr \u003d new XDR(data);\n     XDR out \u003d new XDR();\n     InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n \n     if (mntproc \u003d\u003d MNTPROC.NULL) {\n       out \u003d nullOp(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n       // Only do port monitoring for MNT\n       if (!doPortMonitoring(info.remoteAddress())) {\n         out \u003d MountResponse.writeMNTResponse(Nfs3Status.NFS3ERR_ACCES, out,\n             xid, null);\n       } else {\n         out \u003d mnt(xdr, out, xid, client);\n       }\n     } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n       out \u003d dump(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n       out \u003d umnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n       umntall(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n-      // Currently only support one NFS export \n+      // Currently only support one NFS export\n       List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n-      hostsMatchers.add(hostsMatcher);\n-      out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n+      if (hostsMatcher !\u003d null) {\n+        hostsMatchers.add(hostsMatcher);\n+        out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n+      } else {\n+        // This means there are no valid exports provided.\n+        RpcAcceptedReply.getInstance(xid,\n+          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n+          out);\n+      }\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n-    }  \n+    }\n     ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n     RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n     RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n\n    if (mntproc \u003d\u003d MNTPROC.NULL) {\n      out \u003d nullOp(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n      // Only do port monitoring for MNT\n      if (!doPortMonitoring(info.remoteAddress())) {\n        out \u003d MountResponse.writeMNTResponse(Nfs3Status.NFS3ERR_ACCES, out,\n            xid, null);\n      } else {\n        out \u003d mnt(xdr, out, xid, client);\n      }\n    } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n      out \u003d dump(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n      out \u003d umnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n      umntall(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n      // Currently only support one NFS export\n      List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n      if (hostsMatcher !\u003d null) {\n        hostsMatchers.add(hostsMatcher);\n        out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n      } else {\n        // This means there are no valid exports provided.\n        RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n      }\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }\n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/mount/RpcProgramMountd.java",
      "extendedDetails": {}
    },
    "2ecab65e3e290a1ee192b39ec70868863853543a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-6439. NFS should not reject NFS requests to the NULL procedure whether port monitoring is enabled or not. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1603622 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/06/14 1:45 PM",
      "commitName": "2ecab65e3e290a1ee192b39ec70868863853543a",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "30/05/14 4:53 PM",
      "commitNameOld": "42391d260da400593812396c1ffd45d1a371d3cb",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 18.87,
      "commitsBetweenForRepo": 106,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,41 @@\n   public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n     RpcCall rpcCall \u003d (RpcCall) info.header();\n     final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n     byte[] data \u003d new byte[info.data().readableBytes()];\n     info.data().readBytes(data);\n     XDR xdr \u003d new XDR(data);\n     XDR out \u003d new XDR();\n     InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n \n     if (mntproc \u003d\u003d MNTPROC.NULL) {\n       out \u003d nullOp(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n-      out \u003d mnt(xdr, out, xid, client);\n+      // Only do port monitoring for MNT\n+      if (!doPortMonitoring(info.remoteAddress())) {\n+        out \u003d MountResponse.writeMNTResponse(Nfs3Status.NFS3ERR_ACCES, out,\n+            xid, null);\n+      } else {\n+        out \u003d mnt(xdr, out, xid, client);\n+      }\n     } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n       out \u003d dump(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n       out \u003d umnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n       umntall(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n       // Currently only support one NFS export \n       List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n       hostsMatchers.add(hostsMatcher);\n       out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }  \n     ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n     RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n     RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n\n    if (mntproc \u003d\u003d MNTPROC.NULL) {\n      out \u003d nullOp(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n      // Only do port monitoring for MNT\n      if (!doPortMonitoring(info.remoteAddress())) {\n        out \u003d MountResponse.writeMNTResponse(Nfs3Status.NFS3ERR_ACCES, out,\n            xid, null);\n      } else {\n        out \u003d mnt(xdr, out, xid, client);\n      }\n    } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n      out \u003d dump(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n      out \u003d umnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n      umntall(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n      // Currently only support one NFS export \n      List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n      hostsMatchers.add(hostsMatcher);\n      out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }  \n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/mount/RpcProgramMountd.java",
      "extendedDetails": {}
    },
    "ec9ec0084eccdd45a8c3e37ef8121fb8bd44ecd0": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5469. Add configuration property for the sub-directroy export path. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1540443 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/11/13 8:07 PM",
      "commitName": "ec9ec0084eccdd45a8c3e37ef8121fb8bd44ecd0",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "30/09/13 12:21 PM",
      "commitNameOld": "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 40.37,
      "commitsBetweenForRepo": 263,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,35 +1,35 @@\n   public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n     RpcCall rpcCall \u003d (RpcCall) info.header();\n     final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n     byte[] data \u003d new byte[info.data().readableBytes()];\n     info.data().readBytes(data);\n     XDR xdr \u003d new XDR(data);\n     XDR out \u003d new XDR();\n     InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n \n     if (mntproc \u003d\u003d MNTPROC.NULL) {\n       out \u003d nullOp(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n       out \u003d mnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n       out \u003d dump(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n       out \u003d umnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n       umntall(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n-      // Currently only support one NFS export \"/\"\n+      // Currently only support one NFS export \n       List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n       hostsMatchers.add(hostsMatcher);\n       out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }  \n     ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n     RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n     RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n\n    if (mntproc \u003d\u003d MNTPROC.NULL) {\n      out \u003d nullOp(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n      out \u003d mnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n      out \u003d dump(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n      out \u003d umnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n      umntall(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n      // Currently only support one NFS export \n      List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n      hostsMatchers.add(hostsMatcher);\n      out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }  \n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/mount/RpcProgramMountd.java",
      "extendedDetails": {}
    },
    "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891": {
      "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
      "commitMessage": "HDFS-5230. Introduce RpcInfo to decouple XDR classes from the RPC API. Contributed by Haohui Mai\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527726 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/09/13 12:21 PM",
      "commitName": "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
      "commitAuthor": "Brandon Li",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-5230. Introduce RpcInfo to decouple XDR classes from the RPC API. Contributed by Haohui Mai\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527726 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/09/13 12:21 PM",
          "commitName": "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "25/09/13 2:59 PM",
          "commitNameOld": "35820262045dfc00471e25fe3d352cbcaf8632d1",
          "commitAuthorOld": "Brandon Li",
          "daysBetweenCommits": 4.89,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,35 @@\n-  public XDR handleInternal(RpcCall rpcCall, XDR xdr, XDR out,\n-      InetAddress client, Channel channel) {\n+  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n+    RpcCall rpcCall \u003d (RpcCall) info.header();\n     final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n+    byte[] data \u003d new byte[info.data().readableBytes()];\n+    info.data().readBytes(data);\n+    XDR xdr \u003d new XDR(data);\n+    XDR out \u003d new XDR();\n+    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n+\n     if (mntproc \u003d\u003d MNTPROC.NULL) {\n       out \u003d nullOp(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n       out \u003d mnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n       out \u003d dump(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n       out \u003d umnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n       umntall(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n       // Currently only support one NFS export \"/\"\n       List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n       hostsMatchers.add(hostsMatcher);\n       out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }  \n-    return out;\n+    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n+    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n+    RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n\n    if (mntproc \u003d\u003d MNTPROC.NULL) {\n      out \u003d nullOp(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n      out \u003d mnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n      out \u003d dump(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n      out \u003d umnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n      umntall(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n      // Currently only support one NFS export \"/\"\n      List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n      hostsMatchers.add(hostsMatcher);\n      out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }  \n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/mount/RpcProgramMountd.java",
          "extendedDetails": {
            "oldValue": "[rpcCall-RpcCall, xdr-XDR, out-XDR, client-InetAddress, channel-Channel]",
            "newValue": "[ctx-ChannelHandlerContext, info-RpcInfo]"
          }
        },
        {
          "type": "Yreturntypechange",
          "commitMessage": "HDFS-5230. Introduce RpcInfo to decouple XDR classes from the RPC API. Contributed by Haohui Mai\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527726 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/09/13 12:21 PM",
          "commitName": "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "25/09/13 2:59 PM",
          "commitNameOld": "35820262045dfc00471e25fe3d352cbcaf8632d1",
          "commitAuthorOld": "Brandon Li",
          "daysBetweenCommits": 4.89,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,35 @@\n-  public XDR handleInternal(RpcCall rpcCall, XDR xdr, XDR out,\n-      InetAddress client, Channel channel) {\n+  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n+    RpcCall rpcCall \u003d (RpcCall) info.header();\n     final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n+    byte[] data \u003d new byte[info.data().readableBytes()];\n+    info.data().readBytes(data);\n+    XDR xdr \u003d new XDR(data);\n+    XDR out \u003d new XDR();\n+    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n+\n     if (mntproc \u003d\u003d MNTPROC.NULL) {\n       out \u003d nullOp(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n       out \u003d mnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n       out \u003d dump(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n       out \u003d umnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n       umntall(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n       // Currently only support one NFS export \"/\"\n       List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n       hostsMatchers.add(hostsMatcher);\n       out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }  \n-    return out;\n+    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n+    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n+    RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n\n    if (mntproc \u003d\u003d MNTPROC.NULL) {\n      out \u003d nullOp(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n      out \u003d mnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n      out \u003d dump(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n      out \u003d umnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n      umntall(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n      // Currently only support one NFS export \"/\"\n      List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n      hostsMatchers.add(hostsMatcher);\n      out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }  \n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/mount/RpcProgramMountd.java",
          "extendedDetails": {
            "oldValue": "XDR",
            "newValue": "void"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5230. Introduce RpcInfo to decouple XDR classes from the RPC API. Contributed by Haohui Mai\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1527726 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "30/09/13 12:21 PM",
          "commitName": "25cdbdb71a65242b2bc08ca1d61f2c0f7d7ea891",
          "commitAuthor": "Brandon Li",
          "commitDateOld": "25/09/13 2:59 PM",
          "commitNameOld": "35820262045dfc00471e25fe3d352cbcaf8632d1",
          "commitAuthorOld": "Brandon Li",
          "daysBetweenCommits": 4.89,
          "commitsBetweenForRepo": 32,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,27 +1,35 @@\n-  public XDR handleInternal(RpcCall rpcCall, XDR xdr, XDR out,\n-      InetAddress client, Channel channel) {\n+  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n+    RpcCall rpcCall \u003d (RpcCall) info.header();\n     final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n+    byte[] data \u003d new byte[info.data().readableBytes()];\n+    info.data().readBytes(data);\n+    XDR xdr \u003d new XDR(data);\n+    XDR out \u003d new XDR();\n+    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n+\n     if (mntproc \u003d\u003d MNTPROC.NULL) {\n       out \u003d nullOp(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n       out \u003d mnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n       out \u003d dump(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n       out \u003d umnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n       umntall(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n       // Currently only support one NFS export \"/\"\n       List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n       hostsMatchers.add(hostsMatcher);\n       out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.getInstance(xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n           out);\n     }  \n-    return out;\n+    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n+    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n+    RpcUtil.sendRpcResponse(ctx, rsp);\n   }\n\\ No newline at end of file\n",
          "actualSource": "  public void handleInternal(ChannelHandlerContext ctx, RpcInfo info) {\n    RpcCall rpcCall \u003d (RpcCall) info.header();\n    final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    byte[] data \u003d new byte[info.data().readableBytes()];\n    info.data().readBytes(data);\n    XDR xdr \u003d new XDR(data);\n    XDR out \u003d new XDR();\n    InetAddress client \u003d ((InetSocketAddress) info.remoteAddress()).getAddress();\n\n    if (mntproc \u003d\u003d MNTPROC.NULL) {\n      out \u003d nullOp(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n      out \u003d mnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n      out \u003d dump(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n      out \u003d umnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n      umntall(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n      // Currently only support one NFS export \"/\"\n      List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n      hostsMatchers.add(hostsMatcher);\n      out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }  \n    ChannelBuffer buf \u003d ChannelBuffers.wrappedBuffer(out.asReadOnlyWrap().buffer());\n    RpcResponse rsp \u003d new RpcResponse(buf, info.remoteAddress());\n    RpcUtil.sendRpcResponse(ctx, rsp);\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/mount/RpcProgramMountd.java",
          "extendedDetails": {}
        }
      ]
    },
    "5e18410e06dd63113c49029894007e0878312903": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5212. Refactor RpcMessage and NFS3Response to support different types of authentication information. Contributed by Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1524298 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/09/13 11:08 PM",
      "commitName": "5e18410e06dd63113c49029894007e0878312903",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "10/09/13 12:29 PM",
      "commitNameOld": "613979c8fdacf25fd563395ecc399c4de94d3ee7",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 7.44,
      "commitsBetweenForRepo": 41,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,26 +1,27 @@\n   public XDR handleInternal(RpcCall rpcCall, XDR xdr, XDR out,\n       InetAddress client, Channel channel) {\n     final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n     if (mntproc \u003d\u003d MNTPROC.NULL) {\n       out \u003d nullOp(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n       out \u003d mnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n       out \u003d dump(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n       out \u003d umnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n       umntall(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n       // Currently only support one NFS export \"/\"\n       List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n       hostsMatchers.add(hostsMatcher);\n       out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n     } else {\n       // Invalid procedure\n-      RpcAcceptedReply.voidReply(out, xid,\n-          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n+      RpcAcceptedReply.getInstance(xid,\n+          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n+          out);\n     }  \n     return out;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public XDR handleInternal(RpcCall rpcCall, XDR xdr, XDR out,\n      InetAddress client, Channel channel) {\n    final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    if (mntproc \u003d\u003d MNTPROC.NULL) {\n      out \u003d nullOp(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n      out \u003d mnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n      out \u003d dump(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n      out \u003d umnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n      umntall(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n      // Currently only support one NFS export \"/\"\n      List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n      hostsMatchers.add(hostsMatcher);\n      out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.getInstance(xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL, new VerifierNone()).write(\n          out);\n    }  \n    return out;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/mount/RpcProgramMountd.java",
      "extendedDetails": {}
    },
    "cbca1668317f3f2d295eea53d7bd020bda4a810f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5136 MNT EXPORT should give the full group list which can mount the exports. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1519222 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "31/08/13 2:12 PM",
      "commitName": "cbca1668317f3f2d295eea53d7bd020bda4a810f",
      "commitAuthor": "Brandon Li",
      "commitDateOld": "23/08/13 2:14 PM",
      "commitNameOld": "15632cd76f12c2f7df50d0df4865fbe3d8261597",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 8.0,
      "commitsBetweenForRepo": 45,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,23 +1,26 @@\n   public XDR handleInternal(RpcCall rpcCall, XDR xdr, XDR out,\n       InetAddress client, Channel channel) {\n     final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n     if (mntproc \u003d\u003d MNTPROC.NULL) {\n       out \u003d nullOp(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n       out \u003d mnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n       out \u003d dump(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n       out \u003d umnt(xdr, out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n       umntall(out, xid, client);\n     } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n-      out \u003d MountResponse.writeExportList(out, xid, exports);\n+      // Currently only support one NFS export \"/\"\n+      List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n+      hostsMatchers.add(hostsMatcher);\n+      out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.voidReply(out, xid,\n           RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n     }  \n     return out;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public XDR handleInternal(RpcCall rpcCall, XDR xdr, XDR out,\n      InetAddress client, Channel channel) {\n    final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    if (mntproc \u003d\u003d MNTPROC.NULL) {\n      out \u003d nullOp(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n      out \u003d mnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n      out \u003d dump(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n      out \u003d umnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n      umntall(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n      // Currently only support one NFS export \"/\"\n      List\u003cNfsExports\u003e hostsMatchers \u003d new ArrayList\u003cNfsExports\u003e();\n      hostsMatchers.add(hostsMatcher);\n      out \u003d MountResponse.writeExportList(out, xid, exports, hostsMatchers);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.voidReply(out, xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n    }  \n    return out;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/mount/RpcProgramMountd.java",
      "extendedDetails": {}
    },
    "58d75576c4d2a03d4954174bc223ed0334b34fee": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-4962. Use enum for nfs constants. Contributed by Tsz Wo (Nicholas) SZE.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1501851 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "10/07/13 10:01 AM",
      "commitName": "58d75576c4d2a03d4954174bc223ed0334b34fee",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "02/07/13 10:31 AM",
      "commitNameOld": "37f587563a943a827fbff865f5302bac6d202415",
      "commitAuthorOld": "Brandon Li",
      "daysBetweenCommits": 7.98,
      "commitsBetweenForRepo": 31,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,22 +1,23 @@\n   public XDR handleInternal(RpcCall rpcCall, XDR xdr, XDR out,\n       InetAddress client, Channel channel) {\n-    int procedure \u003d rpcCall.getProcedure();\n+    final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n     int xid \u003d rpcCall.getXid();\n-    if (procedure \u003d\u003d MNTPROC_NULL) {\n+    if (mntproc \u003d\u003d MNTPROC.NULL) {\n       out \u003d nullOp(out, xid, client);\n-    } else if (procedure \u003d\u003d MNTPROC_MNT) {\n+    } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n       out \u003d mnt(xdr, out, xid, client);\n-    } else if (procedure \u003d\u003d MNTPROC_DUMP) {\n+    } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n       out \u003d dump(out, xid, client);\n-    } else if (procedure \u003d\u003d MNTPROC_UMNT) {      \n+    } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n       out \u003d umnt(xdr, out, xid, client);\n-    } else if (procedure \u003d\u003d MNTPROC_UMNTALL) {\n+    } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n       umntall(out, xid, client);\n-    } else if (procedure \u003d\u003d MNTPROC_EXPORT) {\n+    } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n       out \u003d MountResponse.writeExportList(out, xid, exports);\n     } else {\n       // Invalid procedure\n       RpcAcceptedReply.voidReply(out, xid,\n-          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);    }  \n+          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n+    }  \n     return out;\n   }\n\\ No newline at end of file\n",
      "actualSource": "  public XDR handleInternal(RpcCall rpcCall, XDR xdr, XDR out,\n      InetAddress client, Channel channel) {\n    final MNTPROC mntproc \u003d MNTPROC.fromValue(rpcCall.getProcedure());\n    int xid \u003d rpcCall.getXid();\n    if (mntproc \u003d\u003d MNTPROC.NULL) {\n      out \u003d nullOp(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.MNT) {\n      out \u003d mnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.DUMP) {\n      out \u003d dump(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNT) {      \n      out \u003d umnt(xdr, out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.UMNTALL) {\n      umntall(out, xid, client);\n    } else if (mntproc \u003d\u003d MNTPROC.EXPORT) {\n      out \u003d MountResponse.writeExportList(out, xid, exports);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.voidReply(out, xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);\n    }  \n    return out;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/mount/RpcProgramMountd.java",
      "extendedDetails": {}
    },
    "37f587563a943a827fbff865f5302bac6d202415": {
      "type": "Yintroduced",
      "commitMessage": "HDFS-4762 Provide HDFS based NFSv3 and Mountd implementation. Contributed by Brandon Li\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1499029 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "02/07/13 10:31 AM",
      "commitName": "37f587563a943a827fbff865f5302bac6d202415",
      "commitAuthor": "Brandon Li",
      "diff": "@@ -0,0 +1,22 @@\n+  public XDR handleInternal(RpcCall rpcCall, XDR xdr, XDR out,\n+      InetAddress client, Channel channel) {\n+    int procedure \u003d rpcCall.getProcedure();\n+    int xid \u003d rpcCall.getXid();\n+    if (procedure \u003d\u003d MNTPROC_NULL) {\n+      out \u003d nullOp(out, xid, client);\n+    } else if (procedure \u003d\u003d MNTPROC_MNT) {\n+      out \u003d mnt(xdr, out, xid, client);\n+    } else if (procedure \u003d\u003d MNTPROC_DUMP) {\n+      out \u003d dump(out, xid, client);\n+    } else if (procedure \u003d\u003d MNTPROC_UMNT) {      \n+      out \u003d umnt(xdr, out, xid, client);\n+    } else if (procedure \u003d\u003d MNTPROC_UMNTALL) {\n+      umntall(out, xid, client);\n+    } else if (procedure \u003d\u003d MNTPROC_EXPORT) {\n+      out \u003d MountResponse.writeExportList(out, xid, exports);\n+    } else {\n+      // Invalid procedure\n+      RpcAcceptedReply.voidReply(out, xid,\n+          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);    }  \n+    return out;\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  public XDR handleInternal(RpcCall rpcCall, XDR xdr, XDR out,\n      InetAddress client, Channel channel) {\n    int procedure \u003d rpcCall.getProcedure();\n    int xid \u003d rpcCall.getXid();\n    if (procedure \u003d\u003d MNTPROC_NULL) {\n      out \u003d nullOp(out, xid, client);\n    } else if (procedure \u003d\u003d MNTPROC_MNT) {\n      out \u003d mnt(xdr, out, xid, client);\n    } else if (procedure \u003d\u003d MNTPROC_DUMP) {\n      out \u003d dump(out, xid, client);\n    } else if (procedure \u003d\u003d MNTPROC_UMNT) {      \n      out \u003d umnt(xdr, out, xid, client);\n    } else if (procedure \u003d\u003d MNTPROC_UMNTALL) {\n      umntall(out, xid, client);\n    } else if (procedure \u003d\u003d MNTPROC_EXPORT) {\n      out \u003d MountResponse.writeExportList(out, xid, exports);\n    } else {\n      // Invalid procedure\n      RpcAcceptedReply.voidReply(out, xid,\n          RpcAcceptedReply.AcceptState.PROC_UNAVAIL);    }  \n    return out;\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-nfs/src/main/java/org/apache/hadoop/hdfs/nfs/mount/RpcProgramMountd.java"
    }
  }
}