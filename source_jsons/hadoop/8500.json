{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FSImage.java",
  "functionName": "doUpgrade",
  "functionId": "doUpgrade___target-FSNamesystem",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
  "functionStartLine": 452,
  "functionEndLine": 516,
  "numCommitsSeen": 134,
  "timeTaken": 7959,
  "changeHistory": [
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
    "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846",
    "43b41f22411439c5e23629197fb2fde45dcf0f0f",
    "56205ca7d7f3b2a7e55f48b9cf444326e1d2b1a7",
    "bc962d6df470e3de18df3a4fd9f8a9853953bda1",
    "00067895a01c66d53715b50bbcb3605efd6425f2",
    "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
    "d8bc523754181b4c1321bcfab886ebf228d9c98f",
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
    "706394d03992b394e9f907aff2155df493e4ea4e",
    "41e56dfecee0db1975c9859017c0de1226afb4b5",
    "2481474bd9c50a23e4fd2eea67ac2dea11ca1f58",
    "f87a4b40bc99e76602a75906df31747cfdbff78a",
    "06e84a1bca19bd01568a3095e33944d4d6387fd3",
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
    "d86f3183d93714ba078416af4f609d26376eadb0",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
    "5147e283ad9757ac2cabaf282ae5cbba76826ede",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc"
  ],
  "changeHistoryShort": {
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": "Ybodychange",
    "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846": "Ybodychange",
    "43b41f22411439c5e23629197fb2fde45dcf0f0f": "Ybodychange",
    "56205ca7d7f3b2a7e55f48b9cf444326e1d2b1a7": "Ybodychange",
    "bc962d6df470e3de18df3a4fd9f8a9853953bda1": "Ybodychange",
    "00067895a01c66d53715b50bbcb3605efd6425f2": "Ybodychange",
    "edb6dc5f303093c2604cd07b0c0dacf12dbce5de": "Ymultichange(Ymodifierchange,Ybodychange)",
    "d8bc523754181b4c1321bcfab886ebf228d9c98f": "Ybodychange",
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8": "Ybodychange",
    "706394d03992b394e9f907aff2155df493e4ea4e": "Ybodychange",
    "41e56dfecee0db1975c9859017c0de1226afb4b5": "Ybodychange",
    "2481474bd9c50a23e4fd2eea67ac2dea11ca1f58": "Ybodychange",
    "f87a4b40bc99e76602a75906df31747cfdbff78a": "Ybodychange",
    "06e84a1bca19bd01568a3095e33944d4d6387fd3": "Ymultichange(Yparameterchange,Ybodychange)",
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324": "Ybodychange",
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": "Yfilerename",
    "d86f3183d93714ba078416af4f609d26376eadb0": "Yfilerename",
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": "Ybodychange",
    "5147e283ad9757ac2cabaf282ae5cbba76826ede": "Ybodychange",
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": "Yintroduced"
  },
  "changeHistoryDetails": {
    "6ae2a0d048e133b43249c248a75a4d77d9abb80d": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8249. Separate HdfsConstants into the client and the server side class. Contributed by Haohui Mai.\n",
      "commitDate": "02/05/15 10:03 AM",
      "commitName": "6ae2a0d048e133b43249c248a75a4d77d9abb80d",
      "commitAuthor": "Haohui Mai",
      "commitDateOld": "14/04/15 3:05 PM",
      "commitNameOld": "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 17.79,
      "commitsBetweenForRepo": 154,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   void doUpgrade(FSNamesystem target) throws IOException {\n     checkUpgrade();\n \n     // load the latest image\n \n     // Do upgrade for each directory\n     this.loadFSImage(target, StartupOption.UPGRADE, null);\n     target.checkRollingUpgrade(\"upgrade namenode\");\n     \n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n-    storage.layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n+    storage.layoutVersion \u003d HdfsServerConstants.NAMENODE_LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n     LOG.info(\"Starting upgrade of local storage directories.\"\n         + \"\\n   old LV \u003d \" + oldLV\n         + \"; old CTime \u003d \" + oldCTime\n         + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n         + \"; new CTime \u003d \" + storage.getCTime());\n     // Do upgrade for each directory\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         NNUpgradeUtil.doPreUpgrade(conf, sd);\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     if (target.isHaEnabled()) {\n       editLog.doPreUpgradeOfSharedLog();\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     // upgrade shared edit storage first\n     if (target.isHaEnabled()) {\n       editLog.doUpgradeOfSharedLog();\n     }\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         NNUpgradeUtil.doUpgrade(sd, storage);\n       } catch (IOException ioe) {\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       // during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doUpgrade(FSNamesystem target) throws IOException {\n    checkUpgrade();\n\n    // load the latest image\n\n    // Do upgrade for each directory\n    this.loadFSImage(target, StartupOption.UPGRADE, null);\n    target.checkRollingUpgrade(\"upgrade namenode\");\n    \n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsServerConstants.NAMENODE_LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n    LOG.info(\"Starting upgrade of local storage directories.\"\n        + \"\\n   old LV \u003d \" + oldLV\n        + \"; old CTime \u003d \" + oldCTime\n        + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n        + \"; new CTime \u003d \" + storage.getCTime());\n    // Do upgrade for each directory\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doPreUpgrade(conf, sd);\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    if (target.isHaEnabled()) {\n      editLog.doPreUpgradeOfSharedLog();\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    // upgrade shared edit storage first\n    if (target.isHaEnabled()) {\n      editLog.doUpgradeOfSharedLog();\n    }\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doUpgrade(sd, storage);\n      } catch (IOException ioe) {\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    \n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      // during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-8127. NameNode Failover during HA upgrade can cause DataNode to finalize upgrade. Contributed by Jing Zhao.\n",
      "commitDate": "14/04/15 3:05 PM",
      "commitName": "fddd55279d0bdd08b3b40aba6fe2ded1d2e0d846",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "09/04/15 10:42 PM",
      "commitNameOld": "987c9e12e184b35a5abab49f4188e22509ad63a5",
      "commitAuthorOld": "Vinayakumar B",
      "daysBetweenCommits": 4.68,
      "commitsBetweenForRepo": 33,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   void doUpgrade(FSNamesystem target) throws IOException {\n-    checkUpgrade(target);\n+    checkUpgrade();\n \n     // load the latest image\n \n     // Do upgrade for each directory\n     this.loadFSImage(target, StartupOption.UPGRADE, null);\n     target.checkRollingUpgrade(\"upgrade namenode\");\n     \n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n     LOG.info(\"Starting upgrade of local storage directories.\"\n         + \"\\n   old LV \u003d \" + oldLV\n         + \"; old CTime \u003d \" + oldCTime\n         + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n         + \"; new CTime \u003d \" + storage.getCTime());\n     // Do upgrade for each directory\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         NNUpgradeUtil.doPreUpgrade(conf, sd);\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     if (target.isHaEnabled()) {\n       editLog.doPreUpgradeOfSharedLog();\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     // upgrade shared edit storage first\n     if (target.isHaEnabled()) {\n       editLog.doUpgradeOfSharedLog();\n     }\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         NNUpgradeUtil.doUpgrade(sd, storage);\n       } catch (IOException ioe) {\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       // during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doUpgrade(FSNamesystem target) throws IOException {\n    checkUpgrade();\n\n    // load the latest image\n\n    // Do upgrade for each directory\n    this.loadFSImage(target, StartupOption.UPGRADE, null);\n    target.checkRollingUpgrade(\"upgrade namenode\");\n    \n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n    LOG.info(\"Starting upgrade of local storage directories.\"\n        + \"\\n   old LV \u003d \" + oldLV\n        + \"; old CTime \u003d \" + oldCTime\n        + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n        + \"; new CTime \u003d \" + storage.getCTime());\n    // Do upgrade for each directory\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doPreUpgrade(conf, sd);\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    if (target.isHaEnabled()) {\n      editLog.doPreUpgradeOfSharedLog();\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    // upgrade shared edit storage first\n    if (target.isHaEnabled()) {\n      editLog.doUpgradeOfSharedLog();\n    }\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doUpgrade(sd, storage);\n      } catch (IOException ioe) {\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    \n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      // during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "43b41f22411439c5e23629197fb2fde45dcf0f0f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-7929. inotify unable fetch pre-upgrade edit log segments once upgrade starts (Zhe Zhang via Colin P. McCabe)\n",
      "commitDate": "18/03/15 6:48 PM",
      "commitName": "43b41f22411439c5e23629197fb2fde45dcf0f0f",
      "commitAuthor": "Colin Patrick Mccabe",
      "commitDateOld": "03/03/15 10:55 AM",
      "commitNameOld": "1004473aa612ee3703394943f25687aa5bef47ea",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 15.29,
      "commitsBetweenForRepo": 132,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,65 +1,65 @@\n   void doUpgrade(FSNamesystem target) throws IOException {\n     checkUpgrade(target);\n \n     // load the latest image\n \n     // Do upgrade for each directory\n     this.loadFSImage(target, StartupOption.UPGRADE, null);\n     target.checkRollingUpgrade(\"upgrade namenode\");\n     \n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n     LOG.info(\"Starting upgrade of local storage directories.\"\n         + \"\\n   old LV \u003d \" + oldLV\n         + \"; old CTime \u003d \" + oldCTime\n         + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n         + \"; new CTime \u003d \" + storage.getCTime());\n     // Do upgrade for each directory\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n-        NNUpgradeUtil.doPreUpgrade(sd);\n+        NNUpgradeUtil.doPreUpgrade(conf, sd);\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     if (target.isHaEnabled()) {\n       editLog.doPreUpgradeOfSharedLog();\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     // upgrade shared edit storage first\n     if (target.isHaEnabled()) {\n       editLog.doUpgradeOfSharedLog();\n     }\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         NNUpgradeUtil.doUpgrade(sd, storage);\n       } catch (IOException ioe) {\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       // during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doUpgrade(FSNamesystem target) throws IOException {\n    checkUpgrade(target);\n\n    // load the latest image\n\n    // Do upgrade for each directory\n    this.loadFSImage(target, StartupOption.UPGRADE, null);\n    target.checkRollingUpgrade(\"upgrade namenode\");\n    \n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n    LOG.info(\"Starting upgrade of local storage directories.\"\n        + \"\\n   old LV \u003d \" + oldLV\n        + \"; old CTime \u003d \" + oldCTime\n        + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n        + \"; new CTime \u003d \" + storage.getCTime());\n    // Do upgrade for each directory\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doPreUpgrade(conf, sd);\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    if (target.isHaEnabled()) {\n      editLog.doPreUpgradeOfSharedLog();\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    // upgrade shared edit storage first\n    if (target.isHaEnabled()) {\n      editLog.doUpgradeOfSharedLog();\n    }\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doUpgrade(sd, storage);\n      } catch (IOException ioe) {\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    \n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      // during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "56205ca7d7f3b2a7e55f48b9cf444326e1d2b1a7": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5840. Follow-up to HDFS-5138 to improve error handling during partial upgrade failures. Contributed by Aaron T. Myers, Suresh Srinivas, and Jing Zhao.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1581260 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/03/14 11:48 PM",
      "commitName": "56205ca7d7f3b2a7e55f48b9cf444326e1d2b1a7",
      "commitAuthor": "Jing Zhao",
      "commitDateOld": "24/03/14 4:32 PM",
      "commitNameOld": "c2ef7e239eb0e81cf8a3e971378e9e696202de67",
      "commitAuthorOld": "Arpit Agarwal",
      "daysBetweenCommits": 0.3,
      "commitsBetweenForRepo": 5,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,64 +1,65 @@\n   void doUpgrade(FSNamesystem target) throws IOException {\n     checkUpgrade(target);\n \n     // load the latest image\n \n     // Do upgrade for each directory\n     this.loadFSImage(target, StartupOption.UPGRADE, null);\n     target.checkRollingUpgrade(\"upgrade namenode\");\n     \n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n     LOG.info(\"Starting upgrade of local storage directories.\"\n         + \"\\n   old LV \u003d \" + oldLV\n         + \"; old CTime \u003d \" + oldCTime\n         + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n         + \"; new CTime \u003d \" + storage.getCTime());\n     // Do upgrade for each directory\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         NNUpgradeUtil.doPreUpgrade(sd);\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     if (target.isHaEnabled()) {\n       editLog.doPreUpgradeOfSharedLog();\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n+    // upgrade shared edit storage first\n+    if (target.isHaEnabled()) {\n+      editLog.doUpgradeOfSharedLog();\n+    }\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         NNUpgradeUtil.doUpgrade(sd, storage);\n       } catch (IOException ioe) {\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n-    if (target.isHaEnabled()) {\n-      editLog.doUpgradeOfSharedLog();\n-    }\n     storage.reportErrorsOnDirectories(errorSDs);\n     \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       // during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doUpgrade(FSNamesystem target) throws IOException {\n    checkUpgrade(target);\n\n    // load the latest image\n\n    // Do upgrade for each directory\n    this.loadFSImage(target, StartupOption.UPGRADE, null);\n    target.checkRollingUpgrade(\"upgrade namenode\");\n    \n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n    LOG.info(\"Starting upgrade of local storage directories.\"\n        + \"\\n   old LV \u003d \" + oldLV\n        + \"; old CTime \u003d \" + oldCTime\n        + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n        + \"; new CTime \u003d \" + storage.getCTime());\n    // Do upgrade for each directory\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doPreUpgrade(sd);\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    if (target.isHaEnabled()) {\n      editLog.doPreUpgradeOfSharedLog();\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    // upgrade shared edit storage first\n    if (target.isHaEnabled()) {\n      editLog.doUpgradeOfSharedLog();\n    }\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doUpgrade(sd, storage);\n      } catch (IOException ioe) {\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    \n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      // during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "bc962d6df470e3de18df3a4fd9f8a9853953bda1": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5945. Add rolling upgrade information to fsimage; and disallow upgrade and rolling upgrade to be started simultaneously.  Contributed by szetszwo \u0026 jing9\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1569515 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/02/14 12:12 PM",
      "commitName": "bc962d6df470e3de18df3a4fd9f8a9853953bda1",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "14/02/14 4:28 PM",
      "commitNameOld": "470d4253b246670f220eec81dd617ba0ee979623",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 3.82,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,64 @@\n   void doUpgrade(FSNamesystem target) throws IOException {\n-    // Upgrade is allowed only if there are \n-    // no previous fs states in any of the local directories\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n-      StorageDirectory sd \u003d it.next();\n-      if (sd.getPreviousDir().exists())\n-        throw new InconsistentFSStateException(sd.getRoot(),\n-            \"previous fs state should not exist during upgrade. \"\n-            + \"Finalize or rollback first.\");\n-    }\n+    checkUpgrade(target);\n \n     // load the latest image\n \n     // Do upgrade for each directory\n     this.loadFSImage(target, StartupOption.UPGRADE, null);\n+    target.checkRollingUpgrade(\"upgrade namenode\");\n     \n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n     LOG.info(\"Starting upgrade of local storage directories.\"\n         + \"\\n   old LV \u003d \" + oldLV\n         + \"; old CTime \u003d \" + oldCTime\n         + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n         + \"; new CTime \u003d \" + storage.getCTime());\n     // Do upgrade for each directory\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         NNUpgradeUtil.doPreUpgrade(sd);\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     if (target.isHaEnabled()) {\n       editLog.doPreUpgradeOfSharedLog();\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         NNUpgradeUtil.doUpgrade(sd, storage);\n       } catch (IOException ioe) {\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     if (target.isHaEnabled()) {\n       editLog.doUpgradeOfSharedLog();\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       // during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doUpgrade(FSNamesystem target) throws IOException {\n    checkUpgrade(target);\n\n    // load the latest image\n\n    // Do upgrade for each directory\n    this.loadFSImage(target, StartupOption.UPGRADE, null);\n    target.checkRollingUpgrade(\"upgrade namenode\");\n    \n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n    LOG.info(\"Starting upgrade of local storage directories.\"\n        + \"\\n   old LV \u003d \" + oldLV\n        + \"; old CTime \u003d \" + oldCTime\n        + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n        + \"; new CTime \u003d \" + storage.getCTime());\n    // Do upgrade for each directory\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doPreUpgrade(sd);\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    if (target.isHaEnabled()) {\n      editLog.doPreUpgradeOfSharedLog();\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doUpgrade(sd, storage);\n      } catch (IOException ioe) {\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    if (target.isHaEnabled()) {\n      editLog.doUpgradeOfSharedLog();\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    \n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      // during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "00067895a01c66d53715b50bbcb3605efd6425f2": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5754. Split LayoutVerion into NameNodeLayoutVersion and DataNodeLayoutVersion. Contributed by Brandon Li\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1563041 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/01/14 7:21 PM",
      "commitName": "00067895a01c66d53715b50bbcb3605efd6425f2",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "26/01/14 8:34 AM",
      "commitNameOld": "a9110e178837bdcd236e528875daa3651e13dacc",
      "commitAuthorOld": "",
      "daysBetweenCommits": 4.45,
      "commitsBetweenForRepo": 15,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,71 +1,71 @@\n   void doUpgrade(FSNamesystem target) throws IOException {\n     // Upgrade is allowed only if there are \n     // no previous fs states in any of the local directories\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n \n     // Do upgrade for each directory\n     this.loadFSImage(target, StartupOption.UPGRADE, null);\n     \n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n-    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n+    storage.layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n     LOG.info(\"Starting upgrade of local storage directories.\"\n         + \"\\n   old LV \u003d \" + oldLV\n         + \"; old CTime \u003d \" + oldCTime\n         + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n         + \"; new CTime \u003d \" + storage.getCTime());\n     // Do upgrade for each directory\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         NNUpgradeUtil.doPreUpgrade(sd);\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     if (target.isHaEnabled()) {\n       editLog.doPreUpgradeOfSharedLog();\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         NNUpgradeUtil.doUpgrade(sd, storage);\n       } catch (IOException ioe) {\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     if (target.isHaEnabled()) {\n       editLog.doUpgradeOfSharedLog();\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       // during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void doUpgrade(FSNamesystem target) throws IOException {\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the local directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n\n    // Do upgrade for each directory\n    this.loadFSImage(target, StartupOption.UPGRADE, null);\n    \n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.NAMENODE_LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n    LOG.info(\"Starting upgrade of local storage directories.\"\n        + \"\\n   old LV \u003d \" + oldLV\n        + \"; old CTime \u003d \" + oldCTime\n        + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n        + \"; new CTime \u003d \" + storage.getCTime());\n    // Do upgrade for each directory\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doPreUpgrade(sd);\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    if (target.isHaEnabled()) {\n      editLog.doPreUpgradeOfSharedLog();\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doUpgrade(sd, storage);\n      } catch (IOException ioe) {\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    if (target.isHaEnabled()) {\n      editLog.doUpgradeOfSharedLog();\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    \n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      // during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "edb6dc5f303093c2604cd07b0c0dacf12dbce5de": {
      "type": "Ymultichange(Ymodifierchange,Ybodychange)",
      "commitMessage": "HDFS-5138. Support HDFS upgrade in HA. Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561381 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/01/14 12:01 PM",
      "commitName": "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Ymodifierchange",
          "commitMessage": "HDFS-5138. Support HDFS upgrade in HA. Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561381 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "25/01/14 12:01 PM",
          "commitName": "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "07/01/14 12:52 PM",
          "commitNameOld": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 17.96,
          "commitsBetweenForRepo": 91,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,70 @@\n-  private void doUpgrade(FSNamesystem target) throws IOException {\n+  void doUpgrade(FSNamesystem target) throws IOException {\n     // Upgrade is allowed only if there are \n-    // no previous fs states in any of the directories\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+    // no previous fs states in any of the local directories\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n-    this.loadFSImage(target, null);\n-\n     // Do upgrade for each directory\n+    this.loadFSImage(target, null, StartupOption.UPGRADE);\n+    \n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+    assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n+    LOG.info(\"Starting upgrade of local storage directories.\"\n+        + \"\\n   old LV \u003d \" + oldLV\n+        + \"; old CTime \u003d \" + oldCTime\n+        + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n+        + \"; new CTime \u003d \" + storage.getCTime());\n+    // Do upgrade for each directory\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n-      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n-               + \".\\n   old LV \u003d \" + oldLV\n-               + \"; old CTime \u003d \" + oldCTime\n-               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n-               + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n-        File curDir \u003d sd.getCurrentDir();\n-        File prevDir \u003d sd.getPreviousDir();\n-        File tmpDir \u003d sd.getPreviousTmp();\n-        assert curDir.exists() : \"Current directory must exist.\";\n-        assert !prevDir.exists() : \"previous directory must not exist.\";\n-        assert !tmpDir.exists() : \"previous.tmp directory must not exist.\";\n-        assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n-\n-        // rename current to tmp\n-        NNStorage.rename(curDir, tmpDir);\n-        \n-        if (!curDir.mkdir()) {\n-          throw new IOException(\"Cannot create directory \" + curDir);\n-        }\n+        NNUpgradeUtil.doPreUpgrade(sd);\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n+    if (target.isHaEnabled()) {\n+      editLog.doPreUpgradeOfSharedLog();\n+    }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n-        // Write the version file, since saveFsImage above only makes the\n-        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n-        storage.writeProperties(sd);\n-        \n-        File prevDir \u003d sd.getPreviousDir();\n-        File tmpDir \u003d sd.getPreviousTmp();\n-        // rename tmp to previous\n-        NNStorage.rename(tmpDir, prevDir);\n+        NNUpgradeUtil.doUpgrade(sd, storage);\n       } catch (IOException ioe) {\n-        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n-      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n+    }\n+    if (target.isHaEnabled()) {\n+      editLog.doUpgradeOfSharedLog();\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n-\n+    \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n-      //during upgrade, it\u0027s a fatal error to fail any storage directory\n+      // during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void doUpgrade(FSNamesystem target) throws IOException {\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the local directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    // Do upgrade for each directory\n    this.loadFSImage(target, null, StartupOption.UPGRADE);\n    \n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n    LOG.info(\"Starting upgrade of local storage directories.\"\n        + \"\\n   old LV \u003d \" + oldLV\n        + \"; old CTime \u003d \" + oldCTime\n        + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n        + \"; new CTime \u003d \" + storage.getCTime());\n    // Do upgrade for each directory\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doPreUpgrade(sd);\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    if (target.isHaEnabled()) {\n      editLog.doPreUpgradeOfSharedLog();\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doUpgrade(sd, storage);\n      } catch (IOException ioe) {\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    if (target.isHaEnabled()) {\n      editLog.doUpgradeOfSharedLog();\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    \n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      // during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[private]",
            "newValue": "[]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-5138. Support HDFS upgrade in HA. Contributed by Aaron T. Myers.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1561381 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "25/01/14 12:01 PM",
          "commitName": "edb6dc5f303093c2604cd07b0c0dacf12dbce5de",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "07/01/14 12:52 PM",
          "commitNameOld": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
          "commitAuthorOld": "Jing Zhao",
          "daysBetweenCommits": 17.96,
          "commitsBetweenForRepo": 91,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,84 +1,70 @@\n-  private void doUpgrade(FSNamesystem target) throws IOException {\n+  void doUpgrade(FSNamesystem target) throws IOException {\n     // Upgrade is allowed only if there are \n-    // no previous fs states in any of the directories\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+    // no previous fs states in any of the local directories\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n-    this.loadFSImage(target, null);\n-\n     // Do upgrade for each directory\n+    this.loadFSImage(target, null, StartupOption.UPGRADE);\n+    \n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+    assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n+    LOG.info(\"Starting upgrade of local storage directories.\"\n+        + \"\\n   old LV \u003d \" + oldLV\n+        + \"; old CTime \u003d \" + oldCTime\n+        + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n+        + \"; new CTime \u003d \" + storage.getCTime());\n+    // Do upgrade for each directory\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n-      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n-               + \".\\n   old LV \u003d \" + oldLV\n-               + \"; old CTime \u003d \" + oldCTime\n-               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n-               + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n-        File curDir \u003d sd.getCurrentDir();\n-        File prevDir \u003d sd.getPreviousDir();\n-        File tmpDir \u003d sd.getPreviousTmp();\n-        assert curDir.exists() : \"Current directory must exist.\";\n-        assert !prevDir.exists() : \"previous directory must not exist.\";\n-        assert !tmpDir.exists() : \"previous.tmp directory must not exist.\";\n-        assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n-\n-        // rename current to tmp\n-        NNStorage.rename(curDir, tmpDir);\n-        \n-        if (!curDir.mkdir()) {\n-          throw new IOException(\"Cannot create directory \" + curDir);\n-        }\n+        NNUpgradeUtil.doPreUpgrade(sd);\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n+    if (target.isHaEnabled()) {\n+      editLog.doPreUpgradeOfSharedLog();\n+    }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n-    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n-        // Write the version file, since saveFsImage above only makes the\n-        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n-        storage.writeProperties(sd);\n-        \n-        File prevDir \u003d sd.getPreviousDir();\n-        File tmpDir \u003d sd.getPreviousTmp();\n-        // rename tmp to previous\n-        NNStorage.rename(tmpDir, prevDir);\n+        NNUpgradeUtil.doUpgrade(sd, storage);\n       } catch (IOException ioe) {\n-        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n-      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n+    }\n+    if (target.isHaEnabled()) {\n+      editLog.doUpgradeOfSharedLog();\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n-\n+    \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n-      //during upgrade, it\u0027s a fatal error to fail any storage directory\n+      // during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n   }\n\\ No newline at end of file\n",
          "actualSource": "  void doUpgrade(FSNamesystem target) throws IOException {\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the local directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    // Do upgrade for each directory\n    this.loadFSImage(target, null, StartupOption.UPGRADE);\n    \n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n    LOG.info(\"Starting upgrade of local storage directories.\"\n        + \"\\n   old LV \u003d \" + oldLV\n        + \"; old CTime \u003d \" + oldCTime\n        + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n        + \"; new CTime \u003d \" + storage.getCTime());\n    // Do upgrade for each directory\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doPreUpgrade(sd);\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    if (target.isHaEnabled()) {\n      editLog.doPreUpgradeOfSharedLog();\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(false); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        NNUpgradeUtil.doUpgrade(sd, storage);\n      } catch (IOException ioe) {\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    if (target.isHaEnabled()) {\n      editLog.doUpgradeOfSharedLog();\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    \n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      // during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {}
        }
      ]
    },
    "d8bc523754181b4c1321bcfab886ebf228d9c98f": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-5753. Add new NN startup options for downgrade and rollback using upgrade marker.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-5535@1559907 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/01/14 6:38 PM",
      "commitName": "d8bc523754181b4c1321bcfab886ebf228d9c98f",
      "commitAuthor": "Tsz-wo Sze",
      "commitDateOld": "07/01/14 12:52 PM",
      "commitNameOld": "70cff9e2f0c8f78c1dc54a064182971bb2106795",
      "commitAuthorOld": "Jing Zhao",
      "daysBetweenCommits": 13.24,
      "commitsBetweenForRepo": 67,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,84 +1,84 @@\n   private void doUpgrade(FSNamesystem target) throws IOException {\n     // Upgrade is allowed only if there are \n     // no previous fs states in any of the directories\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n-    this.loadFSImage(target, null);\n+    this.loadFSImage(target, null, null);\n \n     // Do upgrade for each directory\n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n                + \".\\n   old LV \u003d \" + oldLV\n                + \"; old CTime \u003d \" + oldCTime\n                + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n                + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n         File curDir \u003d sd.getCurrentDir();\n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         assert curDir.exists() : \"Current directory must exist.\";\n         assert !prevDir.exists() : \"previous directory must not exist.\";\n         assert !tmpDir.exists() : \"previous.tmp directory must not exist.\";\n         assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n \n         // rename current to tmp\n         NNStorage.rename(curDir, tmpDir);\n         \n         if (!curDir.mkdir()) {\n           throw new IOException(\"Cannot create directory \" + curDir);\n         }\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         // Write the version file, since saveFsImage above only makes the\n         // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n         storage.writeProperties(sd);\n         \n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         // rename tmp to previous\n         NNStorage.rename(tmpDir, prevDir);\n       } catch (IOException ioe) {\n         LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n       LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       //during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doUpgrade(FSNamesystem target) throws IOException {\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage(target, null, null);\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        File curDir \u003d sd.getCurrentDir();\n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"previous directory must not exist.\";\n        assert !tmpDir.exists() : \"previous.tmp directory must not exist.\";\n        assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        if (!curDir.mkdir()) {\n          throw new IOException(\"Cannot create directory \" + curDir);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        // Write the version file, since saveFsImage above only makes the\n        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n        storage.writeProperties(sd);\n        \n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n\n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2686. Remove DistributedUpgrade related code. Contributed by Suresh Srinivas\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1375800 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "21/08/12 2:18 PM",
      "commitName": "6c0ccb5989c2053f5a1ebab0dd9fdb7b4019fda8",
      "commitAuthor": "Suresh Srinivas",
      "commitDateOld": "09/08/12 3:13 PM",
      "commitNameOld": "9d0f8792a9a1d3d2b24adfc2c213247a099e7ad1",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 11.96,
      "commitsBetweenForRepo": 66,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,84 @@\n   private void doUpgrade(FSNamesystem target) throws IOException {\n-    if(storage.getDistributedUpgradeState()) {\n-      // only distributed upgrade need to continue\n-      // don\u0027t do version upgrade\n-      this.loadFSImage(target, null);\n-      storage.initializeDistributedUpgrade();\n-      return;\n-    }\n     // Upgrade is allowed only if there are \n     // no previous fs states in any of the directories\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n     this.loadFSImage(target, null);\n \n     // Do upgrade for each directory\n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n                + \".\\n   old LV \u003d \" + oldLV\n                + \"; old CTime \u003d \" + oldCTime\n                + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n                + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n         File curDir \u003d sd.getCurrentDir();\n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         assert curDir.exists() : \"Current directory must exist.\";\n         assert !prevDir.exists() : \"previous directory must not exist.\";\n         assert !tmpDir.exists() : \"previous.tmp directory must not exist.\";\n         assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n \n         // rename current to tmp\n         NNStorage.rename(curDir, tmpDir);\n         \n         if (!curDir.mkdir()) {\n           throw new IOException(\"Cannot create directory \" + curDir);\n         }\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         // Write the version file, since saveFsImage above only makes the\n         // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n         storage.writeProperties(sd);\n         \n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         // rename tmp to previous\n         NNStorage.rename(tmpDir, prevDir);\n       } catch (IOException ioe) {\n         LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n       LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       //during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n-    storage.initializeDistributedUpgrade();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doUpgrade(FSNamesystem target) throws IOException {\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage(target, null);\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        File curDir \u003d sd.getCurrentDir();\n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"previous directory must not exist.\";\n        assert !tmpDir.exists() : \"previous.tmp directory must not exist.\";\n        assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        if (!curDir.mkdir()) {\n          throw new IOException(\"Cannot create directory \" + curDir);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        // Write the version file, since saveFsImage above only makes the\n        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n        storage.writeProperties(sd);\n        \n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n\n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "706394d03992b394e9f907aff2155df493e4ea4e": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-3004. Implement Recovery Mode. Contributed by Colin Patrick McCabe\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1311394 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "09/04/12 12:39 PM",
      "commitName": "706394d03992b394e9f907aff2155df493e4ea4e",
      "commitAuthor": "Eli Collins",
      "commitDateOld": "12/03/12 12:41 PM",
      "commitNameOld": "1a75ec82885e45baf4d5cd56d6c738d8e68d8bc7",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 28.0,
      "commitsBetweenForRepo": 204,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n   private void doUpgrade(FSNamesystem target) throws IOException {\n     if(storage.getDistributedUpgradeState()) {\n       // only distributed upgrade need to continue\n       // don\u0027t do version upgrade\n-      this.loadFSImage(target);\n+      this.loadFSImage(target, null);\n       storage.initializeDistributedUpgrade();\n       return;\n     }\n     // Upgrade is allowed only if there are \n     // no previous fs states in any of the directories\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n-    this.loadFSImage(target);\n+    this.loadFSImage(target, null);\n \n     // Do upgrade for each directory\n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n                + \".\\n   old LV \u003d \" + oldLV\n                + \"; old CTime \u003d \" + oldCTime\n                + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n                + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n         File curDir \u003d sd.getCurrentDir();\n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         assert curDir.exists() : \"Current directory must exist.\";\n         assert !prevDir.exists() : \"previous directory must not exist.\";\n         assert !tmpDir.exists() : \"previous.tmp directory must not exist.\";\n         assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n \n         // rename current to tmp\n         NNStorage.rename(curDir, tmpDir);\n         \n         if (!curDir.mkdir()) {\n           throw new IOException(\"Cannot create directory \" + curDir);\n         }\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         // Write the version file, since saveFsImage above only makes the\n         // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n         storage.writeProperties(sd);\n         \n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         // rename tmp to previous\n         NNStorage.rename(tmpDir, prevDir);\n       } catch (IOException ioe) {\n         LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n       LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       //during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n     storage.initializeDistributedUpgrade();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doUpgrade(FSNamesystem target) throws IOException {\n    if(storage.getDistributedUpgradeState()) {\n      // only distributed upgrade need to continue\n      // don\u0027t do version upgrade\n      this.loadFSImage(target, null);\n      storage.initializeDistributedUpgrade();\n      return;\n    }\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage(target, null);\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        File curDir \u003d sd.getCurrentDir();\n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"previous directory must not exist.\";\n        assert !tmpDir.exists() : \"previous.tmp directory must not exist.\";\n        assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        if (!curDir.mkdir()) {\n          throw new IOException(\"Cannot create directory \" + curDir);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        // Write the version file, since saveFsImage above only makes the\n        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n        storage.writeProperties(sd);\n        \n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n\n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n    storage.initializeDistributedUpgrade();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "41e56dfecee0db1975c9859017c0de1226afb4b5": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2952. NN should not start with upgrade option or with a pending an unfinalized upgrade. Contributed by Aaron T. Myers.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1245875 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "17/02/12 11:12 PM",
      "commitName": "41e56dfecee0db1975c9859017c0de1226afb4b5",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "14/02/12 12:37 PM",
      "commitNameOld": "011611c7659e02ff875ed0ffba184b9aa06504a8",
      "commitAuthorOld": "",
      "daysBetweenCommits": 3.44,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n   private void doUpgrade(FSNamesystem target) throws IOException {\n     if(storage.getDistributedUpgradeState()) {\n       // only distributed upgrade need to continue\n       // don\u0027t do version upgrade\n       this.loadFSImage(target);\n       storage.initializeDistributedUpgrade();\n       return;\n     }\n     // Upgrade is allowed only if there are \n     // no previous fs states in any of the directories\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n     this.loadFSImage(target);\n \n     // Do upgrade for each directory\n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n                + \".\\n   old LV \u003d \" + oldLV\n                + \"; old CTime \u003d \" + oldCTime\n                + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n                + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n         File curDir \u003d sd.getCurrentDir();\n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         assert curDir.exists() : \"Current directory must exist.\";\n-        assert !prevDir.exists() : \"prvious directory must not exist.\";\n-        assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n+        assert !prevDir.exists() : \"previous directory must not exist.\";\n+        assert !tmpDir.exists() : \"previous.tmp directory must not exist.\";\n         assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n \n         // rename current to tmp\n         NNStorage.rename(curDir, tmpDir);\n         \n         if (!curDir.mkdir()) {\n           throw new IOException(\"Cannot create directory \" + curDir);\n         }\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         // Write the version file, since saveFsImage above only makes the\n         // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n         storage.writeProperties(sd);\n         \n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         // rename tmp to previous\n         NNStorage.rename(tmpDir, prevDir);\n       } catch (IOException ioe) {\n         LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n       LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       //during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n     storage.initializeDistributedUpgrade();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doUpgrade(FSNamesystem target) throws IOException {\n    if(storage.getDistributedUpgradeState()) {\n      // only distributed upgrade need to continue\n      // don\u0027t do version upgrade\n      this.loadFSImage(target);\n      storage.initializeDistributedUpgrade();\n      return;\n    }\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage(target);\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        File curDir \u003d sd.getCurrentDir();\n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"previous directory must not exist.\";\n        assert !tmpDir.exists() : \"previous.tmp directory must not exist.\";\n        assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        if (!curDir.mkdir()) {\n          throw new IOException(\"Cannot create directory \" + curDir);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        // Write the version file, since saveFsImage above only makes the\n        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n        storage.writeProperties(sd);\n        \n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n\n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n    storage.initializeDistributedUpgrade();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "2481474bd9c50a23e4fd2eea67ac2dea11ca1f58": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-2634. Standby needs to ingest latest edit logs before transitioning to active. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1212187 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "08/12/11 3:55 PM",
      "commitName": "2481474bd9c50a23e4fd2eea67ac2dea11ca1f58",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "07/12/11 6:57 PM",
      "commitNameOld": "d9ea5bb48940c6ee2b6688a527ad74bccce6ed18",
      "commitAuthorOld": "",
      "daysBetweenCommits": 0.87,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n   private void doUpgrade(FSNamesystem target) throws IOException {\n     if(storage.getDistributedUpgradeState()) {\n       // only distributed upgrade need to continue\n       // don\u0027t do version upgrade\n       this.loadFSImage(target);\n       storage.initializeDistributedUpgrade();\n       return;\n     }\n     // Upgrade is allowed only if there are \n     // no previous fs states in any of the directories\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n     this.loadFSImage(target);\n \n     // Do upgrade for each directory\n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n                + \".\\n   old LV \u003d \" + oldLV\n                + \"; old CTime \u003d \" + oldCTime\n                + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n                + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n         File curDir \u003d sd.getCurrentDir();\n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         assert curDir.exists() : \"Current directory must exist.\";\n         assert !prevDir.exists() : \"prvious directory must not exist.\";\n         assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n-        assert !editLog.isOpenForWrite() : \"Edits log must not be open.\";\n+        assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n \n         // rename current to tmp\n         NNStorage.rename(curDir, tmpDir);\n         \n         if (!curDir.mkdir()) {\n           throw new IOException(\"Cannot create directory \" + curDir);\n         }\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         // Write the version file, since saveFsImage above only makes the\n         // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n         storage.writeProperties(sd);\n         \n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         // rename tmp to previous\n         NNStorage.rename(tmpDir, prevDir);\n       } catch (IOException ioe) {\n         LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n       LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       //during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n     storage.initializeDistributedUpgrade();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doUpgrade(FSNamesystem target) throws IOException {\n    if(storage.getDistributedUpgradeState()) {\n      // only distributed upgrade need to continue\n      // don\u0027t do version upgrade\n      this.loadFSImage(target);\n      storage.initializeDistributedUpgrade();\n      return;\n    }\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage(target);\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        File curDir \u003d sd.getCurrentDir();\n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"prvious directory must not exist.\";\n        assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n        assert !editLog.isSegmentOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        if (!curDir.mkdir()) {\n          throw new IOException(\"Cannot create directory \" + curDir);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        // Write the version file, since saveFsImage above only makes the\n        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n        storage.writeProperties(sd);\n        \n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n\n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n    storage.initializeDistributedUpgrade();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "f87a4b40bc99e76602a75906df31747cfdbff78a": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1975. Support for sharing the namenode state from active to standby. Contributed by Jitendra Nath Pandey, Aaron T Myers, and Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/branches/HDFS-1623@1208813 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/11/11 1:46 PM",
      "commitName": "f87a4b40bc99e76602a75906df31747cfdbff78a",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "01/11/11 9:44 AM",
      "commitNameOld": "496144158443078f5fc7c8930d971601f2b08dff",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 29.21,
      "commitsBetweenForRepo": 147,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n   private void doUpgrade(FSNamesystem target) throws IOException {\n     if(storage.getDistributedUpgradeState()) {\n       // only distributed upgrade need to continue\n       // don\u0027t do version upgrade\n       this.loadFSImage(target);\n       storage.initializeDistributedUpgrade();\n       return;\n     }\n     // Upgrade is allowed only if there are \n     // no previous fs states in any of the directories\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n     this.loadFSImage(target);\n \n     // Do upgrade for each directory\n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n                + \".\\n   old LV \u003d \" + oldLV\n                + \"; old CTime \u003d \" + oldCTime\n                + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n                + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n         File curDir \u003d sd.getCurrentDir();\n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         assert curDir.exists() : \"Current directory must exist.\";\n         assert !prevDir.exists() : \"prvious directory must not exist.\";\n         assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n-        assert !editLog.isOpen() : \"Edits log must not be open.\";\n+        assert !editLog.isOpenForWrite() : \"Edits log must not be open.\";\n \n         // rename current to tmp\n         NNStorage.rename(curDir, tmpDir);\n         \n         if (!curDir.mkdir()) {\n           throw new IOException(\"Cannot create directory \" + curDir);\n         }\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         // Write the version file, since saveFsImage above only makes the\n         // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n         storage.writeProperties(sd);\n         \n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         // rename tmp to previous\n         NNStorage.rename(tmpDir, prevDir);\n       } catch (IOException ioe) {\n         LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n       LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       //during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n     storage.initializeDistributedUpgrade();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doUpgrade(FSNamesystem target) throws IOException {\n    if(storage.getDistributedUpgradeState()) {\n      // only distributed upgrade need to continue\n      // don\u0027t do version upgrade\n      this.loadFSImage(target);\n      storage.initializeDistributedUpgrade();\n      return;\n    }\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage(target);\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        File curDir \u003d sd.getCurrentDir();\n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"prvious directory must not exist.\";\n        assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n        assert !editLog.isOpenForWrite() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        if (!curDir.mkdir()) {\n          throw new IOException(\"Cannot create directory \" + curDir);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        // Write the version file, since saveFsImage above only makes the\n        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n        storage.writeProperties(sd);\n        \n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n\n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n    storage.initializeDistributedUpgrade();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "06e84a1bca19bd01568a3095e33944d4d6387fd3": {
      "type": "Ymultichange(Yparameterchange,Ybodychange)",
      "commitMessage": "HDFS-2223. Untangle depencencies between NN components. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166466 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/09/11 4:23 PM",
      "commitName": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
      "commitAuthor": "Todd Lipcon",
      "subchanges": [
        {
          "type": "Yparameterchange",
          "commitMessage": "HDFS-2223. Untangle depencencies between NN components. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166466 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/09/11 4:23 PM",
          "commitName": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "06/09/11 1:27 PM",
          "commitNameOld": "bdc3720d5b67a1c8fc2dfb29be16e4155c0e7f15",
          "commitAuthorOld": "Jitendra Nath Pandey",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,92 +1,92 @@\n-  private void doUpgrade() throws IOException {\n+  private void doUpgrade(FSNamesystem target) throws IOException {\n     if(storage.getDistributedUpgradeState()) {\n       // only distributed upgrade need to continue\n       // don\u0027t do version upgrade\n-      this.loadFSImage();\n+      this.loadFSImage(target);\n       storage.initializeDistributedUpgrade();\n       return;\n     }\n     // Upgrade is allowed only if there are \n     // no previous fs states in any of the directories\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n-    this.loadFSImage();\n+    this.loadFSImage(target);\n \n     // Do upgrade for each directory\n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n                + \".\\n   old LV \u003d \" + oldLV\n                + \"; old CTime \u003d \" + oldCTime\n                + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n                + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n         File curDir \u003d sd.getCurrentDir();\n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         assert curDir.exists() : \"Current directory must exist.\";\n         assert !prevDir.exists() : \"prvious directory must not exist.\";\n         assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n         assert !editLog.isOpen() : \"Edits log must not be open.\";\n \n         // rename current to tmp\n         NNStorage.rename(curDir, tmpDir);\n         \n         if (!curDir.mkdir()) {\n           throw new IOException(\"Cannot create directory \" + curDir);\n         }\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n-    saveFSImageInAllDirs(editLog.getLastWrittenTxId());\n+    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         // Write the version file, since saveFsImage above only makes the\n         // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n         storage.writeProperties(sd);\n         \n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         // rename tmp to previous\n         NNStorage.rename(tmpDir, prevDir);\n       } catch (IOException ioe) {\n         LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n       LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       //during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n     storage.initializeDistributedUpgrade();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doUpgrade(FSNamesystem target) throws IOException {\n    if(storage.getDistributedUpgradeState()) {\n      // only distributed upgrade need to continue\n      // don\u0027t do version upgrade\n      this.loadFSImage(target);\n      storage.initializeDistributedUpgrade();\n      return;\n    }\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage(target);\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        File curDir \u003d sd.getCurrentDir();\n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"prvious directory must not exist.\";\n        assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n        assert !editLog.isOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        if (!curDir.mkdir()) {\n          throw new IOException(\"Cannot create directory \" + curDir);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        // Write the version file, since saveFsImage above only makes the\n        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n        storage.writeProperties(sd);\n        \n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n\n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n    storage.initializeDistributedUpgrade();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {
            "oldValue": "[]",
            "newValue": "[target-FSNamesystem]"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-2223. Untangle depencencies between NN components. Contributed by Todd Lipcon.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1166466 13f79535-47bb-0310-9956-ffa450edef68\n",
          "commitDate": "07/09/11 4:23 PM",
          "commitName": "06e84a1bca19bd01568a3095e33944d4d6387fd3",
          "commitAuthor": "Todd Lipcon",
          "commitDateOld": "06/09/11 1:27 PM",
          "commitNameOld": "bdc3720d5b67a1c8fc2dfb29be16e4155c0e7f15",
          "commitAuthorOld": "Jitendra Nath Pandey",
          "daysBetweenCommits": 1.12,
          "commitsBetweenForRepo": 13,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,92 +1,92 @@\n-  private void doUpgrade() throws IOException {\n+  private void doUpgrade(FSNamesystem target) throws IOException {\n     if(storage.getDistributedUpgradeState()) {\n       // only distributed upgrade need to continue\n       // don\u0027t do version upgrade\n-      this.loadFSImage();\n+      this.loadFSImage(target);\n       storage.initializeDistributedUpgrade();\n       return;\n     }\n     // Upgrade is allowed only if there are \n     // no previous fs states in any of the directories\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n-    this.loadFSImage();\n+    this.loadFSImage(target);\n \n     // Do upgrade for each directory\n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n                + \".\\n   old LV \u003d \" + oldLV\n                + \"; old CTime \u003d \" + oldCTime\n                + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n                + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n         File curDir \u003d sd.getCurrentDir();\n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         assert curDir.exists() : \"Current directory must exist.\";\n         assert !prevDir.exists() : \"prvious directory must not exist.\";\n         assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n         assert !editLog.isOpen() : \"Edits log must not be open.\";\n \n         // rename current to tmp\n         NNStorage.rename(curDir, tmpDir);\n         \n         if (!curDir.mkdir()) {\n           throw new IOException(\"Cannot create directory \" + curDir);\n         }\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n-    saveFSImageInAllDirs(editLog.getLastWrittenTxId());\n+    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         // Write the version file, since saveFsImage above only makes the\n         // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n         storage.writeProperties(sd);\n         \n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         // rename tmp to previous\n         NNStorage.rename(tmpDir, prevDir);\n       } catch (IOException ioe) {\n         LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n       LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       //during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n     storage.initializeDistributedUpgrade();\n   }\n\\ No newline at end of file\n",
          "actualSource": "  private void doUpgrade(FSNamesystem target) throws IOException {\n    if(storage.getDistributedUpgradeState()) {\n      // only distributed upgrade need to continue\n      // don\u0027t do version upgrade\n      this.loadFSImage(target);\n      storage.initializeDistributedUpgrade();\n      return;\n    }\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage(target);\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        File curDir \u003d sd.getCurrentDir();\n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"prvious directory must not exist.\";\n        assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n        assert !editLog.isOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        if (!curDir.mkdir()) {\n          throw new IOException(\"Cannot create directory \" + curDir);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(target, editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        // Write the version file, since saveFsImage above only makes the\n        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n        storage.writeProperties(sd);\n        \n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n\n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n    storage.initializeDistributedUpgrade();\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
          "extendedDetails": {}
        }
      ]
    },
    "8ae98a9d1ca4725e28783370517cb3a3ecda7324": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1620. Rename HdfsConstants -\u003e HdfsServerConstants, FSConstants -\u003e HdfsConstants. (Harsh J Chouraria via atm)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1165096 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "04/09/11 12:30 PM",
      "commitName": "8ae98a9d1ca4725e28783370517cb3a3ecda7324",
      "commitAuthor": "Aaron Myers",
      "commitDateOld": "24/08/11 5:14 PM",
      "commitNameOld": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 10.8,
      "commitsBetweenForRepo": 53,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,92 +1,92 @@\n   private void doUpgrade() throws IOException {\n     if(storage.getDistributedUpgradeState()) {\n       // only distributed upgrade need to continue\n       // don\u0027t do version upgrade\n       this.loadFSImage();\n       storage.initializeDistributedUpgrade();\n       return;\n     }\n     // Upgrade is allowed only if there are \n     // no previous fs states in any of the directories\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n     this.loadFSImage();\n \n     // Do upgrade for each directory\n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n-    storage.layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n+    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n                + \".\\n   old LV \u003d \" + oldLV\n                + \"; old CTime \u003d \" + oldCTime\n                + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n                + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n         File curDir \u003d sd.getCurrentDir();\n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         assert curDir.exists() : \"Current directory must exist.\";\n         assert !prevDir.exists() : \"prvious directory must not exist.\";\n         assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n         assert !editLog.isOpen() : \"Edits log must not be open.\";\n \n         // rename current to tmp\n         NNStorage.rename(curDir, tmpDir);\n         \n         if (!curDir.mkdir()) {\n           throw new IOException(\"Cannot create directory \" + curDir);\n         }\n       } catch (Exception e) {\n         LOG.error(\"Failed to move aside pre-upgrade storage \" +\n             \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n     errorSDs.clear();\n \n     saveFSImageInAllDirs(editLog.getLastWrittenTxId());\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       try {\n         // Write the version file, since saveFsImage above only makes the\n         // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n         storage.writeProperties(sd);\n         \n         File prevDir \u003d sd.getPreviousDir();\n         File tmpDir \u003d sd.getPreviousTmp();\n         // rename tmp to previous\n         NNStorage.rename(tmpDir, prevDir);\n       } catch (IOException ioe) {\n         LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n       LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n     }\n     storage.reportErrorsOnDirectories(errorSDs);\n \n     isUpgradeFinalized \u003d false;\n     if (!storage.getRemovedStorageDirs().isEmpty()) {\n       //during upgrade, it\u0027s a fatal error to fail any storage directory\n       throw new IOException(\"Upgrade failed in \"\n           + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n     storage.initializeDistributedUpgrade();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doUpgrade() throws IOException {\n    if(storage.getDistributedUpgradeState()) {\n      // only distributed upgrade need to continue\n      // don\u0027t do version upgrade\n      this.loadFSImage();\n      storage.initializeDistributedUpgrade();\n      return;\n    }\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage();\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d HdfsConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        File curDir \u003d sd.getCurrentDir();\n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"prvious directory must not exist.\";\n        assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n        assert !editLog.isOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        if (!curDir.mkdir()) {\n          throw new IOException(\"Cannot create directory \" + curDir);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        // Write the version file, since saveFsImage above only makes the\n        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n        storage.writeProperties(sd);\n        \n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n\n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n    storage.initializeDistributedUpgrade();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "cd7157784e5e5ddc4e77144d042e54dd0d04bac1": {
      "type": "Yfilerename",
      "commitMessage": "HADOOP-7560. Change src layout to be heirarchical. Contributed by Alejandro Abdelnur.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1161332 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "24/08/11 5:14 PM",
      "commitName": "cd7157784e5e5ddc4e77144d042e54dd0d04bac1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "24/08/11 5:06 PM",
      "commitNameOld": "bb0005cfec5fd2861600ff5babd259b48ba18b63",
      "commitAuthorOld": "Arun Murthy",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void doUpgrade() throws IOException {\n    if(storage.getDistributedUpgradeState()) {\n      // only distributed upgrade need to continue\n      // don\u0027t do version upgrade\n      this.loadFSImage();\n      storage.initializeDistributedUpgrade();\n      return;\n    }\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage();\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        File curDir \u003d sd.getCurrentDir();\n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"prvious directory must not exist.\";\n        assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n        assert !editLog.isOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        if (!curDir.mkdir()) {\n          throw new IOException(\"Cannot create directory \" + curDir);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        // Write the version file, since saveFsImage above only makes the\n        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n        storage.writeProperties(sd);\n        \n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n\n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n    storage.initializeDistributedUpgrade();\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {
        "oldPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
        "newPath": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
      }
    },
    "d86f3183d93714ba078416af4f609d26376eadb0": {
      "type": "Yfilerename",
      "commitMessage": "HDFS-2096. Mavenization of hadoop-hdfs. Contributed by Alejandro Abdelnur.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1159702 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "19/08/11 10:36 AM",
      "commitName": "d86f3183d93714ba078416af4f609d26376eadb0",
      "commitAuthor": "Thomas White",
      "commitDateOld": "19/08/11 10:26 AM",
      "commitNameOld": "6ee5a73e0e91a2ef27753a32c576835e951d8119",
      "commitAuthorOld": "Thomas White",
      "daysBetweenCommits": 0.01,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "  private void doUpgrade() throws IOException {\n    if(storage.getDistributedUpgradeState()) {\n      // only distributed upgrade need to continue\n      // don\u0027t do version upgrade\n      this.loadFSImage();\n      storage.initializeDistributedUpgrade();\n      return;\n    }\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage();\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        File curDir \u003d sd.getCurrentDir();\n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"prvious directory must not exist.\";\n        assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n        assert !editLog.isOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        if (!curDir.mkdir()) {\n          throw new IOException(\"Cannot create directory \" + curDir);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        // Write the version file, since saveFsImage above only makes the\n        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n        storage.writeProperties(sd);\n        \n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n\n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n    storage.initializeDistributedUpgrade();\n  }",
      "path": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {
        "oldPath": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
        "newPath": "hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
      }
    },
    "28e6a4e44a3e920dcaf858f9a74a6358226b3a63": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1073. Redesign the NameNode\u0027s storage layout for image checkpoints and edit logs to introduce transaction IDs and be more robust. Contributed by Todd Lipcon and Ivan Kelly.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1152295 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "29/07/11 9:28 AM",
      "commitName": "28e6a4e44a3e920dcaf858f9a74a6358226b3a63",
      "commitAuthor": "Todd Lipcon",
      "commitDateOld": "27/07/11 8:19 PM",
      "commitNameOld": "ffbe9e5972bf3eee9037e2602c1330e0dc744646",
      "commitAuthorOld": "Eli Collins",
      "daysBetweenCommits": 1.55,
      "commitsBetweenForRepo": 6,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,91 +1,92 @@\n   private void doUpgrade() throws IOException {\n     if(storage.getDistributedUpgradeState()) {\n       // only distributed upgrade need to continue\n       // don\u0027t do version upgrade\n       this.loadFSImage();\n       storage.initializeDistributedUpgrade();\n       return;\n     }\n     // Upgrade is allowed only if there are \n     // no previous fs states in any of the directories\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n     this.loadFSImage();\n \n     // Do upgrade for each directory\n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n-    storage.setCheckpointTime(now());\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n-    List\u003cThread\u003e saveThreads \u003d new ArrayList\u003cThread\u003e();\n-    File curDir, prevDir, tmpDir;\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n                + \".\\n   old LV \u003d \" + oldLV\n                + \"; old CTime \u003d \" + oldCTime\n                + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n                + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n-        curDir \u003d sd.getCurrentDir();\n-        prevDir \u003d sd.getPreviousDir();\n-        tmpDir \u003d sd.getPreviousTmp();\n+        File curDir \u003d sd.getCurrentDir();\n+        File prevDir \u003d sd.getPreviousDir();\n+        File tmpDir \u003d sd.getPreviousTmp();\n         assert curDir.exists() : \"Current directory must exist.\";\n         assert !prevDir.exists() : \"prvious directory must not exist.\";\n         assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n         assert !editLog.isOpen() : \"Edits log must not be open.\";\n \n         // rename current to tmp\n         NNStorage.rename(curDir, tmpDir);\n         \n-        // launch thread to save new image\n-        FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n-        Thread saveThread \u003d new Thread(saver, saver.toString());\n-        saveThreads.add(saveThread);\n-        saveThread.start();\n-        \n+        if (!curDir.mkdir()) {\n+          throw new IOException(\"Cannot create directory \" + curDir);\n+        }\n       } catch (Exception e) {\n-        LOG.error(\"Failed upgrade of image directory \" + sd.getRoot(), e);\n+        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n+            \"in image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n-    waitForThreads(saveThreads);\n-    saveThreads.clear();\n+    storage.reportErrorsOnDirectories(errorSDs);\n+    errorSDs.clear();\n+\n+    saveFSImageInAllDirs(editLog.getLastWrittenTxId());\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n-      if (errorSDs.contains(sd)) continue;\n       try {\n-        prevDir \u003d sd.getPreviousDir();\n-        tmpDir \u003d sd.getPreviousTmp();\n+        // Write the version file, since saveFsImage above only makes the\n+        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n+        storage.writeProperties(sd);\n+        \n+        File prevDir \u003d sd.getPreviousDir();\n+        File tmpDir \u003d sd.getPreviousTmp();\n         // rename tmp to previous\n         NNStorage.rename(tmpDir, prevDir);\n       } catch (IOException ioe) {\n         LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n       LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n     }\n+    storage.reportErrorsOnDirectories(errorSDs);\n+\n     isUpgradeFinalized \u003d false;\n-    if (!errorSDs.isEmpty()) {\n-      storage.reportErrorsOnDirectories(errorSDs);\n+    if (!storage.getRemovedStorageDirs().isEmpty()) {\n       //during upgrade, it\u0027s a fatal error to fail any storage directory\n-      throw new IOException(\"Upgrade failed in \" + errorSDs.size()\n+      throw new IOException(\"Upgrade failed in \"\n+          + storage.getRemovedStorageDirs().size()\n           + \" storage directory(ies), previously logged.\");\n     }\n     storage.initializeDistributedUpgrade();\n-    editLog.open();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doUpgrade() throws IOException {\n    if(storage.getDistributedUpgradeState()) {\n      // only distributed upgrade need to continue\n      // don\u0027t do version upgrade\n      this.loadFSImage();\n      storage.initializeDistributedUpgrade();\n      return;\n    }\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage();\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        File curDir \u003d sd.getCurrentDir();\n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"prvious directory must not exist.\";\n        assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n        assert !editLog.isOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        if (!curDir.mkdir()) {\n          throw new IOException(\"Cannot create directory \" + curDir);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Failed to move aside pre-upgrade storage \" +\n            \"in image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n    errorSDs.clear();\n\n    saveFSImageInAllDirs(editLog.getLastWrittenTxId());\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      try {\n        // Write the version file, since saveFsImage above only makes the\n        // fsimage_\u003ctxid\u003e, and the directory is otherwise empty.\n        storage.writeProperties(sd);\n        \n        File prevDir \u003d sd.getPreviousDir();\n        File tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    storage.reportErrorsOnDirectories(errorSDs);\n\n    isUpgradeFinalized \u003d false;\n    if (!storage.getRemovedStorageDirs().isEmpty()) {\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \"\n          + storage.getRemovedStorageDirs().size()\n          + \" storage directory(ies), previously logged.\");\n    }\n    storage.initializeDistributedUpgrade();\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "5147e283ad9757ac2cabaf282ae5cbba76826ede": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-1955. FSImage.doUpgrade() was made too fault-tolerant by HDFS-1826. Contributed by Matt Foley.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1141658 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "30/06/11 11:38 AM",
      "commitName": "5147e283ad9757ac2cabaf282ae5cbba76826ede",
      "commitAuthor": "Matthew Foley",
      "commitDateOld": "12/06/11 3:00 PM",
      "commitNameOld": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthorOld": "Todd Lipcon",
      "daysBetweenCommits": 17.86,
      "commitsBetweenForRepo": 60,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,86 +1,91 @@\n   private void doUpgrade() throws IOException {\n     if(storage.getDistributedUpgradeState()) {\n       // only distributed upgrade need to continue\n       // don\u0027t do version upgrade\n       this.loadFSImage();\n       storage.initializeDistributedUpgrade();\n       return;\n     }\n     // Upgrade is allowed only if there are \n     // no previous fs states in any of the directories\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (sd.getPreviousDir().exists())\n         throw new InconsistentFSStateException(sd.getRoot(),\n             \"previous fs state should not exist during upgrade. \"\n             + \"Finalize or rollback first.\");\n     }\n \n     // load the latest image\n     this.loadFSImage();\n \n     // Do upgrade for each directory\n     long oldCTime \u003d storage.getCTime();\n     storage.cTime \u003d now();  // generate new cTime for the state\n     int oldLV \u003d storage.getLayoutVersion();\n     storage.layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n     storage.setCheckpointTime(now());\n     \n     List\u003cStorageDirectory\u003e errorSDs \u003d\n       Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n     List\u003cThread\u003e saveThreads \u003d new ArrayList\u003cThread\u003e();\n     File curDir, prevDir, tmpDir;\n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n                + \".\\n   old LV \u003d \" + oldLV\n                + \"; old CTime \u003d \" + oldCTime\n                + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n                + \"; new CTime \u003d \" + storage.getCTime());\n       try {\n         curDir \u003d sd.getCurrentDir();\n         prevDir \u003d sd.getPreviousDir();\n         tmpDir \u003d sd.getPreviousTmp();\n         assert curDir.exists() : \"Current directory must exist.\";\n         assert !prevDir.exists() : \"prvious directory must not exist.\";\n         assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n         assert !editLog.isOpen() : \"Edits log must not be open.\";\n \n         // rename current to tmp\n         NNStorage.rename(curDir, tmpDir);\n         \n         // launch thread to save new image\n         FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n         Thread saveThread \u003d new Thread(saver, saver.toString());\n         saveThreads.add(saveThread);\n         saveThread.start();\n         \n       } catch (Exception e) {\n         LOG.error(\"Failed upgrade of image directory \" + sd.getRoot(), e);\n         errorSDs.add(sd);\n         continue;\n       }\n     }\n     waitForThreads(saveThreads);\n     saveThreads.clear();\n \n     for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n       StorageDirectory sd \u003d it.next();\n       if (errorSDs.contains(sd)) continue;\n       try {\n         prevDir \u003d sd.getPreviousDir();\n         tmpDir \u003d sd.getPreviousTmp();\n         // rename tmp to previous\n         NNStorage.rename(tmpDir, prevDir);\n       } catch (IOException ioe) {\n         LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n         errorSDs.add(sd);\n         continue;\n       }\n       LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n     }\n     isUpgradeFinalized \u003d false;\n-    storage.reportErrorsOnDirectories(errorSDs);\n+    if (!errorSDs.isEmpty()) {\n+      storage.reportErrorsOnDirectories(errorSDs);\n+      //during upgrade, it\u0027s a fatal error to fail any storage directory\n+      throw new IOException(\"Upgrade failed in \" + errorSDs.size()\n+          + \" storage directory(ies), previously logged.\");\n+    }\n     storage.initializeDistributedUpgrade();\n     editLog.open();\n   }\n\\ No newline at end of file\n",
      "actualSource": "  private void doUpgrade() throws IOException {\n    if(storage.getDistributedUpgradeState()) {\n      // only distributed upgrade need to continue\n      // don\u0027t do version upgrade\n      this.loadFSImage();\n      storage.initializeDistributedUpgrade();\n      return;\n    }\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage();\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n    storage.setCheckpointTime(now());\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    List\u003cThread\u003e saveThreads \u003d new ArrayList\u003cThread\u003e();\n    File curDir, prevDir, tmpDir;\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        curDir \u003d sd.getCurrentDir();\n        prevDir \u003d sd.getPreviousDir();\n        tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"prvious directory must not exist.\";\n        assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n        assert !editLog.isOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        // launch thread to save new image\n        FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n        Thread saveThread \u003d new Thread(saver, saver.toString());\n        saveThreads.add(saveThread);\n        saveThread.start();\n        \n      } catch (Exception e) {\n        LOG.error(\"Failed upgrade of image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    waitForThreads(saveThreads);\n    saveThreads.clear();\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (errorSDs.contains(sd)) continue;\n      try {\n        prevDir \u003d sd.getPreviousDir();\n        tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    isUpgradeFinalized \u003d false;\n    if (!errorSDs.isEmpty()) {\n      storage.reportErrorsOnDirectories(errorSDs);\n      //during upgrade, it\u0027s a fatal error to fail any storage directory\n      throw new IOException(\"Upgrade failed in \" + errorSDs.size()\n          + \" storage directory(ies), previously logged.\");\n    }\n    storage.initializeDistributedUpgrade();\n    editLog.open();\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java",
      "extendedDetails": {}
    },
    "a196766ea07775f18ded69bd9e8d239f8cfd3ccc": {
      "type": "Yintroduced",
      "commitMessage": "HADOOP-7106. Reorganize SVN layout to combine HDFS, Common, and MR in a single tree (project unsplit)\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1134994 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/06/11 3:00 PM",
      "commitName": "a196766ea07775f18ded69bd9e8d239f8cfd3ccc",
      "commitAuthor": "Todd Lipcon",
      "diff": "@@ -0,0 +1,86 @@\n+  private void doUpgrade() throws IOException {\n+    if(storage.getDistributedUpgradeState()) {\n+      // only distributed upgrade need to continue\n+      // don\u0027t do version upgrade\n+      this.loadFSImage();\n+      storage.initializeDistributedUpgrade();\n+      return;\n+    }\n+    // Upgrade is allowed only if there are \n+    // no previous fs states in any of the directories\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      StorageDirectory sd \u003d it.next();\n+      if (sd.getPreviousDir().exists())\n+        throw new InconsistentFSStateException(sd.getRoot(),\n+            \"previous fs state should not exist during upgrade. \"\n+            + \"Finalize or rollback first.\");\n+    }\n+\n+    // load the latest image\n+    this.loadFSImage();\n+\n+    // Do upgrade for each directory\n+    long oldCTime \u003d storage.getCTime();\n+    storage.cTime \u003d now();  // generate new cTime for the state\n+    int oldLV \u003d storage.getLayoutVersion();\n+    storage.layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n+    storage.setCheckpointTime(now());\n+    \n+    List\u003cStorageDirectory\u003e errorSDs \u003d\n+      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n+    List\u003cThread\u003e saveThreads \u003d new ArrayList\u003cThread\u003e();\n+    File curDir, prevDir, tmpDir;\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      StorageDirectory sd \u003d it.next();\n+      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n+               + \".\\n   old LV \u003d \" + oldLV\n+               + \"; old CTime \u003d \" + oldCTime\n+               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n+               + \"; new CTime \u003d \" + storage.getCTime());\n+      try {\n+        curDir \u003d sd.getCurrentDir();\n+        prevDir \u003d sd.getPreviousDir();\n+        tmpDir \u003d sd.getPreviousTmp();\n+        assert curDir.exists() : \"Current directory must exist.\";\n+        assert !prevDir.exists() : \"prvious directory must not exist.\";\n+        assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n+        assert !editLog.isOpen() : \"Edits log must not be open.\";\n+\n+        // rename current to tmp\n+        NNStorage.rename(curDir, tmpDir);\n+        \n+        // launch thread to save new image\n+        FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n+        Thread saveThread \u003d new Thread(saver, saver.toString());\n+        saveThreads.add(saveThread);\n+        saveThread.start();\n+        \n+      } catch (Exception e) {\n+        LOG.error(\"Failed upgrade of image directory \" + sd.getRoot(), e);\n+        errorSDs.add(sd);\n+        continue;\n+      }\n+    }\n+    waitForThreads(saveThreads);\n+    saveThreads.clear();\n+\n+    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n+      StorageDirectory sd \u003d it.next();\n+      if (errorSDs.contains(sd)) continue;\n+      try {\n+        prevDir \u003d sd.getPreviousDir();\n+        tmpDir \u003d sd.getPreviousTmp();\n+        // rename tmp to previous\n+        NNStorage.rename(tmpDir, prevDir);\n+      } catch (IOException ioe) {\n+        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n+        errorSDs.add(sd);\n+        continue;\n+      }\n+      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n+    }\n+    isUpgradeFinalized \u003d false;\n+    storage.reportErrorsOnDirectories(errorSDs);\n+    storage.initializeDistributedUpgrade();\n+    editLog.open();\n+  }\n\\ No newline at end of file\n",
      "actualSource": "  private void doUpgrade() throws IOException {\n    if(storage.getDistributedUpgradeState()) {\n      // only distributed upgrade need to continue\n      // don\u0027t do version upgrade\n      this.loadFSImage();\n      storage.initializeDistributedUpgrade();\n      return;\n    }\n    // Upgrade is allowed only if there are \n    // no previous fs states in any of the directories\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (sd.getPreviousDir().exists())\n        throw new InconsistentFSStateException(sd.getRoot(),\n            \"previous fs state should not exist during upgrade. \"\n            + \"Finalize or rollback first.\");\n    }\n\n    // load the latest image\n    this.loadFSImage();\n\n    // Do upgrade for each directory\n    long oldCTime \u003d storage.getCTime();\n    storage.cTime \u003d now();  // generate new cTime for the state\n    int oldLV \u003d storage.getLayoutVersion();\n    storage.layoutVersion \u003d FSConstants.LAYOUT_VERSION;\n    storage.setCheckpointTime(now());\n    \n    List\u003cStorageDirectory\u003e errorSDs \u003d\n      Collections.synchronizedList(new ArrayList\u003cStorageDirectory\u003e());\n    List\u003cThread\u003e saveThreads \u003d new ArrayList\u003cThread\u003e();\n    File curDir, prevDir, tmpDir;\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      LOG.info(\"Starting upgrade of image directory \" + sd.getRoot()\n               + \".\\n   old LV \u003d \" + oldLV\n               + \"; old CTime \u003d \" + oldCTime\n               + \".\\n   new LV \u003d \" + storage.getLayoutVersion()\n               + \"; new CTime \u003d \" + storage.getCTime());\n      try {\n        curDir \u003d sd.getCurrentDir();\n        prevDir \u003d sd.getPreviousDir();\n        tmpDir \u003d sd.getPreviousTmp();\n        assert curDir.exists() : \"Current directory must exist.\";\n        assert !prevDir.exists() : \"prvious directory must not exist.\";\n        assert !tmpDir.exists() : \"prvious.tmp directory must not exist.\";\n        assert !editLog.isOpen() : \"Edits log must not be open.\";\n\n        // rename current to tmp\n        NNStorage.rename(curDir, tmpDir);\n        \n        // launch thread to save new image\n        FSImageSaver saver \u003d new FSImageSaver(sd, errorSDs);\n        Thread saveThread \u003d new Thread(saver, saver.toString());\n        saveThreads.add(saveThread);\n        saveThread.start();\n        \n      } catch (Exception e) {\n        LOG.error(\"Failed upgrade of image directory \" + sd.getRoot(), e);\n        errorSDs.add(sd);\n        continue;\n      }\n    }\n    waitForThreads(saveThreads);\n    saveThreads.clear();\n\n    for (Iterator\u003cStorageDirectory\u003e it \u003d storage.dirIterator(); it.hasNext();) {\n      StorageDirectory sd \u003d it.next();\n      if (errorSDs.contains(sd)) continue;\n      try {\n        prevDir \u003d sd.getPreviousDir();\n        tmpDir \u003d sd.getPreviousTmp();\n        // rename tmp to previous\n        NNStorage.rename(tmpDir, prevDir);\n      } catch (IOException ioe) {\n        LOG.error(\"Unable to rename temp to previous for \" + sd.getRoot(), ioe);\n        errorSDs.add(sd);\n        continue;\n      }\n      LOG.info(\"Upgrade of \" + sd.getRoot() + \" is complete.\");\n    }\n    isUpgradeFinalized \u003d false;\n    storage.reportErrorsOnDirectories(errorSDs);\n    storage.initializeDistributedUpgrade();\n    editLog.open();\n  }",
      "path": "hdfs/src/java/org/apache/hadoop/hdfs/server/namenode/FSImage.java"
    }
  }
}