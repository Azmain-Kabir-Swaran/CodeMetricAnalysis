{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "FairSharePolicy.java",
  "functionName": "compare",
  "functionId": "compare___s1-Schedulable__s2-Schedulable",
  "sourceFilePath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java",
  "functionStartLine": 89,
  "functionEndLine": 117,
  "numCommitsSeen": 29,
  "timeTaken": 4569,
  "changeHistory": [
    "8a6bb8409c2dc695c0ffc70df0528d7f8bd5d795",
    "f81a4efb8c40f99a9a6b7b42d3b6eeedf43eb27a",
    "4a574e9a84f2e997038452b22f2ad2a2d42e8ac8",
    "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf",
    "c3973e7080bf71b57ace4a6adf4bb43f3c5d35b5",
    "4df8ed63ed93f2542e4b48f521b0cc6624ab59c1",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae",
    "7c71a3b876f18510fd10a0b08bf27f83ac3aa389",
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
    "a43c344eee888f2a2488c8c9dca7e25a2cce10bf",
    "df55edd5dec9c944a6c38f08d6f1f0fdb901c880",
    "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3",
    "e1fdf62123625e4ba399af02f8aad500637d29d1",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c"
  ],
  "changeHistoryShort": {
    "8a6bb8409c2dc695c0ffc70df0528d7f8bd5d795": "Ybodychange",
    "f81a4efb8c40f99a9a6b7b42d3b6eeedf43eb27a": "Ybodychange",
    "4a574e9a84f2e997038452b22f2ad2a2d42e8ac8": "Ybodychange",
    "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf": "Ybodychange",
    "c3973e7080bf71b57ace4a6adf4bb43f3c5d35b5": "Ybodychange",
    "4df8ed63ed93f2542e4b48f521b0cc6624ab59c1": "Ybodychange",
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": "Ybodychange",
    "7c71a3b876f18510fd10a0b08bf27f83ac3aa389": "Ybodychange",
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650": "Ybodychange",
    "a43c344eee888f2a2488c8c9dca7e25a2cce10bf": "Ybodychange",
    "df55edd5dec9c944a6c38f08d6f1f0fdb901c880": "Yfilerename",
    "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3": "Yfilerename",
    "e1fdf62123625e4ba399af02f8aad500637d29d1": "Yfilerename",
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": "Yintroduced"
  },
  "changeHistoryDetails": {
    "8a6bb8409c2dc695c0ffc70df0528d7f8bd5d795": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6964. Fair scheduler misuses Resources operations. (Daniel Templeton and Szilard Nemeth via Haibo Chen)\n",
      "commitDate": "20/07/18 10:46 AM",
      "commitName": "8a6bb8409c2dc695c0ffc70df0528d7f8bd5d795",
      "commitAuthor": "Haibo Chen",
      "commitDateOld": "14/09/17 11:23 AM",
      "commitNameOld": "09b476e6dabe8039a41dde7930c8a9c0d14bb750",
      "commitAuthorOld": "Yufei Gu",
      "daysBetweenCommits": 308.97,
      "commitsBetweenForRepo": 2762,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,27 +1,29 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n       int res \u003d compareDemand(s1, s2);\n \n-      // Pre-compute resource usages to avoid duplicate calculation\n-      Resource resourceUsage1 \u003d s1.getResourceUsage();\n-      Resource resourceUsage2 \u003d s2.getResourceUsage();\n+      // Share resource usages to avoid duplicate calculation\n+      Resource resourceUsage1 \u003d null;\n+      Resource resourceUsage2 \u003d null;\n \n       if (res \u003d\u003d 0) {\n+        resourceUsage1 \u003d s1.getResourceUsage();\n+        resourceUsage2 \u003d s2.getResourceUsage();\n         res \u003d compareMinShareUsage(s1, s2, resourceUsage1, resourceUsage2);\n       }\n \n       if (res \u003d\u003d 0) {\n         res \u003d compareFairShareUsage(s1, s2, resourceUsage1, resourceUsage2);\n       }\n \n       // Break the tie by submit time\n       if (res \u003d\u003d 0) {\n         res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n       }\n \n       // Break the tie by job name\n       if (res \u003d\u003d 0) {\n         res \u003d s1.getName().compareTo(s2.getName());\n       }\n \n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      int res \u003d compareDemand(s1, s2);\n\n      // Share resource usages to avoid duplicate calculation\n      Resource resourceUsage1 \u003d null;\n      Resource resourceUsage2 \u003d null;\n\n      if (res \u003d\u003d 0) {\n        resourceUsage1 \u003d s1.getResourceUsage();\n        resourceUsage2 \u003d s2.getResourceUsage();\n        res \u003d compareMinShareUsage(s1, s2, resourceUsage1, resourceUsage2);\n      }\n\n      if (res \u003d\u003d 0) {\n        res \u003d compareFairShareUsage(s1, s2, resourceUsage1, resourceUsage2);\n      }\n\n      // Break the tie by submit time\n      if (res \u003d\u003d 0) {\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n      }\n\n      // Break the tie by job name\n      if (res \u003d\u003d 0) {\n        res \u003d s1.getName().compareTo(s2.getName());\n      }\n\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java",
      "extendedDetails": {}
    },
    "f81a4efb8c40f99a9a6b7b42d3b6eeedf43eb27a": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6307. Refactor FairShareComparator#compare (Contributed by Yufei Gu via Daniel Templeton)\n",
      "commitDate": "25/07/17 1:00 PM",
      "commitName": "f81a4efb8c40f99a9a6b7b42d3b6eeedf43eb27a",
      "commitAuthor": "Daniel Templeton",
      "commitDateOld": "13/07/17 11:10 PM",
      "commitNameOld": "4a574e9a84f2e997038452b22f2ad2a2d42e8ac8",
      "commitAuthorOld": "Yufei Gu",
      "daysBetweenCommits": 11.58,
      "commitsBetweenForRepo": 56,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,69 +1,27 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n-      Resource demand1 \u003d s1.getDemand();\n-      Resource demand2 \u003d s2.getDemand();\n-      if (demand1.equals(Resources.none()) \u0026\u0026 Resources.greaterThan(\n-          RESOURCE_CALCULATOR, null, demand2, Resources.none())) {\n-        return 1;\n-      } else if (demand2.equals(Resources.none()) \u0026\u0026 Resources.greaterThan(\n-          RESOURCE_CALCULATOR, null, demand1, Resources.none())) {\n-        return -1;\n-      }\n+      int res \u003d compareDemand(s1, s2);\n \n-      double minShareRatio1, minShareRatio2;\n-      double useToWeightRatio1, useToWeightRatio2;\n-      double weight1, weight2;\n-      //Do not repeat the getResourceUsage calculation\n+      // Pre-compute resource usages to avoid duplicate calculation\n       Resource resourceUsage1 \u003d s1.getResourceUsage();\n       Resource resourceUsage2 \u003d s2.getResourceUsage();\n-      Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n-          s1.getMinShare(), demand1);\n-      Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n-          s2.getMinShare(), demand2);\n-      boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n-          resourceUsage1, minShare1);\n-      boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n-          resourceUsage2, minShare2);\n-      minShareRatio1 \u003d (double) resourceUsage1.getMemorySize()\n-          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemorySize();\n-      minShareRatio2 \u003d (double) resourceUsage2.getMemorySize()\n-          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemorySize();\n \n-      weight1 \u003d s1.getWeights().getWeight(ResourceType.MEMORY);\n-      weight2 \u003d s2.getWeights().getWeight(ResourceType.MEMORY);\n-      if (weight1 \u003e 0.0 \u0026\u0026 weight2 \u003e 0.0) {\n-        useToWeightRatio1 \u003d resourceUsage1.getMemorySize() / weight1;\n-        useToWeightRatio2 \u003d resourceUsage2.getMemorySize() / weight2;\n-      } else { // Either weight1 or weight2 equals to 0\n-        if (weight1 \u003d\u003d weight2) {\n-          // If they have same weight, just compare usage\n-          useToWeightRatio1 \u003d resourceUsage1.getMemorySize();\n-          useToWeightRatio2 \u003d resourceUsage2.getMemorySize();\n-        } else {\n-          // By setting useToWeightRatios to negative weights, we give the\n-          // zero-weight one less priority, so the non-zero weight one will\n-          // be given slots.\n-          useToWeightRatio1 \u003d -weight1;\n-          useToWeightRatio2 \u003d -weight2;\n-        }\n-      }\n-\n-      int res \u003d 0;\n-      if (s1Needy \u0026\u0026 !s2Needy)\n-        res \u003d -1;\n-      else if (s2Needy \u0026\u0026 !s1Needy)\n-        res \u003d 1;\n-      else if (s1Needy \u0026\u0026 s2Needy)\n-        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n-      else\n-        // Neither schedulable is needy\n-        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n       if (res \u003d\u003d 0) {\n-        // Apps are tied in fairness ratio. Break the tie by submit time and job\n-        // name to get a deterministic ordering, which is useful for unit tests.\n-        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n-        if (res \u003d\u003d 0) {\n-          res \u003d s1.getName().compareTo(s2.getName());\n-        }\n+        res \u003d compareMinShareUsage(s1, s2, resourceUsage1, resourceUsage2);\n       }\n+\n+      if (res \u003d\u003d 0) {\n+        res \u003d compareFairShareUsage(s1, s2, resourceUsage1, resourceUsage2);\n+      }\n+\n+      // Break the tie by submit time\n+      if (res \u003d\u003d 0) {\n+        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n+      }\n+\n+      // Break the tie by job name\n+      if (res \u003d\u003d 0) {\n+        res \u003d s1.getName().compareTo(s2.getName());\n+      }\n+\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      int res \u003d compareDemand(s1, s2);\n\n      // Pre-compute resource usages to avoid duplicate calculation\n      Resource resourceUsage1 \u003d s1.getResourceUsage();\n      Resource resourceUsage2 \u003d s2.getResourceUsage();\n\n      if (res \u003d\u003d 0) {\n        res \u003d compareMinShareUsage(s1, s2, resourceUsage1, resourceUsage2);\n      }\n\n      if (res \u003d\u003d 0) {\n        res \u003d compareFairShareUsage(s1, s2, resourceUsage1, resourceUsage2);\n      }\n\n      // Break the tie by submit time\n      if (res \u003d\u003d 0) {\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n      }\n\n      // Break the tie by job name\n      if (res \u003d\u003d 0) {\n        res \u003d s1.getName().compareTo(s2.getName());\n      }\n\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java",
      "extendedDetails": {}
    },
    "4a574e9a84f2e997038452b22f2ad2a2d42e8ac8": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6769. Make schedulables without demand less needy in FairSharePolicy#compare. (Yunfan Zhou via Yufei Gu)\n",
      "commitDate": "13/07/17 11:10 PM",
      "commitName": "4a574e9a84f2e997038452b22f2ad2a2d42e8ac8",
      "commitAuthor": "Yufei Gu",
      "commitDateOld": "12/05/17 1:05 PM",
      "commitNameOld": "6c35001b9f93fd85a02c3465e87bfd1612f4cce9",
      "commitAuthorOld": "Haibo Chen",
      "daysBetweenCommits": 62.42,
      "commitsBetweenForRepo": 293,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,59 +1,69 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n+      Resource demand1 \u003d s1.getDemand();\n+      Resource demand2 \u003d s2.getDemand();\n+      if (demand1.equals(Resources.none()) \u0026\u0026 Resources.greaterThan(\n+          RESOURCE_CALCULATOR, null, demand2, Resources.none())) {\n+        return 1;\n+      } else if (demand2.equals(Resources.none()) \u0026\u0026 Resources.greaterThan(\n+          RESOURCE_CALCULATOR, null, demand1, Resources.none())) {\n+        return -1;\n+      }\n+\n       double minShareRatio1, minShareRatio2;\n       double useToWeightRatio1, useToWeightRatio2;\n       double weight1, weight2;\n       //Do not repeat the getResourceUsage calculation\n       Resource resourceUsage1 \u003d s1.getResourceUsage();\n       Resource resourceUsage2 \u003d s2.getResourceUsage();\n       Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n-          s1.getMinShare(), s1.getDemand());\n+          s1.getMinShare(), demand1);\n       Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n-          s2.getMinShare(), s2.getDemand());\n+          s2.getMinShare(), demand2);\n       boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n           resourceUsage1, minShare1);\n       boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n           resourceUsage2, minShare2);\n       minShareRatio1 \u003d (double) resourceUsage1.getMemorySize()\n           / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemorySize();\n       minShareRatio2 \u003d (double) resourceUsage2.getMemorySize()\n           / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemorySize();\n \n       weight1 \u003d s1.getWeights().getWeight(ResourceType.MEMORY);\n       weight2 \u003d s2.getWeights().getWeight(ResourceType.MEMORY);\n       if (weight1 \u003e 0.0 \u0026\u0026 weight2 \u003e 0.0) {\n         useToWeightRatio1 \u003d resourceUsage1.getMemorySize() / weight1;\n         useToWeightRatio2 \u003d resourceUsage2.getMemorySize() / weight2;\n       } else { // Either weight1 or weight2 equals to 0\n         if (weight1 \u003d\u003d weight2) {\n           // If they have same weight, just compare usage\n           useToWeightRatio1 \u003d resourceUsage1.getMemorySize();\n           useToWeightRatio2 \u003d resourceUsage2.getMemorySize();\n         } else {\n           // By setting useToWeightRatios to negative weights, we give the\n           // zero-weight one less priority, so the non-zero weight one will\n           // be given slots.\n           useToWeightRatio1 \u003d -weight1;\n           useToWeightRatio2 \u003d -weight2;\n         }\n       }\n \n       int res \u003d 0;\n       if (s1Needy \u0026\u0026 !s2Needy)\n         res \u003d -1;\n       else if (s2Needy \u0026\u0026 !s1Needy)\n         res \u003d 1;\n       else if (s1Needy \u0026\u0026 s2Needy)\n         res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n       else\n         // Neither schedulable is needy\n         res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n       if (res \u003d\u003d 0) {\n         // Apps are tied in fairness ratio. Break the tie by submit time and job\n         // name to get a deterministic ordering, which is useful for unit tests.\n         res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n         if (res \u003d\u003d 0) {\n           res \u003d s1.getName().compareTo(s2.getName());\n         }\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      Resource demand1 \u003d s1.getDemand();\n      Resource demand2 \u003d s2.getDemand();\n      if (demand1.equals(Resources.none()) \u0026\u0026 Resources.greaterThan(\n          RESOURCE_CALCULATOR, null, demand2, Resources.none())) {\n        return 1;\n      } else if (demand2.equals(Resources.none()) \u0026\u0026 Resources.greaterThan(\n          RESOURCE_CALCULATOR, null, demand1, Resources.none())) {\n        return -1;\n      }\n\n      double minShareRatio1, minShareRatio2;\n      double useToWeightRatio1, useToWeightRatio2;\n      double weight1, weight2;\n      //Do not repeat the getResourceUsage calculation\n      Resource resourceUsage1 \u003d s1.getResourceUsage();\n      Resource resourceUsage2 \u003d s2.getResourceUsage();\n      Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s1.getMinShare(), demand1);\n      Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s2.getMinShare(), demand2);\n      boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          resourceUsage1, minShare1);\n      boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          resourceUsage2, minShare2);\n      minShareRatio1 \u003d (double) resourceUsage1.getMemorySize()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemorySize();\n      minShareRatio2 \u003d (double) resourceUsage2.getMemorySize()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemorySize();\n\n      weight1 \u003d s1.getWeights().getWeight(ResourceType.MEMORY);\n      weight2 \u003d s2.getWeights().getWeight(ResourceType.MEMORY);\n      if (weight1 \u003e 0.0 \u0026\u0026 weight2 \u003e 0.0) {\n        useToWeightRatio1 \u003d resourceUsage1.getMemorySize() / weight1;\n        useToWeightRatio2 \u003d resourceUsage2.getMemorySize() / weight2;\n      } else { // Either weight1 or weight2 equals to 0\n        if (weight1 \u003d\u003d weight2) {\n          // If they have same weight, just compare usage\n          useToWeightRatio1 \u003d resourceUsage1.getMemorySize();\n          useToWeightRatio2 \u003d resourceUsage2.getMemorySize();\n        } else {\n          // By setting useToWeightRatios to negative weights, we give the\n          // zero-weight one less priority, so the non-zero weight one will\n          // be given slots.\n          useToWeightRatio1 \u003d -weight1;\n          useToWeightRatio2 \u003d -weight2;\n        }\n      }\n\n      int res \u003d 0;\n      if (s1Needy \u0026\u0026 !s2Needy)\n        res \u003d -1;\n      else if (s2Needy \u0026\u0026 !s1Needy)\n        res \u003d 1;\n      else if (s1Needy \u0026\u0026 s2Needy)\n        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n      else\n        // Neither schedulable is needy\n        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0) {\n          res \u003d s1.getName().compareTo(s2.getName());\n        }\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java",
      "extendedDetails": {}
    },
    "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-6210. FairScheduler: Node reservations can interfere with preemption. (kasha)\n",
      "commitDate": "22/02/17 3:46 PM",
      "commitName": "718ad9f6ee93d4145f2bb19b7582ce4e1174feaf",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "15/02/17 11:51 PM",
      "commitNameOld": "11be3f70e029c2324b167563168c8a254d234aef",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 6.66,
      "commitsBetweenForRepo": 34,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,58 +1,59 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n       double minShareRatio1, minShareRatio2;\n       double useToWeightRatio1, useToWeightRatio2;\n       double weight1, weight2;\n       //Do not repeat the getResourceUsage calculation\n       Resource resourceUsage1 \u003d s1.getResourceUsage();\n       Resource resourceUsage2 \u003d s2.getResourceUsage();\n       Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n           s1.getMinShare(), s1.getDemand());\n       Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n           s2.getMinShare(), s2.getDemand());\n       boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n           resourceUsage1, minShare1);\n       boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n           resourceUsage2, minShare2);\n       minShareRatio1 \u003d (double) resourceUsage1.getMemorySize()\n           / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemorySize();\n       minShareRatio2 \u003d (double) resourceUsage2.getMemorySize()\n           / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemorySize();\n \n       weight1 \u003d s1.getWeights().getWeight(ResourceType.MEMORY);\n       weight2 \u003d s2.getWeights().getWeight(ResourceType.MEMORY);\n       if (weight1 \u003e 0.0 \u0026\u0026 weight2 \u003e 0.0) {\n         useToWeightRatio1 \u003d resourceUsage1.getMemorySize() / weight1;\n         useToWeightRatio2 \u003d resourceUsage2.getMemorySize() / weight2;\n       } else { // Either weight1 or weight2 equals to 0\n         if (weight1 \u003d\u003d weight2) {\n           // If they have same weight, just compare usage\n           useToWeightRatio1 \u003d resourceUsage1.getMemorySize();\n           useToWeightRatio2 \u003d resourceUsage2.getMemorySize();\n         } else {\n           // By setting useToWeightRatios to negative weights, we give the\n           // zero-weight one less priority, so the non-zero weight one will\n           // be given slots.\n           useToWeightRatio1 \u003d -weight1;\n           useToWeightRatio2 \u003d -weight2;\n         }\n       }\n \n       int res \u003d 0;\n       if (s1Needy \u0026\u0026 !s2Needy)\n         res \u003d -1;\n       else if (s2Needy \u0026\u0026 !s1Needy)\n         res \u003d 1;\n       else if (s1Needy \u0026\u0026 s2Needy)\n         res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n       else\n         // Neither schedulable is needy\n         res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n       if (res \u003d\u003d 0) {\n         // Apps are tied in fairness ratio. Break the tie by submit time and job\n         // name to get a deterministic ordering, which is useful for unit tests.\n         res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n-        if (res \u003d\u003d 0)\n+        if (res \u003d\u003d 0) {\n           res \u003d s1.getName().compareTo(s2.getName());\n+        }\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      double minShareRatio1, minShareRatio2;\n      double useToWeightRatio1, useToWeightRatio2;\n      double weight1, weight2;\n      //Do not repeat the getResourceUsage calculation\n      Resource resourceUsage1 \u003d s1.getResourceUsage();\n      Resource resourceUsage2 \u003d s2.getResourceUsage();\n      Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s1.getMinShare(), s1.getDemand());\n      Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s2.getMinShare(), s2.getDemand());\n      boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          resourceUsage1, minShare1);\n      boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          resourceUsage2, minShare2);\n      minShareRatio1 \u003d (double) resourceUsage1.getMemorySize()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemorySize();\n      minShareRatio2 \u003d (double) resourceUsage2.getMemorySize()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemorySize();\n\n      weight1 \u003d s1.getWeights().getWeight(ResourceType.MEMORY);\n      weight2 \u003d s2.getWeights().getWeight(ResourceType.MEMORY);\n      if (weight1 \u003e 0.0 \u0026\u0026 weight2 \u003e 0.0) {\n        useToWeightRatio1 \u003d resourceUsage1.getMemorySize() / weight1;\n        useToWeightRatio2 \u003d resourceUsage2.getMemorySize() / weight2;\n      } else { // Either weight1 or weight2 equals to 0\n        if (weight1 \u003d\u003d weight2) {\n          // If they have same weight, just compare usage\n          useToWeightRatio1 \u003d resourceUsage1.getMemorySize();\n          useToWeightRatio2 \u003d resourceUsage2.getMemorySize();\n        } else {\n          // By setting useToWeightRatios to negative weights, we give the\n          // zero-weight one less priority, so the non-zero weight one will\n          // be given slots.\n          useToWeightRatio1 \u003d -weight1;\n          useToWeightRatio2 \u003d -weight2;\n        }\n      }\n\n      int res \u003d 0;\n      if (s1Needy \u0026\u0026 !s2Needy)\n        res \u003d -1;\n      else if (s2Needy \u0026\u0026 !s1Needy)\n        res \u003d 1;\n      else if (s1Needy \u0026\u0026 s2Needy)\n        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n      else\n        // Neither schedulable is needy\n        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0) {\n          res \u003d s1.getName().compareTo(s2.getName());\n        }\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java",
      "extendedDetails": {}
    },
    "c3973e7080bf71b57ace4a6adf4bb43f3c5d35b5": {
      "type": "Ybodychange",
      "commitMessage": "YARN-5969. FairShareComparator: Cache value of getResourceUsage for better performance. (zhangshilong via kasha)\n",
      "commitDate": "27/12/16 12:30 PM",
      "commitName": "c3973e7080bf71b57ace4a6adf4bb43f3c5d35b5",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "27/10/16 5:45 PM",
      "commitNameOld": "4df8ed63ed93f2542e4b48f521b0cc6624ab59c1",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 60.82,
      "commitsBetweenForRepo": 389,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,55 +1,58 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n       double minShareRatio1, minShareRatio2;\n       double useToWeightRatio1, useToWeightRatio2;\n       double weight1, weight2;\n+      //Do not repeat the getResourceUsage calculation\n+      Resource resourceUsage1 \u003d s1.getResourceUsage();\n+      Resource resourceUsage2 \u003d s2.getResourceUsage();\n       Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n           s1.getMinShare(), s1.getDemand());\n       Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n           s2.getMinShare(), s2.getDemand());\n       boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n-          s1.getResourceUsage(), minShare1);\n+          resourceUsage1, minShare1);\n       boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n-          s2.getResourceUsage(), minShare2);\n-      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemorySize()\n+          resourceUsage2, minShare2);\n+      minShareRatio1 \u003d (double) resourceUsage1.getMemorySize()\n           / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemorySize();\n-      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemorySize()\n+      minShareRatio2 \u003d (double) resourceUsage2.getMemorySize()\n           / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemorySize();\n \n       weight1 \u003d s1.getWeights().getWeight(ResourceType.MEMORY);\n       weight2 \u003d s2.getWeights().getWeight(ResourceType.MEMORY);\n       if (weight1 \u003e 0.0 \u0026\u0026 weight2 \u003e 0.0) {\n-        useToWeightRatio1 \u003d s1.getResourceUsage().getMemorySize() / weight1;\n-        useToWeightRatio2 \u003d s2.getResourceUsage().getMemorySize() / weight2;\n+        useToWeightRatio1 \u003d resourceUsage1.getMemorySize() / weight1;\n+        useToWeightRatio2 \u003d resourceUsage2.getMemorySize() / weight2;\n       } else { // Either weight1 or weight2 equals to 0\n         if (weight1 \u003d\u003d weight2) {\n           // If they have same weight, just compare usage\n-          useToWeightRatio1 \u003d s1.getResourceUsage().getMemorySize();\n-          useToWeightRatio2 \u003d s2.getResourceUsage().getMemorySize();\n+          useToWeightRatio1 \u003d resourceUsage1.getMemorySize();\n+          useToWeightRatio2 \u003d resourceUsage2.getMemorySize();\n         } else {\n           // By setting useToWeightRatios to negative weights, we give the\n           // zero-weight one less priority, so the non-zero weight one will\n           // be given slots.\n           useToWeightRatio1 \u003d -weight1;\n           useToWeightRatio2 \u003d -weight2;\n         }\n       }\n \n       int res \u003d 0;\n       if (s1Needy \u0026\u0026 !s2Needy)\n         res \u003d -1;\n       else if (s2Needy \u0026\u0026 !s1Needy)\n         res \u003d 1;\n       else if (s1Needy \u0026\u0026 s2Needy)\n         res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n       else\n         // Neither schedulable is needy\n         res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n       if (res \u003d\u003d 0) {\n         // Apps are tied in fairness ratio. Break the tie by submit time and job\n         // name to get a deterministic ordering, which is useful for unit tests.\n         res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n         if (res \u003d\u003d 0)\n           res \u003d s1.getName().compareTo(s2.getName());\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      double minShareRatio1, minShareRatio2;\n      double useToWeightRatio1, useToWeightRatio2;\n      double weight1, weight2;\n      //Do not repeat the getResourceUsage calculation\n      Resource resourceUsage1 \u003d s1.getResourceUsage();\n      Resource resourceUsage2 \u003d s2.getResourceUsage();\n      Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s1.getMinShare(), s1.getDemand());\n      Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s2.getMinShare(), s2.getDemand());\n      boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          resourceUsage1, minShare1);\n      boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          resourceUsage2, minShare2);\n      minShareRatio1 \u003d (double) resourceUsage1.getMemorySize()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemorySize();\n      minShareRatio2 \u003d (double) resourceUsage2.getMemorySize()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemorySize();\n\n      weight1 \u003d s1.getWeights().getWeight(ResourceType.MEMORY);\n      weight2 \u003d s2.getWeights().getWeight(ResourceType.MEMORY);\n      if (weight1 \u003e 0.0 \u0026\u0026 weight2 \u003e 0.0) {\n        useToWeightRatio1 \u003d resourceUsage1.getMemorySize() / weight1;\n        useToWeightRatio2 \u003d resourceUsage2.getMemorySize() / weight2;\n      } else { // Either weight1 or weight2 equals to 0\n        if (weight1 \u003d\u003d weight2) {\n          // If they have same weight, just compare usage\n          useToWeightRatio1 \u003d resourceUsage1.getMemorySize();\n          useToWeightRatio2 \u003d resourceUsage2.getMemorySize();\n        } else {\n          // By setting useToWeightRatios to negative weights, we give the\n          // zero-weight one less priority, so the non-zero weight one will\n          // be given slots.\n          useToWeightRatio1 \u003d -weight1;\n          useToWeightRatio2 \u003d -weight2;\n        }\n      }\n\n      int res \u003d 0;\n      if (s1Needy \u0026\u0026 !s2Needy)\n        res \u003d -1;\n      else if (s2Needy \u0026\u0026 !s1Needy)\n        res \u003d 1;\n      else if (s1Needy \u0026\u0026 s2Needy)\n        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n      else\n        // Neither schedulable is needy\n        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0)\n          res \u003d s1.getName().compareTo(s2.getName());\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java",
      "extendedDetails": {}
    },
    "4df8ed63ed93f2542e4b48f521b0cc6624ab59c1": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4743. FairSharePolicy breaks TimSort assumption. (Zephyr Guo and Yufei Gu via kasha)\n",
      "commitDate": "27/10/16 5:45 PM",
      "commitName": "4df8ed63ed93f2542e4b48f521b0cc6624ab59c1",
      "commitAuthor": "Karthik Kambatla",
      "commitDateOld": "17/06/16 10:24 PM",
      "commitNameOld": "20f2799938c5cad59f59617cdb0f86e137c3c2c0",
      "commitAuthorOld": "Karthik Kambatla",
      "daysBetweenCommits": 131.81,
      "commitsBetweenForRepo": 1049,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,55 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n       double minShareRatio1, minShareRatio2;\n       double useToWeightRatio1, useToWeightRatio2;\n+      double weight1, weight2;\n       Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n           s1.getMinShare(), s1.getDemand());\n       Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n           s2.getMinShare(), s2.getDemand());\n       boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n           s1.getResourceUsage(), minShare1);\n       boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n           s2.getResourceUsage(), minShare2);\n       minShareRatio1 \u003d (double) s1.getResourceUsage().getMemorySize()\n           / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemorySize();\n       minShareRatio2 \u003d (double) s2.getResourceUsage().getMemorySize()\n           / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemorySize();\n-      useToWeightRatio1 \u003d s1.getResourceUsage().getMemorySize() /\n-          s1.getWeights().getWeight(ResourceType.MEMORY);\n-      useToWeightRatio2 \u003d s2.getResourceUsage().getMemorySize() /\n-          s2.getWeights().getWeight(ResourceType.MEMORY);\n+\n+      weight1 \u003d s1.getWeights().getWeight(ResourceType.MEMORY);\n+      weight2 \u003d s2.getWeights().getWeight(ResourceType.MEMORY);\n+      if (weight1 \u003e 0.0 \u0026\u0026 weight2 \u003e 0.0) {\n+        useToWeightRatio1 \u003d s1.getResourceUsage().getMemorySize() / weight1;\n+        useToWeightRatio2 \u003d s2.getResourceUsage().getMemorySize() / weight2;\n+      } else { // Either weight1 or weight2 equals to 0\n+        if (weight1 \u003d\u003d weight2) {\n+          // If they have same weight, just compare usage\n+          useToWeightRatio1 \u003d s1.getResourceUsage().getMemorySize();\n+          useToWeightRatio2 \u003d s2.getResourceUsage().getMemorySize();\n+        } else {\n+          // By setting useToWeightRatios to negative weights, we give the\n+          // zero-weight one less priority, so the non-zero weight one will\n+          // be given slots.\n+          useToWeightRatio1 \u003d -weight1;\n+          useToWeightRatio2 \u003d -weight2;\n+        }\n+      }\n+\n       int res \u003d 0;\n       if (s1Needy \u0026\u0026 !s2Needy)\n         res \u003d -1;\n       else if (s2Needy \u0026\u0026 !s1Needy)\n         res \u003d 1;\n       else if (s1Needy \u0026\u0026 s2Needy)\n         res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n       else\n         // Neither schedulable is needy\n         res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n       if (res \u003d\u003d 0) {\n         // Apps are tied in fairness ratio. Break the tie by submit time and job\n         // name to get a deterministic ordering, which is useful for unit tests.\n         res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n         if (res \u003d\u003d 0)\n           res \u003d s1.getName().compareTo(s2.getName());\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      double minShareRatio1, minShareRatio2;\n      double useToWeightRatio1, useToWeightRatio2;\n      double weight1, weight2;\n      Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s1.getMinShare(), s1.getDemand());\n      Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s2.getMinShare(), s2.getDemand());\n      boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          s1.getResourceUsage(), minShare1);\n      boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          s2.getResourceUsage(), minShare2);\n      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemorySize()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemorySize();\n      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemorySize()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemorySize();\n\n      weight1 \u003d s1.getWeights().getWeight(ResourceType.MEMORY);\n      weight2 \u003d s2.getWeights().getWeight(ResourceType.MEMORY);\n      if (weight1 \u003e 0.0 \u0026\u0026 weight2 \u003e 0.0) {\n        useToWeightRatio1 \u003d s1.getResourceUsage().getMemorySize() / weight1;\n        useToWeightRatio2 \u003d s2.getResourceUsage().getMemorySize() / weight2;\n      } else { // Either weight1 or weight2 equals to 0\n        if (weight1 \u003d\u003d weight2) {\n          // If they have same weight, just compare usage\n          useToWeightRatio1 \u003d s1.getResourceUsage().getMemorySize();\n          useToWeightRatio2 \u003d s2.getResourceUsage().getMemorySize();\n        } else {\n          // By setting useToWeightRatios to negative weights, we give the\n          // zero-weight one less priority, so the non-zero weight one will\n          // be given slots.\n          useToWeightRatio1 \u003d -weight1;\n          useToWeightRatio2 \u003d -weight2;\n        }\n      }\n\n      int res \u003d 0;\n      if (s1Needy \u0026\u0026 !s2Needy)\n        res \u003d -1;\n      else if (s2Needy \u0026\u0026 !s1Needy)\n        res \u003d 1;\n      else if (s1Needy \u0026\u0026 s2Needy)\n        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n      else\n        // Neither schedulable is needy\n        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0)\n          res \u003d s1.getName().compareTo(s2.getName());\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java",
      "extendedDetails": {}
    },
    "42f90ab885d9693fcc1e52f9637f7de4111110ae": {
      "type": "Ybodychange",
      "commitMessage": "YARN-4844. Add getMemorySize/getVirtualCoresSize to o.a.h.y.api.records.Resource. Contributed by Wangda Tan.\n",
      "commitDate": "29/05/16 8:54 AM",
      "commitName": "42f90ab885d9693fcc1e52f9637f7de4111110ae",
      "commitAuthor": "Varun Vasudev",
      "commitDateOld": "14/07/15 12:23 AM",
      "commitNameOld": "ac94ba3e185115b83351e35c610c2b8ff91b1ebc",
      "commitAuthorOld": "Arun Suresh",
      "daysBetweenCommits": 320.35,
      "commitsBetweenForRepo": 2116,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,38 +1,38 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n       double minShareRatio1, minShareRatio2;\n       double useToWeightRatio1, useToWeightRatio2;\n       Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n           s1.getMinShare(), s1.getDemand());\n       Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n           s2.getMinShare(), s2.getDemand());\n       boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n           s1.getResourceUsage(), minShare1);\n       boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n           s2.getResourceUsage(), minShare2);\n-      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory()\n-          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemory();\n-      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory()\n-          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemory();\n-      useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() /\n+      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemorySize()\n+          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemorySize();\n+      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemorySize()\n+          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemorySize();\n+      useToWeightRatio1 \u003d s1.getResourceUsage().getMemorySize() /\n           s1.getWeights().getWeight(ResourceType.MEMORY);\n-      useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() /\n+      useToWeightRatio2 \u003d s2.getResourceUsage().getMemorySize() /\n           s2.getWeights().getWeight(ResourceType.MEMORY);\n       int res \u003d 0;\n       if (s1Needy \u0026\u0026 !s2Needy)\n         res \u003d -1;\n       else if (s2Needy \u0026\u0026 !s1Needy)\n         res \u003d 1;\n       else if (s1Needy \u0026\u0026 s2Needy)\n         res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n       else\n         // Neither schedulable is needy\n         res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n       if (res \u003d\u003d 0) {\n         // Apps are tied in fairness ratio. Break the tie by submit time and job\n         // name to get a deterministic ordering, which is useful for unit tests.\n         res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n         if (res \u003d\u003d 0)\n           res \u003d s1.getName().compareTo(s2.getName());\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      double minShareRatio1, minShareRatio2;\n      double useToWeightRatio1, useToWeightRatio2;\n      Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s1.getMinShare(), s1.getDemand());\n      Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s2.getMinShare(), s2.getDemand());\n      boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          s1.getResourceUsage(), minShare1);\n      boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          s2.getResourceUsage(), minShare2);\n      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemorySize()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemorySize();\n      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemorySize()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemorySize();\n      useToWeightRatio1 \u003d s1.getResourceUsage().getMemorySize() /\n          s1.getWeights().getWeight(ResourceType.MEMORY);\n      useToWeightRatio2 \u003d s2.getResourceUsage().getMemorySize() /\n          s2.getWeights().getWeight(ResourceType.MEMORY);\n      int res \u003d 0;\n      if (s1Needy \u0026\u0026 !s2Needy)\n        res \u003d -1;\n      else if (s2Needy \u0026\u0026 !s1Needy)\n        res \u003d 1;\n      else if (s1Needy \u0026\u0026 s2Needy)\n        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n      else\n        // Neither schedulable is needy\n        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0)\n          res \u003d s1.getName().compareTo(s2.getName());\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java",
      "extendedDetails": {}
    },
    "7c71a3b876f18510fd10a0b08bf27f83ac3aa389": {
      "type": "Ybodychange",
      "commitMessage": "YARN-2323. FairShareComparator creates too many Resource objects (Hong Zhiguo via Sandy Ryza)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1612187 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "20/07/14 10:00 PM",
      "commitName": "7c71a3b876f18510fd10a0b08bf27f83ac3aa389",
      "commitAuthor": "Sanford Ryza",
      "commitDateOld": "02/06/14 5:56 PM",
      "commitNameOld": "16caa3fd18424a67fc01b1ae3a8fcdbc99c8cbc4",
      "commitAuthorOld": "Sanford Ryza",
      "daysBetweenCommits": 48.17,
      "commitsBetweenForRepo": 311,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,39 +1,38 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n       double minShareRatio1, minShareRatio2;\n       double useToWeightRatio1, useToWeightRatio2;\n       Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n           s1.getMinShare(), s1.getDemand());\n       Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n           s2.getMinShare(), s2.getDemand());\n       boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n           s1.getResourceUsage(), minShare1);\n       boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n           s2.getResourceUsage(), minShare2);\n-      Resource one \u003d Resources.createResource(1);\n       minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory()\n-          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, one).getMemory();\n+          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemory();\n       minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory()\n-          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, one).getMemory();\n+          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemory();\n       useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() /\n           s1.getWeights().getWeight(ResourceType.MEMORY);\n       useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() /\n           s2.getWeights().getWeight(ResourceType.MEMORY);\n       int res \u003d 0;\n       if (s1Needy \u0026\u0026 !s2Needy)\n         res \u003d -1;\n       else if (s2Needy \u0026\u0026 !s1Needy)\n         res \u003d 1;\n       else if (s1Needy \u0026\u0026 s2Needy)\n         res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n       else\n         // Neither schedulable is needy\n         res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n       if (res \u003d\u003d 0) {\n         // Apps are tied in fairness ratio. Break the tie by submit time and job\n         // name to get a deterministic ordering, which is useful for unit tests.\n         res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n         if (res \u003d\u003d 0)\n           res \u003d s1.getName().compareTo(s2.getName());\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      double minShareRatio1, minShareRatio2;\n      double useToWeightRatio1, useToWeightRatio2;\n      Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s1.getMinShare(), s1.getDemand());\n      Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s2.getMinShare(), s2.getDemand());\n      boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          s1.getResourceUsage(), minShare1);\n      boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          s2.getResourceUsage(), minShare2);\n      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, ONE).getMemory();\n      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, ONE).getMemory();\n      useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() /\n          s1.getWeights().getWeight(ResourceType.MEMORY);\n      useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() /\n          s2.getWeights().getWeight(ResourceType.MEMORY);\n      int res \u003d 0;\n      if (s1Needy \u0026\u0026 !s2Needy)\n        res \u003d -1;\n      else if (s2Needy \u0026\u0026 !s1Needy)\n        res \u003d 1;\n      else if (s1Needy \u0026\u0026 s2Needy)\n        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n      else\n        // Neither schedulable is needy\n        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0)\n          res \u003d s1.getName().compareTo(s2.getName());\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java",
      "extendedDetails": {}
    },
    "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650": {
      "type": "Ybodychange",
      "commitMessage": "YARN-326. Add multi-resource scheduling to the fair scheduler. (sandyr via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1489070 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "03/06/13 10:33 AM",
      "commitName": "c1b635ed4826b0f9c8574d262dfeb13fa5ceb650",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "09/05/13 2:47 PM",
      "commitNameOld": "c7bfd17ad1cbfdb411bdf26572084efc2fb8dee0",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 24.82,
      "commitsBetweenForRepo": 130,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,37 +1,39 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n       double minShareRatio1, minShareRatio2;\n       double useToWeightRatio1, useToWeightRatio2;\n       Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n           s1.getMinShare(), s1.getDemand());\n       Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n           s2.getMinShare(), s2.getDemand());\n       boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n           s1.getResourceUsage(), minShare1);\n       boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n           s2.getResourceUsage(), minShare2);\n       Resource one \u003d Resources.createResource(1);\n       minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory()\n           / Resources.max(RESOURCE_CALCULATOR, null, minShare1, one).getMemory();\n       minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory()\n           / Resources.max(RESOURCE_CALCULATOR, null, minShare2, one).getMemory();\n-      useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() / s1.getWeight();\n-      useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() / s2.getWeight();\n+      useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() /\n+          s1.getWeights().getWeight(ResourceType.MEMORY);\n+      useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() /\n+          s2.getWeights().getWeight(ResourceType.MEMORY);\n       int res \u003d 0;\n       if (s1Needy \u0026\u0026 !s2Needy)\n         res \u003d -1;\n       else if (s2Needy \u0026\u0026 !s1Needy)\n         res \u003d 1;\n       else if (s1Needy \u0026\u0026 s2Needy)\n         res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n       else\n         // Neither schedulable is needy\n         res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n       if (res \u003d\u003d 0) {\n         // Apps are tied in fairness ratio. Break the tie by submit time and job\n         // name to get a deterministic ordering, which is useful for unit tests.\n         res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n         if (res \u003d\u003d 0)\n           res \u003d s1.getName().compareTo(s2.getName());\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      double minShareRatio1, minShareRatio2;\n      double useToWeightRatio1, useToWeightRatio2;\n      Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s1.getMinShare(), s1.getDemand());\n      Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s2.getMinShare(), s2.getDemand());\n      boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          s1.getResourceUsage(), minShare1);\n      boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          s2.getResourceUsage(), minShare2);\n      Resource one \u003d Resources.createResource(1);\n      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, one).getMemory();\n      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, one).getMemory();\n      useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() /\n          s1.getWeights().getWeight(ResourceType.MEMORY);\n      useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() /\n          s2.getWeights().getWeight(ResourceType.MEMORY);\n      int res \u003d 0;\n      if (s1Needy \u0026\u0026 !s2Needy)\n        res \u003d -1;\n      else if (s2Needy \u0026\u0026 !s1Needy)\n        res \u003d 1;\n      else if (s1Needy \u0026\u0026 s2Needy)\n        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n      else\n        // Neither schedulable is needy\n        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0)\n          res \u003d s1.getName().compareTo(s2.getName());\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java",
      "extendedDetails": {}
    },
    "a43c344eee888f2a2488c8c9dca7e25a2cce10bf": {
      "type": "Ybodychange",
      "commitMessage": "YARN-595. Refactor fair scheduler to use common Resources. Contributed by Sandy Ryza.\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1475670 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/04/13 1:33 AM",
      "commitName": "a43c344eee888f2a2488c8c9dca7e25a2cce10bf",
      "commitAuthor": "Thomas White",
      "commitDateOld": "18/04/13 11:11 AM",
      "commitNameOld": "df55edd5dec9c944a6c38f08d6f1f0fdb901c880",
      "commitAuthorOld": "Alejandro Abdelnur",
      "daysBetweenCommits": 6.6,
      "commitsBetweenForRepo": 37,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,33 +1,37 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n       double minShareRatio1, minShareRatio2;\n       double useToWeightRatio1, useToWeightRatio2;\n-      Resource minShare1 \u003d Resources.min(s1.getMinShare(), s1.getDemand());\n-      Resource minShare2 \u003d Resources.min(s2.getMinShare(), s2.getDemand());\n-      boolean s1Needy \u003d Resources.lessThan(s1.getResourceUsage(), minShare1);\n-      boolean s2Needy \u003d Resources.lessThan(s2.getResourceUsage(), minShare2);\n+      Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n+          s1.getMinShare(), s1.getDemand());\n+      Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n+          s2.getMinShare(), s2.getDemand());\n+      boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n+          s1.getResourceUsage(), minShare1);\n+      boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n+          s2.getResourceUsage(), minShare2);\n       Resource one \u003d Resources.createResource(1);\n       minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory()\n-          / Resources.max(minShare1, one).getMemory();\n+          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, one).getMemory();\n       minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory()\n-          / Resources.max(minShare2, one).getMemory();\n+          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, one).getMemory();\n       useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() / s1.getWeight();\n       useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() / s2.getWeight();\n       int res \u003d 0;\n       if (s1Needy \u0026\u0026 !s2Needy)\n         res \u003d -1;\n       else if (s2Needy \u0026\u0026 !s1Needy)\n         res \u003d 1;\n       else if (s1Needy \u0026\u0026 s2Needy)\n         res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n       else\n         // Neither schedulable is needy\n         res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n       if (res \u003d\u003d 0) {\n         // Apps are tied in fairness ratio. Break the tie by submit time and job\n         // name to get a deterministic ordering, which is useful for unit tests.\n         res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n         if (res \u003d\u003d 0)\n           res \u003d s1.getName().compareTo(s2.getName());\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      double minShareRatio1, minShareRatio2;\n      double useToWeightRatio1, useToWeightRatio2;\n      Resource minShare1 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s1.getMinShare(), s1.getDemand());\n      Resource minShare2 \u003d Resources.min(RESOURCE_CALCULATOR, null,\n          s2.getMinShare(), s2.getDemand());\n      boolean s1Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          s1.getResourceUsage(), minShare1);\n      boolean s2Needy \u003d Resources.lessThan(RESOURCE_CALCULATOR, null,\n          s2.getResourceUsage(), minShare2);\n      Resource one \u003d Resources.createResource(1);\n      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare1, one).getMemory();\n      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory()\n          / Resources.max(RESOURCE_CALCULATOR, null, minShare2, one).getMemory();\n      useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() / s1.getWeight();\n      useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() / s2.getWeight();\n      int res \u003d 0;\n      if (s1Needy \u0026\u0026 !s2Needy)\n        res \u003d -1;\n      else if (s2Needy \u0026\u0026 !s1Needy)\n        res \u003d 1;\n      else if (s1Needy \u0026\u0026 s2Needy)\n        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n      else\n        // Neither schedulable is needy\n        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0)\n          res \u003d s1.getName().compareTo(s2.getName());\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java",
      "extendedDetails": {}
    },
    "df55edd5dec9c944a6c38f08d6f1f0fdb901c880": {
      "type": "Yfilerename",
      "commitMessage": "YARN-482. FS: Extend SchedulingMode to intermediate queues. (kkambatl via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1469506 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "18/04/13 11:11 AM",
      "commitName": "df55edd5dec9c944a6c38f08d6f1f0fdb901c880",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "18/04/13 10:49 AM",
      "commitNameOld": "d219c904d32641c70f80f5d33c99cc81c79cf055",
      "commitAuthorOld": "Vinod Kumar Vavilapalli",
      "daysBetweenCommits": 0.02,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      double minShareRatio1, minShareRatio2;\n      double useToWeightRatio1, useToWeightRatio2;\n      Resource minShare1 \u003d Resources.min(s1.getMinShare(), s1.getDemand());\n      Resource minShare2 \u003d Resources.min(s2.getMinShare(), s2.getDemand());\n      boolean s1Needy \u003d Resources.lessThan(s1.getResourceUsage(), minShare1);\n      boolean s2Needy \u003d Resources.lessThan(s2.getResourceUsage(), minShare2);\n      Resource one \u003d Resources.createResource(1);\n      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory()\n          / Resources.max(minShare1, one).getMemory();\n      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory()\n          / Resources.max(minShare2, one).getMemory();\n      useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() / s1.getWeight();\n      useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() / s2.getWeight();\n      int res \u003d 0;\n      if (s1Needy \u0026\u0026 !s2Needy)\n        res \u003d -1;\n      else if (s2Needy \u0026\u0026 !s1Needy)\n        res \u003d 1;\n      else if (s1Needy \u0026\u0026 s2Needy)\n        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n      else\n        // Neither schedulable is needy\n        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0)\n          res \u003d s1.getName().compareTo(s2.getName());\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/modes/FairSchedulingMode.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/policies/FairSharePolicy.java"
      }
    },
    "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3": {
      "type": "Yfilerename",
      "commitMessage": "YARN-469. Make scheduling mode in FS pluggable. (kkambatl via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1460961 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "25/03/13 8:25 PM",
      "commitName": "e74d1f0435c2bcdfae2c26f6c340a5a487d20aa3",
      "commitAuthor": "Alejandro Abdelnur",
      "commitDateOld": "25/03/13 7:34 PM",
      "commitNameOld": "2aed48a67f408c290e90c83af9f76165d695f91a",
      "commitAuthorOld": "Bikas Saha",
      "daysBetweenCommits": 0.04,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,32 +1,33 @@\n     public int compare(Schedulable s1, Schedulable s2) {\n       double minShareRatio1, minShareRatio2;\n       double useToWeightRatio1, useToWeightRatio2;\n       Resource minShare1 \u003d Resources.min(s1.getMinShare(), s1.getDemand());\n       Resource minShare2 \u003d Resources.min(s2.getMinShare(), s2.getDemand());\n       boolean s1Needy \u003d Resources.lessThan(s1.getResourceUsage(), minShare1);\n       boolean s2Needy \u003d Resources.lessThan(s2.getResourceUsage(), minShare2);\n       Resource one \u003d Resources.createResource(1);\n-      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory() /\n-          Resources.max(minShare1, one).getMemory();\n-      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory() /\n-          Resources.max(minShare2, one).getMemory();\n+      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory()\n+          / Resources.max(minShare1, one).getMemory();\n+      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory()\n+          / Resources.max(minShare2, one).getMemory();\n       useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() / s1.getWeight();\n       useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() / s2.getWeight();\n       int res \u003d 0;\n       if (s1Needy \u0026\u0026 !s2Needy)\n         res \u003d -1;\n       else if (s2Needy \u0026\u0026 !s1Needy)\n         res \u003d 1;\n       else if (s1Needy \u0026\u0026 s2Needy)\n         res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n-      else // Neither schedulable is needy\n+      else\n+        // Neither schedulable is needy\n         res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n       if (res \u003d\u003d 0) {\n         // Apps are tied in fairness ratio. Break the tie by submit time and job\n         // name to get a deterministic ordering, which is useful for unit tests.\n         res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n         if (res \u003d\u003d 0)\n           res \u003d s1.getName().compareTo(s2.getName());\n       }\n       return res;\n     }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      double minShareRatio1, minShareRatio2;\n      double useToWeightRatio1, useToWeightRatio2;\n      Resource minShare1 \u003d Resources.min(s1.getMinShare(), s1.getDemand());\n      Resource minShare2 \u003d Resources.min(s2.getMinShare(), s2.getDemand());\n      boolean s1Needy \u003d Resources.lessThan(s1.getResourceUsage(), minShare1);\n      boolean s2Needy \u003d Resources.lessThan(s2.getResourceUsage(), minShare2);\n      Resource one \u003d Resources.createResource(1);\n      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory()\n          / Resources.max(minShare1, one).getMemory();\n      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory()\n          / Resources.max(minShare2, one).getMemory();\n      useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() / s1.getWeight();\n      useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() / s2.getWeight();\n      int res \u003d 0;\n      if (s1Needy \u0026\u0026 !s2Needy)\n        res \u003d -1;\n      else if (s2Needy \u0026\u0026 !s1Needy)\n        res \u003d 1;\n      else if (s1Needy \u0026\u0026 s2Needy)\n        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n      else\n        // Neither schedulable is needy\n        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0)\n          res \u003d s1.getName().compareTo(s2.getName());\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/modes/FairSchedulingMode.java",
      "extendedDetails": {
        "oldPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/SchedulingAlgorithms.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/modes/FairSchedulingMode.java"
      }
    },
    "e1fdf62123625e4ba399af02f8aad500637d29d1": {
      "type": "Yfilerename",
      "commitMessage": "YARN-1. Promote YARN to be a sub-project of Apache Hadoop.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1370666 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "07/08/12 10:22 PM",
      "commitName": "e1fdf62123625e4ba399af02f8aad500637d29d1",
      "commitAuthor": "Arun Murthy",
      "commitDateOld": "07/08/12 7:53 PM",
      "commitNameOld": "34554d1e11ee1d5b564d7d9ed3e6d55931d72749",
      "commitAuthorOld": "Aaron Myers",
      "daysBetweenCommits": 0.1,
      "commitsBetweenForRepo": 1,
      "commitsBetweenForFile": 1,
      "diff": "",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      double minShareRatio1, minShareRatio2;\n      double useToWeightRatio1, useToWeightRatio2;\n      Resource minShare1 \u003d Resources.min(s1.getMinShare(), s1.getDemand());\n      Resource minShare2 \u003d Resources.min(s2.getMinShare(), s2.getDemand());\n      boolean s1Needy \u003d Resources.lessThan(s1.getResourceUsage(), minShare1);\n      boolean s2Needy \u003d Resources.lessThan(s2.getResourceUsage(), minShare2);\n      Resource one \u003d Resources.createResource(1);\n      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory() /\n          Resources.max(minShare1, one).getMemory();\n      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory() /\n          Resources.max(minShare2, one).getMemory();\n      useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() / s1.getWeight();\n      useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() / s2.getWeight();\n      int res \u003d 0;\n      if (s1Needy \u0026\u0026 !s2Needy)\n        res \u003d -1;\n      else if (s2Needy \u0026\u0026 !s1Needy)\n        res \u003d 1;\n      else if (s1Needy \u0026\u0026 s2Needy)\n        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n      else // Neither schedulable is needy\n        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0)\n          res \u003d s1.getName().compareTo(s2.getName());\n      }\n      return res;\n    }",
      "path": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/SchedulingAlgorithms.java",
      "extendedDetails": {
        "oldPath": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/SchedulingAlgorithms.java",
        "newPath": "hadoop-yarn-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/SchedulingAlgorithms.java"
      }
    },
    "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c": {
      "type": "Yintroduced",
      "commitMessage": "MAPREDUCE-3451. Port Fair Scheduler to MR2 (pwendell via tucu)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/common/trunk@1361020 13f79535-47bb-0310-9956-ffa450edef68\n",
      "commitDate": "12/07/12 5:43 PM",
      "commitName": "1ef64e64c05ae5318cd4cb47d03a0494d742fb7c",
      "commitAuthor": "Alejandro Abdelnur",
      "diff": "@@ -0,0 +1,32 @@\n+    public int compare(Schedulable s1, Schedulable s2) {\n+      double minShareRatio1, minShareRatio2;\n+      double useToWeightRatio1, useToWeightRatio2;\n+      Resource minShare1 \u003d Resources.min(s1.getMinShare(), s1.getDemand());\n+      Resource minShare2 \u003d Resources.min(s2.getMinShare(), s2.getDemand());\n+      boolean s1Needy \u003d Resources.lessThan(s1.getResourceUsage(), minShare1);\n+      boolean s2Needy \u003d Resources.lessThan(s2.getResourceUsage(), minShare2);\n+      Resource one \u003d Resources.createResource(1);\n+      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory() /\n+          Resources.max(minShare1, one).getMemory();\n+      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory() /\n+          Resources.max(minShare2, one).getMemory();\n+      useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() / s1.getWeight();\n+      useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() / s2.getWeight();\n+      int res \u003d 0;\n+      if (s1Needy \u0026\u0026 !s2Needy)\n+        res \u003d -1;\n+      else if (s2Needy \u0026\u0026 !s1Needy)\n+        res \u003d 1;\n+      else if (s1Needy \u0026\u0026 s2Needy)\n+        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n+      else // Neither schedulable is needy\n+        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n+      if (res \u003d\u003d 0) {\n+        // Apps are tied in fairness ratio. Break the tie by submit time and job\n+        // name to get a deterministic ordering, which is useful for unit tests.\n+        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n+        if (res \u003d\u003d 0)\n+          res \u003d s1.getName().compareTo(s2.getName());\n+      }\n+      return res;\n+    }\n\\ No newline at end of file\n",
      "actualSource": "    public int compare(Schedulable s1, Schedulable s2) {\n      double minShareRatio1, minShareRatio2;\n      double useToWeightRatio1, useToWeightRatio2;\n      Resource minShare1 \u003d Resources.min(s1.getMinShare(), s1.getDemand());\n      Resource minShare2 \u003d Resources.min(s2.getMinShare(), s2.getDemand());\n      boolean s1Needy \u003d Resources.lessThan(s1.getResourceUsage(), minShare1);\n      boolean s2Needy \u003d Resources.lessThan(s2.getResourceUsage(), minShare2);\n      Resource one \u003d Resources.createResource(1);\n      minShareRatio1 \u003d (double) s1.getResourceUsage().getMemory() /\n          Resources.max(minShare1, one).getMemory();\n      minShareRatio2 \u003d (double) s2.getResourceUsage().getMemory() /\n          Resources.max(minShare2, one).getMemory();\n      useToWeightRatio1 \u003d s1.getResourceUsage().getMemory() / s1.getWeight();\n      useToWeightRatio2 \u003d s2.getResourceUsage().getMemory() / s2.getWeight();\n      int res \u003d 0;\n      if (s1Needy \u0026\u0026 !s2Needy)\n        res \u003d -1;\n      else if (s2Needy \u0026\u0026 !s1Needy)\n        res \u003d 1;\n      else if (s1Needy \u0026\u0026 s2Needy)\n        res \u003d (int) Math.signum(minShareRatio1 - minShareRatio2);\n      else // Neither schedulable is needy\n        res \u003d (int) Math.signum(useToWeightRatio1 - useToWeightRatio2);\n      if (res \u003d\u003d 0) {\n        // Apps are tied in fairness ratio. Break the tie by submit time and job\n        // name to get a deterministic ordering, which is useful for unit tests.\n        res \u003d (int) Math.signum(s1.getStartTime() - s2.getStartTime());\n        if (res \u003d\u003d 0)\n          res \u003d s1.getName().compareTo(s2.getName());\n      }\n      return res;\n    }",
      "path": "hadoop-mapreduce-project/hadoop-yarn/hadoop-yarn-server/hadoop-yarn-server-resourcemanager/src/main/java/org/apache/hadoop/yarn/server/resourcemanager/scheduler/fair/SchedulingAlgorithms.java"
    }
  }
}