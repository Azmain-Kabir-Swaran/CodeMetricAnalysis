{
  "origin": "codeshovel",
  "repositoryName": "hadoop",
  "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/hadoop/.git",
  "startCommitName": "HEAD",
  "sourceFileName": "StripeReader.java",
  "functionName": "readStripe",
  "functionId": "readStripe",
  "sourceFilePath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/StripeReader.java",
  "functionStartLine": 330,
  "functionEndLine": 396,
  "numCommitsSeen": 19,
  "timeTaken": 1954,
  "changeHistory": [
    "08bb6c49a5aec32b7d9f29238560f947420405d6",
    "734d54c1a8950446e68098f62d8964e02ecc2890"
  ],
  "changeHistoryShort": {
    "08bb6c49a5aec32b7d9f29238560f947420405d6": "Ybodychange",
    "734d54c1a8950446e68098f62d8964e02ecc2890": "Ymultichange(Ymovefromfile,Ybodychange)"
  },
  "changeHistoryDetails": {
    "08bb6c49a5aec32b7d9f29238560f947420405d6": {
      "type": "Ybodychange",
      "commitMessage": "HDFS-13926. ThreadLocal aggregations for FileSystem.Statistics are incorrect with striped reads.\nContributed by Xiao Chen, Hrishikesh Gadre.\n\nSigned-off-by: Xiao Chen \u003cxiao@apache.org\u003e\n",
      "commitDate": "08/10/18 8:31 PM",
      "commitName": "08bb6c49a5aec32b7d9f29238560f947420405d6",
      "commitAuthor": "Hrishikesh Gadre",
      "commitDateOld": "26/04/18 1:54 PM",
      "commitNameOld": "a8e428b2dc0883184b43cb776d5c7196aaa3bf56",
      "commitAuthorOld": "Lei Xu",
      "daysBetweenCommits": 165.28,
      "commitsBetweenForRepo": 1297,
      "commitsBetweenForFile": 1,
      "diff": "@@ -1,66 +1,67 @@\n   void readStripe() throws IOException {\n     for (int i \u003d 0; i \u003c dataBlkNum; i++) {\n       if (alignedStripe.chunks[i] !\u003d null \u0026\u0026\n           alignedStripe.chunks[i].state !\u003d StripingChunk.ALLZERO) {\n         if (!readChunk(targetBlocks[i], i)) {\n           alignedStripe.missingChunksNum++;\n         }\n       }\n     }\n     // There are missing block locations at this stage. Thus we need to read\n     // the full stripe and one more parity block.\n     if (alignedStripe.missingChunksNum \u003e 0) {\n       checkMissingBlocks();\n       readDataForDecoding();\n       // read parity chunks\n       readParityChunks(alignedStripe.missingChunksNum);\n     }\n     // TODO: for a full stripe we can start reading (dataBlkNum + 1) chunks\n \n     // Input buffers for potential decode operation, which remains null until\n     // first read failure\n     while (!futures.isEmpty()) {\n       try {\n         StripingChunkReadResult r \u003d StripedBlockUtil\n             .getNextCompletedStripedRead(service, futures, 0);\n+        dfsStripedInputStream.updateReadStats(r.getReadStats());\n         if (DFSClient.LOG.isDebugEnabled()) {\n           DFSClient.LOG.debug(\"Read task returned: \" + r + \", for stripe \"\n               + alignedStripe);\n         }\n         StripingChunk returnedChunk \u003d alignedStripe.chunks[r.index];\n         Preconditions.checkNotNull(returnedChunk);\n         Preconditions.checkState(returnedChunk.state \u003d\u003d StripingChunk.PENDING);\n \n         if (r.state \u003d\u003d StripingChunkReadResult.SUCCESSFUL) {\n           returnedChunk.state \u003d StripingChunk.FETCHED;\n           alignedStripe.fetchedChunksNum++;\n           updateState4SuccessRead(r);\n           if (alignedStripe.fetchedChunksNum \u003d\u003d dataBlkNum) {\n             clearFutures();\n             break;\n           }\n         } else {\n           returnedChunk.state \u003d StripingChunk.MISSING;\n           // close the corresponding reader\n           dfsStripedInputStream.closeReader(readerInfos[r.index]);\n \n           final int missing \u003d alignedStripe.missingChunksNum;\n           alignedStripe.missingChunksNum++;\n           checkMissingBlocks();\n \n           readDataForDecoding();\n           readParityChunks(alignedStripe.missingChunksNum - missing);\n         }\n       } catch (InterruptedException ie) {\n         String err \u003d \"Read request interrupted\";\n         DFSClient.LOG.error(err);\n         clearFutures();\n         // Don\u0027t decode if read interrupted\n         throw new InterruptedIOException(err);\n       }\n     }\n \n     if (alignedStripe.missingChunksNum \u003e 0) {\n       decode();\n     }\n   }\n\\ No newline at end of file\n",
      "actualSource": "  void readStripe() throws IOException {\n    for (int i \u003d 0; i \u003c dataBlkNum; i++) {\n      if (alignedStripe.chunks[i] !\u003d null \u0026\u0026\n          alignedStripe.chunks[i].state !\u003d StripingChunk.ALLZERO) {\n        if (!readChunk(targetBlocks[i], i)) {\n          alignedStripe.missingChunksNum++;\n        }\n      }\n    }\n    // There are missing block locations at this stage. Thus we need to read\n    // the full stripe and one more parity block.\n    if (alignedStripe.missingChunksNum \u003e 0) {\n      checkMissingBlocks();\n      readDataForDecoding();\n      // read parity chunks\n      readParityChunks(alignedStripe.missingChunksNum);\n    }\n    // TODO: for a full stripe we can start reading (dataBlkNum + 1) chunks\n\n    // Input buffers for potential decode operation, which remains null until\n    // first read failure\n    while (!futures.isEmpty()) {\n      try {\n        StripingChunkReadResult r \u003d StripedBlockUtil\n            .getNextCompletedStripedRead(service, futures, 0);\n        dfsStripedInputStream.updateReadStats(r.getReadStats());\n        if (DFSClient.LOG.isDebugEnabled()) {\n          DFSClient.LOG.debug(\"Read task returned: \" + r + \", for stripe \"\n              + alignedStripe);\n        }\n        StripingChunk returnedChunk \u003d alignedStripe.chunks[r.index];\n        Preconditions.checkNotNull(returnedChunk);\n        Preconditions.checkState(returnedChunk.state \u003d\u003d StripingChunk.PENDING);\n\n        if (r.state \u003d\u003d StripingChunkReadResult.SUCCESSFUL) {\n          returnedChunk.state \u003d StripingChunk.FETCHED;\n          alignedStripe.fetchedChunksNum++;\n          updateState4SuccessRead(r);\n          if (alignedStripe.fetchedChunksNum \u003d\u003d dataBlkNum) {\n            clearFutures();\n            break;\n          }\n        } else {\n          returnedChunk.state \u003d StripingChunk.MISSING;\n          // close the corresponding reader\n          dfsStripedInputStream.closeReader(readerInfos[r.index]);\n\n          final int missing \u003d alignedStripe.missingChunksNum;\n          alignedStripe.missingChunksNum++;\n          checkMissingBlocks();\n\n          readDataForDecoding();\n          readParityChunks(alignedStripe.missingChunksNum - missing);\n        }\n      } catch (InterruptedException ie) {\n        String err \u003d \"Read request interrupted\";\n        DFSClient.LOG.error(err);\n        clearFutures();\n        // Don\u0027t decode if read interrupted\n        throw new InterruptedIOException(err);\n      }\n    }\n\n    if (alignedStripe.missingChunksNum \u003e 0) {\n      decode();\n    }\n  }",
      "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/StripeReader.java",
      "extendedDetails": {}
    },
    "734d54c1a8950446e68098f62d8964e02ecc2890": {
      "type": "Ymultichange(Ymovefromfile,Ybodychange)",
      "commitMessage": "HDFS-10861. Refactor StripeReaders and use ECChunk version decode API. Contributed by Sammi Chen\n",
      "commitDate": "21/09/16 6:34 AM",
      "commitName": "734d54c1a8950446e68098f62d8964e02ecc2890",
      "commitAuthor": "Kai Zheng",
      "subchanges": [
        {
          "type": "Ymovefromfile",
          "commitMessage": "HDFS-10861. Refactor StripeReaders and use ECChunk version decode API. Contributed by Sammi Chen\n",
          "commitDate": "21/09/16 6:34 AM",
          "commitName": "734d54c1a8950446e68098f62d8964e02ecc2890",
          "commitAuthor": "Kai Zheng",
          "commitDateOld": "20/09/16 12:03 AM",
          "commitNameOld": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 1.27,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,66 @@\n-    void readStripe() throws IOException {\n-      for (int i \u003d 0; i \u003c dataBlkNum; i++) {\n-        if (alignedStripe.chunks[i] !\u003d null \u0026\u0026\n-            alignedStripe.chunks[i].state !\u003d StripingChunk.ALLZERO) {\n-          if (!readChunk(targetBlocks[i], i)) {\n-            alignedStripe.missingChunksNum++;\n-          }\n+  void readStripe() throws IOException {\n+    for (int i \u003d 0; i \u003c dataBlkNum; i++) {\n+      if (alignedStripe.chunks[i] !\u003d null \u0026\u0026\n+          alignedStripe.chunks[i].state !\u003d StripingChunk.ALLZERO) {\n+        if (!readChunk(targetBlocks[i], i)) {\n+          alignedStripe.missingChunksNum++;\n         }\n       }\n-      // There are missing block locations at this stage. Thus we need to read\n-      // the full stripe and one more parity block.\n-      if (alignedStripe.missingChunksNum \u003e 0) {\n-        checkMissingBlocks();\n-        readDataForDecoding();\n-        // read parity chunks\n-        readParityChunks(alignedStripe.missingChunksNum);\n-      }\n-      // TODO: for a full stripe we can start reading (dataBlkNum + 1) chunks\n+    }\n+    // There are missing block locations at this stage. Thus we need to read\n+    // the full stripe and one more parity block.\n+    if (alignedStripe.missingChunksNum \u003e 0) {\n+      checkMissingBlocks();\n+      readDataForDecoding();\n+      // read parity chunks\n+      readParityChunks(alignedStripe.missingChunksNum);\n+    }\n+    // TODO: for a full stripe we can start reading (dataBlkNum + 1) chunks\n \n-      // Input buffers for potential decode operation, which remains null until\n-      // first read failure\n-      while (!futures.isEmpty()) {\n-        try {\n-          StripingChunkReadResult r \u003d StripedBlockUtil\n-              .getNextCompletedStripedRead(service, futures, 0);\n-          if (DFSClient.LOG.isDebugEnabled()) {\n-            DFSClient.LOG.debug(\"Read task returned: \" + r + \", for stripe \"\n-                + alignedStripe);\n-          }\n-          StripingChunk returnedChunk \u003d alignedStripe.chunks[r.index];\n-          Preconditions.checkNotNull(returnedChunk);\n-          Preconditions.checkState(returnedChunk.state \u003d\u003d StripingChunk.PENDING);\n-\n-          if (r.state \u003d\u003d StripingChunkReadResult.SUCCESSFUL) {\n-            returnedChunk.state \u003d StripingChunk.FETCHED;\n-            alignedStripe.fetchedChunksNum++;\n-            updateState4SuccessRead(r);\n-            if (alignedStripe.fetchedChunksNum \u003d\u003d dataBlkNum) {\n-              clearFutures(futures.keySet());\n-              break;\n-            }\n-          } else {\n-            returnedChunk.state \u003d StripingChunk.MISSING;\n-            // close the corresponding reader\n-            closeReader(readerInfos[r.index]);\n-\n-            final int missing \u003d alignedStripe.missingChunksNum;\n-            alignedStripe.missingChunksNum++;\n-            checkMissingBlocks();\n-\n-            readDataForDecoding();\n-            readParityChunks(alignedStripe.missingChunksNum - missing);\n-          }\n-        } catch (InterruptedException ie) {\n-          String err \u003d \"Read request interrupted\";\n-          DFSClient.LOG.error(err);\n-          clearFutures(futures.keySet());\n-          // Don\u0027t decode if read interrupted\n-          throw new InterruptedIOException(err);\n+    // Input buffers for potential decode operation, which remains null until\n+    // first read failure\n+    while (!futures.isEmpty()) {\n+      try {\n+        StripingChunkReadResult r \u003d StripedBlockUtil\n+            .getNextCompletedStripedRead(service, futures, 0);\n+        if (DFSClient.LOG.isDebugEnabled()) {\n+          DFSClient.LOG.debug(\"Read task returned: \" + r + \", for stripe \"\n+              + alignedStripe);\n         }\n-      }\n+        StripingChunk returnedChunk \u003d alignedStripe.chunks[r.index];\n+        Preconditions.checkNotNull(returnedChunk);\n+        Preconditions.checkState(returnedChunk.state \u003d\u003d StripingChunk.PENDING);\n \n-      if (alignedStripe.missingChunksNum \u003e 0) {\n-        decode();\n+        if (r.state \u003d\u003d StripingChunkReadResult.SUCCESSFUL) {\n+          returnedChunk.state \u003d StripingChunk.FETCHED;\n+          alignedStripe.fetchedChunksNum++;\n+          updateState4SuccessRead(r);\n+          if (alignedStripe.fetchedChunksNum \u003d\u003d dataBlkNum) {\n+            clearFutures();\n+            break;\n+          }\n+        } else {\n+          returnedChunk.state \u003d StripingChunk.MISSING;\n+          // close the corresponding reader\n+          dfsStripedInputStream.closeReader(readerInfos[r.index]);\n+\n+          final int missing \u003d alignedStripe.missingChunksNum;\n+          alignedStripe.missingChunksNum++;\n+          checkMissingBlocks();\n+\n+          readDataForDecoding();\n+          readParityChunks(alignedStripe.missingChunksNum - missing);\n+        }\n+      } catch (InterruptedException ie) {\n+        String err \u003d \"Read request interrupted\";\n+        DFSClient.LOG.error(err);\n+        clearFutures();\n+        // Don\u0027t decode if read interrupted\n+        throw new InterruptedIOException(err);\n       }\n-    }\n\\ No newline at end of file\n+    }\n+\n+    if (alignedStripe.missingChunksNum \u003e 0) {\n+      decode();\n+    }\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  void readStripe() throws IOException {\n    for (int i \u003d 0; i \u003c dataBlkNum; i++) {\n      if (alignedStripe.chunks[i] !\u003d null \u0026\u0026\n          alignedStripe.chunks[i].state !\u003d StripingChunk.ALLZERO) {\n        if (!readChunk(targetBlocks[i], i)) {\n          alignedStripe.missingChunksNum++;\n        }\n      }\n    }\n    // There are missing block locations at this stage. Thus we need to read\n    // the full stripe and one more parity block.\n    if (alignedStripe.missingChunksNum \u003e 0) {\n      checkMissingBlocks();\n      readDataForDecoding();\n      // read parity chunks\n      readParityChunks(alignedStripe.missingChunksNum);\n    }\n    // TODO: for a full stripe we can start reading (dataBlkNum + 1) chunks\n\n    // Input buffers for potential decode operation, which remains null until\n    // first read failure\n    while (!futures.isEmpty()) {\n      try {\n        StripingChunkReadResult r \u003d StripedBlockUtil\n            .getNextCompletedStripedRead(service, futures, 0);\n        if (DFSClient.LOG.isDebugEnabled()) {\n          DFSClient.LOG.debug(\"Read task returned: \" + r + \", for stripe \"\n              + alignedStripe);\n        }\n        StripingChunk returnedChunk \u003d alignedStripe.chunks[r.index];\n        Preconditions.checkNotNull(returnedChunk);\n        Preconditions.checkState(returnedChunk.state \u003d\u003d StripingChunk.PENDING);\n\n        if (r.state \u003d\u003d StripingChunkReadResult.SUCCESSFUL) {\n          returnedChunk.state \u003d StripingChunk.FETCHED;\n          alignedStripe.fetchedChunksNum++;\n          updateState4SuccessRead(r);\n          if (alignedStripe.fetchedChunksNum \u003d\u003d dataBlkNum) {\n            clearFutures();\n            break;\n          }\n        } else {\n          returnedChunk.state \u003d StripingChunk.MISSING;\n          // close the corresponding reader\n          dfsStripedInputStream.closeReader(readerInfos[r.index]);\n\n          final int missing \u003d alignedStripe.missingChunksNum;\n          alignedStripe.missingChunksNum++;\n          checkMissingBlocks();\n\n          readDataForDecoding();\n          readParityChunks(alignedStripe.missingChunksNum - missing);\n        }\n      } catch (InterruptedException ie) {\n        String err \u003d \"Read request interrupted\";\n        DFSClient.LOG.error(err);\n        clearFutures();\n        // Don\u0027t decode if read interrupted\n        throw new InterruptedIOException(err);\n      }\n    }\n\n    if (alignedStripe.missingChunksNum \u003e 0) {\n      decode();\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/StripeReader.java",
          "extendedDetails": {
            "oldPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSStripedInputStream.java",
            "newPath": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/StripeReader.java",
            "oldMethodName": "readStripe",
            "newMethodName": "readStripe"
          }
        },
        {
          "type": "Ybodychange",
          "commitMessage": "HDFS-10861. Refactor StripeReaders and use ECChunk version decode API. Contributed by Sammi Chen\n",
          "commitDate": "21/09/16 6:34 AM",
          "commitName": "734d54c1a8950446e68098f62d8964e02ecc2890",
          "commitAuthor": "Kai Zheng",
          "commitDateOld": "20/09/16 12:03 AM",
          "commitNameOld": "2b66d9ec5bdaec7e6b278926fbb6f222c4e3afaa",
          "commitAuthorOld": "Jian He",
          "daysBetweenCommits": 1.27,
          "commitsBetweenForRepo": 1,
          "commitsBetweenForFile": 1,
          "diff": "@@ -1,66 +1,66 @@\n-    void readStripe() throws IOException {\n-      for (int i \u003d 0; i \u003c dataBlkNum; i++) {\n-        if (alignedStripe.chunks[i] !\u003d null \u0026\u0026\n-            alignedStripe.chunks[i].state !\u003d StripingChunk.ALLZERO) {\n-          if (!readChunk(targetBlocks[i], i)) {\n-            alignedStripe.missingChunksNum++;\n-          }\n+  void readStripe() throws IOException {\n+    for (int i \u003d 0; i \u003c dataBlkNum; i++) {\n+      if (alignedStripe.chunks[i] !\u003d null \u0026\u0026\n+          alignedStripe.chunks[i].state !\u003d StripingChunk.ALLZERO) {\n+        if (!readChunk(targetBlocks[i], i)) {\n+          alignedStripe.missingChunksNum++;\n         }\n       }\n-      // There are missing block locations at this stage. Thus we need to read\n-      // the full stripe and one more parity block.\n-      if (alignedStripe.missingChunksNum \u003e 0) {\n-        checkMissingBlocks();\n-        readDataForDecoding();\n-        // read parity chunks\n-        readParityChunks(alignedStripe.missingChunksNum);\n-      }\n-      // TODO: for a full stripe we can start reading (dataBlkNum + 1) chunks\n+    }\n+    // There are missing block locations at this stage. Thus we need to read\n+    // the full stripe and one more parity block.\n+    if (alignedStripe.missingChunksNum \u003e 0) {\n+      checkMissingBlocks();\n+      readDataForDecoding();\n+      // read parity chunks\n+      readParityChunks(alignedStripe.missingChunksNum);\n+    }\n+    // TODO: for a full stripe we can start reading (dataBlkNum + 1) chunks\n \n-      // Input buffers for potential decode operation, which remains null until\n-      // first read failure\n-      while (!futures.isEmpty()) {\n-        try {\n-          StripingChunkReadResult r \u003d StripedBlockUtil\n-              .getNextCompletedStripedRead(service, futures, 0);\n-          if (DFSClient.LOG.isDebugEnabled()) {\n-            DFSClient.LOG.debug(\"Read task returned: \" + r + \", for stripe \"\n-                + alignedStripe);\n-          }\n-          StripingChunk returnedChunk \u003d alignedStripe.chunks[r.index];\n-          Preconditions.checkNotNull(returnedChunk);\n-          Preconditions.checkState(returnedChunk.state \u003d\u003d StripingChunk.PENDING);\n-\n-          if (r.state \u003d\u003d StripingChunkReadResult.SUCCESSFUL) {\n-            returnedChunk.state \u003d StripingChunk.FETCHED;\n-            alignedStripe.fetchedChunksNum++;\n-            updateState4SuccessRead(r);\n-            if (alignedStripe.fetchedChunksNum \u003d\u003d dataBlkNum) {\n-              clearFutures(futures.keySet());\n-              break;\n-            }\n-          } else {\n-            returnedChunk.state \u003d StripingChunk.MISSING;\n-            // close the corresponding reader\n-            closeReader(readerInfos[r.index]);\n-\n-            final int missing \u003d alignedStripe.missingChunksNum;\n-            alignedStripe.missingChunksNum++;\n-            checkMissingBlocks();\n-\n-            readDataForDecoding();\n-            readParityChunks(alignedStripe.missingChunksNum - missing);\n-          }\n-        } catch (InterruptedException ie) {\n-          String err \u003d \"Read request interrupted\";\n-          DFSClient.LOG.error(err);\n-          clearFutures(futures.keySet());\n-          // Don\u0027t decode if read interrupted\n-          throw new InterruptedIOException(err);\n+    // Input buffers for potential decode operation, which remains null until\n+    // first read failure\n+    while (!futures.isEmpty()) {\n+      try {\n+        StripingChunkReadResult r \u003d StripedBlockUtil\n+            .getNextCompletedStripedRead(service, futures, 0);\n+        if (DFSClient.LOG.isDebugEnabled()) {\n+          DFSClient.LOG.debug(\"Read task returned: \" + r + \", for stripe \"\n+              + alignedStripe);\n         }\n-      }\n+        StripingChunk returnedChunk \u003d alignedStripe.chunks[r.index];\n+        Preconditions.checkNotNull(returnedChunk);\n+        Preconditions.checkState(returnedChunk.state \u003d\u003d StripingChunk.PENDING);\n \n-      if (alignedStripe.missingChunksNum \u003e 0) {\n-        decode();\n+        if (r.state \u003d\u003d StripingChunkReadResult.SUCCESSFUL) {\n+          returnedChunk.state \u003d StripingChunk.FETCHED;\n+          alignedStripe.fetchedChunksNum++;\n+          updateState4SuccessRead(r);\n+          if (alignedStripe.fetchedChunksNum \u003d\u003d dataBlkNum) {\n+            clearFutures();\n+            break;\n+          }\n+        } else {\n+          returnedChunk.state \u003d StripingChunk.MISSING;\n+          // close the corresponding reader\n+          dfsStripedInputStream.closeReader(readerInfos[r.index]);\n+\n+          final int missing \u003d alignedStripe.missingChunksNum;\n+          alignedStripe.missingChunksNum++;\n+          checkMissingBlocks();\n+\n+          readDataForDecoding();\n+          readParityChunks(alignedStripe.missingChunksNum - missing);\n+        }\n+      } catch (InterruptedException ie) {\n+        String err \u003d \"Read request interrupted\";\n+        DFSClient.LOG.error(err);\n+        clearFutures();\n+        // Don\u0027t decode if read interrupted\n+        throw new InterruptedIOException(err);\n       }\n-    }\n\\ No newline at end of file\n+    }\n+\n+    if (alignedStripe.missingChunksNum \u003e 0) {\n+      decode();\n+    }\n+  }\n\\ No newline at end of file\n",
          "actualSource": "  void readStripe() throws IOException {\n    for (int i \u003d 0; i \u003c dataBlkNum; i++) {\n      if (alignedStripe.chunks[i] !\u003d null \u0026\u0026\n          alignedStripe.chunks[i].state !\u003d StripingChunk.ALLZERO) {\n        if (!readChunk(targetBlocks[i], i)) {\n          alignedStripe.missingChunksNum++;\n        }\n      }\n    }\n    // There are missing block locations at this stage. Thus we need to read\n    // the full stripe and one more parity block.\n    if (alignedStripe.missingChunksNum \u003e 0) {\n      checkMissingBlocks();\n      readDataForDecoding();\n      // read parity chunks\n      readParityChunks(alignedStripe.missingChunksNum);\n    }\n    // TODO: for a full stripe we can start reading (dataBlkNum + 1) chunks\n\n    // Input buffers for potential decode operation, which remains null until\n    // first read failure\n    while (!futures.isEmpty()) {\n      try {\n        StripingChunkReadResult r \u003d StripedBlockUtil\n            .getNextCompletedStripedRead(service, futures, 0);\n        if (DFSClient.LOG.isDebugEnabled()) {\n          DFSClient.LOG.debug(\"Read task returned: \" + r + \", for stripe \"\n              + alignedStripe);\n        }\n        StripingChunk returnedChunk \u003d alignedStripe.chunks[r.index];\n        Preconditions.checkNotNull(returnedChunk);\n        Preconditions.checkState(returnedChunk.state \u003d\u003d StripingChunk.PENDING);\n\n        if (r.state \u003d\u003d StripingChunkReadResult.SUCCESSFUL) {\n          returnedChunk.state \u003d StripingChunk.FETCHED;\n          alignedStripe.fetchedChunksNum++;\n          updateState4SuccessRead(r);\n          if (alignedStripe.fetchedChunksNum \u003d\u003d dataBlkNum) {\n            clearFutures();\n            break;\n          }\n        } else {\n          returnedChunk.state \u003d StripingChunk.MISSING;\n          // close the corresponding reader\n          dfsStripedInputStream.closeReader(readerInfos[r.index]);\n\n          final int missing \u003d alignedStripe.missingChunksNum;\n          alignedStripe.missingChunksNum++;\n          checkMissingBlocks();\n\n          readDataForDecoding();\n          readParityChunks(alignedStripe.missingChunksNum - missing);\n        }\n      } catch (InterruptedException ie) {\n        String err \u003d \"Read request interrupted\";\n        DFSClient.LOG.error(err);\n        clearFutures();\n        // Don\u0027t decode if read interrupted\n        throw new InterruptedIOException(err);\n      }\n    }\n\n    if (alignedStripe.missingChunksNum \u003e 0) {\n      decode();\n    }\n  }",
          "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/StripeReader.java",
          "extendedDetails": {}
        }
      ]
    }
  }
}